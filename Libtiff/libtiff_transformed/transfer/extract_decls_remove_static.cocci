//
// Coccinelle script to extract function declarations and remove 'static' keyword
//
// Generated by: 3_5_extract_fn_declarations.py
// Purpose: Extract function declarations from definitions, remove static keyword
//
// This script:
// 1. Finds function definitions and declarations
// 2. Removes static keyword if present
// 3. Extracts signatures as declaration form (with semicolon)
// 4. Saves to definitions/ folder and consolidates to header file
//
// Usage: spatch --sp-file extract_declarations.cocci --dir <source_directory> --in-place

// Shared Python functions
@initialize:python@
@@
import os
import re

# Track processed functions to avoid duplicates
processed_functions = set()

def clean_function_signature(signature):
    """Clean up function signature formatting"""
    if not signature:
        return signature
    
    # Normalize all whitespace
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Remove all spaces around asterisks first
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Add space before asterisk groups
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Clean up double spaces
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

def extract_and_save_signature(signature, func_name):
    """Extract and save function signature to file (skip if already processed)"""
    if func_name in processed_functions:
        return
    
    processed_functions.add(func_name)
    os.makedirs("definitions", exist_ok=True)
    clean_signature = clean_function_signature(signature)
    filepath = "definitions/" + func_name + ".txt"
    with open(filepath, "w") as f:
        f.write(clean_signature + "\n")
    print("[EXTRACTED] " + func_name)


// ============================================================
// Rules for function: DecodeRowError
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_DecodeRowError_def@
type T;
identifier F = DecodeRowError;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_DecodeRowError_def@
F << remove_static_DecodeRowError_def.F;
T << remove_static_DecodeRowError_def.T;
P << remove_static_DecodeRowError_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_DecodeRowError_def_void@
identifier F = DecodeRowError;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_DecodeRowError_def_void@
F << remove_static_DecodeRowError_def_void.F;
P << remove_static_DecodeRowError_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_DecodeRowError_decl@
type T;
identifier F = DecodeRowError;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_DecodeRowError_decl@
F << remove_static_DecodeRowError_decl.F;
T << remove_static_DecodeRowError_decl.T;
P << remove_static_DecodeRowError_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_DecodeRowError_decl_void@
identifier F = DecodeRowError;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_DecodeRowError_decl_void@
F << remove_static_DecodeRowError_decl_void.F;
P << remove_static_DecodeRowError_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_DecodeRowError_def@
type T;
identifier F = DecodeRowError;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_DecodeRowError_def@
F << extract_DecodeRowError_def.F;
T << extract_DecodeRowError_def.T;
P << extract_DecodeRowError_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_DecodeRowError_def_void@
identifier F = DecodeRowError;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_DecodeRowError_def_void@
F << extract_DecodeRowError_def_void.F;
P << extract_DecodeRowError_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_DecodeRowError_decl@
type T;
identifier F = DecodeRowError;
parameter list P;
@@
T F(P);

@script:python depends on extract_DecodeRowError_decl@
F << extract_DecodeRowError_decl.F;
T << extract_DecodeRowError_decl.T;
P << extract_DecodeRowError_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_DecodeRowError_decl_void@
identifier F = DecodeRowError;
parameter list P;
@@
void F(P);

@script:python depends on extract_DecodeRowError_decl_void@
F << extract_DecodeRowError_decl_void.F;
P << extract_DecodeRowError_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: DumpFixupTags
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_DumpFixupTags_def@
type T;
identifier F = DumpFixupTags;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_DumpFixupTags_def@
F << remove_static_DumpFixupTags_def.F;
T << remove_static_DumpFixupTags_def.T;
P << remove_static_DumpFixupTags_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_DumpFixupTags_def_void@
identifier F = DumpFixupTags;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_DumpFixupTags_def_void@
F << remove_static_DumpFixupTags_def_void.F;
P << remove_static_DumpFixupTags_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_DumpFixupTags_decl@
type T;
identifier F = DumpFixupTags;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_DumpFixupTags_decl@
F << remove_static_DumpFixupTags_decl.F;
T << remove_static_DumpFixupTags_decl.T;
P << remove_static_DumpFixupTags_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_DumpFixupTags_decl_void@
identifier F = DumpFixupTags;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_DumpFixupTags_decl_void@
F << remove_static_DumpFixupTags_decl_void.F;
P << remove_static_DumpFixupTags_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_DumpFixupTags_def@
type T;
identifier F = DumpFixupTags;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_DumpFixupTags_def@
F << extract_DumpFixupTags_def.F;
T << extract_DumpFixupTags_def.T;
P << extract_DumpFixupTags_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_DumpFixupTags_def_void@
identifier F = DumpFixupTags;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_DumpFixupTags_def_void@
F << extract_DumpFixupTags_def_void.F;
P << extract_DumpFixupTags_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_DumpFixupTags_decl@
type T;
identifier F = DumpFixupTags;
parameter list P;
@@
T F(P);

@script:python depends on extract_DumpFixupTags_decl@
F << extract_DumpFixupTags_decl.F;
T << extract_DumpFixupTags_decl.T;
P << extract_DumpFixupTags_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_DumpFixupTags_decl_void@
identifier F = DumpFixupTags;
parameter list P;
@@
void F(P);

@script:python depends on extract_DumpFixupTags_decl_void@
F << extract_DumpFixupTags_decl_void.F;
P << extract_DumpFixupTags_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: DumpModeDecode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_DumpModeDecode_def@
type T;
identifier F = DumpModeDecode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_DumpModeDecode_def@
F << remove_static_DumpModeDecode_def.F;
T << remove_static_DumpModeDecode_def.T;
P << remove_static_DumpModeDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_DumpModeDecode_def_void@
identifier F = DumpModeDecode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_DumpModeDecode_def_void@
F << remove_static_DumpModeDecode_def_void.F;
P << remove_static_DumpModeDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_DumpModeDecode_decl@
type T;
identifier F = DumpModeDecode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_DumpModeDecode_decl@
F << remove_static_DumpModeDecode_decl.F;
T << remove_static_DumpModeDecode_decl.T;
P << remove_static_DumpModeDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_DumpModeDecode_decl_void@
identifier F = DumpModeDecode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_DumpModeDecode_decl_void@
F << remove_static_DumpModeDecode_decl_void.F;
P << remove_static_DumpModeDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_DumpModeDecode_def@
type T;
identifier F = DumpModeDecode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_DumpModeDecode_def@
F << extract_DumpModeDecode_def.F;
T << extract_DumpModeDecode_def.T;
P << extract_DumpModeDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_DumpModeDecode_def_void@
identifier F = DumpModeDecode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_DumpModeDecode_def_void@
F << extract_DumpModeDecode_def_void.F;
P << extract_DumpModeDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_DumpModeDecode_decl@
type T;
identifier F = DumpModeDecode;
parameter list P;
@@
T F(P);

@script:python depends on extract_DumpModeDecode_decl@
F << extract_DumpModeDecode_decl.F;
T << extract_DumpModeDecode_decl.T;
P << extract_DumpModeDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_DumpModeDecode_decl_void@
identifier F = DumpModeDecode;
parameter list P;
@@
void F(P);

@script:python depends on extract_DumpModeDecode_decl_void@
F << extract_DumpModeDecode_decl_void.F;
P << extract_DumpModeDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: DumpModeEncode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_DumpModeEncode_def@
type T;
identifier F = DumpModeEncode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_DumpModeEncode_def@
F << remove_static_DumpModeEncode_def.F;
T << remove_static_DumpModeEncode_def.T;
P << remove_static_DumpModeEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_DumpModeEncode_def_void@
identifier F = DumpModeEncode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_DumpModeEncode_def_void@
F << remove_static_DumpModeEncode_def_void.F;
P << remove_static_DumpModeEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_DumpModeEncode_decl@
type T;
identifier F = DumpModeEncode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_DumpModeEncode_decl@
F << remove_static_DumpModeEncode_decl.F;
T << remove_static_DumpModeEncode_decl.T;
P << remove_static_DumpModeEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_DumpModeEncode_decl_void@
identifier F = DumpModeEncode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_DumpModeEncode_decl_void@
F << remove_static_DumpModeEncode_decl_void.F;
P << remove_static_DumpModeEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_DumpModeEncode_def@
type T;
identifier F = DumpModeEncode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_DumpModeEncode_def@
F << extract_DumpModeEncode_def.F;
T << extract_DumpModeEncode_def.T;
P << extract_DumpModeEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_DumpModeEncode_def_void@
identifier F = DumpModeEncode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_DumpModeEncode_def_void@
F << extract_DumpModeEncode_def_void.F;
P << extract_DumpModeEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_DumpModeEncode_decl@
type T;
identifier F = DumpModeEncode;
parameter list P;
@@
T F(P);

@script:python depends on extract_DumpModeEncode_decl@
F << extract_DumpModeEncode_decl.F;
T << extract_DumpModeEncode_decl.T;
P << extract_DumpModeEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_DumpModeEncode_decl_void@
identifier F = DumpModeEncode;
parameter list P;
@@
void F(P);

@script:python depends on extract_DumpModeEncode_decl_void@
F << extract_DumpModeEncode_decl_void.F;
P << extract_DumpModeEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: DumpModeSeek
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_DumpModeSeek_def@
type T;
identifier F = DumpModeSeek;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_DumpModeSeek_def@
F << remove_static_DumpModeSeek_def.F;
T << remove_static_DumpModeSeek_def.T;
P << remove_static_DumpModeSeek_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_DumpModeSeek_def_void@
identifier F = DumpModeSeek;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_DumpModeSeek_def_void@
F << remove_static_DumpModeSeek_def_void.F;
P << remove_static_DumpModeSeek_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_DumpModeSeek_decl@
type T;
identifier F = DumpModeSeek;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_DumpModeSeek_decl@
F << remove_static_DumpModeSeek_decl.F;
T << remove_static_DumpModeSeek_decl.T;
P << remove_static_DumpModeSeek_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_DumpModeSeek_decl_void@
identifier F = DumpModeSeek;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_DumpModeSeek_decl_void@
F << remove_static_DumpModeSeek_decl_void.F;
P << remove_static_DumpModeSeek_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_DumpModeSeek_def@
type T;
identifier F = DumpModeSeek;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_DumpModeSeek_def@
F << extract_DumpModeSeek_def.F;
T << extract_DumpModeSeek_def.T;
P << extract_DumpModeSeek_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_DumpModeSeek_def_void@
identifier F = DumpModeSeek;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_DumpModeSeek_def_void@
F << extract_DumpModeSeek_def_void.F;
P << extract_DumpModeSeek_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_DumpModeSeek_decl@
type T;
identifier F = DumpModeSeek;
parameter list P;
@@
T F(P);

@script:python depends on extract_DumpModeSeek_decl@
F << extract_DumpModeSeek_decl.F;
T << extract_DumpModeSeek_decl.T;
P << extract_DumpModeSeek_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_DumpModeSeek_decl_void@
identifier F = DumpModeSeek;
parameter list P;
@@
void F(P);

@script:python depends on extract_DumpModeSeek_decl_void@
F << extract_DumpModeSeek_decl_void.F;
P << extract_DumpModeSeek_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: Fax3Cleanup
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_Fax3Cleanup_def@
type T;
identifier F = Fax3Cleanup;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_Fax3Cleanup_def@
F << remove_static_Fax3Cleanup_def.F;
T << remove_static_Fax3Cleanup_def.T;
P << remove_static_Fax3Cleanup_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_Fax3Cleanup_def_void@
identifier F = Fax3Cleanup;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_Fax3Cleanup_def_void@
F << remove_static_Fax3Cleanup_def_void.F;
P << remove_static_Fax3Cleanup_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_Fax3Cleanup_decl@
type T;
identifier F = Fax3Cleanup;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_Fax3Cleanup_decl@
F << remove_static_Fax3Cleanup_decl.F;
T << remove_static_Fax3Cleanup_decl.T;
P << remove_static_Fax3Cleanup_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_Fax3Cleanup_decl_void@
identifier F = Fax3Cleanup;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_Fax3Cleanup_decl_void@
F << remove_static_Fax3Cleanup_decl_void.F;
P << remove_static_Fax3Cleanup_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_Fax3Cleanup_def@
type T;
identifier F = Fax3Cleanup;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_Fax3Cleanup_def@
F << extract_Fax3Cleanup_def.F;
T << extract_Fax3Cleanup_def.T;
P << extract_Fax3Cleanup_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_Fax3Cleanup_def_void@
identifier F = Fax3Cleanup;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_Fax3Cleanup_def_void@
F << extract_Fax3Cleanup_def_void.F;
P << extract_Fax3Cleanup_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_Fax3Cleanup_decl@
type T;
identifier F = Fax3Cleanup;
parameter list P;
@@
T F(P);

@script:python depends on extract_Fax3Cleanup_decl@
F << extract_Fax3Cleanup_decl.F;
T << extract_Fax3Cleanup_decl.T;
P << extract_Fax3Cleanup_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_Fax3Cleanup_decl_void@
identifier F = Fax3Cleanup;
parameter list P;
@@
void F(P);

@script:python depends on extract_Fax3Cleanup_decl_void@
F << extract_Fax3Cleanup_decl_void.F;
P << extract_Fax3Cleanup_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: Fax3Close
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_Fax3Close_def@
type T;
identifier F = Fax3Close;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_Fax3Close_def@
F << remove_static_Fax3Close_def.F;
T << remove_static_Fax3Close_def.T;
P << remove_static_Fax3Close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_Fax3Close_def_void@
identifier F = Fax3Close;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_Fax3Close_def_void@
F << remove_static_Fax3Close_def_void.F;
P << remove_static_Fax3Close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_Fax3Close_decl@
type T;
identifier F = Fax3Close;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_Fax3Close_decl@
F << remove_static_Fax3Close_decl.F;
T << remove_static_Fax3Close_decl.T;
P << remove_static_Fax3Close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_Fax3Close_decl_void@
identifier F = Fax3Close;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_Fax3Close_decl_void@
F << remove_static_Fax3Close_decl_void.F;
P << remove_static_Fax3Close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_Fax3Close_def@
type T;
identifier F = Fax3Close;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_Fax3Close_def@
F << extract_Fax3Close_def.F;
T << extract_Fax3Close_def.T;
P << extract_Fax3Close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_Fax3Close_def_void@
identifier F = Fax3Close;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_Fax3Close_def_void@
F << extract_Fax3Close_def_void.F;
P << extract_Fax3Close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_Fax3Close_decl@
type T;
identifier F = Fax3Close;
parameter list P;
@@
T F(P);

@script:python depends on extract_Fax3Close_decl@
F << extract_Fax3Close_decl.F;
T << extract_Fax3Close_decl.T;
P << extract_Fax3Close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_Fax3Close_decl_void@
identifier F = Fax3Close;
parameter list P;
@@
void F(P);

@script:python depends on extract_Fax3Close_decl_void@
F << extract_Fax3Close_decl_void.F;
P << extract_Fax3Close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: Fax3Decode1D
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_Fax3Decode1D_def@
type T;
identifier F = Fax3Decode1D;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_Fax3Decode1D_def@
F << remove_static_Fax3Decode1D_def.F;
T << remove_static_Fax3Decode1D_def.T;
P << remove_static_Fax3Decode1D_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_Fax3Decode1D_def_void@
identifier F = Fax3Decode1D;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_Fax3Decode1D_def_void@
F << remove_static_Fax3Decode1D_def_void.F;
P << remove_static_Fax3Decode1D_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_Fax3Decode1D_decl@
type T;
identifier F = Fax3Decode1D;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_Fax3Decode1D_decl@
F << remove_static_Fax3Decode1D_decl.F;
T << remove_static_Fax3Decode1D_decl.T;
P << remove_static_Fax3Decode1D_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_Fax3Decode1D_decl_void@
identifier F = Fax3Decode1D;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_Fax3Decode1D_decl_void@
F << remove_static_Fax3Decode1D_decl_void.F;
P << remove_static_Fax3Decode1D_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_Fax3Decode1D_def@
type T;
identifier F = Fax3Decode1D;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_Fax3Decode1D_def@
F << extract_Fax3Decode1D_def.F;
T << extract_Fax3Decode1D_def.T;
P << extract_Fax3Decode1D_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_Fax3Decode1D_def_void@
identifier F = Fax3Decode1D;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_Fax3Decode1D_def_void@
F << extract_Fax3Decode1D_def_void.F;
P << extract_Fax3Decode1D_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_Fax3Decode1D_decl@
type T;
identifier F = Fax3Decode1D;
parameter list P;
@@
T F(P);

@script:python depends on extract_Fax3Decode1D_decl@
F << extract_Fax3Decode1D_decl.F;
T << extract_Fax3Decode1D_decl.T;
P << extract_Fax3Decode1D_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_Fax3Decode1D_decl_void@
identifier F = Fax3Decode1D;
parameter list P;
@@
void F(P);

@script:python depends on extract_Fax3Decode1D_decl_void@
F << extract_Fax3Decode1D_decl_void.F;
P << extract_Fax3Decode1D_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: Fax3Decode2D
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_Fax3Decode2D_def@
type T;
identifier F = Fax3Decode2D;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_Fax3Decode2D_def@
F << remove_static_Fax3Decode2D_def.F;
T << remove_static_Fax3Decode2D_def.T;
P << remove_static_Fax3Decode2D_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_Fax3Decode2D_def_void@
identifier F = Fax3Decode2D;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_Fax3Decode2D_def_void@
F << remove_static_Fax3Decode2D_def_void.F;
P << remove_static_Fax3Decode2D_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_Fax3Decode2D_decl@
type T;
identifier F = Fax3Decode2D;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_Fax3Decode2D_decl@
F << remove_static_Fax3Decode2D_decl.F;
T << remove_static_Fax3Decode2D_decl.T;
P << remove_static_Fax3Decode2D_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_Fax3Decode2D_decl_void@
identifier F = Fax3Decode2D;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_Fax3Decode2D_decl_void@
F << remove_static_Fax3Decode2D_decl_void.F;
P << remove_static_Fax3Decode2D_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_Fax3Decode2D_def@
type T;
identifier F = Fax3Decode2D;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_Fax3Decode2D_def@
F << extract_Fax3Decode2D_def.F;
T << extract_Fax3Decode2D_def.T;
P << extract_Fax3Decode2D_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_Fax3Decode2D_def_void@
identifier F = Fax3Decode2D;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_Fax3Decode2D_def_void@
F << extract_Fax3Decode2D_def_void.F;
P << extract_Fax3Decode2D_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_Fax3Decode2D_decl@
type T;
identifier F = Fax3Decode2D;
parameter list P;
@@
T F(P);

@script:python depends on extract_Fax3Decode2D_decl@
F << extract_Fax3Decode2D_decl.F;
T << extract_Fax3Decode2D_decl.T;
P << extract_Fax3Decode2D_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_Fax3Decode2D_decl_void@
identifier F = Fax3Decode2D;
parameter list P;
@@
void F(P);

@script:python depends on extract_Fax3Decode2D_decl_void@
F << extract_Fax3Decode2D_decl_void.F;
P << extract_Fax3Decode2D_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: Fax3DecodeRLE
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_Fax3DecodeRLE_def@
type T;
identifier F = Fax3DecodeRLE;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_Fax3DecodeRLE_def@
F << remove_static_Fax3DecodeRLE_def.F;
T << remove_static_Fax3DecodeRLE_def.T;
P << remove_static_Fax3DecodeRLE_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_Fax3DecodeRLE_def_void@
identifier F = Fax3DecodeRLE;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_Fax3DecodeRLE_def_void@
F << remove_static_Fax3DecodeRLE_def_void.F;
P << remove_static_Fax3DecodeRLE_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_Fax3DecodeRLE_decl@
type T;
identifier F = Fax3DecodeRLE;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_Fax3DecodeRLE_decl@
F << remove_static_Fax3DecodeRLE_decl.F;
T << remove_static_Fax3DecodeRLE_decl.T;
P << remove_static_Fax3DecodeRLE_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_Fax3DecodeRLE_decl_void@
identifier F = Fax3DecodeRLE;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_Fax3DecodeRLE_decl_void@
F << remove_static_Fax3DecodeRLE_decl_void.F;
P << remove_static_Fax3DecodeRLE_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_Fax3DecodeRLE_def@
type T;
identifier F = Fax3DecodeRLE;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_Fax3DecodeRLE_def@
F << extract_Fax3DecodeRLE_def.F;
T << extract_Fax3DecodeRLE_def.T;
P << extract_Fax3DecodeRLE_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_Fax3DecodeRLE_def_void@
identifier F = Fax3DecodeRLE;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_Fax3DecodeRLE_def_void@
F << extract_Fax3DecodeRLE_def_void.F;
P << extract_Fax3DecodeRLE_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_Fax3DecodeRLE_decl@
type T;
identifier F = Fax3DecodeRLE;
parameter list P;
@@
T F(P);

@script:python depends on extract_Fax3DecodeRLE_decl@
F << extract_Fax3DecodeRLE_decl.F;
T << extract_Fax3DecodeRLE_decl.T;
P << extract_Fax3DecodeRLE_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_Fax3DecodeRLE_decl_void@
identifier F = Fax3DecodeRLE;
parameter list P;
@@
void F(P);

@script:python depends on extract_Fax3DecodeRLE_decl_void@
F << extract_Fax3DecodeRLE_decl_void.F;
P << extract_Fax3DecodeRLE_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: Fax3Encode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_Fax3Encode_def@
type T;
identifier F = Fax3Encode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_Fax3Encode_def@
F << remove_static_Fax3Encode_def.F;
T << remove_static_Fax3Encode_def.T;
P << remove_static_Fax3Encode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_Fax3Encode_def_void@
identifier F = Fax3Encode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_Fax3Encode_def_void@
F << remove_static_Fax3Encode_def_void.F;
P << remove_static_Fax3Encode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_Fax3Encode_decl@
type T;
identifier F = Fax3Encode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_Fax3Encode_decl@
F << remove_static_Fax3Encode_decl.F;
T << remove_static_Fax3Encode_decl.T;
P << remove_static_Fax3Encode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_Fax3Encode_decl_void@
identifier F = Fax3Encode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_Fax3Encode_decl_void@
F << remove_static_Fax3Encode_decl_void.F;
P << remove_static_Fax3Encode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_Fax3Encode_def@
type T;
identifier F = Fax3Encode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_Fax3Encode_def@
F << extract_Fax3Encode_def.F;
T << extract_Fax3Encode_def.T;
P << extract_Fax3Encode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_Fax3Encode_def_void@
identifier F = Fax3Encode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_Fax3Encode_def_void@
F << extract_Fax3Encode_def_void.F;
P << extract_Fax3Encode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_Fax3Encode_decl@
type T;
identifier F = Fax3Encode;
parameter list P;
@@
T F(P);

@script:python depends on extract_Fax3Encode_decl@
F << extract_Fax3Encode_decl.F;
T << extract_Fax3Encode_decl.T;
P << extract_Fax3Encode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_Fax3Encode_decl_void@
identifier F = Fax3Encode;
parameter list P;
@@
void F(P);

@script:python depends on extract_Fax3Encode_decl_void@
F << extract_Fax3Encode_decl_void.F;
P << extract_Fax3Encode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: Fax3FixupTags
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_Fax3FixupTags_def@
type T;
identifier F = Fax3FixupTags;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_Fax3FixupTags_def@
F << remove_static_Fax3FixupTags_def.F;
T << remove_static_Fax3FixupTags_def.T;
P << remove_static_Fax3FixupTags_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_Fax3FixupTags_def_void@
identifier F = Fax3FixupTags;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_Fax3FixupTags_def_void@
F << remove_static_Fax3FixupTags_def_void.F;
P << remove_static_Fax3FixupTags_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_Fax3FixupTags_decl@
type T;
identifier F = Fax3FixupTags;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_Fax3FixupTags_decl@
F << remove_static_Fax3FixupTags_decl.F;
T << remove_static_Fax3FixupTags_decl.T;
P << remove_static_Fax3FixupTags_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_Fax3FixupTags_decl_void@
identifier F = Fax3FixupTags;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_Fax3FixupTags_decl_void@
F << remove_static_Fax3FixupTags_decl_void.F;
P << remove_static_Fax3FixupTags_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_Fax3FixupTags_def@
type T;
identifier F = Fax3FixupTags;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_Fax3FixupTags_def@
F << extract_Fax3FixupTags_def.F;
T << extract_Fax3FixupTags_def.T;
P << extract_Fax3FixupTags_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_Fax3FixupTags_def_void@
identifier F = Fax3FixupTags;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_Fax3FixupTags_def_void@
F << extract_Fax3FixupTags_def_void.F;
P << extract_Fax3FixupTags_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_Fax3FixupTags_decl@
type T;
identifier F = Fax3FixupTags;
parameter list P;
@@
T F(P);

@script:python depends on extract_Fax3FixupTags_decl@
F << extract_Fax3FixupTags_decl.F;
T << extract_Fax3FixupTags_decl.T;
P << extract_Fax3FixupTags_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_Fax3FixupTags_decl_void@
identifier F = Fax3FixupTags;
parameter list P;
@@
void F(P);

@script:python depends on extract_Fax3FixupTags_decl_void@
F << extract_Fax3FixupTags_decl_void.F;
P << extract_Fax3FixupTags_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: Fax3PostEncode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_Fax3PostEncode_def@
type T;
identifier F = Fax3PostEncode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_Fax3PostEncode_def@
F << remove_static_Fax3PostEncode_def.F;
T << remove_static_Fax3PostEncode_def.T;
P << remove_static_Fax3PostEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_Fax3PostEncode_def_void@
identifier F = Fax3PostEncode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_Fax3PostEncode_def_void@
F << remove_static_Fax3PostEncode_def_void.F;
P << remove_static_Fax3PostEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_Fax3PostEncode_decl@
type T;
identifier F = Fax3PostEncode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_Fax3PostEncode_decl@
F << remove_static_Fax3PostEncode_decl.F;
T << remove_static_Fax3PostEncode_decl.T;
P << remove_static_Fax3PostEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_Fax3PostEncode_decl_void@
identifier F = Fax3PostEncode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_Fax3PostEncode_decl_void@
F << remove_static_Fax3PostEncode_decl_void.F;
P << remove_static_Fax3PostEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_Fax3PostEncode_def@
type T;
identifier F = Fax3PostEncode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_Fax3PostEncode_def@
F << extract_Fax3PostEncode_def.F;
T << extract_Fax3PostEncode_def.T;
P << extract_Fax3PostEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_Fax3PostEncode_def_void@
identifier F = Fax3PostEncode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_Fax3PostEncode_def_void@
F << extract_Fax3PostEncode_def_void.F;
P << extract_Fax3PostEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_Fax3PostEncode_decl@
type T;
identifier F = Fax3PostEncode;
parameter list P;
@@
T F(P);

@script:python depends on extract_Fax3PostEncode_decl@
F << extract_Fax3PostEncode_decl.F;
T << extract_Fax3PostEncode_decl.T;
P << extract_Fax3PostEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_Fax3PostEncode_decl_void@
identifier F = Fax3PostEncode;
parameter list P;
@@
void F(P);

@script:python depends on extract_Fax3PostEncode_decl_void@
F << extract_Fax3PostEncode_decl_void.F;
P << extract_Fax3PostEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: Fax3PreDecode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_Fax3PreDecode_def@
type T;
identifier F = Fax3PreDecode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_Fax3PreDecode_def@
F << remove_static_Fax3PreDecode_def.F;
T << remove_static_Fax3PreDecode_def.T;
P << remove_static_Fax3PreDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_Fax3PreDecode_def_void@
identifier F = Fax3PreDecode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_Fax3PreDecode_def_void@
F << remove_static_Fax3PreDecode_def_void.F;
P << remove_static_Fax3PreDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_Fax3PreDecode_decl@
type T;
identifier F = Fax3PreDecode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_Fax3PreDecode_decl@
F << remove_static_Fax3PreDecode_decl.F;
T << remove_static_Fax3PreDecode_decl.T;
P << remove_static_Fax3PreDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_Fax3PreDecode_decl_void@
identifier F = Fax3PreDecode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_Fax3PreDecode_decl_void@
F << remove_static_Fax3PreDecode_decl_void.F;
P << remove_static_Fax3PreDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_Fax3PreDecode_def@
type T;
identifier F = Fax3PreDecode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_Fax3PreDecode_def@
F << extract_Fax3PreDecode_def.F;
T << extract_Fax3PreDecode_def.T;
P << extract_Fax3PreDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_Fax3PreDecode_def_void@
identifier F = Fax3PreDecode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_Fax3PreDecode_def_void@
F << extract_Fax3PreDecode_def_void.F;
P << extract_Fax3PreDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_Fax3PreDecode_decl@
type T;
identifier F = Fax3PreDecode;
parameter list P;
@@
T F(P);

@script:python depends on extract_Fax3PreDecode_decl@
F << extract_Fax3PreDecode_decl.F;
T << extract_Fax3PreDecode_decl.T;
P << extract_Fax3PreDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_Fax3PreDecode_decl_void@
identifier F = Fax3PreDecode;
parameter list P;
@@
void F(P);

@script:python depends on extract_Fax3PreDecode_decl_void@
F << extract_Fax3PreDecode_decl_void.F;
P << extract_Fax3PreDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: Fax3PreEncode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_Fax3PreEncode_def@
type T;
identifier F = Fax3PreEncode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_Fax3PreEncode_def@
F << remove_static_Fax3PreEncode_def.F;
T << remove_static_Fax3PreEncode_def.T;
P << remove_static_Fax3PreEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_Fax3PreEncode_def_void@
identifier F = Fax3PreEncode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_Fax3PreEncode_def_void@
F << remove_static_Fax3PreEncode_def_void.F;
P << remove_static_Fax3PreEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_Fax3PreEncode_decl@
type T;
identifier F = Fax3PreEncode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_Fax3PreEncode_decl@
F << remove_static_Fax3PreEncode_decl.F;
T << remove_static_Fax3PreEncode_decl.T;
P << remove_static_Fax3PreEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_Fax3PreEncode_decl_void@
identifier F = Fax3PreEncode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_Fax3PreEncode_decl_void@
F << remove_static_Fax3PreEncode_decl_void.F;
P << remove_static_Fax3PreEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_Fax3PreEncode_def@
type T;
identifier F = Fax3PreEncode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_Fax3PreEncode_def@
F << extract_Fax3PreEncode_def.F;
T << extract_Fax3PreEncode_def.T;
P << extract_Fax3PreEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_Fax3PreEncode_def_void@
identifier F = Fax3PreEncode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_Fax3PreEncode_def_void@
F << extract_Fax3PreEncode_def_void.F;
P << extract_Fax3PreEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_Fax3PreEncode_decl@
type T;
identifier F = Fax3PreEncode;
parameter list P;
@@
T F(P);

@script:python depends on extract_Fax3PreEncode_decl@
F << extract_Fax3PreEncode_decl.F;
T << extract_Fax3PreEncode_decl.T;
P << extract_Fax3PreEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_Fax3PreEncode_decl_void@
identifier F = Fax3PreEncode;
parameter list P;
@@
void F(P);

@script:python depends on extract_Fax3PreEncode_decl_void@
F << extract_Fax3PreEncode_decl_void.F;
P << extract_Fax3PreEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: Fax3PrintDir
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_Fax3PrintDir_def@
type T;
identifier F = Fax3PrintDir;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_Fax3PrintDir_def@
F << remove_static_Fax3PrintDir_def.F;
T << remove_static_Fax3PrintDir_def.T;
P << remove_static_Fax3PrintDir_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_Fax3PrintDir_def_void@
identifier F = Fax3PrintDir;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_Fax3PrintDir_def_void@
F << remove_static_Fax3PrintDir_def_void.F;
P << remove_static_Fax3PrintDir_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_Fax3PrintDir_decl@
type T;
identifier F = Fax3PrintDir;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_Fax3PrintDir_decl@
F << remove_static_Fax3PrintDir_decl.F;
T << remove_static_Fax3PrintDir_decl.T;
P << remove_static_Fax3PrintDir_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_Fax3PrintDir_decl_void@
identifier F = Fax3PrintDir;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_Fax3PrintDir_decl_void@
F << remove_static_Fax3PrintDir_decl_void.F;
P << remove_static_Fax3PrintDir_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_Fax3PrintDir_def@
type T;
identifier F = Fax3PrintDir;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_Fax3PrintDir_def@
F << extract_Fax3PrintDir_def.F;
T << extract_Fax3PrintDir_def.T;
P << extract_Fax3PrintDir_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_Fax3PrintDir_def_void@
identifier F = Fax3PrintDir;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_Fax3PrintDir_def_void@
F << extract_Fax3PrintDir_def_void.F;
P << extract_Fax3PrintDir_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_Fax3PrintDir_decl@
type T;
identifier F = Fax3PrintDir;
parameter list P;
@@
T F(P);

@script:python depends on extract_Fax3PrintDir_decl@
F << extract_Fax3PrintDir_decl.F;
T << extract_Fax3PrintDir_decl.T;
P << extract_Fax3PrintDir_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_Fax3PrintDir_decl_void@
identifier F = Fax3PrintDir;
parameter list P;
@@
void F(P);

@script:python depends on extract_Fax3PrintDir_decl_void@
F << extract_Fax3PrintDir_decl_void.F;
P << extract_Fax3PrintDir_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: Fax3SetupState
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_Fax3SetupState_def@
type T;
identifier F = Fax3SetupState;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_Fax3SetupState_def@
F << remove_static_Fax3SetupState_def.F;
T << remove_static_Fax3SetupState_def.T;
P << remove_static_Fax3SetupState_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_Fax3SetupState_def_void@
identifier F = Fax3SetupState;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_Fax3SetupState_def_void@
F << remove_static_Fax3SetupState_def_void.F;
P << remove_static_Fax3SetupState_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_Fax3SetupState_decl@
type T;
identifier F = Fax3SetupState;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_Fax3SetupState_decl@
F << remove_static_Fax3SetupState_decl.F;
T << remove_static_Fax3SetupState_decl.T;
P << remove_static_Fax3SetupState_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_Fax3SetupState_decl_void@
identifier F = Fax3SetupState;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_Fax3SetupState_decl_void@
F << remove_static_Fax3SetupState_decl_void.F;
P << remove_static_Fax3SetupState_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_Fax3SetupState_def@
type T;
identifier F = Fax3SetupState;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_Fax3SetupState_def@
F << extract_Fax3SetupState_def.F;
T << extract_Fax3SetupState_def.T;
P << extract_Fax3SetupState_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_Fax3SetupState_def_void@
identifier F = Fax3SetupState;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_Fax3SetupState_def_void@
F << extract_Fax3SetupState_def_void.F;
P << extract_Fax3SetupState_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_Fax3SetupState_decl@
type T;
identifier F = Fax3SetupState;
parameter list P;
@@
T F(P);

@script:python depends on extract_Fax3SetupState_decl@
F << extract_Fax3SetupState_decl.F;
T << extract_Fax3SetupState_decl.T;
P << extract_Fax3SetupState_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_Fax3SetupState_decl_void@
identifier F = Fax3SetupState;
parameter list P;
@@
void F(P);

@script:python depends on extract_Fax3SetupState_decl_void@
F << extract_Fax3SetupState_decl_void.F;
P << extract_Fax3SetupState_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: Fax3VGetField
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_Fax3VGetField_def@
type T;
identifier F = Fax3VGetField;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_Fax3VGetField_def@
F << remove_static_Fax3VGetField_def.F;
T << remove_static_Fax3VGetField_def.T;
P << remove_static_Fax3VGetField_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_Fax3VGetField_def_void@
identifier F = Fax3VGetField;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_Fax3VGetField_def_void@
F << remove_static_Fax3VGetField_def_void.F;
P << remove_static_Fax3VGetField_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_Fax3VGetField_decl@
type T;
identifier F = Fax3VGetField;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_Fax3VGetField_decl@
F << remove_static_Fax3VGetField_decl.F;
T << remove_static_Fax3VGetField_decl.T;
P << remove_static_Fax3VGetField_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_Fax3VGetField_decl_void@
identifier F = Fax3VGetField;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_Fax3VGetField_decl_void@
F << remove_static_Fax3VGetField_decl_void.F;
P << remove_static_Fax3VGetField_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_Fax3VGetField_def@
type T;
identifier F = Fax3VGetField;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_Fax3VGetField_def@
F << extract_Fax3VGetField_def.F;
T << extract_Fax3VGetField_def.T;
P << extract_Fax3VGetField_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_Fax3VGetField_def_void@
identifier F = Fax3VGetField;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_Fax3VGetField_def_void@
F << extract_Fax3VGetField_def_void.F;
P << extract_Fax3VGetField_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_Fax3VGetField_decl@
type T;
identifier F = Fax3VGetField;
parameter list P;
@@
T F(P);

@script:python depends on extract_Fax3VGetField_decl@
F << extract_Fax3VGetField_decl.F;
T << extract_Fax3VGetField_decl.T;
P << extract_Fax3VGetField_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_Fax3VGetField_decl_void@
identifier F = Fax3VGetField;
parameter list P;
@@
void F(P);

@script:python depends on extract_Fax3VGetField_decl_void@
F << extract_Fax3VGetField_decl_void.F;
P << extract_Fax3VGetField_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: Fax3VSetField
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_Fax3VSetField_def@
type T;
identifier F = Fax3VSetField;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_Fax3VSetField_def@
F << remove_static_Fax3VSetField_def.F;
T << remove_static_Fax3VSetField_def.T;
P << remove_static_Fax3VSetField_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_Fax3VSetField_def_void@
identifier F = Fax3VSetField;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_Fax3VSetField_def_void@
F << remove_static_Fax3VSetField_def_void.F;
P << remove_static_Fax3VSetField_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_Fax3VSetField_decl@
type T;
identifier F = Fax3VSetField;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_Fax3VSetField_decl@
F << remove_static_Fax3VSetField_decl.F;
T << remove_static_Fax3VSetField_decl.T;
P << remove_static_Fax3VSetField_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_Fax3VSetField_decl_void@
identifier F = Fax3VSetField;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_Fax3VSetField_decl_void@
F << remove_static_Fax3VSetField_decl_void.F;
P << remove_static_Fax3VSetField_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_Fax3VSetField_def@
type T;
identifier F = Fax3VSetField;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_Fax3VSetField_def@
F << extract_Fax3VSetField_def.F;
T << extract_Fax3VSetField_def.T;
P << extract_Fax3VSetField_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_Fax3VSetField_def_void@
identifier F = Fax3VSetField;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_Fax3VSetField_def_void@
F << extract_Fax3VSetField_def_void.F;
P << extract_Fax3VSetField_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_Fax3VSetField_decl@
type T;
identifier F = Fax3VSetField;
parameter list P;
@@
T F(P);

@script:python depends on extract_Fax3VSetField_decl@
F << extract_Fax3VSetField_decl.F;
T << extract_Fax3VSetField_decl.T;
P << extract_Fax3VSetField_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_Fax3VSetField_decl_void@
identifier F = Fax3VSetField;
parameter list P;
@@
void F(P);

@script:python depends on extract_Fax3VSetField_decl_void@
F << extract_Fax3VSetField_decl_void.F;
P << extract_Fax3VSetField_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: Fax4Decode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_Fax4Decode_def@
type T;
identifier F = Fax4Decode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_Fax4Decode_def@
F << remove_static_Fax4Decode_def.F;
T << remove_static_Fax4Decode_def.T;
P << remove_static_Fax4Decode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_Fax4Decode_def_void@
identifier F = Fax4Decode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_Fax4Decode_def_void@
F << remove_static_Fax4Decode_def_void.F;
P << remove_static_Fax4Decode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_Fax4Decode_decl@
type T;
identifier F = Fax4Decode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_Fax4Decode_decl@
F << remove_static_Fax4Decode_decl.F;
T << remove_static_Fax4Decode_decl.T;
P << remove_static_Fax4Decode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_Fax4Decode_decl_void@
identifier F = Fax4Decode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_Fax4Decode_decl_void@
F << remove_static_Fax4Decode_decl_void.F;
P << remove_static_Fax4Decode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_Fax4Decode_def@
type T;
identifier F = Fax4Decode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_Fax4Decode_def@
F << extract_Fax4Decode_def.F;
T << extract_Fax4Decode_def.T;
P << extract_Fax4Decode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_Fax4Decode_def_void@
identifier F = Fax4Decode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_Fax4Decode_def_void@
F << extract_Fax4Decode_def_void.F;
P << extract_Fax4Decode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_Fax4Decode_decl@
type T;
identifier F = Fax4Decode;
parameter list P;
@@
T F(P);

@script:python depends on extract_Fax4Decode_decl@
F << extract_Fax4Decode_decl.F;
T << extract_Fax4Decode_decl.T;
P << extract_Fax4Decode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_Fax4Decode_decl_void@
identifier F = Fax4Decode;
parameter list P;
@@
void F(P);

@script:python depends on extract_Fax4Decode_decl_void@
F << extract_Fax4Decode_decl_void.F;
P << extract_Fax4Decode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: Fax4Encode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_Fax4Encode_def@
type T;
identifier F = Fax4Encode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_Fax4Encode_def@
F << remove_static_Fax4Encode_def.F;
T << remove_static_Fax4Encode_def.T;
P << remove_static_Fax4Encode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_Fax4Encode_def_void@
identifier F = Fax4Encode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_Fax4Encode_def_void@
F << remove_static_Fax4Encode_def_void.F;
P << remove_static_Fax4Encode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_Fax4Encode_decl@
type T;
identifier F = Fax4Encode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_Fax4Encode_decl@
F << remove_static_Fax4Encode_decl.F;
T << remove_static_Fax4Encode_decl.T;
P << remove_static_Fax4Encode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_Fax4Encode_decl_void@
identifier F = Fax4Encode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_Fax4Encode_decl_void@
F << remove_static_Fax4Encode_decl_void.F;
P << remove_static_Fax4Encode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_Fax4Encode_def@
type T;
identifier F = Fax4Encode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_Fax4Encode_def@
F << extract_Fax4Encode_def.F;
T << extract_Fax4Encode_def.T;
P << extract_Fax4Encode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_Fax4Encode_def_void@
identifier F = Fax4Encode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_Fax4Encode_def_void@
F << extract_Fax4Encode_def_void.F;
P << extract_Fax4Encode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_Fax4Encode_decl@
type T;
identifier F = Fax4Encode;
parameter list P;
@@
T F(P);

@script:python depends on extract_Fax4Encode_decl@
F << extract_Fax4Encode_decl.F;
T << extract_Fax4Encode_decl.T;
P << extract_Fax4Encode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_Fax4Encode_decl_void@
identifier F = Fax4Encode;
parameter list P;
@@
void F(P);

@script:python depends on extract_Fax4Encode_decl_void@
F << extract_Fax4Encode_decl_void.F;
P << extract_Fax4Encode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: Fax4PostEncode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_Fax4PostEncode_def@
type T;
identifier F = Fax4PostEncode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_Fax4PostEncode_def@
F << remove_static_Fax4PostEncode_def.F;
T << remove_static_Fax4PostEncode_def.T;
P << remove_static_Fax4PostEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_Fax4PostEncode_def_void@
identifier F = Fax4PostEncode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_Fax4PostEncode_def_void@
F << remove_static_Fax4PostEncode_def_void.F;
P << remove_static_Fax4PostEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_Fax4PostEncode_decl@
type T;
identifier F = Fax4PostEncode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_Fax4PostEncode_decl@
F << remove_static_Fax4PostEncode_decl.F;
T << remove_static_Fax4PostEncode_decl.T;
P << remove_static_Fax4PostEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_Fax4PostEncode_decl_void@
identifier F = Fax4PostEncode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_Fax4PostEncode_decl_void@
F << remove_static_Fax4PostEncode_decl_void.F;
P << remove_static_Fax4PostEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_Fax4PostEncode_def@
type T;
identifier F = Fax4PostEncode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_Fax4PostEncode_def@
F << extract_Fax4PostEncode_def.F;
T << extract_Fax4PostEncode_def.T;
P << extract_Fax4PostEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_Fax4PostEncode_def_void@
identifier F = Fax4PostEncode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_Fax4PostEncode_def_void@
F << extract_Fax4PostEncode_def_void.F;
P << extract_Fax4PostEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_Fax4PostEncode_decl@
type T;
identifier F = Fax4PostEncode;
parameter list P;
@@
T F(P);

@script:python depends on extract_Fax4PostEncode_decl@
F << extract_Fax4PostEncode_decl.F;
T << extract_Fax4PostEncode_decl.T;
P << extract_Fax4PostEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_Fax4PostEncode_decl_void@
identifier F = Fax4PostEncode;
parameter list P;
@@
void F(P);

@script:python depends on extract_Fax4PostEncode_decl_void@
F << extract_Fax4PostEncode_decl_void.F;
P << extract_Fax4PostEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: JBIGDecode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_JBIGDecode_def@
type T;
identifier F = JBIGDecode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_JBIGDecode_def@
F << remove_static_JBIGDecode_def.F;
T << remove_static_JBIGDecode_def.T;
P << remove_static_JBIGDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_JBIGDecode_def_void@
identifier F = JBIGDecode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_JBIGDecode_def_void@
F << remove_static_JBIGDecode_def_void.F;
P << remove_static_JBIGDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_JBIGDecode_decl@
type T;
identifier F = JBIGDecode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_JBIGDecode_decl@
F << remove_static_JBIGDecode_decl.F;
T << remove_static_JBIGDecode_decl.T;
P << remove_static_JBIGDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_JBIGDecode_decl_void@
identifier F = JBIGDecode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_JBIGDecode_decl_void@
F << remove_static_JBIGDecode_decl_void.F;
P << remove_static_JBIGDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_JBIGDecode_def@
type T;
identifier F = JBIGDecode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_JBIGDecode_def@
F << extract_JBIGDecode_def.F;
T << extract_JBIGDecode_def.T;
P << extract_JBIGDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_JBIGDecode_def_void@
identifier F = JBIGDecode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_JBIGDecode_def_void@
F << extract_JBIGDecode_def_void.F;
P << extract_JBIGDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_JBIGDecode_decl@
type T;
identifier F = JBIGDecode;
parameter list P;
@@
T F(P);

@script:python depends on extract_JBIGDecode_decl@
F << extract_JBIGDecode_decl.F;
T << extract_JBIGDecode_decl.T;
P << extract_JBIGDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_JBIGDecode_decl_void@
identifier F = JBIGDecode;
parameter list P;
@@
void F(P);

@script:python depends on extract_JBIGDecode_decl_void@
F << extract_JBIGDecode_decl_void.F;
P << extract_JBIGDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: JBIGEncode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_JBIGEncode_def@
type T;
identifier F = JBIGEncode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_JBIGEncode_def@
F << remove_static_JBIGEncode_def.F;
T << remove_static_JBIGEncode_def.T;
P << remove_static_JBIGEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_JBIGEncode_def_void@
identifier F = JBIGEncode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_JBIGEncode_def_void@
F << remove_static_JBIGEncode_def_void.F;
P << remove_static_JBIGEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_JBIGEncode_decl@
type T;
identifier F = JBIGEncode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_JBIGEncode_decl@
F << remove_static_JBIGEncode_decl.F;
T << remove_static_JBIGEncode_decl.T;
P << remove_static_JBIGEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_JBIGEncode_decl_void@
identifier F = JBIGEncode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_JBIGEncode_decl_void@
F << remove_static_JBIGEncode_decl_void.F;
P << remove_static_JBIGEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_JBIGEncode_def@
type T;
identifier F = JBIGEncode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_JBIGEncode_def@
F << extract_JBIGEncode_def.F;
T << extract_JBIGEncode_def.T;
P << extract_JBIGEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_JBIGEncode_def_void@
identifier F = JBIGEncode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_JBIGEncode_def_void@
F << extract_JBIGEncode_def_void.F;
P << extract_JBIGEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_JBIGEncode_decl@
type T;
identifier F = JBIGEncode;
parameter list P;
@@
T F(P);

@script:python depends on extract_JBIGEncode_decl@
F << extract_JBIGEncode_decl.F;
T << extract_JBIGEncode_decl.T;
P << extract_JBIGEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_JBIGEncode_decl_void@
identifier F = JBIGEncode;
parameter list P;
@@
void F(P);

@script:python depends on extract_JBIGEncode_decl_void@
F << extract_JBIGEncode_decl_void.F;
P << extract_JBIGEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: JBIGSetupDecode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_JBIGSetupDecode_def@
type T;
identifier F = JBIGSetupDecode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_JBIGSetupDecode_def@
F << remove_static_JBIGSetupDecode_def.F;
T << remove_static_JBIGSetupDecode_def.T;
P << remove_static_JBIGSetupDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_JBIGSetupDecode_def_void@
identifier F = JBIGSetupDecode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_JBIGSetupDecode_def_void@
F << remove_static_JBIGSetupDecode_def_void.F;
P << remove_static_JBIGSetupDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_JBIGSetupDecode_decl@
type T;
identifier F = JBIGSetupDecode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_JBIGSetupDecode_decl@
F << remove_static_JBIGSetupDecode_decl.F;
T << remove_static_JBIGSetupDecode_decl.T;
P << remove_static_JBIGSetupDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_JBIGSetupDecode_decl_void@
identifier F = JBIGSetupDecode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_JBIGSetupDecode_decl_void@
F << remove_static_JBIGSetupDecode_decl_void.F;
P << remove_static_JBIGSetupDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_JBIGSetupDecode_def@
type T;
identifier F = JBIGSetupDecode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_JBIGSetupDecode_def@
F << extract_JBIGSetupDecode_def.F;
T << extract_JBIGSetupDecode_def.T;
P << extract_JBIGSetupDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_JBIGSetupDecode_def_void@
identifier F = JBIGSetupDecode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_JBIGSetupDecode_def_void@
F << extract_JBIGSetupDecode_def_void.F;
P << extract_JBIGSetupDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_JBIGSetupDecode_decl@
type T;
identifier F = JBIGSetupDecode;
parameter list P;
@@
T F(P);

@script:python depends on extract_JBIGSetupDecode_decl@
F << extract_JBIGSetupDecode_decl.F;
T << extract_JBIGSetupDecode_decl.T;
P << extract_JBIGSetupDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_JBIGSetupDecode_decl_void@
identifier F = JBIGSetupDecode;
parameter list P;
@@
void F(P);

@script:python depends on extract_JBIGSetupDecode_decl_void@
F << extract_JBIGSetupDecode_decl_void.F;
P << extract_JBIGSetupDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: JBIGSetupEncode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_JBIGSetupEncode_def@
type T;
identifier F = JBIGSetupEncode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_JBIGSetupEncode_def@
F << remove_static_JBIGSetupEncode_def.F;
T << remove_static_JBIGSetupEncode_def.T;
P << remove_static_JBIGSetupEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_JBIGSetupEncode_def_void@
identifier F = JBIGSetupEncode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_JBIGSetupEncode_def_void@
F << remove_static_JBIGSetupEncode_def_void.F;
P << remove_static_JBIGSetupEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_JBIGSetupEncode_decl@
type T;
identifier F = JBIGSetupEncode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_JBIGSetupEncode_decl@
F << remove_static_JBIGSetupEncode_decl.F;
T << remove_static_JBIGSetupEncode_decl.T;
P << remove_static_JBIGSetupEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_JBIGSetupEncode_decl_void@
identifier F = JBIGSetupEncode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_JBIGSetupEncode_decl_void@
F << remove_static_JBIGSetupEncode_decl_void.F;
P << remove_static_JBIGSetupEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_JBIGSetupEncode_def@
type T;
identifier F = JBIGSetupEncode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_JBIGSetupEncode_def@
F << extract_JBIGSetupEncode_def.F;
T << extract_JBIGSetupEncode_def.T;
P << extract_JBIGSetupEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_JBIGSetupEncode_def_void@
identifier F = JBIGSetupEncode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_JBIGSetupEncode_def_void@
F << extract_JBIGSetupEncode_def_void.F;
P << extract_JBIGSetupEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_JBIGSetupEncode_decl@
type T;
identifier F = JBIGSetupEncode;
parameter list P;
@@
T F(P);

@script:python depends on extract_JBIGSetupEncode_decl@
F << extract_JBIGSetupEncode_decl.F;
T << extract_JBIGSetupEncode_decl.T;
P << extract_JBIGSetupEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_JBIGSetupEncode_decl_void@
identifier F = JBIGSetupEncode;
parameter list P;
@@
void F(P);

@script:python depends on extract_JBIGSetupEncode_decl_void@
F << extract_JBIGSetupEncode_decl_void.F;
P << extract_JBIGSetupEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: JPEGCleanup
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_JPEGCleanup_def@
type T;
identifier F = JPEGCleanup;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_JPEGCleanup_def@
F << remove_static_JPEGCleanup_def.F;
T << remove_static_JPEGCleanup_def.T;
P << remove_static_JPEGCleanup_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_JPEGCleanup_def_void@
identifier F = JPEGCleanup;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_JPEGCleanup_def_void@
F << remove_static_JPEGCleanup_def_void.F;
P << remove_static_JPEGCleanup_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_JPEGCleanup_decl@
type T;
identifier F = JPEGCleanup;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_JPEGCleanup_decl@
F << remove_static_JPEGCleanup_decl.F;
T << remove_static_JPEGCleanup_decl.T;
P << remove_static_JPEGCleanup_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_JPEGCleanup_decl_void@
identifier F = JPEGCleanup;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_JPEGCleanup_decl_void@
F << remove_static_JPEGCleanup_decl_void.F;
P << remove_static_JPEGCleanup_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_JPEGCleanup_def@
type T;
identifier F = JPEGCleanup;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_JPEGCleanup_def@
F << extract_JPEGCleanup_def.F;
T << extract_JPEGCleanup_def.T;
P << extract_JPEGCleanup_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_JPEGCleanup_def_void@
identifier F = JPEGCleanup;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_JPEGCleanup_def_void@
F << extract_JPEGCleanup_def_void.F;
P << extract_JPEGCleanup_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_JPEGCleanup_decl@
type T;
identifier F = JPEGCleanup;
parameter list P;
@@
T F(P);

@script:python depends on extract_JPEGCleanup_decl@
F << extract_JPEGCleanup_decl.F;
T << extract_JPEGCleanup_decl.T;
P << extract_JPEGCleanup_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_JPEGCleanup_decl_void@
identifier F = JPEGCleanup;
parameter list P;
@@
void F(P);

@script:python depends on extract_JPEGCleanup_decl_void@
F << extract_JPEGCleanup_decl_void.F;
P << extract_JPEGCleanup_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: JPEGDecode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_JPEGDecode_def@
type T;
identifier F = JPEGDecode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_JPEGDecode_def@
F << remove_static_JPEGDecode_def.F;
T << remove_static_JPEGDecode_def.T;
P << remove_static_JPEGDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_JPEGDecode_def_void@
identifier F = JPEGDecode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_JPEGDecode_def_void@
F << remove_static_JPEGDecode_def_void.F;
P << remove_static_JPEGDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_JPEGDecode_decl@
type T;
identifier F = JPEGDecode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_JPEGDecode_decl@
F << remove_static_JPEGDecode_decl.F;
T << remove_static_JPEGDecode_decl.T;
P << remove_static_JPEGDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_JPEGDecode_decl_void@
identifier F = JPEGDecode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_JPEGDecode_decl_void@
F << remove_static_JPEGDecode_decl_void.F;
P << remove_static_JPEGDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_JPEGDecode_def@
type T;
identifier F = JPEGDecode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_JPEGDecode_def@
F << extract_JPEGDecode_def.F;
T << extract_JPEGDecode_def.T;
P << extract_JPEGDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_JPEGDecode_def_void@
identifier F = JPEGDecode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_JPEGDecode_def_void@
F << extract_JPEGDecode_def_void.F;
P << extract_JPEGDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_JPEGDecode_decl@
type T;
identifier F = JPEGDecode;
parameter list P;
@@
T F(P);

@script:python depends on extract_JPEGDecode_decl@
F << extract_JPEGDecode_decl.F;
T << extract_JPEGDecode_decl.T;
P << extract_JPEGDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_JPEGDecode_decl_void@
identifier F = JPEGDecode;
parameter list P;
@@
void F(P);

@script:python depends on extract_JPEGDecode_decl_void@
F << extract_JPEGDecode_decl_void.F;
P << extract_JPEGDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: JPEGDecodeRaw
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_JPEGDecodeRaw_def@
type T;
identifier F = JPEGDecodeRaw;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_JPEGDecodeRaw_def@
F << remove_static_JPEGDecodeRaw_def.F;
T << remove_static_JPEGDecodeRaw_def.T;
P << remove_static_JPEGDecodeRaw_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_JPEGDecodeRaw_def_void@
identifier F = JPEGDecodeRaw;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_JPEGDecodeRaw_def_void@
F << remove_static_JPEGDecodeRaw_def_void.F;
P << remove_static_JPEGDecodeRaw_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_JPEGDecodeRaw_decl@
type T;
identifier F = JPEGDecodeRaw;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_JPEGDecodeRaw_decl@
F << remove_static_JPEGDecodeRaw_decl.F;
T << remove_static_JPEGDecodeRaw_decl.T;
P << remove_static_JPEGDecodeRaw_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_JPEGDecodeRaw_decl_void@
identifier F = JPEGDecodeRaw;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_JPEGDecodeRaw_decl_void@
F << remove_static_JPEGDecodeRaw_decl_void.F;
P << remove_static_JPEGDecodeRaw_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_JPEGDecodeRaw_def@
type T;
identifier F = JPEGDecodeRaw;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_JPEGDecodeRaw_def@
F << extract_JPEGDecodeRaw_def.F;
T << extract_JPEGDecodeRaw_def.T;
P << extract_JPEGDecodeRaw_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_JPEGDecodeRaw_def_void@
identifier F = JPEGDecodeRaw;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_JPEGDecodeRaw_def_void@
F << extract_JPEGDecodeRaw_def_void.F;
P << extract_JPEGDecodeRaw_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_JPEGDecodeRaw_decl@
type T;
identifier F = JPEGDecodeRaw;
parameter list P;
@@
T F(P);

@script:python depends on extract_JPEGDecodeRaw_decl@
F << extract_JPEGDecodeRaw_decl.F;
T << extract_JPEGDecodeRaw_decl.T;
P << extract_JPEGDecodeRaw_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_JPEGDecodeRaw_decl_void@
identifier F = JPEGDecodeRaw;
parameter list P;
@@
void F(P);

@script:python depends on extract_JPEGDecodeRaw_decl_void@
F << extract_JPEGDecodeRaw_decl_void.F;
P << extract_JPEGDecodeRaw_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: JPEGDefaultStripSize
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_JPEGDefaultStripSize_def@
type T;
identifier F = JPEGDefaultStripSize;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_JPEGDefaultStripSize_def@
F << remove_static_JPEGDefaultStripSize_def.F;
T << remove_static_JPEGDefaultStripSize_def.T;
P << remove_static_JPEGDefaultStripSize_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_JPEGDefaultStripSize_def_void@
identifier F = JPEGDefaultStripSize;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_JPEGDefaultStripSize_def_void@
F << remove_static_JPEGDefaultStripSize_def_void.F;
P << remove_static_JPEGDefaultStripSize_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_JPEGDefaultStripSize_decl@
type T;
identifier F = JPEGDefaultStripSize;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_JPEGDefaultStripSize_decl@
F << remove_static_JPEGDefaultStripSize_decl.F;
T << remove_static_JPEGDefaultStripSize_decl.T;
P << remove_static_JPEGDefaultStripSize_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_JPEGDefaultStripSize_decl_void@
identifier F = JPEGDefaultStripSize;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_JPEGDefaultStripSize_decl_void@
F << remove_static_JPEGDefaultStripSize_decl_void.F;
P << remove_static_JPEGDefaultStripSize_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_JPEGDefaultStripSize_def@
type T;
identifier F = JPEGDefaultStripSize;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_JPEGDefaultStripSize_def@
F << extract_JPEGDefaultStripSize_def.F;
T << extract_JPEGDefaultStripSize_def.T;
P << extract_JPEGDefaultStripSize_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_JPEGDefaultStripSize_def_void@
identifier F = JPEGDefaultStripSize;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_JPEGDefaultStripSize_def_void@
F << extract_JPEGDefaultStripSize_def_void.F;
P << extract_JPEGDefaultStripSize_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_JPEGDefaultStripSize_decl@
type T;
identifier F = JPEGDefaultStripSize;
parameter list P;
@@
T F(P);

@script:python depends on extract_JPEGDefaultStripSize_decl@
F << extract_JPEGDefaultStripSize_decl.F;
T << extract_JPEGDefaultStripSize_decl.T;
P << extract_JPEGDefaultStripSize_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_JPEGDefaultStripSize_decl_void@
identifier F = JPEGDefaultStripSize;
parameter list P;
@@
void F(P);

@script:python depends on extract_JPEGDefaultStripSize_decl_void@
F << extract_JPEGDefaultStripSize_decl_void.F;
P << extract_JPEGDefaultStripSize_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: JPEGDefaultTileSize
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_JPEGDefaultTileSize_def@
type T;
identifier F = JPEGDefaultTileSize;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_JPEGDefaultTileSize_def@
F << remove_static_JPEGDefaultTileSize_def.F;
T << remove_static_JPEGDefaultTileSize_def.T;
P << remove_static_JPEGDefaultTileSize_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_JPEGDefaultTileSize_def_void@
identifier F = JPEGDefaultTileSize;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_JPEGDefaultTileSize_def_void@
F << remove_static_JPEGDefaultTileSize_def_void.F;
P << remove_static_JPEGDefaultTileSize_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_JPEGDefaultTileSize_decl@
type T;
identifier F = JPEGDefaultTileSize;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_JPEGDefaultTileSize_decl@
F << remove_static_JPEGDefaultTileSize_decl.F;
T << remove_static_JPEGDefaultTileSize_decl.T;
P << remove_static_JPEGDefaultTileSize_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_JPEGDefaultTileSize_decl_void@
identifier F = JPEGDefaultTileSize;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_JPEGDefaultTileSize_decl_void@
F << remove_static_JPEGDefaultTileSize_decl_void.F;
P << remove_static_JPEGDefaultTileSize_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_JPEGDefaultTileSize_def@
type T;
identifier F = JPEGDefaultTileSize;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_JPEGDefaultTileSize_def@
F << extract_JPEGDefaultTileSize_def.F;
T << extract_JPEGDefaultTileSize_def.T;
P << extract_JPEGDefaultTileSize_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_JPEGDefaultTileSize_def_void@
identifier F = JPEGDefaultTileSize;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_JPEGDefaultTileSize_def_void@
F << extract_JPEGDefaultTileSize_def_void.F;
P << extract_JPEGDefaultTileSize_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_JPEGDefaultTileSize_decl@
type T;
identifier F = JPEGDefaultTileSize;
parameter list P;
@@
T F(P);

@script:python depends on extract_JPEGDefaultTileSize_decl@
F << extract_JPEGDefaultTileSize_decl.F;
T << extract_JPEGDefaultTileSize_decl.T;
P << extract_JPEGDefaultTileSize_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_JPEGDefaultTileSize_decl_void@
identifier F = JPEGDefaultTileSize;
parameter list P;
@@
void F(P);

@script:python depends on extract_JPEGDefaultTileSize_decl_void@
F << extract_JPEGDefaultTileSize_decl_void.F;
P << extract_JPEGDefaultTileSize_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: JPEGEncode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_JPEGEncode_def@
type T;
identifier F = JPEGEncode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_JPEGEncode_def@
F << remove_static_JPEGEncode_def.F;
T << remove_static_JPEGEncode_def.T;
P << remove_static_JPEGEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_JPEGEncode_def_void@
identifier F = JPEGEncode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_JPEGEncode_def_void@
F << remove_static_JPEGEncode_def_void.F;
P << remove_static_JPEGEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_JPEGEncode_decl@
type T;
identifier F = JPEGEncode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_JPEGEncode_decl@
F << remove_static_JPEGEncode_decl.F;
T << remove_static_JPEGEncode_decl.T;
P << remove_static_JPEGEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_JPEGEncode_decl_void@
identifier F = JPEGEncode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_JPEGEncode_decl_void@
F << remove_static_JPEGEncode_decl_void.F;
P << remove_static_JPEGEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_JPEGEncode_def@
type T;
identifier F = JPEGEncode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_JPEGEncode_def@
F << extract_JPEGEncode_def.F;
T << extract_JPEGEncode_def.T;
P << extract_JPEGEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_JPEGEncode_def_void@
identifier F = JPEGEncode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_JPEGEncode_def_void@
F << extract_JPEGEncode_def_void.F;
P << extract_JPEGEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_JPEGEncode_decl@
type T;
identifier F = JPEGEncode;
parameter list P;
@@
T F(P);

@script:python depends on extract_JPEGEncode_decl@
F << extract_JPEGEncode_decl.F;
T << extract_JPEGEncode_decl.T;
P << extract_JPEGEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_JPEGEncode_decl_void@
identifier F = JPEGEncode;
parameter list P;
@@
void F(P);

@script:python depends on extract_JPEGEncode_decl_void@
F << extract_JPEGEncode_decl_void.F;
P << extract_JPEGEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: JPEGEncodeRaw
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_JPEGEncodeRaw_def@
type T;
identifier F = JPEGEncodeRaw;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_JPEGEncodeRaw_def@
F << remove_static_JPEGEncodeRaw_def.F;
T << remove_static_JPEGEncodeRaw_def.T;
P << remove_static_JPEGEncodeRaw_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_JPEGEncodeRaw_def_void@
identifier F = JPEGEncodeRaw;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_JPEGEncodeRaw_def_void@
F << remove_static_JPEGEncodeRaw_def_void.F;
P << remove_static_JPEGEncodeRaw_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_JPEGEncodeRaw_decl@
type T;
identifier F = JPEGEncodeRaw;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_JPEGEncodeRaw_decl@
F << remove_static_JPEGEncodeRaw_decl.F;
T << remove_static_JPEGEncodeRaw_decl.T;
P << remove_static_JPEGEncodeRaw_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_JPEGEncodeRaw_decl_void@
identifier F = JPEGEncodeRaw;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_JPEGEncodeRaw_decl_void@
F << remove_static_JPEGEncodeRaw_decl_void.F;
P << remove_static_JPEGEncodeRaw_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_JPEGEncodeRaw_def@
type T;
identifier F = JPEGEncodeRaw;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_JPEGEncodeRaw_def@
F << extract_JPEGEncodeRaw_def.F;
T << extract_JPEGEncodeRaw_def.T;
P << extract_JPEGEncodeRaw_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_JPEGEncodeRaw_def_void@
identifier F = JPEGEncodeRaw;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_JPEGEncodeRaw_def_void@
F << extract_JPEGEncodeRaw_def_void.F;
P << extract_JPEGEncodeRaw_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_JPEGEncodeRaw_decl@
type T;
identifier F = JPEGEncodeRaw;
parameter list P;
@@
T F(P);

@script:python depends on extract_JPEGEncodeRaw_decl@
F << extract_JPEGEncodeRaw_decl.F;
T << extract_JPEGEncodeRaw_decl.T;
P << extract_JPEGEncodeRaw_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_JPEGEncodeRaw_decl_void@
identifier F = JPEGEncodeRaw;
parameter list P;
@@
void F(P);

@script:python depends on extract_JPEGEncodeRaw_decl_void@
F << extract_JPEGEncodeRaw_decl_void.F;
P << extract_JPEGEncodeRaw_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: JPEGFixupTags
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_JPEGFixupTags_def@
type T;
identifier F = JPEGFixupTags;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_JPEGFixupTags_def@
F << remove_static_JPEGFixupTags_def.F;
T << remove_static_JPEGFixupTags_def.T;
P << remove_static_JPEGFixupTags_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_JPEGFixupTags_def_void@
identifier F = JPEGFixupTags;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_JPEGFixupTags_def_void@
F << remove_static_JPEGFixupTags_def_void.F;
P << remove_static_JPEGFixupTags_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_JPEGFixupTags_decl@
type T;
identifier F = JPEGFixupTags;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_JPEGFixupTags_decl@
F << remove_static_JPEGFixupTags_decl.F;
T << remove_static_JPEGFixupTags_decl.T;
P << remove_static_JPEGFixupTags_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_JPEGFixupTags_decl_void@
identifier F = JPEGFixupTags;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_JPEGFixupTags_decl_void@
F << remove_static_JPEGFixupTags_decl_void.F;
P << remove_static_JPEGFixupTags_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_JPEGFixupTags_def@
type T;
identifier F = JPEGFixupTags;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_JPEGFixupTags_def@
F << extract_JPEGFixupTags_def.F;
T << extract_JPEGFixupTags_def.T;
P << extract_JPEGFixupTags_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_JPEGFixupTags_def_void@
identifier F = JPEGFixupTags;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_JPEGFixupTags_def_void@
F << extract_JPEGFixupTags_def_void.F;
P << extract_JPEGFixupTags_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_JPEGFixupTags_decl@
type T;
identifier F = JPEGFixupTags;
parameter list P;
@@
T F(P);

@script:python depends on extract_JPEGFixupTags_decl@
F << extract_JPEGFixupTags_decl.F;
T << extract_JPEGFixupTags_decl.T;
P << extract_JPEGFixupTags_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_JPEGFixupTags_decl_void@
identifier F = JPEGFixupTags;
parameter list P;
@@
void F(P);

@script:python depends on extract_JPEGFixupTags_decl_void@
F << extract_JPEGFixupTags_decl_void.F;
P << extract_JPEGFixupTags_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: JPEGPostEncode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_JPEGPostEncode_def@
type T;
identifier F = JPEGPostEncode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_JPEGPostEncode_def@
F << remove_static_JPEGPostEncode_def.F;
T << remove_static_JPEGPostEncode_def.T;
P << remove_static_JPEGPostEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_JPEGPostEncode_def_void@
identifier F = JPEGPostEncode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_JPEGPostEncode_def_void@
F << remove_static_JPEGPostEncode_def_void.F;
P << remove_static_JPEGPostEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_JPEGPostEncode_decl@
type T;
identifier F = JPEGPostEncode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_JPEGPostEncode_decl@
F << remove_static_JPEGPostEncode_decl.F;
T << remove_static_JPEGPostEncode_decl.T;
P << remove_static_JPEGPostEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_JPEGPostEncode_decl_void@
identifier F = JPEGPostEncode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_JPEGPostEncode_decl_void@
F << remove_static_JPEGPostEncode_decl_void.F;
P << remove_static_JPEGPostEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_JPEGPostEncode_def@
type T;
identifier F = JPEGPostEncode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_JPEGPostEncode_def@
F << extract_JPEGPostEncode_def.F;
T << extract_JPEGPostEncode_def.T;
P << extract_JPEGPostEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_JPEGPostEncode_def_void@
identifier F = JPEGPostEncode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_JPEGPostEncode_def_void@
F << extract_JPEGPostEncode_def_void.F;
P << extract_JPEGPostEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_JPEGPostEncode_decl@
type T;
identifier F = JPEGPostEncode;
parameter list P;
@@
T F(P);

@script:python depends on extract_JPEGPostEncode_decl@
F << extract_JPEGPostEncode_decl.F;
T << extract_JPEGPostEncode_decl.T;
P << extract_JPEGPostEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_JPEGPostEncode_decl_void@
identifier F = JPEGPostEncode;
parameter list P;
@@
void F(P);

@script:python depends on extract_JPEGPostEncode_decl_void@
F << extract_JPEGPostEncode_decl_void.F;
P << extract_JPEGPostEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: JPEGPreDecode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_JPEGPreDecode_def@
type T;
identifier F = JPEGPreDecode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_JPEGPreDecode_def@
F << remove_static_JPEGPreDecode_def.F;
T << remove_static_JPEGPreDecode_def.T;
P << remove_static_JPEGPreDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_JPEGPreDecode_def_void@
identifier F = JPEGPreDecode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_JPEGPreDecode_def_void@
F << remove_static_JPEGPreDecode_def_void.F;
P << remove_static_JPEGPreDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_JPEGPreDecode_decl@
type T;
identifier F = JPEGPreDecode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_JPEGPreDecode_decl@
F << remove_static_JPEGPreDecode_decl.F;
T << remove_static_JPEGPreDecode_decl.T;
P << remove_static_JPEGPreDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_JPEGPreDecode_decl_void@
identifier F = JPEGPreDecode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_JPEGPreDecode_decl_void@
F << remove_static_JPEGPreDecode_decl_void.F;
P << remove_static_JPEGPreDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_JPEGPreDecode_def@
type T;
identifier F = JPEGPreDecode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_JPEGPreDecode_def@
F << extract_JPEGPreDecode_def.F;
T << extract_JPEGPreDecode_def.T;
P << extract_JPEGPreDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_JPEGPreDecode_def_void@
identifier F = JPEGPreDecode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_JPEGPreDecode_def_void@
F << extract_JPEGPreDecode_def_void.F;
P << extract_JPEGPreDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_JPEGPreDecode_decl@
type T;
identifier F = JPEGPreDecode;
parameter list P;
@@
T F(P);

@script:python depends on extract_JPEGPreDecode_decl@
F << extract_JPEGPreDecode_decl.F;
T << extract_JPEGPreDecode_decl.T;
P << extract_JPEGPreDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_JPEGPreDecode_decl_void@
identifier F = JPEGPreDecode;
parameter list P;
@@
void F(P);

@script:python depends on extract_JPEGPreDecode_decl_void@
F << extract_JPEGPreDecode_decl_void.F;
P << extract_JPEGPreDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: JPEGPreEncode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_JPEGPreEncode_def@
type T;
identifier F = JPEGPreEncode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_JPEGPreEncode_def@
F << remove_static_JPEGPreEncode_def.F;
T << remove_static_JPEGPreEncode_def.T;
P << remove_static_JPEGPreEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_JPEGPreEncode_def_void@
identifier F = JPEGPreEncode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_JPEGPreEncode_def_void@
F << remove_static_JPEGPreEncode_def_void.F;
P << remove_static_JPEGPreEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_JPEGPreEncode_decl@
type T;
identifier F = JPEGPreEncode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_JPEGPreEncode_decl@
F << remove_static_JPEGPreEncode_decl.F;
T << remove_static_JPEGPreEncode_decl.T;
P << remove_static_JPEGPreEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_JPEGPreEncode_decl_void@
identifier F = JPEGPreEncode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_JPEGPreEncode_decl_void@
F << remove_static_JPEGPreEncode_decl_void.F;
P << remove_static_JPEGPreEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_JPEGPreEncode_def@
type T;
identifier F = JPEGPreEncode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_JPEGPreEncode_def@
F << extract_JPEGPreEncode_def.F;
T << extract_JPEGPreEncode_def.T;
P << extract_JPEGPreEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_JPEGPreEncode_def_void@
identifier F = JPEGPreEncode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_JPEGPreEncode_def_void@
F << extract_JPEGPreEncode_def_void.F;
P << extract_JPEGPreEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_JPEGPreEncode_decl@
type T;
identifier F = JPEGPreEncode;
parameter list P;
@@
T F(P);

@script:python depends on extract_JPEGPreEncode_decl@
F << extract_JPEGPreEncode_decl.F;
T << extract_JPEGPreEncode_decl.T;
P << extract_JPEGPreEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_JPEGPreEncode_decl_void@
identifier F = JPEGPreEncode;
parameter list P;
@@
void F(P);

@script:python depends on extract_JPEGPreEncode_decl_void@
F << extract_JPEGPreEncode_decl_void.F;
P << extract_JPEGPreEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: JPEGPrintDir
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_JPEGPrintDir_def@
type T;
identifier F = JPEGPrintDir;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_JPEGPrintDir_def@
F << remove_static_JPEGPrintDir_def.F;
T << remove_static_JPEGPrintDir_def.T;
P << remove_static_JPEGPrintDir_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_JPEGPrintDir_def_void@
identifier F = JPEGPrintDir;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_JPEGPrintDir_def_void@
F << remove_static_JPEGPrintDir_def_void.F;
P << remove_static_JPEGPrintDir_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_JPEGPrintDir_decl@
type T;
identifier F = JPEGPrintDir;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_JPEGPrintDir_decl@
F << remove_static_JPEGPrintDir_decl.F;
T << remove_static_JPEGPrintDir_decl.T;
P << remove_static_JPEGPrintDir_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_JPEGPrintDir_decl_void@
identifier F = JPEGPrintDir;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_JPEGPrintDir_decl_void@
F << remove_static_JPEGPrintDir_decl_void.F;
P << remove_static_JPEGPrintDir_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_JPEGPrintDir_def@
type T;
identifier F = JPEGPrintDir;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_JPEGPrintDir_def@
F << extract_JPEGPrintDir_def.F;
T << extract_JPEGPrintDir_def.T;
P << extract_JPEGPrintDir_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_JPEGPrintDir_def_void@
identifier F = JPEGPrintDir;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_JPEGPrintDir_def_void@
F << extract_JPEGPrintDir_def_void.F;
P << extract_JPEGPrintDir_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_JPEGPrintDir_decl@
type T;
identifier F = JPEGPrintDir;
parameter list P;
@@
T F(P);

@script:python depends on extract_JPEGPrintDir_decl@
F << extract_JPEGPrintDir_decl.F;
T << extract_JPEGPrintDir_decl.T;
P << extract_JPEGPrintDir_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_JPEGPrintDir_decl_void@
identifier F = JPEGPrintDir;
parameter list P;
@@
void F(P);

@script:python depends on extract_JPEGPrintDir_decl_void@
F << extract_JPEGPrintDir_decl_void.F;
P << extract_JPEGPrintDir_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: JPEGSetupDecode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_JPEGSetupDecode_def@
type T;
identifier F = JPEGSetupDecode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_JPEGSetupDecode_def@
F << remove_static_JPEGSetupDecode_def.F;
T << remove_static_JPEGSetupDecode_def.T;
P << remove_static_JPEGSetupDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_JPEGSetupDecode_def_void@
identifier F = JPEGSetupDecode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_JPEGSetupDecode_def_void@
F << remove_static_JPEGSetupDecode_def_void.F;
P << remove_static_JPEGSetupDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_JPEGSetupDecode_decl@
type T;
identifier F = JPEGSetupDecode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_JPEGSetupDecode_decl@
F << remove_static_JPEGSetupDecode_decl.F;
T << remove_static_JPEGSetupDecode_decl.T;
P << remove_static_JPEGSetupDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_JPEGSetupDecode_decl_void@
identifier F = JPEGSetupDecode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_JPEGSetupDecode_decl_void@
F << remove_static_JPEGSetupDecode_decl_void.F;
P << remove_static_JPEGSetupDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_JPEGSetupDecode_def@
type T;
identifier F = JPEGSetupDecode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_JPEGSetupDecode_def@
F << extract_JPEGSetupDecode_def.F;
T << extract_JPEGSetupDecode_def.T;
P << extract_JPEGSetupDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_JPEGSetupDecode_def_void@
identifier F = JPEGSetupDecode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_JPEGSetupDecode_def_void@
F << extract_JPEGSetupDecode_def_void.F;
P << extract_JPEGSetupDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_JPEGSetupDecode_decl@
type T;
identifier F = JPEGSetupDecode;
parameter list P;
@@
T F(P);

@script:python depends on extract_JPEGSetupDecode_decl@
F << extract_JPEGSetupDecode_decl.F;
T << extract_JPEGSetupDecode_decl.T;
P << extract_JPEGSetupDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_JPEGSetupDecode_decl_void@
identifier F = JPEGSetupDecode;
parameter list P;
@@
void F(P);

@script:python depends on extract_JPEGSetupDecode_decl_void@
F << extract_JPEGSetupDecode_decl_void.F;
P << extract_JPEGSetupDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: JPEGSetupEncode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_JPEGSetupEncode_def@
type T;
identifier F = JPEGSetupEncode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_JPEGSetupEncode_def@
F << remove_static_JPEGSetupEncode_def.F;
T << remove_static_JPEGSetupEncode_def.T;
P << remove_static_JPEGSetupEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_JPEGSetupEncode_def_void@
identifier F = JPEGSetupEncode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_JPEGSetupEncode_def_void@
F << remove_static_JPEGSetupEncode_def_void.F;
P << remove_static_JPEGSetupEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_JPEGSetupEncode_decl@
type T;
identifier F = JPEGSetupEncode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_JPEGSetupEncode_decl@
F << remove_static_JPEGSetupEncode_decl.F;
T << remove_static_JPEGSetupEncode_decl.T;
P << remove_static_JPEGSetupEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_JPEGSetupEncode_decl_void@
identifier F = JPEGSetupEncode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_JPEGSetupEncode_decl_void@
F << remove_static_JPEGSetupEncode_decl_void.F;
P << remove_static_JPEGSetupEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_JPEGSetupEncode_def@
type T;
identifier F = JPEGSetupEncode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_JPEGSetupEncode_def@
F << extract_JPEGSetupEncode_def.F;
T << extract_JPEGSetupEncode_def.T;
P << extract_JPEGSetupEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_JPEGSetupEncode_def_void@
identifier F = JPEGSetupEncode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_JPEGSetupEncode_def_void@
F << extract_JPEGSetupEncode_def_void.F;
P << extract_JPEGSetupEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_JPEGSetupEncode_decl@
type T;
identifier F = JPEGSetupEncode;
parameter list P;
@@
T F(P);

@script:python depends on extract_JPEGSetupEncode_decl@
F << extract_JPEGSetupEncode_decl.F;
T << extract_JPEGSetupEncode_decl.T;
P << extract_JPEGSetupEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_JPEGSetupEncode_decl_void@
identifier F = JPEGSetupEncode;
parameter list P;
@@
void F(P);

@script:python depends on extract_JPEGSetupEncode_decl_void@
F << extract_JPEGSetupEncode_decl_void.F;
P << extract_JPEGSetupEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: JPEGVGetField
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_JPEGVGetField_def@
type T;
identifier F = JPEGVGetField;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_JPEGVGetField_def@
F << remove_static_JPEGVGetField_def.F;
T << remove_static_JPEGVGetField_def.T;
P << remove_static_JPEGVGetField_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_JPEGVGetField_def_void@
identifier F = JPEGVGetField;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_JPEGVGetField_def_void@
F << remove_static_JPEGVGetField_def_void.F;
P << remove_static_JPEGVGetField_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_JPEGVGetField_decl@
type T;
identifier F = JPEGVGetField;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_JPEGVGetField_decl@
F << remove_static_JPEGVGetField_decl.F;
T << remove_static_JPEGVGetField_decl.T;
P << remove_static_JPEGVGetField_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_JPEGVGetField_decl_void@
identifier F = JPEGVGetField;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_JPEGVGetField_decl_void@
F << remove_static_JPEGVGetField_decl_void.F;
P << remove_static_JPEGVGetField_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_JPEGVGetField_def@
type T;
identifier F = JPEGVGetField;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_JPEGVGetField_def@
F << extract_JPEGVGetField_def.F;
T << extract_JPEGVGetField_def.T;
P << extract_JPEGVGetField_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_JPEGVGetField_def_void@
identifier F = JPEGVGetField;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_JPEGVGetField_def_void@
F << extract_JPEGVGetField_def_void.F;
P << extract_JPEGVGetField_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_JPEGVGetField_decl@
type T;
identifier F = JPEGVGetField;
parameter list P;
@@
T F(P);

@script:python depends on extract_JPEGVGetField_decl@
F << extract_JPEGVGetField_decl.F;
T << extract_JPEGVGetField_decl.T;
P << extract_JPEGVGetField_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_JPEGVGetField_decl_void@
identifier F = JPEGVGetField;
parameter list P;
@@
void F(P);

@script:python depends on extract_JPEGVGetField_decl_void@
F << extract_JPEGVGetField_decl_void.F;
P << extract_JPEGVGetField_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: JPEGVSetField
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_JPEGVSetField_def@
type T;
identifier F = JPEGVSetField;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_JPEGVSetField_def@
F << remove_static_JPEGVSetField_def.F;
T << remove_static_JPEGVSetField_def.T;
P << remove_static_JPEGVSetField_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_JPEGVSetField_def_void@
identifier F = JPEGVSetField;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_JPEGVSetField_def_void@
F << remove_static_JPEGVSetField_def_void.F;
P << remove_static_JPEGVSetField_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_JPEGVSetField_decl@
type T;
identifier F = JPEGVSetField;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_JPEGVSetField_decl@
F << remove_static_JPEGVSetField_decl.F;
T << remove_static_JPEGVSetField_decl.T;
P << remove_static_JPEGVSetField_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_JPEGVSetField_decl_void@
identifier F = JPEGVSetField;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_JPEGVSetField_decl_void@
F << remove_static_JPEGVSetField_decl_void.F;
P << remove_static_JPEGVSetField_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_JPEGVSetField_def@
type T;
identifier F = JPEGVSetField;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_JPEGVSetField_def@
F << extract_JPEGVSetField_def.F;
T << extract_JPEGVSetField_def.T;
P << extract_JPEGVSetField_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_JPEGVSetField_def_void@
identifier F = JPEGVSetField;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_JPEGVSetField_def_void@
F << extract_JPEGVSetField_def_void.F;
P << extract_JPEGVSetField_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_JPEGVSetField_decl@
type T;
identifier F = JPEGVSetField;
parameter list P;
@@
T F(P);

@script:python depends on extract_JPEGVSetField_decl@
F << extract_JPEGVSetField_decl.F;
T << extract_JPEGVSetField_decl.T;
P << extract_JPEGVSetField_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_JPEGVSetField_decl_void@
identifier F = JPEGVSetField;
parameter list P;
@@
void F(P);

@script:python depends on extract_JPEGVSetField_decl_void@
F << extract_JPEGVSetField_decl_void.F;
P << extract_JPEGVSetField_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: L16fromY
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_L16fromY_def@
type T;
identifier F = L16fromY;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_L16fromY_def@
F << remove_static_L16fromY_def.F;
T << remove_static_L16fromY_def.T;
P << remove_static_L16fromY_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_L16fromY_def_void@
identifier F = L16fromY;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_L16fromY_def_void@
F << remove_static_L16fromY_def_void.F;
P << remove_static_L16fromY_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_L16fromY_decl@
type T;
identifier F = L16fromY;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_L16fromY_decl@
F << remove_static_L16fromY_decl.F;
T << remove_static_L16fromY_decl.T;
P << remove_static_L16fromY_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_L16fromY_decl_void@
identifier F = L16fromY;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_L16fromY_decl_void@
F << remove_static_L16fromY_decl_void.F;
P << remove_static_L16fromY_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_L16fromY_def@
type T;
identifier F = L16fromY;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_L16fromY_def@
F << extract_L16fromY_def.F;
T << extract_L16fromY_def.T;
P << extract_L16fromY_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_L16fromY_def_void@
identifier F = L16fromY;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_L16fromY_def_void@
F << extract_L16fromY_def_void.F;
P << extract_L16fromY_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_L16fromY_decl@
type T;
identifier F = L16fromY;
parameter list P;
@@
T F(P);

@script:python depends on extract_L16fromY_decl@
F << extract_L16fromY_decl.F;
T << extract_L16fromY_decl.T;
P << extract_L16fromY_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_L16fromY_decl_void@
identifier F = L16fromY;
parameter list P;
@@
void F(P);

@script:python depends on extract_L16fromY_decl_void@
F << extract_L16fromY_decl_void.F;
P << extract_L16fromY_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: L16toGry
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_L16toGry_def@
type T;
identifier F = L16toGry;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_L16toGry_def@
F << remove_static_L16toGry_def.F;
T << remove_static_L16toGry_def.T;
P << remove_static_L16toGry_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_L16toGry_def_void@
identifier F = L16toGry;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_L16toGry_def_void@
F << remove_static_L16toGry_def_void.F;
P << remove_static_L16toGry_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_L16toGry_decl@
type T;
identifier F = L16toGry;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_L16toGry_decl@
F << remove_static_L16toGry_decl.F;
T << remove_static_L16toGry_decl.T;
P << remove_static_L16toGry_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_L16toGry_decl_void@
identifier F = L16toGry;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_L16toGry_decl_void@
F << remove_static_L16toGry_decl_void.F;
P << remove_static_L16toGry_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_L16toGry_def@
type T;
identifier F = L16toGry;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_L16toGry_def@
F << extract_L16toGry_def.F;
T << extract_L16toGry_def.T;
P << extract_L16toGry_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_L16toGry_def_void@
identifier F = L16toGry;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_L16toGry_def_void@
F << extract_L16toGry_def_void.F;
P << extract_L16toGry_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_L16toGry_decl@
type T;
identifier F = L16toGry;
parameter list P;
@@
T F(P);

@script:python depends on extract_L16toGry_decl@
F << extract_L16toGry_decl.F;
T << extract_L16toGry_decl.T;
P << extract_L16toGry_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_L16toGry_decl_void@
identifier F = L16toGry;
parameter list P;
@@
void F(P);

@script:python depends on extract_L16toGry_decl_void@
F << extract_L16toGry_decl_void.F;
P << extract_L16toGry_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: L16toY
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_L16toY_def@
type T;
identifier F = L16toY;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_L16toY_def@
F << remove_static_L16toY_def.F;
T << remove_static_L16toY_def.T;
P << remove_static_L16toY_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_L16toY_def_void@
identifier F = L16toY;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_L16toY_def_void@
F << remove_static_L16toY_def_void.F;
P << remove_static_L16toY_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_L16toY_decl@
type T;
identifier F = L16toY;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_L16toY_decl@
F << remove_static_L16toY_decl.F;
T << remove_static_L16toY_decl.T;
P << remove_static_L16toY_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_L16toY_decl_void@
identifier F = L16toY;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_L16toY_decl_void@
F << remove_static_L16toY_decl_void.F;
P << remove_static_L16toY_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_L16toY_def@
type T;
identifier F = L16toY;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_L16toY_def@
F << extract_L16toY_def.F;
T << extract_L16toY_def.T;
P << extract_L16toY_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_L16toY_def_void@
identifier F = L16toY;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_L16toY_def_void@
F << extract_L16toY_def_void.F;
P << extract_L16toY_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_L16toY_decl@
type T;
identifier F = L16toY;
parameter list P;
@@
T F(P);

@script:python depends on extract_L16toY_decl@
F << extract_L16toY_decl.F;
T << extract_L16toY_decl.T;
P << extract_L16toY_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_L16toY_decl_void@
identifier F = L16toY;
parameter list P;
@@
void F(P);

@script:python depends on extract_L16toY_decl_void@
F << extract_L16toY_decl_void.F;
P << extract_L16toY_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: LERCCleanup
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_LERCCleanup_def@
type T;
identifier F = LERCCleanup;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_LERCCleanup_def@
F << remove_static_LERCCleanup_def.F;
T << remove_static_LERCCleanup_def.T;
P << remove_static_LERCCleanup_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_LERCCleanup_def_void@
identifier F = LERCCleanup;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_LERCCleanup_def_void@
F << remove_static_LERCCleanup_def_void.F;
P << remove_static_LERCCleanup_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_LERCCleanup_decl@
type T;
identifier F = LERCCleanup;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_LERCCleanup_decl@
F << remove_static_LERCCleanup_decl.F;
T << remove_static_LERCCleanup_decl.T;
P << remove_static_LERCCleanup_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_LERCCleanup_decl_void@
identifier F = LERCCleanup;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_LERCCleanup_decl_void@
F << remove_static_LERCCleanup_decl_void.F;
P << remove_static_LERCCleanup_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_LERCCleanup_def@
type T;
identifier F = LERCCleanup;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_LERCCleanup_def@
F << extract_LERCCleanup_def.F;
T << extract_LERCCleanup_def.T;
P << extract_LERCCleanup_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_LERCCleanup_def_void@
identifier F = LERCCleanup;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_LERCCleanup_def_void@
F << extract_LERCCleanup_def_void.F;
P << extract_LERCCleanup_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_LERCCleanup_decl@
type T;
identifier F = LERCCleanup;
parameter list P;
@@
T F(P);

@script:python depends on extract_LERCCleanup_decl@
F << extract_LERCCleanup_decl.F;
T << extract_LERCCleanup_decl.T;
P << extract_LERCCleanup_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_LERCCleanup_decl_void@
identifier F = LERCCleanup;
parameter list P;
@@
void F(P);

@script:python depends on extract_LERCCleanup_decl_void@
F << extract_LERCCleanup_decl_void.F;
P << extract_LERCCleanup_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: LERCDecode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_LERCDecode_def@
type T;
identifier F = LERCDecode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_LERCDecode_def@
F << remove_static_LERCDecode_def.F;
T << remove_static_LERCDecode_def.T;
P << remove_static_LERCDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_LERCDecode_def_void@
identifier F = LERCDecode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_LERCDecode_def_void@
F << remove_static_LERCDecode_def_void.F;
P << remove_static_LERCDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_LERCDecode_decl@
type T;
identifier F = LERCDecode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_LERCDecode_decl@
F << remove_static_LERCDecode_decl.F;
T << remove_static_LERCDecode_decl.T;
P << remove_static_LERCDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_LERCDecode_decl_void@
identifier F = LERCDecode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_LERCDecode_decl_void@
F << remove_static_LERCDecode_decl_void.F;
P << remove_static_LERCDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_LERCDecode_def@
type T;
identifier F = LERCDecode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_LERCDecode_def@
F << extract_LERCDecode_def.F;
T << extract_LERCDecode_def.T;
P << extract_LERCDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_LERCDecode_def_void@
identifier F = LERCDecode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_LERCDecode_def_void@
F << extract_LERCDecode_def_void.F;
P << extract_LERCDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_LERCDecode_decl@
type T;
identifier F = LERCDecode;
parameter list P;
@@
T F(P);

@script:python depends on extract_LERCDecode_decl@
F << extract_LERCDecode_decl.F;
T << extract_LERCDecode_decl.T;
P << extract_LERCDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_LERCDecode_decl_void@
identifier F = LERCDecode;
parameter list P;
@@
void F(P);

@script:python depends on extract_LERCDecode_decl_void@
F << extract_LERCDecode_decl_void.F;
P << extract_LERCDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: LERCEncode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_LERCEncode_def@
type T;
identifier F = LERCEncode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_LERCEncode_def@
F << remove_static_LERCEncode_def.F;
T << remove_static_LERCEncode_def.T;
P << remove_static_LERCEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_LERCEncode_def_void@
identifier F = LERCEncode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_LERCEncode_def_void@
F << remove_static_LERCEncode_def_void.F;
P << remove_static_LERCEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_LERCEncode_decl@
type T;
identifier F = LERCEncode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_LERCEncode_decl@
F << remove_static_LERCEncode_decl.F;
T << remove_static_LERCEncode_decl.T;
P << remove_static_LERCEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_LERCEncode_decl_void@
identifier F = LERCEncode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_LERCEncode_decl_void@
F << remove_static_LERCEncode_decl_void.F;
P << remove_static_LERCEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_LERCEncode_def@
type T;
identifier F = LERCEncode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_LERCEncode_def@
F << extract_LERCEncode_def.F;
T << extract_LERCEncode_def.T;
P << extract_LERCEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_LERCEncode_def_void@
identifier F = LERCEncode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_LERCEncode_def_void@
F << extract_LERCEncode_def_void.F;
P << extract_LERCEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_LERCEncode_decl@
type T;
identifier F = LERCEncode;
parameter list P;
@@
T F(P);

@script:python depends on extract_LERCEncode_decl@
F << extract_LERCEncode_decl.F;
T << extract_LERCEncode_decl.T;
P << extract_LERCEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_LERCEncode_decl_void@
identifier F = LERCEncode;
parameter list P;
@@
void F(P);

@script:python depends on extract_LERCEncode_decl_void@
F << extract_LERCEncode_decl_void.F;
P << extract_LERCEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: LERCFixupTags
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_LERCFixupTags_def@
type T;
identifier F = LERCFixupTags;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_LERCFixupTags_def@
F << remove_static_LERCFixupTags_def.F;
T << remove_static_LERCFixupTags_def.T;
P << remove_static_LERCFixupTags_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_LERCFixupTags_def_void@
identifier F = LERCFixupTags;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_LERCFixupTags_def_void@
F << remove_static_LERCFixupTags_def_void.F;
P << remove_static_LERCFixupTags_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_LERCFixupTags_decl@
type T;
identifier F = LERCFixupTags;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_LERCFixupTags_decl@
F << remove_static_LERCFixupTags_decl.F;
T << remove_static_LERCFixupTags_decl.T;
P << remove_static_LERCFixupTags_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_LERCFixupTags_decl_void@
identifier F = LERCFixupTags;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_LERCFixupTags_decl_void@
F << remove_static_LERCFixupTags_decl_void.F;
P << remove_static_LERCFixupTags_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_LERCFixupTags_def@
type T;
identifier F = LERCFixupTags;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_LERCFixupTags_def@
F << extract_LERCFixupTags_def.F;
T << extract_LERCFixupTags_def.T;
P << extract_LERCFixupTags_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_LERCFixupTags_def_void@
identifier F = LERCFixupTags;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_LERCFixupTags_def_void@
F << extract_LERCFixupTags_def_void.F;
P << extract_LERCFixupTags_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_LERCFixupTags_decl@
type T;
identifier F = LERCFixupTags;
parameter list P;
@@
T F(P);

@script:python depends on extract_LERCFixupTags_decl@
F << extract_LERCFixupTags_decl.F;
T << extract_LERCFixupTags_decl.T;
P << extract_LERCFixupTags_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_LERCFixupTags_decl_void@
identifier F = LERCFixupTags;
parameter list P;
@@
void F(P);

@script:python depends on extract_LERCFixupTags_decl_void@
F << extract_LERCFixupTags_decl_void.F;
P << extract_LERCFixupTags_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: LERCPostEncode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_LERCPostEncode_def@
type T;
identifier F = LERCPostEncode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_LERCPostEncode_def@
F << remove_static_LERCPostEncode_def.F;
T << remove_static_LERCPostEncode_def.T;
P << remove_static_LERCPostEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_LERCPostEncode_def_void@
identifier F = LERCPostEncode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_LERCPostEncode_def_void@
F << remove_static_LERCPostEncode_def_void.F;
P << remove_static_LERCPostEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_LERCPostEncode_decl@
type T;
identifier F = LERCPostEncode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_LERCPostEncode_decl@
F << remove_static_LERCPostEncode_decl.F;
T << remove_static_LERCPostEncode_decl.T;
P << remove_static_LERCPostEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_LERCPostEncode_decl_void@
identifier F = LERCPostEncode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_LERCPostEncode_decl_void@
F << remove_static_LERCPostEncode_decl_void.F;
P << remove_static_LERCPostEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_LERCPostEncode_def@
type T;
identifier F = LERCPostEncode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_LERCPostEncode_def@
F << extract_LERCPostEncode_def.F;
T << extract_LERCPostEncode_def.T;
P << extract_LERCPostEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_LERCPostEncode_def_void@
identifier F = LERCPostEncode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_LERCPostEncode_def_void@
F << extract_LERCPostEncode_def_void.F;
P << extract_LERCPostEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_LERCPostEncode_decl@
type T;
identifier F = LERCPostEncode;
parameter list P;
@@
T F(P);

@script:python depends on extract_LERCPostEncode_decl@
F << extract_LERCPostEncode_decl.F;
T << extract_LERCPostEncode_decl.T;
P << extract_LERCPostEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_LERCPostEncode_decl_void@
identifier F = LERCPostEncode;
parameter list P;
@@
void F(P);

@script:python depends on extract_LERCPostEncode_decl_void@
F << extract_LERCPostEncode_decl_void.F;
P << extract_LERCPostEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: LERCPreDecode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_LERCPreDecode_def@
type T;
identifier F = LERCPreDecode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_LERCPreDecode_def@
F << remove_static_LERCPreDecode_def.F;
T << remove_static_LERCPreDecode_def.T;
P << remove_static_LERCPreDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_LERCPreDecode_def_void@
identifier F = LERCPreDecode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_LERCPreDecode_def_void@
F << remove_static_LERCPreDecode_def_void.F;
P << remove_static_LERCPreDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_LERCPreDecode_decl@
type T;
identifier F = LERCPreDecode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_LERCPreDecode_decl@
F << remove_static_LERCPreDecode_decl.F;
T << remove_static_LERCPreDecode_decl.T;
P << remove_static_LERCPreDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_LERCPreDecode_decl_void@
identifier F = LERCPreDecode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_LERCPreDecode_decl_void@
F << remove_static_LERCPreDecode_decl_void.F;
P << remove_static_LERCPreDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_LERCPreDecode_def@
type T;
identifier F = LERCPreDecode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_LERCPreDecode_def@
F << extract_LERCPreDecode_def.F;
T << extract_LERCPreDecode_def.T;
P << extract_LERCPreDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_LERCPreDecode_def_void@
identifier F = LERCPreDecode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_LERCPreDecode_def_void@
F << extract_LERCPreDecode_def_void.F;
P << extract_LERCPreDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_LERCPreDecode_decl@
type T;
identifier F = LERCPreDecode;
parameter list P;
@@
T F(P);

@script:python depends on extract_LERCPreDecode_decl@
F << extract_LERCPreDecode_decl.F;
T << extract_LERCPreDecode_decl.T;
P << extract_LERCPreDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_LERCPreDecode_decl_void@
identifier F = LERCPreDecode;
parameter list P;
@@
void F(P);

@script:python depends on extract_LERCPreDecode_decl_void@
F << extract_LERCPreDecode_decl_void.F;
P << extract_LERCPreDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: LERCPreEncode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_LERCPreEncode_def@
type T;
identifier F = LERCPreEncode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_LERCPreEncode_def@
F << remove_static_LERCPreEncode_def.F;
T << remove_static_LERCPreEncode_def.T;
P << remove_static_LERCPreEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_LERCPreEncode_def_void@
identifier F = LERCPreEncode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_LERCPreEncode_def_void@
F << remove_static_LERCPreEncode_def_void.F;
P << remove_static_LERCPreEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_LERCPreEncode_decl@
type T;
identifier F = LERCPreEncode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_LERCPreEncode_decl@
F << remove_static_LERCPreEncode_decl.F;
T << remove_static_LERCPreEncode_decl.T;
P << remove_static_LERCPreEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_LERCPreEncode_decl_void@
identifier F = LERCPreEncode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_LERCPreEncode_decl_void@
F << remove_static_LERCPreEncode_decl_void.F;
P << remove_static_LERCPreEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_LERCPreEncode_def@
type T;
identifier F = LERCPreEncode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_LERCPreEncode_def@
F << extract_LERCPreEncode_def.F;
T << extract_LERCPreEncode_def.T;
P << extract_LERCPreEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_LERCPreEncode_def_void@
identifier F = LERCPreEncode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_LERCPreEncode_def_void@
F << extract_LERCPreEncode_def_void.F;
P << extract_LERCPreEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_LERCPreEncode_decl@
type T;
identifier F = LERCPreEncode;
parameter list P;
@@
T F(P);

@script:python depends on extract_LERCPreEncode_decl@
F << extract_LERCPreEncode_decl.F;
T << extract_LERCPreEncode_decl.T;
P << extract_LERCPreEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_LERCPreEncode_decl_void@
identifier F = LERCPreEncode;
parameter list P;
@@
void F(P);

@script:python depends on extract_LERCPreEncode_decl_void@
F << extract_LERCPreEncode_decl_void.F;
P << extract_LERCPreEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: LERCSetupDecode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_LERCSetupDecode_def@
type T;
identifier F = LERCSetupDecode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_LERCSetupDecode_def@
F << remove_static_LERCSetupDecode_def.F;
T << remove_static_LERCSetupDecode_def.T;
P << remove_static_LERCSetupDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_LERCSetupDecode_def_void@
identifier F = LERCSetupDecode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_LERCSetupDecode_def_void@
F << remove_static_LERCSetupDecode_def_void.F;
P << remove_static_LERCSetupDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_LERCSetupDecode_decl@
type T;
identifier F = LERCSetupDecode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_LERCSetupDecode_decl@
F << remove_static_LERCSetupDecode_decl.F;
T << remove_static_LERCSetupDecode_decl.T;
P << remove_static_LERCSetupDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_LERCSetupDecode_decl_void@
identifier F = LERCSetupDecode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_LERCSetupDecode_decl_void@
F << remove_static_LERCSetupDecode_decl_void.F;
P << remove_static_LERCSetupDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_LERCSetupDecode_def@
type T;
identifier F = LERCSetupDecode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_LERCSetupDecode_def@
F << extract_LERCSetupDecode_def.F;
T << extract_LERCSetupDecode_def.T;
P << extract_LERCSetupDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_LERCSetupDecode_def_void@
identifier F = LERCSetupDecode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_LERCSetupDecode_def_void@
F << extract_LERCSetupDecode_def_void.F;
P << extract_LERCSetupDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_LERCSetupDecode_decl@
type T;
identifier F = LERCSetupDecode;
parameter list P;
@@
T F(P);

@script:python depends on extract_LERCSetupDecode_decl@
F << extract_LERCSetupDecode_decl.F;
T << extract_LERCSetupDecode_decl.T;
P << extract_LERCSetupDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_LERCSetupDecode_decl_void@
identifier F = LERCSetupDecode;
parameter list P;
@@
void F(P);

@script:python depends on extract_LERCSetupDecode_decl_void@
F << extract_LERCSetupDecode_decl_void.F;
P << extract_LERCSetupDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: LERCSetupEncode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_LERCSetupEncode_def@
type T;
identifier F = LERCSetupEncode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_LERCSetupEncode_def@
F << remove_static_LERCSetupEncode_def.F;
T << remove_static_LERCSetupEncode_def.T;
P << remove_static_LERCSetupEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_LERCSetupEncode_def_void@
identifier F = LERCSetupEncode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_LERCSetupEncode_def_void@
F << remove_static_LERCSetupEncode_def_void.F;
P << remove_static_LERCSetupEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_LERCSetupEncode_decl@
type T;
identifier F = LERCSetupEncode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_LERCSetupEncode_decl@
F << remove_static_LERCSetupEncode_decl.F;
T << remove_static_LERCSetupEncode_decl.T;
P << remove_static_LERCSetupEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_LERCSetupEncode_decl_void@
identifier F = LERCSetupEncode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_LERCSetupEncode_decl_void@
F << remove_static_LERCSetupEncode_decl_void.F;
P << remove_static_LERCSetupEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_LERCSetupEncode_def@
type T;
identifier F = LERCSetupEncode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_LERCSetupEncode_def@
F << extract_LERCSetupEncode_def.F;
T << extract_LERCSetupEncode_def.T;
P << extract_LERCSetupEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_LERCSetupEncode_def_void@
identifier F = LERCSetupEncode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_LERCSetupEncode_def_void@
F << extract_LERCSetupEncode_def_void.F;
P << extract_LERCSetupEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_LERCSetupEncode_decl@
type T;
identifier F = LERCSetupEncode;
parameter list P;
@@
T F(P);

@script:python depends on extract_LERCSetupEncode_decl@
F << extract_LERCSetupEncode_decl.F;
T << extract_LERCSetupEncode_decl.T;
P << extract_LERCSetupEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_LERCSetupEncode_decl_void@
identifier F = LERCSetupEncode;
parameter list P;
@@
void F(P);

@script:python depends on extract_LERCSetupEncode_decl_void@
F << extract_LERCSetupEncode_decl_void.F;
P << extract_LERCSetupEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: LERCVGetField
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_LERCVGetField_def@
type T;
identifier F = LERCVGetField;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_LERCVGetField_def@
F << remove_static_LERCVGetField_def.F;
T << remove_static_LERCVGetField_def.T;
P << remove_static_LERCVGetField_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_LERCVGetField_def_void@
identifier F = LERCVGetField;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_LERCVGetField_def_void@
F << remove_static_LERCVGetField_def_void.F;
P << remove_static_LERCVGetField_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_LERCVGetField_decl@
type T;
identifier F = LERCVGetField;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_LERCVGetField_decl@
F << remove_static_LERCVGetField_decl.F;
T << remove_static_LERCVGetField_decl.T;
P << remove_static_LERCVGetField_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_LERCVGetField_decl_void@
identifier F = LERCVGetField;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_LERCVGetField_decl_void@
F << remove_static_LERCVGetField_decl_void.F;
P << remove_static_LERCVGetField_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_LERCVGetField_def@
type T;
identifier F = LERCVGetField;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_LERCVGetField_def@
F << extract_LERCVGetField_def.F;
T << extract_LERCVGetField_def.T;
P << extract_LERCVGetField_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_LERCVGetField_def_void@
identifier F = LERCVGetField;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_LERCVGetField_def_void@
F << extract_LERCVGetField_def_void.F;
P << extract_LERCVGetField_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_LERCVGetField_decl@
type T;
identifier F = LERCVGetField;
parameter list P;
@@
T F(P);

@script:python depends on extract_LERCVGetField_decl@
F << extract_LERCVGetField_decl.F;
T << extract_LERCVGetField_decl.T;
P << extract_LERCVGetField_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_LERCVGetField_decl_void@
identifier F = LERCVGetField;
parameter list P;
@@
void F(P);

@script:python depends on extract_LERCVGetField_decl_void@
F << extract_LERCVGetField_decl_void.F;
P << extract_LERCVGetField_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: LERCVSetField
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_LERCVSetField_def@
type T;
identifier F = LERCVSetField;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_LERCVSetField_def@
F << remove_static_LERCVSetField_def.F;
T << remove_static_LERCVSetField_def.T;
P << remove_static_LERCVSetField_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_LERCVSetField_def_void@
identifier F = LERCVSetField;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_LERCVSetField_def_void@
F << remove_static_LERCVSetField_def_void.F;
P << remove_static_LERCVSetField_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_LERCVSetField_decl@
type T;
identifier F = LERCVSetField;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_LERCVSetField_decl@
F << remove_static_LERCVSetField_decl.F;
T << remove_static_LERCVSetField_decl.T;
P << remove_static_LERCVSetField_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_LERCVSetField_decl_void@
identifier F = LERCVSetField;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_LERCVSetField_decl_void@
F << remove_static_LERCVSetField_decl_void.F;
P << remove_static_LERCVSetField_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_LERCVSetField_def@
type T;
identifier F = LERCVSetField;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_LERCVSetField_def@
F << extract_LERCVSetField_def.F;
T << extract_LERCVSetField_def.T;
P << extract_LERCVSetField_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_LERCVSetField_def_void@
identifier F = LERCVSetField;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_LERCVSetField_def_void@
F << extract_LERCVSetField_def_void.F;
P << extract_LERCVSetField_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_LERCVSetField_decl@
type T;
identifier F = LERCVSetField;
parameter list P;
@@
T F(P);

@script:python depends on extract_LERCVSetField_decl@
F << extract_LERCVSetField_decl.F;
T << extract_LERCVSetField_decl.T;
P << extract_LERCVSetField_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_LERCVSetField_decl_void@
identifier F = LERCVSetField;
parameter list P;
@@
void F(P);

@script:python depends on extract_LERCVSetField_decl_void@
F << extract_LERCVSetField_decl_void.F;
P << extract_LERCVSetField_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: LZMACleanup
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_LZMACleanup_def@
type T;
identifier F = LZMACleanup;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_LZMACleanup_def@
F << remove_static_LZMACleanup_def.F;
T << remove_static_LZMACleanup_def.T;
P << remove_static_LZMACleanup_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_LZMACleanup_def_void@
identifier F = LZMACleanup;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_LZMACleanup_def_void@
F << remove_static_LZMACleanup_def_void.F;
P << remove_static_LZMACleanup_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_LZMACleanup_decl@
type T;
identifier F = LZMACleanup;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_LZMACleanup_decl@
F << remove_static_LZMACleanup_decl.F;
T << remove_static_LZMACleanup_decl.T;
P << remove_static_LZMACleanup_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_LZMACleanup_decl_void@
identifier F = LZMACleanup;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_LZMACleanup_decl_void@
F << remove_static_LZMACleanup_decl_void.F;
P << remove_static_LZMACleanup_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_LZMACleanup_def@
type T;
identifier F = LZMACleanup;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_LZMACleanup_def@
F << extract_LZMACleanup_def.F;
T << extract_LZMACleanup_def.T;
P << extract_LZMACleanup_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_LZMACleanup_def_void@
identifier F = LZMACleanup;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_LZMACleanup_def_void@
F << extract_LZMACleanup_def_void.F;
P << extract_LZMACleanup_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_LZMACleanup_decl@
type T;
identifier F = LZMACleanup;
parameter list P;
@@
T F(P);

@script:python depends on extract_LZMACleanup_decl@
F << extract_LZMACleanup_decl.F;
T << extract_LZMACleanup_decl.T;
P << extract_LZMACleanup_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_LZMACleanup_decl_void@
identifier F = LZMACleanup;
parameter list P;
@@
void F(P);

@script:python depends on extract_LZMACleanup_decl_void@
F << extract_LZMACleanup_decl_void.F;
P << extract_LZMACleanup_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: LZMADecode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_LZMADecode_def@
type T;
identifier F = LZMADecode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_LZMADecode_def@
F << remove_static_LZMADecode_def.F;
T << remove_static_LZMADecode_def.T;
P << remove_static_LZMADecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_LZMADecode_def_void@
identifier F = LZMADecode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_LZMADecode_def_void@
F << remove_static_LZMADecode_def_void.F;
P << remove_static_LZMADecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_LZMADecode_decl@
type T;
identifier F = LZMADecode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_LZMADecode_decl@
F << remove_static_LZMADecode_decl.F;
T << remove_static_LZMADecode_decl.T;
P << remove_static_LZMADecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_LZMADecode_decl_void@
identifier F = LZMADecode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_LZMADecode_decl_void@
F << remove_static_LZMADecode_decl_void.F;
P << remove_static_LZMADecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_LZMADecode_def@
type T;
identifier F = LZMADecode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_LZMADecode_def@
F << extract_LZMADecode_def.F;
T << extract_LZMADecode_def.T;
P << extract_LZMADecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_LZMADecode_def_void@
identifier F = LZMADecode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_LZMADecode_def_void@
F << extract_LZMADecode_def_void.F;
P << extract_LZMADecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_LZMADecode_decl@
type T;
identifier F = LZMADecode;
parameter list P;
@@
T F(P);

@script:python depends on extract_LZMADecode_decl@
F << extract_LZMADecode_decl.F;
T << extract_LZMADecode_decl.T;
P << extract_LZMADecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_LZMADecode_decl_void@
identifier F = LZMADecode;
parameter list P;
@@
void F(P);

@script:python depends on extract_LZMADecode_decl_void@
F << extract_LZMADecode_decl_void.F;
P << extract_LZMADecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: LZMAEncode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_LZMAEncode_def@
type T;
identifier F = LZMAEncode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_LZMAEncode_def@
F << remove_static_LZMAEncode_def.F;
T << remove_static_LZMAEncode_def.T;
P << remove_static_LZMAEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_LZMAEncode_def_void@
identifier F = LZMAEncode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_LZMAEncode_def_void@
F << remove_static_LZMAEncode_def_void.F;
P << remove_static_LZMAEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_LZMAEncode_decl@
type T;
identifier F = LZMAEncode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_LZMAEncode_decl@
F << remove_static_LZMAEncode_decl.F;
T << remove_static_LZMAEncode_decl.T;
P << remove_static_LZMAEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_LZMAEncode_decl_void@
identifier F = LZMAEncode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_LZMAEncode_decl_void@
F << remove_static_LZMAEncode_decl_void.F;
P << remove_static_LZMAEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_LZMAEncode_def@
type T;
identifier F = LZMAEncode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_LZMAEncode_def@
F << extract_LZMAEncode_def.F;
T << extract_LZMAEncode_def.T;
P << extract_LZMAEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_LZMAEncode_def_void@
identifier F = LZMAEncode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_LZMAEncode_def_void@
F << extract_LZMAEncode_def_void.F;
P << extract_LZMAEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_LZMAEncode_decl@
type T;
identifier F = LZMAEncode;
parameter list P;
@@
T F(P);

@script:python depends on extract_LZMAEncode_decl@
F << extract_LZMAEncode_decl.F;
T << extract_LZMAEncode_decl.T;
P << extract_LZMAEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_LZMAEncode_decl_void@
identifier F = LZMAEncode;
parameter list P;
@@
void F(P);

@script:python depends on extract_LZMAEncode_decl_void@
F << extract_LZMAEncode_decl_void.F;
P << extract_LZMAEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: LZMAFixupTags
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_LZMAFixupTags_def@
type T;
identifier F = LZMAFixupTags;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_LZMAFixupTags_def@
F << remove_static_LZMAFixupTags_def.F;
T << remove_static_LZMAFixupTags_def.T;
P << remove_static_LZMAFixupTags_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_LZMAFixupTags_def_void@
identifier F = LZMAFixupTags;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_LZMAFixupTags_def_void@
F << remove_static_LZMAFixupTags_def_void.F;
P << remove_static_LZMAFixupTags_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_LZMAFixupTags_decl@
type T;
identifier F = LZMAFixupTags;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_LZMAFixupTags_decl@
F << remove_static_LZMAFixupTags_decl.F;
T << remove_static_LZMAFixupTags_decl.T;
P << remove_static_LZMAFixupTags_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_LZMAFixupTags_decl_void@
identifier F = LZMAFixupTags;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_LZMAFixupTags_decl_void@
F << remove_static_LZMAFixupTags_decl_void.F;
P << remove_static_LZMAFixupTags_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_LZMAFixupTags_def@
type T;
identifier F = LZMAFixupTags;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_LZMAFixupTags_def@
F << extract_LZMAFixupTags_def.F;
T << extract_LZMAFixupTags_def.T;
P << extract_LZMAFixupTags_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_LZMAFixupTags_def_void@
identifier F = LZMAFixupTags;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_LZMAFixupTags_def_void@
F << extract_LZMAFixupTags_def_void.F;
P << extract_LZMAFixupTags_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_LZMAFixupTags_decl@
type T;
identifier F = LZMAFixupTags;
parameter list P;
@@
T F(P);

@script:python depends on extract_LZMAFixupTags_decl@
F << extract_LZMAFixupTags_decl.F;
T << extract_LZMAFixupTags_decl.T;
P << extract_LZMAFixupTags_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_LZMAFixupTags_decl_void@
identifier F = LZMAFixupTags;
parameter list P;
@@
void F(P);

@script:python depends on extract_LZMAFixupTags_decl_void@
F << extract_LZMAFixupTags_decl_void.F;
P << extract_LZMAFixupTags_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: LZMAPostEncode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_LZMAPostEncode_def@
type T;
identifier F = LZMAPostEncode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_LZMAPostEncode_def@
F << remove_static_LZMAPostEncode_def.F;
T << remove_static_LZMAPostEncode_def.T;
P << remove_static_LZMAPostEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_LZMAPostEncode_def_void@
identifier F = LZMAPostEncode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_LZMAPostEncode_def_void@
F << remove_static_LZMAPostEncode_def_void.F;
P << remove_static_LZMAPostEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_LZMAPostEncode_decl@
type T;
identifier F = LZMAPostEncode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_LZMAPostEncode_decl@
F << remove_static_LZMAPostEncode_decl.F;
T << remove_static_LZMAPostEncode_decl.T;
P << remove_static_LZMAPostEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_LZMAPostEncode_decl_void@
identifier F = LZMAPostEncode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_LZMAPostEncode_decl_void@
F << remove_static_LZMAPostEncode_decl_void.F;
P << remove_static_LZMAPostEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_LZMAPostEncode_def@
type T;
identifier F = LZMAPostEncode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_LZMAPostEncode_def@
F << extract_LZMAPostEncode_def.F;
T << extract_LZMAPostEncode_def.T;
P << extract_LZMAPostEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_LZMAPostEncode_def_void@
identifier F = LZMAPostEncode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_LZMAPostEncode_def_void@
F << extract_LZMAPostEncode_def_void.F;
P << extract_LZMAPostEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_LZMAPostEncode_decl@
type T;
identifier F = LZMAPostEncode;
parameter list P;
@@
T F(P);

@script:python depends on extract_LZMAPostEncode_decl@
F << extract_LZMAPostEncode_decl.F;
T << extract_LZMAPostEncode_decl.T;
P << extract_LZMAPostEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_LZMAPostEncode_decl_void@
identifier F = LZMAPostEncode;
parameter list P;
@@
void F(P);

@script:python depends on extract_LZMAPostEncode_decl_void@
F << extract_LZMAPostEncode_decl_void.F;
P << extract_LZMAPostEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: LZMAPreDecode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_LZMAPreDecode_def@
type T;
identifier F = LZMAPreDecode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_LZMAPreDecode_def@
F << remove_static_LZMAPreDecode_def.F;
T << remove_static_LZMAPreDecode_def.T;
P << remove_static_LZMAPreDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_LZMAPreDecode_def_void@
identifier F = LZMAPreDecode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_LZMAPreDecode_def_void@
F << remove_static_LZMAPreDecode_def_void.F;
P << remove_static_LZMAPreDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_LZMAPreDecode_decl@
type T;
identifier F = LZMAPreDecode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_LZMAPreDecode_decl@
F << remove_static_LZMAPreDecode_decl.F;
T << remove_static_LZMAPreDecode_decl.T;
P << remove_static_LZMAPreDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_LZMAPreDecode_decl_void@
identifier F = LZMAPreDecode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_LZMAPreDecode_decl_void@
F << remove_static_LZMAPreDecode_decl_void.F;
P << remove_static_LZMAPreDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_LZMAPreDecode_def@
type T;
identifier F = LZMAPreDecode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_LZMAPreDecode_def@
F << extract_LZMAPreDecode_def.F;
T << extract_LZMAPreDecode_def.T;
P << extract_LZMAPreDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_LZMAPreDecode_def_void@
identifier F = LZMAPreDecode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_LZMAPreDecode_def_void@
F << extract_LZMAPreDecode_def_void.F;
P << extract_LZMAPreDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_LZMAPreDecode_decl@
type T;
identifier F = LZMAPreDecode;
parameter list P;
@@
T F(P);

@script:python depends on extract_LZMAPreDecode_decl@
F << extract_LZMAPreDecode_decl.F;
T << extract_LZMAPreDecode_decl.T;
P << extract_LZMAPreDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_LZMAPreDecode_decl_void@
identifier F = LZMAPreDecode;
parameter list P;
@@
void F(P);

@script:python depends on extract_LZMAPreDecode_decl_void@
F << extract_LZMAPreDecode_decl_void.F;
P << extract_LZMAPreDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: LZMAPreEncode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_LZMAPreEncode_def@
type T;
identifier F = LZMAPreEncode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_LZMAPreEncode_def@
F << remove_static_LZMAPreEncode_def.F;
T << remove_static_LZMAPreEncode_def.T;
P << remove_static_LZMAPreEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_LZMAPreEncode_def_void@
identifier F = LZMAPreEncode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_LZMAPreEncode_def_void@
F << remove_static_LZMAPreEncode_def_void.F;
P << remove_static_LZMAPreEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_LZMAPreEncode_decl@
type T;
identifier F = LZMAPreEncode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_LZMAPreEncode_decl@
F << remove_static_LZMAPreEncode_decl.F;
T << remove_static_LZMAPreEncode_decl.T;
P << remove_static_LZMAPreEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_LZMAPreEncode_decl_void@
identifier F = LZMAPreEncode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_LZMAPreEncode_decl_void@
F << remove_static_LZMAPreEncode_decl_void.F;
P << remove_static_LZMAPreEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_LZMAPreEncode_def@
type T;
identifier F = LZMAPreEncode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_LZMAPreEncode_def@
F << extract_LZMAPreEncode_def.F;
T << extract_LZMAPreEncode_def.T;
P << extract_LZMAPreEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_LZMAPreEncode_def_void@
identifier F = LZMAPreEncode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_LZMAPreEncode_def_void@
F << extract_LZMAPreEncode_def_void.F;
P << extract_LZMAPreEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_LZMAPreEncode_decl@
type T;
identifier F = LZMAPreEncode;
parameter list P;
@@
T F(P);

@script:python depends on extract_LZMAPreEncode_decl@
F << extract_LZMAPreEncode_decl.F;
T << extract_LZMAPreEncode_decl.T;
P << extract_LZMAPreEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_LZMAPreEncode_decl_void@
identifier F = LZMAPreEncode;
parameter list P;
@@
void F(P);

@script:python depends on extract_LZMAPreEncode_decl_void@
F << extract_LZMAPreEncode_decl_void.F;
P << extract_LZMAPreEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: LZMASetupDecode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_LZMASetupDecode_def@
type T;
identifier F = LZMASetupDecode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_LZMASetupDecode_def@
F << remove_static_LZMASetupDecode_def.F;
T << remove_static_LZMASetupDecode_def.T;
P << remove_static_LZMASetupDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_LZMASetupDecode_def_void@
identifier F = LZMASetupDecode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_LZMASetupDecode_def_void@
F << remove_static_LZMASetupDecode_def_void.F;
P << remove_static_LZMASetupDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_LZMASetupDecode_decl@
type T;
identifier F = LZMASetupDecode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_LZMASetupDecode_decl@
F << remove_static_LZMASetupDecode_decl.F;
T << remove_static_LZMASetupDecode_decl.T;
P << remove_static_LZMASetupDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_LZMASetupDecode_decl_void@
identifier F = LZMASetupDecode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_LZMASetupDecode_decl_void@
F << remove_static_LZMASetupDecode_decl_void.F;
P << remove_static_LZMASetupDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_LZMASetupDecode_def@
type T;
identifier F = LZMASetupDecode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_LZMASetupDecode_def@
F << extract_LZMASetupDecode_def.F;
T << extract_LZMASetupDecode_def.T;
P << extract_LZMASetupDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_LZMASetupDecode_def_void@
identifier F = LZMASetupDecode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_LZMASetupDecode_def_void@
F << extract_LZMASetupDecode_def_void.F;
P << extract_LZMASetupDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_LZMASetupDecode_decl@
type T;
identifier F = LZMASetupDecode;
parameter list P;
@@
T F(P);

@script:python depends on extract_LZMASetupDecode_decl@
F << extract_LZMASetupDecode_decl.F;
T << extract_LZMASetupDecode_decl.T;
P << extract_LZMASetupDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_LZMASetupDecode_decl_void@
identifier F = LZMASetupDecode;
parameter list P;
@@
void F(P);

@script:python depends on extract_LZMASetupDecode_decl_void@
F << extract_LZMASetupDecode_decl_void.F;
P << extract_LZMASetupDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: LZMASetupEncode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_LZMASetupEncode_def@
type T;
identifier F = LZMASetupEncode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_LZMASetupEncode_def@
F << remove_static_LZMASetupEncode_def.F;
T << remove_static_LZMASetupEncode_def.T;
P << remove_static_LZMASetupEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_LZMASetupEncode_def_void@
identifier F = LZMASetupEncode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_LZMASetupEncode_def_void@
F << remove_static_LZMASetupEncode_def_void.F;
P << remove_static_LZMASetupEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_LZMASetupEncode_decl@
type T;
identifier F = LZMASetupEncode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_LZMASetupEncode_decl@
F << remove_static_LZMASetupEncode_decl.F;
T << remove_static_LZMASetupEncode_decl.T;
P << remove_static_LZMASetupEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_LZMASetupEncode_decl_void@
identifier F = LZMASetupEncode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_LZMASetupEncode_decl_void@
F << remove_static_LZMASetupEncode_decl_void.F;
P << remove_static_LZMASetupEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_LZMASetupEncode_def@
type T;
identifier F = LZMASetupEncode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_LZMASetupEncode_def@
F << extract_LZMASetupEncode_def.F;
T << extract_LZMASetupEncode_def.T;
P << extract_LZMASetupEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_LZMASetupEncode_def_void@
identifier F = LZMASetupEncode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_LZMASetupEncode_def_void@
F << extract_LZMASetupEncode_def_void.F;
P << extract_LZMASetupEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_LZMASetupEncode_decl@
type T;
identifier F = LZMASetupEncode;
parameter list P;
@@
T F(P);

@script:python depends on extract_LZMASetupEncode_decl@
F << extract_LZMASetupEncode_decl.F;
T << extract_LZMASetupEncode_decl.T;
P << extract_LZMASetupEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_LZMASetupEncode_decl_void@
identifier F = LZMASetupEncode;
parameter list P;
@@
void F(P);

@script:python depends on extract_LZMASetupEncode_decl_void@
F << extract_LZMASetupEncode_decl_void.F;
P << extract_LZMASetupEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: LZMAVGetField
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_LZMAVGetField_def@
type T;
identifier F = LZMAVGetField;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_LZMAVGetField_def@
F << remove_static_LZMAVGetField_def.F;
T << remove_static_LZMAVGetField_def.T;
P << remove_static_LZMAVGetField_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_LZMAVGetField_def_void@
identifier F = LZMAVGetField;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_LZMAVGetField_def_void@
F << remove_static_LZMAVGetField_def_void.F;
P << remove_static_LZMAVGetField_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_LZMAVGetField_decl@
type T;
identifier F = LZMAVGetField;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_LZMAVGetField_decl@
F << remove_static_LZMAVGetField_decl.F;
T << remove_static_LZMAVGetField_decl.T;
P << remove_static_LZMAVGetField_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_LZMAVGetField_decl_void@
identifier F = LZMAVGetField;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_LZMAVGetField_decl_void@
F << remove_static_LZMAVGetField_decl_void.F;
P << remove_static_LZMAVGetField_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_LZMAVGetField_def@
type T;
identifier F = LZMAVGetField;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_LZMAVGetField_def@
F << extract_LZMAVGetField_def.F;
T << extract_LZMAVGetField_def.T;
P << extract_LZMAVGetField_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_LZMAVGetField_def_void@
identifier F = LZMAVGetField;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_LZMAVGetField_def_void@
F << extract_LZMAVGetField_def_void.F;
P << extract_LZMAVGetField_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_LZMAVGetField_decl@
type T;
identifier F = LZMAVGetField;
parameter list P;
@@
T F(P);

@script:python depends on extract_LZMAVGetField_decl@
F << extract_LZMAVGetField_decl.F;
T << extract_LZMAVGetField_decl.T;
P << extract_LZMAVGetField_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_LZMAVGetField_decl_void@
identifier F = LZMAVGetField;
parameter list P;
@@
void F(P);

@script:python depends on extract_LZMAVGetField_decl_void@
F << extract_LZMAVGetField_decl_void.F;
P << extract_LZMAVGetField_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: LZMAVSetField
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_LZMAVSetField_def@
type T;
identifier F = LZMAVSetField;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_LZMAVSetField_def@
F << remove_static_LZMAVSetField_def.F;
T << remove_static_LZMAVSetField_def.T;
P << remove_static_LZMAVSetField_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_LZMAVSetField_def_void@
identifier F = LZMAVSetField;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_LZMAVSetField_def_void@
F << remove_static_LZMAVSetField_def_void.F;
P << remove_static_LZMAVSetField_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_LZMAVSetField_decl@
type T;
identifier F = LZMAVSetField;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_LZMAVSetField_decl@
F << remove_static_LZMAVSetField_decl.F;
T << remove_static_LZMAVSetField_decl.T;
P << remove_static_LZMAVSetField_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_LZMAVSetField_decl_void@
identifier F = LZMAVSetField;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_LZMAVSetField_decl_void@
F << remove_static_LZMAVSetField_decl_void.F;
P << remove_static_LZMAVSetField_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_LZMAVSetField_def@
type T;
identifier F = LZMAVSetField;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_LZMAVSetField_def@
F << extract_LZMAVSetField_def.F;
T << extract_LZMAVSetField_def.T;
P << extract_LZMAVSetField_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_LZMAVSetField_def_void@
identifier F = LZMAVSetField;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_LZMAVSetField_def_void@
F << extract_LZMAVSetField_def_void.F;
P << extract_LZMAVSetField_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_LZMAVSetField_decl@
type T;
identifier F = LZMAVSetField;
parameter list P;
@@
T F(P);

@script:python depends on extract_LZMAVSetField_decl@
F << extract_LZMAVSetField_decl.F;
T << extract_LZMAVSetField_decl.T;
P << extract_LZMAVSetField_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_LZMAVSetField_decl_void@
identifier F = LZMAVSetField;
parameter list P;
@@
void F(P);

@script:python depends on extract_LZMAVSetField_decl_void@
F << extract_LZMAVSetField_decl_void.F;
P << extract_LZMAVSetField_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: LZWCleanup
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_LZWCleanup_def@
type T;
identifier F = LZWCleanup;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_LZWCleanup_def@
F << remove_static_LZWCleanup_def.F;
T << remove_static_LZWCleanup_def.T;
P << remove_static_LZWCleanup_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_LZWCleanup_def_void@
identifier F = LZWCleanup;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_LZWCleanup_def_void@
F << remove_static_LZWCleanup_def_void.F;
P << remove_static_LZWCleanup_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_LZWCleanup_decl@
type T;
identifier F = LZWCleanup;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_LZWCleanup_decl@
F << remove_static_LZWCleanup_decl.F;
T << remove_static_LZWCleanup_decl.T;
P << remove_static_LZWCleanup_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_LZWCleanup_decl_void@
identifier F = LZWCleanup;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_LZWCleanup_decl_void@
F << remove_static_LZWCleanup_decl_void.F;
P << remove_static_LZWCleanup_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_LZWCleanup_def@
type T;
identifier F = LZWCleanup;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_LZWCleanup_def@
F << extract_LZWCleanup_def.F;
T << extract_LZWCleanup_def.T;
P << extract_LZWCleanup_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_LZWCleanup_def_void@
identifier F = LZWCleanup;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_LZWCleanup_def_void@
F << extract_LZWCleanup_def_void.F;
P << extract_LZWCleanup_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_LZWCleanup_decl@
type T;
identifier F = LZWCleanup;
parameter list P;
@@
T F(P);

@script:python depends on extract_LZWCleanup_decl@
F << extract_LZWCleanup_decl.F;
T << extract_LZWCleanup_decl.T;
P << extract_LZWCleanup_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_LZWCleanup_decl_void@
identifier F = LZWCleanup;
parameter list P;
@@
void F(P);

@script:python depends on extract_LZWCleanup_decl_void@
F << extract_LZWCleanup_decl_void.F;
P << extract_LZWCleanup_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: LZWDecode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_LZWDecode_def@
type T;
identifier F = LZWDecode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_LZWDecode_def@
F << remove_static_LZWDecode_def.F;
T << remove_static_LZWDecode_def.T;
P << remove_static_LZWDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_LZWDecode_def_void@
identifier F = LZWDecode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_LZWDecode_def_void@
F << remove_static_LZWDecode_def_void.F;
P << remove_static_LZWDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_LZWDecode_decl@
type T;
identifier F = LZWDecode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_LZWDecode_decl@
F << remove_static_LZWDecode_decl.F;
T << remove_static_LZWDecode_decl.T;
P << remove_static_LZWDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_LZWDecode_decl_void@
identifier F = LZWDecode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_LZWDecode_decl_void@
F << remove_static_LZWDecode_decl_void.F;
P << remove_static_LZWDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_LZWDecode_def@
type T;
identifier F = LZWDecode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_LZWDecode_def@
F << extract_LZWDecode_def.F;
T << extract_LZWDecode_def.T;
P << extract_LZWDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_LZWDecode_def_void@
identifier F = LZWDecode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_LZWDecode_def_void@
F << extract_LZWDecode_def_void.F;
P << extract_LZWDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_LZWDecode_decl@
type T;
identifier F = LZWDecode;
parameter list P;
@@
T F(P);

@script:python depends on extract_LZWDecode_decl@
F << extract_LZWDecode_decl.F;
T << extract_LZWDecode_decl.T;
P << extract_LZWDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_LZWDecode_decl_void@
identifier F = LZWDecode;
parameter list P;
@@
void F(P);

@script:python depends on extract_LZWDecode_decl_void@
F << extract_LZWDecode_decl_void.F;
P << extract_LZWDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: LZWDecodeCompat
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_LZWDecodeCompat_def@
type T;
identifier F = LZWDecodeCompat;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_LZWDecodeCompat_def@
F << remove_static_LZWDecodeCompat_def.F;
T << remove_static_LZWDecodeCompat_def.T;
P << remove_static_LZWDecodeCompat_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_LZWDecodeCompat_def_void@
identifier F = LZWDecodeCompat;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_LZWDecodeCompat_def_void@
F << remove_static_LZWDecodeCompat_def_void.F;
P << remove_static_LZWDecodeCompat_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_LZWDecodeCompat_decl@
type T;
identifier F = LZWDecodeCompat;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_LZWDecodeCompat_decl@
F << remove_static_LZWDecodeCompat_decl.F;
T << remove_static_LZWDecodeCompat_decl.T;
P << remove_static_LZWDecodeCompat_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_LZWDecodeCompat_decl_void@
identifier F = LZWDecodeCompat;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_LZWDecodeCompat_decl_void@
F << remove_static_LZWDecodeCompat_decl_void.F;
P << remove_static_LZWDecodeCompat_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_LZWDecodeCompat_def@
type T;
identifier F = LZWDecodeCompat;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_LZWDecodeCompat_def@
F << extract_LZWDecodeCompat_def.F;
T << extract_LZWDecodeCompat_def.T;
P << extract_LZWDecodeCompat_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_LZWDecodeCompat_def_void@
identifier F = LZWDecodeCompat;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_LZWDecodeCompat_def_void@
F << extract_LZWDecodeCompat_def_void.F;
P << extract_LZWDecodeCompat_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_LZWDecodeCompat_decl@
type T;
identifier F = LZWDecodeCompat;
parameter list P;
@@
T F(P);

@script:python depends on extract_LZWDecodeCompat_decl@
F << extract_LZWDecodeCompat_decl.F;
T << extract_LZWDecodeCompat_decl.T;
P << extract_LZWDecodeCompat_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_LZWDecodeCompat_decl_void@
identifier F = LZWDecodeCompat;
parameter list P;
@@
void F(P);

@script:python depends on extract_LZWDecodeCompat_decl_void@
F << extract_LZWDecodeCompat_decl_void.F;
P << extract_LZWDecodeCompat_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: LZWEncode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_LZWEncode_def@
type T;
identifier F = LZWEncode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_LZWEncode_def@
F << remove_static_LZWEncode_def.F;
T << remove_static_LZWEncode_def.T;
P << remove_static_LZWEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_LZWEncode_def_void@
identifier F = LZWEncode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_LZWEncode_def_void@
F << remove_static_LZWEncode_def_void.F;
P << remove_static_LZWEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_LZWEncode_decl@
type T;
identifier F = LZWEncode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_LZWEncode_decl@
F << remove_static_LZWEncode_decl.F;
T << remove_static_LZWEncode_decl.T;
P << remove_static_LZWEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_LZWEncode_decl_void@
identifier F = LZWEncode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_LZWEncode_decl_void@
F << remove_static_LZWEncode_decl_void.F;
P << remove_static_LZWEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_LZWEncode_def@
type T;
identifier F = LZWEncode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_LZWEncode_def@
F << extract_LZWEncode_def.F;
T << extract_LZWEncode_def.T;
P << extract_LZWEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_LZWEncode_def_void@
identifier F = LZWEncode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_LZWEncode_def_void@
F << extract_LZWEncode_def_void.F;
P << extract_LZWEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_LZWEncode_decl@
type T;
identifier F = LZWEncode;
parameter list P;
@@
T F(P);

@script:python depends on extract_LZWEncode_decl@
F << extract_LZWEncode_decl.F;
T << extract_LZWEncode_decl.T;
P << extract_LZWEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_LZWEncode_decl_void@
identifier F = LZWEncode;
parameter list P;
@@
void F(P);

@script:python depends on extract_LZWEncode_decl_void@
F << extract_LZWEncode_decl_void.F;
P << extract_LZWEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: LZWFixupTags
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_LZWFixupTags_def@
type T;
identifier F = LZWFixupTags;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_LZWFixupTags_def@
F << remove_static_LZWFixupTags_def.F;
T << remove_static_LZWFixupTags_def.T;
P << remove_static_LZWFixupTags_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_LZWFixupTags_def_void@
identifier F = LZWFixupTags;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_LZWFixupTags_def_void@
F << remove_static_LZWFixupTags_def_void.F;
P << remove_static_LZWFixupTags_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_LZWFixupTags_decl@
type T;
identifier F = LZWFixupTags;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_LZWFixupTags_decl@
F << remove_static_LZWFixupTags_decl.F;
T << remove_static_LZWFixupTags_decl.T;
P << remove_static_LZWFixupTags_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_LZWFixupTags_decl_void@
identifier F = LZWFixupTags;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_LZWFixupTags_decl_void@
F << remove_static_LZWFixupTags_decl_void.F;
P << remove_static_LZWFixupTags_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_LZWFixupTags_def@
type T;
identifier F = LZWFixupTags;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_LZWFixupTags_def@
F << extract_LZWFixupTags_def.F;
T << extract_LZWFixupTags_def.T;
P << extract_LZWFixupTags_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_LZWFixupTags_def_void@
identifier F = LZWFixupTags;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_LZWFixupTags_def_void@
F << extract_LZWFixupTags_def_void.F;
P << extract_LZWFixupTags_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_LZWFixupTags_decl@
type T;
identifier F = LZWFixupTags;
parameter list P;
@@
T F(P);

@script:python depends on extract_LZWFixupTags_decl@
F << extract_LZWFixupTags_decl.F;
T << extract_LZWFixupTags_decl.T;
P << extract_LZWFixupTags_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_LZWFixupTags_decl_void@
identifier F = LZWFixupTags;
parameter list P;
@@
void F(P);

@script:python depends on extract_LZWFixupTags_decl_void@
F << extract_LZWFixupTags_decl_void.F;
P << extract_LZWFixupTags_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: LZWPostEncode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_LZWPostEncode_def@
type T;
identifier F = LZWPostEncode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_LZWPostEncode_def@
F << remove_static_LZWPostEncode_def.F;
T << remove_static_LZWPostEncode_def.T;
P << remove_static_LZWPostEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_LZWPostEncode_def_void@
identifier F = LZWPostEncode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_LZWPostEncode_def_void@
F << remove_static_LZWPostEncode_def_void.F;
P << remove_static_LZWPostEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_LZWPostEncode_decl@
type T;
identifier F = LZWPostEncode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_LZWPostEncode_decl@
F << remove_static_LZWPostEncode_decl.F;
T << remove_static_LZWPostEncode_decl.T;
P << remove_static_LZWPostEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_LZWPostEncode_decl_void@
identifier F = LZWPostEncode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_LZWPostEncode_decl_void@
F << remove_static_LZWPostEncode_decl_void.F;
P << remove_static_LZWPostEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_LZWPostEncode_def@
type T;
identifier F = LZWPostEncode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_LZWPostEncode_def@
F << extract_LZWPostEncode_def.F;
T << extract_LZWPostEncode_def.T;
P << extract_LZWPostEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_LZWPostEncode_def_void@
identifier F = LZWPostEncode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_LZWPostEncode_def_void@
F << extract_LZWPostEncode_def_void.F;
P << extract_LZWPostEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_LZWPostEncode_decl@
type T;
identifier F = LZWPostEncode;
parameter list P;
@@
T F(P);

@script:python depends on extract_LZWPostEncode_decl@
F << extract_LZWPostEncode_decl.F;
T << extract_LZWPostEncode_decl.T;
P << extract_LZWPostEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_LZWPostEncode_decl_void@
identifier F = LZWPostEncode;
parameter list P;
@@
void F(P);

@script:python depends on extract_LZWPostEncode_decl_void@
F << extract_LZWPostEncode_decl_void.F;
P << extract_LZWPostEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: LZWPreDecode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_LZWPreDecode_def@
type T;
identifier F = LZWPreDecode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_LZWPreDecode_def@
F << remove_static_LZWPreDecode_def.F;
T << remove_static_LZWPreDecode_def.T;
P << remove_static_LZWPreDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_LZWPreDecode_def_void@
identifier F = LZWPreDecode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_LZWPreDecode_def_void@
F << remove_static_LZWPreDecode_def_void.F;
P << remove_static_LZWPreDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_LZWPreDecode_decl@
type T;
identifier F = LZWPreDecode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_LZWPreDecode_decl@
F << remove_static_LZWPreDecode_decl.F;
T << remove_static_LZWPreDecode_decl.T;
P << remove_static_LZWPreDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_LZWPreDecode_decl_void@
identifier F = LZWPreDecode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_LZWPreDecode_decl_void@
F << remove_static_LZWPreDecode_decl_void.F;
P << remove_static_LZWPreDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_LZWPreDecode_def@
type T;
identifier F = LZWPreDecode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_LZWPreDecode_def@
F << extract_LZWPreDecode_def.F;
T << extract_LZWPreDecode_def.T;
P << extract_LZWPreDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_LZWPreDecode_def_void@
identifier F = LZWPreDecode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_LZWPreDecode_def_void@
F << extract_LZWPreDecode_def_void.F;
P << extract_LZWPreDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_LZWPreDecode_decl@
type T;
identifier F = LZWPreDecode;
parameter list P;
@@
T F(P);

@script:python depends on extract_LZWPreDecode_decl@
F << extract_LZWPreDecode_decl.F;
T << extract_LZWPreDecode_decl.T;
P << extract_LZWPreDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_LZWPreDecode_decl_void@
identifier F = LZWPreDecode;
parameter list P;
@@
void F(P);

@script:python depends on extract_LZWPreDecode_decl_void@
F << extract_LZWPreDecode_decl_void.F;
P << extract_LZWPreDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: LZWPreEncode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_LZWPreEncode_def@
type T;
identifier F = LZWPreEncode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_LZWPreEncode_def@
F << remove_static_LZWPreEncode_def.F;
T << remove_static_LZWPreEncode_def.T;
P << remove_static_LZWPreEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_LZWPreEncode_def_void@
identifier F = LZWPreEncode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_LZWPreEncode_def_void@
F << remove_static_LZWPreEncode_def_void.F;
P << remove_static_LZWPreEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_LZWPreEncode_decl@
type T;
identifier F = LZWPreEncode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_LZWPreEncode_decl@
F << remove_static_LZWPreEncode_decl.F;
T << remove_static_LZWPreEncode_decl.T;
P << remove_static_LZWPreEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_LZWPreEncode_decl_void@
identifier F = LZWPreEncode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_LZWPreEncode_decl_void@
F << remove_static_LZWPreEncode_decl_void.F;
P << remove_static_LZWPreEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_LZWPreEncode_def@
type T;
identifier F = LZWPreEncode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_LZWPreEncode_def@
F << extract_LZWPreEncode_def.F;
T << extract_LZWPreEncode_def.T;
P << extract_LZWPreEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_LZWPreEncode_def_void@
identifier F = LZWPreEncode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_LZWPreEncode_def_void@
F << extract_LZWPreEncode_def_void.F;
P << extract_LZWPreEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_LZWPreEncode_decl@
type T;
identifier F = LZWPreEncode;
parameter list P;
@@
T F(P);

@script:python depends on extract_LZWPreEncode_decl@
F << extract_LZWPreEncode_decl.F;
T << extract_LZWPreEncode_decl.T;
P << extract_LZWPreEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_LZWPreEncode_decl_void@
identifier F = LZWPreEncode;
parameter list P;
@@
void F(P);

@script:python depends on extract_LZWPreEncode_decl_void@
F << extract_LZWPreEncode_decl_void.F;
P << extract_LZWPreEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: LZWSetupDecode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_LZWSetupDecode_def@
type T;
identifier F = LZWSetupDecode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_LZWSetupDecode_def@
F << remove_static_LZWSetupDecode_def.F;
T << remove_static_LZWSetupDecode_def.T;
P << remove_static_LZWSetupDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_LZWSetupDecode_def_void@
identifier F = LZWSetupDecode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_LZWSetupDecode_def_void@
F << remove_static_LZWSetupDecode_def_void.F;
P << remove_static_LZWSetupDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_LZWSetupDecode_decl@
type T;
identifier F = LZWSetupDecode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_LZWSetupDecode_decl@
F << remove_static_LZWSetupDecode_decl.F;
T << remove_static_LZWSetupDecode_decl.T;
P << remove_static_LZWSetupDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_LZWSetupDecode_decl_void@
identifier F = LZWSetupDecode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_LZWSetupDecode_decl_void@
F << remove_static_LZWSetupDecode_decl_void.F;
P << remove_static_LZWSetupDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_LZWSetupDecode_def@
type T;
identifier F = LZWSetupDecode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_LZWSetupDecode_def@
F << extract_LZWSetupDecode_def.F;
T << extract_LZWSetupDecode_def.T;
P << extract_LZWSetupDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_LZWSetupDecode_def_void@
identifier F = LZWSetupDecode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_LZWSetupDecode_def_void@
F << extract_LZWSetupDecode_def_void.F;
P << extract_LZWSetupDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_LZWSetupDecode_decl@
type T;
identifier F = LZWSetupDecode;
parameter list P;
@@
T F(P);

@script:python depends on extract_LZWSetupDecode_decl@
F << extract_LZWSetupDecode_decl.F;
T << extract_LZWSetupDecode_decl.T;
P << extract_LZWSetupDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_LZWSetupDecode_decl_void@
identifier F = LZWSetupDecode;
parameter list P;
@@
void F(P);

@script:python depends on extract_LZWSetupDecode_decl_void@
F << extract_LZWSetupDecode_decl_void.F;
P << extract_LZWSetupDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: LZWSetupEncode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_LZWSetupEncode_def@
type T;
identifier F = LZWSetupEncode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_LZWSetupEncode_def@
F << remove_static_LZWSetupEncode_def.F;
T << remove_static_LZWSetupEncode_def.T;
P << remove_static_LZWSetupEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_LZWSetupEncode_def_void@
identifier F = LZWSetupEncode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_LZWSetupEncode_def_void@
F << remove_static_LZWSetupEncode_def_void.F;
P << remove_static_LZWSetupEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_LZWSetupEncode_decl@
type T;
identifier F = LZWSetupEncode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_LZWSetupEncode_decl@
F << remove_static_LZWSetupEncode_decl.F;
T << remove_static_LZWSetupEncode_decl.T;
P << remove_static_LZWSetupEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_LZWSetupEncode_decl_void@
identifier F = LZWSetupEncode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_LZWSetupEncode_decl_void@
F << remove_static_LZWSetupEncode_decl_void.F;
P << remove_static_LZWSetupEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_LZWSetupEncode_def@
type T;
identifier F = LZWSetupEncode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_LZWSetupEncode_def@
F << extract_LZWSetupEncode_def.F;
T << extract_LZWSetupEncode_def.T;
P << extract_LZWSetupEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_LZWSetupEncode_def_void@
identifier F = LZWSetupEncode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_LZWSetupEncode_def_void@
F << extract_LZWSetupEncode_def_void.F;
P << extract_LZWSetupEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_LZWSetupEncode_decl@
type T;
identifier F = LZWSetupEncode;
parameter list P;
@@
T F(P);

@script:python depends on extract_LZWSetupEncode_decl@
F << extract_LZWSetupEncode_decl.F;
T << extract_LZWSetupEncode_decl.T;
P << extract_LZWSetupEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_LZWSetupEncode_decl_void@
identifier F = LZWSetupEncode;
parameter list P;
@@
void F(P);

@script:python depends on extract_LZWSetupEncode_decl_void@
F << extract_LZWSetupEncode_decl_void.F;
P << extract_LZWSetupEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: LogL16Decode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_LogL16Decode_def@
type T;
identifier F = LogL16Decode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_LogL16Decode_def@
F << remove_static_LogL16Decode_def.F;
T << remove_static_LogL16Decode_def.T;
P << remove_static_LogL16Decode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_LogL16Decode_def_void@
identifier F = LogL16Decode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_LogL16Decode_def_void@
F << remove_static_LogL16Decode_def_void.F;
P << remove_static_LogL16Decode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_LogL16Decode_decl@
type T;
identifier F = LogL16Decode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_LogL16Decode_decl@
F << remove_static_LogL16Decode_decl.F;
T << remove_static_LogL16Decode_decl.T;
P << remove_static_LogL16Decode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_LogL16Decode_decl_void@
identifier F = LogL16Decode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_LogL16Decode_decl_void@
F << remove_static_LogL16Decode_decl_void.F;
P << remove_static_LogL16Decode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_LogL16Decode_def@
type T;
identifier F = LogL16Decode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_LogL16Decode_def@
F << extract_LogL16Decode_def.F;
T << extract_LogL16Decode_def.T;
P << extract_LogL16Decode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_LogL16Decode_def_void@
identifier F = LogL16Decode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_LogL16Decode_def_void@
F << extract_LogL16Decode_def_void.F;
P << extract_LogL16Decode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_LogL16Decode_decl@
type T;
identifier F = LogL16Decode;
parameter list P;
@@
T F(P);

@script:python depends on extract_LogL16Decode_decl@
F << extract_LogL16Decode_decl.F;
T << extract_LogL16Decode_decl.T;
P << extract_LogL16Decode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_LogL16Decode_decl_void@
identifier F = LogL16Decode;
parameter list P;
@@
void F(P);

@script:python depends on extract_LogL16Decode_decl_void@
F << extract_LogL16Decode_decl_void.F;
P << extract_LogL16Decode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: LogL16Encode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_LogL16Encode_def@
type T;
identifier F = LogL16Encode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_LogL16Encode_def@
F << remove_static_LogL16Encode_def.F;
T << remove_static_LogL16Encode_def.T;
P << remove_static_LogL16Encode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_LogL16Encode_def_void@
identifier F = LogL16Encode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_LogL16Encode_def_void@
F << remove_static_LogL16Encode_def_void.F;
P << remove_static_LogL16Encode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_LogL16Encode_decl@
type T;
identifier F = LogL16Encode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_LogL16Encode_decl@
F << remove_static_LogL16Encode_decl.F;
T << remove_static_LogL16Encode_decl.T;
P << remove_static_LogL16Encode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_LogL16Encode_decl_void@
identifier F = LogL16Encode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_LogL16Encode_decl_void@
F << remove_static_LogL16Encode_decl_void.F;
P << remove_static_LogL16Encode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_LogL16Encode_def@
type T;
identifier F = LogL16Encode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_LogL16Encode_def@
F << extract_LogL16Encode_def.F;
T << extract_LogL16Encode_def.T;
P << extract_LogL16Encode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_LogL16Encode_def_void@
identifier F = LogL16Encode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_LogL16Encode_def_void@
F << extract_LogL16Encode_def_void.F;
P << extract_LogL16Encode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_LogL16Encode_decl@
type T;
identifier F = LogL16Encode;
parameter list P;
@@
T F(P);

@script:python depends on extract_LogL16Encode_decl@
F << extract_LogL16Encode_decl.F;
T << extract_LogL16Encode_decl.T;
P << extract_LogL16Encode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_LogL16Encode_decl_void@
identifier F = LogL16Encode;
parameter list P;
@@
void F(P);

@script:python depends on extract_LogL16Encode_decl_void@
F << extract_LogL16Encode_decl_void.F;
P << extract_LogL16Encode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: LogLuvCleanup
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_LogLuvCleanup_def@
type T;
identifier F = LogLuvCleanup;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_LogLuvCleanup_def@
F << remove_static_LogLuvCleanup_def.F;
T << remove_static_LogLuvCleanup_def.T;
P << remove_static_LogLuvCleanup_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_LogLuvCleanup_def_void@
identifier F = LogLuvCleanup;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_LogLuvCleanup_def_void@
F << remove_static_LogLuvCleanup_def_void.F;
P << remove_static_LogLuvCleanup_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_LogLuvCleanup_decl@
type T;
identifier F = LogLuvCleanup;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_LogLuvCleanup_decl@
F << remove_static_LogLuvCleanup_decl.F;
T << remove_static_LogLuvCleanup_decl.T;
P << remove_static_LogLuvCleanup_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_LogLuvCleanup_decl_void@
identifier F = LogLuvCleanup;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_LogLuvCleanup_decl_void@
F << remove_static_LogLuvCleanup_decl_void.F;
P << remove_static_LogLuvCleanup_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_LogLuvCleanup_def@
type T;
identifier F = LogLuvCleanup;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_LogLuvCleanup_def@
F << extract_LogLuvCleanup_def.F;
T << extract_LogLuvCleanup_def.T;
P << extract_LogLuvCleanup_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_LogLuvCleanup_def_void@
identifier F = LogLuvCleanup;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_LogLuvCleanup_def_void@
F << extract_LogLuvCleanup_def_void.F;
P << extract_LogLuvCleanup_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_LogLuvCleanup_decl@
type T;
identifier F = LogLuvCleanup;
parameter list P;
@@
T F(P);

@script:python depends on extract_LogLuvCleanup_decl@
F << extract_LogLuvCleanup_decl.F;
T << extract_LogLuvCleanup_decl.T;
P << extract_LogLuvCleanup_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_LogLuvCleanup_decl_void@
identifier F = LogLuvCleanup;
parameter list P;
@@
void F(P);

@script:python depends on extract_LogLuvCleanup_decl_void@
F << extract_LogLuvCleanup_decl_void.F;
P << extract_LogLuvCleanup_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: LogLuvClose
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_LogLuvClose_def@
type T;
identifier F = LogLuvClose;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_LogLuvClose_def@
F << remove_static_LogLuvClose_def.F;
T << remove_static_LogLuvClose_def.T;
P << remove_static_LogLuvClose_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_LogLuvClose_def_void@
identifier F = LogLuvClose;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_LogLuvClose_def_void@
F << remove_static_LogLuvClose_def_void.F;
P << remove_static_LogLuvClose_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_LogLuvClose_decl@
type T;
identifier F = LogLuvClose;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_LogLuvClose_decl@
F << remove_static_LogLuvClose_decl.F;
T << remove_static_LogLuvClose_decl.T;
P << remove_static_LogLuvClose_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_LogLuvClose_decl_void@
identifier F = LogLuvClose;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_LogLuvClose_decl_void@
F << remove_static_LogLuvClose_decl_void.F;
P << remove_static_LogLuvClose_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_LogLuvClose_def@
type T;
identifier F = LogLuvClose;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_LogLuvClose_def@
F << extract_LogLuvClose_def.F;
T << extract_LogLuvClose_def.T;
P << extract_LogLuvClose_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_LogLuvClose_def_void@
identifier F = LogLuvClose;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_LogLuvClose_def_void@
F << extract_LogLuvClose_def_void.F;
P << extract_LogLuvClose_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_LogLuvClose_decl@
type T;
identifier F = LogLuvClose;
parameter list P;
@@
T F(P);

@script:python depends on extract_LogLuvClose_decl@
F << extract_LogLuvClose_decl.F;
T << extract_LogLuvClose_decl.T;
P << extract_LogLuvClose_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_LogLuvClose_decl_void@
identifier F = LogLuvClose;
parameter list P;
@@
void F(P);

@script:python depends on extract_LogLuvClose_decl_void@
F << extract_LogLuvClose_decl_void.F;
P << extract_LogLuvClose_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: LogLuvDecode24
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_LogLuvDecode24_def@
type T;
identifier F = LogLuvDecode24;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_LogLuvDecode24_def@
F << remove_static_LogLuvDecode24_def.F;
T << remove_static_LogLuvDecode24_def.T;
P << remove_static_LogLuvDecode24_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_LogLuvDecode24_def_void@
identifier F = LogLuvDecode24;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_LogLuvDecode24_def_void@
F << remove_static_LogLuvDecode24_def_void.F;
P << remove_static_LogLuvDecode24_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_LogLuvDecode24_decl@
type T;
identifier F = LogLuvDecode24;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_LogLuvDecode24_decl@
F << remove_static_LogLuvDecode24_decl.F;
T << remove_static_LogLuvDecode24_decl.T;
P << remove_static_LogLuvDecode24_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_LogLuvDecode24_decl_void@
identifier F = LogLuvDecode24;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_LogLuvDecode24_decl_void@
F << remove_static_LogLuvDecode24_decl_void.F;
P << remove_static_LogLuvDecode24_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_LogLuvDecode24_def@
type T;
identifier F = LogLuvDecode24;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_LogLuvDecode24_def@
F << extract_LogLuvDecode24_def.F;
T << extract_LogLuvDecode24_def.T;
P << extract_LogLuvDecode24_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_LogLuvDecode24_def_void@
identifier F = LogLuvDecode24;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_LogLuvDecode24_def_void@
F << extract_LogLuvDecode24_def_void.F;
P << extract_LogLuvDecode24_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_LogLuvDecode24_decl@
type T;
identifier F = LogLuvDecode24;
parameter list P;
@@
T F(P);

@script:python depends on extract_LogLuvDecode24_decl@
F << extract_LogLuvDecode24_decl.F;
T << extract_LogLuvDecode24_decl.T;
P << extract_LogLuvDecode24_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_LogLuvDecode24_decl_void@
identifier F = LogLuvDecode24;
parameter list P;
@@
void F(P);

@script:python depends on extract_LogLuvDecode24_decl_void@
F << extract_LogLuvDecode24_decl_void.F;
P << extract_LogLuvDecode24_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: LogLuvDecode32
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_LogLuvDecode32_def@
type T;
identifier F = LogLuvDecode32;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_LogLuvDecode32_def@
F << remove_static_LogLuvDecode32_def.F;
T << remove_static_LogLuvDecode32_def.T;
P << remove_static_LogLuvDecode32_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_LogLuvDecode32_def_void@
identifier F = LogLuvDecode32;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_LogLuvDecode32_def_void@
F << remove_static_LogLuvDecode32_def_void.F;
P << remove_static_LogLuvDecode32_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_LogLuvDecode32_decl@
type T;
identifier F = LogLuvDecode32;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_LogLuvDecode32_decl@
F << remove_static_LogLuvDecode32_decl.F;
T << remove_static_LogLuvDecode32_decl.T;
P << remove_static_LogLuvDecode32_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_LogLuvDecode32_decl_void@
identifier F = LogLuvDecode32;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_LogLuvDecode32_decl_void@
F << remove_static_LogLuvDecode32_decl_void.F;
P << remove_static_LogLuvDecode32_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_LogLuvDecode32_def@
type T;
identifier F = LogLuvDecode32;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_LogLuvDecode32_def@
F << extract_LogLuvDecode32_def.F;
T << extract_LogLuvDecode32_def.T;
P << extract_LogLuvDecode32_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_LogLuvDecode32_def_void@
identifier F = LogLuvDecode32;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_LogLuvDecode32_def_void@
F << extract_LogLuvDecode32_def_void.F;
P << extract_LogLuvDecode32_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_LogLuvDecode32_decl@
type T;
identifier F = LogLuvDecode32;
parameter list P;
@@
T F(P);

@script:python depends on extract_LogLuvDecode32_decl@
F << extract_LogLuvDecode32_decl.F;
T << extract_LogLuvDecode32_decl.T;
P << extract_LogLuvDecode32_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_LogLuvDecode32_decl_void@
identifier F = LogLuvDecode32;
parameter list P;
@@
void F(P);

@script:python depends on extract_LogLuvDecode32_decl_void@
F << extract_LogLuvDecode32_decl_void.F;
P << extract_LogLuvDecode32_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: LogLuvDecodeStrip
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_LogLuvDecodeStrip_def@
type T;
identifier F = LogLuvDecodeStrip;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_LogLuvDecodeStrip_def@
F << remove_static_LogLuvDecodeStrip_def.F;
T << remove_static_LogLuvDecodeStrip_def.T;
P << remove_static_LogLuvDecodeStrip_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_LogLuvDecodeStrip_def_void@
identifier F = LogLuvDecodeStrip;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_LogLuvDecodeStrip_def_void@
F << remove_static_LogLuvDecodeStrip_def_void.F;
P << remove_static_LogLuvDecodeStrip_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_LogLuvDecodeStrip_decl@
type T;
identifier F = LogLuvDecodeStrip;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_LogLuvDecodeStrip_decl@
F << remove_static_LogLuvDecodeStrip_decl.F;
T << remove_static_LogLuvDecodeStrip_decl.T;
P << remove_static_LogLuvDecodeStrip_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_LogLuvDecodeStrip_decl_void@
identifier F = LogLuvDecodeStrip;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_LogLuvDecodeStrip_decl_void@
F << remove_static_LogLuvDecodeStrip_decl_void.F;
P << remove_static_LogLuvDecodeStrip_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_LogLuvDecodeStrip_def@
type T;
identifier F = LogLuvDecodeStrip;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_LogLuvDecodeStrip_def@
F << extract_LogLuvDecodeStrip_def.F;
T << extract_LogLuvDecodeStrip_def.T;
P << extract_LogLuvDecodeStrip_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_LogLuvDecodeStrip_def_void@
identifier F = LogLuvDecodeStrip;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_LogLuvDecodeStrip_def_void@
F << extract_LogLuvDecodeStrip_def_void.F;
P << extract_LogLuvDecodeStrip_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_LogLuvDecodeStrip_decl@
type T;
identifier F = LogLuvDecodeStrip;
parameter list P;
@@
T F(P);

@script:python depends on extract_LogLuvDecodeStrip_decl@
F << extract_LogLuvDecodeStrip_decl.F;
T << extract_LogLuvDecodeStrip_decl.T;
P << extract_LogLuvDecodeStrip_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_LogLuvDecodeStrip_decl_void@
identifier F = LogLuvDecodeStrip;
parameter list P;
@@
void F(P);

@script:python depends on extract_LogLuvDecodeStrip_decl_void@
F << extract_LogLuvDecodeStrip_decl_void.F;
P << extract_LogLuvDecodeStrip_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: LogLuvDecodeTile
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_LogLuvDecodeTile_def@
type T;
identifier F = LogLuvDecodeTile;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_LogLuvDecodeTile_def@
F << remove_static_LogLuvDecodeTile_def.F;
T << remove_static_LogLuvDecodeTile_def.T;
P << remove_static_LogLuvDecodeTile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_LogLuvDecodeTile_def_void@
identifier F = LogLuvDecodeTile;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_LogLuvDecodeTile_def_void@
F << remove_static_LogLuvDecodeTile_def_void.F;
P << remove_static_LogLuvDecodeTile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_LogLuvDecodeTile_decl@
type T;
identifier F = LogLuvDecodeTile;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_LogLuvDecodeTile_decl@
F << remove_static_LogLuvDecodeTile_decl.F;
T << remove_static_LogLuvDecodeTile_decl.T;
P << remove_static_LogLuvDecodeTile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_LogLuvDecodeTile_decl_void@
identifier F = LogLuvDecodeTile;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_LogLuvDecodeTile_decl_void@
F << remove_static_LogLuvDecodeTile_decl_void.F;
P << remove_static_LogLuvDecodeTile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_LogLuvDecodeTile_def@
type T;
identifier F = LogLuvDecodeTile;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_LogLuvDecodeTile_def@
F << extract_LogLuvDecodeTile_def.F;
T << extract_LogLuvDecodeTile_def.T;
P << extract_LogLuvDecodeTile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_LogLuvDecodeTile_def_void@
identifier F = LogLuvDecodeTile;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_LogLuvDecodeTile_def_void@
F << extract_LogLuvDecodeTile_def_void.F;
P << extract_LogLuvDecodeTile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_LogLuvDecodeTile_decl@
type T;
identifier F = LogLuvDecodeTile;
parameter list P;
@@
T F(P);

@script:python depends on extract_LogLuvDecodeTile_decl@
F << extract_LogLuvDecodeTile_decl.F;
T << extract_LogLuvDecodeTile_decl.T;
P << extract_LogLuvDecodeTile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_LogLuvDecodeTile_decl_void@
identifier F = LogLuvDecodeTile;
parameter list P;
@@
void F(P);

@script:python depends on extract_LogLuvDecodeTile_decl_void@
F << extract_LogLuvDecodeTile_decl_void.F;
P << extract_LogLuvDecodeTile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: LogLuvEncode24
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_LogLuvEncode24_def@
type T;
identifier F = LogLuvEncode24;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_LogLuvEncode24_def@
F << remove_static_LogLuvEncode24_def.F;
T << remove_static_LogLuvEncode24_def.T;
P << remove_static_LogLuvEncode24_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_LogLuvEncode24_def_void@
identifier F = LogLuvEncode24;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_LogLuvEncode24_def_void@
F << remove_static_LogLuvEncode24_def_void.F;
P << remove_static_LogLuvEncode24_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_LogLuvEncode24_decl@
type T;
identifier F = LogLuvEncode24;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_LogLuvEncode24_decl@
F << remove_static_LogLuvEncode24_decl.F;
T << remove_static_LogLuvEncode24_decl.T;
P << remove_static_LogLuvEncode24_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_LogLuvEncode24_decl_void@
identifier F = LogLuvEncode24;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_LogLuvEncode24_decl_void@
F << remove_static_LogLuvEncode24_decl_void.F;
P << remove_static_LogLuvEncode24_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_LogLuvEncode24_def@
type T;
identifier F = LogLuvEncode24;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_LogLuvEncode24_def@
F << extract_LogLuvEncode24_def.F;
T << extract_LogLuvEncode24_def.T;
P << extract_LogLuvEncode24_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_LogLuvEncode24_def_void@
identifier F = LogLuvEncode24;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_LogLuvEncode24_def_void@
F << extract_LogLuvEncode24_def_void.F;
P << extract_LogLuvEncode24_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_LogLuvEncode24_decl@
type T;
identifier F = LogLuvEncode24;
parameter list P;
@@
T F(P);

@script:python depends on extract_LogLuvEncode24_decl@
F << extract_LogLuvEncode24_decl.F;
T << extract_LogLuvEncode24_decl.T;
P << extract_LogLuvEncode24_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_LogLuvEncode24_decl_void@
identifier F = LogLuvEncode24;
parameter list P;
@@
void F(P);

@script:python depends on extract_LogLuvEncode24_decl_void@
F << extract_LogLuvEncode24_decl_void.F;
P << extract_LogLuvEncode24_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: LogLuvEncode32
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_LogLuvEncode32_def@
type T;
identifier F = LogLuvEncode32;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_LogLuvEncode32_def@
F << remove_static_LogLuvEncode32_def.F;
T << remove_static_LogLuvEncode32_def.T;
P << remove_static_LogLuvEncode32_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_LogLuvEncode32_def_void@
identifier F = LogLuvEncode32;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_LogLuvEncode32_def_void@
F << remove_static_LogLuvEncode32_def_void.F;
P << remove_static_LogLuvEncode32_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_LogLuvEncode32_decl@
type T;
identifier F = LogLuvEncode32;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_LogLuvEncode32_decl@
F << remove_static_LogLuvEncode32_decl.F;
T << remove_static_LogLuvEncode32_decl.T;
P << remove_static_LogLuvEncode32_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_LogLuvEncode32_decl_void@
identifier F = LogLuvEncode32;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_LogLuvEncode32_decl_void@
F << remove_static_LogLuvEncode32_decl_void.F;
P << remove_static_LogLuvEncode32_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_LogLuvEncode32_def@
type T;
identifier F = LogLuvEncode32;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_LogLuvEncode32_def@
F << extract_LogLuvEncode32_def.F;
T << extract_LogLuvEncode32_def.T;
P << extract_LogLuvEncode32_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_LogLuvEncode32_def_void@
identifier F = LogLuvEncode32;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_LogLuvEncode32_def_void@
F << extract_LogLuvEncode32_def_void.F;
P << extract_LogLuvEncode32_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_LogLuvEncode32_decl@
type T;
identifier F = LogLuvEncode32;
parameter list P;
@@
T F(P);

@script:python depends on extract_LogLuvEncode32_decl@
F << extract_LogLuvEncode32_decl.F;
T << extract_LogLuvEncode32_decl.T;
P << extract_LogLuvEncode32_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_LogLuvEncode32_decl_void@
identifier F = LogLuvEncode32;
parameter list P;
@@
void F(P);

@script:python depends on extract_LogLuvEncode32_decl_void@
F << extract_LogLuvEncode32_decl_void.F;
P << extract_LogLuvEncode32_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: LogLuvEncodeStrip
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_LogLuvEncodeStrip_def@
type T;
identifier F = LogLuvEncodeStrip;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_LogLuvEncodeStrip_def@
F << remove_static_LogLuvEncodeStrip_def.F;
T << remove_static_LogLuvEncodeStrip_def.T;
P << remove_static_LogLuvEncodeStrip_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_LogLuvEncodeStrip_def_void@
identifier F = LogLuvEncodeStrip;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_LogLuvEncodeStrip_def_void@
F << remove_static_LogLuvEncodeStrip_def_void.F;
P << remove_static_LogLuvEncodeStrip_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_LogLuvEncodeStrip_decl@
type T;
identifier F = LogLuvEncodeStrip;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_LogLuvEncodeStrip_decl@
F << remove_static_LogLuvEncodeStrip_decl.F;
T << remove_static_LogLuvEncodeStrip_decl.T;
P << remove_static_LogLuvEncodeStrip_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_LogLuvEncodeStrip_decl_void@
identifier F = LogLuvEncodeStrip;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_LogLuvEncodeStrip_decl_void@
F << remove_static_LogLuvEncodeStrip_decl_void.F;
P << remove_static_LogLuvEncodeStrip_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_LogLuvEncodeStrip_def@
type T;
identifier F = LogLuvEncodeStrip;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_LogLuvEncodeStrip_def@
F << extract_LogLuvEncodeStrip_def.F;
T << extract_LogLuvEncodeStrip_def.T;
P << extract_LogLuvEncodeStrip_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_LogLuvEncodeStrip_def_void@
identifier F = LogLuvEncodeStrip;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_LogLuvEncodeStrip_def_void@
F << extract_LogLuvEncodeStrip_def_void.F;
P << extract_LogLuvEncodeStrip_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_LogLuvEncodeStrip_decl@
type T;
identifier F = LogLuvEncodeStrip;
parameter list P;
@@
T F(P);

@script:python depends on extract_LogLuvEncodeStrip_decl@
F << extract_LogLuvEncodeStrip_decl.F;
T << extract_LogLuvEncodeStrip_decl.T;
P << extract_LogLuvEncodeStrip_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_LogLuvEncodeStrip_decl_void@
identifier F = LogLuvEncodeStrip;
parameter list P;
@@
void F(P);

@script:python depends on extract_LogLuvEncodeStrip_decl_void@
F << extract_LogLuvEncodeStrip_decl_void.F;
P << extract_LogLuvEncodeStrip_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: LogLuvEncodeTile
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_LogLuvEncodeTile_def@
type T;
identifier F = LogLuvEncodeTile;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_LogLuvEncodeTile_def@
F << remove_static_LogLuvEncodeTile_def.F;
T << remove_static_LogLuvEncodeTile_def.T;
P << remove_static_LogLuvEncodeTile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_LogLuvEncodeTile_def_void@
identifier F = LogLuvEncodeTile;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_LogLuvEncodeTile_def_void@
F << remove_static_LogLuvEncodeTile_def_void.F;
P << remove_static_LogLuvEncodeTile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_LogLuvEncodeTile_decl@
type T;
identifier F = LogLuvEncodeTile;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_LogLuvEncodeTile_decl@
F << remove_static_LogLuvEncodeTile_decl.F;
T << remove_static_LogLuvEncodeTile_decl.T;
P << remove_static_LogLuvEncodeTile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_LogLuvEncodeTile_decl_void@
identifier F = LogLuvEncodeTile;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_LogLuvEncodeTile_decl_void@
F << remove_static_LogLuvEncodeTile_decl_void.F;
P << remove_static_LogLuvEncodeTile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_LogLuvEncodeTile_def@
type T;
identifier F = LogLuvEncodeTile;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_LogLuvEncodeTile_def@
F << extract_LogLuvEncodeTile_def.F;
T << extract_LogLuvEncodeTile_def.T;
P << extract_LogLuvEncodeTile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_LogLuvEncodeTile_def_void@
identifier F = LogLuvEncodeTile;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_LogLuvEncodeTile_def_void@
F << extract_LogLuvEncodeTile_def_void.F;
P << extract_LogLuvEncodeTile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_LogLuvEncodeTile_decl@
type T;
identifier F = LogLuvEncodeTile;
parameter list P;
@@
T F(P);

@script:python depends on extract_LogLuvEncodeTile_decl@
F << extract_LogLuvEncodeTile_decl.F;
T << extract_LogLuvEncodeTile_decl.T;
P << extract_LogLuvEncodeTile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_LogLuvEncodeTile_decl_void@
identifier F = LogLuvEncodeTile;
parameter list P;
@@
void F(P);

@script:python depends on extract_LogLuvEncodeTile_decl_void@
F << extract_LogLuvEncodeTile_decl_void.F;
P << extract_LogLuvEncodeTile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: LogLuvFixupTags
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_LogLuvFixupTags_def@
type T;
identifier F = LogLuvFixupTags;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_LogLuvFixupTags_def@
F << remove_static_LogLuvFixupTags_def.F;
T << remove_static_LogLuvFixupTags_def.T;
P << remove_static_LogLuvFixupTags_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_LogLuvFixupTags_def_void@
identifier F = LogLuvFixupTags;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_LogLuvFixupTags_def_void@
F << remove_static_LogLuvFixupTags_def_void.F;
P << remove_static_LogLuvFixupTags_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_LogLuvFixupTags_decl@
type T;
identifier F = LogLuvFixupTags;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_LogLuvFixupTags_decl@
F << remove_static_LogLuvFixupTags_decl.F;
T << remove_static_LogLuvFixupTags_decl.T;
P << remove_static_LogLuvFixupTags_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_LogLuvFixupTags_decl_void@
identifier F = LogLuvFixupTags;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_LogLuvFixupTags_decl_void@
F << remove_static_LogLuvFixupTags_decl_void.F;
P << remove_static_LogLuvFixupTags_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_LogLuvFixupTags_def@
type T;
identifier F = LogLuvFixupTags;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_LogLuvFixupTags_def@
F << extract_LogLuvFixupTags_def.F;
T << extract_LogLuvFixupTags_def.T;
P << extract_LogLuvFixupTags_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_LogLuvFixupTags_def_void@
identifier F = LogLuvFixupTags;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_LogLuvFixupTags_def_void@
F << extract_LogLuvFixupTags_def_void.F;
P << extract_LogLuvFixupTags_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_LogLuvFixupTags_decl@
type T;
identifier F = LogLuvFixupTags;
parameter list P;
@@
T F(P);

@script:python depends on extract_LogLuvFixupTags_decl@
F << extract_LogLuvFixupTags_decl.F;
T << extract_LogLuvFixupTags_decl.T;
P << extract_LogLuvFixupTags_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_LogLuvFixupTags_decl_void@
identifier F = LogLuvFixupTags;
parameter list P;
@@
void F(P);

@script:python depends on extract_LogLuvFixupTags_decl_void@
F << extract_LogLuvFixupTags_decl_void.F;
P << extract_LogLuvFixupTags_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: LogLuvSetupDecode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_LogLuvSetupDecode_def@
type T;
identifier F = LogLuvSetupDecode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_LogLuvSetupDecode_def@
F << remove_static_LogLuvSetupDecode_def.F;
T << remove_static_LogLuvSetupDecode_def.T;
P << remove_static_LogLuvSetupDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_LogLuvSetupDecode_def_void@
identifier F = LogLuvSetupDecode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_LogLuvSetupDecode_def_void@
F << remove_static_LogLuvSetupDecode_def_void.F;
P << remove_static_LogLuvSetupDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_LogLuvSetupDecode_decl@
type T;
identifier F = LogLuvSetupDecode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_LogLuvSetupDecode_decl@
F << remove_static_LogLuvSetupDecode_decl.F;
T << remove_static_LogLuvSetupDecode_decl.T;
P << remove_static_LogLuvSetupDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_LogLuvSetupDecode_decl_void@
identifier F = LogLuvSetupDecode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_LogLuvSetupDecode_decl_void@
F << remove_static_LogLuvSetupDecode_decl_void.F;
P << remove_static_LogLuvSetupDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_LogLuvSetupDecode_def@
type T;
identifier F = LogLuvSetupDecode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_LogLuvSetupDecode_def@
F << extract_LogLuvSetupDecode_def.F;
T << extract_LogLuvSetupDecode_def.T;
P << extract_LogLuvSetupDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_LogLuvSetupDecode_def_void@
identifier F = LogLuvSetupDecode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_LogLuvSetupDecode_def_void@
F << extract_LogLuvSetupDecode_def_void.F;
P << extract_LogLuvSetupDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_LogLuvSetupDecode_decl@
type T;
identifier F = LogLuvSetupDecode;
parameter list P;
@@
T F(P);

@script:python depends on extract_LogLuvSetupDecode_decl@
F << extract_LogLuvSetupDecode_decl.F;
T << extract_LogLuvSetupDecode_decl.T;
P << extract_LogLuvSetupDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_LogLuvSetupDecode_decl_void@
identifier F = LogLuvSetupDecode;
parameter list P;
@@
void F(P);

@script:python depends on extract_LogLuvSetupDecode_decl_void@
F << extract_LogLuvSetupDecode_decl_void.F;
P << extract_LogLuvSetupDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: LogLuvSetupEncode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_LogLuvSetupEncode_def@
type T;
identifier F = LogLuvSetupEncode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_LogLuvSetupEncode_def@
F << remove_static_LogLuvSetupEncode_def.F;
T << remove_static_LogLuvSetupEncode_def.T;
P << remove_static_LogLuvSetupEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_LogLuvSetupEncode_def_void@
identifier F = LogLuvSetupEncode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_LogLuvSetupEncode_def_void@
F << remove_static_LogLuvSetupEncode_def_void.F;
P << remove_static_LogLuvSetupEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_LogLuvSetupEncode_decl@
type T;
identifier F = LogLuvSetupEncode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_LogLuvSetupEncode_decl@
F << remove_static_LogLuvSetupEncode_decl.F;
T << remove_static_LogLuvSetupEncode_decl.T;
P << remove_static_LogLuvSetupEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_LogLuvSetupEncode_decl_void@
identifier F = LogLuvSetupEncode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_LogLuvSetupEncode_decl_void@
F << remove_static_LogLuvSetupEncode_decl_void.F;
P << remove_static_LogLuvSetupEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_LogLuvSetupEncode_def@
type T;
identifier F = LogLuvSetupEncode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_LogLuvSetupEncode_def@
F << extract_LogLuvSetupEncode_def.F;
T << extract_LogLuvSetupEncode_def.T;
P << extract_LogLuvSetupEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_LogLuvSetupEncode_def_void@
identifier F = LogLuvSetupEncode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_LogLuvSetupEncode_def_void@
F << extract_LogLuvSetupEncode_def_void.F;
P << extract_LogLuvSetupEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_LogLuvSetupEncode_decl@
type T;
identifier F = LogLuvSetupEncode;
parameter list P;
@@
T F(P);

@script:python depends on extract_LogLuvSetupEncode_decl@
F << extract_LogLuvSetupEncode_decl.F;
T << extract_LogLuvSetupEncode_decl.T;
P << extract_LogLuvSetupEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_LogLuvSetupEncode_decl_void@
identifier F = LogLuvSetupEncode;
parameter list P;
@@
void F(P);

@script:python depends on extract_LogLuvSetupEncode_decl_void@
F << extract_LogLuvSetupEncode_decl_void.F;
P << extract_LogLuvSetupEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: LogLuvVGetField
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_LogLuvVGetField_def@
type T;
identifier F = LogLuvVGetField;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_LogLuvVGetField_def@
F << remove_static_LogLuvVGetField_def.F;
T << remove_static_LogLuvVGetField_def.T;
P << remove_static_LogLuvVGetField_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_LogLuvVGetField_def_void@
identifier F = LogLuvVGetField;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_LogLuvVGetField_def_void@
F << remove_static_LogLuvVGetField_def_void.F;
P << remove_static_LogLuvVGetField_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_LogLuvVGetField_decl@
type T;
identifier F = LogLuvVGetField;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_LogLuvVGetField_decl@
F << remove_static_LogLuvVGetField_decl.F;
T << remove_static_LogLuvVGetField_decl.T;
P << remove_static_LogLuvVGetField_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_LogLuvVGetField_decl_void@
identifier F = LogLuvVGetField;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_LogLuvVGetField_decl_void@
F << remove_static_LogLuvVGetField_decl_void.F;
P << remove_static_LogLuvVGetField_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_LogLuvVGetField_def@
type T;
identifier F = LogLuvVGetField;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_LogLuvVGetField_def@
F << extract_LogLuvVGetField_def.F;
T << extract_LogLuvVGetField_def.T;
P << extract_LogLuvVGetField_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_LogLuvVGetField_def_void@
identifier F = LogLuvVGetField;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_LogLuvVGetField_def_void@
F << extract_LogLuvVGetField_def_void.F;
P << extract_LogLuvVGetField_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_LogLuvVGetField_decl@
type T;
identifier F = LogLuvVGetField;
parameter list P;
@@
T F(P);

@script:python depends on extract_LogLuvVGetField_decl@
F << extract_LogLuvVGetField_decl.F;
T << extract_LogLuvVGetField_decl.T;
P << extract_LogLuvVGetField_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_LogLuvVGetField_decl_void@
identifier F = LogLuvVGetField;
parameter list P;
@@
void F(P);

@script:python depends on extract_LogLuvVGetField_decl_void@
F << extract_LogLuvVGetField_decl_void.F;
P << extract_LogLuvVGetField_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: LogLuvVSetField
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_LogLuvVSetField_def@
type T;
identifier F = LogLuvVSetField;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_LogLuvVSetField_def@
F << remove_static_LogLuvVSetField_def.F;
T << remove_static_LogLuvVSetField_def.T;
P << remove_static_LogLuvVSetField_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_LogLuvVSetField_def_void@
identifier F = LogLuvVSetField;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_LogLuvVSetField_def_void@
F << remove_static_LogLuvVSetField_def_void.F;
P << remove_static_LogLuvVSetField_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_LogLuvVSetField_decl@
type T;
identifier F = LogLuvVSetField;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_LogLuvVSetField_decl@
F << remove_static_LogLuvVSetField_decl.F;
T << remove_static_LogLuvVSetField_decl.T;
P << remove_static_LogLuvVSetField_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_LogLuvVSetField_decl_void@
identifier F = LogLuvVSetField;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_LogLuvVSetField_decl_void@
F << remove_static_LogLuvVSetField_decl_void.F;
P << remove_static_LogLuvVSetField_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_LogLuvVSetField_def@
type T;
identifier F = LogLuvVSetField;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_LogLuvVSetField_def@
F << extract_LogLuvVSetField_def.F;
T << extract_LogLuvVSetField_def.T;
P << extract_LogLuvVSetField_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_LogLuvVSetField_def_void@
identifier F = LogLuvVSetField;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_LogLuvVSetField_def_void@
F << extract_LogLuvVSetField_def_void.F;
P << extract_LogLuvVSetField_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_LogLuvVSetField_decl@
type T;
identifier F = LogLuvVSetField;
parameter list P;
@@
T F(P);

@script:python depends on extract_LogLuvVSetField_decl@
F << extract_LogLuvVSetField_decl.F;
T << extract_LogLuvVSetField_decl.T;
P << extract_LogLuvVSetField_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_LogLuvVSetField_decl_void@
identifier F = LogLuvVSetField;
parameter list P;
@@
void F(P);

@script:python depends on extract_LogLuvVSetField_decl_void@
F << extract_LogLuvVSetField_decl_void.F;
P << extract_LogLuvVSetField_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: Luv24fromLuv48
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_Luv24fromLuv48_def@
type T;
identifier F = Luv24fromLuv48;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_Luv24fromLuv48_def@
F << remove_static_Luv24fromLuv48_def.F;
T << remove_static_Luv24fromLuv48_def.T;
P << remove_static_Luv24fromLuv48_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_Luv24fromLuv48_def_void@
identifier F = Luv24fromLuv48;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_Luv24fromLuv48_def_void@
F << remove_static_Luv24fromLuv48_def_void.F;
P << remove_static_Luv24fromLuv48_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_Luv24fromLuv48_decl@
type T;
identifier F = Luv24fromLuv48;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_Luv24fromLuv48_decl@
F << remove_static_Luv24fromLuv48_decl.F;
T << remove_static_Luv24fromLuv48_decl.T;
P << remove_static_Luv24fromLuv48_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_Luv24fromLuv48_decl_void@
identifier F = Luv24fromLuv48;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_Luv24fromLuv48_decl_void@
F << remove_static_Luv24fromLuv48_decl_void.F;
P << remove_static_Luv24fromLuv48_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_Luv24fromLuv48_def@
type T;
identifier F = Luv24fromLuv48;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_Luv24fromLuv48_def@
F << extract_Luv24fromLuv48_def.F;
T << extract_Luv24fromLuv48_def.T;
P << extract_Luv24fromLuv48_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_Luv24fromLuv48_def_void@
identifier F = Luv24fromLuv48;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_Luv24fromLuv48_def_void@
F << extract_Luv24fromLuv48_def_void.F;
P << extract_Luv24fromLuv48_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_Luv24fromLuv48_decl@
type T;
identifier F = Luv24fromLuv48;
parameter list P;
@@
T F(P);

@script:python depends on extract_Luv24fromLuv48_decl@
F << extract_Luv24fromLuv48_decl.F;
T << extract_Luv24fromLuv48_decl.T;
P << extract_Luv24fromLuv48_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_Luv24fromLuv48_decl_void@
identifier F = Luv24fromLuv48;
parameter list P;
@@
void F(P);

@script:python depends on extract_Luv24fromLuv48_decl_void@
F << extract_Luv24fromLuv48_decl_void.F;
P << extract_Luv24fromLuv48_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: Luv24fromXYZ
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_Luv24fromXYZ_def@
type T;
identifier F = Luv24fromXYZ;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_Luv24fromXYZ_def@
F << remove_static_Luv24fromXYZ_def.F;
T << remove_static_Luv24fromXYZ_def.T;
P << remove_static_Luv24fromXYZ_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_Luv24fromXYZ_def_void@
identifier F = Luv24fromXYZ;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_Luv24fromXYZ_def_void@
F << remove_static_Luv24fromXYZ_def_void.F;
P << remove_static_Luv24fromXYZ_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_Luv24fromXYZ_decl@
type T;
identifier F = Luv24fromXYZ;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_Luv24fromXYZ_decl@
F << remove_static_Luv24fromXYZ_decl.F;
T << remove_static_Luv24fromXYZ_decl.T;
P << remove_static_Luv24fromXYZ_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_Luv24fromXYZ_decl_void@
identifier F = Luv24fromXYZ;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_Luv24fromXYZ_decl_void@
F << remove_static_Luv24fromXYZ_decl_void.F;
P << remove_static_Luv24fromXYZ_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_Luv24fromXYZ_def@
type T;
identifier F = Luv24fromXYZ;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_Luv24fromXYZ_def@
F << extract_Luv24fromXYZ_def.F;
T << extract_Luv24fromXYZ_def.T;
P << extract_Luv24fromXYZ_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_Luv24fromXYZ_def_void@
identifier F = Luv24fromXYZ;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_Luv24fromXYZ_def_void@
F << extract_Luv24fromXYZ_def_void.F;
P << extract_Luv24fromXYZ_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_Luv24fromXYZ_decl@
type T;
identifier F = Luv24fromXYZ;
parameter list P;
@@
T F(P);

@script:python depends on extract_Luv24fromXYZ_decl@
F << extract_Luv24fromXYZ_decl.F;
T << extract_Luv24fromXYZ_decl.T;
P << extract_Luv24fromXYZ_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_Luv24fromXYZ_decl_void@
identifier F = Luv24fromXYZ;
parameter list P;
@@
void F(P);

@script:python depends on extract_Luv24fromXYZ_decl_void@
F << extract_Luv24fromXYZ_decl_void.F;
P << extract_Luv24fromXYZ_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: Luv24toLuv48
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_Luv24toLuv48_def@
type T;
identifier F = Luv24toLuv48;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_Luv24toLuv48_def@
F << remove_static_Luv24toLuv48_def.F;
T << remove_static_Luv24toLuv48_def.T;
P << remove_static_Luv24toLuv48_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_Luv24toLuv48_def_void@
identifier F = Luv24toLuv48;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_Luv24toLuv48_def_void@
F << remove_static_Luv24toLuv48_def_void.F;
P << remove_static_Luv24toLuv48_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_Luv24toLuv48_decl@
type T;
identifier F = Luv24toLuv48;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_Luv24toLuv48_decl@
F << remove_static_Luv24toLuv48_decl.F;
T << remove_static_Luv24toLuv48_decl.T;
P << remove_static_Luv24toLuv48_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_Luv24toLuv48_decl_void@
identifier F = Luv24toLuv48;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_Luv24toLuv48_decl_void@
F << remove_static_Luv24toLuv48_decl_void.F;
P << remove_static_Luv24toLuv48_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_Luv24toLuv48_def@
type T;
identifier F = Luv24toLuv48;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_Luv24toLuv48_def@
F << extract_Luv24toLuv48_def.F;
T << extract_Luv24toLuv48_def.T;
P << extract_Luv24toLuv48_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_Luv24toLuv48_def_void@
identifier F = Luv24toLuv48;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_Luv24toLuv48_def_void@
F << extract_Luv24toLuv48_def_void.F;
P << extract_Luv24toLuv48_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_Luv24toLuv48_decl@
type T;
identifier F = Luv24toLuv48;
parameter list P;
@@
T F(P);

@script:python depends on extract_Luv24toLuv48_decl@
F << extract_Luv24toLuv48_decl.F;
T << extract_Luv24toLuv48_decl.T;
P << extract_Luv24toLuv48_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_Luv24toLuv48_decl_void@
identifier F = Luv24toLuv48;
parameter list P;
@@
void F(P);

@script:python depends on extract_Luv24toLuv48_decl_void@
F << extract_Luv24toLuv48_decl_void.F;
P << extract_Luv24toLuv48_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: Luv24toRGB
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_Luv24toRGB_def@
type T;
identifier F = Luv24toRGB;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_Luv24toRGB_def@
F << remove_static_Luv24toRGB_def.F;
T << remove_static_Luv24toRGB_def.T;
P << remove_static_Luv24toRGB_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_Luv24toRGB_def_void@
identifier F = Luv24toRGB;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_Luv24toRGB_def_void@
F << remove_static_Luv24toRGB_def_void.F;
P << remove_static_Luv24toRGB_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_Luv24toRGB_decl@
type T;
identifier F = Luv24toRGB;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_Luv24toRGB_decl@
F << remove_static_Luv24toRGB_decl.F;
T << remove_static_Luv24toRGB_decl.T;
P << remove_static_Luv24toRGB_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_Luv24toRGB_decl_void@
identifier F = Luv24toRGB;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_Luv24toRGB_decl_void@
F << remove_static_Luv24toRGB_decl_void.F;
P << remove_static_Luv24toRGB_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_Luv24toRGB_def@
type T;
identifier F = Luv24toRGB;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_Luv24toRGB_def@
F << extract_Luv24toRGB_def.F;
T << extract_Luv24toRGB_def.T;
P << extract_Luv24toRGB_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_Luv24toRGB_def_void@
identifier F = Luv24toRGB;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_Luv24toRGB_def_void@
F << extract_Luv24toRGB_def_void.F;
P << extract_Luv24toRGB_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_Luv24toRGB_decl@
type T;
identifier F = Luv24toRGB;
parameter list P;
@@
T F(P);

@script:python depends on extract_Luv24toRGB_decl@
F << extract_Luv24toRGB_decl.F;
T << extract_Luv24toRGB_decl.T;
P << extract_Luv24toRGB_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_Luv24toRGB_decl_void@
identifier F = Luv24toRGB;
parameter list P;
@@
void F(P);

@script:python depends on extract_Luv24toRGB_decl_void@
F << extract_Luv24toRGB_decl_void.F;
P << extract_Luv24toRGB_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: Luv24toXYZ
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_Luv24toXYZ_def@
type T;
identifier F = Luv24toXYZ;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_Luv24toXYZ_def@
F << remove_static_Luv24toXYZ_def.F;
T << remove_static_Luv24toXYZ_def.T;
P << remove_static_Luv24toXYZ_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_Luv24toXYZ_def_void@
identifier F = Luv24toXYZ;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_Luv24toXYZ_def_void@
F << remove_static_Luv24toXYZ_def_void.F;
P << remove_static_Luv24toXYZ_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_Luv24toXYZ_decl@
type T;
identifier F = Luv24toXYZ;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_Luv24toXYZ_decl@
F << remove_static_Luv24toXYZ_decl.F;
T << remove_static_Luv24toXYZ_decl.T;
P << remove_static_Luv24toXYZ_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_Luv24toXYZ_decl_void@
identifier F = Luv24toXYZ;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_Luv24toXYZ_decl_void@
F << remove_static_Luv24toXYZ_decl_void.F;
P << remove_static_Luv24toXYZ_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_Luv24toXYZ_def@
type T;
identifier F = Luv24toXYZ;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_Luv24toXYZ_def@
F << extract_Luv24toXYZ_def.F;
T << extract_Luv24toXYZ_def.T;
P << extract_Luv24toXYZ_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_Luv24toXYZ_def_void@
identifier F = Luv24toXYZ;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_Luv24toXYZ_def_void@
F << extract_Luv24toXYZ_def_void.F;
P << extract_Luv24toXYZ_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_Luv24toXYZ_decl@
type T;
identifier F = Luv24toXYZ;
parameter list P;
@@
T F(P);

@script:python depends on extract_Luv24toXYZ_decl@
F << extract_Luv24toXYZ_decl.F;
T << extract_Luv24toXYZ_decl.T;
P << extract_Luv24toXYZ_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_Luv24toXYZ_decl_void@
identifier F = Luv24toXYZ;
parameter list P;
@@
void F(P);

@script:python depends on extract_Luv24toXYZ_decl_void@
F << extract_Luv24toXYZ_decl_void.F;
P << extract_Luv24toXYZ_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: Luv32fromLuv48
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_Luv32fromLuv48_def@
type T;
identifier F = Luv32fromLuv48;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_Luv32fromLuv48_def@
F << remove_static_Luv32fromLuv48_def.F;
T << remove_static_Luv32fromLuv48_def.T;
P << remove_static_Luv32fromLuv48_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_Luv32fromLuv48_def_void@
identifier F = Luv32fromLuv48;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_Luv32fromLuv48_def_void@
F << remove_static_Luv32fromLuv48_def_void.F;
P << remove_static_Luv32fromLuv48_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_Luv32fromLuv48_decl@
type T;
identifier F = Luv32fromLuv48;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_Luv32fromLuv48_decl@
F << remove_static_Luv32fromLuv48_decl.F;
T << remove_static_Luv32fromLuv48_decl.T;
P << remove_static_Luv32fromLuv48_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_Luv32fromLuv48_decl_void@
identifier F = Luv32fromLuv48;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_Luv32fromLuv48_decl_void@
F << remove_static_Luv32fromLuv48_decl_void.F;
P << remove_static_Luv32fromLuv48_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_Luv32fromLuv48_def@
type T;
identifier F = Luv32fromLuv48;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_Luv32fromLuv48_def@
F << extract_Luv32fromLuv48_def.F;
T << extract_Luv32fromLuv48_def.T;
P << extract_Luv32fromLuv48_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_Luv32fromLuv48_def_void@
identifier F = Luv32fromLuv48;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_Luv32fromLuv48_def_void@
F << extract_Luv32fromLuv48_def_void.F;
P << extract_Luv32fromLuv48_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_Luv32fromLuv48_decl@
type T;
identifier F = Luv32fromLuv48;
parameter list P;
@@
T F(P);

@script:python depends on extract_Luv32fromLuv48_decl@
F << extract_Luv32fromLuv48_decl.F;
T << extract_Luv32fromLuv48_decl.T;
P << extract_Luv32fromLuv48_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_Luv32fromLuv48_decl_void@
identifier F = Luv32fromLuv48;
parameter list P;
@@
void F(P);

@script:python depends on extract_Luv32fromLuv48_decl_void@
F << extract_Luv32fromLuv48_decl_void.F;
P << extract_Luv32fromLuv48_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: Luv32fromXYZ
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_Luv32fromXYZ_def@
type T;
identifier F = Luv32fromXYZ;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_Luv32fromXYZ_def@
F << remove_static_Luv32fromXYZ_def.F;
T << remove_static_Luv32fromXYZ_def.T;
P << remove_static_Luv32fromXYZ_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_Luv32fromXYZ_def_void@
identifier F = Luv32fromXYZ;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_Luv32fromXYZ_def_void@
F << remove_static_Luv32fromXYZ_def_void.F;
P << remove_static_Luv32fromXYZ_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_Luv32fromXYZ_decl@
type T;
identifier F = Luv32fromXYZ;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_Luv32fromXYZ_decl@
F << remove_static_Luv32fromXYZ_decl.F;
T << remove_static_Luv32fromXYZ_decl.T;
P << remove_static_Luv32fromXYZ_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_Luv32fromXYZ_decl_void@
identifier F = Luv32fromXYZ;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_Luv32fromXYZ_decl_void@
F << remove_static_Luv32fromXYZ_decl_void.F;
P << remove_static_Luv32fromXYZ_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_Luv32fromXYZ_def@
type T;
identifier F = Luv32fromXYZ;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_Luv32fromXYZ_def@
F << extract_Luv32fromXYZ_def.F;
T << extract_Luv32fromXYZ_def.T;
P << extract_Luv32fromXYZ_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_Luv32fromXYZ_def_void@
identifier F = Luv32fromXYZ;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_Luv32fromXYZ_def_void@
F << extract_Luv32fromXYZ_def_void.F;
P << extract_Luv32fromXYZ_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_Luv32fromXYZ_decl@
type T;
identifier F = Luv32fromXYZ;
parameter list P;
@@
T F(P);

@script:python depends on extract_Luv32fromXYZ_decl@
F << extract_Luv32fromXYZ_decl.F;
T << extract_Luv32fromXYZ_decl.T;
P << extract_Luv32fromXYZ_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_Luv32fromXYZ_decl_void@
identifier F = Luv32fromXYZ;
parameter list P;
@@
void F(P);

@script:python depends on extract_Luv32fromXYZ_decl_void@
F << extract_Luv32fromXYZ_decl_void.F;
P << extract_Luv32fromXYZ_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: Luv32toLuv48
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_Luv32toLuv48_def@
type T;
identifier F = Luv32toLuv48;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_Luv32toLuv48_def@
F << remove_static_Luv32toLuv48_def.F;
T << remove_static_Luv32toLuv48_def.T;
P << remove_static_Luv32toLuv48_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_Luv32toLuv48_def_void@
identifier F = Luv32toLuv48;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_Luv32toLuv48_def_void@
F << remove_static_Luv32toLuv48_def_void.F;
P << remove_static_Luv32toLuv48_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_Luv32toLuv48_decl@
type T;
identifier F = Luv32toLuv48;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_Luv32toLuv48_decl@
F << remove_static_Luv32toLuv48_decl.F;
T << remove_static_Luv32toLuv48_decl.T;
P << remove_static_Luv32toLuv48_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_Luv32toLuv48_decl_void@
identifier F = Luv32toLuv48;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_Luv32toLuv48_decl_void@
F << remove_static_Luv32toLuv48_decl_void.F;
P << remove_static_Luv32toLuv48_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_Luv32toLuv48_def@
type T;
identifier F = Luv32toLuv48;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_Luv32toLuv48_def@
F << extract_Luv32toLuv48_def.F;
T << extract_Luv32toLuv48_def.T;
P << extract_Luv32toLuv48_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_Luv32toLuv48_def_void@
identifier F = Luv32toLuv48;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_Luv32toLuv48_def_void@
F << extract_Luv32toLuv48_def_void.F;
P << extract_Luv32toLuv48_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_Luv32toLuv48_decl@
type T;
identifier F = Luv32toLuv48;
parameter list P;
@@
T F(P);

@script:python depends on extract_Luv32toLuv48_decl@
F << extract_Luv32toLuv48_decl.F;
T << extract_Luv32toLuv48_decl.T;
P << extract_Luv32toLuv48_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_Luv32toLuv48_decl_void@
identifier F = Luv32toLuv48;
parameter list P;
@@
void F(P);

@script:python depends on extract_Luv32toLuv48_decl_void@
F << extract_Luv32toLuv48_decl_void.F;
P << extract_Luv32toLuv48_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: Luv32toRGB
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_Luv32toRGB_def@
type T;
identifier F = Luv32toRGB;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_Luv32toRGB_def@
F << remove_static_Luv32toRGB_def.F;
T << remove_static_Luv32toRGB_def.T;
P << remove_static_Luv32toRGB_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_Luv32toRGB_def_void@
identifier F = Luv32toRGB;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_Luv32toRGB_def_void@
F << remove_static_Luv32toRGB_def_void.F;
P << remove_static_Luv32toRGB_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_Luv32toRGB_decl@
type T;
identifier F = Luv32toRGB;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_Luv32toRGB_decl@
F << remove_static_Luv32toRGB_decl.F;
T << remove_static_Luv32toRGB_decl.T;
P << remove_static_Luv32toRGB_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_Luv32toRGB_decl_void@
identifier F = Luv32toRGB;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_Luv32toRGB_decl_void@
F << remove_static_Luv32toRGB_decl_void.F;
P << remove_static_Luv32toRGB_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_Luv32toRGB_def@
type T;
identifier F = Luv32toRGB;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_Luv32toRGB_def@
F << extract_Luv32toRGB_def.F;
T << extract_Luv32toRGB_def.T;
P << extract_Luv32toRGB_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_Luv32toRGB_def_void@
identifier F = Luv32toRGB;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_Luv32toRGB_def_void@
F << extract_Luv32toRGB_def_void.F;
P << extract_Luv32toRGB_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_Luv32toRGB_decl@
type T;
identifier F = Luv32toRGB;
parameter list P;
@@
T F(P);

@script:python depends on extract_Luv32toRGB_decl@
F << extract_Luv32toRGB_decl.F;
T << extract_Luv32toRGB_decl.T;
P << extract_Luv32toRGB_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_Luv32toRGB_decl_void@
identifier F = Luv32toRGB;
parameter list P;
@@
void F(P);

@script:python depends on extract_Luv32toRGB_decl_void@
F << extract_Luv32toRGB_decl_void.F;
P << extract_Luv32toRGB_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: Luv32toXYZ
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_Luv32toXYZ_def@
type T;
identifier F = Luv32toXYZ;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_Luv32toXYZ_def@
F << remove_static_Luv32toXYZ_def.F;
T << remove_static_Luv32toXYZ_def.T;
P << remove_static_Luv32toXYZ_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_Luv32toXYZ_def_void@
identifier F = Luv32toXYZ;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_Luv32toXYZ_def_void@
F << remove_static_Luv32toXYZ_def_void.F;
P << remove_static_Luv32toXYZ_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_Luv32toXYZ_decl@
type T;
identifier F = Luv32toXYZ;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_Luv32toXYZ_decl@
F << remove_static_Luv32toXYZ_decl.F;
T << remove_static_Luv32toXYZ_decl.T;
P << remove_static_Luv32toXYZ_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_Luv32toXYZ_decl_void@
identifier F = Luv32toXYZ;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_Luv32toXYZ_decl_void@
F << remove_static_Luv32toXYZ_decl_void.F;
P << remove_static_Luv32toXYZ_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_Luv32toXYZ_def@
type T;
identifier F = Luv32toXYZ;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_Luv32toXYZ_def@
F << extract_Luv32toXYZ_def.F;
T << extract_Luv32toXYZ_def.T;
P << extract_Luv32toXYZ_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_Luv32toXYZ_def_void@
identifier F = Luv32toXYZ;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_Luv32toXYZ_def_void@
F << extract_Luv32toXYZ_def_void.F;
P << extract_Luv32toXYZ_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_Luv32toXYZ_decl@
type T;
identifier F = Luv32toXYZ;
parameter list P;
@@
T F(P);

@script:python depends on extract_Luv32toXYZ_decl@
F << extract_Luv32toXYZ_decl.F;
T << extract_Luv32toXYZ_decl.T;
P << extract_Luv32toXYZ_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_Luv32toXYZ_decl_void@
identifier F = Luv32toXYZ;
parameter list P;
@@
void F(P);

@script:python depends on extract_Luv32toXYZ_decl_void@
F << extract_Luv32toXYZ_decl_void.F;
P << extract_Luv32toXYZ_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: NeXTDecode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_NeXTDecode_def@
type T;
identifier F = NeXTDecode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_NeXTDecode_def@
F << remove_static_NeXTDecode_def.F;
T << remove_static_NeXTDecode_def.T;
P << remove_static_NeXTDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_NeXTDecode_def_void@
identifier F = NeXTDecode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_NeXTDecode_def_void@
F << remove_static_NeXTDecode_def_void.F;
P << remove_static_NeXTDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_NeXTDecode_decl@
type T;
identifier F = NeXTDecode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_NeXTDecode_decl@
F << remove_static_NeXTDecode_decl.F;
T << remove_static_NeXTDecode_decl.T;
P << remove_static_NeXTDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_NeXTDecode_decl_void@
identifier F = NeXTDecode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_NeXTDecode_decl_void@
F << remove_static_NeXTDecode_decl_void.F;
P << remove_static_NeXTDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_NeXTDecode_def@
type T;
identifier F = NeXTDecode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_NeXTDecode_def@
F << extract_NeXTDecode_def.F;
T << extract_NeXTDecode_def.T;
P << extract_NeXTDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_NeXTDecode_def_void@
identifier F = NeXTDecode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_NeXTDecode_def_void@
F << extract_NeXTDecode_def_void.F;
P << extract_NeXTDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_NeXTDecode_decl@
type T;
identifier F = NeXTDecode;
parameter list P;
@@
T F(P);

@script:python depends on extract_NeXTDecode_decl@
F << extract_NeXTDecode_decl.F;
T << extract_NeXTDecode_decl.T;
P << extract_NeXTDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_NeXTDecode_decl_void@
identifier F = NeXTDecode;
parameter list P;
@@
void F(P);

@script:python depends on extract_NeXTDecode_decl_void@
F << extract_NeXTDecode_decl_void.F;
P << extract_NeXTDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: NeXTPreDecode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_NeXTPreDecode_def@
type T;
identifier F = NeXTPreDecode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_NeXTPreDecode_def@
F << remove_static_NeXTPreDecode_def.F;
T << remove_static_NeXTPreDecode_def.T;
P << remove_static_NeXTPreDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_NeXTPreDecode_def_void@
identifier F = NeXTPreDecode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_NeXTPreDecode_def_void@
F << remove_static_NeXTPreDecode_def_void.F;
P << remove_static_NeXTPreDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_NeXTPreDecode_decl@
type T;
identifier F = NeXTPreDecode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_NeXTPreDecode_decl@
F << remove_static_NeXTPreDecode_decl.F;
T << remove_static_NeXTPreDecode_decl.T;
P << remove_static_NeXTPreDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_NeXTPreDecode_decl_void@
identifier F = NeXTPreDecode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_NeXTPreDecode_decl_void@
F << remove_static_NeXTPreDecode_decl_void.F;
P << remove_static_NeXTPreDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_NeXTPreDecode_def@
type T;
identifier F = NeXTPreDecode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_NeXTPreDecode_def@
F << extract_NeXTPreDecode_def.F;
T << extract_NeXTPreDecode_def.T;
P << extract_NeXTPreDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_NeXTPreDecode_def_void@
identifier F = NeXTPreDecode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_NeXTPreDecode_def_void@
F << extract_NeXTPreDecode_def_void.F;
P << extract_NeXTPreDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_NeXTPreDecode_decl@
type T;
identifier F = NeXTPreDecode;
parameter list P;
@@
T F(P);

@script:python depends on extract_NeXTPreDecode_decl@
F << extract_NeXTPreDecode_decl.F;
T << extract_NeXTPreDecode_decl.T;
P << extract_NeXTPreDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_NeXTPreDecode_decl_void@
identifier F = NeXTPreDecode;
parameter list P;
@@
void F(P);

@script:python depends on extract_NeXTPreDecode_decl_void@
F << extract_NeXTPreDecode_decl_void.F;
P << extract_NeXTPreDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: OJPEGCleanup
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_OJPEGCleanup_def@
type T;
identifier F = OJPEGCleanup;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_OJPEGCleanup_def@
F << remove_static_OJPEGCleanup_def.F;
T << remove_static_OJPEGCleanup_def.T;
P << remove_static_OJPEGCleanup_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_OJPEGCleanup_def_void@
identifier F = OJPEGCleanup;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_OJPEGCleanup_def_void@
F << remove_static_OJPEGCleanup_def_void.F;
P << remove_static_OJPEGCleanup_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_OJPEGCleanup_decl@
type T;
identifier F = OJPEGCleanup;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_OJPEGCleanup_decl@
F << remove_static_OJPEGCleanup_decl.F;
T << remove_static_OJPEGCleanup_decl.T;
P << remove_static_OJPEGCleanup_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_OJPEGCleanup_decl_void@
identifier F = OJPEGCleanup;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_OJPEGCleanup_decl_void@
F << remove_static_OJPEGCleanup_decl_void.F;
P << remove_static_OJPEGCleanup_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_OJPEGCleanup_def@
type T;
identifier F = OJPEGCleanup;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_OJPEGCleanup_def@
F << extract_OJPEGCleanup_def.F;
T << extract_OJPEGCleanup_def.T;
P << extract_OJPEGCleanup_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_OJPEGCleanup_def_void@
identifier F = OJPEGCleanup;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_OJPEGCleanup_def_void@
F << extract_OJPEGCleanup_def_void.F;
P << extract_OJPEGCleanup_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_OJPEGCleanup_decl@
type T;
identifier F = OJPEGCleanup;
parameter list P;
@@
T F(P);

@script:python depends on extract_OJPEGCleanup_decl@
F << extract_OJPEGCleanup_decl.F;
T << extract_OJPEGCleanup_decl.T;
P << extract_OJPEGCleanup_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_OJPEGCleanup_decl_void@
identifier F = OJPEGCleanup;
parameter list P;
@@
void F(P);

@script:python depends on extract_OJPEGCleanup_decl_void@
F << extract_OJPEGCleanup_decl_void.F;
P << extract_OJPEGCleanup_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: OJPEGDecode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_OJPEGDecode_def@
type T;
identifier F = OJPEGDecode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_OJPEGDecode_def@
F << remove_static_OJPEGDecode_def.F;
T << remove_static_OJPEGDecode_def.T;
P << remove_static_OJPEGDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_OJPEGDecode_def_void@
identifier F = OJPEGDecode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_OJPEGDecode_def_void@
F << remove_static_OJPEGDecode_def_void.F;
P << remove_static_OJPEGDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_OJPEGDecode_decl@
type T;
identifier F = OJPEGDecode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_OJPEGDecode_decl@
F << remove_static_OJPEGDecode_decl.F;
T << remove_static_OJPEGDecode_decl.T;
P << remove_static_OJPEGDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_OJPEGDecode_decl_void@
identifier F = OJPEGDecode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_OJPEGDecode_decl_void@
F << remove_static_OJPEGDecode_decl_void.F;
P << remove_static_OJPEGDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_OJPEGDecode_def@
type T;
identifier F = OJPEGDecode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_OJPEGDecode_def@
F << extract_OJPEGDecode_def.F;
T << extract_OJPEGDecode_def.T;
P << extract_OJPEGDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_OJPEGDecode_def_void@
identifier F = OJPEGDecode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_OJPEGDecode_def_void@
F << extract_OJPEGDecode_def_void.F;
P << extract_OJPEGDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_OJPEGDecode_decl@
type T;
identifier F = OJPEGDecode;
parameter list P;
@@
T F(P);

@script:python depends on extract_OJPEGDecode_decl@
F << extract_OJPEGDecode_decl.F;
T << extract_OJPEGDecode_decl.T;
P << extract_OJPEGDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_OJPEGDecode_decl_void@
identifier F = OJPEGDecode;
parameter list P;
@@
void F(P);

@script:python depends on extract_OJPEGDecode_decl_void@
F << extract_OJPEGDecode_decl_void.F;
P << extract_OJPEGDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: OJPEGEncode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_OJPEGEncode_def@
type T;
identifier F = OJPEGEncode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_OJPEGEncode_def@
F << remove_static_OJPEGEncode_def.F;
T << remove_static_OJPEGEncode_def.T;
P << remove_static_OJPEGEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_OJPEGEncode_def_void@
identifier F = OJPEGEncode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_OJPEGEncode_def_void@
F << remove_static_OJPEGEncode_def_void.F;
P << remove_static_OJPEGEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_OJPEGEncode_decl@
type T;
identifier F = OJPEGEncode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_OJPEGEncode_decl@
F << remove_static_OJPEGEncode_decl.F;
T << remove_static_OJPEGEncode_decl.T;
P << remove_static_OJPEGEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_OJPEGEncode_decl_void@
identifier F = OJPEGEncode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_OJPEGEncode_decl_void@
F << remove_static_OJPEGEncode_decl_void.F;
P << remove_static_OJPEGEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_OJPEGEncode_def@
type T;
identifier F = OJPEGEncode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_OJPEGEncode_def@
F << extract_OJPEGEncode_def.F;
T << extract_OJPEGEncode_def.T;
P << extract_OJPEGEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_OJPEGEncode_def_void@
identifier F = OJPEGEncode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_OJPEGEncode_def_void@
F << extract_OJPEGEncode_def_void.F;
P << extract_OJPEGEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_OJPEGEncode_decl@
type T;
identifier F = OJPEGEncode;
parameter list P;
@@
T F(P);

@script:python depends on extract_OJPEGEncode_decl@
F << extract_OJPEGEncode_decl.F;
T << extract_OJPEGEncode_decl.T;
P << extract_OJPEGEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_OJPEGEncode_decl_void@
identifier F = OJPEGEncode;
parameter list P;
@@
void F(P);

@script:python depends on extract_OJPEGEncode_decl_void@
F << extract_OJPEGEncode_decl_void.F;
P << extract_OJPEGEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: OJPEGFixupTags
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_OJPEGFixupTags_def@
type T;
identifier F = OJPEGFixupTags;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_OJPEGFixupTags_def@
F << remove_static_OJPEGFixupTags_def.F;
T << remove_static_OJPEGFixupTags_def.T;
P << remove_static_OJPEGFixupTags_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_OJPEGFixupTags_def_void@
identifier F = OJPEGFixupTags;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_OJPEGFixupTags_def_void@
F << remove_static_OJPEGFixupTags_def_void.F;
P << remove_static_OJPEGFixupTags_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_OJPEGFixupTags_decl@
type T;
identifier F = OJPEGFixupTags;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_OJPEGFixupTags_decl@
F << remove_static_OJPEGFixupTags_decl.F;
T << remove_static_OJPEGFixupTags_decl.T;
P << remove_static_OJPEGFixupTags_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_OJPEGFixupTags_decl_void@
identifier F = OJPEGFixupTags;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_OJPEGFixupTags_decl_void@
F << remove_static_OJPEGFixupTags_decl_void.F;
P << remove_static_OJPEGFixupTags_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_OJPEGFixupTags_def@
type T;
identifier F = OJPEGFixupTags;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_OJPEGFixupTags_def@
F << extract_OJPEGFixupTags_def.F;
T << extract_OJPEGFixupTags_def.T;
P << extract_OJPEGFixupTags_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_OJPEGFixupTags_def_void@
identifier F = OJPEGFixupTags;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_OJPEGFixupTags_def_void@
F << extract_OJPEGFixupTags_def_void.F;
P << extract_OJPEGFixupTags_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_OJPEGFixupTags_decl@
type T;
identifier F = OJPEGFixupTags;
parameter list P;
@@
T F(P);

@script:python depends on extract_OJPEGFixupTags_decl@
F << extract_OJPEGFixupTags_decl.F;
T << extract_OJPEGFixupTags_decl.T;
P << extract_OJPEGFixupTags_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_OJPEGFixupTags_decl_void@
identifier F = OJPEGFixupTags;
parameter list P;
@@
void F(P);

@script:python depends on extract_OJPEGFixupTags_decl_void@
F << extract_OJPEGFixupTags_decl_void.F;
P << extract_OJPEGFixupTags_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: OJPEGPostDecode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_OJPEGPostDecode_def@
type T;
identifier F = OJPEGPostDecode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_OJPEGPostDecode_def@
F << remove_static_OJPEGPostDecode_def.F;
T << remove_static_OJPEGPostDecode_def.T;
P << remove_static_OJPEGPostDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_OJPEGPostDecode_def_void@
identifier F = OJPEGPostDecode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_OJPEGPostDecode_def_void@
F << remove_static_OJPEGPostDecode_def_void.F;
P << remove_static_OJPEGPostDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_OJPEGPostDecode_decl@
type T;
identifier F = OJPEGPostDecode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_OJPEGPostDecode_decl@
F << remove_static_OJPEGPostDecode_decl.F;
T << remove_static_OJPEGPostDecode_decl.T;
P << remove_static_OJPEGPostDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_OJPEGPostDecode_decl_void@
identifier F = OJPEGPostDecode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_OJPEGPostDecode_decl_void@
F << remove_static_OJPEGPostDecode_decl_void.F;
P << remove_static_OJPEGPostDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_OJPEGPostDecode_def@
type T;
identifier F = OJPEGPostDecode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_OJPEGPostDecode_def@
F << extract_OJPEGPostDecode_def.F;
T << extract_OJPEGPostDecode_def.T;
P << extract_OJPEGPostDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_OJPEGPostDecode_def_void@
identifier F = OJPEGPostDecode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_OJPEGPostDecode_def_void@
F << extract_OJPEGPostDecode_def_void.F;
P << extract_OJPEGPostDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_OJPEGPostDecode_decl@
type T;
identifier F = OJPEGPostDecode;
parameter list P;
@@
T F(P);

@script:python depends on extract_OJPEGPostDecode_decl@
F << extract_OJPEGPostDecode_decl.F;
T << extract_OJPEGPostDecode_decl.T;
P << extract_OJPEGPostDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_OJPEGPostDecode_decl_void@
identifier F = OJPEGPostDecode;
parameter list P;
@@
void F(P);

@script:python depends on extract_OJPEGPostDecode_decl_void@
F << extract_OJPEGPostDecode_decl_void.F;
P << extract_OJPEGPostDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: OJPEGPostEncode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_OJPEGPostEncode_def@
type T;
identifier F = OJPEGPostEncode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_OJPEGPostEncode_def@
F << remove_static_OJPEGPostEncode_def.F;
T << remove_static_OJPEGPostEncode_def.T;
P << remove_static_OJPEGPostEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_OJPEGPostEncode_def_void@
identifier F = OJPEGPostEncode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_OJPEGPostEncode_def_void@
F << remove_static_OJPEGPostEncode_def_void.F;
P << remove_static_OJPEGPostEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_OJPEGPostEncode_decl@
type T;
identifier F = OJPEGPostEncode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_OJPEGPostEncode_decl@
F << remove_static_OJPEGPostEncode_decl.F;
T << remove_static_OJPEGPostEncode_decl.T;
P << remove_static_OJPEGPostEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_OJPEGPostEncode_decl_void@
identifier F = OJPEGPostEncode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_OJPEGPostEncode_decl_void@
F << remove_static_OJPEGPostEncode_decl_void.F;
P << remove_static_OJPEGPostEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_OJPEGPostEncode_def@
type T;
identifier F = OJPEGPostEncode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_OJPEGPostEncode_def@
F << extract_OJPEGPostEncode_def.F;
T << extract_OJPEGPostEncode_def.T;
P << extract_OJPEGPostEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_OJPEGPostEncode_def_void@
identifier F = OJPEGPostEncode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_OJPEGPostEncode_def_void@
F << extract_OJPEGPostEncode_def_void.F;
P << extract_OJPEGPostEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_OJPEGPostEncode_decl@
type T;
identifier F = OJPEGPostEncode;
parameter list P;
@@
T F(P);

@script:python depends on extract_OJPEGPostEncode_decl@
F << extract_OJPEGPostEncode_decl.F;
T << extract_OJPEGPostEncode_decl.T;
P << extract_OJPEGPostEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_OJPEGPostEncode_decl_void@
identifier F = OJPEGPostEncode;
parameter list P;
@@
void F(P);

@script:python depends on extract_OJPEGPostEncode_decl_void@
F << extract_OJPEGPostEncode_decl_void.F;
P << extract_OJPEGPostEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: OJPEGPreDecode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_OJPEGPreDecode_def@
type T;
identifier F = OJPEGPreDecode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_OJPEGPreDecode_def@
F << remove_static_OJPEGPreDecode_def.F;
T << remove_static_OJPEGPreDecode_def.T;
P << remove_static_OJPEGPreDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_OJPEGPreDecode_def_void@
identifier F = OJPEGPreDecode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_OJPEGPreDecode_def_void@
F << remove_static_OJPEGPreDecode_def_void.F;
P << remove_static_OJPEGPreDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_OJPEGPreDecode_decl@
type T;
identifier F = OJPEGPreDecode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_OJPEGPreDecode_decl@
F << remove_static_OJPEGPreDecode_decl.F;
T << remove_static_OJPEGPreDecode_decl.T;
P << remove_static_OJPEGPreDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_OJPEGPreDecode_decl_void@
identifier F = OJPEGPreDecode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_OJPEGPreDecode_decl_void@
F << remove_static_OJPEGPreDecode_decl_void.F;
P << remove_static_OJPEGPreDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_OJPEGPreDecode_def@
type T;
identifier F = OJPEGPreDecode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_OJPEGPreDecode_def@
F << extract_OJPEGPreDecode_def.F;
T << extract_OJPEGPreDecode_def.T;
P << extract_OJPEGPreDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_OJPEGPreDecode_def_void@
identifier F = OJPEGPreDecode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_OJPEGPreDecode_def_void@
F << extract_OJPEGPreDecode_def_void.F;
P << extract_OJPEGPreDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_OJPEGPreDecode_decl@
type T;
identifier F = OJPEGPreDecode;
parameter list P;
@@
T F(P);

@script:python depends on extract_OJPEGPreDecode_decl@
F << extract_OJPEGPreDecode_decl.F;
T << extract_OJPEGPreDecode_decl.T;
P << extract_OJPEGPreDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_OJPEGPreDecode_decl_void@
identifier F = OJPEGPreDecode;
parameter list P;
@@
void F(P);

@script:python depends on extract_OJPEGPreDecode_decl_void@
F << extract_OJPEGPreDecode_decl_void.F;
P << extract_OJPEGPreDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: OJPEGPreEncode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_OJPEGPreEncode_def@
type T;
identifier F = OJPEGPreEncode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_OJPEGPreEncode_def@
F << remove_static_OJPEGPreEncode_def.F;
T << remove_static_OJPEGPreEncode_def.T;
P << remove_static_OJPEGPreEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_OJPEGPreEncode_def_void@
identifier F = OJPEGPreEncode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_OJPEGPreEncode_def_void@
F << remove_static_OJPEGPreEncode_def_void.F;
P << remove_static_OJPEGPreEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_OJPEGPreEncode_decl@
type T;
identifier F = OJPEGPreEncode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_OJPEGPreEncode_decl@
F << remove_static_OJPEGPreEncode_decl.F;
T << remove_static_OJPEGPreEncode_decl.T;
P << remove_static_OJPEGPreEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_OJPEGPreEncode_decl_void@
identifier F = OJPEGPreEncode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_OJPEGPreEncode_decl_void@
F << remove_static_OJPEGPreEncode_decl_void.F;
P << remove_static_OJPEGPreEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_OJPEGPreEncode_def@
type T;
identifier F = OJPEGPreEncode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_OJPEGPreEncode_def@
F << extract_OJPEGPreEncode_def.F;
T << extract_OJPEGPreEncode_def.T;
P << extract_OJPEGPreEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_OJPEGPreEncode_def_void@
identifier F = OJPEGPreEncode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_OJPEGPreEncode_def_void@
F << extract_OJPEGPreEncode_def_void.F;
P << extract_OJPEGPreEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_OJPEGPreEncode_decl@
type T;
identifier F = OJPEGPreEncode;
parameter list P;
@@
T F(P);

@script:python depends on extract_OJPEGPreEncode_decl@
F << extract_OJPEGPreEncode_decl.F;
T << extract_OJPEGPreEncode_decl.T;
P << extract_OJPEGPreEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_OJPEGPreEncode_decl_void@
identifier F = OJPEGPreEncode;
parameter list P;
@@
void F(P);

@script:python depends on extract_OJPEGPreEncode_decl_void@
F << extract_OJPEGPreEncode_decl_void.F;
P << extract_OJPEGPreEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: OJPEGPrintDir
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_OJPEGPrintDir_def@
type T;
identifier F = OJPEGPrintDir;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_OJPEGPrintDir_def@
F << remove_static_OJPEGPrintDir_def.F;
T << remove_static_OJPEGPrintDir_def.T;
P << remove_static_OJPEGPrintDir_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_OJPEGPrintDir_def_void@
identifier F = OJPEGPrintDir;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_OJPEGPrintDir_def_void@
F << remove_static_OJPEGPrintDir_def_void.F;
P << remove_static_OJPEGPrintDir_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_OJPEGPrintDir_decl@
type T;
identifier F = OJPEGPrintDir;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_OJPEGPrintDir_decl@
F << remove_static_OJPEGPrintDir_decl.F;
T << remove_static_OJPEGPrintDir_decl.T;
P << remove_static_OJPEGPrintDir_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_OJPEGPrintDir_decl_void@
identifier F = OJPEGPrintDir;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_OJPEGPrintDir_decl_void@
F << remove_static_OJPEGPrintDir_decl_void.F;
P << remove_static_OJPEGPrintDir_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_OJPEGPrintDir_def@
type T;
identifier F = OJPEGPrintDir;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_OJPEGPrintDir_def@
F << extract_OJPEGPrintDir_def.F;
T << extract_OJPEGPrintDir_def.T;
P << extract_OJPEGPrintDir_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_OJPEGPrintDir_def_void@
identifier F = OJPEGPrintDir;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_OJPEGPrintDir_def_void@
F << extract_OJPEGPrintDir_def_void.F;
P << extract_OJPEGPrintDir_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_OJPEGPrintDir_decl@
type T;
identifier F = OJPEGPrintDir;
parameter list P;
@@
T F(P);

@script:python depends on extract_OJPEGPrintDir_decl@
F << extract_OJPEGPrintDir_decl.F;
T << extract_OJPEGPrintDir_decl.T;
P << extract_OJPEGPrintDir_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_OJPEGPrintDir_decl_void@
identifier F = OJPEGPrintDir;
parameter list P;
@@
void F(P);

@script:python depends on extract_OJPEGPrintDir_decl_void@
F << extract_OJPEGPrintDir_decl_void.F;
P << extract_OJPEGPrintDir_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: OJPEGSetupDecode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_OJPEGSetupDecode_def@
type T;
identifier F = OJPEGSetupDecode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_OJPEGSetupDecode_def@
F << remove_static_OJPEGSetupDecode_def.F;
T << remove_static_OJPEGSetupDecode_def.T;
P << remove_static_OJPEGSetupDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_OJPEGSetupDecode_def_void@
identifier F = OJPEGSetupDecode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_OJPEGSetupDecode_def_void@
F << remove_static_OJPEGSetupDecode_def_void.F;
P << remove_static_OJPEGSetupDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_OJPEGSetupDecode_decl@
type T;
identifier F = OJPEGSetupDecode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_OJPEGSetupDecode_decl@
F << remove_static_OJPEGSetupDecode_decl.F;
T << remove_static_OJPEGSetupDecode_decl.T;
P << remove_static_OJPEGSetupDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_OJPEGSetupDecode_decl_void@
identifier F = OJPEGSetupDecode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_OJPEGSetupDecode_decl_void@
F << remove_static_OJPEGSetupDecode_decl_void.F;
P << remove_static_OJPEGSetupDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_OJPEGSetupDecode_def@
type T;
identifier F = OJPEGSetupDecode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_OJPEGSetupDecode_def@
F << extract_OJPEGSetupDecode_def.F;
T << extract_OJPEGSetupDecode_def.T;
P << extract_OJPEGSetupDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_OJPEGSetupDecode_def_void@
identifier F = OJPEGSetupDecode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_OJPEGSetupDecode_def_void@
F << extract_OJPEGSetupDecode_def_void.F;
P << extract_OJPEGSetupDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_OJPEGSetupDecode_decl@
type T;
identifier F = OJPEGSetupDecode;
parameter list P;
@@
T F(P);

@script:python depends on extract_OJPEGSetupDecode_decl@
F << extract_OJPEGSetupDecode_decl.F;
T << extract_OJPEGSetupDecode_decl.T;
P << extract_OJPEGSetupDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_OJPEGSetupDecode_decl_void@
identifier F = OJPEGSetupDecode;
parameter list P;
@@
void F(P);

@script:python depends on extract_OJPEGSetupDecode_decl_void@
F << extract_OJPEGSetupDecode_decl_void.F;
P << extract_OJPEGSetupDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: OJPEGSetupEncode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_OJPEGSetupEncode_def@
type T;
identifier F = OJPEGSetupEncode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_OJPEGSetupEncode_def@
F << remove_static_OJPEGSetupEncode_def.F;
T << remove_static_OJPEGSetupEncode_def.T;
P << remove_static_OJPEGSetupEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_OJPEGSetupEncode_def_void@
identifier F = OJPEGSetupEncode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_OJPEGSetupEncode_def_void@
F << remove_static_OJPEGSetupEncode_def_void.F;
P << remove_static_OJPEGSetupEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_OJPEGSetupEncode_decl@
type T;
identifier F = OJPEGSetupEncode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_OJPEGSetupEncode_decl@
F << remove_static_OJPEGSetupEncode_decl.F;
T << remove_static_OJPEGSetupEncode_decl.T;
P << remove_static_OJPEGSetupEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_OJPEGSetupEncode_decl_void@
identifier F = OJPEGSetupEncode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_OJPEGSetupEncode_decl_void@
F << remove_static_OJPEGSetupEncode_decl_void.F;
P << remove_static_OJPEGSetupEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_OJPEGSetupEncode_def@
type T;
identifier F = OJPEGSetupEncode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_OJPEGSetupEncode_def@
F << extract_OJPEGSetupEncode_def.F;
T << extract_OJPEGSetupEncode_def.T;
P << extract_OJPEGSetupEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_OJPEGSetupEncode_def_void@
identifier F = OJPEGSetupEncode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_OJPEGSetupEncode_def_void@
F << extract_OJPEGSetupEncode_def_void.F;
P << extract_OJPEGSetupEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_OJPEGSetupEncode_decl@
type T;
identifier F = OJPEGSetupEncode;
parameter list P;
@@
T F(P);

@script:python depends on extract_OJPEGSetupEncode_decl@
F << extract_OJPEGSetupEncode_decl.F;
T << extract_OJPEGSetupEncode_decl.T;
P << extract_OJPEGSetupEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_OJPEGSetupEncode_decl_void@
identifier F = OJPEGSetupEncode;
parameter list P;
@@
void F(P);

@script:python depends on extract_OJPEGSetupEncode_decl_void@
F << extract_OJPEGSetupEncode_decl_void.F;
P << extract_OJPEGSetupEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: OJPEGVGetField
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_OJPEGVGetField_def@
type T;
identifier F = OJPEGVGetField;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_OJPEGVGetField_def@
F << remove_static_OJPEGVGetField_def.F;
T << remove_static_OJPEGVGetField_def.T;
P << remove_static_OJPEGVGetField_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_OJPEGVGetField_def_void@
identifier F = OJPEGVGetField;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_OJPEGVGetField_def_void@
F << remove_static_OJPEGVGetField_def_void.F;
P << remove_static_OJPEGVGetField_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_OJPEGVGetField_decl@
type T;
identifier F = OJPEGVGetField;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_OJPEGVGetField_decl@
F << remove_static_OJPEGVGetField_decl.F;
T << remove_static_OJPEGVGetField_decl.T;
P << remove_static_OJPEGVGetField_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_OJPEGVGetField_decl_void@
identifier F = OJPEGVGetField;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_OJPEGVGetField_decl_void@
F << remove_static_OJPEGVGetField_decl_void.F;
P << remove_static_OJPEGVGetField_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_OJPEGVGetField_def@
type T;
identifier F = OJPEGVGetField;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_OJPEGVGetField_def@
F << extract_OJPEGVGetField_def.F;
T << extract_OJPEGVGetField_def.T;
P << extract_OJPEGVGetField_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_OJPEGVGetField_def_void@
identifier F = OJPEGVGetField;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_OJPEGVGetField_def_void@
F << extract_OJPEGVGetField_def_void.F;
P << extract_OJPEGVGetField_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_OJPEGVGetField_decl@
type T;
identifier F = OJPEGVGetField;
parameter list P;
@@
T F(P);

@script:python depends on extract_OJPEGVGetField_decl@
F << extract_OJPEGVGetField_decl.F;
T << extract_OJPEGVGetField_decl.T;
P << extract_OJPEGVGetField_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_OJPEGVGetField_decl_void@
identifier F = OJPEGVGetField;
parameter list P;
@@
void F(P);

@script:python depends on extract_OJPEGVGetField_decl_void@
F << extract_OJPEGVGetField_decl_void.F;
P << extract_OJPEGVGetField_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: OJPEGVSetField
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_OJPEGVSetField_def@
type T;
identifier F = OJPEGVSetField;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_OJPEGVSetField_def@
F << remove_static_OJPEGVSetField_def.F;
T << remove_static_OJPEGVSetField_def.T;
P << remove_static_OJPEGVSetField_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_OJPEGVSetField_def_void@
identifier F = OJPEGVSetField;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_OJPEGVSetField_def_void@
F << remove_static_OJPEGVSetField_def_void.F;
P << remove_static_OJPEGVSetField_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_OJPEGVSetField_decl@
type T;
identifier F = OJPEGVSetField;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_OJPEGVSetField_decl@
F << remove_static_OJPEGVSetField_decl.F;
T << remove_static_OJPEGVSetField_decl.T;
P << remove_static_OJPEGVSetField_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_OJPEGVSetField_decl_void@
identifier F = OJPEGVSetField;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_OJPEGVSetField_decl_void@
F << remove_static_OJPEGVSetField_decl_void.F;
P << remove_static_OJPEGVSetField_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_OJPEGVSetField_def@
type T;
identifier F = OJPEGVSetField;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_OJPEGVSetField_def@
F << extract_OJPEGVSetField_def.F;
T << extract_OJPEGVSetField_def.T;
P << extract_OJPEGVSetField_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_OJPEGVSetField_def_void@
identifier F = OJPEGVSetField;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_OJPEGVSetField_def_void@
F << extract_OJPEGVSetField_def_void.F;
P << extract_OJPEGVSetField_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_OJPEGVSetField_decl@
type T;
identifier F = OJPEGVSetField;
parameter list P;
@@
T F(P);

@script:python depends on extract_OJPEGVSetField_decl@
F << extract_OJPEGVSetField_decl.F;
T << extract_OJPEGVSetField_decl.T;
P << extract_OJPEGVSetField_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_OJPEGVSetField_decl_void@
identifier F = OJPEGVSetField;
parameter list P;
@@
void F(P);

@script:python depends on extract_OJPEGVSetField_decl_void@
F << extract_OJPEGVSetField_decl_void.F;
P << extract_OJPEGVSetField_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: PackBitsDecode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_PackBitsDecode_def@
type T;
identifier F = PackBitsDecode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_PackBitsDecode_def@
F << remove_static_PackBitsDecode_def.F;
T << remove_static_PackBitsDecode_def.T;
P << remove_static_PackBitsDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_PackBitsDecode_def_void@
identifier F = PackBitsDecode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_PackBitsDecode_def_void@
F << remove_static_PackBitsDecode_def_void.F;
P << remove_static_PackBitsDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_PackBitsDecode_decl@
type T;
identifier F = PackBitsDecode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_PackBitsDecode_decl@
F << remove_static_PackBitsDecode_decl.F;
T << remove_static_PackBitsDecode_decl.T;
P << remove_static_PackBitsDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_PackBitsDecode_decl_void@
identifier F = PackBitsDecode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_PackBitsDecode_decl_void@
F << remove_static_PackBitsDecode_decl_void.F;
P << remove_static_PackBitsDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_PackBitsDecode_def@
type T;
identifier F = PackBitsDecode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_PackBitsDecode_def@
F << extract_PackBitsDecode_def.F;
T << extract_PackBitsDecode_def.T;
P << extract_PackBitsDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_PackBitsDecode_def_void@
identifier F = PackBitsDecode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_PackBitsDecode_def_void@
F << extract_PackBitsDecode_def_void.F;
P << extract_PackBitsDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_PackBitsDecode_decl@
type T;
identifier F = PackBitsDecode;
parameter list P;
@@
T F(P);

@script:python depends on extract_PackBitsDecode_decl@
F << extract_PackBitsDecode_decl.F;
T << extract_PackBitsDecode_decl.T;
P << extract_PackBitsDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_PackBitsDecode_decl_void@
identifier F = PackBitsDecode;
parameter list P;
@@
void F(P);

@script:python depends on extract_PackBitsDecode_decl_void@
F << extract_PackBitsDecode_decl_void.F;
P << extract_PackBitsDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: PackBitsEncode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_PackBitsEncode_def@
type T;
identifier F = PackBitsEncode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_PackBitsEncode_def@
F << remove_static_PackBitsEncode_def.F;
T << remove_static_PackBitsEncode_def.T;
P << remove_static_PackBitsEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_PackBitsEncode_def_void@
identifier F = PackBitsEncode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_PackBitsEncode_def_void@
F << remove_static_PackBitsEncode_def_void.F;
P << remove_static_PackBitsEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_PackBitsEncode_decl@
type T;
identifier F = PackBitsEncode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_PackBitsEncode_decl@
F << remove_static_PackBitsEncode_decl.F;
T << remove_static_PackBitsEncode_decl.T;
P << remove_static_PackBitsEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_PackBitsEncode_decl_void@
identifier F = PackBitsEncode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_PackBitsEncode_decl_void@
F << remove_static_PackBitsEncode_decl_void.F;
P << remove_static_PackBitsEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_PackBitsEncode_def@
type T;
identifier F = PackBitsEncode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_PackBitsEncode_def@
F << extract_PackBitsEncode_def.F;
T << extract_PackBitsEncode_def.T;
P << extract_PackBitsEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_PackBitsEncode_def_void@
identifier F = PackBitsEncode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_PackBitsEncode_def_void@
F << extract_PackBitsEncode_def_void.F;
P << extract_PackBitsEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_PackBitsEncode_decl@
type T;
identifier F = PackBitsEncode;
parameter list P;
@@
T F(P);

@script:python depends on extract_PackBitsEncode_decl@
F << extract_PackBitsEncode_decl.F;
T << extract_PackBitsEncode_decl.T;
P << extract_PackBitsEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_PackBitsEncode_decl_void@
identifier F = PackBitsEncode;
parameter list P;
@@
void F(P);

@script:python depends on extract_PackBitsEncode_decl_void@
F << extract_PackBitsEncode_decl_void.F;
P << extract_PackBitsEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: PackBitsEncodeChunk
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_PackBitsEncodeChunk_def@
type T;
identifier F = PackBitsEncodeChunk;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_PackBitsEncodeChunk_def@
F << remove_static_PackBitsEncodeChunk_def.F;
T << remove_static_PackBitsEncodeChunk_def.T;
P << remove_static_PackBitsEncodeChunk_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_PackBitsEncodeChunk_def_void@
identifier F = PackBitsEncodeChunk;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_PackBitsEncodeChunk_def_void@
F << remove_static_PackBitsEncodeChunk_def_void.F;
P << remove_static_PackBitsEncodeChunk_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_PackBitsEncodeChunk_decl@
type T;
identifier F = PackBitsEncodeChunk;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_PackBitsEncodeChunk_decl@
F << remove_static_PackBitsEncodeChunk_decl.F;
T << remove_static_PackBitsEncodeChunk_decl.T;
P << remove_static_PackBitsEncodeChunk_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_PackBitsEncodeChunk_decl_void@
identifier F = PackBitsEncodeChunk;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_PackBitsEncodeChunk_decl_void@
F << remove_static_PackBitsEncodeChunk_decl_void.F;
P << remove_static_PackBitsEncodeChunk_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_PackBitsEncodeChunk_def@
type T;
identifier F = PackBitsEncodeChunk;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_PackBitsEncodeChunk_def@
F << extract_PackBitsEncodeChunk_def.F;
T << extract_PackBitsEncodeChunk_def.T;
P << extract_PackBitsEncodeChunk_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_PackBitsEncodeChunk_def_void@
identifier F = PackBitsEncodeChunk;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_PackBitsEncodeChunk_def_void@
F << extract_PackBitsEncodeChunk_def_void.F;
P << extract_PackBitsEncodeChunk_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_PackBitsEncodeChunk_decl@
type T;
identifier F = PackBitsEncodeChunk;
parameter list P;
@@
T F(P);

@script:python depends on extract_PackBitsEncodeChunk_decl@
F << extract_PackBitsEncodeChunk_decl.F;
T << extract_PackBitsEncodeChunk_decl.T;
P << extract_PackBitsEncodeChunk_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_PackBitsEncodeChunk_decl_void@
identifier F = PackBitsEncodeChunk;
parameter list P;
@@
void F(P);

@script:python depends on extract_PackBitsEncodeChunk_decl_void@
F << extract_PackBitsEncodeChunk_decl_void.F;
P << extract_PackBitsEncodeChunk_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: PackBitsPostEncode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_PackBitsPostEncode_def@
type T;
identifier F = PackBitsPostEncode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_PackBitsPostEncode_def@
F << remove_static_PackBitsPostEncode_def.F;
T << remove_static_PackBitsPostEncode_def.T;
P << remove_static_PackBitsPostEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_PackBitsPostEncode_def_void@
identifier F = PackBitsPostEncode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_PackBitsPostEncode_def_void@
F << remove_static_PackBitsPostEncode_def_void.F;
P << remove_static_PackBitsPostEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_PackBitsPostEncode_decl@
type T;
identifier F = PackBitsPostEncode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_PackBitsPostEncode_decl@
F << remove_static_PackBitsPostEncode_decl.F;
T << remove_static_PackBitsPostEncode_decl.T;
P << remove_static_PackBitsPostEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_PackBitsPostEncode_decl_void@
identifier F = PackBitsPostEncode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_PackBitsPostEncode_decl_void@
F << remove_static_PackBitsPostEncode_decl_void.F;
P << remove_static_PackBitsPostEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_PackBitsPostEncode_def@
type T;
identifier F = PackBitsPostEncode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_PackBitsPostEncode_def@
F << extract_PackBitsPostEncode_def.F;
T << extract_PackBitsPostEncode_def.T;
P << extract_PackBitsPostEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_PackBitsPostEncode_def_void@
identifier F = PackBitsPostEncode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_PackBitsPostEncode_def_void@
F << extract_PackBitsPostEncode_def_void.F;
P << extract_PackBitsPostEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_PackBitsPostEncode_decl@
type T;
identifier F = PackBitsPostEncode;
parameter list P;
@@
T F(P);

@script:python depends on extract_PackBitsPostEncode_decl@
F << extract_PackBitsPostEncode_decl.F;
T << extract_PackBitsPostEncode_decl.T;
P << extract_PackBitsPostEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_PackBitsPostEncode_decl_void@
identifier F = PackBitsPostEncode;
parameter list P;
@@
void F(P);

@script:python depends on extract_PackBitsPostEncode_decl_void@
F << extract_PackBitsPostEncode_decl_void.F;
P << extract_PackBitsPostEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: PackBitsPreEncode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_PackBitsPreEncode_def@
type T;
identifier F = PackBitsPreEncode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_PackBitsPreEncode_def@
F << remove_static_PackBitsPreEncode_def.F;
T << remove_static_PackBitsPreEncode_def.T;
P << remove_static_PackBitsPreEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_PackBitsPreEncode_def_void@
identifier F = PackBitsPreEncode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_PackBitsPreEncode_def_void@
F << remove_static_PackBitsPreEncode_def_void.F;
P << remove_static_PackBitsPreEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_PackBitsPreEncode_decl@
type T;
identifier F = PackBitsPreEncode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_PackBitsPreEncode_decl@
F << remove_static_PackBitsPreEncode_decl.F;
T << remove_static_PackBitsPreEncode_decl.T;
P << remove_static_PackBitsPreEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_PackBitsPreEncode_decl_void@
identifier F = PackBitsPreEncode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_PackBitsPreEncode_decl_void@
F << remove_static_PackBitsPreEncode_decl_void.F;
P << remove_static_PackBitsPreEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_PackBitsPreEncode_def@
type T;
identifier F = PackBitsPreEncode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_PackBitsPreEncode_def@
F << extract_PackBitsPreEncode_def.F;
T << extract_PackBitsPreEncode_def.T;
P << extract_PackBitsPreEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_PackBitsPreEncode_def_void@
identifier F = PackBitsPreEncode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_PackBitsPreEncode_def_void@
F << extract_PackBitsPreEncode_def_void.F;
P << extract_PackBitsPreEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_PackBitsPreEncode_decl@
type T;
identifier F = PackBitsPreEncode;
parameter list P;
@@
T F(P);

@script:python depends on extract_PackBitsPreEncode_decl@
F << extract_PackBitsPreEncode_decl.F;
T << extract_PackBitsPreEncode_decl.T;
P << extract_PackBitsPreEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_PackBitsPreEncode_decl_void@
identifier F = PackBitsPreEncode;
parameter list P;
@@
void F(P);

@script:python depends on extract_PackBitsPreEncode_decl_void@
F << extract_PackBitsPreEncode_decl_void.F;
P << extract_PackBitsPreEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: PixarLogCleanup
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_PixarLogCleanup_def@
type T;
identifier F = PixarLogCleanup;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_PixarLogCleanup_def@
F << remove_static_PixarLogCleanup_def.F;
T << remove_static_PixarLogCleanup_def.T;
P << remove_static_PixarLogCleanup_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_PixarLogCleanup_def_void@
identifier F = PixarLogCleanup;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_PixarLogCleanup_def_void@
F << remove_static_PixarLogCleanup_def_void.F;
P << remove_static_PixarLogCleanup_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_PixarLogCleanup_decl@
type T;
identifier F = PixarLogCleanup;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_PixarLogCleanup_decl@
F << remove_static_PixarLogCleanup_decl.F;
T << remove_static_PixarLogCleanup_decl.T;
P << remove_static_PixarLogCleanup_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_PixarLogCleanup_decl_void@
identifier F = PixarLogCleanup;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_PixarLogCleanup_decl_void@
F << remove_static_PixarLogCleanup_decl_void.F;
P << remove_static_PixarLogCleanup_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_PixarLogCleanup_def@
type T;
identifier F = PixarLogCleanup;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_PixarLogCleanup_def@
F << extract_PixarLogCleanup_def.F;
T << extract_PixarLogCleanup_def.T;
P << extract_PixarLogCleanup_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_PixarLogCleanup_def_void@
identifier F = PixarLogCleanup;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_PixarLogCleanup_def_void@
F << extract_PixarLogCleanup_def_void.F;
P << extract_PixarLogCleanup_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_PixarLogCleanup_decl@
type T;
identifier F = PixarLogCleanup;
parameter list P;
@@
T F(P);

@script:python depends on extract_PixarLogCleanup_decl@
F << extract_PixarLogCleanup_decl.F;
T << extract_PixarLogCleanup_decl.T;
P << extract_PixarLogCleanup_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_PixarLogCleanup_decl_void@
identifier F = PixarLogCleanup;
parameter list P;
@@
void F(P);

@script:python depends on extract_PixarLogCleanup_decl_void@
F << extract_PixarLogCleanup_decl_void.F;
P << extract_PixarLogCleanup_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: PixarLogClose
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_PixarLogClose_def@
type T;
identifier F = PixarLogClose;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_PixarLogClose_def@
F << remove_static_PixarLogClose_def.F;
T << remove_static_PixarLogClose_def.T;
P << remove_static_PixarLogClose_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_PixarLogClose_def_void@
identifier F = PixarLogClose;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_PixarLogClose_def_void@
F << remove_static_PixarLogClose_def_void.F;
P << remove_static_PixarLogClose_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_PixarLogClose_decl@
type T;
identifier F = PixarLogClose;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_PixarLogClose_decl@
F << remove_static_PixarLogClose_decl.F;
T << remove_static_PixarLogClose_decl.T;
P << remove_static_PixarLogClose_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_PixarLogClose_decl_void@
identifier F = PixarLogClose;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_PixarLogClose_decl_void@
F << remove_static_PixarLogClose_decl_void.F;
P << remove_static_PixarLogClose_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_PixarLogClose_def@
type T;
identifier F = PixarLogClose;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_PixarLogClose_def@
F << extract_PixarLogClose_def.F;
T << extract_PixarLogClose_def.T;
P << extract_PixarLogClose_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_PixarLogClose_def_void@
identifier F = PixarLogClose;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_PixarLogClose_def_void@
F << extract_PixarLogClose_def_void.F;
P << extract_PixarLogClose_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_PixarLogClose_decl@
type T;
identifier F = PixarLogClose;
parameter list P;
@@
T F(P);

@script:python depends on extract_PixarLogClose_decl@
F << extract_PixarLogClose_decl.F;
T << extract_PixarLogClose_decl.T;
P << extract_PixarLogClose_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_PixarLogClose_decl_void@
identifier F = PixarLogClose;
parameter list P;
@@
void F(P);

@script:python depends on extract_PixarLogClose_decl_void@
F << extract_PixarLogClose_decl_void.F;
P << extract_PixarLogClose_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: PixarLogDecode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_PixarLogDecode_def@
type T;
identifier F = PixarLogDecode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_PixarLogDecode_def@
F << remove_static_PixarLogDecode_def.F;
T << remove_static_PixarLogDecode_def.T;
P << remove_static_PixarLogDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_PixarLogDecode_def_void@
identifier F = PixarLogDecode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_PixarLogDecode_def_void@
F << remove_static_PixarLogDecode_def_void.F;
P << remove_static_PixarLogDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_PixarLogDecode_decl@
type T;
identifier F = PixarLogDecode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_PixarLogDecode_decl@
F << remove_static_PixarLogDecode_decl.F;
T << remove_static_PixarLogDecode_decl.T;
P << remove_static_PixarLogDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_PixarLogDecode_decl_void@
identifier F = PixarLogDecode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_PixarLogDecode_decl_void@
F << remove_static_PixarLogDecode_decl_void.F;
P << remove_static_PixarLogDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_PixarLogDecode_def@
type T;
identifier F = PixarLogDecode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_PixarLogDecode_def@
F << extract_PixarLogDecode_def.F;
T << extract_PixarLogDecode_def.T;
P << extract_PixarLogDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_PixarLogDecode_def_void@
identifier F = PixarLogDecode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_PixarLogDecode_def_void@
F << extract_PixarLogDecode_def_void.F;
P << extract_PixarLogDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_PixarLogDecode_decl@
type T;
identifier F = PixarLogDecode;
parameter list P;
@@
T F(P);

@script:python depends on extract_PixarLogDecode_decl@
F << extract_PixarLogDecode_decl.F;
T << extract_PixarLogDecode_decl.T;
P << extract_PixarLogDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_PixarLogDecode_decl_void@
identifier F = PixarLogDecode;
parameter list P;
@@
void F(P);

@script:python depends on extract_PixarLogDecode_decl_void@
F << extract_PixarLogDecode_decl_void.F;
P << extract_PixarLogDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: PixarLogEncode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_PixarLogEncode_def@
type T;
identifier F = PixarLogEncode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_PixarLogEncode_def@
F << remove_static_PixarLogEncode_def.F;
T << remove_static_PixarLogEncode_def.T;
P << remove_static_PixarLogEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_PixarLogEncode_def_void@
identifier F = PixarLogEncode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_PixarLogEncode_def_void@
F << remove_static_PixarLogEncode_def_void.F;
P << remove_static_PixarLogEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_PixarLogEncode_decl@
type T;
identifier F = PixarLogEncode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_PixarLogEncode_decl@
F << remove_static_PixarLogEncode_decl.F;
T << remove_static_PixarLogEncode_decl.T;
P << remove_static_PixarLogEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_PixarLogEncode_decl_void@
identifier F = PixarLogEncode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_PixarLogEncode_decl_void@
F << remove_static_PixarLogEncode_decl_void.F;
P << remove_static_PixarLogEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_PixarLogEncode_def@
type T;
identifier F = PixarLogEncode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_PixarLogEncode_def@
F << extract_PixarLogEncode_def.F;
T << extract_PixarLogEncode_def.T;
P << extract_PixarLogEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_PixarLogEncode_def_void@
identifier F = PixarLogEncode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_PixarLogEncode_def_void@
F << extract_PixarLogEncode_def_void.F;
P << extract_PixarLogEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_PixarLogEncode_decl@
type T;
identifier F = PixarLogEncode;
parameter list P;
@@
T F(P);

@script:python depends on extract_PixarLogEncode_decl@
F << extract_PixarLogEncode_decl.F;
T << extract_PixarLogEncode_decl.T;
P << extract_PixarLogEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_PixarLogEncode_decl_void@
identifier F = PixarLogEncode;
parameter list P;
@@
void F(P);

@script:python depends on extract_PixarLogEncode_decl_void@
F << extract_PixarLogEncode_decl_void.F;
P << extract_PixarLogEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: PixarLogFixupTags
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_PixarLogFixupTags_def@
type T;
identifier F = PixarLogFixupTags;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_PixarLogFixupTags_def@
F << remove_static_PixarLogFixupTags_def.F;
T << remove_static_PixarLogFixupTags_def.T;
P << remove_static_PixarLogFixupTags_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_PixarLogFixupTags_def_void@
identifier F = PixarLogFixupTags;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_PixarLogFixupTags_def_void@
F << remove_static_PixarLogFixupTags_def_void.F;
P << remove_static_PixarLogFixupTags_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_PixarLogFixupTags_decl@
type T;
identifier F = PixarLogFixupTags;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_PixarLogFixupTags_decl@
F << remove_static_PixarLogFixupTags_decl.F;
T << remove_static_PixarLogFixupTags_decl.T;
P << remove_static_PixarLogFixupTags_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_PixarLogFixupTags_decl_void@
identifier F = PixarLogFixupTags;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_PixarLogFixupTags_decl_void@
F << remove_static_PixarLogFixupTags_decl_void.F;
P << remove_static_PixarLogFixupTags_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_PixarLogFixupTags_def@
type T;
identifier F = PixarLogFixupTags;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_PixarLogFixupTags_def@
F << extract_PixarLogFixupTags_def.F;
T << extract_PixarLogFixupTags_def.T;
P << extract_PixarLogFixupTags_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_PixarLogFixupTags_def_void@
identifier F = PixarLogFixupTags;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_PixarLogFixupTags_def_void@
F << extract_PixarLogFixupTags_def_void.F;
P << extract_PixarLogFixupTags_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_PixarLogFixupTags_decl@
type T;
identifier F = PixarLogFixupTags;
parameter list P;
@@
T F(P);

@script:python depends on extract_PixarLogFixupTags_decl@
F << extract_PixarLogFixupTags_decl.F;
T << extract_PixarLogFixupTags_decl.T;
P << extract_PixarLogFixupTags_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_PixarLogFixupTags_decl_void@
identifier F = PixarLogFixupTags;
parameter list P;
@@
void F(P);

@script:python depends on extract_PixarLogFixupTags_decl_void@
F << extract_PixarLogFixupTags_decl_void.F;
P << extract_PixarLogFixupTags_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: PixarLogPostEncode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_PixarLogPostEncode_def@
type T;
identifier F = PixarLogPostEncode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_PixarLogPostEncode_def@
F << remove_static_PixarLogPostEncode_def.F;
T << remove_static_PixarLogPostEncode_def.T;
P << remove_static_PixarLogPostEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_PixarLogPostEncode_def_void@
identifier F = PixarLogPostEncode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_PixarLogPostEncode_def_void@
F << remove_static_PixarLogPostEncode_def_void.F;
P << remove_static_PixarLogPostEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_PixarLogPostEncode_decl@
type T;
identifier F = PixarLogPostEncode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_PixarLogPostEncode_decl@
F << remove_static_PixarLogPostEncode_decl.F;
T << remove_static_PixarLogPostEncode_decl.T;
P << remove_static_PixarLogPostEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_PixarLogPostEncode_decl_void@
identifier F = PixarLogPostEncode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_PixarLogPostEncode_decl_void@
F << remove_static_PixarLogPostEncode_decl_void.F;
P << remove_static_PixarLogPostEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_PixarLogPostEncode_def@
type T;
identifier F = PixarLogPostEncode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_PixarLogPostEncode_def@
F << extract_PixarLogPostEncode_def.F;
T << extract_PixarLogPostEncode_def.T;
P << extract_PixarLogPostEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_PixarLogPostEncode_def_void@
identifier F = PixarLogPostEncode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_PixarLogPostEncode_def_void@
F << extract_PixarLogPostEncode_def_void.F;
P << extract_PixarLogPostEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_PixarLogPostEncode_decl@
type T;
identifier F = PixarLogPostEncode;
parameter list P;
@@
T F(P);

@script:python depends on extract_PixarLogPostEncode_decl@
F << extract_PixarLogPostEncode_decl.F;
T << extract_PixarLogPostEncode_decl.T;
P << extract_PixarLogPostEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_PixarLogPostEncode_decl_void@
identifier F = PixarLogPostEncode;
parameter list P;
@@
void F(P);

@script:python depends on extract_PixarLogPostEncode_decl_void@
F << extract_PixarLogPostEncode_decl_void.F;
P << extract_PixarLogPostEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: PixarLogPreDecode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_PixarLogPreDecode_def@
type T;
identifier F = PixarLogPreDecode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_PixarLogPreDecode_def@
F << remove_static_PixarLogPreDecode_def.F;
T << remove_static_PixarLogPreDecode_def.T;
P << remove_static_PixarLogPreDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_PixarLogPreDecode_def_void@
identifier F = PixarLogPreDecode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_PixarLogPreDecode_def_void@
F << remove_static_PixarLogPreDecode_def_void.F;
P << remove_static_PixarLogPreDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_PixarLogPreDecode_decl@
type T;
identifier F = PixarLogPreDecode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_PixarLogPreDecode_decl@
F << remove_static_PixarLogPreDecode_decl.F;
T << remove_static_PixarLogPreDecode_decl.T;
P << remove_static_PixarLogPreDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_PixarLogPreDecode_decl_void@
identifier F = PixarLogPreDecode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_PixarLogPreDecode_decl_void@
F << remove_static_PixarLogPreDecode_decl_void.F;
P << remove_static_PixarLogPreDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_PixarLogPreDecode_def@
type T;
identifier F = PixarLogPreDecode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_PixarLogPreDecode_def@
F << extract_PixarLogPreDecode_def.F;
T << extract_PixarLogPreDecode_def.T;
P << extract_PixarLogPreDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_PixarLogPreDecode_def_void@
identifier F = PixarLogPreDecode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_PixarLogPreDecode_def_void@
F << extract_PixarLogPreDecode_def_void.F;
P << extract_PixarLogPreDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_PixarLogPreDecode_decl@
type T;
identifier F = PixarLogPreDecode;
parameter list P;
@@
T F(P);

@script:python depends on extract_PixarLogPreDecode_decl@
F << extract_PixarLogPreDecode_decl.F;
T << extract_PixarLogPreDecode_decl.T;
P << extract_PixarLogPreDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_PixarLogPreDecode_decl_void@
identifier F = PixarLogPreDecode;
parameter list P;
@@
void F(P);

@script:python depends on extract_PixarLogPreDecode_decl_void@
F << extract_PixarLogPreDecode_decl_void.F;
P << extract_PixarLogPreDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: PixarLogPreEncode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_PixarLogPreEncode_def@
type T;
identifier F = PixarLogPreEncode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_PixarLogPreEncode_def@
F << remove_static_PixarLogPreEncode_def.F;
T << remove_static_PixarLogPreEncode_def.T;
P << remove_static_PixarLogPreEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_PixarLogPreEncode_def_void@
identifier F = PixarLogPreEncode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_PixarLogPreEncode_def_void@
F << remove_static_PixarLogPreEncode_def_void.F;
P << remove_static_PixarLogPreEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_PixarLogPreEncode_decl@
type T;
identifier F = PixarLogPreEncode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_PixarLogPreEncode_decl@
F << remove_static_PixarLogPreEncode_decl.F;
T << remove_static_PixarLogPreEncode_decl.T;
P << remove_static_PixarLogPreEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_PixarLogPreEncode_decl_void@
identifier F = PixarLogPreEncode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_PixarLogPreEncode_decl_void@
F << remove_static_PixarLogPreEncode_decl_void.F;
P << remove_static_PixarLogPreEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_PixarLogPreEncode_def@
type T;
identifier F = PixarLogPreEncode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_PixarLogPreEncode_def@
F << extract_PixarLogPreEncode_def.F;
T << extract_PixarLogPreEncode_def.T;
P << extract_PixarLogPreEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_PixarLogPreEncode_def_void@
identifier F = PixarLogPreEncode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_PixarLogPreEncode_def_void@
F << extract_PixarLogPreEncode_def_void.F;
P << extract_PixarLogPreEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_PixarLogPreEncode_decl@
type T;
identifier F = PixarLogPreEncode;
parameter list P;
@@
T F(P);

@script:python depends on extract_PixarLogPreEncode_decl@
F << extract_PixarLogPreEncode_decl.F;
T << extract_PixarLogPreEncode_decl.T;
P << extract_PixarLogPreEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_PixarLogPreEncode_decl_void@
identifier F = PixarLogPreEncode;
parameter list P;
@@
void F(P);

@script:python depends on extract_PixarLogPreEncode_decl_void@
F << extract_PixarLogPreEncode_decl_void.F;
P << extract_PixarLogPreEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: PixarLogSetupDecode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_PixarLogSetupDecode_def@
type T;
identifier F = PixarLogSetupDecode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_PixarLogSetupDecode_def@
F << remove_static_PixarLogSetupDecode_def.F;
T << remove_static_PixarLogSetupDecode_def.T;
P << remove_static_PixarLogSetupDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_PixarLogSetupDecode_def_void@
identifier F = PixarLogSetupDecode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_PixarLogSetupDecode_def_void@
F << remove_static_PixarLogSetupDecode_def_void.F;
P << remove_static_PixarLogSetupDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_PixarLogSetupDecode_decl@
type T;
identifier F = PixarLogSetupDecode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_PixarLogSetupDecode_decl@
F << remove_static_PixarLogSetupDecode_decl.F;
T << remove_static_PixarLogSetupDecode_decl.T;
P << remove_static_PixarLogSetupDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_PixarLogSetupDecode_decl_void@
identifier F = PixarLogSetupDecode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_PixarLogSetupDecode_decl_void@
F << remove_static_PixarLogSetupDecode_decl_void.F;
P << remove_static_PixarLogSetupDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_PixarLogSetupDecode_def@
type T;
identifier F = PixarLogSetupDecode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_PixarLogSetupDecode_def@
F << extract_PixarLogSetupDecode_def.F;
T << extract_PixarLogSetupDecode_def.T;
P << extract_PixarLogSetupDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_PixarLogSetupDecode_def_void@
identifier F = PixarLogSetupDecode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_PixarLogSetupDecode_def_void@
F << extract_PixarLogSetupDecode_def_void.F;
P << extract_PixarLogSetupDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_PixarLogSetupDecode_decl@
type T;
identifier F = PixarLogSetupDecode;
parameter list P;
@@
T F(P);

@script:python depends on extract_PixarLogSetupDecode_decl@
F << extract_PixarLogSetupDecode_decl.F;
T << extract_PixarLogSetupDecode_decl.T;
P << extract_PixarLogSetupDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_PixarLogSetupDecode_decl_void@
identifier F = PixarLogSetupDecode;
parameter list P;
@@
void F(P);

@script:python depends on extract_PixarLogSetupDecode_decl_void@
F << extract_PixarLogSetupDecode_decl_void.F;
P << extract_PixarLogSetupDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: PixarLogSetupEncode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_PixarLogSetupEncode_def@
type T;
identifier F = PixarLogSetupEncode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_PixarLogSetupEncode_def@
F << remove_static_PixarLogSetupEncode_def.F;
T << remove_static_PixarLogSetupEncode_def.T;
P << remove_static_PixarLogSetupEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_PixarLogSetupEncode_def_void@
identifier F = PixarLogSetupEncode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_PixarLogSetupEncode_def_void@
F << remove_static_PixarLogSetupEncode_def_void.F;
P << remove_static_PixarLogSetupEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_PixarLogSetupEncode_decl@
type T;
identifier F = PixarLogSetupEncode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_PixarLogSetupEncode_decl@
F << remove_static_PixarLogSetupEncode_decl.F;
T << remove_static_PixarLogSetupEncode_decl.T;
P << remove_static_PixarLogSetupEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_PixarLogSetupEncode_decl_void@
identifier F = PixarLogSetupEncode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_PixarLogSetupEncode_decl_void@
F << remove_static_PixarLogSetupEncode_decl_void.F;
P << remove_static_PixarLogSetupEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_PixarLogSetupEncode_def@
type T;
identifier F = PixarLogSetupEncode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_PixarLogSetupEncode_def@
F << extract_PixarLogSetupEncode_def.F;
T << extract_PixarLogSetupEncode_def.T;
P << extract_PixarLogSetupEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_PixarLogSetupEncode_def_void@
identifier F = PixarLogSetupEncode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_PixarLogSetupEncode_def_void@
F << extract_PixarLogSetupEncode_def_void.F;
P << extract_PixarLogSetupEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_PixarLogSetupEncode_decl@
type T;
identifier F = PixarLogSetupEncode;
parameter list P;
@@
T F(P);

@script:python depends on extract_PixarLogSetupEncode_decl@
F << extract_PixarLogSetupEncode_decl.F;
T << extract_PixarLogSetupEncode_decl.T;
P << extract_PixarLogSetupEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_PixarLogSetupEncode_decl_void@
identifier F = PixarLogSetupEncode;
parameter list P;
@@
void F(P);

@script:python depends on extract_PixarLogSetupEncode_decl_void@
F << extract_PixarLogSetupEncode_decl_void.F;
P << extract_PixarLogSetupEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: PixarLogVGetField
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_PixarLogVGetField_def@
type T;
identifier F = PixarLogVGetField;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_PixarLogVGetField_def@
F << remove_static_PixarLogVGetField_def.F;
T << remove_static_PixarLogVGetField_def.T;
P << remove_static_PixarLogVGetField_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_PixarLogVGetField_def_void@
identifier F = PixarLogVGetField;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_PixarLogVGetField_def_void@
F << remove_static_PixarLogVGetField_def_void.F;
P << remove_static_PixarLogVGetField_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_PixarLogVGetField_decl@
type T;
identifier F = PixarLogVGetField;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_PixarLogVGetField_decl@
F << remove_static_PixarLogVGetField_decl.F;
T << remove_static_PixarLogVGetField_decl.T;
P << remove_static_PixarLogVGetField_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_PixarLogVGetField_decl_void@
identifier F = PixarLogVGetField;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_PixarLogVGetField_decl_void@
F << remove_static_PixarLogVGetField_decl_void.F;
P << remove_static_PixarLogVGetField_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_PixarLogVGetField_def@
type T;
identifier F = PixarLogVGetField;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_PixarLogVGetField_def@
F << extract_PixarLogVGetField_def.F;
T << extract_PixarLogVGetField_def.T;
P << extract_PixarLogVGetField_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_PixarLogVGetField_def_void@
identifier F = PixarLogVGetField;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_PixarLogVGetField_def_void@
F << extract_PixarLogVGetField_def_void.F;
P << extract_PixarLogVGetField_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_PixarLogVGetField_decl@
type T;
identifier F = PixarLogVGetField;
parameter list P;
@@
T F(P);

@script:python depends on extract_PixarLogVGetField_decl@
F << extract_PixarLogVGetField_decl.F;
T << extract_PixarLogVGetField_decl.T;
P << extract_PixarLogVGetField_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_PixarLogVGetField_decl_void@
identifier F = PixarLogVGetField;
parameter list P;
@@
void F(P);

@script:python depends on extract_PixarLogVGetField_decl_void@
F << extract_PixarLogVGetField_decl_void.F;
P << extract_PixarLogVGetField_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: PixarLogVSetField
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_PixarLogVSetField_def@
type T;
identifier F = PixarLogVSetField;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_PixarLogVSetField_def@
F << remove_static_PixarLogVSetField_def.F;
T << remove_static_PixarLogVSetField_def.T;
P << remove_static_PixarLogVSetField_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_PixarLogVSetField_def_void@
identifier F = PixarLogVSetField;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_PixarLogVSetField_def_void@
F << remove_static_PixarLogVSetField_def_void.F;
P << remove_static_PixarLogVSetField_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_PixarLogVSetField_decl@
type T;
identifier F = PixarLogVSetField;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_PixarLogVSetField_decl@
F << remove_static_PixarLogVSetField_decl.F;
T << remove_static_PixarLogVSetField_decl.T;
P << remove_static_PixarLogVSetField_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_PixarLogVSetField_decl_void@
identifier F = PixarLogVSetField;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_PixarLogVSetField_decl_void@
F << remove_static_PixarLogVSetField_decl_void.F;
P << remove_static_PixarLogVSetField_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_PixarLogVSetField_def@
type T;
identifier F = PixarLogVSetField;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_PixarLogVSetField_def@
F << extract_PixarLogVSetField_def.F;
T << extract_PixarLogVSetField_def.T;
P << extract_PixarLogVSetField_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_PixarLogVSetField_def_void@
identifier F = PixarLogVSetField;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_PixarLogVSetField_def_void@
F << extract_PixarLogVSetField_def_void.F;
P << extract_PixarLogVSetField_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_PixarLogVSetField_decl@
type T;
identifier F = PixarLogVSetField;
parameter list P;
@@
T F(P);

@script:python depends on extract_PixarLogVSetField_decl@
F << extract_PixarLogVSetField_decl.F;
T << extract_PixarLogVSetField_decl.T;
P << extract_PixarLogVSetField_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_PixarLogVSetField_decl_void@
identifier F = PixarLogVSetField;
parameter list P;
@@
void F(P);

@script:python depends on extract_PixarLogVSetField_decl_void@
F << extract_PixarLogVSetField_decl_void.F;
P << extract_PixarLogVSetField_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: PredictorDecodeRow
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_PredictorDecodeRow_def@
type T;
identifier F = PredictorDecodeRow;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_PredictorDecodeRow_def@
F << remove_static_PredictorDecodeRow_def.F;
T << remove_static_PredictorDecodeRow_def.T;
P << remove_static_PredictorDecodeRow_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_PredictorDecodeRow_def_void@
identifier F = PredictorDecodeRow;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_PredictorDecodeRow_def_void@
F << remove_static_PredictorDecodeRow_def_void.F;
P << remove_static_PredictorDecodeRow_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_PredictorDecodeRow_decl@
type T;
identifier F = PredictorDecodeRow;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_PredictorDecodeRow_decl@
F << remove_static_PredictorDecodeRow_decl.F;
T << remove_static_PredictorDecodeRow_decl.T;
P << remove_static_PredictorDecodeRow_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_PredictorDecodeRow_decl_void@
identifier F = PredictorDecodeRow;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_PredictorDecodeRow_decl_void@
F << remove_static_PredictorDecodeRow_decl_void.F;
P << remove_static_PredictorDecodeRow_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_PredictorDecodeRow_def@
type T;
identifier F = PredictorDecodeRow;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_PredictorDecodeRow_def@
F << extract_PredictorDecodeRow_def.F;
T << extract_PredictorDecodeRow_def.T;
P << extract_PredictorDecodeRow_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_PredictorDecodeRow_def_void@
identifier F = PredictorDecodeRow;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_PredictorDecodeRow_def_void@
F << extract_PredictorDecodeRow_def_void.F;
P << extract_PredictorDecodeRow_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_PredictorDecodeRow_decl@
type T;
identifier F = PredictorDecodeRow;
parameter list P;
@@
T F(P);

@script:python depends on extract_PredictorDecodeRow_decl@
F << extract_PredictorDecodeRow_decl.F;
T << extract_PredictorDecodeRow_decl.T;
P << extract_PredictorDecodeRow_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_PredictorDecodeRow_decl_void@
identifier F = PredictorDecodeRow;
parameter list P;
@@
void F(P);

@script:python depends on extract_PredictorDecodeRow_decl_void@
F << extract_PredictorDecodeRow_decl_void.F;
P << extract_PredictorDecodeRow_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: PredictorDecodeTile
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_PredictorDecodeTile_def@
type T;
identifier F = PredictorDecodeTile;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_PredictorDecodeTile_def@
F << remove_static_PredictorDecodeTile_def.F;
T << remove_static_PredictorDecodeTile_def.T;
P << remove_static_PredictorDecodeTile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_PredictorDecodeTile_def_void@
identifier F = PredictorDecodeTile;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_PredictorDecodeTile_def_void@
F << remove_static_PredictorDecodeTile_def_void.F;
P << remove_static_PredictorDecodeTile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_PredictorDecodeTile_decl@
type T;
identifier F = PredictorDecodeTile;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_PredictorDecodeTile_decl@
F << remove_static_PredictorDecodeTile_decl.F;
T << remove_static_PredictorDecodeTile_decl.T;
P << remove_static_PredictorDecodeTile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_PredictorDecodeTile_decl_void@
identifier F = PredictorDecodeTile;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_PredictorDecodeTile_decl_void@
F << remove_static_PredictorDecodeTile_decl_void.F;
P << remove_static_PredictorDecodeTile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_PredictorDecodeTile_def@
type T;
identifier F = PredictorDecodeTile;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_PredictorDecodeTile_def@
F << extract_PredictorDecodeTile_def.F;
T << extract_PredictorDecodeTile_def.T;
P << extract_PredictorDecodeTile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_PredictorDecodeTile_def_void@
identifier F = PredictorDecodeTile;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_PredictorDecodeTile_def_void@
F << extract_PredictorDecodeTile_def_void.F;
P << extract_PredictorDecodeTile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_PredictorDecodeTile_decl@
type T;
identifier F = PredictorDecodeTile;
parameter list P;
@@
T F(P);

@script:python depends on extract_PredictorDecodeTile_decl@
F << extract_PredictorDecodeTile_decl.F;
T << extract_PredictorDecodeTile_decl.T;
P << extract_PredictorDecodeTile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_PredictorDecodeTile_decl_void@
identifier F = PredictorDecodeTile;
parameter list P;
@@
void F(P);

@script:python depends on extract_PredictorDecodeTile_decl_void@
F << extract_PredictorDecodeTile_decl_void.F;
P << extract_PredictorDecodeTile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: PredictorEncodeRow
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_PredictorEncodeRow_def@
type T;
identifier F = PredictorEncodeRow;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_PredictorEncodeRow_def@
F << remove_static_PredictorEncodeRow_def.F;
T << remove_static_PredictorEncodeRow_def.T;
P << remove_static_PredictorEncodeRow_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_PredictorEncodeRow_def_void@
identifier F = PredictorEncodeRow;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_PredictorEncodeRow_def_void@
F << remove_static_PredictorEncodeRow_def_void.F;
P << remove_static_PredictorEncodeRow_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_PredictorEncodeRow_decl@
type T;
identifier F = PredictorEncodeRow;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_PredictorEncodeRow_decl@
F << remove_static_PredictorEncodeRow_decl.F;
T << remove_static_PredictorEncodeRow_decl.T;
P << remove_static_PredictorEncodeRow_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_PredictorEncodeRow_decl_void@
identifier F = PredictorEncodeRow;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_PredictorEncodeRow_decl_void@
F << remove_static_PredictorEncodeRow_decl_void.F;
P << remove_static_PredictorEncodeRow_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_PredictorEncodeRow_def@
type T;
identifier F = PredictorEncodeRow;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_PredictorEncodeRow_def@
F << extract_PredictorEncodeRow_def.F;
T << extract_PredictorEncodeRow_def.T;
P << extract_PredictorEncodeRow_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_PredictorEncodeRow_def_void@
identifier F = PredictorEncodeRow;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_PredictorEncodeRow_def_void@
F << extract_PredictorEncodeRow_def_void.F;
P << extract_PredictorEncodeRow_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_PredictorEncodeRow_decl@
type T;
identifier F = PredictorEncodeRow;
parameter list P;
@@
T F(P);

@script:python depends on extract_PredictorEncodeRow_decl@
F << extract_PredictorEncodeRow_decl.F;
T << extract_PredictorEncodeRow_decl.T;
P << extract_PredictorEncodeRow_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_PredictorEncodeRow_decl_void@
identifier F = PredictorEncodeRow;
parameter list P;
@@
void F(P);

@script:python depends on extract_PredictorEncodeRow_decl_void@
F << extract_PredictorEncodeRow_decl_void.F;
P << extract_PredictorEncodeRow_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: PredictorEncodeTile
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_PredictorEncodeTile_def@
type T;
identifier F = PredictorEncodeTile;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_PredictorEncodeTile_def@
F << remove_static_PredictorEncodeTile_def.F;
T << remove_static_PredictorEncodeTile_def.T;
P << remove_static_PredictorEncodeTile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_PredictorEncodeTile_def_void@
identifier F = PredictorEncodeTile;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_PredictorEncodeTile_def_void@
F << remove_static_PredictorEncodeTile_def_void.F;
P << remove_static_PredictorEncodeTile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_PredictorEncodeTile_decl@
type T;
identifier F = PredictorEncodeTile;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_PredictorEncodeTile_decl@
F << remove_static_PredictorEncodeTile_decl.F;
T << remove_static_PredictorEncodeTile_decl.T;
P << remove_static_PredictorEncodeTile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_PredictorEncodeTile_decl_void@
identifier F = PredictorEncodeTile;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_PredictorEncodeTile_decl_void@
F << remove_static_PredictorEncodeTile_decl_void.F;
P << remove_static_PredictorEncodeTile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_PredictorEncodeTile_def@
type T;
identifier F = PredictorEncodeTile;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_PredictorEncodeTile_def@
F << extract_PredictorEncodeTile_def.F;
T << extract_PredictorEncodeTile_def.T;
P << extract_PredictorEncodeTile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_PredictorEncodeTile_def_void@
identifier F = PredictorEncodeTile;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_PredictorEncodeTile_def_void@
F << extract_PredictorEncodeTile_def_void.F;
P << extract_PredictorEncodeTile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_PredictorEncodeTile_decl@
type T;
identifier F = PredictorEncodeTile;
parameter list P;
@@
T F(P);

@script:python depends on extract_PredictorEncodeTile_decl@
F << extract_PredictorEncodeTile_decl.F;
T << extract_PredictorEncodeTile_decl.T;
P << extract_PredictorEncodeTile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_PredictorEncodeTile_decl_void@
identifier F = PredictorEncodeTile;
parameter list P;
@@
void F(P);

@script:python depends on extract_PredictorEncodeTile_decl_void@
F << extract_PredictorEncodeTile_decl_void.F;
P << extract_PredictorEncodeTile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: PredictorPrintDir
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_PredictorPrintDir_def@
type T;
identifier F = PredictorPrintDir;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_PredictorPrintDir_def@
F << remove_static_PredictorPrintDir_def.F;
T << remove_static_PredictorPrintDir_def.T;
P << remove_static_PredictorPrintDir_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_PredictorPrintDir_def_void@
identifier F = PredictorPrintDir;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_PredictorPrintDir_def_void@
F << remove_static_PredictorPrintDir_def_void.F;
P << remove_static_PredictorPrintDir_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_PredictorPrintDir_decl@
type T;
identifier F = PredictorPrintDir;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_PredictorPrintDir_decl@
F << remove_static_PredictorPrintDir_decl.F;
T << remove_static_PredictorPrintDir_decl.T;
P << remove_static_PredictorPrintDir_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_PredictorPrintDir_decl_void@
identifier F = PredictorPrintDir;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_PredictorPrintDir_decl_void@
F << remove_static_PredictorPrintDir_decl_void.F;
P << remove_static_PredictorPrintDir_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_PredictorPrintDir_def@
type T;
identifier F = PredictorPrintDir;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_PredictorPrintDir_def@
F << extract_PredictorPrintDir_def.F;
T << extract_PredictorPrintDir_def.T;
P << extract_PredictorPrintDir_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_PredictorPrintDir_def_void@
identifier F = PredictorPrintDir;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_PredictorPrintDir_def_void@
F << extract_PredictorPrintDir_def_void.F;
P << extract_PredictorPrintDir_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_PredictorPrintDir_decl@
type T;
identifier F = PredictorPrintDir;
parameter list P;
@@
T F(P);

@script:python depends on extract_PredictorPrintDir_decl@
F << extract_PredictorPrintDir_decl.F;
T << extract_PredictorPrintDir_decl.T;
P << extract_PredictorPrintDir_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_PredictorPrintDir_decl_void@
identifier F = PredictorPrintDir;
parameter list P;
@@
void F(P);

@script:python depends on extract_PredictorPrintDir_decl_void@
F << extract_PredictorPrintDir_decl_void.F;
P << extract_PredictorPrintDir_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: PredictorSetupDecode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_PredictorSetupDecode_def@
type T;
identifier F = PredictorSetupDecode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_PredictorSetupDecode_def@
F << remove_static_PredictorSetupDecode_def.F;
T << remove_static_PredictorSetupDecode_def.T;
P << remove_static_PredictorSetupDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_PredictorSetupDecode_def_void@
identifier F = PredictorSetupDecode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_PredictorSetupDecode_def_void@
F << remove_static_PredictorSetupDecode_def_void.F;
P << remove_static_PredictorSetupDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_PredictorSetupDecode_decl@
type T;
identifier F = PredictorSetupDecode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_PredictorSetupDecode_decl@
F << remove_static_PredictorSetupDecode_decl.F;
T << remove_static_PredictorSetupDecode_decl.T;
P << remove_static_PredictorSetupDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_PredictorSetupDecode_decl_void@
identifier F = PredictorSetupDecode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_PredictorSetupDecode_decl_void@
F << remove_static_PredictorSetupDecode_decl_void.F;
P << remove_static_PredictorSetupDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_PredictorSetupDecode_def@
type T;
identifier F = PredictorSetupDecode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_PredictorSetupDecode_def@
F << extract_PredictorSetupDecode_def.F;
T << extract_PredictorSetupDecode_def.T;
P << extract_PredictorSetupDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_PredictorSetupDecode_def_void@
identifier F = PredictorSetupDecode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_PredictorSetupDecode_def_void@
F << extract_PredictorSetupDecode_def_void.F;
P << extract_PredictorSetupDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_PredictorSetupDecode_decl@
type T;
identifier F = PredictorSetupDecode;
parameter list P;
@@
T F(P);

@script:python depends on extract_PredictorSetupDecode_decl@
F << extract_PredictorSetupDecode_decl.F;
T << extract_PredictorSetupDecode_decl.T;
P << extract_PredictorSetupDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_PredictorSetupDecode_decl_void@
identifier F = PredictorSetupDecode;
parameter list P;
@@
void F(P);

@script:python depends on extract_PredictorSetupDecode_decl_void@
F << extract_PredictorSetupDecode_decl_void.F;
P << extract_PredictorSetupDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: PredictorSetupEncode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_PredictorSetupEncode_def@
type T;
identifier F = PredictorSetupEncode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_PredictorSetupEncode_def@
F << remove_static_PredictorSetupEncode_def.F;
T << remove_static_PredictorSetupEncode_def.T;
P << remove_static_PredictorSetupEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_PredictorSetupEncode_def_void@
identifier F = PredictorSetupEncode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_PredictorSetupEncode_def_void@
F << remove_static_PredictorSetupEncode_def_void.F;
P << remove_static_PredictorSetupEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_PredictorSetupEncode_decl@
type T;
identifier F = PredictorSetupEncode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_PredictorSetupEncode_decl@
F << remove_static_PredictorSetupEncode_decl.F;
T << remove_static_PredictorSetupEncode_decl.T;
P << remove_static_PredictorSetupEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_PredictorSetupEncode_decl_void@
identifier F = PredictorSetupEncode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_PredictorSetupEncode_decl_void@
F << remove_static_PredictorSetupEncode_decl_void.F;
P << remove_static_PredictorSetupEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_PredictorSetupEncode_def@
type T;
identifier F = PredictorSetupEncode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_PredictorSetupEncode_def@
F << extract_PredictorSetupEncode_def.F;
T << extract_PredictorSetupEncode_def.T;
P << extract_PredictorSetupEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_PredictorSetupEncode_def_void@
identifier F = PredictorSetupEncode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_PredictorSetupEncode_def_void@
F << extract_PredictorSetupEncode_def_void.F;
P << extract_PredictorSetupEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_PredictorSetupEncode_decl@
type T;
identifier F = PredictorSetupEncode;
parameter list P;
@@
T F(P);

@script:python depends on extract_PredictorSetupEncode_decl@
F << extract_PredictorSetupEncode_decl.F;
T << extract_PredictorSetupEncode_decl.T;
P << extract_PredictorSetupEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_PredictorSetupEncode_decl_void@
identifier F = PredictorSetupEncode;
parameter list P;
@@
void F(P);

@script:python depends on extract_PredictorSetupEncode_decl_void@
F << extract_PredictorSetupEncode_decl_void.F;
P << extract_PredictorSetupEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: PredictorVGetField
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_PredictorVGetField_def@
type T;
identifier F = PredictorVGetField;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_PredictorVGetField_def@
F << remove_static_PredictorVGetField_def.F;
T << remove_static_PredictorVGetField_def.T;
P << remove_static_PredictorVGetField_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_PredictorVGetField_def_void@
identifier F = PredictorVGetField;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_PredictorVGetField_def_void@
F << remove_static_PredictorVGetField_def_void.F;
P << remove_static_PredictorVGetField_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_PredictorVGetField_decl@
type T;
identifier F = PredictorVGetField;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_PredictorVGetField_decl@
F << remove_static_PredictorVGetField_decl.F;
T << remove_static_PredictorVGetField_decl.T;
P << remove_static_PredictorVGetField_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_PredictorVGetField_decl_void@
identifier F = PredictorVGetField;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_PredictorVGetField_decl_void@
F << remove_static_PredictorVGetField_decl_void.F;
P << remove_static_PredictorVGetField_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_PredictorVGetField_def@
type T;
identifier F = PredictorVGetField;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_PredictorVGetField_def@
F << extract_PredictorVGetField_def.F;
T << extract_PredictorVGetField_def.T;
P << extract_PredictorVGetField_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_PredictorVGetField_def_void@
identifier F = PredictorVGetField;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_PredictorVGetField_def_void@
F << extract_PredictorVGetField_def_void.F;
P << extract_PredictorVGetField_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_PredictorVGetField_decl@
type T;
identifier F = PredictorVGetField;
parameter list P;
@@
T F(P);

@script:python depends on extract_PredictorVGetField_decl@
F << extract_PredictorVGetField_decl.F;
T << extract_PredictorVGetField_decl.T;
P << extract_PredictorVGetField_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_PredictorVGetField_decl_void@
identifier F = PredictorVGetField;
parameter list P;
@@
void F(P);

@script:python depends on extract_PredictorVGetField_decl_void@
F << extract_PredictorVGetField_decl_void.F;
P << extract_PredictorVGetField_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: PredictorVSetField
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_PredictorVSetField_def@
type T;
identifier F = PredictorVSetField;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_PredictorVSetField_def@
F << remove_static_PredictorVSetField_def.F;
T << remove_static_PredictorVSetField_def.T;
P << remove_static_PredictorVSetField_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_PredictorVSetField_def_void@
identifier F = PredictorVSetField;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_PredictorVSetField_def_void@
F << remove_static_PredictorVSetField_def_void.F;
P << remove_static_PredictorVSetField_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_PredictorVSetField_decl@
type T;
identifier F = PredictorVSetField;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_PredictorVSetField_decl@
F << remove_static_PredictorVSetField_decl.F;
T << remove_static_PredictorVSetField_decl.T;
P << remove_static_PredictorVSetField_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_PredictorVSetField_decl_void@
identifier F = PredictorVSetField;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_PredictorVSetField_decl_void@
F << remove_static_PredictorVSetField_decl_void.F;
P << remove_static_PredictorVSetField_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_PredictorVSetField_def@
type T;
identifier F = PredictorVSetField;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_PredictorVSetField_def@
F << extract_PredictorVSetField_def.F;
T << extract_PredictorVSetField_def.T;
P << extract_PredictorVSetField_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_PredictorVSetField_def_void@
identifier F = PredictorVSetField;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_PredictorVSetField_def_void@
F << extract_PredictorVSetField_def_void.F;
P << extract_PredictorVSetField_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_PredictorVSetField_decl@
type T;
identifier F = PredictorVSetField;
parameter list P;
@@
T F(P);

@script:python depends on extract_PredictorVSetField_decl@
F << extract_PredictorVSetField_decl.F;
T << extract_PredictorVSetField_decl.T;
P << extract_PredictorVSetField_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_PredictorVSetField_decl_void@
identifier F = PredictorVSetField;
parameter list P;
@@
void F(P);

@script:python depends on extract_PredictorVSetField_decl_void@
F << extract_PredictorVSetField_decl_void.F;
P << extract_PredictorVSetField_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: TWebPCleanup
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_TWebPCleanup_def@
type T;
identifier F = TWebPCleanup;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_TWebPCleanup_def@
F << remove_static_TWebPCleanup_def.F;
T << remove_static_TWebPCleanup_def.T;
P << remove_static_TWebPCleanup_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_TWebPCleanup_def_void@
identifier F = TWebPCleanup;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_TWebPCleanup_def_void@
F << remove_static_TWebPCleanup_def_void.F;
P << remove_static_TWebPCleanup_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_TWebPCleanup_decl@
type T;
identifier F = TWebPCleanup;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_TWebPCleanup_decl@
F << remove_static_TWebPCleanup_decl.F;
T << remove_static_TWebPCleanup_decl.T;
P << remove_static_TWebPCleanup_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_TWebPCleanup_decl_void@
identifier F = TWebPCleanup;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_TWebPCleanup_decl_void@
F << remove_static_TWebPCleanup_decl_void.F;
P << remove_static_TWebPCleanup_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_TWebPCleanup_def@
type T;
identifier F = TWebPCleanup;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_TWebPCleanup_def@
F << extract_TWebPCleanup_def.F;
T << extract_TWebPCleanup_def.T;
P << extract_TWebPCleanup_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_TWebPCleanup_def_void@
identifier F = TWebPCleanup;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_TWebPCleanup_def_void@
F << extract_TWebPCleanup_def_void.F;
P << extract_TWebPCleanup_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_TWebPCleanup_decl@
type T;
identifier F = TWebPCleanup;
parameter list P;
@@
T F(P);

@script:python depends on extract_TWebPCleanup_decl@
F << extract_TWebPCleanup_decl.F;
T << extract_TWebPCleanup_decl.T;
P << extract_TWebPCleanup_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_TWebPCleanup_decl_void@
identifier F = TWebPCleanup;
parameter list P;
@@
void F(P);

@script:python depends on extract_TWebPCleanup_decl_void@
F << extract_TWebPCleanup_decl_void.F;
P << extract_TWebPCleanup_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: TWebPDecode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_TWebPDecode_def@
type T;
identifier F = TWebPDecode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_TWebPDecode_def@
F << remove_static_TWebPDecode_def.F;
T << remove_static_TWebPDecode_def.T;
P << remove_static_TWebPDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_TWebPDecode_def_void@
identifier F = TWebPDecode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_TWebPDecode_def_void@
F << remove_static_TWebPDecode_def_void.F;
P << remove_static_TWebPDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_TWebPDecode_decl@
type T;
identifier F = TWebPDecode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_TWebPDecode_decl@
F << remove_static_TWebPDecode_decl.F;
T << remove_static_TWebPDecode_decl.T;
P << remove_static_TWebPDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_TWebPDecode_decl_void@
identifier F = TWebPDecode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_TWebPDecode_decl_void@
F << remove_static_TWebPDecode_decl_void.F;
P << remove_static_TWebPDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_TWebPDecode_def@
type T;
identifier F = TWebPDecode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_TWebPDecode_def@
F << extract_TWebPDecode_def.F;
T << extract_TWebPDecode_def.T;
P << extract_TWebPDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_TWebPDecode_def_void@
identifier F = TWebPDecode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_TWebPDecode_def_void@
F << extract_TWebPDecode_def_void.F;
P << extract_TWebPDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_TWebPDecode_decl@
type T;
identifier F = TWebPDecode;
parameter list P;
@@
T F(P);

@script:python depends on extract_TWebPDecode_decl@
F << extract_TWebPDecode_decl.F;
T << extract_TWebPDecode_decl.T;
P << extract_TWebPDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_TWebPDecode_decl_void@
identifier F = TWebPDecode;
parameter list P;
@@
void F(P);

@script:python depends on extract_TWebPDecode_decl_void@
F << extract_TWebPDecode_decl_void.F;
P << extract_TWebPDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: TWebPEncode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_TWebPEncode_def@
type T;
identifier F = TWebPEncode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_TWebPEncode_def@
F << remove_static_TWebPEncode_def.F;
T << remove_static_TWebPEncode_def.T;
P << remove_static_TWebPEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_TWebPEncode_def_void@
identifier F = TWebPEncode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_TWebPEncode_def_void@
F << remove_static_TWebPEncode_def_void.F;
P << remove_static_TWebPEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_TWebPEncode_decl@
type T;
identifier F = TWebPEncode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_TWebPEncode_decl@
F << remove_static_TWebPEncode_decl.F;
T << remove_static_TWebPEncode_decl.T;
P << remove_static_TWebPEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_TWebPEncode_decl_void@
identifier F = TWebPEncode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_TWebPEncode_decl_void@
F << remove_static_TWebPEncode_decl_void.F;
P << remove_static_TWebPEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_TWebPEncode_def@
type T;
identifier F = TWebPEncode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_TWebPEncode_def@
F << extract_TWebPEncode_def.F;
T << extract_TWebPEncode_def.T;
P << extract_TWebPEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_TWebPEncode_def_void@
identifier F = TWebPEncode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_TWebPEncode_def_void@
F << extract_TWebPEncode_def_void.F;
P << extract_TWebPEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_TWebPEncode_decl@
type T;
identifier F = TWebPEncode;
parameter list P;
@@
T F(P);

@script:python depends on extract_TWebPEncode_decl@
F << extract_TWebPEncode_decl.F;
T << extract_TWebPEncode_decl.T;
P << extract_TWebPEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_TWebPEncode_decl_void@
identifier F = TWebPEncode;
parameter list P;
@@
void F(P);

@script:python depends on extract_TWebPEncode_decl_void@
F << extract_TWebPEncode_decl_void.F;
P << extract_TWebPEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: TWebPFixupTags
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_TWebPFixupTags_def@
type T;
identifier F = TWebPFixupTags;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_TWebPFixupTags_def@
F << remove_static_TWebPFixupTags_def.F;
T << remove_static_TWebPFixupTags_def.T;
P << remove_static_TWebPFixupTags_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_TWebPFixupTags_def_void@
identifier F = TWebPFixupTags;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_TWebPFixupTags_def_void@
F << remove_static_TWebPFixupTags_def_void.F;
P << remove_static_TWebPFixupTags_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_TWebPFixupTags_decl@
type T;
identifier F = TWebPFixupTags;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_TWebPFixupTags_decl@
F << remove_static_TWebPFixupTags_decl.F;
T << remove_static_TWebPFixupTags_decl.T;
P << remove_static_TWebPFixupTags_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_TWebPFixupTags_decl_void@
identifier F = TWebPFixupTags;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_TWebPFixupTags_decl_void@
F << remove_static_TWebPFixupTags_decl_void.F;
P << remove_static_TWebPFixupTags_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_TWebPFixupTags_def@
type T;
identifier F = TWebPFixupTags;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_TWebPFixupTags_def@
F << extract_TWebPFixupTags_def.F;
T << extract_TWebPFixupTags_def.T;
P << extract_TWebPFixupTags_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_TWebPFixupTags_def_void@
identifier F = TWebPFixupTags;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_TWebPFixupTags_def_void@
F << extract_TWebPFixupTags_def_void.F;
P << extract_TWebPFixupTags_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_TWebPFixupTags_decl@
type T;
identifier F = TWebPFixupTags;
parameter list P;
@@
T F(P);

@script:python depends on extract_TWebPFixupTags_decl@
F << extract_TWebPFixupTags_decl.F;
T << extract_TWebPFixupTags_decl.T;
P << extract_TWebPFixupTags_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_TWebPFixupTags_decl_void@
identifier F = TWebPFixupTags;
parameter list P;
@@
void F(P);

@script:python depends on extract_TWebPFixupTags_decl_void@
F << extract_TWebPFixupTags_decl_void.F;
P << extract_TWebPFixupTags_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: TWebPPostEncode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_TWebPPostEncode_def@
type T;
identifier F = TWebPPostEncode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_TWebPPostEncode_def@
F << remove_static_TWebPPostEncode_def.F;
T << remove_static_TWebPPostEncode_def.T;
P << remove_static_TWebPPostEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_TWebPPostEncode_def_void@
identifier F = TWebPPostEncode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_TWebPPostEncode_def_void@
F << remove_static_TWebPPostEncode_def_void.F;
P << remove_static_TWebPPostEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_TWebPPostEncode_decl@
type T;
identifier F = TWebPPostEncode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_TWebPPostEncode_decl@
F << remove_static_TWebPPostEncode_decl.F;
T << remove_static_TWebPPostEncode_decl.T;
P << remove_static_TWebPPostEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_TWebPPostEncode_decl_void@
identifier F = TWebPPostEncode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_TWebPPostEncode_decl_void@
F << remove_static_TWebPPostEncode_decl_void.F;
P << remove_static_TWebPPostEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_TWebPPostEncode_def@
type T;
identifier F = TWebPPostEncode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_TWebPPostEncode_def@
F << extract_TWebPPostEncode_def.F;
T << extract_TWebPPostEncode_def.T;
P << extract_TWebPPostEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_TWebPPostEncode_def_void@
identifier F = TWebPPostEncode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_TWebPPostEncode_def_void@
F << extract_TWebPPostEncode_def_void.F;
P << extract_TWebPPostEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_TWebPPostEncode_decl@
type T;
identifier F = TWebPPostEncode;
parameter list P;
@@
T F(P);

@script:python depends on extract_TWebPPostEncode_decl@
F << extract_TWebPPostEncode_decl.F;
T << extract_TWebPPostEncode_decl.T;
P << extract_TWebPPostEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_TWebPPostEncode_decl_void@
identifier F = TWebPPostEncode;
parameter list P;
@@
void F(P);

@script:python depends on extract_TWebPPostEncode_decl_void@
F << extract_TWebPPostEncode_decl_void.F;
P << extract_TWebPPostEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: TWebPPreDecode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_TWebPPreDecode_def@
type T;
identifier F = TWebPPreDecode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_TWebPPreDecode_def@
F << remove_static_TWebPPreDecode_def.F;
T << remove_static_TWebPPreDecode_def.T;
P << remove_static_TWebPPreDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_TWebPPreDecode_def_void@
identifier F = TWebPPreDecode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_TWebPPreDecode_def_void@
F << remove_static_TWebPPreDecode_def_void.F;
P << remove_static_TWebPPreDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_TWebPPreDecode_decl@
type T;
identifier F = TWebPPreDecode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_TWebPPreDecode_decl@
F << remove_static_TWebPPreDecode_decl.F;
T << remove_static_TWebPPreDecode_decl.T;
P << remove_static_TWebPPreDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_TWebPPreDecode_decl_void@
identifier F = TWebPPreDecode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_TWebPPreDecode_decl_void@
F << remove_static_TWebPPreDecode_decl_void.F;
P << remove_static_TWebPPreDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_TWebPPreDecode_def@
type T;
identifier F = TWebPPreDecode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_TWebPPreDecode_def@
F << extract_TWebPPreDecode_def.F;
T << extract_TWebPPreDecode_def.T;
P << extract_TWebPPreDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_TWebPPreDecode_def_void@
identifier F = TWebPPreDecode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_TWebPPreDecode_def_void@
F << extract_TWebPPreDecode_def_void.F;
P << extract_TWebPPreDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_TWebPPreDecode_decl@
type T;
identifier F = TWebPPreDecode;
parameter list P;
@@
T F(P);

@script:python depends on extract_TWebPPreDecode_decl@
F << extract_TWebPPreDecode_decl.F;
T << extract_TWebPPreDecode_decl.T;
P << extract_TWebPPreDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_TWebPPreDecode_decl_void@
identifier F = TWebPPreDecode;
parameter list P;
@@
void F(P);

@script:python depends on extract_TWebPPreDecode_decl_void@
F << extract_TWebPPreDecode_decl_void.F;
P << extract_TWebPPreDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: TWebPPreEncode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_TWebPPreEncode_def@
type T;
identifier F = TWebPPreEncode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_TWebPPreEncode_def@
F << remove_static_TWebPPreEncode_def.F;
T << remove_static_TWebPPreEncode_def.T;
P << remove_static_TWebPPreEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_TWebPPreEncode_def_void@
identifier F = TWebPPreEncode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_TWebPPreEncode_def_void@
F << remove_static_TWebPPreEncode_def_void.F;
P << remove_static_TWebPPreEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_TWebPPreEncode_decl@
type T;
identifier F = TWebPPreEncode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_TWebPPreEncode_decl@
F << remove_static_TWebPPreEncode_decl.F;
T << remove_static_TWebPPreEncode_decl.T;
P << remove_static_TWebPPreEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_TWebPPreEncode_decl_void@
identifier F = TWebPPreEncode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_TWebPPreEncode_decl_void@
F << remove_static_TWebPPreEncode_decl_void.F;
P << remove_static_TWebPPreEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_TWebPPreEncode_def@
type T;
identifier F = TWebPPreEncode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_TWebPPreEncode_def@
F << extract_TWebPPreEncode_def.F;
T << extract_TWebPPreEncode_def.T;
P << extract_TWebPPreEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_TWebPPreEncode_def_void@
identifier F = TWebPPreEncode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_TWebPPreEncode_def_void@
F << extract_TWebPPreEncode_def_void.F;
P << extract_TWebPPreEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_TWebPPreEncode_decl@
type T;
identifier F = TWebPPreEncode;
parameter list P;
@@
T F(P);

@script:python depends on extract_TWebPPreEncode_decl@
F << extract_TWebPPreEncode_decl.F;
T << extract_TWebPPreEncode_decl.T;
P << extract_TWebPPreEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_TWebPPreEncode_decl_void@
identifier F = TWebPPreEncode;
parameter list P;
@@
void F(P);

@script:python depends on extract_TWebPPreEncode_decl_void@
F << extract_TWebPPreEncode_decl_void.F;
P << extract_TWebPPreEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: TWebPSetupDecode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_TWebPSetupDecode_def@
type T;
identifier F = TWebPSetupDecode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_TWebPSetupDecode_def@
F << remove_static_TWebPSetupDecode_def.F;
T << remove_static_TWebPSetupDecode_def.T;
P << remove_static_TWebPSetupDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_TWebPSetupDecode_def_void@
identifier F = TWebPSetupDecode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_TWebPSetupDecode_def_void@
F << remove_static_TWebPSetupDecode_def_void.F;
P << remove_static_TWebPSetupDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_TWebPSetupDecode_decl@
type T;
identifier F = TWebPSetupDecode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_TWebPSetupDecode_decl@
F << remove_static_TWebPSetupDecode_decl.F;
T << remove_static_TWebPSetupDecode_decl.T;
P << remove_static_TWebPSetupDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_TWebPSetupDecode_decl_void@
identifier F = TWebPSetupDecode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_TWebPSetupDecode_decl_void@
F << remove_static_TWebPSetupDecode_decl_void.F;
P << remove_static_TWebPSetupDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_TWebPSetupDecode_def@
type T;
identifier F = TWebPSetupDecode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_TWebPSetupDecode_def@
F << extract_TWebPSetupDecode_def.F;
T << extract_TWebPSetupDecode_def.T;
P << extract_TWebPSetupDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_TWebPSetupDecode_def_void@
identifier F = TWebPSetupDecode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_TWebPSetupDecode_def_void@
F << extract_TWebPSetupDecode_def_void.F;
P << extract_TWebPSetupDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_TWebPSetupDecode_decl@
type T;
identifier F = TWebPSetupDecode;
parameter list P;
@@
T F(P);

@script:python depends on extract_TWebPSetupDecode_decl@
F << extract_TWebPSetupDecode_decl.F;
T << extract_TWebPSetupDecode_decl.T;
P << extract_TWebPSetupDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_TWebPSetupDecode_decl_void@
identifier F = TWebPSetupDecode;
parameter list P;
@@
void F(P);

@script:python depends on extract_TWebPSetupDecode_decl_void@
F << extract_TWebPSetupDecode_decl_void.F;
P << extract_TWebPSetupDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: TWebPSetupEncode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_TWebPSetupEncode_def@
type T;
identifier F = TWebPSetupEncode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_TWebPSetupEncode_def@
F << remove_static_TWebPSetupEncode_def.F;
T << remove_static_TWebPSetupEncode_def.T;
P << remove_static_TWebPSetupEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_TWebPSetupEncode_def_void@
identifier F = TWebPSetupEncode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_TWebPSetupEncode_def_void@
F << remove_static_TWebPSetupEncode_def_void.F;
P << remove_static_TWebPSetupEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_TWebPSetupEncode_decl@
type T;
identifier F = TWebPSetupEncode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_TWebPSetupEncode_decl@
F << remove_static_TWebPSetupEncode_decl.F;
T << remove_static_TWebPSetupEncode_decl.T;
P << remove_static_TWebPSetupEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_TWebPSetupEncode_decl_void@
identifier F = TWebPSetupEncode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_TWebPSetupEncode_decl_void@
F << remove_static_TWebPSetupEncode_decl_void.F;
P << remove_static_TWebPSetupEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_TWebPSetupEncode_def@
type T;
identifier F = TWebPSetupEncode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_TWebPSetupEncode_def@
F << extract_TWebPSetupEncode_def.F;
T << extract_TWebPSetupEncode_def.T;
P << extract_TWebPSetupEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_TWebPSetupEncode_def_void@
identifier F = TWebPSetupEncode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_TWebPSetupEncode_def_void@
F << extract_TWebPSetupEncode_def_void.F;
P << extract_TWebPSetupEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_TWebPSetupEncode_decl@
type T;
identifier F = TWebPSetupEncode;
parameter list P;
@@
T F(P);

@script:python depends on extract_TWebPSetupEncode_decl@
F << extract_TWebPSetupEncode_decl.F;
T << extract_TWebPSetupEncode_decl.T;
P << extract_TWebPSetupEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_TWebPSetupEncode_decl_void@
identifier F = TWebPSetupEncode;
parameter list P;
@@
void F(P);

@script:python depends on extract_TWebPSetupEncode_decl_void@
F << extract_TWebPSetupEncode_decl_void.F;
P << extract_TWebPSetupEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: TWebPVGetField
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_TWebPVGetField_def@
type T;
identifier F = TWebPVGetField;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_TWebPVGetField_def@
F << remove_static_TWebPVGetField_def.F;
T << remove_static_TWebPVGetField_def.T;
P << remove_static_TWebPVGetField_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_TWebPVGetField_def_void@
identifier F = TWebPVGetField;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_TWebPVGetField_def_void@
F << remove_static_TWebPVGetField_def_void.F;
P << remove_static_TWebPVGetField_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_TWebPVGetField_decl@
type T;
identifier F = TWebPVGetField;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_TWebPVGetField_decl@
F << remove_static_TWebPVGetField_decl.F;
T << remove_static_TWebPVGetField_decl.T;
P << remove_static_TWebPVGetField_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_TWebPVGetField_decl_void@
identifier F = TWebPVGetField;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_TWebPVGetField_decl_void@
F << remove_static_TWebPVGetField_decl_void.F;
P << remove_static_TWebPVGetField_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_TWebPVGetField_def@
type T;
identifier F = TWebPVGetField;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_TWebPVGetField_def@
F << extract_TWebPVGetField_def.F;
T << extract_TWebPVGetField_def.T;
P << extract_TWebPVGetField_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_TWebPVGetField_def_void@
identifier F = TWebPVGetField;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_TWebPVGetField_def_void@
F << extract_TWebPVGetField_def_void.F;
P << extract_TWebPVGetField_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_TWebPVGetField_decl@
type T;
identifier F = TWebPVGetField;
parameter list P;
@@
T F(P);

@script:python depends on extract_TWebPVGetField_decl@
F << extract_TWebPVGetField_decl.F;
T << extract_TWebPVGetField_decl.T;
P << extract_TWebPVGetField_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_TWebPVGetField_decl_void@
identifier F = TWebPVGetField;
parameter list P;
@@
void F(P);

@script:python depends on extract_TWebPVGetField_decl_void@
F << extract_TWebPVGetField_decl_void.F;
P << extract_TWebPVGetField_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: TWebPVSetField
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_TWebPVSetField_def@
type T;
identifier F = TWebPVSetField;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_TWebPVSetField_def@
F << remove_static_TWebPVSetField_def.F;
T << remove_static_TWebPVSetField_def.T;
P << remove_static_TWebPVSetField_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_TWebPVSetField_def_void@
identifier F = TWebPVSetField;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_TWebPVSetField_def_void@
F << remove_static_TWebPVSetField_def_void.F;
P << remove_static_TWebPVSetField_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_TWebPVSetField_decl@
type T;
identifier F = TWebPVSetField;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_TWebPVSetField_decl@
F << remove_static_TWebPVSetField_decl.F;
T << remove_static_TWebPVSetField_decl.T;
P << remove_static_TWebPVSetField_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_TWebPVSetField_decl_void@
identifier F = TWebPVSetField;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_TWebPVSetField_decl_void@
F << remove_static_TWebPVSetField_decl_void.F;
P << remove_static_TWebPVSetField_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_TWebPVSetField_def@
type T;
identifier F = TWebPVSetField;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_TWebPVSetField_def@
F << extract_TWebPVSetField_def.F;
T << extract_TWebPVSetField_def.T;
P << extract_TWebPVSetField_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_TWebPVSetField_def_void@
identifier F = TWebPVSetField;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_TWebPVSetField_def_void@
F << extract_TWebPVSetField_def_void.F;
P << extract_TWebPVSetField_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_TWebPVSetField_decl@
type T;
identifier F = TWebPVSetField;
parameter list P;
@@
T F(P);

@script:python depends on extract_TWebPVSetField_decl@
F << extract_TWebPVSetField_decl.F;
T << extract_TWebPVSetField_decl.T;
P << extract_TWebPVSetField_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_TWebPVSetField_decl_void@
identifier F = TWebPVSetField;
parameter list P;
@@
void F(P);

@script:python depends on extract_TWebPVSetField_decl_void@
F << extract_TWebPVSetField_decl_void.F;
P << extract_TWebPVSetField_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: ThunderDecodeRow
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_ThunderDecodeRow_def@
type T;
identifier F = ThunderDecodeRow;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_ThunderDecodeRow_def@
F << remove_static_ThunderDecodeRow_def.F;
T << remove_static_ThunderDecodeRow_def.T;
P << remove_static_ThunderDecodeRow_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_ThunderDecodeRow_def_void@
identifier F = ThunderDecodeRow;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_ThunderDecodeRow_def_void@
F << remove_static_ThunderDecodeRow_def_void.F;
P << remove_static_ThunderDecodeRow_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_ThunderDecodeRow_decl@
type T;
identifier F = ThunderDecodeRow;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_ThunderDecodeRow_decl@
F << remove_static_ThunderDecodeRow_decl.F;
T << remove_static_ThunderDecodeRow_decl.T;
P << remove_static_ThunderDecodeRow_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_ThunderDecodeRow_decl_void@
identifier F = ThunderDecodeRow;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_ThunderDecodeRow_decl_void@
F << remove_static_ThunderDecodeRow_decl_void.F;
P << remove_static_ThunderDecodeRow_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_ThunderDecodeRow_def@
type T;
identifier F = ThunderDecodeRow;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_ThunderDecodeRow_def@
F << extract_ThunderDecodeRow_def.F;
T << extract_ThunderDecodeRow_def.T;
P << extract_ThunderDecodeRow_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_ThunderDecodeRow_def_void@
identifier F = ThunderDecodeRow;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_ThunderDecodeRow_def_void@
F << extract_ThunderDecodeRow_def_void.F;
P << extract_ThunderDecodeRow_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_ThunderDecodeRow_decl@
type T;
identifier F = ThunderDecodeRow;
parameter list P;
@@
T F(P);

@script:python depends on extract_ThunderDecodeRow_decl@
F << extract_ThunderDecodeRow_decl.F;
T << extract_ThunderDecodeRow_decl.T;
P << extract_ThunderDecodeRow_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_ThunderDecodeRow_decl_void@
identifier F = ThunderDecodeRow;
parameter list P;
@@
void F(P);

@script:python depends on extract_ThunderDecodeRow_decl_void@
F << extract_ThunderDecodeRow_decl_void.F;
P << extract_ThunderDecodeRow_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: ThunderSetupDecode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_ThunderSetupDecode_def@
type T;
identifier F = ThunderSetupDecode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_ThunderSetupDecode_def@
F << remove_static_ThunderSetupDecode_def.F;
T << remove_static_ThunderSetupDecode_def.T;
P << remove_static_ThunderSetupDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_ThunderSetupDecode_def_void@
identifier F = ThunderSetupDecode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_ThunderSetupDecode_def_void@
F << remove_static_ThunderSetupDecode_def_void.F;
P << remove_static_ThunderSetupDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_ThunderSetupDecode_decl@
type T;
identifier F = ThunderSetupDecode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_ThunderSetupDecode_decl@
F << remove_static_ThunderSetupDecode_decl.F;
T << remove_static_ThunderSetupDecode_decl.T;
P << remove_static_ThunderSetupDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_ThunderSetupDecode_decl_void@
identifier F = ThunderSetupDecode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_ThunderSetupDecode_decl_void@
F << remove_static_ThunderSetupDecode_decl_void.F;
P << remove_static_ThunderSetupDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_ThunderSetupDecode_def@
type T;
identifier F = ThunderSetupDecode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_ThunderSetupDecode_def@
F << extract_ThunderSetupDecode_def.F;
T << extract_ThunderSetupDecode_def.T;
P << extract_ThunderSetupDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_ThunderSetupDecode_def_void@
identifier F = ThunderSetupDecode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_ThunderSetupDecode_def_void@
F << extract_ThunderSetupDecode_def_void.F;
P << extract_ThunderSetupDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_ThunderSetupDecode_decl@
type T;
identifier F = ThunderSetupDecode;
parameter list P;
@@
T F(P);

@script:python depends on extract_ThunderSetupDecode_decl@
F << extract_ThunderSetupDecode_decl.F;
T << extract_ThunderSetupDecode_decl.T;
P << extract_ThunderSetupDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_ThunderSetupDecode_decl_void@
identifier F = ThunderSetupDecode;
parameter list P;
@@
void F(P);

@script:python depends on extract_ThunderSetupDecode_decl_void@
F << extract_ThunderSetupDecode_decl_void.F;
P << extract_ThunderSetupDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: ZIPCleanup
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_ZIPCleanup_def@
type T;
identifier F = ZIPCleanup;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_ZIPCleanup_def@
F << remove_static_ZIPCleanup_def.F;
T << remove_static_ZIPCleanup_def.T;
P << remove_static_ZIPCleanup_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_ZIPCleanup_def_void@
identifier F = ZIPCleanup;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_ZIPCleanup_def_void@
F << remove_static_ZIPCleanup_def_void.F;
P << remove_static_ZIPCleanup_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_ZIPCleanup_decl@
type T;
identifier F = ZIPCleanup;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_ZIPCleanup_decl@
F << remove_static_ZIPCleanup_decl.F;
T << remove_static_ZIPCleanup_decl.T;
P << remove_static_ZIPCleanup_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_ZIPCleanup_decl_void@
identifier F = ZIPCleanup;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_ZIPCleanup_decl_void@
F << remove_static_ZIPCleanup_decl_void.F;
P << remove_static_ZIPCleanup_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_ZIPCleanup_def@
type T;
identifier F = ZIPCleanup;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_ZIPCleanup_def@
F << extract_ZIPCleanup_def.F;
T << extract_ZIPCleanup_def.T;
P << extract_ZIPCleanup_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_ZIPCleanup_def_void@
identifier F = ZIPCleanup;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_ZIPCleanup_def_void@
F << extract_ZIPCleanup_def_void.F;
P << extract_ZIPCleanup_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_ZIPCleanup_decl@
type T;
identifier F = ZIPCleanup;
parameter list P;
@@
T F(P);

@script:python depends on extract_ZIPCleanup_decl@
F << extract_ZIPCleanup_decl.F;
T << extract_ZIPCleanup_decl.T;
P << extract_ZIPCleanup_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_ZIPCleanup_decl_void@
identifier F = ZIPCleanup;
parameter list P;
@@
void F(P);

@script:python depends on extract_ZIPCleanup_decl_void@
F << extract_ZIPCleanup_decl_void.F;
P << extract_ZIPCleanup_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: ZIPDecode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_ZIPDecode_def@
type T;
identifier F = ZIPDecode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_ZIPDecode_def@
F << remove_static_ZIPDecode_def.F;
T << remove_static_ZIPDecode_def.T;
P << remove_static_ZIPDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_ZIPDecode_def_void@
identifier F = ZIPDecode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_ZIPDecode_def_void@
F << remove_static_ZIPDecode_def_void.F;
P << remove_static_ZIPDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_ZIPDecode_decl@
type T;
identifier F = ZIPDecode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_ZIPDecode_decl@
F << remove_static_ZIPDecode_decl.F;
T << remove_static_ZIPDecode_decl.T;
P << remove_static_ZIPDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_ZIPDecode_decl_void@
identifier F = ZIPDecode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_ZIPDecode_decl_void@
F << remove_static_ZIPDecode_decl_void.F;
P << remove_static_ZIPDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_ZIPDecode_def@
type T;
identifier F = ZIPDecode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_ZIPDecode_def@
F << extract_ZIPDecode_def.F;
T << extract_ZIPDecode_def.T;
P << extract_ZIPDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_ZIPDecode_def_void@
identifier F = ZIPDecode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_ZIPDecode_def_void@
F << extract_ZIPDecode_def_void.F;
P << extract_ZIPDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_ZIPDecode_decl@
type T;
identifier F = ZIPDecode;
parameter list P;
@@
T F(P);

@script:python depends on extract_ZIPDecode_decl@
F << extract_ZIPDecode_decl.F;
T << extract_ZIPDecode_decl.T;
P << extract_ZIPDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_ZIPDecode_decl_void@
identifier F = ZIPDecode;
parameter list P;
@@
void F(P);

@script:python depends on extract_ZIPDecode_decl_void@
F << extract_ZIPDecode_decl_void.F;
P << extract_ZIPDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: ZIPEncode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_ZIPEncode_def@
type T;
identifier F = ZIPEncode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_ZIPEncode_def@
F << remove_static_ZIPEncode_def.F;
T << remove_static_ZIPEncode_def.T;
P << remove_static_ZIPEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_ZIPEncode_def_void@
identifier F = ZIPEncode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_ZIPEncode_def_void@
F << remove_static_ZIPEncode_def_void.F;
P << remove_static_ZIPEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_ZIPEncode_decl@
type T;
identifier F = ZIPEncode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_ZIPEncode_decl@
F << remove_static_ZIPEncode_decl.F;
T << remove_static_ZIPEncode_decl.T;
P << remove_static_ZIPEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_ZIPEncode_decl_void@
identifier F = ZIPEncode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_ZIPEncode_decl_void@
F << remove_static_ZIPEncode_decl_void.F;
P << remove_static_ZIPEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_ZIPEncode_def@
type T;
identifier F = ZIPEncode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_ZIPEncode_def@
F << extract_ZIPEncode_def.F;
T << extract_ZIPEncode_def.T;
P << extract_ZIPEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_ZIPEncode_def_void@
identifier F = ZIPEncode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_ZIPEncode_def_void@
F << extract_ZIPEncode_def_void.F;
P << extract_ZIPEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_ZIPEncode_decl@
type T;
identifier F = ZIPEncode;
parameter list P;
@@
T F(P);

@script:python depends on extract_ZIPEncode_decl@
F << extract_ZIPEncode_decl.F;
T << extract_ZIPEncode_decl.T;
P << extract_ZIPEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_ZIPEncode_decl_void@
identifier F = ZIPEncode;
parameter list P;
@@
void F(P);

@script:python depends on extract_ZIPEncode_decl_void@
F << extract_ZIPEncode_decl_void.F;
P << extract_ZIPEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: ZIPFixupTags
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_ZIPFixupTags_def@
type T;
identifier F = ZIPFixupTags;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_ZIPFixupTags_def@
F << remove_static_ZIPFixupTags_def.F;
T << remove_static_ZIPFixupTags_def.T;
P << remove_static_ZIPFixupTags_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_ZIPFixupTags_def_void@
identifier F = ZIPFixupTags;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_ZIPFixupTags_def_void@
F << remove_static_ZIPFixupTags_def_void.F;
P << remove_static_ZIPFixupTags_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_ZIPFixupTags_decl@
type T;
identifier F = ZIPFixupTags;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_ZIPFixupTags_decl@
F << remove_static_ZIPFixupTags_decl.F;
T << remove_static_ZIPFixupTags_decl.T;
P << remove_static_ZIPFixupTags_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_ZIPFixupTags_decl_void@
identifier F = ZIPFixupTags;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_ZIPFixupTags_decl_void@
F << remove_static_ZIPFixupTags_decl_void.F;
P << remove_static_ZIPFixupTags_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_ZIPFixupTags_def@
type T;
identifier F = ZIPFixupTags;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_ZIPFixupTags_def@
F << extract_ZIPFixupTags_def.F;
T << extract_ZIPFixupTags_def.T;
P << extract_ZIPFixupTags_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_ZIPFixupTags_def_void@
identifier F = ZIPFixupTags;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_ZIPFixupTags_def_void@
F << extract_ZIPFixupTags_def_void.F;
P << extract_ZIPFixupTags_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_ZIPFixupTags_decl@
type T;
identifier F = ZIPFixupTags;
parameter list P;
@@
T F(P);

@script:python depends on extract_ZIPFixupTags_decl@
F << extract_ZIPFixupTags_decl.F;
T << extract_ZIPFixupTags_decl.T;
P << extract_ZIPFixupTags_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_ZIPFixupTags_decl_void@
identifier F = ZIPFixupTags;
parameter list P;
@@
void F(P);

@script:python depends on extract_ZIPFixupTags_decl_void@
F << extract_ZIPFixupTags_decl_void.F;
P << extract_ZIPFixupTags_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: ZIPPostEncode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_ZIPPostEncode_def@
type T;
identifier F = ZIPPostEncode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_ZIPPostEncode_def@
F << remove_static_ZIPPostEncode_def.F;
T << remove_static_ZIPPostEncode_def.T;
P << remove_static_ZIPPostEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_ZIPPostEncode_def_void@
identifier F = ZIPPostEncode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_ZIPPostEncode_def_void@
F << remove_static_ZIPPostEncode_def_void.F;
P << remove_static_ZIPPostEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_ZIPPostEncode_decl@
type T;
identifier F = ZIPPostEncode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_ZIPPostEncode_decl@
F << remove_static_ZIPPostEncode_decl.F;
T << remove_static_ZIPPostEncode_decl.T;
P << remove_static_ZIPPostEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_ZIPPostEncode_decl_void@
identifier F = ZIPPostEncode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_ZIPPostEncode_decl_void@
F << remove_static_ZIPPostEncode_decl_void.F;
P << remove_static_ZIPPostEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_ZIPPostEncode_def@
type T;
identifier F = ZIPPostEncode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_ZIPPostEncode_def@
F << extract_ZIPPostEncode_def.F;
T << extract_ZIPPostEncode_def.T;
P << extract_ZIPPostEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_ZIPPostEncode_def_void@
identifier F = ZIPPostEncode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_ZIPPostEncode_def_void@
F << extract_ZIPPostEncode_def_void.F;
P << extract_ZIPPostEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_ZIPPostEncode_decl@
type T;
identifier F = ZIPPostEncode;
parameter list P;
@@
T F(P);

@script:python depends on extract_ZIPPostEncode_decl@
F << extract_ZIPPostEncode_decl.F;
T << extract_ZIPPostEncode_decl.T;
P << extract_ZIPPostEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_ZIPPostEncode_decl_void@
identifier F = ZIPPostEncode;
parameter list P;
@@
void F(P);

@script:python depends on extract_ZIPPostEncode_decl_void@
F << extract_ZIPPostEncode_decl_void.F;
P << extract_ZIPPostEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: ZIPPreDecode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_ZIPPreDecode_def@
type T;
identifier F = ZIPPreDecode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_ZIPPreDecode_def@
F << remove_static_ZIPPreDecode_def.F;
T << remove_static_ZIPPreDecode_def.T;
P << remove_static_ZIPPreDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_ZIPPreDecode_def_void@
identifier F = ZIPPreDecode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_ZIPPreDecode_def_void@
F << remove_static_ZIPPreDecode_def_void.F;
P << remove_static_ZIPPreDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_ZIPPreDecode_decl@
type T;
identifier F = ZIPPreDecode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_ZIPPreDecode_decl@
F << remove_static_ZIPPreDecode_decl.F;
T << remove_static_ZIPPreDecode_decl.T;
P << remove_static_ZIPPreDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_ZIPPreDecode_decl_void@
identifier F = ZIPPreDecode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_ZIPPreDecode_decl_void@
F << remove_static_ZIPPreDecode_decl_void.F;
P << remove_static_ZIPPreDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_ZIPPreDecode_def@
type T;
identifier F = ZIPPreDecode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_ZIPPreDecode_def@
F << extract_ZIPPreDecode_def.F;
T << extract_ZIPPreDecode_def.T;
P << extract_ZIPPreDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_ZIPPreDecode_def_void@
identifier F = ZIPPreDecode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_ZIPPreDecode_def_void@
F << extract_ZIPPreDecode_def_void.F;
P << extract_ZIPPreDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_ZIPPreDecode_decl@
type T;
identifier F = ZIPPreDecode;
parameter list P;
@@
T F(P);

@script:python depends on extract_ZIPPreDecode_decl@
F << extract_ZIPPreDecode_decl.F;
T << extract_ZIPPreDecode_decl.T;
P << extract_ZIPPreDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_ZIPPreDecode_decl_void@
identifier F = ZIPPreDecode;
parameter list P;
@@
void F(P);

@script:python depends on extract_ZIPPreDecode_decl_void@
F << extract_ZIPPreDecode_decl_void.F;
P << extract_ZIPPreDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: ZIPPreEncode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_ZIPPreEncode_def@
type T;
identifier F = ZIPPreEncode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_ZIPPreEncode_def@
F << remove_static_ZIPPreEncode_def.F;
T << remove_static_ZIPPreEncode_def.T;
P << remove_static_ZIPPreEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_ZIPPreEncode_def_void@
identifier F = ZIPPreEncode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_ZIPPreEncode_def_void@
F << remove_static_ZIPPreEncode_def_void.F;
P << remove_static_ZIPPreEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_ZIPPreEncode_decl@
type T;
identifier F = ZIPPreEncode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_ZIPPreEncode_decl@
F << remove_static_ZIPPreEncode_decl.F;
T << remove_static_ZIPPreEncode_decl.T;
P << remove_static_ZIPPreEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_ZIPPreEncode_decl_void@
identifier F = ZIPPreEncode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_ZIPPreEncode_decl_void@
F << remove_static_ZIPPreEncode_decl_void.F;
P << remove_static_ZIPPreEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_ZIPPreEncode_def@
type T;
identifier F = ZIPPreEncode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_ZIPPreEncode_def@
F << extract_ZIPPreEncode_def.F;
T << extract_ZIPPreEncode_def.T;
P << extract_ZIPPreEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_ZIPPreEncode_def_void@
identifier F = ZIPPreEncode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_ZIPPreEncode_def_void@
F << extract_ZIPPreEncode_def_void.F;
P << extract_ZIPPreEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_ZIPPreEncode_decl@
type T;
identifier F = ZIPPreEncode;
parameter list P;
@@
T F(P);

@script:python depends on extract_ZIPPreEncode_decl@
F << extract_ZIPPreEncode_decl.F;
T << extract_ZIPPreEncode_decl.T;
P << extract_ZIPPreEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_ZIPPreEncode_decl_void@
identifier F = ZIPPreEncode;
parameter list P;
@@
void F(P);

@script:python depends on extract_ZIPPreEncode_decl_void@
F << extract_ZIPPreEncode_decl_void.F;
P << extract_ZIPPreEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: ZIPSetupDecode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_ZIPSetupDecode_def@
type T;
identifier F = ZIPSetupDecode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_ZIPSetupDecode_def@
F << remove_static_ZIPSetupDecode_def.F;
T << remove_static_ZIPSetupDecode_def.T;
P << remove_static_ZIPSetupDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_ZIPSetupDecode_def_void@
identifier F = ZIPSetupDecode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_ZIPSetupDecode_def_void@
F << remove_static_ZIPSetupDecode_def_void.F;
P << remove_static_ZIPSetupDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_ZIPSetupDecode_decl@
type T;
identifier F = ZIPSetupDecode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_ZIPSetupDecode_decl@
F << remove_static_ZIPSetupDecode_decl.F;
T << remove_static_ZIPSetupDecode_decl.T;
P << remove_static_ZIPSetupDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_ZIPSetupDecode_decl_void@
identifier F = ZIPSetupDecode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_ZIPSetupDecode_decl_void@
F << remove_static_ZIPSetupDecode_decl_void.F;
P << remove_static_ZIPSetupDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_ZIPSetupDecode_def@
type T;
identifier F = ZIPSetupDecode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_ZIPSetupDecode_def@
F << extract_ZIPSetupDecode_def.F;
T << extract_ZIPSetupDecode_def.T;
P << extract_ZIPSetupDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_ZIPSetupDecode_def_void@
identifier F = ZIPSetupDecode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_ZIPSetupDecode_def_void@
F << extract_ZIPSetupDecode_def_void.F;
P << extract_ZIPSetupDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_ZIPSetupDecode_decl@
type T;
identifier F = ZIPSetupDecode;
parameter list P;
@@
T F(P);

@script:python depends on extract_ZIPSetupDecode_decl@
F << extract_ZIPSetupDecode_decl.F;
T << extract_ZIPSetupDecode_decl.T;
P << extract_ZIPSetupDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_ZIPSetupDecode_decl_void@
identifier F = ZIPSetupDecode;
parameter list P;
@@
void F(P);

@script:python depends on extract_ZIPSetupDecode_decl_void@
F << extract_ZIPSetupDecode_decl_void.F;
P << extract_ZIPSetupDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: ZIPSetupEncode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_ZIPSetupEncode_def@
type T;
identifier F = ZIPSetupEncode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_ZIPSetupEncode_def@
F << remove_static_ZIPSetupEncode_def.F;
T << remove_static_ZIPSetupEncode_def.T;
P << remove_static_ZIPSetupEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_ZIPSetupEncode_def_void@
identifier F = ZIPSetupEncode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_ZIPSetupEncode_def_void@
F << remove_static_ZIPSetupEncode_def_void.F;
P << remove_static_ZIPSetupEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_ZIPSetupEncode_decl@
type T;
identifier F = ZIPSetupEncode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_ZIPSetupEncode_decl@
F << remove_static_ZIPSetupEncode_decl.F;
T << remove_static_ZIPSetupEncode_decl.T;
P << remove_static_ZIPSetupEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_ZIPSetupEncode_decl_void@
identifier F = ZIPSetupEncode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_ZIPSetupEncode_decl_void@
F << remove_static_ZIPSetupEncode_decl_void.F;
P << remove_static_ZIPSetupEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_ZIPSetupEncode_def@
type T;
identifier F = ZIPSetupEncode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_ZIPSetupEncode_def@
F << extract_ZIPSetupEncode_def.F;
T << extract_ZIPSetupEncode_def.T;
P << extract_ZIPSetupEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_ZIPSetupEncode_def_void@
identifier F = ZIPSetupEncode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_ZIPSetupEncode_def_void@
F << extract_ZIPSetupEncode_def_void.F;
P << extract_ZIPSetupEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_ZIPSetupEncode_decl@
type T;
identifier F = ZIPSetupEncode;
parameter list P;
@@
T F(P);

@script:python depends on extract_ZIPSetupEncode_decl@
F << extract_ZIPSetupEncode_decl.F;
T << extract_ZIPSetupEncode_decl.T;
P << extract_ZIPSetupEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_ZIPSetupEncode_decl_void@
identifier F = ZIPSetupEncode;
parameter list P;
@@
void F(P);

@script:python depends on extract_ZIPSetupEncode_decl_void@
F << extract_ZIPSetupEncode_decl_void.F;
P << extract_ZIPSetupEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: ZIPVGetField
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_ZIPVGetField_def@
type T;
identifier F = ZIPVGetField;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_ZIPVGetField_def@
F << remove_static_ZIPVGetField_def.F;
T << remove_static_ZIPVGetField_def.T;
P << remove_static_ZIPVGetField_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_ZIPVGetField_def_void@
identifier F = ZIPVGetField;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_ZIPVGetField_def_void@
F << remove_static_ZIPVGetField_def_void.F;
P << remove_static_ZIPVGetField_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_ZIPVGetField_decl@
type T;
identifier F = ZIPVGetField;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_ZIPVGetField_decl@
F << remove_static_ZIPVGetField_decl.F;
T << remove_static_ZIPVGetField_decl.T;
P << remove_static_ZIPVGetField_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_ZIPVGetField_decl_void@
identifier F = ZIPVGetField;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_ZIPVGetField_decl_void@
F << remove_static_ZIPVGetField_decl_void.F;
P << remove_static_ZIPVGetField_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_ZIPVGetField_def@
type T;
identifier F = ZIPVGetField;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_ZIPVGetField_def@
F << extract_ZIPVGetField_def.F;
T << extract_ZIPVGetField_def.T;
P << extract_ZIPVGetField_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_ZIPVGetField_def_void@
identifier F = ZIPVGetField;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_ZIPVGetField_def_void@
F << extract_ZIPVGetField_def_void.F;
P << extract_ZIPVGetField_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_ZIPVGetField_decl@
type T;
identifier F = ZIPVGetField;
parameter list P;
@@
T F(P);

@script:python depends on extract_ZIPVGetField_decl@
F << extract_ZIPVGetField_decl.F;
T << extract_ZIPVGetField_decl.T;
P << extract_ZIPVGetField_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_ZIPVGetField_decl_void@
identifier F = ZIPVGetField;
parameter list P;
@@
void F(P);

@script:python depends on extract_ZIPVGetField_decl_void@
F << extract_ZIPVGetField_decl_void.F;
P << extract_ZIPVGetField_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: ZIPVSetField
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_ZIPVSetField_def@
type T;
identifier F = ZIPVSetField;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_ZIPVSetField_def@
F << remove_static_ZIPVSetField_def.F;
T << remove_static_ZIPVSetField_def.T;
P << remove_static_ZIPVSetField_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_ZIPVSetField_def_void@
identifier F = ZIPVSetField;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_ZIPVSetField_def_void@
F << remove_static_ZIPVSetField_def_void.F;
P << remove_static_ZIPVSetField_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_ZIPVSetField_decl@
type T;
identifier F = ZIPVSetField;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_ZIPVSetField_decl@
F << remove_static_ZIPVSetField_decl.F;
T << remove_static_ZIPVSetField_decl.T;
P << remove_static_ZIPVSetField_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_ZIPVSetField_decl_void@
identifier F = ZIPVSetField;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_ZIPVSetField_decl_void@
F << remove_static_ZIPVSetField_decl_void.F;
P << remove_static_ZIPVSetField_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_ZIPVSetField_def@
type T;
identifier F = ZIPVSetField;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_ZIPVSetField_def@
F << extract_ZIPVSetField_def.F;
T << extract_ZIPVSetField_def.T;
P << extract_ZIPVSetField_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_ZIPVSetField_def_void@
identifier F = ZIPVSetField;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_ZIPVSetField_def_void@
F << extract_ZIPVSetField_def_void.F;
P << extract_ZIPVSetField_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_ZIPVSetField_decl@
type T;
identifier F = ZIPVSetField;
parameter list P;
@@
T F(P);

@script:python depends on extract_ZIPVSetField_decl@
F << extract_ZIPVSetField_decl.F;
T << extract_ZIPVSetField_decl.T;
P << extract_ZIPVSetField_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_ZIPVSetField_decl_void@
identifier F = ZIPVSetField;
parameter list P;
@@
void F(P);

@script:python depends on extract_ZIPVSetField_decl_void@
F << extract_ZIPVSetField_decl_void.F;
P << extract_ZIPVSetField_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: ZSTDCleanup
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_ZSTDCleanup_def@
type T;
identifier F = ZSTDCleanup;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_ZSTDCleanup_def@
F << remove_static_ZSTDCleanup_def.F;
T << remove_static_ZSTDCleanup_def.T;
P << remove_static_ZSTDCleanup_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_ZSTDCleanup_def_void@
identifier F = ZSTDCleanup;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_ZSTDCleanup_def_void@
F << remove_static_ZSTDCleanup_def_void.F;
P << remove_static_ZSTDCleanup_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_ZSTDCleanup_decl@
type T;
identifier F = ZSTDCleanup;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_ZSTDCleanup_decl@
F << remove_static_ZSTDCleanup_decl.F;
T << remove_static_ZSTDCleanup_decl.T;
P << remove_static_ZSTDCleanup_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_ZSTDCleanup_decl_void@
identifier F = ZSTDCleanup;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_ZSTDCleanup_decl_void@
F << remove_static_ZSTDCleanup_decl_void.F;
P << remove_static_ZSTDCleanup_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_ZSTDCleanup_def@
type T;
identifier F = ZSTDCleanup;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_ZSTDCleanup_def@
F << extract_ZSTDCleanup_def.F;
T << extract_ZSTDCleanup_def.T;
P << extract_ZSTDCleanup_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_ZSTDCleanup_def_void@
identifier F = ZSTDCleanup;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_ZSTDCleanup_def_void@
F << extract_ZSTDCleanup_def_void.F;
P << extract_ZSTDCleanup_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_ZSTDCleanup_decl@
type T;
identifier F = ZSTDCleanup;
parameter list P;
@@
T F(P);

@script:python depends on extract_ZSTDCleanup_decl@
F << extract_ZSTDCleanup_decl.F;
T << extract_ZSTDCleanup_decl.T;
P << extract_ZSTDCleanup_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_ZSTDCleanup_decl_void@
identifier F = ZSTDCleanup;
parameter list P;
@@
void F(P);

@script:python depends on extract_ZSTDCleanup_decl_void@
F << extract_ZSTDCleanup_decl_void.F;
P << extract_ZSTDCleanup_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: ZSTDDecode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_ZSTDDecode_def@
type T;
identifier F = ZSTDDecode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_ZSTDDecode_def@
F << remove_static_ZSTDDecode_def.F;
T << remove_static_ZSTDDecode_def.T;
P << remove_static_ZSTDDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_ZSTDDecode_def_void@
identifier F = ZSTDDecode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_ZSTDDecode_def_void@
F << remove_static_ZSTDDecode_def_void.F;
P << remove_static_ZSTDDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_ZSTDDecode_decl@
type T;
identifier F = ZSTDDecode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_ZSTDDecode_decl@
F << remove_static_ZSTDDecode_decl.F;
T << remove_static_ZSTDDecode_decl.T;
P << remove_static_ZSTDDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_ZSTDDecode_decl_void@
identifier F = ZSTDDecode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_ZSTDDecode_decl_void@
F << remove_static_ZSTDDecode_decl_void.F;
P << remove_static_ZSTDDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_ZSTDDecode_def@
type T;
identifier F = ZSTDDecode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_ZSTDDecode_def@
F << extract_ZSTDDecode_def.F;
T << extract_ZSTDDecode_def.T;
P << extract_ZSTDDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_ZSTDDecode_def_void@
identifier F = ZSTDDecode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_ZSTDDecode_def_void@
F << extract_ZSTDDecode_def_void.F;
P << extract_ZSTDDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_ZSTDDecode_decl@
type T;
identifier F = ZSTDDecode;
parameter list P;
@@
T F(P);

@script:python depends on extract_ZSTDDecode_decl@
F << extract_ZSTDDecode_decl.F;
T << extract_ZSTDDecode_decl.T;
P << extract_ZSTDDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_ZSTDDecode_decl_void@
identifier F = ZSTDDecode;
parameter list P;
@@
void F(P);

@script:python depends on extract_ZSTDDecode_decl_void@
F << extract_ZSTDDecode_decl_void.F;
P << extract_ZSTDDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: ZSTDEncode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_ZSTDEncode_def@
type T;
identifier F = ZSTDEncode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_ZSTDEncode_def@
F << remove_static_ZSTDEncode_def.F;
T << remove_static_ZSTDEncode_def.T;
P << remove_static_ZSTDEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_ZSTDEncode_def_void@
identifier F = ZSTDEncode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_ZSTDEncode_def_void@
F << remove_static_ZSTDEncode_def_void.F;
P << remove_static_ZSTDEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_ZSTDEncode_decl@
type T;
identifier F = ZSTDEncode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_ZSTDEncode_decl@
F << remove_static_ZSTDEncode_decl.F;
T << remove_static_ZSTDEncode_decl.T;
P << remove_static_ZSTDEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_ZSTDEncode_decl_void@
identifier F = ZSTDEncode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_ZSTDEncode_decl_void@
F << remove_static_ZSTDEncode_decl_void.F;
P << remove_static_ZSTDEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_ZSTDEncode_def@
type T;
identifier F = ZSTDEncode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_ZSTDEncode_def@
F << extract_ZSTDEncode_def.F;
T << extract_ZSTDEncode_def.T;
P << extract_ZSTDEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_ZSTDEncode_def_void@
identifier F = ZSTDEncode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_ZSTDEncode_def_void@
F << extract_ZSTDEncode_def_void.F;
P << extract_ZSTDEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_ZSTDEncode_decl@
type T;
identifier F = ZSTDEncode;
parameter list P;
@@
T F(P);

@script:python depends on extract_ZSTDEncode_decl@
F << extract_ZSTDEncode_decl.F;
T << extract_ZSTDEncode_decl.T;
P << extract_ZSTDEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_ZSTDEncode_decl_void@
identifier F = ZSTDEncode;
parameter list P;
@@
void F(P);

@script:python depends on extract_ZSTDEncode_decl_void@
F << extract_ZSTDEncode_decl_void.F;
P << extract_ZSTDEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: ZSTDFixupTags
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_ZSTDFixupTags_def@
type T;
identifier F = ZSTDFixupTags;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_ZSTDFixupTags_def@
F << remove_static_ZSTDFixupTags_def.F;
T << remove_static_ZSTDFixupTags_def.T;
P << remove_static_ZSTDFixupTags_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_ZSTDFixupTags_def_void@
identifier F = ZSTDFixupTags;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_ZSTDFixupTags_def_void@
F << remove_static_ZSTDFixupTags_def_void.F;
P << remove_static_ZSTDFixupTags_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_ZSTDFixupTags_decl@
type T;
identifier F = ZSTDFixupTags;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_ZSTDFixupTags_decl@
F << remove_static_ZSTDFixupTags_decl.F;
T << remove_static_ZSTDFixupTags_decl.T;
P << remove_static_ZSTDFixupTags_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_ZSTDFixupTags_decl_void@
identifier F = ZSTDFixupTags;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_ZSTDFixupTags_decl_void@
F << remove_static_ZSTDFixupTags_decl_void.F;
P << remove_static_ZSTDFixupTags_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_ZSTDFixupTags_def@
type T;
identifier F = ZSTDFixupTags;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_ZSTDFixupTags_def@
F << extract_ZSTDFixupTags_def.F;
T << extract_ZSTDFixupTags_def.T;
P << extract_ZSTDFixupTags_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_ZSTDFixupTags_def_void@
identifier F = ZSTDFixupTags;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_ZSTDFixupTags_def_void@
F << extract_ZSTDFixupTags_def_void.F;
P << extract_ZSTDFixupTags_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_ZSTDFixupTags_decl@
type T;
identifier F = ZSTDFixupTags;
parameter list P;
@@
T F(P);

@script:python depends on extract_ZSTDFixupTags_decl@
F << extract_ZSTDFixupTags_decl.F;
T << extract_ZSTDFixupTags_decl.T;
P << extract_ZSTDFixupTags_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_ZSTDFixupTags_decl_void@
identifier F = ZSTDFixupTags;
parameter list P;
@@
void F(P);

@script:python depends on extract_ZSTDFixupTags_decl_void@
F << extract_ZSTDFixupTags_decl_void.F;
P << extract_ZSTDFixupTags_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: ZSTDPostEncode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_ZSTDPostEncode_def@
type T;
identifier F = ZSTDPostEncode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_ZSTDPostEncode_def@
F << remove_static_ZSTDPostEncode_def.F;
T << remove_static_ZSTDPostEncode_def.T;
P << remove_static_ZSTDPostEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_ZSTDPostEncode_def_void@
identifier F = ZSTDPostEncode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_ZSTDPostEncode_def_void@
F << remove_static_ZSTDPostEncode_def_void.F;
P << remove_static_ZSTDPostEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_ZSTDPostEncode_decl@
type T;
identifier F = ZSTDPostEncode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_ZSTDPostEncode_decl@
F << remove_static_ZSTDPostEncode_decl.F;
T << remove_static_ZSTDPostEncode_decl.T;
P << remove_static_ZSTDPostEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_ZSTDPostEncode_decl_void@
identifier F = ZSTDPostEncode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_ZSTDPostEncode_decl_void@
F << remove_static_ZSTDPostEncode_decl_void.F;
P << remove_static_ZSTDPostEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_ZSTDPostEncode_def@
type T;
identifier F = ZSTDPostEncode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_ZSTDPostEncode_def@
F << extract_ZSTDPostEncode_def.F;
T << extract_ZSTDPostEncode_def.T;
P << extract_ZSTDPostEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_ZSTDPostEncode_def_void@
identifier F = ZSTDPostEncode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_ZSTDPostEncode_def_void@
F << extract_ZSTDPostEncode_def_void.F;
P << extract_ZSTDPostEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_ZSTDPostEncode_decl@
type T;
identifier F = ZSTDPostEncode;
parameter list P;
@@
T F(P);

@script:python depends on extract_ZSTDPostEncode_decl@
F << extract_ZSTDPostEncode_decl.F;
T << extract_ZSTDPostEncode_decl.T;
P << extract_ZSTDPostEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_ZSTDPostEncode_decl_void@
identifier F = ZSTDPostEncode;
parameter list P;
@@
void F(P);

@script:python depends on extract_ZSTDPostEncode_decl_void@
F << extract_ZSTDPostEncode_decl_void.F;
P << extract_ZSTDPostEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: ZSTDPreDecode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_ZSTDPreDecode_def@
type T;
identifier F = ZSTDPreDecode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_ZSTDPreDecode_def@
F << remove_static_ZSTDPreDecode_def.F;
T << remove_static_ZSTDPreDecode_def.T;
P << remove_static_ZSTDPreDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_ZSTDPreDecode_def_void@
identifier F = ZSTDPreDecode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_ZSTDPreDecode_def_void@
F << remove_static_ZSTDPreDecode_def_void.F;
P << remove_static_ZSTDPreDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_ZSTDPreDecode_decl@
type T;
identifier F = ZSTDPreDecode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_ZSTDPreDecode_decl@
F << remove_static_ZSTDPreDecode_decl.F;
T << remove_static_ZSTDPreDecode_decl.T;
P << remove_static_ZSTDPreDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_ZSTDPreDecode_decl_void@
identifier F = ZSTDPreDecode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_ZSTDPreDecode_decl_void@
F << remove_static_ZSTDPreDecode_decl_void.F;
P << remove_static_ZSTDPreDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_ZSTDPreDecode_def@
type T;
identifier F = ZSTDPreDecode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_ZSTDPreDecode_def@
F << extract_ZSTDPreDecode_def.F;
T << extract_ZSTDPreDecode_def.T;
P << extract_ZSTDPreDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_ZSTDPreDecode_def_void@
identifier F = ZSTDPreDecode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_ZSTDPreDecode_def_void@
F << extract_ZSTDPreDecode_def_void.F;
P << extract_ZSTDPreDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_ZSTDPreDecode_decl@
type T;
identifier F = ZSTDPreDecode;
parameter list P;
@@
T F(P);

@script:python depends on extract_ZSTDPreDecode_decl@
F << extract_ZSTDPreDecode_decl.F;
T << extract_ZSTDPreDecode_decl.T;
P << extract_ZSTDPreDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_ZSTDPreDecode_decl_void@
identifier F = ZSTDPreDecode;
parameter list P;
@@
void F(P);

@script:python depends on extract_ZSTDPreDecode_decl_void@
F << extract_ZSTDPreDecode_decl_void.F;
P << extract_ZSTDPreDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: ZSTDPreEncode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_ZSTDPreEncode_def@
type T;
identifier F = ZSTDPreEncode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_ZSTDPreEncode_def@
F << remove_static_ZSTDPreEncode_def.F;
T << remove_static_ZSTDPreEncode_def.T;
P << remove_static_ZSTDPreEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_ZSTDPreEncode_def_void@
identifier F = ZSTDPreEncode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_ZSTDPreEncode_def_void@
F << remove_static_ZSTDPreEncode_def_void.F;
P << remove_static_ZSTDPreEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_ZSTDPreEncode_decl@
type T;
identifier F = ZSTDPreEncode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_ZSTDPreEncode_decl@
F << remove_static_ZSTDPreEncode_decl.F;
T << remove_static_ZSTDPreEncode_decl.T;
P << remove_static_ZSTDPreEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_ZSTDPreEncode_decl_void@
identifier F = ZSTDPreEncode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_ZSTDPreEncode_decl_void@
F << remove_static_ZSTDPreEncode_decl_void.F;
P << remove_static_ZSTDPreEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_ZSTDPreEncode_def@
type T;
identifier F = ZSTDPreEncode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_ZSTDPreEncode_def@
F << extract_ZSTDPreEncode_def.F;
T << extract_ZSTDPreEncode_def.T;
P << extract_ZSTDPreEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_ZSTDPreEncode_def_void@
identifier F = ZSTDPreEncode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_ZSTDPreEncode_def_void@
F << extract_ZSTDPreEncode_def_void.F;
P << extract_ZSTDPreEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_ZSTDPreEncode_decl@
type T;
identifier F = ZSTDPreEncode;
parameter list P;
@@
T F(P);

@script:python depends on extract_ZSTDPreEncode_decl@
F << extract_ZSTDPreEncode_decl.F;
T << extract_ZSTDPreEncode_decl.T;
P << extract_ZSTDPreEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_ZSTDPreEncode_decl_void@
identifier F = ZSTDPreEncode;
parameter list P;
@@
void F(P);

@script:python depends on extract_ZSTDPreEncode_decl_void@
F << extract_ZSTDPreEncode_decl_void.F;
P << extract_ZSTDPreEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: ZSTDSetupDecode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_ZSTDSetupDecode_def@
type T;
identifier F = ZSTDSetupDecode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_ZSTDSetupDecode_def@
F << remove_static_ZSTDSetupDecode_def.F;
T << remove_static_ZSTDSetupDecode_def.T;
P << remove_static_ZSTDSetupDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_ZSTDSetupDecode_def_void@
identifier F = ZSTDSetupDecode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_ZSTDSetupDecode_def_void@
F << remove_static_ZSTDSetupDecode_def_void.F;
P << remove_static_ZSTDSetupDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_ZSTDSetupDecode_decl@
type T;
identifier F = ZSTDSetupDecode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_ZSTDSetupDecode_decl@
F << remove_static_ZSTDSetupDecode_decl.F;
T << remove_static_ZSTDSetupDecode_decl.T;
P << remove_static_ZSTDSetupDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_ZSTDSetupDecode_decl_void@
identifier F = ZSTDSetupDecode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_ZSTDSetupDecode_decl_void@
F << remove_static_ZSTDSetupDecode_decl_void.F;
P << remove_static_ZSTDSetupDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_ZSTDSetupDecode_def@
type T;
identifier F = ZSTDSetupDecode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_ZSTDSetupDecode_def@
F << extract_ZSTDSetupDecode_def.F;
T << extract_ZSTDSetupDecode_def.T;
P << extract_ZSTDSetupDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_ZSTDSetupDecode_def_void@
identifier F = ZSTDSetupDecode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_ZSTDSetupDecode_def_void@
F << extract_ZSTDSetupDecode_def_void.F;
P << extract_ZSTDSetupDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_ZSTDSetupDecode_decl@
type T;
identifier F = ZSTDSetupDecode;
parameter list P;
@@
T F(P);

@script:python depends on extract_ZSTDSetupDecode_decl@
F << extract_ZSTDSetupDecode_decl.F;
T << extract_ZSTDSetupDecode_decl.T;
P << extract_ZSTDSetupDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_ZSTDSetupDecode_decl_void@
identifier F = ZSTDSetupDecode;
parameter list P;
@@
void F(P);

@script:python depends on extract_ZSTDSetupDecode_decl_void@
F << extract_ZSTDSetupDecode_decl_void.F;
P << extract_ZSTDSetupDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: ZSTDSetupEncode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_ZSTDSetupEncode_def@
type T;
identifier F = ZSTDSetupEncode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_ZSTDSetupEncode_def@
F << remove_static_ZSTDSetupEncode_def.F;
T << remove_static_ZSTDSetupEncode_def.T;
P << remove_static_ZSTDSetupEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_ZSTDSetupEncode_def_void@
identifier F = ZSTDSetupEncode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_ZSTDSetupEncode_def_void@
F << remove_static_ZSTDSetupEncode_def_void.F;
P << remove_static_ZSTDSetupEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_ZSTDSetupEncode_decl@
type T;
identifier F = ZSTDSetupEncode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_ZSTDSetupEncode_decl@
F << remove_static_ZSTDSetupEncode_decl.F;
T << remove_static_ZSTDSetupEncode_decl.T;
P << remove_static_ZSTDSetupEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_ZSTDSetupEncode_decl_void@
identifier F = ZSTDSetupEncode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_ZSTDSetupEncode_decl_void@
F << remove_static_ZSTDSetupEncode_decl_void.F;
P << remove_static_ZSTDSetupEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_ZSTDSetupEncode_def@
type T;
identifier F = ZSTDSetupEncode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_ZSTDSetupEncode_def@
F << extract_ZSTDSetupEncode_def.F;
T << extract_ZSTDSetupEncode_def.T;
P << extract_ZSTDSetupEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_ZSTDSetupEncode_def_void@
identifier F = ZSTDSetupEncode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_ZSTDSetupEncode_def_void@
F << extract_ZSTDSetupEncode_def_void.F;
P << extract_ZSTDSetupEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_ZSTDSetupEncode_decl@
type T;
identifier F = ZSTDSetupEncode;
parameter list P;
@@
T F(P);

@script:python depends on extract_ZSTDSetupEncode_decl@
F << extract_ZSTDSetupEncode_decl.F;
T << extract_ZSTDSetupEncode_decl.T;
P << extract_ZSTDSetupEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_ZSTDSetupEncode_decl_void@
identifier F = ZSTDSetupEncode;
parameter list P;
@@
void F(P);

@script:python depends on extract_ZSTDSetupEncode_decl_void@
F << extract_ZSTDSetupEncode_decl_void.F;
P << extract_ZSTDSetupEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: ZSTDVGetField
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_ZSTDVGetField_def@
type T;
identifier F = ZSTDVGetField;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_ZSTDVGetField_def@
F << remove_static_ZSTDVGetField_def.F;
T << remove_static_ZSTDVGetField_def.T;
P << remove_static_ZSTDVGetField_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_ZSTDVGetField_def_void@
identifier F = ZSTDVGetField;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_ZSTDVGetField_def_void@
F << remove_static_ZSTDVGetField_def_void.F;
P << remove_static_ZSTDVGetField_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_ZSTDVGetField_decl@
type T;
identifier F = ZSTDVGetField;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_ZSTDVGetField_decl@
F << remove_static_ZSTDVGetField_decl.F;
T << remove_static_ZSTDVGetField_decl.T;
P << remove_static_ZSTDVGetField_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_ZSTDVGetField_decl_void@
identifier F = ZSTDVGetField;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_ZSTDVGetField_decl_void@
F << remove_static_ZSTDVGetField_decl_void.F;
P << remove_static_ZSTDVGetField_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_ZSTDVGetField_def@
type T;
identifier F = ZSTDVGetField;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_ZSTDVGetField_def@
F << extract_ZSTDVGetField_def.F;
T << extract_ZSTDVGetField_def.T;
P << extract_ZSTDVGetField_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_ZSTDVGetField_def_void@
identifier F = ZSTDVGetField;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_ZSTDVGetField_def_void@
F << extract_ZSTDVGetField_def_void.F;
P << extract_ZSTDVGetField_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_ZSTDVGetField_decl@
type T;
identifier F = ZSTDVGetField;
parameter list P;
@@
T F(P);

@script:python depends on extract_ZSTDVGetField_decl@
F << extract_ZSTDVGetField_decl.F;
T << extract_ZSTDVGetField_decl.T;
P << extract_ZSTDVGetField_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_ZSTDVGetField_decl_void@
identifier F = ZSTDVGetField;
parameter list P;
@@
void F(P);

@script:python depends on extract_ZSTDVGetField_decl_void@
F << extract_ZSTDVGetField_decl_void.F;
P << extract_ZSTDVGetField_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: ZSTDVSetField
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_ZSTDVSetField_def@
type T;
identifier F = ZSTDVSetField;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_ZSTDVSetField_def@
F << remove_static_ZSTDVSetField_def.F;
T << remove_static_ZSTDVSetField_def.T;
P << remove_static_ZSTDVSetField_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_ZSTDVSetField_def_void@
identifier F = ZSTDVSetField;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_ZSTDVSetField_def_void@
F << remove_static_ZSTDVSetField_def_void.F;
P << remove_static_ZSTDVSetField_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_ZSTDVSetField_decl@
type T;
identifier F = ZSTDVSetField;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_ZSTDVSetField_decl@
F << remove_static_ZSTDVSetField_decl.F;
T << remove_static_ZSTDVSetField_decl.T;
P << remove_static_ZSTDVSetField_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_ZSTDVSetField_decl_void@
identifier F = ZSTDVSetField;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_ZSTDVSetField_decl_void@
F << remove_static_ZSTDVSetField_decl_void.F;
P << remove_static_ZSTDVSetField_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_ZSTDVSetField_def@
type T;
identifier F = ZSTDVSetField;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_ZSTDVSetField_def@
F << extract_ZSTDVSetField_def.F;
T << extract_ZSTDVSetField_def.T;
P << extract_ZSTDVSetField_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_ZSTDVSetField_def_void@
identifier F = ZSTDVSetField;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_ZSTDVSetField_def_void@
F << extract_ZSTDVSetField_def_void.F;
P << extract_ZSTDVSetField_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_ZSTDVSetField_decl@
type T;
identifier F = ZSTDVSetField;
parameter list P;
@@
T F(P);

@script:python depends on extract_ZSTDVSetField_decl@
F << extract_ZSTDVSetField_decl.F;
T << extract_ZSTDVSetField_decl.T;
P << extract_ZSTDVSetField_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_ZSTDVSetField_decl_void@
identifier F = ZSTDVSetField;
parameter list P;
@@
void F(P);

@script:python depends on extract_ZSTDVSetField_decl_void@
F << extract_ZSTDVSetField_decl_void.F;
P << extract_ZSTDVSetField_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: _TIFFDefaultStripSize
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static__TIFFDefaultStripSize_def@
type T;
identifier F = _TIFFDefaultStripSize;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static__TIFFDefaultStripSize_def@
F << remove_static__TIFFDefaultStripSize_def.F;
T << remove_static__TIFFDefaultStripSize_def.T;
P << remove_static__TIFFDefaultStripSize_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static__TIFFDefaultStripSize_def_void@
identifier F = _TIFFDefaultStripSize;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static__TIFFDefaultStripSize_def_void@
F << remove_static__TIFFDefaultStripSize_def_void.F;
P << remove_static__TIFFDefaultStripSize_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static__TIFFDefaultStripSize_decl@
type T;
identifier F = _TIFFDefaultStripSize;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static__TIFFDefaultStripSize_decl@
F << remove_static__TIFFDefaultStripSize_decl.F;
T << remove_static__TIFFDefaultStripSize_decl.T;
P << remove_static__TIFFDefaultStripSize_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static__TIFFDefaultStripSize_decl_void@
identifier F = _TIFFDefaultStripSize;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static__TIFFDefaultStripSize_decl_void@
F << remove_static__TIFFDefaultStripSize_decl_void.F;
P << remove_static__TIFFDefaultStripSize_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract__TIFFDefaultStripSize_def@
type T;
identifier F = _TIFFDefaultStripSize;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract__TIFFDefaultStripSize_def@
F << extract__TIFFDefaultStripSize_def.F;
T << extract__TIFFDefaultStripSize_def.T;
P << extract__TIFFDefaultStripSize_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract__TIFFDefaultStripSize_def_void@
identifier F = _TIFFDefaultStripSize;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract__TIFFDefaultStripSize_def_void@
F << extract__TIFFDefaultStripSize_def_void.F;
P << extract__TIFFDefaultStripSize_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract__TIFFDefaultStripSize_decl@
type T;
identifier F = _TIFFDefaultStripSize;
parameter list P;
@@
T F(P);

@script:python depends on extract__TIFFDefaultStripSize_decl@
F << extract__TIFFDefaultStripSize_decl.F;
T << extract__TIFFDefaultStripSize_decl.T;
P << extract__TIFFDefaultStripSize_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract__TIFFDefaultStripSize_decl_void@
identifier F = _TIFFDefaultStripSize;
parameter list P;
@@
void F(P);

@script:python depends on extract__TIFFDefaultStripSize_decl_void@
F << extract__TIFFDefaultStripSize_decl_void.F;
P << extract__TIFFDefaultStripSize_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: _TIFFDefaultTileSize
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static__TIFFDefaultTileSize_def@
type T;
identifier F = _TIFFDefaultTileSize;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static__TIFFDefaultTileSize_def@
F << remove_static__TIFFDefaultTileSize_def.F;
T << remove_static__TIFFDefaultTileSize_def.T;
P << remove_static__TIFFDefaultTileSize_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static__TIFFDefaultTileSize_def_void@
identifier F = _TIFFDefaultTileSize;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static__TIFFDefaultTileSize_def_void@
F << remove_static__TIFFDefaultTileSize_def_void.F;
P << remove_static__TIFFDefaultTileSize_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static__TIFFDefaultTileSize_decl@
type T;
identifier F = _TIFFDefaultTileSize;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static__TIFFDefaultTileSize_decl@
F << remove_static__TIFFDefaultTileSize_decl.F;
T << remove_static__TIFFDefaultTileSize_decl.T;
P << remove_static__TIFFDefaultTileSize_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static__TIFFDefaultTileSize_decl_void@
identifier F = _TIFFDefaultTileSize;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static__TIFFDefaultTileSize_decl_void@
F << remove_static__TIFFDefaultTileSize_decl_void.F;
P << remove_static__TIFFDefaultTileSize_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract__TIFFDefaultTileSize_def@
type T;
identifier F = _TIFFDefaultTileSize;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract__TIFFDefaultTileSize_def@
F << extract__TIFFDefaultTileSize_def.F;
T << extract__TIFFDefaultTileSize_def.T;
P << extract__TIFFDefaultTileSize_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract__TIFFDefaultTileSize_def_void@
identifier F = _TIFFDefaultTileSize;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract__TIFFDefaultTileSize_def_void@
F << extract__TIFFDefaultTileSize_def_void.F;
P << extract__TIFFDefaultTileSize_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract__TIFFDefaultTileSize_decl@
type T;
identifier F = _TIFFDefaultTileSize;
parameter list P;
@@
T F(P);

@script:python depends on extract__TIFFDefaultTileSize_decl@
F << extract__TIFFDefaultTileSize_decl.F;
T << extract__TIFFDefaultTileSize_decl.T;
P << extract__TIFFDefaultTileSize_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract__TIFFDefaultTileSize_decl_void@
identifier F = _TIFFDefaultTileSize;
parameter list P;
@@
void F(P);

@script:python depends on extract__TIFFDefaultTileSize_decl_void@
F << extract__TIFFDefaultTileSize_decl_void.F;
P << extract__TIFFDefaultTileSize_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: _TIFFNoFixupTags
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static__TIFFNoFixupTags_def@
type T;
identifier F = _TIFFNoFixupTags;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static__TIFFNoFixupTags_def@
F << remove_static__TIFFNoFixupTags_def.F;
T << remove_static__TIFFNoFixupTags_def.T;
P << remove_static__TIFFNoFixupTags_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static__TIFFNoFixupTags_def_void@
identifier F = _TIFFNoFixupTags;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static__TIFFNoFixupTags_def_void@
F << remove_static__TIFFNoFixupTags_def_void.F;
P << remove_static__TIFFNoFixupTags_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static__TIFFNoFixupTags_decl@
type T;
identifier F = _TIFFNoFixupTags;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static__TIFFNoFixupTags_decl@
F << remove_static__TIFFNoFixupTags_decl.F;
T << remove_static__TIFFNoFixupTags_decl.T;
P << remove_static__TIFFNoFixupTags_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static__TIFFNoFixupTags_decl_void@
identifier F = _TIFFNoFixupTags;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static__TIFFNoFixupTags_decl_void@
F << remove_static__TIFFNoFixupTags_decl_void.F;
P << remove_static__TIFFNoFixupTags_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract__TIFFNoFixupTags_def@
type T;
identifier F = _TIFFNoFixupTags;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract__TIFFNoFixupTags_def@
F << extract__TIFFNoFixupTags_def.F;
T << extract__TIFFNoFixupTags_def.T;
P << extract__TIFFNoFixupTags_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract__TIFFNoFixupTags_def_void@
identifier F = _TIFFNoFixupTags;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract__TIFFNoFixupTags_def_void@
F << extract__TIFFNoFixupTags_def_void.F;
P << extract__TIFFNoFixupTags_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract__TIFFNoFixupTags_decl@
type T;
identifier F = _TIFFNoFixupTags;
parameter list P;
@@
T F(P);

@script:python depends on extract__TIFFNoFixupTags_decl@
F << extract__TIFFNoFixupTags_decl.F;
T << extract__TIFFNoFixupTags_decl.T;
P << extract__TIFFNoFixupTags_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract__TIFFNoFixupTags_decl_void@
identifier F = _TIFFNoFixupTags;
parameter list P;
@@
void F(P);

@script:python depends on extract__TIFFNoFixupTags_decl_void@
F << extract__TIFFNoFixupTags_decl_void.F;
P << extract__TIFFNoFixupTags_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: _TIFFNoPostDecode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static__TIFFNoPostDecode_def@
type T;
identifier F = _TIFFNoPostDecode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static__TIFFNoPostDecode_def@
F << remove_static__TIFFNoPostDecode_def.F;
T << remove_static__TIFFNoPostDecode_def.T;
P << remove_static__TIFFNoPostDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static__TIFFNoPostDecode_def_void@
identifier F = _TIFFNoPostDecode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static__TIFFNoPostDecode_def_void@
F << remove_static__TIFFNoPostDecode_def_void.F;
P << remove_static__TIFFNoPostDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static__TIFFNoPostDecode_decl@
type T;
identifier F = _TIFFNoPostDecode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static__TIFFNoPostDecode_decl@
F << remove_static__TIFFNoPostDecode_decl.F;
T << remove_static__TIFFNoPostDecode_decl.T;
P << remove_static__TIFFNoPostDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static__TIFFNoPostDecode_decl_void@
identifier F = _TIFFNoPostDecode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static__TIFFNoPostDecode_decl_void@
F << remove_static__TIFFNoPostDecode_decl_void.F;
P << remove_static__TIFFNoPostDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract__TIFFNoPostDecode_def@
type T;
identifier F = _TIFFNoPostDecode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract__TIFFNoPostDecode_def@
F << extract__TIFFNoPostDecode_def.F;
T << extract__TIFFNoPostDecode_def.T;
P << extract__TIFFNoPostDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract__TIFFNoPostDecode_def_void@
identifier F = _TIFFNoPostDecode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract__TIFFNoPostDecode_def_void@
F << extract__TIFFNoPostDecode_def_void.F;
P << extract__TIFFNoPostDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract__TIFFNoPostDecode_decl@
type T;
identifier F = _TIFFNoPostDecode;
parameter list P;
@@
T F(P);

@script:python depends on extract__TIFFNoPostDecode_decl@
F << extract__TIFFNoPostDecode_decl.F;
T << extract__TIFFNoPostDecode_decl.T;
P << extract__TIFFNoPostDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract__TIFFNoPostDecode_decl_void@
identifier F = _TIFFNoPostDecode;
parameter list P;
@@
void F(P);

@script:python depends on extract__TIFFNoPostDecode_decl_void@
F << extract__TIFFNoPostDecode_decl_void.F;
P << extract__TIFFNoPostDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: _TIFFNoPreCode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static__TIFFNoPreCode_def@
type T;
identifier F = _TIFFNoPreCode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static__TIFFNoPreCode_def@
F << remove_static__TIFFNoPreCode_def.F;
T << remove_static__TIFFNoPreCode_def.T;
P << remove_static__TIFFNoPreCode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static__TIFFNoPreCode_def_void@
identifier F = _TIFFNoPreCode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static__TIFFNoPreCode_def_void@
F << remove_static__TIFFNoPreCode_def_void.F;
P << remove_static__TIFFNoPreCode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static__TIFFNoPreCode_decl@
type T;
identifier F = _TIFFNoPreCode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static__TIFFNoPreCode_decl@
F << remove_static__TIFFNoPreCode_decl.F;
T << remove_static__TIFFNoPreCode_decl.T;
P << remove_static__TIFFNoPreCode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static__TIFFNoPreCode_decl_void@
identifier F = _TIFFNoPreCode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static__TIFFNoPreCode_decl_void@
F << remove_static__TIFFNoPreCode_decl_void.F;
P << remove_static__TIFFNoPreCode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract__TIFFNoPreCode_def@
type T;
identifier F = _TIFFNoPreCode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract__TIFFNoPreCode_def@
F << extract__TIFFNoPreCode_def.F;
T << extract__TIFFNoPreCode_def.T;
P << extract__TIFFNoPreCode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract__TIFFNoPreCode_def_void@
identifier F = _TIFFNoPreCode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract__TIFFNoPreCode_def_void@
F << extract__TIFFNoPreCode_def_void.F;
P << extract__TIFFNoPreCode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract__TIFFNoPreCode_decl@
type T;
identifier F = _TIFFNoPreCode;
parameter list P;
@@
T F(P);

@script:python depends on extract__TIFFNoPreCode_decl@
F << extract__TIFFNoPreCode_decl.F;
T << extract__TIFFNoPreCode_decl.T;
P << extract__TIFFNoPreCode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract__TIFFNoPreCode_decl_void@
identifier F = _TIFFNoPreCode;
parameter list P;
@@
void F(P);

@script:python depends on extract__TIFFNoPreCode_decl_void@
F << extract__TIFFNoPreCode_decl_void.F;
P << extract__TIFFNoPreCode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: _TIFFNoRowDecode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static__TIFFNoRowDecode_def@
type T;
identifier F = _TIFFNoRowDecode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static__TIFFNoRowDecode_def@
F << remove_static__TIFFNoRowDecode_def.F;
T << remove_static__TIFFNoRowDecode_def.T;
P << remove_static__TIFFNoRowDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static__TIFFNoRowDecode_def_void@
identifier F = _TIFFNoRowDecode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static__TIFFNoRowDecode_def_void@
F << remove_static__TIFFNoRowDecode_def_void.F;
P << remove_static__TIFFNoRowDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static__TIFFNoRowDecode_decl@
type T;
identifier F = _TIFFNoRowDecode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static__TIFFNoRowDecode_decl@
F << remove_static__TIFFNoRowDecode_decl.F;
T << remove_static__TIFFNoRowDecode_decl.T;
P << remove_static__TIFFNoRowDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static__TIFFNoRowDecode_decl_void@
identifier F = _TIFFNoRowDecode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static__TIFFNoRowDecode_decl_void@
F << remove_static__TIFFNoRowDecode_decl_void.F;
P << remove_static__TIFFNoRowDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract__TIFFNoRowDecode_def@
type T;
identifier F = _TIFFNoRowDecode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract__TIFFNoRowDecode_def@
F << extract__TIFFNoRowDecode_def.F;
T << extract__TIFFNoRowDecode_def.T;
P << extract__TIFFNoRowDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract__TIFFNoRowDecode_def_void@
identifier F = _TIFFNoRowDecode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract__TIFFNoRowDecode_def_void@
F << extract__TIFFNoRowDecode_def_void.F;
P << extract__TIFFNoRowDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract__TIFFNoRowDecode_decl@
type T;
identifier F = _TIFFNoRowDecode;
parameter list P;
@@
T F(P);

@script:python depends on extract__TIFFNoRowDecode_decl@
F << extract__TIFFNoRowDecode_decl.F;
T << extract__TIFFNoRowDecode_decl.T;
P << extract__TIFFNoRowDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract__TIFFNoRowDecode_decl_void@
identifier F = _TIFFNoRowDecode;
parameter list P;
@@
void F(P);

@script:python depends on extract__TIFFNoRowDecode_decl_void@
F << extract__TIFFNoRowDecode_decl_void.F;
P << extract__TIFFNoRowDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: _TIFFNoRowEncode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static__TIFFNoRowEncode_def@
type T;
identifier F = _TIFFNoRowEncode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static__TIFFNoRowEncode_def@
F << remove_static__TIFFNoRowEncode_def.F;
T << remove_static__TIFFNoRowEncode_def.T;
P << remove_static__TIFFNoRowEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static__TIFFNoRowEncode_def_void@
identifier F = _TIFFNoRowEncode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static__TIFFNoRowEncode_def_void@
F << remove_static__TIFFNoRowEncode_def_void.F;
P << remove_static__TIFFNoRowEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static__TIFFNoRowEncode_decl@
type T;
identifier F = _TIFFNoRowEncode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static__TIFFNoRowEncode_decl@
F << remove_static__TIFFNoRowEncode_decl.F;
T << remove_static__TIFFNoRowEncode_decl.T;
P << remove_static__TIFFNoRowEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static__TIFFNoRowEncode_decl_void@
identifier F = _TIFFNoRowEncode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static__TIFFNoRowEncode_decl_void@
F << remove_static__TIFFNoRowEncode_decl_void.F;
P << remove_static__TIFFNoRowEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract__TIFFNoRowEncode_def@
type T;
identifier F = _TIFFNoRowEncode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract__TIFFNoRowEncode_def@
F << extract__TIFFNoRowEncode_def.F;
T << extract__TIFFNoRowEncode_def.T;
P << extract__TIFFNoRowEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract__TIFFNoRowEncode_def_void@
identifier F = _TIFFNoRowEncode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract__TIFFNoRowEncode_def_void@
F << extract__TIFFNoRowEncode_def_void.F;
P << extract__TIFFNoRowEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract__TIFFNoRowEncode_decl@
type T;
identifier F = _TIFFNoRowEncode;
parameter list P;
@@
T F(P);

@script:python depends on extract__TIFFNoRowEncode_decl@
F << extract__TIFFNoRowEncode_decl.F;
T << extract__TIFFNoRowEncode_decl.T;
P << extract__TIFFNoRowEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract__TIFFNoRowEncode_decl_void@
identifier F = _TIFFNoRowEncode;
parameter list P;
@@
void F(P);

@script:python depends on extract__TIFFNoRowEncode_decl_void@
F << extract__TIFFNoRowEncode_decl_void.F;
P << extract__TIFFNoRowEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: _TIFFNoSeek
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static__TIFFNoSeek_def@
type T;
identifier F = _TIFFNoSeek;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static__TIFFNoSeek_def@
F << remove_static__TIFFNoSeek_def.F;
T << remove_static__TIFFNoSeek_def.T;
P << remove_static__TIFFNoSeek_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static__TIFFNoSeek_def_void@
identifier F = _TIFFNoSeek;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static__TIFFNoSeek_def_void@
F << remove_static__TIFFNoSeek_def_void.F;
P << remove_static__TIFFNoSeek_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static__TIFFNoSeek_decl@
type T;
identifier F = _TIFFNoSeek;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static__TIFFNoSeek_decl@
F << remove_static__TIFFNoSeek_decl.F;
T << remove_static__TIFFNoSeek_decl.T;
P << remove_static__TIFFNoSeek_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static__TIFFNoSeek_decl_void@
identifier F = _TIFFNoSeek;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static__TIFFNoSeek_decl_void@
F << remove_static__TIFFNoSeek_decl_void.F;
P << remove_static__TIFFNoSeek_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract__TIFFNoSeek_def@
type T;
identifier F = _TIFFNoSeek;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract__TIFFNoSeek_def@
F << extract__TIFFNoSeek_def.F;
T << extract__TIFFNoSeek_def.T;
P << extract__TIFFNoSeek_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract__TIFFNoSeek_def_void@
identifier F = _TIFFNoSeek;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract__TIFFNoSeek_def_void@
F << extract__TIFFNoSeek_def_void.F;
P << extract__TIFFNoSeek_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract__TIFFNoSeek_decl@
type T;
identifier F = _TIFFNoSeek;
parameter list P;
@@
T F(P);

@script:python depends on extract__TIFFNoSeek_decl@
F << extract__TIFFNoSeek_decl.F;
T << extract__TIFFNoSeek_decl.T;
P << extract__TIFFNoSeek_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract__TIFFNoSeek_decl_void@
identifier F = _TIFFNoSeek;
parameter list P;
@@
void F(P);

@script:python depends on extract__TIFFNoSeek_decl_void@
F << extract__TIFFNoSeek_decl_void.F;
P << extract__TIFFNoSeek_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: _TIFFNoStripDecode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static__TIFFNoStripDecode_def@
type T;
identifier F = _TIFFNoStripDecode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static__TIFFNoStripDecode_def@
F << remove_static__TIFFNoStripDecode_def.F;
T << remove_static__TIFFNoStripDecode_def.T;
P << remove_static__TIFFNoStripDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static__TIFFNoStripDecode_def_void@
identifier F = _TIFFNoStripDecode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static__TIFFNoStripDecode_def_void@
F << remove_static__TIFFNoStripDecode_def_void.F;
P << remove_static__TIFFNoStripDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static__TIFFNoStripDecode_decl@
type T;
identifier F = _TIFFNoStripDecode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static__TIFFNoStripDecode_decl@
F << remove_static__TIFFNoStripDecode_decl.F;
T << remove_static__TIFFNoStripDecode_decl.T;
P << remove_static__TIFFNoStripDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static__TIFFNoStripDecode_decl_void@
identifier F = _TIFFNoStripDecode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static__TIFFNoStripDecode_decl_void@
F << remove_static__TIFFNoStripDecode_decl_void.F;
P << remove_static__TIFFNoStripDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract__TIFFNoStripDecode_def@
type T;
identifier F = _TIFFNoStripDecode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract__TIFFNoStripDecode_def@
F << extract__TIFFNoStripDecode_def.F;
T << extract__TIFFNoStripDecode_def.T;
P << extract__TIFFNoStripDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract__TIFFNoStripDecode_def_void@
identifier F = _TIFFNoStripDecode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract__TIFFNoStripDecode_def_void@
F << extract__TIFFNoStripDecode_def_void.F;
P << extract__TIFFNoStripDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract__TIFFNoStripDecode_decl@
type T;
identifier F = _TIFFNoStripDecode;
parameter list P;
@@
T F(P);

@script:python depends on extract__TIFFNoStripDecode_decl@
F << extract__TIFFNoStripDecode_decl.F;
T << extract__TIFFNoStripDecode_decl.T;
P << extract__TIFFNoStripDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract__TIFFNoStripDecode_decl_void@
identifier F = _TIFFNoStripDecode;
parameter list P;
@@
void F(P);

@script:python depends on extract__TIFFNoStripDecode_decl_void@
F << extract__TIFFNoStripDecode_decl_void.F;
P << extract__TIFFNoStripDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: _TIFFNoStripEncode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static__TIFFNoStripEncode_def@
type T;
identifier F = _TIFFNoStripEncode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static__TIFFNoStripEncode_def@
F << remove_static__TIFFNoStripEncode_def.F;
T << remove_static__TIFFNoStripEncode_def.T;
P << remove_static__TIFFNoStripEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static__TIFFNoStripEncode_def_void@
identifier F = _TIFFNoStripEncode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static__TIFFNoStripEncode_def_void@
F << remove_static__TIFFNoStripEncode_def_void.F;
P << remove_static__TIFFNoStripEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static__TIFFNoStripEncode_decl@
type T;
identifier F = _TIFFNoStripEncode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static__TIFFNoStripEncode_decl@
F << remove_static__TIFFNoStripEncode_decl.F;
T << remove_static__TIFFNoStripEncode_decl.T;
P << remove_static__TIFFNoStripEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static__TIFFNoStripEncode_decl_void@
identifier F = _TIFFNoStripEncode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static__TIFFNoStripEncode_decl_void@
F << remove_static__TIFFNoStripEncode_decl_void.F;
P << remove_static__TIFFNoStripEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract__TIFFNoStripEncode_def@
type T;
identifier F = _TIFFNoStripEncode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract__TIFFNoStripEncode_def@
F << extract__TIFFNoStripEncode_def.F;
T << extract__TIFFNoStripEncode_def.T;
P << extract__TIFFNoStripEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract__TIFFNoStripEncode_def_void@
identifier F = _TIFFNoStripEncode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract__TIFFNoStripEncode_def_void@
F << extract__TIFFNoStripEncode_def_void.F;
P << extract__TIFFNoStripEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract__TIFFNoStripEncode_decl@
type T;
identifier F = _TIFFNoStripEncode;
parameter list P;
@@
T F(P);

@script:python depends on extract__TIFFNoStripEncode_decl@
F << extract__TIFFNoStripEncode_decl.F;
T << extract__TIFFNoStripEncode_decl.T;
P << extract__TIFFNoStripEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract__TIFFNoStripEncode_decl_void@
identifier F = _TIFFNoStripEncode;
parameter list P;
@@
void F(P);

@script:python depends on extract__TIFFNoStripEncode_decl_void@
F << extract__TIFFNoStripEncode_decl_void.F;
P << extract__TIFFNoStripEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: _TIFFNoTileDecode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static__TIFFNoTileDecode_def@
type T;
identifier F = _TIFFNoTileDecode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static__TIFFNoTileDecode_def@
F << remove_static__TIFFNoTileDecode_def.F;
T << remove_static__TIFFNoTileDecode_def.T;
P << remove_static__TIFFNoTileDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static__TIFFNoTileDecode_def_void@
identifier F = _TIFFNoTileDecode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static__TIFFNoTileDecode_def_void@
F << remove_static__TIFFNoTileDecode_def_void.F;
P << remove_static__TIFFNoTileDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static__TIFFNoTileDecode_decl@
type T;
identifier F = _TIFFNoTileDecode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static__TIFFNoTileDecode_decl@
F << remove_static__TIFFNoTileDecode_decl.F;
T << remove_static__TIFFNoTileDecode_decl.T;
P << remove_static__TIFFNoTileDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static__TIFFNoTileDecode_decl_void@
identifier F = _TIFFNoTileDecode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static__TIFFNoTileDecode_decl_void@
F << remove_static__TIFFNoTileDecode_decl_void.F;
P << remove_static__TIFFNoTileDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract__TIFFNoTileDecode_def@
type T;
identifier F = _TIFFNoTileDecode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract__TIFFNoTileDecode_def@
F << extract__TIFFNoTileDecode_def.F;
T << extract__TIFFNoTileDecode_def.T;
P << extract__TIFFNoTileDecode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract__TIFFNoTileDecode_def_void@
identifier F = _TIFFNoTileDecode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract__TIFFNoTileDecode_def_void@
F << extract__TIFFNoTileDecode_def_void.F;
P << extract__TIFFNoTileDecode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract__TIFFNoTileDecode_decl@
type T;
identifier F = _TIFFNoTileDecode;
parameter list P;
@@
T F(P);

@script:python depends on extract__TIFFNoTileDecode_decl@
F << extract__TIFFNoTileDecode_decl.F;
T << extract__TIFFNoTileDecode_decl.T;
P << extract__TIFFNoTileDecode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract__TIFFNoTileDecode_decl_void@
identifier F = _TIFFNoTileDecode;
parameter list P;
@@
void F(P);

@script:python depends on extract__TIFFNoTileDecode_decl_void@
F << extract__TIFFNoTileDecode_decl_void.F;
P << extract__TIFFNoTileDecode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: _TIFFNoTileEncode
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static__TIFFNoTileEncode_def@
type T;
identifier F = _TIFFNoTileEncode;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static__TIFFNoTileEncode_def@
F << remove_static__TIFFNoTileEncode_def.F;
T << remove_static__TIFFNoTileEncode_def.T;
P << remove_static__TIFFNoTileEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static__TIFFNoTileEncode_def_void@
identifier F = _TIFFNoTileEncode;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static__TIFFNoTileEncode_def_void@
F << remove_static__TIFFNoTileEncode_def_void.F;
P << remove_static__TIFFNoTileEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static__TIFFNoTileEncode_decl@
type T;
identifier F = _TIFFNoTileEncode;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static__TIFFNoTileEncode_decl@
F << remove_static__TIFFNoTileEncode_decl.F;
T << remove_static__TIFFNoTileEncode_decl.T;
P << remove_static__TIFFNoTileEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static__TIFFNoTileEncode_decl_void@
identifier F = _TIFFNoTileEncode;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static__TIFFNoTileEncode_decl_void@
F << remove_static__TIFFNoTileEncode_decl_void.F;
P << remove_static__TIFFNoTileEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract__TIFFNoTileEncode_def@
type T;
identifier F = _TIFFNoTileEncode;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract__TIFFNoTileEncode_def@
F << extract__TIFFNoTileEncode_def.F;
T << extract__TIFFNoTileEncode_def.T;
P << extract__TIFFNoTileEncode_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract__TIFFNoTileEncode_def_void@
identifier F = _TIFFNoTileEncode;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract__TIFFNoTileEncode_def_void@
F << extract__TIFFNoTileEncode_def_void.F;
P << extract__TIFFNoTileEncode_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract__TIFFNoTileEncode_decl@
type T;
identifier F = _TIFFNoTileEncode;
parameter list P;
@@
T F(P);

@script:python depends on extract__TIFFNoTileEncode_decl@
F << extract__TIFFNoTileEncode_decl.F;
T << extract__TIFFNoTileEncode_decl.T;
P << extract__TIFFNoTileEncode_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract__TIFFNoTileEncode_decl_void@
identifier F = _TIFFNoTileEncode;
parameter list P;
@@
void F(P);

@script:python depends on extract__TIFFNoTileEncode_decl_void@
F << extract__TIFFNoTileEncode_decl_void.F;
P << extract__TIFFNoTileEncode_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: _TIFFSwab16BitData
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static__TIFFSwab16BitData_def@
type T;
identifier F = _TIFFSwab16BitData;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static__TIFFSwab16BitData_def@
F << remove_static__TIFFSwab16BitData_def.F;
T << remove_static__TIFFSwab16BitData_def.T;
P << remove_static__TIFFSwab16BitData_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static__TIFFSwab16BitData_def_void@
identifier F = _TIFFSwab16BitData;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static__TIFFSwab16BitData_def_void@
F << remove_static__TIFFSwab16BitData_def_void.F;
P << remove_static__TIFFSwab16BitData_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static__TIFFSwab16BitData_decl@
type T;
identifier F = _TIFFSwab16BitData;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static__TIFFSwab16BitData_decl@
F << remove_static__TIFFSwab16BitData_decl.F;
T << remove_static__TIFFSwab16BitData_decl.T;
P << remove_static__TIFFSwab16BitData_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static__TIFFSwab16BitData_decl_void@
identifier F = _TIFFSwab16BitData;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static__TIFFSwab16BitData_decl_void@
F << remove_static__TIFFSwab16BitData_decl_void.F;
P << remove_static__TIFFSwab16BitData_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract__TIFFSwab16BitData_def@
type T;
identifier F = _TIFFSwab16BitData;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract__TIFFSwab16BitData_def@
F << extract__TIFFSwab16BitData_def.F;
T << extract__TIFFSwab16BitData_def.T;
P << extract__TIFFSwab16BitData_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract__TIFFSwab16BitData_def_void@
identifier F = _TIFFSwab16BitData;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract__TIFFSwab16BitData_def_void@
F << extract__TIFFSwab16BitData_def_void.F;
P << extract__TIFFSwab16BitData_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract__TIFFSwab16BitData_decl@
type T;
identifier F = _TIFFSwab16BitData;
parameter list P;
@@
T F(P);

@script:python depends on extract__TIFFSwab16BitData_decl@
F << extract__TIFFSwab16BitData_decl.F;
T << extract__TIFFSwab16BitData_decl.T;
P << extract__TIFFSwab16BitData_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract__TIFFSwab16BitData_decl_void@
identifier F = _TIFFSwab16BitData;
parameter list P;
@@
void F(P);

@script:python depends on extract__TIFFSwab16BitData_decl_void@
F << extract__TIFFSwab16BitData_decl_void.F;
P << extract__TIFFSwab16BitData_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: _TIFFSwab24BitData
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static__TIFFSwab24BitData_def@
type T;
identifier F = _TIFFSwab24BitData;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static__TIFFSwab24BitData_def@
F << remove_static__TIFFSwab24BitData_def.F;
T << remove_static__TIFFSwab24BitData_def.T;
P << remove_static__TIFFSwab24BitData_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static__TIFFSwab24BitData_def_void@
identifier F = _TIFFSwab24BitData;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static__TIFFSwab24BitData_def_void@
F << remove_static__TIFFSwab24BitData_def_void.F;
P << remove_static__TIFFSwab24BitData_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static__TIFFSwab24BitData_decl@
type T;
identifier F = _TIFFSwab24BitData;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static__TIFFSwab24BitData_decl@
F << remove_static__TIFFSwab24BitData_decl.F;
T << remove_static__TIFFSwab24BitData_decl.T;
P << remove_static__TIFFSwab24BitData_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static__TIFFSwab24BitData_decl_void@
identifier F = _TIFFSwab24BitData;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static__TIFFSwab24BitData_decl_void@
F << remove_static__TIFFSwab24BitData_decl_void.F;
P << remove_static__TIFFSwab24BitData_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract__TIFFSwab24BitData_def@
type T;
identifier F = _TIFFSwab24BitData;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract__TIFFSwab24BitData_def@
F << extract__TIFFSwab24BitData_def.F;
T << extract__TIFFSwab24BitData_def.T;
P << extract__TIFFSwab24BitData_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract__TIFFSwab24BitData_def_void@
identifier F = _TIFFSwab24BitData;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract__TIFFSwab24BitData_def_void@
F << extract__TIFFSwab24BitData_def_void.F;
P << extract__TIFFSwab24BitData_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract__TIFFSwab24BitData_decl@
type T;
identifier F = _TIFFSwab24BitData;
parameter list P;
@@
T F(P);

@script:python depends on extract__TIFFSwab24BitData_decl@
F << extract__TIFFSwab24BitData_decl.F;
T << extract__TIFFSwab24BitData_decl.T;
P << extract__TIFFSwab24BitData_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract__TIFFSwab24BitData_decl_void@
identifier F = _TIFFSwab24BitData;
parameter list P;
@@
void F(P);

@script:python depends on extract__TIFFSwab24BitData_decl_void@
F << extract__TIFFSwab24BitData_decl_void.F;
P << extract__TIFFSwab24BitData_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: _TIFFSwab32BitData
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static__TIFFSwab32BitData_def@
type T;
identifier F = _TIFFSwab32BitData;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static__TIFFSwab32BitData_def@
F << remove_static__TIFFSwab32BitData_def.F;
T << remove_static__TIFFSwab32BitData_def.T;
P << remove_static__TIFFSwab32BitData_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static__TIFFSwab32BitData_def_void@
identifier F = _TIFFSwab32BitData;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static__TIFFSwab32BitData_def_void@
F << remove_static__TIFFSwab32BitData_def_void.F;
P << remove_static__TIFFSwab32BitData_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static__TIFFSwab32BitData_decl@
type T;
identifier F = _TIFFSwab32BitData;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static__TIFFSwab32BitData_decl@
F << remove_static__TIFFSwab32BitData_decl.F;
T << remove_static__TIFFSwab32BitData_decl.T;
P << remove_static__TIFFSwab32BitData_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static__TIFFSwab32BitData_decl_void@
identifier F = _TIFFSwab32BitData;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static__TIFFSwab32BitData_decl_void@
F << remove_static__TIFFSwab32BitData_decl_void.F;
P << remove_static__TIFFSwab32BitData_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract__TIFFSwab32BitData_def@
type T;
identifier F = _TIFFSwab32BitData;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract__TIFFSwab32BitData_def@
F << extract__TIFFSwab32BitData_def.F;
T << extract__TIFFSwab32BitData_def.T;
P << extract__TIFFSwab32BitData_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract__TIFFSwab32BitData_def_void@
identifier F = _TIFFSwab32BitData;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract__TIFFSwab32BitData_def_void@
F << extract__TIFFSwab32BitData_def_void.F;
P << extract__TIFFSwab32BitData_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract__TIFFSwab32BitData_decl@
type T;
identifier F = _TIFFSwab32BitData;
parameter list P;
@@
T F(P);

@script:python depends on extract__TIFFSwab32BitData_decl@
F << extract__TIFFSwab32BitData_decl.F;
T << extract__TIFFSwab32BitData_decl.T;
P << extract__TIFFSwab32BitData_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract__TIFFSwab32BitData_decl_void@
identifier F = _TIFFSwab32BitData;
parameter list P;
@@
void F(P);

@script:python depends on extract__TIFFSwab32BitData_decl_void@
F << extract__TIFFSwab32BitData_decl_void.F;
P << extract__TIFFSwab32BitData_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: _TIFFSwab64BitData
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static__TIFFSwab64BitData_def@
type T;
identifier F = _TIFFSwab64BitData;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static__TIFFSwab64BitData_def@
F << remove_static__TIFFSwab64BitData_def.F;
T << remove_static__TIFFSwab64BitData_def.T;
P << remove_static__TIFFSwab64BitData_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static__TIFFSwab64BitData_def_void@
identifier F = _TIFFSwab64BitData;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static__TIFFSwab64BitData_def_void@
F << remove_static__TIFFSwab64BitData_def_void.F;
P << remove_static__TIFFSwab64BitData_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static__TIFFSwab64BitData_decl@
type T;
identifier F = _TIFFSwab64BitData;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static__TIFFSwab64BitData_decl@
F << remove_static__TIFFSwab64BitData_decl.F;
T << remove_static__TIFFSwab64BitData_decl.T;
P << remove_static__TIFFSwab64BitData_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static__TIFFSwab64BitData_decl_void@
identifier F = _TIFFSwab64BitData;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static__TIFFSwab64BitData_decl_void@
F << remove_static__TIFFSwab64BitData_decl_void.F;
P << remove_static__TIFFSwab64BitData_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract__TIFFSwab64BitData_def@
type T;
identifier F = _TIFFSwab64BitData;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract__TIFFSwab64BitData_def@
F << extract__TIFFSwab64BitData_def.F;
T << extract__TIFFSwab64BitData_def.T;
P << extract__TIFFSwab64BitData_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract__TIFFSwab64BitData_def_void@
identifier F = _TIFFSwab64BitData;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract__TIFFSwab64BitData_def_void@
F << extract__TIFFSwab64BitData_def_void.F;
P << extract__TIFFSwab64BitData_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract__TIFFSwab64BitData_decl@
type T;
identifier F = _TIFFSwab64BitData;
parameter list P;
@@
T F(P);

@script:python depends on extract__TIFFSwab64BitData_decl@
F << extract__TIFFSwab64BitData_decl.F;
T << extract__TIFFSwab64BitData_decl.T;
P << extract__TIFFSwab64BitData_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract__TIFFSwab64BitData_decl_void@
identifier F = _TIFFSwab64BitData;
parameter list P;
@@
void F(P);

@script:python depends on extract__TIFFSwab64BitData_decl_void@
F << extract__TIFFSwab64BitData_decl_void.F;
P << extract__TIFFSwab64BitData_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: _TIFFVGetField
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static__TIFFVGetField_def@
type T;
identifier F = _TIFFVGetField;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static__TIFFVGetField_def@
F << remove_static__TIFFVGetField_def.F;
T << remove_static__TIFFVGetField_def.T;
P << remove_static__TIFFVGetField_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static__TIFFVGetField_def_void@
identifier F = _TIFFVGetField;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static__TIFFVGetField_def_void@
F << remove_static__TIFFVGetField_def_void.F;
P << remove_static__TIFFVGetField_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static__TIFFVGetField_decl@
type T;
identifier F = _TIFFVGetField;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static__TIFFVGetField_decl@
F << remove_static__TIFFVGetField_decl.F;
T << remove_static__TIFFVGetField_decl.T;
P << remove_static__TIFFVGetField_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static__TIFFVGetField_decl_void@
identifier F = _TIFFVGetField;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static__TIFFVGetField_decl_void@
F << remove_static__TIFFVGetField_decl_void.F;
P << remove_static__TIFFVGetField_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract__TIFFVGetField_def@
type T;
identifier F = _TIFFVGetField;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract__TIFFVGetField_def@
F << extract__TIFFVGetField_def.F;
T << extract__TIFFVGetField_def.T;
P << extract__TIFFVGetField_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract__TIFFVGetField_def_void@
identifier F = _TIFFVGetField;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract__TIFFVGetField_def_void@
F << extract__TIFFVGetField_def_void.F;
P << extract__TIFFVGetField_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract__TIFFVGetField_decl@
type T;
identifier F = _TIFFVGetField;
parameter list P;
@@
T F(P);

@script:python depends on extract__TIFFVGetField_decl@
F << extract__TIFFVGetField_decl.F;
T << extract__TIFFVGetField_decl.T;
P << extract__TIFFVGetField_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract__TIFFVGetField_decl_void@
identifier F = _TIFFVGetField;
parameter list P;
@@
void F(P);

@script:python depends on extract__TIFFVGetField_decl_void@
F << extract__TIFFVGetField_decl_void.F;
P << extract__TIFFVGetField_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: _TIFFVSetField
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static__TIFFVSetField_def@
type T;
identifier F = _TIFFVSetField;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static__TIFFVSetField_def@
F << remove_static__TIFFVSetField_def.F;
T << remove_static__TIFFVSetField_def.T;
P << remove_static__TIFFVSetField_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static__TIFFVSetField_def_void@
identifier F = _TIFFVSetField;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static__TIFFVSetField_def_void@
F << remove_static__TIFFVSetField_def_void.F;
P << remove_static__TIFFVSetField_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static__TIFFVSetField_decl@
type T;
identifier F = _TIFFVSetField;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static__TIFFVSetField_decl@
F << remove_static__TIFFVSetField_decl.F;
T << remove_static__TIFFVSetField_decl.T;
P << remove_static__TIFFVSetField_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static__TIFFVSetField_decl_void@
identifier F = _TIFFVSetField;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static__TIFFVSetField_decl_void@
F << remove_static__TIFFVSetField_decl_void.F;
P << remove_static__TIFFVSetField_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract__TIFFVSetField_def@
type T;
identifier F = _TIFFVSetField;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract__TIFFVSetField_def@
F << extract__TIFFVSetField_def.F;
T << extract__TIFFVSetField_def.T;
P << extract__TIFFVSetField_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract__TIFFVSetField_def_void@
identifier F = _TIFFVSetField;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract__TIFFVSetField_def_void@
F << extract__TIFFVSetField_def_void.F;
P << extract__TIFFVSetField_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract__TIFFVSetField_decl@
type T;
identifier F = _TIFFVSetField;
parameter list P;
@@
T F(P);

@script:python depends on extract__TIFFVSetField_decl@
F << extract__TIFFVSetField_decl.F;
T << extract__TIFFVSetField_decl.T;
P << extract__TIFFVSetField_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract__TIFFVSetField_decl_void@
identifier F = _TIFFVSetField;
parameter list P;
@@
void F(P);

@script:python depends on extract__TIFFVSetField_decl_void@
F << extract__TIFFVSetField_decl_void.F;
P << extract__TIFFVSetField_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: _TIFFtrue
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static__TIFFtrue_def@
type T;
identifier F = _TIFFtrue;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static__TIFFtrue_def@
F << remove_static__TIFFtrue_def.F;
T << remove_static__TIFFtrue_def.T;
P << remove_static__TIFFtrue_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static__TIFFtrue_def_void@
identifier F = _TIFFtrue;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static__TIFFtrue_def_void@
F << remove_static__TIFFtrue_def_void.F;
P << remove_static__TIFFtrue_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static__TIFFtrue_decl@
type T;
identifier F = _TIFFtrue;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static__TIFFtrue_decl@
F << remove_static__TIFFtrue_decl.F;
T << remove_static__TIFFtrue_decl.T;
P << remove_static__TIFFtrue_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static__TIFFtrue_decl_void@
identifier F = _TIFFtrue;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static__TIFFtrue_decl_void@
F << remove_static__TIFFtrue_decl_void.F;
P << remove_static__TIFFtrue_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract__TIFFtrue_def@
type T;
identifier F = _TIFFtrue;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract__TIFFtrue_def@
F << extract__TIFFtrue_def.F;
T << extract__TIFFtrue_def.T;
P << extract__TIFFtrue_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract__TIFFtrue_def_void@
identifier F = _TIFFtrue;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract__TIFFtrue_def_void@
F << extract__TIFFtrue_def_void.F;
P << extract__TIFFtrue_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract__TIFFtrue_decl@
type T;
identifier F = _TIFFtrue;
parameter list P;
@@
T F(P);

@script:python depends on extract__TIFFtrue_decl@
F << extract__TIFFtrue_decl.F;
T << extract__TIFFtrue_decl.T;
P << extract__TIFFtrue_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract__TIFFtrue_decl_void@
identifier F = _TIFFtrue;
parameter list P;
@@
void F(P);

@script:python depends on extract__TIFFtrue_decl_void@
F << extract__TIFFtrue_decl_void.F;
P << extract__TIFFtrue_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: _TIFFvoid
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static__TIFFvoid_def@
type T;
identifier F = _TIFFvoid;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static__TIFFvoid_def@
F << remove_static__TIFFvoid_def.F;
T << remove_static__TIFFvoid_def.T;
P << remove_static__TIFFvoid_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static__TIFFvoid_def_void@
identifier F = _TIFFvoid;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static__TIFFvoid_def_void@
F << remove_static__TIFFvoid_def_void.F;
P << remove_static__TIFFvoid_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static__TIFFvoid_decl@
type T;
identifier F = _TIFFvoid;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static__TIFFvoid_decl@
F << remove_static__TIFFvoid_decl.F;
T << remove_static__TIFFvoid_decl.T;
P << remove_static__TIFFvoid_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static__TIFFvoid_decl_void@
identifier F = _TIFFvoid;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static__TIFFvoid_decl_void@
F << remove_static__TIFFvoid_decl_void.F;
P << remove_static__TIFFvoid_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract__TIFFvoid_def@
type T;
identifier F = _TIFFvoid;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract__TIFFvoid_def@
F << extract__TIFFvoid_def.F;
T << extract__TIFFvoid_def.T;
P << extract__TIFFvoid_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract__TIFFvoid_def_void@
identifier F = _TIFFvoid;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract__TIFFvoid_def_void@
F << extract__TIFFvoid_def_void.F;
P << extract__TIFFvoid_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract__TIFFvoid_decl@
type T;
identifier F = _TIFFvoid;
parameter list P;
@@
T F(P);

@script:python depends on extract__TIFFvoid_decl@
F << extract__TIFFvoid_decl.F;
T << extract__TIFFvoid_decl.T;
P << extract__TIFFvoid_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract__TIFFvoid_decl_void@
identifier F = _TIFFvoid;
parameter list P;
@@
void F(P);

@script:python depends on extract__TIFFvoid_decl_void@
F << extract__TIFFvoid_decl_void.F;
P << extract__TIFFvoid_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: _logLuvNop
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static__logLuvNop_def@
type T;
identifier F = _logLuvNop;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static__logLuvNop_def@
F << remove_static__logLuvNop_def.F;
T << remove_static__logLuvNop_def.T;
P << remove_static__logLuvNop_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static__logLuvNop_def_void@
identifier F = _logLuvNop;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static__logLuvNop_def_void@
F << remove_static__logLuvNop_def_void.F;
P << remove_static__logLuvNop_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static__logLuvNop_decl@
type T;
identifier F = _logLuvNop;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static__logLuvNop_decl@
F << remove_static__logLuvNop_decl.F;
T << remove_static__logLuvNop_decl.T;
P << remove_static__logLuvNop_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static__logLuvNop_decl_void@
identifier F = _logLuvNop;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static__logLuvNop_decl_void@
F << remove_static__logLuvNop_decl_void.F;
P << remove_static__logLuvNop_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract__logLuvNop_def@
type T;
identifier F = _logLuvNop;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract__logLuvNop_def@
F << extract__logLuvNop_def.F;
T << extract__logLuvNop_def.T;
P << extract__logLuvNop_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract__logLuvNop_def_void@
identifier F = _logLuvNop;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract__logLuvNop_def_void@
F << extract__logLuvNop_def_void.F;
P << extract__logLuvNop_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract__logLuvNop_decl@
type T;
identifier F = _logLuvNop;
parameter list P;
@@
T F(P);

@script:python depends on extract__logLuvNop_decl@
F << extract__logLuvNop_decl.F;
T << extract__logLuvNop_decl.T;
P << extract__logLuvNop_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract__logLuvNop_decl_void@
identifier F = _logLuvNop;
parameter list P;
@@
void F(P);

@script:python depends on extract__logLuvNop_decl_void@
F << extract__logLuvNop_decl_void.F;
P << extract__logLuvNop_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: _notConfigured
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static__notConfigured_def@
type T;
identifier F = _notConfigured;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static__notConfigured_def@
F << remove_static__notConfigured_def.F;
T << remove_static__notConfigured_def.T;
P << remove_static__notConfigured_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static__notConfigured_def_void@
identifier F = _notConfigured;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static__notConfigured_def_void@
F << remove_static__notConfigured_def_void.F;
P << remove_static__notConfigured_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static__notConfigured_decl@
type T;
identifier F = _notConfigured;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static__notConfigured_decl@
F << remove_static__notConfigured_decl.F;
T << remove_static__notConfigured_decl.T;
P << remove_static__notConfigured_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static__notConfigured_decl_void@
identifier F = _notConfigured;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static__notConfigured_decl_void@
F << remove_static__notConfigured_decl_void.F;
P << remove_static__notConfigured_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract__notConfigured_def@
type T;
identifier F = _notConfigured;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract__notConfigured_def@
F << extract__notConfigured_def.F;
T << extract__notConfigured_def.T;
P << extract__notConfigured_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract__notConfigured_def_void@
identifier F = _notConfigured;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract__notConfigured_def_void@
F << extract__notConfigured_def_void.F;
P << extract__notConfigured_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract__notConfigured_decl@
type T;
identifier F = _notConfigured;
parameter list P;
@@
T F(P);

@script:python depends on extract__notConfigured_decl@
F << extract__notConfigured_decl.F;
T << extract__notConfigured_decl.T;
P << extract__notConfigured_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract__notConfigured_decl_void@
identifier F = _notConfigured;
parameter list P;
@@
void F(P);

@script:python depends on extract__notConfigured_decl_void@
F << extract__notConfigured_decl_void.F;
P << extract__notConfigured_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: closeproc
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_closeproc_def@
type T;
identifier F = closeproc;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_closeproc_def@
F << remove_static_closeproc_def.F;
T << remove_static_closeproc_def.T;
P << remove_static_closeproc_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_closeproc_def_void@
identifier F = closeproc;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_closeproc_def_void@
F << remove_static_closeproc_def_void.F;
P << remove_static_closeproc_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_closeproc_decl@
type T;
identifier F = closeproc;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_closeproc_decl@
F << remove_static_closeproc_decl.F;
T << remove_static_closeproc_decl.T;
P << remove_static_closeproc_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_closeproc_decl_void@
identifier F = closeproc;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_closeproc_decl_void@
F << remove_static_closeproc_decl_void.F;
P << remove_static_closeproc_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_closeproc_def@
type T;
identifier F = closeproc;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_closeproc_def@
F << extract_closeproc_def.F;
T << extract_closeproc_def.T;
P << extract_closeproc_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_closeproc_def_void@
identifier F = closeproc;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_closeproc_def_void@
F << extract_closeproc_def_void.F;
P << extract_closeproc_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_closeproc_decl@
type T;
identifier F = closeproc;
parameter list P;
@@
T F(P);

@script:python depends on extract_closeproc_decl@
F << extract_closeproc_decl.F;
T << extract_closeproc_decl.T;
P << extract_closeproc_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_closeproc_decl_void@
identifier F = closeproc;
parameter list P;
@@
void F(P);

@script:python depends on extract_closeproc_decl_void@
F << extract_closeproc_decl_void.F;
P << extract_closeproc_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: fpAcc
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_fpAcc_def@
type T;
identifier F = fpAcc;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_fpAcc_def@
F << remove_static_fpAcc_def.F;
T << remove_static_fpAcc_def.T;
P << remove_static_fpAcc_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_fpAcc_def_void@
identifier F = fpAcc;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_fpAcc_def_void@
F << remove_static_fpAcc_def_void.F;
P << remove_static_fpAcc_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_fpAcc_decl@
type T;
identifier F = fpAcc;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_fpAcc_decl@
F << remove_static_fpAcc_decl.F;
T << remove_static_fpAcc_decl.T;
P << remove_static_fpAcc_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_fpAcc_decl_void@
identifier F = fpAcc;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_fpAcc_decl_void@
F << remove_static_fpAcc_decl_void.F;
P << remove_static_fpAcc_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_fpAcc_def@
type T;
identifier F = fpAcc;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_fpAcc_def@
F << extract_fpAcc_def.F;
T << extract_fpAcc_def.T;
P << extract_fpAcc_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_fpAcc_def_void@
identifier F = fpAcc;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_fpAcc_def_void@
F << extract_fpAcc_def_void.F;
P << extract_fpAcc_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_fpAcc_decl@
type T;
identifier F = fpAcc;
parameter list P;
@@
T F(P);

@script:python depends on extract_fpAcc_decl@
F << extract_fpAcc_decl.F;
T << extract_fpAcc_decl.T;
P << extract_fpAcc_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_fpAcc_decl_void@
identifier F = fpAcc;
parameter list P;
@@
void F(P);

@script:python depends on extract_fpAcc_decl_void@
F << extract_fpAcc_decl_void.F;
P << extract_fpAcc_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: fpDiff
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_fpDiff_def@
type T;
identifier F = fpDiff;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_fpDiff_def@
F << remove_static_fpDiff_def.F;
T << remove_static_fpDiff_def.T;
P << remove_static_fpDiff_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_fpDiff_def_void@
identifier F = fpDiff;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_fpDiff_def_void@
F << remove_static_fpDiff_def_void.F;
P << remove_static_fpDiff_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_fpDiff_decl@
type T;
identifier F = fpDiff;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_fpDiff_decl@
F << remove_static_fpDiff_decl.F;
T << remove_static_fpDiff_decl.T;
P << remove_static_fpDiff_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_fpDiff_decl_void@
identifier F = fpDiff;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_fpDiff_decl_void@
F << remove_static_fpDiff_decl_void.F;
P << remove_static_fpDiff_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_fpDiff_def@
type T;
identifier F = fpDiff;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_fpDiff_def@
F << extract_fpDiff_def.F;
T << extract_fpDiff_def.T;
P << extract_fpDiff_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_fpDiff_def_void@
identifier F = fpDiff;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_fpDiff_def_void@
F << extract_fpDiff_def_void.F;
P << extract_fpDiff_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_fpDiff_decl@
type T;
identifier F = fpDiff;
parameter list P;
@@
T F(P);

@script:python depends on extract_fpDiff_decl@
F << extract_fpDiff_decl.F;
T << extract_fpDiff_decl.T;
P << extract_fpDiff_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_fpDiff_decl_void@
identifier F = fpDiff;
parameter list P;
@@
void F(P);

@script:python depends on extract_fpDiff_decl_void@
F << extract_fpDiff_decl_void.F;
P << extract_fpDiff_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: handler
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_handler_def@
type T;
identifier F = handler;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_handler_def@
F << remove_static_handler_def.F;
T << remove_static_handler_def.T;
P << remove_static_handler_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_handler_def_void@
identifier F = handler;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_handler_def_void@
F << remove_static_handler_def_void.F;
P << remove_static_handler_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_handler_decl@
type T;
identifier F = handler;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_handler_decl@
F << remove_static_handler_decl.F;
T << remove_static_handler_decl.T;
P << remove_static_handler_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_handler_decl_void@
identifier F = handler;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_handler_decl_void@
F << remove_static_handler_decl_void.F;
P << remove_static_handler_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_handler_def@
type T;
identifier F = handler;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_handler_def@
F << extract_handler_def.F;
T << extract_handler_def.T;
P << extract_handler_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_handler_def_void@
identifier F = handler;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_handler_def_void@
F << extract_handler_def_void.F;
P << extract_handler_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_handler_decl@
type T;
identifier F = handler;
parameter list P;
@@
T F(P);

@script:python depends on extract_handler_decl@
F << extract_handler_decl.F;
T << extract_handler_decl.T;
P << extract_handler_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_handler_decl_void@
identifier F = handler;
parameter list P;
@@
void F(P);

@script:python depends on extract_handler_decl_void@
F << extract_handler_decl_void.F;
P << extract_handler_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: horAcc16
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_horAcc16_def@
type T;
identifier F = horAcc16;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_horAcc16_def@
F << remove_static_horAcc16_def.F;
T << remove_static_horAcc16_def.T;
P << remove_static_horAcc16_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_horAcc16_def_void@
identifier F = horAcc16;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_horAcc16_def_void@
F << remove_static_horAcc16_def_void.F;
P << remove_static_horAcc16_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_horAcc16_decl@
type T;
identifier F = horAcc16;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_horAcc16_decl@
F << remove_static_horAcc16_decl.F;
T << remove_static_horAcc16_decl.T;
P << remove_static_horAcc16_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_horAcc16_decl_void@
identifier F = horAcc16;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_horAcc16_decl_void@
F << remove_static_horAcc16_decl_void.F;
P << remove_static_horAcc16_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_horAcc16_def@
type T;
identifier F = horAcc16;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_horAcc16_def@
F << extract_horAcc16_def.F;
T << extract_horAcc16_def.T;
P << extract_horAcc16_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_horAcc16_def_void@
identifier F = horAcc16;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_horAcc16_def_void@
F << extract_horAcc16_def_void.F;
P << extract_horAcc16_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_horAcc16_decl@
type T;
identifier F = horAcc16;
parameter list P;
@@
T F(P);

@script:python depends on extract_horAcc16_decl@
F << extract_horAcc16_decl.F;
T << extract_horAcc16_decl.T;
P << extract_horAcc16_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_horAcc16_decl_void@
identifier F = horAcc16;
parameter list P;
@@
void F(P);

@script:python depends on extract_horAcc16_decl_void@
F << extract_horAcc16_decl_void.F;
P << extract_horAcc16_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: horAcc32
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_horAcc32_def@
type T;
identifier F = horAcc32;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_horAcc32_def@
F << remove_static_horAcc32_def.F;
T << remove_static_horAcc32_def.T;
P << remove_static_horAcc32_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_horAcc32_def_void@
identifier F = horAcc32;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_horAcc32_def_void@
F << remove_static_horAcc32_def_void.F;
P << remove_static_horAcc32_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_horAcc32_decl@
type T;
identifier F = horAcc32;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_horAcc32_decl@
F << remove_static_horAcc32_decl.F;
T << remove_static_horAcc32_decl.T;
P << remove_static_horAcc32_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_horAcc32_decl_void@
identifier F = horAcc32;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_horAcc32_decl_void@
F << remove_static_horAcc32_decl_void.F;
P << remove_static_horAcc32_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_horAcc32_def@
type T;
identifier F = horAcc32;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_horAcc32_def@
F << extract_horAcc32_def.F;
T << extract_horAcc32_def.T;
P << extract_horAcc32_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_horAcc32_def_void@
identifier F = horAcc32;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_horAcc32_def_void@
F << extract_horAcc32_def_void.F;
P << extract_horAcc32_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_horAcc32_decl@
type T;
identifier F = horAcc32;
parameter list P;
@@
T F(P);

@script:python depends on extract_horAcc32_decl@
F << extract_horAcc32_decl.F;
T << extract_horAcc32_decl.T;
P << extract_horAcc32_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_horAcc32_decl_void@
identifier F = horAcc32;
parameter list P;
@@
void F(P);

@script:python depends on extract_horAcc32_decl_void@
F << extract_horAcc32_decl_void.F;
P << extract_horAcc32_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: horAcc64
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_horAcc64_def@
type T;
identifier F = horAcc64;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_horAcc64_def@
F << remove_static_horAcc64_def.F;
T << remove_static_horAcc64_def.T;
P << remove_static_horAcc64_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_horAcc64_def_void@
identifier F = horAcc64;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_horAcc64_def_void@
F << remove_static_horAcc64_def_void.F;
P << remove_static_horAcc64_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_horAcc64_decl@
type T;
identifier F = horAcc64;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_horAcc64_decl@
F << remove_static_horAcc64_decl.F;
T << remove_static_horAcc64_decl.T;
P << remove_static_horAcc64_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_horAcc64_decl_void@
identifier F = horAcc64;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_horAcc64_decl_void@
F << remove_static_horAcc64_decl_void.F;
P << remove_static_horAcc64_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_horAcc64_def@
type T;
identifier F = horAcc64;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_horAcc64_def@
F << extract_horAcc64_def.F;
T << extract_horAcc64_def.T;
P << extract_horAcc64_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_horAcc64_def_void@
identifier F = horAcc64;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_horAcc64_def_void@
F << extract_horAcc64_def_void.F;
P << extract_horAcc64_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_horAcc64_decl@
type T;
identifier F = horAcc64;
parameter list P;
@@
T F(P);

@script:python depends on extract_horAcc64_decl@
F << extract_horAcc64_decl.F;
T << extract_horAcc64_decl.T;
P << extract_horAcc64_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_horAcc64_decl_void@
identifier F = horAcc64;
parameter list P;
@@
void F(P);

@script:python depends on extract_horAcc64_decl_void@
F << extract_horAcc64_decl_void.F;
P << extract_horAcc64_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: horAcc8
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_horAcc8_def@
type T;
identifier F = horAcc8;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_horAcc8_def@
F << remove_static_horAcc8_def.F;
T << remove_static_horAcc8_def.T;
P << remove_static_horAcc8_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_horAcc8_def_void@
identifier F = horAcc8;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_horAcc8_def_void@
F << remove_static_horAcc8_def_void.F;
P << remove_static_horAcc8_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_horAcc8_decl@
type T;
identifier F = horAcc8;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_horAcc8_decl@
F << remove_static_horAcc8_decl.F;
T << remove_static_horAcc8_decl.T;
P << remove_static_horAcc8_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_horAcc8_decl_void@
identifier F = horAcc8;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_horAcc8_decl_void@
F << remove_static_horAcc8_decl_void.F;
P << remove_static_horAcc8_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_horAcc8_def@
type T;
identifier F = horAcc8;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_horAcc8_def@
F << extract_horAcc8_def.F;
T << extract_horAcc8_def.T;
P << extract_horAcc8_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_horAcc8_def_void@
identifier F = horAcc8;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_horAcc8_def_void@
F << extract_horAcc8_def_void.F;
P << extract_horAcc8_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_horAcc8_decl@
type T;
identifier F = horAcc8;
parameter list P;
@@
T F(P);

@script:python depends on extract_horAcc8_decl@
F << extract_horAcc8_decl.F;
T << extract_horAcc8_decl.T;
P << extract_horAcc8_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_horAcc8_decl_void@
identifier F = horAcc8;
parameter list P;
@@
void F(P);

@script:python depends on extract_horAcc8_decl_void@
F << extract_horAcc8_decl_void.F;
P << extract_horAcc8_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: horDiff16
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_horDiff16_def@
type T;
identifier F = horDiff16;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_horDiff16_def@
F << remove_static_horDiff16_def.F;
T << remove_static_horDiff16_def.T;
P << remove_static_horDiff16_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_horDiff16_def_void@
identifier F = horDiff16;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_horDiff16_def_void@
F << remove_static_horDiff16_def_void.F;
P << remove_static_horDiff16_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_horDiff16_decl@
type T;
identifier F = horDiff16;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_horDiff16_decl@
F << remove_static_horDiff16_decl.F;
T << remove_static_horDiff16_decl.T;
P << remove_static_horDiff16_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_horDiff16_decl_void@
identifier F = horDiff16;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_horDiff16_decl_void@
F << remove_static_horDiff16_decl_void.F;
P << remove_static_horDiff16_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_horDiff16_def@
type T;
identifier F = horDiff16;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_horDiff16_def@
F << extract_horDiff16_def.F;
T << extract_horDiff16_def.T;
P << extract_horDiff16_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_horDiff16_def_void@
identifier F = horDiff16;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_horDiff16_def_void@
F << extract_horDiff16_def_void.F;
P << extract_horDiff16_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_horDiff16_decl@
type T;
identifier F = horDiff16;
parameter list P;
@@
T F(P);

@script:python depends on extract_horDiff16_decl@
F << extract_horDiff16_decl.F;
T << extract_horDiff16_decl.T;
P << extract_horDiff16_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_horDiff16_decl_void@
identifier F = horDiff16;
parameter list P;
@@
void F(P);

@script:python depends on extract_horDiff16_decl_void@
F << extract_horDiff16_decl_void.F;
P << extract_horDiff16_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: horDiff32
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_horDiff32_def@
type T;
identifier F = horDiff32;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_horDiff32_def@
F << remove_static_horDiff32_def.F;
T << remove_static_horDiff32_def.T;
P << remove_static_horDiff32_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_horDiff32_def_void@
identifier F = horDiff32;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_horDiff32_def_void@
F << remove_static_horDiff32_def_void.F;
P << remove_static_horDiff32_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_horDiff32_decl@
type T;
identifier F = horDiff32;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_horDiff32_decl@
F << remove_static_horDiff32_decl.F;
T << remove_static_horDiff32_decl.T;
P << remove_static_horDiff32_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_horDiff32_decl_void@
identifier F = horDiff32;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_horDiff32_decl_void@
F << remove_static_horDiff32_decl_void.F;
P << remove_static_horDiff32_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_horDiff32_def@
type T;
identifier F = horDiff32;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_horDiff32_def@
F << extract_horDiff32_def.F;
T << extract_horDiff32_def.T;
P << extract_horDiff32_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_horDiff32_def_void@
identifier F = horDiff32;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_horDiff32_def_void@
F << extract_horDiff32_def_void.F;
P << extract_horDiff32_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_horDiff32_decl@
type T;
identifier F = horDiff32;
parameter list P;
@@
T F(P);

@script:python depends on extract_horDiff32_decl@
F << extract_horDiff32_decl.F;
T << extract_horDiff32_decl.T;
P << extract_horDiff32_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_horDiff32_decl_void@
identifier F = horDiff32;
parameter list P;
@@
void F(P);

@script:python depends on extract_horDiff32_decl_void@
F << extract_horDiff32_decl_void.F;
P << extract_horDiff32_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: horDiff64
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_horDiff64_def@
type T;
identifier F = horDiff64;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_horDiff64_def@
F << remove_static_horDiff64_def.F;
T << remove_static_horDiff64_def.T;
P << remove_static_horDiff64_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_horDiff64_def_void@
identifier F = horDiff64;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_horDiff64_def_void@
F << remove_static_horDiff64_def_void.F;
P << remove_static_horDiff64_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_horDiff64_decl@
type T;
identifier F = horDiff64;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_horDiff64_decl@
F << remove_static_horDiff64_decl.F;
T << remove_static_horDiff64_decl.T;
P << remove_static_horDiff64_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_horDiff64_decl_void@
identifier F = horDiff64;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_horDiff64_decl_void@
F << remove_static_horDiff64_decl_void.F;
P << remove_static_horDiff64_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_horDiff64_def@
type T;
identifier F = horDiff64;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_horDiff64_def@
F << extract_horDiff64_def.F;
T << extract_horDiff64_def.T;
P << extract_horDiff64_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_horDiff64_def_void@
identifier F = horDiff64;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_horDiff64_def_void@
F << extract_horDiff64_def_void.F;
P << extract_horDiff64_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_horDiff64_decl@
type T;
identifier F = horDiff64;
parameter list P;
@@
T F(P);

@script:python depends on extract_horDiff64_decl@
F << extract_horDiff64_decl.F;
T << extract_horDiff64_decl.T;
P << extract_horDiff64_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_horDiff64_decl_void@
identifier F = horDiff64;
parameter list P;
@@
void F(P);

@script:python depends on extract_horDiff64_decl_void@
F << extract_horDiff64_decl_void.F;
P << extract_horDiff64_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: horDiff8
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_horDiff8_def@
type T;
identifier F = horDiff8;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_horDiff8_def@
F << remove_static_horDiff8_def.F;
T << remove_static_horDiff8_def.T;
P << remove_static_horDiff8_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_horDiff8_def_void@
identifier F = horDiff8;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_horDiff8_def_void@
F << remove_static_horDiff8_def_void.F;
P << remove_static_horDiff8_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_horDiff8_decl@
type T;
identifier F = horDiff8;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_horDiff8_decl@
F << remove_static_horDiff8_decl.F;
T << remove_static_horDiff8_decl.T;
P << remove_static_horDiff8_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_horDiff8_decl_void@
identifier F = horDiff8;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_horDiff8_decl_void@
F << remove_static_horDiff8_decl_void.F;
P << remove_static_horDiff8_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_horDiff8_def@
type T;
identifier F = horDiff8;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_horDiff8_def@
F << extract_horDiff8_def.F;
T << extract_horDiff8_def.T;
P << extract_horDiff8_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_horDiff8_def_void@
identifier F = horDiff8;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_horDiff8_def_void@
F << extract_horDiff8_def_void.F;
P << extract_horDiff8_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_horDiff8_decl@
type T;
identifier F = horDiff8;
parameter list P;
@@
T F(P);

@script:python depends on extract_horDiff8_decl@
F << extract_horDiff8_decl.F;
T << extract_horDiff8_decl.T;
P << extract_horDiff8_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_horDiff8_decl_void@
identifier F = horDiff8;
parameter list P;
@@
void F(P);

@script:python depends on extract_horDiff8_decl_void@
F << extract_horDiff8_decl_void.F;
P << extract_horDiff8_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: put16bitbwtile
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_put16bitbwtile_def@
type T;
identifier F = put16bitbwtile;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_put16bitbwtile_def@
F << remove_static_put16bitbwtile_def.F;
T << remove_static_put16bitbwtile_def.T;
P << remove_static_put16bitbwtile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_put16bitbwtile_def_void@
identifier F = put16bitbwtile;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_put16bitbwtile_def_void@
F << remove_static_put16bitbwtile_def_void.F;
P << remove_static_put16bitbwtile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_put16bitbwtile_decl@
type T;
identifier F = put16bitbwtile;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_put16bitbwtile_decl@
F << remove_static_put16bitbwtile_decl.F;
T << remove_static_put16bitbwtile_decl.T;
P << remove_static_put16bitbwtile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_put16bitbwtile_decl_void@
identifier F = put16bitbwtile;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_put16bitbwtile_decl_void@
F << remove_static_put16bitbwtile_decl_void.F;
P << remove_static_put16bitbwtile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_put16bitbwtile_def@
type T;
identifier F = put16bitbwtile;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_put16bitbwtile_def@
F << extract_put16bitbwtile_def.F;
T << extract_put16bitbwtile_def.T;
P << extract_put16bitbwtile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_put16bitbwtile_def_void@
identifier F = put16bitbwtile;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_put16bitbwtile_def_void@
F << extract_put16bitbwtile_def_void.F;
P << extract_put16bitbwtile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_put16bitbwtile_decl@
type T;
identifier F = put16bitbwtile;
parameter list P;
@@
T F(P);

@script:python depends on extract_put16bitbwtile_decl@
F << extract_put16bitbwtile_decl.F;
T << extract_put16bitbwtile_decl.T;
P << extract_put16bitbwtile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_put16bitbwtile_decl_void@
identifier F = put16bitbwtile;
parameter list P;
@@
void F(P);

@script:python depends on extract_put16bitbwtile_decl_void@
F << extract_put16bitbwtile_decl_void.F;
P << extract_put16bitbwtile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: put1bitbwtile
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_put1bitbwtile_def@
type T;
identifier F = put1bitbwtile;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_put1bitbwtile_def@
F << remove_static_put1bitbwtile_def.F;
T << remove_static_put1bitbwtile_def.T;
P << remove_static_put1bitbwtile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_put1bitbwtile_def_void@
identifier F = put1bitbwtile;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_put1bitbwtile_def_void@
F << remove_static_put1bitbwtile_def_void.F;
P << remove_static_put1bitbwtile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_put1bitbwtile_decl@
type T;
identifier F = put1bitbwtile;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_put1bitbwtile_decl@
F << remove_static_put1bitbwtile_decl.F;
T << remove_static_put1bitbwtile_decl.T;
P << remove_static_put1bitbwtile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_put1bitbwtile_decl_void@
identifier F = put1bitbwtile;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_put1bitbwtile_decl_void@
F << remove_static_put1bitbwtile_decl_void.F;
P << remove_static_put1bitbwtile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_put1bitbwtile_def@
type T;
identifier F = put1bitbwtile;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_put1bitbwtile_def@
F << extract_put1bitbwtile_def.F;
T << extract_put1bitbwtile_def.T;
P << extract_put1bitbwtile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_put1bitbwtile_def_void@
identifier F = put1bitbwtile;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_put1bitbwtile_def_void@
F << extract_put1bitbwtile_def_void.F;
P << extract_put1bitbwtile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_put1bitbwtile_decl@
type T;
identifier F = put1bitbwtile;
parameter list P;
@@
T F(P);

@script:python depends on extract_put1bitbwtile_decl@
F << extract_put1bitbwtile_decl.F;
T << extract_put1bitbwtile_decl.T;
P << extract_put1bitbwtile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_put1bitbwtile_decl_void@
identifier F = put1bitbwtile;
parameter list P;
@@
void F(P);

@script:python depends on extract_put1bitbwtile_decl_void@
F << extract_put1bitbwtile_decl_void.F;
P << extract_put1bitbwtile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: put1bitcmaptile
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_put1bitcmaptile_def@
type T;
identifier F = put1bitcmaptile;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_put1bitcmaptile_def@
F << remove_static_put1bitcmaptile_def.F;
T << remove_static_put1bitcmaptile_def.T;
P << remove_static_put1bitcmaptile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_put1bitcmaptile_def_void@
identifier F = put1bitcmaptile;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_put1bitcmaptile_def_void@
F << remove_static_put1bitcmaptile_def_void.F;
P << remove_static_put1bitcmaptile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_put1bitcmaptile_decl@
type T;
identifier F = put1bitcmaptile;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_put1bitcmaptile_decl@
F << remove_static_put1bitcmaptile_decl.F;
T << remove_static_put1bitcmaptile_decl.T;
P << remove_static_put1bitcmaptile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_put1bitcmaptile_decl_void@
identifier F = put1bitcmaptile;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_put1bitcmaptile_decl_void@
F << remove_static_put1bitcmaptile_decl_void.F;
P << remove_static_put1bitcmaptile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_put1bitcmaptile_def@
type T;
identifier F = put1bitcmaptile;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_put1bitcmaptile_def@
F << extract_put1bitcmaptile_def.F;
T << extract_put1bitcmaptile_def.T;
P << extract_put1bitcmaptile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_put1bitcmaptile_def_void@
identifier F = put1bitcmaptile;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_put1bitcmaptile_def_void@
F << extract_put1bitcmaptile_def_void.F;
P << extract_put1bitcmaptile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_put1bitcmaptile_decl@
type T;
identifier F = put1bitcmaptile;
parameter list P;
@@
T F(P);

@script:python depends on extract_put1bitcmaptile_decl@
F << extract_put1bitcmaptile_decl.F;
T << extract_put1bitcmaptile_decl.T;
P << extract_put1bitcmaptile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_put1bitcmaptile_decl_void@
identifier F = put1bitcmaptile;
parameter list P;
@@
void F(P);

@script:python depends on extract_put1bitcmaptile_decl_void@
F << extract_put1bitcmaptile_decl_void.F;
P << extract_put1bitcmaptile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: put2bitbwtile
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_put2bitbwtile_def@
type T;
identifier F = put2bitbwtile;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_put2bitbwtile_def@
F << remove_static_put2bitbwtile_def.F;
T << remove_static_put2bitbwtile_def.T;
P << remove_static_put2bitbwtile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_put2bitbwtile_def_void@
identifier F = put2bitbwtile;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_put2bitbwtile_def_void@
F << remove_static_put2bitbwtile_def_void.F;
P << remove_static_put2bitbwtile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_put2bitbwtile_decl@
type T;
identifier F = put2bitbwtile;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_put2bitbwtile_decl@
F << remove_static_put2bitbwtile_decl.F;
T << remove_static_put2bitbwtile_decl.T;
P << remove_static_put2bitbwtile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_put2bitbwtile_decl_void@
identifier F = put2bitbwtile;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_put2bitbwtile_decl_void@
F << remove_static_put2bitbwtile_decl_void.F;
P << remove_static_put2bitbwtile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_put2bitbwtile_def@
type T;
identifier F = put2bitbwtile;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_put2bitbwtile_def@
F << extract_put2bitbwtile_def.F;
T << extract_put2bitbwtile_def.T;
P << extract_put2bitbwtile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_put2bitbwtile_def_void@
identifier F = put2bitbwtile;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_put2bitbwtile_def_void@
F << extract_put2bitbwtile_def_void.F;
P << extract_put2bitbwtile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_put2bitbwtile_decl@
type T;
identifier F = put2bitbwtile;
parameter list P;
@@
T F(P);

@script:python depends on extract_put2bitbwtile_decl@
F << extract_put2bitbwtile_decl.F;
T << extract_put2bitbwtile_decl.T;
P << extract_put2bitbwtile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_put2bitbwtile_decl_void@
identifier F = put2bitbwtile;
parameter list P;
@@
void F(P);

@script:python depends on extract_put2bitbwtile_decl_void@
F << extract_put2bitbwtile_decl_void.F;
P << extract_put2bitbwtile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: put2bitcmaptile
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_put2bitcmaptile_def@
type T;
identifier F = put2bitcmaptile;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_put2bitcmaptile_def@
F << remove_static_put2bitcmaptile_def.F;
T << remove_static_put2bitcmaptile_def.T;
P << remove_static_put2bitcmaptile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_put2bitcmaptile_def_void@
identifier F = put2bitcmaptile;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_put2bitcmaptile_def_void@
F << remove_static_put2bitcmaptile_def_void.F;
P << remove_static_put2bitcmaptile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_put2bitcmaptile_decl@
type T;
identifier F = put2bitcmaptile;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_put2bitcmaptile_decl@
F << remove_static_put2bitcmaptile_decl.F;
T << remove_static_put2bitcmaptile_decl.T;
P << remove_static_put2bitcmaptile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_put2bitcmaptile_decl_void@
identifier F = put2bitcmaptile;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_put2bitcmaptile_decl_void@
F << remove_static_put2bitcmaptile_decl_void.F;
P << remove_static_put2bitcmaptile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_put2bitcmaptile_def@
type T;
identifier F = put2bitcmaptile;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_put2bitcmaptile_def@
F << extract_put2bitcmaptile_def.F;
T << extract_put2bitcmaptile_def.T;
P << extract_put2bitcmaptile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_put2bitcmaptile_def_void@
identifier F = put2bitcmaptile;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_put2bitcmaptile_def_void@
F << extract_put2bitcmaptile_def_void.F;
P << extract_put2bitcmaptile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_put2bitcmaptile_decl@
type T;
identifier F = put2bitcmaptile;
parameter list P;
@@
T F(P);

@script:python depends on extract_put2bitcmaptile_decl@
F << extract_put2bitcmaptile_decl.F;
T << extract_put2bitcmaptile_decl.T;
P << extract_put2bitcmaptile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_put2bitcmaptile_decl_void@
identifier F = put2bitcmaptile;
parameter list P;
@@
void F(P);

@script:python depends on extract_put2bitcmaptile_decl_void@
F << extract_put2bitcmaptile_decl_void.F;
P << extract_put2bitcmaptile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: put4bitbwtile
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_put4bitbwtile_def@
type T;
identifier F = put4bitbwtile;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_put4bitbwtile_def@
F << remove_static_put4bitbwtile_def.F;
T << remove_static_put4bitbwtile_def.T;
P << remove_static_put4bitbwtile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_put4bitbwtile_def_void@
identifier F = put4bitbwtile;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_put4bitbwtile_def_void@
F << remove_static_put4bitbwtile_def_void.F;
P << remove_static_put4bitbwtile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_put4bitbwtile_decl@
type T;
identifier F = put4bitbwtile;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_put4bitbwtile_decl@
F << remove_static_put4bitbwtile_decl.F;
T << remove_static_put4bitbwtile_decl.T;
P << remove_static_put4bitbwtile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_put4bitbwtile_decl_void@
identifier F = put4bitbwtile;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_put4bitbwtile_decl_void@
F << remove_static_put4bitbwtile_decl_void.F;
P << remove_static_put4bitbwtile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_put4bitbwtile_def@
type T;
identifier F = put4bitbwtile;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_put4bitbwtile_def@
F << extract_put4bitbwtile_def.F;
T << extract_put4bitbwtile_def.T;
P << extract_put4bitbwtile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_put4bitbwtile_def_void@
identifier F = put4bitbwtile;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_put4bitbwtile_def_void@
F << extract_put4bitbwtile_def_void.F;
P << extract_put4bitbwtile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_put4bitbwtile_decl@
type T;
identifier F = put4bitbwtile;
parameter list P;
@@
T F(P);

@script:python depends on extract_put4bitbwtile_decl@
F << extract_put4bitbwtile_decl.F;
T << extract_put4bitbwtile_decl.T;
P << extract_put4bitbwtile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_put4bitbwtile_decl_void@
identifier F = put4bitbwtile;
parameter list P;
@@
void F(P);

@script:python depends on extract_put4bitbwtile_decl_void@
F << extract_put4bitbwtile_decl_void.F;
P << extract_put4bitbwtile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: put4bitcmaptile
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_put4bitcmaptile_def@
type T;
identifier F = put4bitcmaptile;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_put4bitcmaptile_def@
F << remove_static_put4bitcmaptile_def.F;
T << remove_static_put4bitcmaptile_def.T;
P << remove_static_put4bitcmaptile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_put4bitcmaptile_def_void@
identifier F = put4bitcmaptile;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_put4bitcmaptile_def_void@
F << remove_static_put4bitcmaptile_def_void.F;
P << remove_static_put4bitcmaptile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_put4bitcmaptile_decl@
type T;
identifier F = put4bitcmaptile;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_put4bitcmaptile_decl@
F << remove_static_put4bitcmaptile_decl.F;
T << remove_static_put4bitcmaptile_decl.T;
P << remove_static_put4bitcmaptile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_put4bitcmaptile_decl_void@
identifier F = put4bitcmaptile;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_put4bitcmaptile_decl_void@
F << remove_static_put4bitcmaptile_decl_void.F;
P << remove_static_put4bitcmaptile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_put4bitcmaptile_def@
type T;
identifier F = put4bitcmaptile;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_put4bitcmaptile_def@
F << extract_put4bitcmaptile_def.F;
T << extract_put4bitcmaptile_def.T;
P << extract_put4bitcmaptile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_put4bitcmaptile_def_void@
identifier F = put4bitcmaptile;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_put4bitcmaptile_def_void@
F << extract_put4bitcmaptile_def_void.F;
P << extract_put4bitcmaptile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_put4bitcmaptile_decl@
type T;
identifier F = put4bitcmaptile;
parameter list P;
@@
T F(P);

@script:python depends on extract_put4bitcmaptile_decl@
F << extract_put4bitcmaptile_decl.F;
T << extract_put4bitcmaptile_decl.T;
P << extract_put4bitcmaptile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_put4bitcmaptile_decl_void@
identifier F = put4bitcmaptile;
parameter list P;
@@
void F(P);

@script:python depends on extract_put4bitcmaptile_decl_void@
F << extract_put4bitcmaptile_decl_void.F;
P << extract_put4bitcmaptile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: put8bitcmaptile
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_put8bitcmaptile_def@
type T;
identifier F = put8bitcmaptile;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_put8bitcmaptile_def@
F << remove_static_put8bitcmaptile_def.F;
T << remove_static_put8bitcmaptile_def.T;
P << remove_static_put8bitcmaptile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_put8bitcmaptile_def_void@
identifier F = put8bitcmaptile;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_put8bitcmaptile_def_void@
F << remove_static_put8bitcmaptile_def_void.F;
P << remove_static_put8bitcmaptile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_put8bitcmaptile_decl@
type T;
identifier F = put8bitcmaptile;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_put8bitcmaptile_decl@
F << remove_static_put8bitcmaptile_decl.F;
T << remove_static_put8bitcmaptile_decl.T;
P << remove_static_put8bitcmaptile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_put8bitcmaptile_decl_void@
identifier F = put8bitcmaptile;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_put8bitcmaptile_decl_void@
F << remove_static_put8bitcmaptile_decl_void.F;
P << remove_static_put8bitcmaptile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_put8bitcmaptile_def@
type T;
identifier F = put8bitcmaptile;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_put8bitcmaptile_def@
F << extract_put8bitcmaptile_def.F;
T << extract_put8bitcmaptile_def.T;
P << extract_put8bitcmaptile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_put8bitcmaptile_def_void@
identifier F = put8bitcmaptile;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_put8bitcmaptile_def_void@
F << extract_put8bitcmaptile_def_void.F;
P << extract_put8bitcmaptile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_put8bitcmaptile_decl@
type T;
identifier F = put8bitcmaptile;
parameter list P;
@@
T F(P);

@script:python depends on extract_put8bitcmaptile_decl@
F << extract_put8bitcmaptile_decl.F;
T << extract_put8bitcmaptile_decl.T;
P << extract_put8bitcmaptile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_put8bitcmaptile_decl_void@
identifier F = put8bitcmaptile;
parameter list P;
@@
void F(P);

@script:python depends on extract_put8bitcmaptile_decl_void@
F << extract_put8bitcmaptile_decl_void.F;
P << extract_put8bitcmaptile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: putCMYKseparate8bittile
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_putCMYKseparate8bittile_def@
type T;
identifier F = putCMYKseparate8bittile;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_putCMYKseparate8bittile_def@
F << remove_static_putCMYKseparate8bittile_def.F;
T << remove_static_putCMYKseparate8bittile_def.T;
P << remove_static_putCMYKseparate8bittile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_putCMYKseparate8bittile_def_void@
identifier F = putCMYKseparate8bittile;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_putCMYKseparate8bittile_def_void@
F << remove_static_putCMYKseparate8bittile_def_void.F;
P << remove_static_putCMYKseparate8bittile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_putCMYKseparate8bittile_decl@
type T;
identifier F = putCMYKseparate8bittile;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_putCMYKseparate8bittile_decl@
F << remove_static_putCMYKseparate8bittile_decl.F;
T << remove_static_putCMYKseparate8bittile_decl.T;
P << remove_static_putCMYKseparate8bittile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_putCMYKseparate8bittile_decl_void@
identifier F = putCMYKseparate8bittile;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_putCMYKseparate8bittile_decl_void@
F << remove_static_putCMYKseparate8bittile_decl_void.F;
P << remove_static_putCMYKseparate8bittile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_putCMYKseparate8bittile_def@
type T;
identifier F = putCMYKseparate8bittile;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_putCMYKseparate8bittile_def@
F << extract_putCMYKseparate8bittile_def.F;
T << extract_putCMYKseparate8bittile_def.T;
P << extract_putCMYKseparate8bittile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_putCMYKseparate8bittile_def_void@
identifier F = putCMYKseparate8bittile;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_putCMYKseparate8bittile_def_void@
F << extract_putCMYKseparate8bittile_def_void.F;
P << extract_putCMYKseparate8bittile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_putCMYKseparate8bittile_decl@
type T;
identifier F = putCMYKseparate8bittile;
parameter list P;
@@
T F(P);

@script:python depends on extract_putCMYKseparate8bittile_decl@
F << extract_putCMYKseparate8bittile_decl.F;
T << extract_putCMYKseparate8bittile_decl.T;
P << extract_putCMYKseparate8bittile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_putCMYKseparate8bittile_decl_void@
identifier F = putCMYKseparate8bittile;
parameter list P;
@@
void F(P);

@script:python depends on extract_putCMYKseparate8bittile_decl_void@
F << extract_putCMYKseparate8bittile_decl_void.F;
P << extract_putCMYKseparate8bittile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: putRGBAAcontig16bittile
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_putRGBAAcontig16bittile_def@
type T;
identifier F = putRGBAAcontig16bittile;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_putRGBAAcontig16bittile_def@
F << remove_static_putRGBAAcontig16bittile_def.F;
T << remove_static_putRGBAAcontig16bittile_def.T;
P << remove_static_putRGBAAcontig16bittile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_putRGBAAcontig16bittile_def_void@
identifier F = putRGBAAcontig16bittile;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_putRGBAAcontig16bittile_def_void@
F << remove_static_putRGBAAcontig16bittile_def_void.F;
P << remove_static_putRGBAAcontig16bittile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_putRGBAAcontig16bittile_decl@
type T;
identifier F = putRGBAAcontig16bittile;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_putRGBAAcontig16bittile_decl@
F << remove_static_putRGBAAcontig16bittile_decl.F;
T << remove_static_putRGBAAcontig16bittile_decl.T;
P << remove_static_putRGBAAcontig16bittile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_putRGBAAcontig16bittile_decl_void@
identifier F = putRGBAAcontig16bittile;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_putRGBAAcontig16bittile_decl_void@
F << remove_static_putRGBAAcontig16bittile_decl_void.F;
P << remove_static_putRGBAAcontig16bittile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_putRGBAAcontig16bittile_def@
type T;
identifier F = putRGBAAcontig16bittile;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_putRGBAAcontig16bittile_def@
F << extract_putRGBAAcontig16bittile_def.F;
T << extract_putRGBAAcontig16bittile_def.T;
P << extract_putRGBAAcontig16bittile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_putRGBAAcontig16bittile_def_void@
identifier F = putRGBAAcontig16bittile;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_putRGBAAcontig16bittile_def_void@
F << extract_putRGBAAcontig16bittile_def_void.F;
P << extract_putRGBAAcontig16bittile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_putRGBAAcontig16bittile_decl@
type T;
identifier F = putRGBAAcontig16bittile;
parameter list P;
@@
T F(P);

@script:python depends on extract_putRGBAAcontig16bittile_decl@
F << extract_putRGBAAcontig16bittile_decl.F;
T << extract_putRGBAAcontig16bittile_decl.T;
P << extract_putRGBAAcontig16bittile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_putRGBAAcontig16bittile_decl_void@
identifier F = putRGBAAcontig16bittile;
parameter list P;
@@
void F(P);

@script:python depends on extract_putRGBAAcontig16bittile_decl_void@
F << extract_putRGBAAcontig16bittile_decl_void.F;
P << extract_putRGBAAcontig16bittile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: putRGBAAcontig8bittile
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_putRGBAAcontig8bittile_def@
type T;
identifier F = putRGBAAcontig8bittile;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_putRGBAAcontig8bittile_def@
F << remove_static_putRGBAAcontig8bittile_def.F;
T << remove_static_putRGBAAcontig8bittile_def.T;
P << remove_static_putRGBAAcontig8bittile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_putRGBAAcontig8bittile_def_void@
identifier F = putRGBAAcontig8bittile;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_putRGBAAcontig8bittile_def_void@
F << remove_static_putRGBAAcontig8bittile_def_void.F;
P << remove_static_putRGBAAcontig8bittile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_putRGBAAcontig8bittile_decl@
type T;
identifier F = putRGBAAcontig8bittile;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_putRGBAAcontig8bittile_decl@
F << remove_static_putRGBAAcontig8bittile_decl.F;
T << remove_static_putRGBAAcontig8bittile_decl.T;
P << remove_static_putRGBAAcontig8bittile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_putRGBAAcontig8bittile_decl_void@
identifier F = putRGBAAcontig8bittile;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_putRGBAAcontig8bittile_decl_void@
F << remove_static_putRGBAAcontig8bittile_decl_void.F;
P << remove_static_putRGBAAcontig8bittile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_putRGBAAcontig8bittile_def@
type T;
identifier F = putRGBAAcontig8bittile;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_putRGBAAcontig8bittile_def@
F << extract_putRGBAAcontig8bittile_def.F;
T << extract_putRGBAAcontig8bittile_def.T;
P << extract_putRGBAAcontig8bittile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_putRGBAAcontig8bittile_def_void@
identifier F = putRGBAAcontig8bittile;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_putRGBAAcontig8bittile_def_void@
F << extract_putRGBAAcontig8bittile_def_void.F;
P << extract_putRGBAAcontig8bittile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_putRGBAAcontig8bittile_decl@
type T;
identifier F = putRGBAAcontig8bittile;
parameter list P;
@@
T F(P);

@script:python depends on extract_putRGBAAcontig8bittile_decl@
F << extract_putRGBAAcontig8bittile_decl.F;
T << extract_putRGBAAcontig8bittile_decl.T;
P << extract_putRGBAAcontig8bittile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_putRGBAAcontig8bittile_decl_void@
identifier F = putRGBAAcontig8bittile;
parameter list P;
@@
void F(P);

@script:python depends on extract_putRGBAAcontig8bittile_decl_void@
F << extract_putRGBAAcontig8bittile_decl_void.F;
P << extract_putRGBAAcontig8bittile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: putRGBAAseparate16bittile
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_putRGBAAseparate16bittile_def@
type T;
identifier F = putRGBAAseparate16bittile;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_putRGBAAseparate16bittile_def@
F << remove_static_putRGBAAseparate16bittile_def.F;
T << remove_static_putRGBAAseparate16bittile_def.T;
P << remove_static_putRGBAAseparate16bittile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_putRGBAAseparate16bittile_def_void@
identifier F = putRGBAAseparate16bittile;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_putRGBAAseparate16bittile_def_void@
F << remove_static_putRGBAAseparate16bittile_def_void.F;
P << remove_static_putRGBAAseparate16bittile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_putRGBAAseparate16bittile_decl@
type T;
identifier F = putRGBAAseparate16bittile;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_putRGBAAseparate16bittile_decl@
F << remove_static_putRGBAAseparate16bittile_decl.F;
T << remove_static_putRGBAAseparate16bittile_decl.T;
P << remove_static_putRGBAAseparate16bittile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_putRGBAAseparate16bittile_decl_void@
identifier F = putRGBAAseparate16bittile;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_putRGBAAseparate16bittile_decl_void@
F << remove_static_putRGBAAseparate16bittile_decl_void.F;
P << remove_static_putRGBAAseparate16bittile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_putRGBAAseparate16bittile_def@
type T;
identifier F = putRGBAAseparate16bittile;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_putRGBAAseparate16bittile_def@
F << extract_putRGBAAseparate16bittile_def.F;
T << extract_putRGBAAseparate16bittile_def.T;
P << extract_putRGBAAseparate16bittile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_putRGBAAseparate16bittile_def_void@
identifier F = putRGBAAseparate16bittile;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_putRGBAAseparate16bittile_def_void@
F << extract_putRGBAAseparate16bittile_def_void.F;
P << extract_putRGBAAseparate16bittile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_putRGBAAseparate16bittile_decl@
type T;
identifier F = putRGBAAseparate16bittile;
parameter list P;
@@
T F(P);

@script:python depends on extract_putRGBAAseparate16bittile_decl@
F << extract_putRGBAAseparate16bittile_decl.F;
T << extract_putRGBAAseparate16bittile_decl.T;
P << extract_putRGBAAseparate16bittile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_putRGBAAseparate16bittile_decl_void@
identifier F = putRGBAAseparate16bittile;
parameter list P;
@@
void F(P);

@script:python depends on extract_putRGBAAseparate16bittile_decl_void@
F << extract_putRGBAAseparate16bittile_decl_void.F;
P << extract_putRGBAAseparate16bittile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: putRGBAAseparate8bittile
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_putRGBAAseparate8bittile_def@
type T;
identifier F = putRGBAAseparate8bittile;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_putRGBAAseparate8bittile_def@
F << remove_static_putRGBAAseparate8bittile_def.F;
T << remove_static_putRGBAAseparate8bittile_def.T;
P << remove_static_putRGBAAseparate8bittile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_putRGBAAseparate8bittile_def_void@
identifier F = putRGBAAseparate8bittile;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_putRGBAAseparate8bittile_def_void@
F << remove_static_putRGBAAseparate8bittile_def_void.F;
P << remove_static_putRGBAAseparate8bittile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_putRGBAAseparate8bittile_decl@
type T;
identifier F = putRGBAAseparate8bittile;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_putRGBAAseparate8bittile_decl@
F << remove_static_putRGBAAseparate8bittile_decl.F;
T << remove_static_putRGBAAseparate8bittile_decl.T;
P << remove_static_putRGBAAseparate8bittile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_putRGBAAseparate8bittile_decl_void@
identifier F = putRGBAAseparate8bittile;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_putRGBAAseparate8bittile_decl_void@
F << remove_static_putRGBAAseparate8bittile_decl_void.F;
P << remove_static_putRGBAAseparate8bittile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_putRGBAAseparate8bittile_def@
type T;
identifier F = putRGBAAseparate8bittile;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_putRGBAAseparate8bittile_def@
F << extract_putRGBAAseparate8bittile_def.F;
T << extract_putRGBAAseparate8bittile_def.T;
P << extract_putRGBAAseparate8bittile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_putRGBAAseparate8bittile_def_void@
identifier F = putRGBAAseparate8bittile;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_putRGBAAseparate8bittile_def_void@
F << extract_putRGBAAseparate8bittile_def_void.F;
P << extract_putRGBAAseparate8bittile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_putRGBAAseparate8bittile_decl@
type T;
identifier F = putRGBAAseparate8bittile;
parameter list P;
@@
T F(P);

@script:python depends on extract_putRGBAAseparate8bittile_decl@
F << extract_putRGBAAseparate8bittile_decl.F;
T << extract_putRGBAAseparate8bittile_decl.T;
P << extract_putRGBAAseparate8bittile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_putRGBAAseparate8bittile_decl_void@
identifier F = putRGBAAseparate8bittile;
parameter list P;
@@
void F(P);

@script:python depends on extract_putRGBAAseparate8bittile_decl_void@
F << extract_putRGBAAseparate8bittile_decl_void.F;
P << extract_putRGBAAseparate8bittile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: putRGBUAcontig16bittile
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_putRGBUAcontig16bittile_def@
type T;
identifier F = putRGBUAcontig16bittile;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_putRGBUAcontig16bittile_def@
F << remove_static_putRGBUAcontig16bittile_def.F;
T << remove_static_putRGBUAcontig16bittile_def.T;
P << remove_static_putRGBUAcontig16bittile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_putRGBUAcontig16bittile_def_void@
identifier F = putRGBUAcontig16bittile;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_putRGBUAcontig16bittile_def_void@
F << remove_static_putRGBUAcontig16bittile_def_void.F;
P << remove_static_putRGBUAcontig16bittile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_putRGBUAcontig16bittile_decl@
type T;
identifier F = putRGBUAcontig16bittile;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_putRGBUAcontig16bittile_decl@
F << remove_static_putRGBUAcontig16bittile_decl.F;
T << remove_static_putRGBUAcontig16bittile_decl.T;
P << remove_static_putRGBUAcontig16bittile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_putRGBUAcontig16bittile_decl_void@
identifier F = putRGBUAcontig16bittile;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_putRGBUAcontig16bittile_decl_void@
F << remove_static_putRGBUAcontig16bittile_decl_void.F;
P << remove_static_putRGBUAcontig16bittile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_putRGBUAcontig16bittile_def@
type T;
identifier F = putRGBUAcontig16bittile;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_putRGBUAcontig16bittile_def@
F << extract_putRGBUAcontig16bittile_def.F;
T << extract_putRGBUAcontig16bittile_def.T;
P << extract_putRGBUAcontig16bittile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_putRGBUAcontig16bittile_def_void@
identifier F = putRGBUAcontig16bittile;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_putRGBUAcontig16bittile_def_void@
F << extract_putRGBUAcontig16bittile_def_void.F;
P << extract_putRGBUAcontig16bittile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_putRGBUAcontig16bittile_decl@
type T;
identifier F = putRGBUAcontig16bittile;
parameter list P;
@@
T F(P);

@script:python depends on extract_putRGBUAcontig16bittile_decl@
F << extract_putRGBUAcontig16bittile_decl.F;
T << extract_putRGBUAcontig16bittile_decl.T;
P << extract_putRGBUAcontig16bittile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_putRGBUAcontig16bittile_decl_void@
identifier F = putRGBUAcontig16bittile;
parameter list P;
@@
void F(P);

@script:python depends on extract_putRGBUAcontig16bittile_decl_void@
F << extract_putRGBUAcontig16bittile_decl_void.F;
P << extract_putRGBUAcontig16bittile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: putRGBUAcontig8bittile
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_putRGBUAcontig8bittile_def@
type T;
identifier F = putRGBUAcontig8bittile;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_putRGBUAcontig8bittile_def@
F << remove_static_putRGBUAcontig8bittile_def.F;
T << remove_static_putRGBUAcontig8bittile_def.T;
P << remove_static_putRGBUAcontig8bittile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_putRGBUAcontig8bittile_def_void@
identifier F = putRGBUAcontig8bittile;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_putRGBUAcontig8bittile_def_void@
F << remove_static_putRGBUAcontig8bittile_def_void.F;
P << remove_static_putRGBUAcontig8bittile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_putRGBUAcontig8bittile_decl@
type T;
identifier F = putRGBUAcontig8bittile;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_putRGBUAcontig8bittile_decl@
F << remove_static_putRGBUAcontig8bittile_decl.F;
T << remove_static_putRGBUAcontig8bittile_decl.T;
P << remove_static_putRGBUAcontig8bittile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_putRGBUAcontig8bittile_decl_void@
identifier F = putRGBUAcontig8bittile;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_putRGBUAcontig8bittile_decl_void@
F << remove_static_putRGBUAcontig8bittile_decl_void.F;
P << remove_static_putRGBUAcontig8bittile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_putRGBUAcontig8bittile_def@
type T;
identifier F = putRGBUAcontig8bittile;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_putRGBUAcontig8bittile_def@
F << extract_putRGBUAcontig8bittile_def.F;
T << extract_putRGBUAcontig8bittile_def.T;
P << extract_putRGBUAcontig8bittile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_putRGBUAcontig8bittile_def_void@
identifier F = putRGBUAcontig8bittile;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_putRGBUAcontig8bittile_def_void@
F << extract_putRGBUAcontig8bittile_def_void.F;
P << extract_putRGBUAcontig8bittile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_putRGBUAcontig8bittile_decl@
type T;
identifier F = putRGBUAcontig8bittile;
parameter list P;
@@
T F(P);

@script:python depends on extract_putRGBUAcontig8bittile_decl@
F << extract_putRGBUAcontig8bittile_decl.F;
T << extract_putRGBUAcontig8bittile_decl.T;
P << extract_putRGBUAcontig8bittile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_putRGBUAcontig8bittile_decl_void@
identifier F = putRGBUAcontig8bittile;
parameter list P;
@@
void F(P);

@script:python depends on extract_putRGBUAcontig8bittile_decl_void@
F << extract_putRGBUAcontig8bittile_decl_void.F;
P << extract_putRGBUAcontig8bittile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: putRGBUAseparate16bittile
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_putRGBUAseparate16bittile_def@
type T;
identifier F = putRGBUAseparate16bittile;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_putRGBUAseparate16bittile_def@
F << remove_static_putRGBUAseparate16bittile_def.F;
T << remove_static_putRGBUAseparate16bittile_def.T;
P << remove_static_putRGBUAseparate16bittile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_putRGBUAseparate16bittile_def_void@
identifier F = putRGBUAseparate16bittile;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_putRGBUAseparate16bittile_def_void@
F << remove_static_putRGBUAseparate16bittile_def_void.F;
P << remove_static_putRGBUAseparate16bittile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_putRGBUAseparate16bittile_decl@
type T;
identifier F = putRGBUAseparate16bittile;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_putRGBUAseparate16bittile_decl@
F << remove_static_putRGBUAseparate16bittile_decl.F;
T << remove_static_putRGBUAseparate16bittile_decl.T;
P << remove_static_putRGBUAseparate16bittile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_putRGBUAseparate16bittile_decl_void@
identifier F = putRGBUAseparate16bittile;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_putRGBUAseparate16bittile_decl_void@
F << remove_static_putRGBUAseparate16bittile_decl_void.F;
P << remove_static_putRGBUAseparate16bittile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_putRGBUAseparate16bittile_def@
type T;
identifier F = putRGBUAseparate16bittile;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_putRGBUAseparate16bittile_def@
F << extract_putRGBUAseparate16bittile_def.F;
T << extract_putRGBUAseparate16bittile_def.T;
P << extract_putRGBUAseparate16bittile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_putRGBUAseparate16bittile_def_void@
identifier F = putRGBUAseparate16bittile;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_putRGBUAseparate16bittile_def_void@
F << extract_putRGBUAseparate16bittile_def_void.F;
P << extract_putRGBUAseparate16bittile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_putRGBUAseparate16bittile_decl@
type T;
identifier F = putRGBUAseparate16bittile;
parameter list P;
@@
T F(P);

@script:python depends on extract_putRGBUAseparate16bittile_decl@
F << extract_putRGBUAseparate16bittile_decl.F;
T << extract_putRGBUAseparate16bittile_decl.T;
P << extract_putRGBUAseparate16bittile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_putRGBUAseparate16bittile_decl_void@
identifier F = putRGBUAseparate16bittile;
parameter list P;
@@
void F(P);

@script:python depends on extract_putRGBUAseparate16bittile_decl_void@
F << extract_putRGBUAseparate16bittile_decl_void.F;
P << extract_putRGBUAseparate16bittile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: putRGBUAseparate8bittile
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_putRGBUAseparate8bittile_def@
type T;
identifier F = putRGBUAseparate8bittile;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_putRGBUAseparate8bittile_def@
F << remove_static_putRGBUAseparate8bittile_def.F;
T << remove_static_putRGBUAseparate8bittile_def.T;
P << remove_static_putRGBUAseparate8bittile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_putRGBUAseparate8bittile_def_void@
identifier F = putRGBUAseparate8bittile;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_putRGBUAseparate8bittile_def_void@
F << remove_static_putRGBUAseparate8bittile_def_void.F;
P << remove_static_putRGBUAseparate8bittile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_putRGBUAseparate8bittile_decl@
type T;
identifier F = putRGBUAseparate8bittile;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_putRGBUAseparate8bittile_decl@
F << remove_static_putRGBUAseparate8bittile_decl.F;
T << remove_static_putRGBUAseparate8bittile_decl.T;
P << remove_static_putRGBUAseparate8bittile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_putRGBUAseparate8bittile_decl_void@
identifier F = putRGBUAseparate8bittile;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_putRGBUAseparate8bittile_decl_void@
F << remove_static_putRGBUAseparate8bittile_decl_void.F;
P << remove_static_putRGBUAseparate8bittile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_putRGBUAseparate8bittile_def@
type T;
identifier F = putRGBUAseparate8bittile;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_putRGBUAseparate8bittile_def@
F << extract_putRGBUAseparate8bittile_def.F;
T << extract_putRGBUAseparate8bittile_def.T;
P << extract_putRGBUAseparate8bittile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_putRGBUAseparate8bittile_def_void@
identifier F = putRGBUAseparate8bittile;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_putRGBUAseparate8bittile_def_void@
F << extract_putRGBUAseparate8bittile_def_void.F;
P << extract_putRGBUAseparate8bittile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_putRGBUAseparate8bittile_decl@
type T;
identifier F = putRGBUAseparate8bittile;
parameter list P;
@@
T F(P);

@script:python depends on extract_putRGBUAseparate8bittile_decl@
F << extract_putRGBUAseparate8bittile_decl.F;
T << extract_putRGBUAseparate8bittile_decl.T;
P << extract_putRGBUAseparate8bittile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_putRGBUAseparate8bittile_decl_void@
identifier F = putRGBUAseparate8bittile;
parameter list P;
@@
void F(P);

@script:python depends on extract_putRGBUAseparate8bittile_decl_void@
F << extract_putRGBUAseparate8bittile_decl_void.F;
P << extract_putRGBUAseparate8bittile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: putRGBcontig16bittile
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_putRGBcontig16bittile_def@
type T;
identifier F = putRGBcontig16bittile;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_putRGBcontig16bittile_def@
F << remove_static_putRGBcontig16bittile_def.F;
T << remove_static_putRGBcontig16bittile_def.T;
P << remove_static_putRGBcontig16bittile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_putRGBcontig16bittile_def_void@
identifier F = putRGBcontig16bittile;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_putRGBcontig16bittile_def_void@
F << remove_static_putRGBcontig16bittile_def_void.F;
P << remove_static_putRGBcontig16bittile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_putRGBcontig16bittile_decl@
type T;
identifier F = putRGBcontig16bittile;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_putRGBcontig16bittile_decl@
F << remove_static_putRGBcontig16bittile_decl.F;
T << remove_static_putRGBcontig16bittile_decl.T;
P << remove_static_putRGBcontig16bittile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_putRGBcontig16bittile_decl_void@
identifier F = putRGBcontig16bittile;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_putRGBcontig16bittile_decl_void@
F << remove_static_putRGBcontig16bittile_decl_void.F;
P << remove_static_putRGBcontig16bittile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_putRGBcontig16bittile_def@
type T;
identifier F = putRGBcontig16bittile;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_putRGBcontig16bittile_def@
F << extract_putRGBcontig16bittile_def.F;
T << extract_putRGBcontig16bittile_def.T;
P << extract_putRGBcontig16bittile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_putRGBcontig16bittile_def_void@
identifier F = putRGBcontig16bittile;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_putRGBcontig16bittile_def_void@
F << extract_putRGBcontig16bittile_def_void.F;
P << extract_putRGBcontig16bittile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_putRGBcontig16bittile_decl@
type T;
identifier F = putRGBcontig16bittile;
parameter list P;
@@
T F(P);

@script:python depends on extract_putRGBcontig16bittile_decl@
F << extract_putRGBcontig16bittile_decl.F;
T << extract_putRGBcontig16bittile_decl.T;
P << extract_putRGBcontig16bittile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_putRGBcontig16bittile_decl_void@
identifier F = putRGBcontig16bittile;
parameter list P;
@@
void F(P);

@script:python depends on extract_putRGBcontig16bittile_decl_void@
F << extract_putRGBcontig16bittile_decl_void.F;
P << extract_putRGBcontig16bittile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: putRGBcontig8bitCMYKMaptile
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_putRGBcontig8bitCMYKMaptile_def@
type T;
identifier F = putRGBcontig8bitCMYKMaptile;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_putRGBcontig8bitCMYKMaptile_def@
F << remove_static_putRGBcontig8bitCMYKMaptile_def.F;
T << remove_static_putRGBcontig8bitCMYKMaptile_def.T;
P << remove_static_putRGBcontig8bitCMYKMaptile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_putRGBcontig8bitCMYKMaptile_def_void@
identifier F = putRGBcontig8bitCMYKMaptile;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_putRGBcontig8bitCMYKMaptile_def_void@
F << remove_static_putRGBcontig8bitCMYKMaptile_def_void.F;
P << remove_static_putRGBcontig8bitCMYKMaptile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_putRGBcontig8bitCMYKMaptile_decl@
type T;
identifier F = putRGBcontig8bitCMYKMaptile;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_putRGBcontig8bitCMYKMaptile_decl@
F << remove_static_putRGBcontig8bitCMYKMaptile_decl.F;
T << remove_static_putRGBcontig8bitCMYKMaptile_decl.T;
P << remove_static_putRGBcontig8bitCMYKMaptile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_putRGBcontig8bitCMYKMaptile_decl_void@
identifier F = putRGBcontig8bitCMYKMaptile;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_putRGBcontig8bitCMYKMaptile_decl_void@
F << remove_static_putRGBcontig8bitCMYKMaptile_decl_void.F;
P << remove_static_putRGBcontig8bitCMYKMaptile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_putRGBcontig8bitCMYKMaptile_def@
type T;
identifier F = putRGBcontig8bitCMYKMaptile;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_putRGBcontig8bitCMYKMaptile_def@
F << extract_putRGBcontig8bitCMYKMaptile_def.F;
T << extract_putRGBcontig8bitCMYKMaptile_def.T;
P << extract_putRGBcontig8bitCMYKMaptile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_putRGBcontig8bitCMYKMaptile_def_void@
identifier F = putRGBcontig8bitCMYKMaptile;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_putRGBcontig8bitCMYKMaptile_def_void@
F << extract_putRGBcontig8bitCMYKMaptile_def_void.F;
P << extract_putRGBcontig8bitCMYKMaptile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_putRGBcontig8bitCMYKMaptile_decl@
type T;
identifier F = putRGBcontig8bitCMYKMaptile;
parameter list P;
@@
T F(P);

@script:python depends on extract_putRGBcontig8bitCMYKMaptile_decl@
F << extract_putRGBcontig8bitCMYKMaptile_decl.F;
T << extract_putRGBcontig8bitCMYKMaptile_decl.T;
P << extract_putRGBcontig8bitCMYKMaptile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_putRGBcontig8bitCMYKMaptile_decl_void@
identifier F = putRGBcontig8bitCMYKMaptile;
parameter list P;
@@
void F(P);

@script:python depends on extract_putRGBcontig8bitCMYKMaptile_decl_void@
F << extract_putRGBcontig8bitCMYKMaptile_decl_void.F;
P << extract_putRGBcontig8bitCMYKMaptile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: putRGBcontig8bitCMYKtile
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_putRGBcontig8bitCMYKtile_def@
type T;
identifier F = putRGBcontig8bitCMYKtile;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_putRGBcontig8bitCMYKtile_def@
F << remove_static_putRGBcontig8bitCMYKtile_def.F;
T << remove_static_putRGBcontig8bitCMYKtile_def.T;
P << remove_static_putRGBcontig8bitCMYKtile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_putRGBcontig8bitCMYKtile_def_void@
identifier F = putRGBcontig8bitCMYKtile;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_putRGBcontig8bitCMYKtile_def_void@
F << remove_static_putRGBcontig8bitCMYKtile_def_void.F;
P << remove_static_putRGBcontig8bitCMYKtile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_putRGBcontig8bitCMYKtile_decl@
type T;
identifier F = putRGBcontig8bitCMYKtile;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_putRGBcontig8bitCMYKtile_decl@
F << remove_static_putRGBcontig8bitCMYKtile_decl.F;
T << remove_static_putRGBcontig8bitCMYKtile_decl.T;
P << remove_static_putRGBcontig8bitCMYKtile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_putRGBcontig8bitCMYKtile_decl_void@
identifier F = putRGBcontig8bitCMYKtile;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_putRGBcontig8bitCMYKtile_decl_void@
F << remove_static_putRGBcontig8bitCMYKtile_decl_void.F;
P << remove_static_putRGBcontig8bitCMYKtile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_putRGBcontig8bitCMYKtile_def@
type T;
identifier F = putRGBcontig8bitCMYKtile;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_putRGBcontig8bitCMYKtile_def@
F << extract_putRGBcontig8bitCMYKtile_def.F;
T << extract_putRGBcontig8bitCMYKtile_def.T;
P << extract_putRGBcontig8bitCMYKtile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_putRGBcontig8bitCMYKtile_def_void@
identifier F = putRGBcontig8bitCMYKtile;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_putRGBcontig8bitCMYKtile_def_void@
F << extract_putRGBcontig8bitCMYKtile_def_void.F;
P << extract_putRGBcontig8bitCMYKtile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_putRGBcontig8bitCMYKtile_decl@
type T;
identifier F = putRGBcontig8bitCMYKtile;
parameter list P;
@@
T F(P);

@script:python depends on extract_putRGBcontig8bitCMYKtile_decl@
F << extract_putRGBcontig8bitCMYKtile_decl.F;
T << extract_putRGBcontig8bitCMYKtile_decl.T;
P << extract_putRGBcontig8bitCMYKtile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_putRGBcontig8bitCMYKtile_decl_void@
identifier F = putRGBcontig8bitCMYKtile;
parameter list P;
@@
void F(P);

@script:python depends on extract_putRGBcontig8bitCMYKtile_decl_void@
F << extract_putRGBcontig8bitCMYKtile_decl_void.F;
P << extract_putRGBcontig8bitCMYKtile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: putRGBcontig8bittile
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_putRGBcontig8bittile_def@
type T;
identifier F = putRGBcontig8bittile;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_putRGBcontig8bittile_def@
F << remove_static_putRGBcontig8bittile_def.F;
T << remove_static_putRGBcontig8bittile_def.T;
P << remove_static_putRGBcontig8bittile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_putRGBcontig8bittile_def_void@
identifier F = putRGBcontig8bittile;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_putRGBcontig8bittile_def_void@
F << remove_static_putRGBcontig8bittile_def_void.F;
P << remove_static_putRGBcontig8bittile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_putRGBcontig8bittile_decl@
type T;
identifier F = putRGBcontig8bittile;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_putRGBcontig8bittile_decl@
F << remove_static_putRGBcontig8bittile_decl.F;
T << remove_static_putRGBcontig8bittile_decl.T;
P << remove_static_putRGBcontig8bittile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_putRGBcontig8bittile_decl_void@
identifier F = putRGBcontig8bittile;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_putRGBcontig8bittile_decl_void@
F << remove_static_putRGBcontig8bittile_decl_void.F;
P << remove_static_putRGBcontig8bittile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_putRGBcontig8bittile_def@
type T;
identifier F = putRGBcontig8bittile;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_putRGBcontig8bittile_def@
F << extract_putRGBcontig8bittile_def.F;
T << extract_putRGBcontig8bittile_def.T;
P << extract_putRGBcontig8bittile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_putRGBcontig8bittile_def_void@
identifier F = putRGBcontig8bittile;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_putRGBcontig8bittile_def_void@
F << extract_putRGBcontig8bittile_def_void.F;
P << extract_putRGBcontig8bittile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_putRGBcontig8bittile_decl@
type T;
identifier F = putRGBcontig8bittile;
parameter list P;
@@
T F(P);

@script:python depends on extract_putRGBcontig8bittile_decl@
F << extract_putRGBcontig8bittile_decl.F;
T << extract_putRGBcontig8bittile_decl.T;
P << extract_putRGBcontig8bittile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_putRGBcontig8bittile_decl_void@
identifier F = putRGBcontig8bittile;
parameter list P;
@@
void F(P);

@script:python depends on extract_putRGBcontig8bittile_decl_void@
F << extract_putRGBcontig8bittile_decl_void.F;
P << extract_putRGBcontig8bittile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: putRGBseparate16bittile
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_putRGBseparate16bittile_def@
type T;
identifier F = putRGBseparate16bittile;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_putRGBseparate16bittile_def@
F << remove_static_putRGBseparate16bittile_def.F;
T << remove_static_putRGBseparate16bittile_def.T;
P << remove_static_putRGBseparate16bittile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_putRGBseparate16bittile_def_void@
identifier F = putRGBseparate16bittile;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_putRGBseparate16bittile_def_void@
F << remove_static_putRGBseparate16bittile_def_void.F;
P << remove_static_putRGBseparate16bittile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_putRGBseparate16bittile_decl@
type T;
identifier F = putRGBseparate16bittile;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_putRGBseparate16bittile_decl@
F << remove_static_putRGBseparate16bittile_decl.F;
T << remove_static_putRGBseparate16bittile_decl.T;
P << remove_static_putRGBseparate16bittile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_putRGBseparate16bittile_decl_void@
identifier F = putRGBseparate16bittile;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_putRGBseparate16bittile_decl_void@
F << remove_static_putRGBseparate16bittile_decl_void.F;
P << remove_static_putRGBseparate16bittile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_putRGBseparate16bittile_def@
type T;
identifier F = putRGBseparate16bittile;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_putRGBseparate16bittile_def@
F << extract_putRGBseparate16bittile_def.F;
T << extract_putRGBseparate16bittile_def.T;
P << extract_putRGBseparate16bittile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_putRGBseparate16bittile_def_void@
identifier F = putRGBseparate16bittile;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_putRGBseparate16bittile_def_void@
F << extract_putRGBseparate16bittile_def_void.F;
P << extract_putRGBseparate16bittile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_putRGBseparate16bittile_decl@
type T;
identifier F = putRGBseparate16bittile;
parameter list P;
@@
T F(P);

@script:python depends on extract_putRGBseparate16bittile_decl@
F << extract_putRGBseparate16bittile_decl.F;
T << extract_putRGBseparate16bittile_decl.T;
P << extract_putRGBseparate16bittile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_putRGBseparate16bittile_decl_void@
identifier F = putRGBseparate16bittile;
parameter list P;
@@
void F(P);

@script:python depends on extract_putRGBseparate16bittile_decl_void@
F << extract_putRGBseparate16bittile_decl_void.F;
P << extract_putRGBseparate16bittile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: putRGBseparate8bittile
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_putRGBseparate8bittile_def@
type T;
identifier F = putRGBseparate8bittile;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_putRGBseparate8bittile_def@
F << remove_static_putRGBseparate8bittile_def.F;
T << remove_static_putRGBseparate8bittile_def.T;
P << remove_static_putRGBseparate8bittile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_putRGBseparate8bittile_def_void@
identifier F = putRGBseparate8bittile;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_putRGBseparate8bittile_def_void@
F << remove_static_putRGBseparate8bittile_def_void.F;
P << remove_static_putRGBseparate8bittile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_putRGBseparate8bittile_decl@
type T;
identifier F = putRGBseparate8bittile;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_putRGBseparate8bittile_decl@
F << remove_static_putRGBseparate8bittile_decl.F;
T << remove_static_putRGBseparate8bittile_decl.T;
P << remove_static_putRGBseparate8bittile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_putRGBseparate8bittile_decl_void@
identifier F = putRGBseparate8bittile;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_putRGBseparate8bittile_decl_void@
F << remove_static_putRGBseparate8bittile_decl_void.F;
P << remove_static_putRGBseparate8bittile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_putRGBseparate8bittile_def@
type T;
identifier F = putRGBseparate8bittile;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_putRGBseparate8bittile_def@
F << extract_putRGBseparate8bittile_def.F;
T << extract_putRGBseparate8bittile_def.T;
P << extract_putRGBseparate8bittile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_putRGBseparate8bittile_def_void@
identifier F = putRGBseparate8bittile;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_putRGBseparate8bittile_def_void@
F << extract_putRGBseparate8bittile_def_void.F;
P << extract_putRGBseparate8bittile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_putRGBseparate8bittile_decl@
type T;
identifier F = putRGBseparate8bittile;
parameter list P;
@@
T F(P);

@script:python depends on extract_putRGBseparate8bittile_decl@
F << extract_putRGBseparate8bittile_decl.F;
T << extract_putRGBseparate8bittile_decl.T;
P << extract_putRGBseparate8bittile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_putRGBseparate8bittile_decl_void@
identifier F = putRGBseparate8bittile;
parameter list P;
@@
void F(P);

@script:python depends on extract_putRGBseparate8bittile_decl_void@
F << extract_putRGBseparate8bittile_decl_void.F;
P << extract_putRGBseparate8bittile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: putagreytile
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_putagreytile_def@
type T;
identifier F = putagreytile;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_putagreytile_def@
F << remove_static_putagreytile_def.F;
T << remove_static_putagreytile_def.T;
P << remove_static_putagreytile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_putagreytile_def_void@
identifier F = putagreytile;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_putagreytile_def_void@
F << remove_static_putagreytile_def_void.F;
P << remove_static_putagreytile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_putagreytile_decl@
type T;
identifier F = putagreytile;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_putagreytile_decl@
F << remove_static_putagreytile_decl.F;
T << remove_static_putagreytile_decl.T;
P << remove_static_putagreytile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_putagreytile_decl_void@
identifier F = putagreytile;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_putagreytile_decl_void@
F << remove_static_putagreytile_decl_void.F;
P << remove_static_putagreytile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_putagreytile_def@
type T;
identifier F = putagreytile;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_putagreytile_def@
F << extract_putagreytile_def.F;
T << extract_putagreytile_def.T;
P << extract_putagreytile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_putagreytile_def_void@
identifier F = putagreytile;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_putagreytile_def_void@
F << extract_putagreytile_def_void.F;
P << extract_putagreytile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_putagreytile_decl@
type T;
identifier F = putagreytile;
parameter list P;
@@
T F(P);

@script:python depends on extract_putagreytile_decl@
F << extract_putagreytile_decl.F;
T << extract_putagreytile_decl.T;
P << extract_putagreytile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_putagreytile_decl_void@
identifier F = putagreytile;
parameter list P;
@@
void F(P);

@script:python depends on extract_putagreytile_decl_void@
F << extract_putagreytile_decl_void.F;
P << extract_putagreytile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: putcontig8bitYCbCr11tile
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_putcontig8bitYCbCr11tile_def@
type T;
identifier F = putcontig8bitYCbCr11tile;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_putcontig8bitYCbCr11tile_def@
F << remove_static_putcontig8bitYCbCr11tile_def.F;
T << remove_static_putcontig8bitYCbCr11tile_def.T;
P << remove_static_putcontig8bitYCbCr11tile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_putcontig8bitYCbCr11tile_def_void@
identifier F = putcontig8bitYCbCr11tile;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_putcontig8bitYCbCr11tile_def_void@
F << remove_static_putcontig8bitYCbCr11tile_def_void.F;
P << remove_static_putcontig8bitYCbCr11tile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_putcontig8bitYCbCr11tile_decl@
type T;
identifier F = putcontig8bitYCbCr11tile;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_putcontig8bitYCbCr11tile_decl@
F << remove_static_putcontig8bitYCbCr11tile_decl.F;
T << remove_static_putcontig8bitYCbCr11tile_decl.T;
P << remove_static_putcontig8bitYCbCr11tile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_putcontig8bitYCbCr11tile_decl_void@
identifier F = putcontig8bitYCbCr11tile;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_putcontig8bitYCbCr11tile_decl_void@
F << remove_static_putcontig8bitYCbCr11tile_decl_void.F;
P << remove_static_putcontig8bitYCbCr11tile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_putcontig8bitYCbCr11tile_def@
type T;
identifier F = putcontig8bitYCbCr11tile;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_putcontig8bitYCbCr11tile_def@
F << extract_putcontig8bitYCbCr11tile_def.F;
T << extract_putcontig8bitYCbCr11tile_def.T;
P << extract_putcontig8bitYCbCr11tile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_putcontig8bitYCbCr11tile_def_void@
identifier F = putcontig8bitYCbCr11tile;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_putcontig8bitYCbCr11tile_def_void@
F << extract_putcontig8bitYCbCr11tile_def_void.F;
P << extract_putcontig8bitYCbCr11tile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_putcontig8bitYCbCr11tile_decl@
type T;
identifier F = putcontig8bitYCbCr11tile;
parameter list P;
@@
T F(P);

@script:python depends on extract_putcontig8bitYCbCr11tile_decl@
F << extract_putcontig8bitYCbCr11tile_decl.F;
T << extract_putcontig8bitYCbCr11tile_decl.T;
P << extract_putcontig8bitYCbCr11tile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_putcontig8bitYCbCr11tile_decl_void@
identifier F = putcontig8bitYCbCr11tile;
parameter list P;
@@
void F(P);

@script:python depends on extract_putcontig8bitYCbCr11tile_decl_void@
F << extract_putcontig8bitYCbCr11tile_decl_void.F;
P << extract_putcontig8bitYCbCr11tile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: putcontig8bitYCbCr12tile
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_putcontig8bitYCbCr12tile_def@
type T;
identifier F = putcontig8bitYCbCr12tile;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_putcontig8bitYCbCr12tile_def@
F << remove_static_putcontig8bitYCbCr12tile_def.F;
T << remove_static_putcontig8bitYCbCr12tile_def.T;
P << remove_static_putcontig8bitYCbCr12tile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_putcontig8bitYCbCr12tile_def_void@
identifier F = putcontig8bitYCbCr12tile;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_putcontig8bitYCbCr12tile_def_void@
F << remove_static_putcontig8bitYCbCr12tile_def_void.F;
P << remove_static_putcontig8bitYCbCr12tile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_putcontig8bitYCbCr12tile_decl@
type T;
identifier F = putcontig8bitYCbCr12tile;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_putcontig8bitYCbCr12tile_decl@
F << remove_static_putcontig8bitYCbCr12tile_decl.F;
T << remove_static_putcontig8bitYCbCr12tile_decl.T;
P << remove_static_putcontig8bitYCbCr12tile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_putcontig8bitYCbCr12tile_decl_void@
identifier F = putcontig8bitYCbCr12tile;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_putcontig8bitYCbCr12tile_decl_void@
F << remove_static_putcontig8bitYCbCr12tile_decl_void.F;
P << remove_static_putcontig8bitYCbCr12tile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_putcontig8bitYCbCr12tile_def@
type T;
identifier F = putcontig8bitYCbCr12tile;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_putcontig8bitYCbCr12tile_def@
F << extract_putcontig8bitYCbCr12tile_def.F;
T << extract_putcontig8bitYCbCr12tile_def.T;
P << extract_putcontig8bitYCbCr12tile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_putcontig8bitYCbCr12tile_def_void@
identifier F = putcontig8bitYCbCr12tile;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_putcontig8bitYCbCr12tile_def_void@
F << extract_putcontig8bitYCbCr12tile_def_void.F;
P << extract_putcontig8bitYCbCr12tile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_putcontig8bitYCbCr12tile_decl@
type T;
identifier F = putcontig8bitYCbCr12tile;
parameter list P;
@@
T F(P);

@script:python depends on extract_putcontig8bitYCbCr12tile_decl@
F << extract_putcontig8bitYCbCr12tile_decl.F;
T << extract_putcontig8bitYCbCr12tile_decl.T;
P << extract_putcontig8bitYCbCr12tile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_putcontig8bitYCbCr12tile_decl_void@
identifier F = putcontig8bitYCbCr12tile;
parameter list P;
@@
void F(P);

@script:python depends on extract_putcontig8bitYCbCr12tile_decl_void@
F << extract_putcontig8bitYCbCr12tile_decl_void.F;
P << extract_putcontig8bitYCbCr12tile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: putcontig8bitYCbCr21tile
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_putcontig8bitYCbCr21tile_def@
type T;
identifier F = putcontig8bitYCbCr21tile;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_putcontig8bitYCbCr21tile_def@
F << remove_static_putcontig8bitYCbCr21tile_def.F;
T << remove_static_putcontig8bitYCbCr21tile_def.T;
P << remove_static_putcontig8bitYCbCr21tile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_putcontig8bitYCbCr21tile_def_void@
identifier F = putcontig8bitYCbCr21tile;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_putcontig8bitYCbCr21tile_def_void@
F << remove_static_putcontig8bitYCbCr21tile_def_void.F;
P << remove_static_putcontig8bitYCbCr21tile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_putcontig8bitYCbCr21tile_decl@
type T;
identifier F = putcontig8bitYCbCr21tile;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_putcontig8bitYCbCr21tile_decl@
F << remove_static_putcontig8bitYCbCr21tile_decl.F;
T << remove_static_putcontig8bitYCbCr21tile_decl.T;
P << remove_static_putcontig8bitYCbCr21tile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_putcontig8bitYCbCr21tile_decl_void@
identifier F = putcontig8bitYCbCr21tile;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_putcontig8bitYCbCr21tile_decl_void@
F << remove_static_putcontig8bitYCbCr21tile_decl_void.F;
P << remove_static_putcontig8bitYCbCr21tile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_putcontig8bitYCbCr21tile_def@
type T;
identifier F = putcontig8bitYCbCr21tile;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_putcontig8bitYCbCr21tile_def@
F << extract_putcontig8bitYCbCr21tile_def.F;
T << extract_putcontig8bitYCbCr21tile_def.T;
P << extract_putcontig8bitYCbCr21tile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_putcontig8bitYCbCr21tile_def_void@
identifier F = putcontig8bitYCbCr21tile;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_putcontig8bitYCbCr21tile_def_void@
F << extract_putcontig8bitYCbCr21tile_def_void.F;
P << extract_putcontig8bitYCbCr21tile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_putcontig8bitYCbCr21tile_decl@
type T;
identifier F = putcontig8bitYCbCr21tile;
parameter list P;
@@
T F(P);

@script:python depends on extract_putcontig8bitYCbCr21tile_decl@
F << extract_putcontig8bitYCbCr21tile_decl.F;
T << extract_putcontig8bitYCbCr21tile_decl.T;
P << extract_putcontig8bitYCbCr21tile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_putcontig8bitYCbCr21tile_decl_void@
identifier F = putcontig8bitYCbCr21tile;
parameter list P;
@@
void F(P);

@script:python depends on extract_putcontig8bitYCbCr21tile_decl_void@
F << extract_putcontig8bitYCbCr21tile_decl_void.F;
P << extract_putcontig8bitYCbCr21tile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: putcontig8bitYCbCr22tile
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_putcontig8bitYCbCr22tile_def@
type T;
identifier F = putcontig8bitYCbCr22tile;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_putcontig8bitYCbCr22tile_def@
F << remove_static_putcontig8bitYCbCr22tile_def.F;
T << remove_static_putcontig8bitYCbCr22tile_def.T;
P << remove_static_putcontig8bitYCbCr22tile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_putcontig8bitYCbCr22tile_def_void@
identifier F = putcontig8bitYCbCr22tile;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_putcontig8bitYCbCr22tile_def_void@
F << remove_static_putcontig8bitYCbCr22tile_def_void.F;
P << remove_static_putcontig8bitYCbCr22tile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_putcontig8bitYCbCr22tile_decl@
type T;
identifier F = putcontig8bitYCbCr22tile;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_putcontig8bitYCbCr22tile_decl@
F << remove_static_putcontig8bitYCbCr22tile_decl.F;
T << remove_static_putcontig8bitYCbCr22tile_decl.T;
P << remove_static_putcontig8bitYCbCr22tile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_putcontig8bitYCbCr22tile_decl_void@
identifier F = putcontig8bitYCbCr22tile;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_putcontig8bitYCbCr22tile_decl_void@
F << remove_static_putcontig8bitYCbCr22tile_decl_void.F;
P << remove_static_putcontig8bitYCbCr22tile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_putcontig8bitYCbCr22tile_def@
type T;
identifier F = putcontig8bitYCbCr22tile;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_putcontig8bitYCbCr22tile_def@
F << extract_putcontig8bitYCbCr22tile_def.F;
T << extract_putcontig8bitYCbCr22tile_def.T;
P << extract_putcontig8bitYCbCr22tile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_putcontig8bitYCbCr22tile_def_void@
identifier F = putcontig8bitYCbCr22tile;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_putcontig8bitYCbCr22tile_def_void@
F << extract_putcontig8bitYCbCr22tile_def_void.F;
P << extract_putcontig8bitYCbCr22tile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_putcontig8bitYCbCr22tile_decl@
type T;
identifier F = putcontig8bitYCbCr22tile;
parameter list P;
@@
T F(P);

@script:python depends on extract_putcontig8bitYCbCr22tile_decl@
F << extract_putcontig8bitYCbCr22tile_decl.F;
T << extract_putcontig8bitYCbCr22tile_decl.T;
P << extract_putcontig8bitYCbCr22tile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_putcontig8bitYCbCr22tile_decl_void@
identifier F = putcontig8bitYCbCr22tile;
parameter list P;
@@
void F(P);

@script:python depends on extract_putcontig8bitYCbCr22tile_decl_void@
F << extract_putcontig8bitYCbCr22tile_decl_void.F;
P << extract_putcontig8bitYCbCr22tile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: putcontig8bitYCbCr41tile
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_putcontig8bitYCbCr41tile_def@
type T;
identifier F = putcontig8bitYCbCr41tile;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_putcontig8bitYCbCr41tile_def@
F << remove_static_putcontig8bitYCbCr41tile_def.F;
T << remove_static_putcontig8bitYCbCr41tile_def.T;
P << remove_static_putcontig8bitYCbCr41tile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_putcontig8bitYCbCr41tile_def_void@
identifier F = putcontig8bitYCbCr41tile;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_putcontig8bitYCbCr41tile_def_void@
F << remove_static_putcontig8bitYCbCr41tile_def_void.F;
P << remove_static_putcontig8bitYCbCr41tile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_putcontig8bitYCbCr41tile_decl@
type T;
identifier F = putcontig8bitYCbCr41tile;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_putcontig8bitYCbCr41tile_decl@
F << remove_static_putcontig8bitYCbCr41tile_decl.F;
T << remove_static_putcontig8bitYCbCr41tile_decl.T;
P << remove_static_putcontig8bitYCbCr41tile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_putcontig8bitYCbCr41tile_decl_void@
identifier F = putcontig8bitYCbCr41tile;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_putcontig8bitYCbCr41tile_decl_void@
F << remove_static_putcontig8bitYCbCr41tile_decl_void.F;
P << remove_static_putcontig8bitYCbCr41tile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_putcontig8bitYCbCr41tile_def@
type T;
identifier F = putcontig8bitYCbCr41tile;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_putcontig8bitYCbCr41tile_def@
F << extract_putcontig8bitYCbCr41tile_def.F;
T << extract_putcontig8bitYCbCr41tile_def.T;
P << extract_putcontig8bitYCbCr41tile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_putcontig8bitYCbCr41tile_def_void@
identifier F = putcontig8bitYCbCr41tile;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_putcontig8bitYCbCr41tile_def_void@
F << extract_putcontig8bitYCbCr41tile_def_void.F;
P << extract_putcontig8bitYCbCr41tile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_putcontig8bitYCbCr41tile_decl@
type T;
identifier F = putcontig8bitYCbCr41tile;
parameter list P;
@@
T F(P);

@script:python depends on extract_putcontig8bitYCbCr41tile_decl@
F << extract_putcontig8bitYCbCr41tile_decl.F;
T << extract_putcontig8bitYCbCr41tile_decl.T;
P << extract_putcontig8bitYCbCr41tile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_putcontig8bitYCbCr41tile_decl_void@
identifier F = putcontig8bitYCbCr41tile;
parameter list P;
@@
void F(P);

@script:python depends on extract_putcontig8bitYCbCr41tile_decl_void@
F << extract_putcontig8bitYCbCr41tile_decl_void.F;
P << extract_putcontig8bitYCbCr41tile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: putcontig8bitYCbCr42tile
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_putcontig8bitYCbCr42tile_def@
type T;
identifier F = putcontig8bitYCbCr42tile;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_putcontig8bitYCbCr42tile_def@
F << remove_static_putcontig8bitYCbCr42tile_def.F;
T << remove_static_putcontig8bitYCbCr42tile_def.T;
P << remove_static_putcontig8bitYCbCr42tile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_putcontig8bitYCbCr42tile_def_void@
identifier F = putcontig8bitYCbCr42tile;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_putcontig8bitYCbCr42tile_def_void@
F << remove_static_putcontig8bitYCbCr42tile_def_void.F;
P << remove_static_putcontig8bitYCbCr42tile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_putcontig8bitYCbCr42tile_decl@
type T;
identifier F = putcontig8bitYCbCr42tile;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_putcontig8bitYCbCr42tile_decl@
F << remove_static_putcontig8bitYCbCr42tile_decl.F;
T << remove_static_putcontig8bitYCbCr42tile_decl.T;
P << remove_static_putcontig8bitYCbCr42tile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_putcontig8bitYCbCr42tile_decl_void@
identifier F = putcontig8bitYCbCr42tile;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_putcontig8bitYCbCr42tile_decl_void@
F << remove_static_putcontig8bitYCbCr42tile_decl_void.F;
P << remove_static_putcontig8bitYCbCr42tile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_putcontig8bitYCbCr42tile_def@
type T;
identifier F = putcontig8bitYCbCr42tile;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_putcontig8bitYCbCr42tile_def@
F << extract_putcontig8bitYCbCr42tile_def.F;
T << extract_putcontig8bitYCbCr42tile_def.T;
P << extract_putcontig8bitYCbCr42tile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_putcontig8bitYCbCr42tile_def_void@
identifier F = putcontig8bitYCbCr42tile;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_putcontig8bitYCbCr42tile_def_void@
F << extract_putcontig8bitYCbCr42tile_def_void.F;
P << extract_putcontig8bitYCbCr42tile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_putcontig8bitYCbCr42tile_decl@
type T;
identifier F = putcontig8bitYCbCr42tile;
parameter list P;
@@
T F(P);

@script:python depends on extract_putcontig8bitYCbCr42tile_decl@
F << extract_putcontig8bitYCbCr42tile_decl.F;
T << extract_putcontig8bitYCbCr42tile_decl.T;
P << extract_putcontig8bitYCbCr42tile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_putcontig8bitYCbCr42tile_decl_void@
identifier F = putcontig8bitYCbCr42tile;
parameter list P;
@@
void F(P);

@script:python depends on extract_putcontig8bitYCbCr42tile_decl_void@
F << extract_putcontig8bitYCbCr42tile_decl_void.F;
P << extract_putcontig8bitYCbCr42tile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: putcontig8bitYCbCr44tile
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_putcontig8bitYCbCr44tile_def@
type T;
identifier F = putcontig8bitYCbCr44tile;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_putcontig8bitYCbCr44tile_def@
F << remove_static_putcontig8bitYCbCr44tile_def.F;
T << remove_static_putcontig8bitYCbCr44tile_def.T;
P << remove_static_putcontig8bitYCbCr44tile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_putcontig8bitYCbCr44tile_def_void@
identifier F = putcontig8bitYCbCr44tile;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_putcontig8bitYCbCr44tile_def_void@
F << remove_static_putcontig8bitYCbCr44tile_def_void.F;
P << remove_static_putcontig8bitYCbCr44tile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_putcontig8bitYCbCr44tile_decl@
type T;
identifier F = putcontig8bitYCbCr44tile;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_putcontig8bitYCbCr44tile_decl@
F << remove_static_putcontig8bitYCbCr44tile_decl.F;
T << remove_static_putcontig8bitYCbCr44tile_decl.T;
P << remove_static_putcontig8bitYCbCr44tile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_putcontig8bitYCbCr44tile_decl_void@
identifier F = putcontig8bitYCbCr44tile;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_putcontig8bitYCbCr44tile_decl_void@
F << remove_static_putcontig8bitYCbCr44tile_decl_void.F;
P << remove_static_putcontig8bitYCbCr44tile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_putcontig8bitYCbCr44tile_def@
type T;
identifier F = putcontig8bitYCbCr44tile;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_putcontig8bitYCbCr44tile_def@
F << extract_putcontig8bitYCbCr44tile_def.F;
T << extract_putcontig8bitYCbCr44tile_def.T;
P << extract_putcontig8bitYCbCr44tile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_putcontig8bitYCbCr44tile_def_void@
identifier F = putcontig8bitYCbCr44tile;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_putcontig8bitYCbCr44tile_def_void@
F << extract_putcontig8bitYCbCr44tile_def_void.F;
P << extract_putcontig8bitYCbCr44tile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_putcontig8bitYCbCr44tile_decl@
type T;
identifier F = putcontig8bitYCbCr44tile;
parameter list P;
@@
T F(P);

@script:python depends on extract_putcontig8bitYCbCr44tile_decl@
F << extract_putcontig8bitYCbCr44tile_decl.F;
T << extract_putcontig8bitYCbCr44tile_decl.T;
P << extract_putcontig8bitYCbCr44tile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_putcontig8bitYCbCr44tile_decl_void@
identifier F = putcontig8bitYCbCr44tile;
parameter list P;
@@
void F(P);

@script:python depends on extract_putcontig8bitYCbCr44tile_decl_void@
F << extract_putcontig8bitYCbCr44tile_decl_void.F;
P << extract_putcontig8bitYCbCr44tile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: putgreytile
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_putgreytile_def@
type T;
identifier F = putgreytile;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_putgreytile_def@
F << remove_static_putgreytile_def.F;
T << remove_static_putgreytile_def.T;
P << remove_static_putgreytile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_putgreytile_def_void@
identifier F = putgreytile;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_putgreytile_def_void@
F << remove_static_putgreytile_def_void.F;
P << remove_static_putgreytile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_putgreytile_decl@
type T;
identifier F = putgreytile;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_putgreytile_decl@
F << remove_static_putgreytile_decl.F;
T << remove_static_putgreytile_decl.T;
P << remove_static_putgreytile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_putgreytile_decl_void@
identifier F = putgreytile;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_putgreytile_decl_void@
F << remove_static_putgreytile_decl_void.F;
P << remove_static_putgreytile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_putgreytile_def@
type T;
identifier F = putgreytile;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_putgreytile_def@
F << extract_putgreytile_def.F;
T << extract_putgreytile_def.T;
P << extract_putgreytile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_putgreytile_def_void@
identifier F = putgreytile;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_putgreytile_def_void@
F << extract_putgreytile_def_void.F;
P << extract_putgreytile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_putgreytile_decl@
type T;
identifier F = putgreytile;
parameter list P;
@@
T F(P);

@script:python depends on extract_putgreytile_decl@
F << extract_putgreytile_decl.F;
T << extract_putgreytile_decl.T;
P << extract_putgreytile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_putgreytile_decl_void@
identifier F = putgreytile;
parameter list P;
@@
void F(P);

@script:python depends on extract_putgreytile_decl_void@
F << extract_putgreytile_decl_void.F;
P << extract_putgreytile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: putseparate8bitYCbCr11tile
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_putseparate8bitYCbCr11tile_def@
type T;
identifier F = putseparate8bitYCbCr11tile;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_putseparate8bitYCbCr11tile_def@
F << remove_static_putseparate8bitYCbCr11tile_def.F;
T << remove_static_putseparate8bitYCbCr11tile_def.T;
P << remove_static_putseparate8bitYCbCr11tile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_putseparate8bitYCbCr11tile_def_void@
identifier F = putseparate8bitYCbCr11tile;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_putseparate8bitYCbCr11tile_def_void@
F << remove_static_putseparate8bitYCbCr11tile_def_void.F;
P << remove_static_putseparate8bitYCbCr11tile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_putseparate8bitYCbCr11tile_decl@
type T;
identifier F = putseparate8bitYCbCr11tile;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_putseparate8bitYCbCr11tile_decl@
F << remove_static_putseparate8bitYCbCr11tile_decl.F;
T << remove_static_putseparate8bitYCbCr11tile_decl.T;
P << remove_static_putseparate8bitYCbCr11tile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_putseparate8bitYCbCr11tile_decl_void@
identifier F = putseparate8bitYCbCr11tile;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_putseparate8bitYCbCr11tile_decl_void@
F << remove_static_putseparate8bitYCbCr11tile_decl_void.F;
P << remove_static_putseparate8bitYCbCr11tile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_putseparate8bitYCbCr11tile_def@
type T;
identifier F = putseparate8bitYCbCr11tile;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_putseparate8bitYCbCr11tile_def@
F << extract_putseparate8bitYCbCr11tile_def.F;
T << extract_putseparate8bitYCbCr11tile_def.T;
P << extract_putseparate8bitYCbCr11tile_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_putseparate8bitYCbCr11tile_def_void@
identifier F = putseparate8bitYCbCr11tile;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_putseparate8bitYCbCr11tile_def_void@
F << extract_putseparate8bitYCbCr11tile_def_void.F;
P << extract_putseparate8bitYCbCr11tile_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_putseparate8bitYCbCr11tile_decl@
type T;
identifier F = putseparate8bitYCbCr11tile;
parameter list P;
@@
T F(P);

@script:python depends on extract_putseparate8bitYCbCr11tile_decl@
F << extract_putseparate8bitYCbCr11tile_decl.F;
T << extract_putseparate8bitYCbCr11tile_decl.T;
P << extract_putseparate8bitYCbCr11tile_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_putseparate8bitYCbCr11tile_decl_void@
identifier F = putseparate8bitYCbCr11tile;
parameter list P;
@@
void F(P);

@script:python depends on extract_putseparate8bitYCbCr11tile_decl_void@
F << extract_putseparate8bitYCbCr11tile_decl_void.F;
P << extract_putseparate8bitYCbCr11tile_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: readproc
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_readproc_def@
type T;
identifier F = readproc;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_readproc_def@
F << remove_static_readproc_def.F;
T << remove_static_readproc_def.T;
P << remove_static_readproc_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_readproc_def_void@
identifier F = readproc;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_readproc_def_void@
F << remove_static_readproc_def_void.F;
P << remove_static_readproc_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_readproc_decl@
type T;
identifier F = readproc;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_readproc_decl@
F << remove_static_readproc_decl.F;
T << remove_static_readproc_decl.T;
P << remove_static_readproc_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_readproc_decl_void@
identifier F = readproc;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_readproc_decl_void@
F << remove_static_readproc_decl_void.F;
P << remove_static_readproc_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_readproc_def@
type T;
identifier F = readproc;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_readproc_def@
F << extract_readproc_def.F;
T << extract_readproc_def.T;
P << extract_readproc_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_readproc_def_void@
identifier F = readproc;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_readproc_def_void@
F << extract_readproc_def_void.F;
P << extract_readproc_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_readproc_decl@
type T;
identifier F = readproc;
parameter list P;
@@
T F(P);

@script:python depends on extract_readproc_decl@
F << extract_readproc_decl.F;
T << extract_readproc_decl.T;
P << extract_readproc_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_readproc_decl_void@
identifier F = readproc;
parameter list P;
@@
void F(P);

@script:python depends on extract_readproc_decl_void@
F << extract_readproc_decl_void.F;
P << extract_readproc_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: seekproc
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_seekproc_def@
type T;
identifier F = seekproc;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_seekproc_def@
F << remove_static_seekproc_def.F;
T << remove_static_seekproc_def.T;
P << remove_static_seekproc_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_seekproc_def_void@
identifier F = seekproc;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_seekproc_def_void@
F << remove_static_seekproc_def_void.F;
P << remove_static_seekproc_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_seekproc_decl@
type T;
identifier F = seekproc;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_seekproc_decl@
F << remove_static_seekproc_decl.F;
T << remove_static_seekproc_decl.T;
P << remove_static_seekproc_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_seekproc_decl_void@
identifier F = seekproc;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_seekproc_decl_void@
F << remove_static_seekproc_decl_void.F;
P << remove_static_seekproc_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_seekproc_def@
type T;
identifier F = seekproc;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_seekproc_def@
F << extract_seekproc_def.F;
T << extract_seekproc_def.T;
P << extract_seekproc_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_seekproc_def_void@
identifier F = seekproc;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_seekproc_def_void@
F << extract_seekproc_def_void.F;
P << extract_seekproc_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_seekproc_decl@
type T;
identifier F = seekproc;
parameter list P;
@@
T F(P);

@script:python depends on extract_seekproc_decl@
F << extract_seekproc_decl.F;
T << extract_seekproc_decl.T;
P << extract_seekproc_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_seekproc_decl_void@
identifier F = seekproc;
parameter list P;
@@
void F(P);

@script:python depends on extract_seekproc_decl_void@
F << extract_seekproc_decl_void.F;
P << extract_seekproc_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: sizeproc
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_sizeproc_def@
type T;
identifier F = sizeproc;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_sizeproc_def@
F << remove_static_sizeproc_def.F;
T << remove_static_sizeproc_def.T;
P << remove_static_sizeproc_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_sizeproc_def_void@
identifier F = sizeproc;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_sizeproc_def_void@
F << remove_static_sizeproc_def_void.F;
P << remove_static_sizeproc_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_sizeproc_decl@
type T;
identifier F = sizeproc;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_sizeproc_decl@
F << remove_static_sizeproc_decl.F;
T << remove_static_sizeproc_decl.T;
P << remove_static_sizeproc_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_sizeproc_decl_void@
identifier F = sizeproc;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_sizeproc_decl_void@
F << remove_static_sizeproc_decl_void.F;
P << remove_static_sizeproc_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_sizeproc_def@
type T;
identifier F = sizeproc;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_sizeproc_def@
F << extract_sizeproc_def.F;
T << extract_sizeproc_def.T;
P << extract_sizeproc_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_sizeproc_def_void@
identifier F = sizeproc;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_sizeproc_def_void@
F << extract_sizeproc_def_void.F;
P << extract_sizeproc_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_sizeproc_decl@
type T;
identifier F = sizeproc;
parameter list P;
@@
T F(P);

@script:python depends on extract_sizeproc_decl@
F << extract_sizeproc_decl.F;
T << extract_sizeproc_decl.T;
P << extract_sizeproc_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_sizeproc_decl_void@
identifier F = sizeproc;
parameter list P;
@@
void F(P);

@script:python depends on extract_sizeproc_decl_void@
F << extract_sizeproc_decl_void.F;
P << extract_sizeproc_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: swabHorAcc16
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_swabHorAcc16_def@
type T;
identifier F = swabHorAcc16;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_swabHorAcc16_def@
F << remove_static_swabHorAcc16_def.F;
T << remove_static_swabHorAcc16_def.T;
P << remove_static_swabHorAcc16_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_swabHorAcc16_def_void@
identifier F = swabHorAcc16;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_swabHorAcc16_def_void@
F << remove_static_swabHorAcc16_def_void.F;
P << remove_static_swabHorAcc16_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_swabHorAcc16_decl@
type T;
identifier F = swabHorAcc16;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_swabHorAcc16_decl@
F << remove_static_swabHorAcc16_decl.F;
T << remove_static_swabHorAcc16_decl.T;
P << remove_static_swabHorAcc16_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_swabHorAcc16_decl_void@
identifier F = swabHorAcc16;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_swabHorAcc16_decl_void@
F << remove_static_swabHorAcc16_decl_void.F;
P << remove_static_swabHorAcc16_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_swabHorAcc16_def@
type T;
identifier F = swabHorAcc16;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_swabHorAcc16_def@
F << extract_swabHorAcc16_def.F;
T << extract_swabHorAcc16_def.T;
P << extract_swabHorAcc16_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_swabHorAcc16_def_void@
identifier F = swabHorAcc16;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_swabHorAcc16_def_void@
F << extract_swabHorAcc16_def_void.F;
P << extract_swabHorAcc16_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_swabHorAcc16_decl@
type T;
identifier F = swabHorAcc16;
parameter list P;
@@
T F(P);

@script:python depends on extract_swabHorAcc16_decl@
F << extract_swabHorAcc16_decl.F;
T << extract_swabHorAcc16_decl.T;
P << extract_swabHorAcc16_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_swabHorAcc16_decl_void@
identifier F = swabHorAcc16;
parameter list P;
@@
void F(P);

@script:python depends on extract_swabHorAcc16_decl_void@
F << extract_swabHorAcc16_decl_void.F;
P << extract_swabHorAcc16_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: swabHorAcc32
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_swabHorAcc32_def@
type T;
identifier F = swabHorAcc32;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_swabHorAcc32_def@
F << remove_static_swabHorAcc32_def.F;
T << remove_static_swabHorAcc32_def.T;
P << remove_static_swabHorAcc32_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_swabHorAcc32_def_void@
identifier F = swabHorAcc32;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_swabHorAcc32_def_void@
F << remove_static_swabHorAcc32_def_void.F;
P << remove_static_swabHorAcc32_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_swabHorAcc32_decl@
type T;
identifier F = swabHorAcc32;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_swabHorAcc32_decl@
F << remove_static_swabHorAcc32_decl.F;
T << remove_static_swabHorAcc32_decl.T;
P << remove_static_swabHorAcc32_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_swabHorAcc32_decl_void@
identifier F = swabHorAcc32;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_swabHorAcc32_decl_void@
F << remove_static_swabHorAcc32_decl_void.F;
P << remove_static_swabHorAcc32_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_swabHorAcc32_def@
type T;
identifier F = swabHorAcc32;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_swabHorAcc32_def@
F << extract_swabHorAcc32_def.F;
T << extract_swabHorAcc32_def.T;
P << extract_swabHorAcc32_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_swabHorAcc32_def_void@
identifier F = swabHorAcc32;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_swabHorAcc32_def_void@
F << extract_swabHorAcc32_def_void.F;
P << extract_swabHorAcc32_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_swabHorAcc32_decl@
type T;
identifier F = swabHorAcc32;
parameter list P;
@@
T F(P);

@script:python depends on extract_swabHorAcc32_decl@
F << extract_swabHorAcc32_decl.F;
T << extract_swabHorAcc32_decl.T;
P << extract_swabHorAcc32_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_swabHorAcc32_decl_void@
identifier F = swabHorAcc32;
parameter list P;
@@
void F(P);

@script:python depends on extract_swabHorAcc32_decl_void@
F << extract_swabHorAcc32_decl_void.F;
P << extract_swabHorAcc32_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: swabHorAcc64
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_swabHorAcc64_def@
type T;
identifier F = swabHorAcc64;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_swabHorAcc64_def@
F << remove_static_swabHorAcc64_def.F;
T << remove_static_swabHorAcc64_def.T;
P << remove_static_swabHorAcc64_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_swabHorAcc64_def_void@
identifier F = swabHorAcc64;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_swabHorAcc64_def_void@
F << remove_static_swabHorAcc64_def_void.F;
P << remove_static_swabHorAcc64_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_swabHorAcc64_decl@
type T;
identifier F = swabHorAcc64;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_swabHorAcc64_decl@
F << remove_static_swabHorAcc64_decl.F;
T << remove_static_swabHorAcc64_decl.T;
P << remove_static_swabHorAcc64_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_swabHorAcc64_decl_void@
identifier F = swabHorAcc64;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_swabHorAcc64_decl_void@
F << remove_static_swabHorAcc64_decl_void.F;
P << remove_static_swabHorAcc64_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_swabHorAcc64_def@
type T;
identifier F = swabHorAcc64;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_swabHorAcc64_def@
F << extract_swabHorAcc64_def.F;
T << extract_swabHorAcc64_def.T;
P << extract_swabHorAcc64_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_swabHorAcc64_def_void@
identifier F = swabHorAcc64;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_swabHorAcc64_def_void@
F << extract_swabHorAcc64_def_void.F;
P << extract_swabHorAcc64_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_swabHorAcc64_decl@
type T;
identifier F = swabHorAcc64;
parameter list P;
@@
T F(P);

@script:python depends on extract_swabHorAcc64_decl@
F << extract_swabHorAcc64_decl.F;
T << extract_swabHorAcc64_decl.T;
P << extract_swabHorAcc64_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_swabHorAcc64_decl_void@
identifier F = swabHorAcc64;
parameter list P;
@@
void F(P);

@script:python depends on extract_swabHorAcc64_decl_void@
F << extract_swabHorAcc64_decl_void.F;
P << extract_swabHorAcc64_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: swabHorDiff16
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_swabHorDiff16_def@
type T;
identifier F = swabHorDiff16;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_swabHorDiff16_def@
F << remove_static_swabHorDiff16_def.F;
T << remove_static_swabHorDiff16_def.T;
P << remove_static_swabHorDiff16_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_swabHorDiff16_def_void@
identifier F = swabHorDiff16;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_swabHorDiff16_def_void@
F << remove_static_swabHorDiff16_def_void.F;
P << remove_static_swabHorDiff16_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_swabHorDiff16_decl@
type T;
identifier F = swabHorDiff16;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_swabHorDiff16_decl@
F << remove_static_swabHorDiff16_decl.F;
T << remove_static_swabHorDiff16_decl.T;
P << remove_static_swabHorDiff16_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_swabHorDiff16_decl_void@
identifier F = swabHorDiff16;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_swabHorDiff16_decl_void@
F << remove_static_swabHorDiff16_decl_void.F;
P << remove_static_swabHorDiff16_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_swabHorDiff16_def@
type T;
identifier F = swabHorDiff16;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_swabHorDiff16_def@
F << extract_swabHorDiff16_def.F;
T << extract_swabHorDiff16_def.T;
P << extract_swabHorDiff16_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_swabHorDiff16_def_void@
identifier F = swabHorDiff16;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_swabHorDiff16_def_void@
F << extract_swabHorDiff16_def_void.F;
P << extract_swabHorDiff16_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_swabHorDiff16_decl@
type T;
identifier F = swabHorDiff16;
parameter list P;
@@
T F(P);

@script:python depends on extract_swabHorDiff16_decl@
F << extract_swabHorDiff16_decl.F;
T << extract_swabHorDiff16_decl.T;
P << extract_swabHorDiff16_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_swabHorDiff16_decl_void@
identifier F = swabHorDiff16;
parameter list P;
@@
void F(P);

@script:python depends on extract_swabHorDiff16_decl_void@
F << extract_swabHorDiff16_decl_void.F;
P << extract_swabHorDiff16_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: swabHorDiff32
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_swabHorDiff32_def@
type T;
identifier F = swabHorDiff32;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_swabHorDiff32_def@
F << remove_static_swabHorDiff32_def.F;
T << remove_static_swabHorDiff32_def.T;
P << remove_static_swabHorDiff32_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_swabHorDiff32_def_void@
identifier F = swabHorDiff32;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_swabHorDiff32_def_void@
F << remove_static_swabHorDiff32_def_void.F;
P << remove_static_swabHorDiff32_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_swabHorDiff32_decl@
type T;
identifier F = swabHorDiff32;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_swabHorDiff32_decl@
F << remove_static_swabHorDiff32_decl.F;
T << remove_static_swabHorDiff32_decl.T;
P << remove_static_swabHorDiff32_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_swabHorDiff32_decl_void@
identifier F = swabHorDiff32;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_swabHorDiff32_decl_void@
F << remove_static_swabHorDiff32_decl_void.F;
P << remove_static_swabHorDiff32_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_swabHorDiff32_def@
type T;
identifier F = swabHorDiff32;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_swabHorDiff32_def@
F << extract_swabHorDiff32_def.F;
T << extract_swabHorDiff32_def.T;
P << extract_swabHorDiff32_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_swabHorDiff32_def_void@
identifier F = swabHorDiff32;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_swabHorDiff32_def_void@
F << extract_swabHorDiff32_def_void.F;
P << extract_swabHorDiff32_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_swabHorDiff32_decl@
type T;
identifier F = swabHorDiff32;
parameter list P;
@@
T F(P);

@script:python depends on extract_swabHorDiff32_decl@
F << extract_swabHorDiff32_decl.F;
T << extract_swabHorDiff32_decl.T;
P << extract_swabHorDiff32_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_swabHorDiff32_decl_void@
identifier F = swabHorDiff32;
parameter list P;
@@
void F(P);

@script:python depends on extract_swabHorDiff32_decl_void@
F << extract_swabHorDiff32_decl_void.F;
P << extract_swabHorDiff32_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: swabHorDiff64
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_swabHorDiff64_def@
type T;
identifier F = swabHorDiff64;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_swabHorDiff64_def@
F << remove_static_swabHorDiff64_def.F;
T << remove_static_swabHorDiff64_def.T;
P << remove_static_swabHorDiff64_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_swabHorDiff64_def_void@
identifier F = swabHorDiff64;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_swabHorDiff64_def_void@
F << remove_static_swabHorDiff64_def_void.F;
P << remove_static_swabHorDiff64_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_swabHorDiff64_decl@
type T;
identifier F = swabHorDiff64;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_swabHorDiff64_decl@
F << remove_static_swabHorDiff64_decl.F;
T << remove_static_swabHorDiff64_decl.T;
P << remove_static_swabHorDiff64_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_swabHorDiff64_decl_void@
identifier F = swabHorDiff64;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_swabHorDiff64_decl_void@
F << remove_static_swabHorDiff64_decl_void.F;
P << remove_static_swabHorDiff64_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_swabHorDiff64_def@
type T;
identifier F = swabHorDiff64;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_swabHorDiff64_def@
F << extract_swabHorDiff64_def.F;
T << extract_swabHorDiff64_def.T;
P << extract_swabHorDiff64_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_swabHorDiff64_def_void@
identifier F = swabHorDiff64;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_swabHorDiff64_def_void@
F << extract_swabHorDiff64_def_void.F;
P << extract_swabHorDiff64_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_swabHorDiff64_decl@
type T;
identifier F = swabHorDiff64;
parameter list P;
@@
T F(P);

@script:python depends on extract_swabHorDiff64_decl@
F << extract_swabHorDiff64_decl.F;
T << extract_swabHorDiff64_decl.T;
P << extract_swabHorDiff64_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_swabHorDiff64_decl_void@
identifier F = swabHorDiff64;
parameter list P;
@@
void F(P);

@script:python depends on extract_swabHorDiff64_decl_void@
F << extract_swabHorDiff64_decl_void.F;
P << extract_swabHorDiff64_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: writeproc
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_writeproc_def@
type T;
identifier F = writeproc;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_writeproc_def@
F << remove_static_writeproc_def.F;
T << remove_static_writeproc_def.T;
P << remove_static_writeproc_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_writeproc_def_void@
identifier F = writeproc;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_writeproc_def_void@
F << remove_static_writeproc_def_void.F;
P << remove_static_writeproc_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_writeproc_decl@
type T;
identifier F = writeproc;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_writeproc_decl@
F << remove_static_writeproc_decl.F;
T << remove_static_writeproc_decl.T;
P << remove_static_writeproc_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_writeproc_decl_void@
identifier F = writeproc;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_writeproc_decl_void@
F << remove_static_writeproc_decl_void.F;
P << remove_static_writeproc_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_writeproc_def@
type T;
identifier F = writeproc;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_writeproc_def@
F << extract_writeproc_def.F;
T << extract_writeproc_def.T;
P << extract_writeproc_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_writeproc_def_void@
identifier F = writeproc;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_writeproc_def_void@
F << extract_writeproc_def_void.F;
P << extract_writeproc_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_writeproc_decl@
type T;
identifier F = writeproc;
parameter list P;
@@
T F(P);

@script:python depends on extract_writeproc_decl@
F << extract_writeproc_decl.F;
T << extract_writeproc_decl.T;
P << extract_writeproc_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_writeproc_decl_void@
identifier F = writeproc;
parameter list P;
@@
void F(P);

@script:python depends on extract_writeproc_decl_void@
F << extract_writeproc_decl_void.F;
P << extract_writeproc_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Consolidation Script
// ============================================================

@script:python@
@@
import os
import glob

print("\n>>> CONSOLIDATING FUNCTION DECLARATIONS")

target_functions = ["DecodeRowError", "DumpFixupTags", "DumpModeDecode", "DumpModeEncode", "DumpModeSeek", "Fax3Cleanup", "Fax3Close", "Fax3Decode1D", "Fax3Decode2D", "Fax3DecodeRLE", "Fax3Encode", "Fax3FixupTags", "Fax3PostEncode", "Fax3PreDecode", "Fax3PreEncode", "Fax3PrintDir", "Fax3SetupState", "Fax3VGetField", "Fax3VSetField", "Fax4Decode", "Fax4Encode", "Fax4PostEncode", "JBIGDecode", "JBIGEncode", "JBIGSetupDecode", "JBIGSetupEncode", "JPEGCleanup", "JPEGDecode", "JPEGDecodeRaw", "JPEGDefaultStripSize", "JPEGDefaultTileSize", "JPEGEncode", "JPEGEncodeRaw", "JPEGFixupTags", "JPEGPostEncode", "JPEGPreDecode", "JPEGPreEncode", "JPEGPrintDir", "JPEGSetupDecode", "JPEGSetupEncode", "JPEGVGetField", "JPEGVSetField", "L16fromY", "L16toGry", "L16toY", "LERCCleanup", "LERCDecode", "LERCEncode", "LERCFixupTags", "LERCPostEncode", "LERCPreDecode", "LERCPreEncode", "LERCSetupDecode", "LERCSetupEncode", "LERCVGetField", "LERCVSetField", "LZMACleanup", "LZMADecode", "LZMAEncode", "LZMAFixupTags", "LZMAPostEncode", "LZMAPreDecode", "LZMAPreEncode", "LZMASetupDecode", "LZMASetupEncode", "LZMAVGetField", "LZMAVSetField", "LZWCleanup", "LZWDecode", "LZWDecodeCompat", "LZWEncode", "LZWFixupTags", "LZWPostEncode", "LZWPreDecode", "LZWPreEncode", "LZWSetupDecode", "LZWSetupEncode", "LogL16Decode", "LogL16Encode", "LogLuvCleanup", "LogLuvClose", "LogLuvDecode24", "LogLuvDecode32", "LogLuvDecodeStrip", "LogLuvDecodeTile", "LogLuvEncode24", "LogLuvEncode32", "LogLuvEncodeStrip", "LogLuvEncodeTile", "LogLuvFixupTags", "LogLuvSetupDecode", "LogLuvSetupEncode", "LogLuvVGetField", "LogLuvVSetField", "Luv24fromLuv48", "Luv24fromXYZ", "Luv24toLuv48", "Luv24toRGB", "Luv24toXYZ", "Luv32fromLuv48", "Luv32fromXYZ", "Luv32toLuv48", "Luv32toRGB", "Luv32toXYZ", "NeXTDecode", "NeXTPreDecode", "OJPEGCleanup", "OJPEGDecode", "OJPEGEncode", "OJPEGFixupTags", "OJPEGPostDecode", "OJPEGPostEncode", "OJPEGPreDecode", "OJPEGPreEncode", "OJPEGPrintDir", "OJPEGSetupDecode", "OJPEGSetupEncode", "OJPEGVGetField", "OJPEGVSetField", "PackBitsDecode", "PackBitsEncode", "PackBitsEncodeChunk", "PackBitsPostEncode", "PackBitsPreEncode", "PixarLogCleanup", "PixarLogClose", "PixarLogDecode", "PixarLogEncode", "PixarLogFixupTags", "PixarLogPostEncode", "PixarLogPreDecode", "PixarLogPreEncode", "PixarLogSetupDecode", "PixarLogSetupEncode", "PixarLogVGetField", "PixarLogVSetField", "PredictorDecodeRow", "PredictorDecodeTile", "PredictorEncodeRow", "PredictorEncodeTile", "PredictorPrintDir", "PredictorSetupDecode", "PredictorSetupEncode", "PredictorVGetField", "PredictorVSetField", "TWebPCleanup", "TWebPDecode", "TWebPEncode", "TWebPFixupTags", "TWebPPostEncode", "TWebPPreDecode", "TWebPPreEncode", "TWebPSetupDecode", "TWebPSetupEncode", "TWebPVGetField", "TWebPVSetField", "ThunderDecodeRow", "ThunderSetupDecode", "ZIPCleanup", "ZIPDecode", "ZIPEncode", "ZIPFixupTags", "ZIPPostEncode", "ZIPPreDecode", "ZIPPreEncode", "ZIPSetupDecode", "ZIPSetupEncode", "ZIPVGetField", "ZIPVSetField", "ZSTDCleanup", "ZSTDDecode", "ZSTDEncode", "ZSTDFixupTags", "ZSTDPostEncode", "ZSTDPreDecode", "ZSTDPreEncode", "ZSTDSetupDecode", "ZSTDSetupEncode", "ZSTDVGetField", "ZSTDVSetField", "_TIFFDefaultStripSize", "_TIFFDefaultTileSize", "_TIFFNoFixupTags", "_TIFFNoPostDecode", "_TIFFNoPreCode", "_TIFFNoRowDecode", "_TIFFNoRowEncode", "_TIFFNoSeek", "_TIFFNoStripDecode", "_TIFFNoStripEncode", "_TIFFNoTileDecode", "_TIFFNoTileEncode", "_TIFFSwab16BitData", "_TIFFSwab24BitData", "_TIFFSwab32BitData", "_TIFFSwab64BitData", "_TIFFVGetField", "_TIFFVSetField", "_TIFFtrue", "_TIFFvoid", "_logLuvNop", "_notConfigured", "closeproc", "fpAcc", "fpDiff", "handler", "horAcc16", "horAcc32", "horAcc64", "horAcc8", "horDiff16", "horDiff32", "horDiff64", "horDiff8", "put16bitbwtile", "put1bitbwtile", "put1bitcmaptile", "put2bitbwtile", "put2bitcmaptile", "put4bitbwtile", "put4bitcmaptile", "put8bitcmaptile", "putCMYKseparate8bittile", "putRGBAAcontig16bittile", "putRGBAAcontig8bittile", "putRGBAAseparate16bittile", "putRGBAAseparate8bittile", "putRGBUAcontig16bittile", "putRGBUAcontig8bittile", "putRGBUAseparate16bittile", "putRGBUAseparate8bittile", "putRGBcontig16bittile", "putRGBcontig8bitCMYKMaptile", "putRGBcontig8bitCMYKtile", "putRGBcontig8bittile", "putRGBseparate16bittile", "putRGBseparate8bittile", "putagreytile", "putcontig8bitYCbCr11tile", "putcontig8bitYCbCr12tile", "putcontig8bitYCbCr21tile", "putcontig8bitYCbCr22tile", "putcontig8bitYCbCr41tile", "putcontig8bitYCbCr42tile", "putcontig8bitYCbCr44tile", "putgreytile", "putseparate8bitYCbCr11tile", "readproc", "seekproc", "sizeproc", "swabHorAcc16", "swabHorAcc32", "swabHorAcc64", "swabHorDiff16", "swabHorDiff32", "swabHorDiff64", "writeproc"]

def_files = glob.glob("definitions/*.txt")
if not def_files:
    print(">>> No function declarations found to consolidate")
else:
    print(">>> Found %d function declarations" % len(def_files))
    
    # Read all declarations
    declarations = {}
    for def_file in sorted(def_files):
        func_name = os.path.basename(def_file).replace('.txt', '')
        try:
            with open(def_file, 'r') as f:
                signature = f.read().strip()
            declarations[func_name] = signature
        except Exception as e:
            print(">>> [ERROR] Failed to read %s: %s" % (def_file, e))
    
    # Write consolidated header file
    header_path = "extracted_declarations.h"
    try:
        with open(header_path, 'w') as f:
            f.write("/* Extracted function declarations */\n")
            f.write("/* Generated by Coccinelle script */\n")
            f.write("/* Static keyword removed where applicable */\n\n")
            f.write("#ifndef EXTRACTED_DECLARATIONS_H\n")
            f.write("#define EXTRACTED_DECLARATIONS_H\n\n")
            
            # Write declarations in sorted order
            for func_name in sorted(declarations.keys()):
                f.write(declarations[func_name] + "\n")
            
            f.write("\n#endif /* EXTRACTED_DECLARATIONS_H */\n")
        
        print(">>> Successfully created header: %s" % header_path)
        print(">>> Total declarations extracted: %d" % len(declarations))
        
        # Report missing functions
        missing = [f for f in target_functions if f not in declarations]
        if missing:
            print(">>> Missing declarations: %d" % len(missing))
            for m in missing[:10]:
                print(">>>   - %s" % m)
            if len(missing) > 10:
                print(">>>   ... and %d more" % (len(missing) - 10))
            
    except Exception as e:
        print(">>> [ERROR] Failed to create header: %s" % e)

print(">>> Consolidation complete")

@finalize:python@
@@
print("\n>>> PROCESSING COMPLETE")
print(">>> Total target functions: 257")
print(">>> Successfully extracted: %d" % len(processed_functions))
print(">>> Individual declarations: definitions/*.txt")
print(">>> Consolidated header: extracted_declarations.h")
