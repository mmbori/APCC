//
// Coccinelle script to extract function declarations and remove 'static' keyword
//
// Generated by: 3_5_extract_fn_declarations.py
// Purpose: Extract function declarations from definitions, remove static keyword
//
// This script:
// 1. Finds function definitions and declarations
// 2. Removes static keyword if present
// 3. Extracts signatures as declaration form (with semicolon)
// 4. Saves to definitions/ folder and consolidates to header file
//
// Usage: spatch --sp-file extract_declarations.cocci --dir <source_directory> --in-place

// Shared Python functions
@initialize:python@
@@
import os
import re

# Track processed functions to avoid duplicates
processed_functions = set()

def clean_function_signature(signature):
    """Clean up function signature formatting"""
    if not signature:
        return signature
    
    # Normalize all whitespace
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Remove all spaces around asterisks first
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Add space before asterisk groups
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Clean up double spaces
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

def extract_and_save_signature(signature, func_name):
    """Extract and save function signature to file (skip if already processed)"""
    if func_name in processed_functions:
        return
    
    processed_functions.add(func_name)
    os.makedirs("definitions", exist_ok=True)
    clean_signature = clean_function_signature(signature)
    filepath = "definitions/" + func_name + ".txt"
    with open(filepath, "w") as f:
        f.write(clean_signature + "\n")
    print("[EXTRACTED] " + func_name)


// ============================================================
// Rules for function: brcm_tag_print
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_brcm_tag_print_def@
type T;
identifier F = brcm_tag_print;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_brcm_tag_print_def@
F << remove_static_brcm_tag_print_def.F;
T << remove_static_brcm_tag_print_def.T;
P << remove_static_brcm_tag_print_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_brcm_tag_print_def_void@
identifier F = brcm_tag_print;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_brcm_tag_print_def_void@
F << remove_static_brcm_tag_print_def_void.F;
P << remove_static_brcm_tag_print_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_brcm_tag_print_decl@
type T;
identifier F = brcm_tag_print;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_brcm_tag_print_decl@
F << remove_static_brcm_tag_print_decl.F;
T << remove_static_brcm_tag_print_decl.T;
P << remove_static_brcm_tag_print_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_brcm_tag_print_decl_void@
identifier F = brcm_tag_print;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_brcm_tag_print_decl_void@
F << remove_static_brcm_tag_print_decl_void.F;
P << remove_static_brcm_tag_print_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_brcm_tag_print_def@
type T;
identifier F = brcm_tag_print;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_brcm_tag_print_def@
F << extract_brcm_tag_print_def.F;
T << extract_brcm_tag_print_def.T;
P << extract_brcm_tag_print_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_brcm_tag_print_def_void@
identifier F = brcm_tag_print;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_brcm_tag_print_def_void@
F << extract_brcm_tag_print_def_void.F;
P << extract_brcm_tag_print_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_brcm_tag_print_decl@
type T;
identifier F = brcm_tag_print;
parameter list P;
@@
T F(P);

@script:python depends on extract_brcm_tag_print_decl@
F << extract_brcm_tag_print_decl.F;
T << extract_brcm_tag_print_decl.T;
P << extract_brcm_tag_print_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_brcm_tag_print_decl_void@
identifier F = brcm_tag_print;
parameter list P;
@@
void F(P);

@script:python depends on extract_brcm_tag_print_decl_void@
F << extract_brcm_tag_print_decl_void.F;
P << extract_brcm_tag_print_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: dsa_tag_print
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_dsa_tag_print_def@
type T;
identifier F = dsa_tag_print;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_dsa_tag_print_def@
F << remove_static_dsa_tag_print_def.F;
T << remove_static_dsa_tag_print_def.T;
P << remove_static_dsa_tag_print_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_dsa_tag_print_def_void@
identifier F = dsa_tag_print;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_dsa_tag_print_def_void@
F << remove_static_dsa_tag_print_def_void.F;
P << remove_static_dsa_tag_print_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_dsa_tag_print_decl@
type T;
identifier F = dsa_tag_print;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_dsa_tag_print_decl@
F << remove_static_dsa_tag_print_decl.F;
T << remove_static_dsa_tag_print_decl.T;
P << remove_static_dsa_tag_print_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_dsa_tag_print_decl_void@
identifier F = dsa_tag_print;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_dsa_tag_print_decl_void@
F << remove_static_dsa_tag_print_decl_void.F;
P << remove_static_dsa_tag_print_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_dsa_tag_print_def@
type T;
identifier F = dsa_tag_print;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_dsa_tag_print_def@
F << extract_dsa_tag_print_def.F;
T << extract_dsa_tag_print_def.T;
P << extract_dsa_tag_print_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_dsa_tag_print_def_void@
identifier F = dsa_tag_print;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_dsa_tag_print_def_void@
F << extract_dsa_tag_print_def_void.F;
P << extract_dsa_tag_print_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_dsa_tag_print_decl@
type T;
identifier F = dsa_tag_print;
parameter list P;
@@
T F(P);

@script:python depends on extract_dsa_tag_print_decl@
F << extract_dsa_tag_print_decl.F;
T << extract_dsa_tag_print_decl.T;
P << extract_dsa_tag_print_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_dsa_tag_print_decl_void@
identifier F = dsa_tag_print;
parameter list P;
@@
void F(P);

@script:python depends on extract_dsa_tag_print_decl_void@
F << extract_dsa_tag_print_decl_void.F;
P << extract_dsa_tag_print_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: edsa_tag_print
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_edsa_tag_print_def@
type T;
identifier F = edsa_tag_print;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_edsa_tag_print_def@
F << remove_static_edsa_tag_print_def.F;
T << remove_static_edsa_tag_print_def.T;
P << remove_static_edsa_tag_print_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_edsa_tag_print_def_void@
identifier F = edsa_tag_print;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_edsa_tag_print_def_void@
F << remove_static_edsa_tag_print_def_void.F;
P << remove_static_edsa_tag_print_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_edsa_tag_print_decl@
type T;
identifier F = edsa_tag_print;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_edsa_tag_print_decl@
F << remove_static_edsa_tag_print_decl.F;
T << remove_static_edsa_tag_print_decl.T;
P << remove_static_edsa_tag_print_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_edsa_tag_print_decl_void@
identifier F = edsa_tag_print;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_edsa_tag_print_decl_void@
F << remove_static_edsa_tag_print_decl_void.F;
P << remove_static_edsa_tag_print_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_edsa_tag_print_def@
type T;
identifier F = edsa_tag_print;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_edsa_tag_print_def@
F << extract_edsa_tag_print_def.F;
T << extract_edsa_tag_print_def.T;
P << extract_edsa_tag_print_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_edsa_tag_print_def_void@
identifier F = edsa_tag_print;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_edsa_tag_print_def_void@
F << extract_edsa_tag_print_def_void.F;
P << extract_edsa_tag_print_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_edsa_tag_print_decl@
type T;
identifier F = edsa_tag_print;
parameter list P;
@@
T F(P);

@script:python depends on extract_edsa_tag_print_decl@
F << extract_edsa_tag_print_decl.F;
T << extract_edsa_tag_print_decl.T;
P << extract_edsa_tag_print_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_edsa_tag_print_decl_void@
identifier F = edsa_tag_print;
parameter list P;
@@
void F(P);

@script:python depends on extract_edsa_tag_print_decl_void@
F << extract_edsa_tag_print_decl_void.F;
P << extract_edsa_tag_print_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: eui64_string
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_eui64_string_def@
type T;
identifier F = eui64_string;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_eui64_string_def@
F << remove_static_eui64_string_def.F;
T << remove_static_eui64_string_def.T;
P << remove_static_eui64_string_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_eui64_string_def_void@
identifier F = eui64_string;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_eui64_string_def_void@
F << remove_static_eui64_string_def_void.F;
P << remove_static_eui64_string_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_eui64_string_decl@
type T;
identifier F = eui64_string;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_eui64_string_decl@
F << remove_static_eui64_string_decl.F;
T << remove_static_eui64_string_decl.T;
P << remove_static_eui64_string_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_eui64_string_decl_void@
identifier F = eui64_string;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_eui64_string_decl_void@
F << remove_static_eui64_string_decl_void.F;
P << remove_static_eui64_string_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_eui64_string_def@
type T;
identifier F = eui64_string;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_eui64_string_def@
F << extract_eui64_string_def.F;
T << extract_eui64_string_def.T;
P << extract_eui64_string_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_eui64_string_def_void@
identifier F = eui64_string;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_eui64_string_def_void@
F << extract_eui64_string_def_void.F;
P << extract_eui64_string_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_eui64_string_decl@
type T;
identifier F = eui64_string;
parameter list P;
@@
T F(P);

@script:python depends on extract_eui64_string_decl@
F << extract_eui64_string_decl.F;
T << extract_eui64_string_decl.T;
P << extract_eui64_string_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_eui64_string_decl_void@
identifier F = eui64_string;
parameter list P;
@@
void F(P);

@script:python depends on extract_eui64_string_decl_void@
F << extract_eui64_string_decl_void.F;
P << extract_eui64_string_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: icmp_code
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_icmp_code_def@
type T;
identifier F = icmp_code;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_icmp_code_def@
F << remove_static_icmp_code_def.F;
T << remove_static_icmp_code_def.T;
P << remove_static_icmp_code_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_icmp_code_def_void@
identifier F = icmp_code;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_icmp_code_def_void@
F << remove_static_icmp_code_def_void.F;
P << remove_static_icmp_code_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_icmp_code_decl@
type T;
identifier F = icmp_code;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_icmp_code_decl@
F << remove_static_icmp_code_decl.F;
T << remove_static_icmp_code_decl.T;
P << remove_static_icmp_code_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_icmp_code_decl_void@
identifier F = icmp_code;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_icmp_code_decl_void@
F << remove_static_icmp_code_decl_void.F;
P << remove_static_icmp_code_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_icmp_code_def@
type T;
identifier F = icmp_code;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_icmp_code_def@
F << extract_icmp_code_def.F;
T << extract_icmp_code_def.T;
P << extract_icmp_code_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_icmp_code_def_void@
identifier F = icmp_code;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_icmp_code_def_void@
F << extract_icmp_code_def_void.F;
P << extract_icmp_code_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_icmp_code_decl@
type T;
identifier F = icmp_code;
parameter list P;
@@
T F(P);

@script:python depends on extract_icmp_code_decl@
F << extract_icmp_code_decl.F;
T << extract_icmp_code_decl.T;
P << extract_icmp_code_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_icmp_code_decl_void@
identifier F = icmp_code;
parameter list P;
@@
void F(P);

@script:python depends on extract_icmp_code_decl_void@
F << extract_icmp_code_decl_void.F;
P << extract_icmp_code_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: ip_proto
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_ip_proto_def@
type T;
identifier F = ip_proto;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_ip_proto_def@
F << remove_static_ip_proto_def.F;
T << remove_static_ip_proto_def.T;
P << remove_static_ip_proto_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_ip_proto_def_void@
identifier F = ip_proto;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_ip_proto_def_void@
F << remove_static_ip_proto_def_void.F;
P << remove_static_ip_proto_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_ip_proto_decl@
type T;
identifier F = ip_proto;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_ip_proto_decl@
F << remove_static_ip_proto_decl.F;
T << remove_static_ip_proto_decl.T;
P << remove_static_ip_proto_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_ip_proto_decl_void@
identifier F = ip_proto;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_ip_proto_decl_void@
F << remove_static_ip_proto_decl_void.F;
P << remove_static_ip_proto_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_ip_proto_def@
type T;
identifier F = ip_proto;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_ip_proto_def@
F << extract_ip_proto_def.F;
T << extract_ip_proto_def.T;
P << extract_ip_proto_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_ip_proto_def_void@
identifier F = ip_proto;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_ip_proto_def_void@
F << extract_ip_proto_def_void.F;
P << extract_ip_proto_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_ip_proto_decl@
type T;
identifier F = ip_proto;
parameter list P;
@@
T F(P);

@script:python depends on extract_ip_proto_decl@
F << extract_ip_proto_decl.F;
T << extract_ip_proto_decl.T;
P << extract_ip_proto_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_ip_proto_decl_void@
identifier F = ip_proto;
parameter list P;
@@
void F(P);

@script:python depends on extract_ip_proto_decl_void@
F << extract_ip_proto_decl_void.F;
P << extract_ip_proto_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: isis_clear_checksum_lifetime
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_isis_clear_checksum_lifetime_def@
type T;
identifier F = isis_clear_checksum_lifetime;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_isis_clear_checksum_lifetime_def@
F << remove_static_isis_clear_checksum_lifetime_def.F;
T << remove_static_isis_clear_checksum_lifetime_def.T;
P << remove_static_isis_clear_checksum_lifetime_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_isis_clear_checksum_lifetime_def_void@
identifier F = isis_clear_checksum_lifetime;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_isis_clear_checksum_lifetime_def_void@
F << remove_static_isis_clear_checksum_lifetime_def_void.F;
P << remove_static_isis_clear_checksum_lifetime_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_isis_clear_checksum_lifetime_decl@
type T;
identifier F = isis_clear_checksum_lifetime;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_isis_clear_checksum_lifetime_decl@
F << remove_static_isis_clear_checksum_lifetime_decl.F;
T << remove_static_isis_clear_checksum_lifetime_decl.T;
P << remove_static_isis_clear_checksum_lifetime_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_isis_clear_checksum_lifetime_decl_void@
identifier F = isis_clear_checksum_lifetime;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_isis_clear_checksum_lifetime_decl_void@
F << remove_static_isis_clear_checksum_lifetime_decl_void.F;
P << remove_static_isis_clear_checksum_lifetime_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_isis_clear_checksum_lifetime_def@
type T;
identifier F = isis_clear_checksum_lifetime;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_isis_clear_checksum_lifetime_def@
F << extract_isis_clear_checksum_lifetime_def.F;
T << extract_isis_clear_checksum_lifetime_def.T;
P << extract_isis_clear_checksum_lifetime_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_isis_clear_checksum_lifetime_def_void@
identifier F = isis_clear_checksum_lifetime;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_isis_clear_checksum_lifetime_def_void@
F << extract_isis_clear_checksum_lifetime_def_void.F;
P << extract_isis_clear_checksum_lifetime_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_isis_clear_checksum_lifetime_decl@
type T;
identifier F = isis_clear_checksum_lifetime;
parameter list P;
@@
T F(P);

@script:python depends on extract_isis_clear_checksum_lifetime_decl@
F << extract_isis_clear_checksum_lifetime_decl.F;
T << extract_isis_clear_checksum_lifetime_decl.T;
P << extract_isis_clear_checksum_lifetime_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_isis_clear_checksum_lifetime_decl_void@
identifier F = isis_clear_checksum_lifetime;
parameter list P;
@@
void F(P);

@script:python depends on extract_isis_clear_checksum_lifetime_decl_void@
F << extract_isis_clear_checksum_lifetime_decl_void.F;
P << extract_isis_clear_checksum_lifetime_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: lane_hdr_print
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_lane_hdr_print_def@
type T;
identifier F = lane_hdr_print;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_lane_hdr_print_def@
F << remove_static_lane_hdr_print_def.F;
T << remove_static_lane_hdr_print_def.T;
P << remove_static_lane_hdr_print_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_lane_hdr_print_def_void@
identifier F = lane_hdr_print;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_lane_hdr_print_def_void@
F << remove_static_lane_hdr_print_def_void.F;
P << remove_static_lane_hdr_print_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_lane_hdr_print_decl@
type T;
identifier F = lane_hdr_print;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_lane_hdr_print_decl@
F << remove_static_lane_hdr_print_decl.F;
T << remove_static_lane_hdr_print_decl.T;
P << remove_static_lane_hdr_print_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_lane_hdr_print_decl_void@
identifier F = lane_hdr_print;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_lane_hdr_print_decl_void@
F << remove_static_lane_hdr_print_decl_void.F;
P << remove_static_lane_hdr_print_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_lane_hdr_print_def@
type T;
identifier F = lane_hdr_print;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_lane_hdr_print_def@
F << extract_lane_hdr_print_def.F;
T << extract_lane_hdr_print_def.T;
P << extract_lane_hdr_print_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_lane_hdr_print_def_void@
identifier F = lane_hdr_print;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_lane_hdr_print_def_void@
F << extract_lane_hdr_print_def_void.F;
P << extract_lane_hdr_print_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_lane_hdr_print_decl@
type T;
identifier F = lane_hdr_print;
parameter list P;
@@
T F(P);

@script:python depends on extract_lane_hdr_print_decl@
F << extract_lane_hdr_print_decl.F;
T << extract_lane_hdr_print_decl.T;
P << extract_lane_hdr_print_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_lane_hdr_print_decl_void@
identifier F = lane_hdr_print;
parameter list P;
@@
void F(P);

@script:python depends on extract_lane_hdr_print_decl_void@
F << extract_lane_hdr_print_decl_void.F;
P << extract_lane_hdr_print_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: mac48_string
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_mac48_string_def@
type T;
identifier F = mac48_string;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_mac48_string_def@
F << remove_static_mac48_string_def.F;
T << remove_static_mac48_string_def.T;
P << remove_static_mac48_string_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_mac48_string_def_void@
identifier F = mac48_string;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_mac48_string_def_void@
F << remove_static_mac48_string_def_void.F;
P << remove_static_mac48_string_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_mac48_string_decl@
type T;
identifier F = mac48_string;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_mac48_string_decl@
F << remove_static_mac48_string_decl.F;
T << remove_static_mac48_string_decl.T;
P << remove_static_mac48_string_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_mac48_string_decl_void@
identifier F = mac48_string;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_mac48_string_decl_void@
F << remove_static_mac48_string_decl_void.F;
P << remove_static_mac48_string_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_mac48_string_def@
type T;
identifier F = mac48_string;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_mac48_string_def@
F << extract_mac48_string_def.F;
T << extract_mac48_string_def.T;
P << extract_mac48_string_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_mac48_string_def_void@
identifier F = mac48_string;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_mac48_string_def_void@
F << extract_mac48_string_def_void.F;
P << extract_mac48_string_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_mac48_string_decl@
type T;
identifier F = mac48_string;
parameter list P;
@@
T F(P);

@script:python depends on extract_mac48_string_decl@
F << extract_mac48_string_decl.F;
T << extract_mac48_string_decl.T;
P << extract_mac48_string_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_mac48_string_decl_void@
identifier F = mac48_string;
parameter list P;
@@
void F(P);

@script:python depends on extract_mac48_string_decl_void@
F << extract_mac48_string_decl_void.F;
P << extract_mac48_string_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: max_chars
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_max_chars_def@
type T;
identifier F = max_chars;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_max_chars_def@
F << remove_static_max_chars_def.F;
T << remove_static_max_chars_def.T;
P << remove_static_max_chars_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_max_chars_def_void@
identifier F = max_chars;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_max_chars_def_void@
F << remove_static_max_chars_def_void.F;
P << remove_static_max_chars_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_max_chars_decl@
type T;
identifier F = max_chars;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_max_chars_decl@
F << remove_static_max_chars_decl.F;
T << remove_static_max_chars_decl.T;
P << remove_static_max_chars_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_max_chars_decl_void@
identifier F = max_chars;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_max_chars_decl_void@
F << remove_static_max_chars_decl_void.F;
P << remove_static_max_chars_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_max_chars_def@
type T;
identifier F = max_chars;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_max_chars_def@
F << extract_max_chars_def.F;
T << extract_max_chars_def.T;
P << extract_max_chars_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_max_chars_def_void@
identifier F = max_chars;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_max_chars_def_void@
F << extract_max_chars_def_void.F;
P << extract_max_chars_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_max_chars_decl@
type T;
identifier F = max_chars;
parameter list P;
@@
T F(P);

@script:python depends on extract_max_chars_decl@
F << extract_max_chars_decl.F;
T << extract_max_chars_decl.T;
P << extract_max_chars_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_max_chars_decl_void@
identifier F = max_chars;
parameter list P;
@@
void F(P);

@script:python depends on extract_max_chars_decl_void@
F << extract_max_chars_decl_void.F;
P << extract_max_chars_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: rsvp_clear_checksum
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_rsvp_clear_checksum_def@
type T;
identifier F = rsvp_clear_checksum;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_rsvp_clear_checksum_def@
F << remove_static_rsvp_clear_checksum_def.F;
T << remove_static_rsvp_clear_checksum_def.T;
P << remove_static_rsvp_clear_checksum_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_rsvp_clear_checksum_def_void@
identifier F = rsvp_clear_checksum;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_rsvp_clear_checksum_def_void@
F << remove_static_rsvp_clear_checksum_def_void.F;
P << remove_static_rsvp_clear_checksum_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_rsvp_clear_checksum_decl@
type T;
identifier F = rsvp_clear_checksum;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_rsvp_clear_checksum_decl@
F << remove_static_rsvp_clear_checksum_decl.F;
T << remove_static_rsvp_clear_checksum_decl.T;
P << remove_static_rsvp_clear_checksum_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_rsvp_clear_checksum_decl_void@
identifier F = rsvp_clear_checksum;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_rsvp_clear_checksum_decl_void@
F << remove_static_rsvp_clear_checksum_decl_void.F;
P << remove_static_rsvp_clear_checksum_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_rsvp_clear_checksum_def@
type T;
identifier F = rsvp_clear_checksum;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_rsvp_clear_checksum_def@
F << extract_rsvp_clear_checksum_def.F;
T << extract_rsvp_clear_checksum_def.T;
P << extract_rsvp_clear_checksum_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_rsvp_clear_checksum_def_void@
identifier F = rsvp_clear_checksum;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_rsvp_clear_checksum_def_void@
F << extract_rsvp_clear_checksum_def_void.F;
P << extract_rsvp_clear_checksum_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_rsvp_clear_checksum_decl@
type T;
identifier F = rsvp_clear_checksum;
parameter list P;
@@
T F(P);

@script:python depends on extract_rsvp_clear_checksum_decl@
F << extract_rsvp_clear_checksum_decl.F;
T << extract_rsvp_clear_checksum_decl.T;
P << extract_rsvp_clear_checksum_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_rsvp_clear_checksum_decl_void@
identifier F = rsvp_clear_checksum;
parameter list P;
@@
void F(P);

@script:python depends on extract_rsvp_clear_checksum_decl_void@
F << extract_rsvp_clear_checksum_decl_void.F;
P << extract_rsvp_clear_checksum_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: rtc_prefix_in_hex
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_rtc_prefix_in_hex_def@
type T;
identifier F = rtc_prefix_in_hex;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_rtc_prefix_in_hex_def@
F << remove_static_rtc_prefix_in_hex_def.F;
T << remove_static_rtc_prefix_in_hex_def.T;
P << remove_static_rtc_prefix_in_hex_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_rtc_prefix_in_hex_def_void@
identifier F = rtc_prefix_in_hex;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_rtc_prefix_in_hex_def_void@
F << remove_static_rtc_prefix_in_hex_def_void.F;
P << remove_static_rtc_prefix_in_hex_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_rtc_prefix_in_hex_decl@
type T;
identifier F = rtc_prefix_in_hex;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_rtc_prefix_in_hex_decl@
F << remove_static_rtc_prefix_in_hex_decl.F;
T << remove_static_rtc_prefix_in_hex_decl.T;
P << remove_static_rtc_prefix_in_hex_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_rtc_prefix_in_hex_decl_void@
identifier F = rtc_prefix_in_hex;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_rtc_prefix_in_hex_decl_void@
F << remove_static_rtc_prefix_in_hex_decl_void.F;
P << remove_static_rtc_prefix_in_hex_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_rtc_prefix_in_hex_def@
type T;
identifier F = rtc_prefix_in_hex;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_rtc_prefix_in_hex_def@
F << extract_rtc_prefix_in_hex_def.F;
T << extract_rtc_prefix_in_hex_def.T;
P << extract_rtc_prefix_in_hex_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_rtc_prefix_in_hex_def_void@
identifier F = rtc_prefix_in_hex;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_rtc_prefix_in_hex_def_void@
F << extract_rtc_prefix_in_hex_def_void.F;
P << extract_rtc_prefix_in_hex_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_rtc_prefix_in_hex_decl@
type T;
identifier F = rtc_prefix_in_hex;
parameter list P;
@@
T F(P);

@script:python depends on extract_rtc_prefix_in_hex_decl@
F << extract_rtc_prefix_in_hex_decl.F;
T << extract_rtc_prefix_in_hex_decl.T;
P << extract_rtc_prefix_in_hex_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_rtc_prefix_in_hex_decl_void@
identifier F = rtc_prefix_in_hex;
parameter list P;
@@
void F(P);

@script:python depends on extract_rtc_prefix_in_hex_decl_void@
F << extract_rtc_prefix_in_hex_decl_void.F;
P << extract_rtc_prefix_in_hex_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Consolidation Script
// ============================================================

@script:python@
@@
import os
import glob

print("\n>>> CONSOLIDATING FUNCTION DECLARATIONS")

target_functions = ["brcm_tag_print", "dsa_tag_print", "edsa_tag_print", "eui64_string", "icmp_code", "ip_proto", "isis_clear_checksum_lifetime", "lane_hdr_print", "mac48_string", "max_chars", "rsvp_clear_checksum", "rtc_prefix_in_hex"]

def_files = glob.glob("definitions/*.txt")
if not def_files:
    print(">>> No function declarations found to consolidate")
else:
    print(">>> Found %d function declarations" % len(def_files))
    
    # Read all declarations
    declarations = {}
    for def_file in sorted(def_files):
        func_name = os.path.basename(def_file).replace('.txt', '')
        try:
            with open(def_file, 'r') as f:
                signature = f.read().strip()
            declarations[func_name] = signature
        except Exception as e:
            print(">>> [ERROR] Failed to read %s: %s" % (def_file, e))
    
    # Write consolidated header file
    header_path = "extracted_declarations.h"
    try:
        with open(header_path, 'w') as f:
            f.write("/* Extracted function declarations */\n")
            f.write("/* Generated by Coccinelle script */\n")
            f.write("/* Static keyword removed where applicable */\n\n")
            f.write("#ifndef EXTRACTED_DECLARATIONS_H\n")
            f.write("#define EXTRACTED_DECLARATIONS_H\n\n")
            
            # Write declarations in sorted order
            for func_name in sorted(declarations.keys()):
                f.write(declarations[func_name] + "\n")
            
            f.write("\n#endif /* EXTRACTED_DECLARATIONS_H */\n")
        
        print(">>> Successfully created header: %s" % header_path)
        print(">>> Total declarations extracted: %d" % len(declarations))
        
        # Report missing functions
        missing = [f for f in target_functions if f not in declarations]
        if missing:
            print(">>> Missing declarations: %d" % len(missing))
            for m in missing[:10]:
                print(">>>   - %s" % m)
            if len(missing) > 10:
                print(">>>   ... and %d more" % (len(missing) - 10))
            
    except Exception as e:
        print(">>> [ERROR] Failed to create header: %s" % e)

print(">>> Consolidation complete")

@finalize:python@
@@
print("\n>>> PROCESSING COMPLETE")
print(">>> Total target functions: 12")
print(">>> Successfully extracted: %d" % len(processed_functions))
print(">>> Individual declarations: definitions/*.txt")
print(">>> Consolidated header: extracted_declarations.h")
