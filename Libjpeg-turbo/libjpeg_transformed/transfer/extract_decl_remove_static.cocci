//
// Coccinelle script to extract function declarations and remove 'static' keyword
//
// Generated by: 3_5_extract_fn_declarations.py
// Purpose: Extract function declarations from definitions, remove static keyword
//
// This script:
// 1. Finds function definitions and declarations
// 2. Removes static keyword if present
// 3. Extracts signatures as declaration form (with semicolon)
// 4. Saves to definitions/ folder and consolidates to header file
//
// Usage: spatch --sp-file extract_declarations.cocci --dir <source_directory> --in-place

// Shared Python functions
@initialize:python@
@@
import os
import re

# Track processed functions to avoid duplicates
processed_functions = set()

def clean_function_signature(signature):
    """Clean up function signature formatting"""
    if not signature:
        return signature
    
    # Normalize all whitespace
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Remove all spaces around asterisks first
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Add space before asterisk groups
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Clean up double spaces
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

def extract_and_save_signature(signature, func_name):
    """Extract and save function signature to file (skip if already processed)"""
    if func_name in processed_functions:
        return
    
    processed_functions.add(func_name)
    os.makedirs("definitions", exist_ok=True)
    clean_signature = clean_function_signature(signature)
    filepath = "definitions/" + func_name + ".txt"
    with open(filepath, "w") as f:
        f.write(clean_signature + "\n")
    print("[EXTRACTED] " + func_name)


// ============================================================
// Rules for function: _jpeg_fdct_ifast
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static__jpeg_fdct_ifast_def@
type T;
identifier F = _jpeg_fdct_ifast;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static__jpeg_fdct_ifast_def@
F << remove_static__jpeg_fdct_ifast_def.F;
T << remove_static__jpeg_fdct_ifast_def.T;
P << remove_static__jpeg_fdct_ifast_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static__jpeg_fdct_ifast_def_void@
identifier F = _jpeg_fdct_ifast;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static__jpeg_fdct_ifast_def_void@
F << remove_static__jpeg_fdct_ifast_def_void.F;
P << remove_static__jpeg_fdct_ifast_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static__jpeg_fdct_ifast_decl@
type T;
identifier F = _jpeg_fdct_ifast;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static__jpeg_fdct_ifast_decl@
F << remove_static__jpeg_fdct_ifast_decl.F;
T << remove_static__jpeg_fdct_ifast_decl.T;
P << remove_static__jpeg_fdct_ifast_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static__jpeg_fdct_ifast_decl_void@
identifier F = _jpeg_fdct_ifast;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static__jpeg_fdct_ifast_decl_void@
F << remove_static__jpeg_fdct_ifast_decl_void.F;
P << remove_static__jpeg_fdct_ifast_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract__jpeg_fdct_ifast_def@
type T;
identifier F = _jpeg_fdct_ifast;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract__jpeg_fdct_ifast_def@
F << extract__jpeg_fdct_ifast_def.F;
T << extract__jpeg_fdct_ifast_def.T;
P << extract__jpeg_fdct_ifast_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract__jpeg_fdct_ifast_def_void@
identifier F = _jpeg_fdct_ifast;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract__jpeg_fdct_ifast_def_void@
F << extract__jpeg_fdct_ifast_def_void.F;
P << extract__jpeg_fdct_ifast_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract__jpeg_fdct_ifast_decl@
type T;
identifier F = _jpeg_fdct_ifast;
parameter list P;
@@
T F(P);

@script:python depends on extract__jpeg_fdct_ifast_decl@
F << extract__jpeg_fdct_ifast_decl.F;
T << extract__jpeg_fdct_ifast_decl.T;
P << extract__jpeg_fdct_ifast_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract__jpeg_fdct_ifast_decl_void@
identifier F = _jpeg_fdct_ifast;
parameter list P;
@@
void F(P);

@script:python depends on extract__jpeg_fdct_ifast_decl_void@
F << extract__jpeg_fdct_ifast_decl_void.F;
P << extract__jpeg_fdct_ifast_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: _jpeg_fdct_islow
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static__jpeg_fdct_islow_def@
type T;
identifier F = _jpeg_fdct_islow;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static__jpeg_fdct_islow_def@
F << remove_static__jpeg_fdct_islow_def.F;
T << remove_static__jpeg_fdct_islow_def.T;
P << remove_static__jpeg_fdct_islow_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static__jpeg_fdct_islow_def_void@
identifier F = _jpeg_fdct_islow;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static__jpeg_fdct_islow_def_void@
F << remove_static__jpeg_fdct_islow_def_void.F;
P << remove_static__jpeg_fdct_islow_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static__jpeg_fdct_islow_decl@
type T;
identifier F = _jpeg_fdct_islow;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static__jpeg_fdct_islow_decl@
F << remove_static__jpeg_fdct_islow_decl.F;
T << remove_static__jpeg_fdct_islow_decl.T;
P << remove_static__jpeg_fdct_islow_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static__jpeg_fdct_islow_decl_void@
identifier F = _jpeg_fdct_islow;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static__jpeg_fdct_islow_decl_void@
F << remove_static__jpeg_fdct_islow_decl_void.F;
P << remove_static__jpeg_fdct_islow_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract__jpeg_fdct_islow_def@
type T;
identifier F = _jpeg_fdct_islow;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract__jpeg_fdct_islow_def@
F << extract__jpeg_fdct_islow_def.F;
T << extract__jpeg_fdct_islow_def.T;
P << extract__jpeg_fdct_islow_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract__jpeg_fdct_islow_def_void@
identifier F = _jpeg_fdct_islow;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract__jpeg_fdct_islow_def_void@
F << extract__jpeg_fdct_islow_def_void.F;
P << extract__jpeg_fdct_islow_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract__jpeg_fdct_islow_decl@
type T;
identifier F = _jpeg_fdct_islow;
parameter list P;
@@
T F(P);

@script:python depends on extract__jpeg_fdct_islow_decl@
F << extract__jpeg_fdct_islow_decl.F;
T << extract__jpeg_fdct_islow_decl.T;
P << extract__jpeg_fdct_islow_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract__jpeg_fdct_islow_decl_void@
identifier F = _jpeg_fdct_islow;
parameter list P;
@@
void F(P);

@script:python depends on extract__jpeg_fdct_islow_decl_void@
F << extract__jpeg_fdct_islow_decl_void.F;
P << extract__jpeg_fdct_islow_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: calc_buffer_dimensions_gif
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_calc_buffer_dimensions_gif_def@
type T;
identifier F = calc_buffer_dimensions_gif;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_calc_buffer_dimensions_gif_def@
F << remove_static_calc_buffer_dimensions_gif_def.F;
T << remove_static_calc_buffer_dimensions_gif_def.T;
P << remove_static_calc_buffer_dimensions_gif_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_calc_buffer_dimensions_gif_def_void@
identifier F = calc_buffer_dimensions_gif;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_calc_buffer_dimensions_gif_def_void@
F << remove_static_calc_buffer_dimensions_gif_def_void.F;
P << remove_static_calc_buffer_dimensions_gif_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_calc_buffer_dimensions_gif_decl@
type T;
identifier F = calc_buffer_dimensions_gif;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_calc_buffer_dimensions_gif_decl@
F << remove_static_calc_buffer_dimensions_gif_decl.F;
T << remove_static_calc_buffer_dimensions_gif_decl.T;
P << remove_static_calc_buffer_dimensions_gif_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_calc_buffer_dimensions_gif_decl_void@
identifier F = calc_buffer_dimensions_gif;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_calc_buffer_dimensions_gif_decl_void@
F << remove_static_calc_buffer_dimensions_gif_decl_void.F;
P << remove_static_calc_buffer_dimensions_gif_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_calc_buffer_dimensions_gif_def@
type T;
identifier F = calc_buffer_dimensions_gif;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_calc_buffer_dimensions_gif_def@
F << extract_calc_buffer_dimensions_gif_def.F;
T << extract_calc_buffer_dimensions_gif_def.T;
P << extract_calc_buffer_dimensions_gif_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_calc_buffer_dimensions_gif_def_void@
identifier F = calc_buffer_dimensions_gif;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_calc_buffer_dimensions_gif_def_void@
F << extract_calc_buffer_dimensions_gif_def_void.F;
P << extract_calc_buffer_dimensions_gif_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_calc_buffer_dimensions_gif_decl@
type T;
identifier F = calc_buffer_dimensions_gif;
parameter list P;
@@
T F(P);

@script:python depends on extract_calc_buffer_dimensions_gif_decl@
F << extract_calc_buffer_dimensions_gif_decl.F;
T << extract_calc_buffer_dimensions_gif_decl.T;
P << extract_calc_buffer_dimensions_gif_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_calc_buffer_dimensions_gif_decl_void@
identifier F = calc_buffer_dimensions_gif;
parameter list P;
@@
void F(P);

@script:python depends on extract_calc_buffer_dimensions_gif_decl_void@
F << extract_calc_buffer_dimensions_gif_decl_void.F;
P << extract_calc_buffer_dimensions_gif_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: calc_buffer_dimensions_ppm
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_calc_buffer_dimensions_ppm_def@
type T;
identifier F = calc_buffer_dimensions_ppm;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_calc_buffer_dimensions_ppm_def@
F << remove_static_calc_buffer_dimensions_ppm_def.F;
T << remove_static_calc_buffer_dimensions_ppm_def.T;
P << remove_static_calc_buffer_dimensions_ppm_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_calc_buffer_dimensions_ppm_def_void@
identifier F = calc_buffer_dimensions_ppm;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_calc_buffer_dimensions_ppm_def_void@
F << remove_static_calc_buffer_dimensions_ppm_def_void.F;
P << remove_static_calc_buffer_dimensions_ppm_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_calc_buffer_dimensions_ppm_decl@
type T;
identifier F = calc_buffer_dimensions_ppm;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_calc_buffer_dimensions_ppm_decl@
F << remove_static_calc_buffer_dimensions_ppm_decl.F;
T << remove_static_calc_buffer_dimensions_ppm_decl.T;
P << remove_static_calc_buffer_dimensions_ppm_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_calc_buffer_dimensions_ppm_decl_void@
identifier F = calc_buffer_dimensions_ppm;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_calc_buffer_dimensions_ppm_decl_void@
F << remove_static_calc_buffer_dimensions_ppm_decl_void.F;
P << remove_static_calc_buffer_dimensions_ppm_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_calc_buffer_dimensions_ppm_def@
type T;
identifier F = calc_buffer_dimensions_ppm;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_calc_buffer_dimensions_ppm_def@
F << extract_calc_buffer_dimensions_ppm_def.F;
T << extract_calc_buffer_dimensions_ppm_def.T;
P << extract_calc_buffer_dimensions_ppm_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_calc_buffer_dimensions_ppm_def_void@
identifier F = calc_buffer_dimensions_ppm;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_calc_buffer_dimensions_ppm_def_void@
F << extract_calc_buffer_dimensions_ppm_def_void.F;
P << extract_calc_buffer_dimensions_ppm_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_calc_buffer_dimensions_ppm_decl@
type T;
identifier F = calc_buffer_dimensions_ppm;
parameter list P;
@@
T F(P);

@script:python depends on extract_calc_buffer_dimensions_ppm_decl@
F << extract_calc_buffer_dimensions_ppm_decl.F;
T << extract_calc_buffer_dimensions_ppm_decl.T;
P << extract_calc_buffer_dimensions_ppm_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_calc_buffer_dimensions_ppm_decl_void@
identifier F = calc_buffer_dimensions_ppm;
parameter list P;
@@
void F(P);

@script:python depends on extract_calc_buffer_dimensions_ppm_decl_void@
F << extract_calc_buffer_dimensions_ppm_decl_void.F;
P << extract_calc_buffer_dimensions_ppm_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: calc_buffer_dimensions_tga
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_calc_buffer_dimensions_tga_def@
type T;
identifier F = calc_buffer_dimensions_tga;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_calc_buffer_dimensions_tga_def@
F << remove_static_calc_buffer_dimensions_tga_def.F;
T << remove_static_calc_buffer_dimensions_tga_def.T;
P << remove_static_calc_buffer_dimensions_tga_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_calc_buffer_dimensions_tga_def_void@
identifier F = calc_buffer_dimensions_tga;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_calc_buffer_dimensions_tga_def_void@
F << remove_static_calc_buffer_dimensions_tga_def_void.F;
P << remove_static_calc_buffer_dimensions_tga_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_calc_buffer_dimensions_tga_decl@
type T;
identifier F = calc_buffer_dimensions_tga;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_calc_buffer_dimensions_tga_decl@
F << remove_static_calc_buffer_dimensions_tga_decl.F;
T << remove_static_calc_buffer_dimensions_tga_decl.T;
P << remove_static_calc_buffer_dimensions_tga_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_calc_buffer_dimensions_tga_decl_void@
identifier F = calc_buffer_dimensions_tga;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_calc_buffer_dimensions_tga_decl_void@
F << remove_static_calc_buffer_dimensions_tga_decl_void.F;
P << remove_static_calc_buffer_dimensions_tga_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_calc_buffer_dimensions_tga_def@
type T;
identifier F = calc_buffer_dimensions_tga;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_calc_buffer_dimensions_tga_def@
F << extract_calc_buffer_dimensions_tga_def.F;
T << extract_calc_buffer_dimensions_tga_def.T;
P << extract_calc_buffer_dimensions_tga_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_calc_buffer_dimensions_tga_def_void@
identifier F = calc_buffer_dimensions_tga;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_calc_buffer_dimensions_tga_def_void@
F << extract_calc_buffer_dimensions_tga_def_void.F;
P << extract_calc_buffer_dimensions_tga_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_calc_buffer_dimensions_tga_decl@
type T;
identifier F = calc_buffer_dimensions_tga;
parameter list P;
@@
T F(P);

@script:python depends on extract_calc_buffer_dimensions_tga_decl@
F << extract_calc_buffer_dimensions_tga_decl.F;
T << extract_calc_buffer_dimensions_tga_decl.T;
P << extract_calc_buffer_dimensions_tga_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_calc_buffer_dimensions_tga_decl_void@
identifier F = calc_buffer_dimensions_tga;
parameter list P;
@@
void F(P);

@script:python depends on extract_calc_buffer_dimensions_tga_decl_void@
F << extract_calc_buffer_dimensions_tga_decl_void.F;
P << extract_calc_buffer_dimensions_tga_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: compress_output
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_compress_output_def@
type T;
identifier F = compress_output;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_compress_output_def@
F << remove_static_compress_output_def.F;
T << remove_static_compress_output_def.T;
P << remove_static_compress_output_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_compress_output_def_void@
identifier F = compress_output;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_compress_output_def_void@
F << remove_static_compress_output_def_void.F;
P << remove_static_compress_output_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_compress_output_decl@
type T;
identifier F = compress_output;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_compress_output_decl@
F << remove_static_compress_output_decl.F;
T << remove_static_compress_output_decl.T;
P << remove_static_compress_output_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_compress_output_decl_void@
identifier F = compress_output;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_compress_output_decl_void@
F << remove_static_compress_output_decl_void.F;
P << remove_static_compress_output_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_compress_output_def@
type T;
identifier F = compress_output;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_compress_output_def@
F << extract_compress_output_def.F;
T << extract_compress_output_def.T;
P << extract_compress_output_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_compress_output_def_void@
identifier F = compress_output;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_compress_output_def_void@
F << extract_compress_output_def_void.F;
P << extract_compress_output_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_compress_output_decl@
type T;
identifier F = compress_output;
parameter list P;
@@
T F(P);

@script:python depends on extract_compress_output_decl@
F << extract_compress_output_decl.F;
T << extract_compress_output_decl.T;
P << extract_compress_output_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_compress_output_decl_void@
identifier F = compress_output;
parameter list P;
@@
void F(P);

@script:python depends on extract_compress_output_decl_void@
F << extract_compress_output_decl_void.F;
P << extract_compress_output_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: compress_output_12
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_compress_output_12_def@
type T;
identifier F = compress_output_12;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_compress_output_12_def@
F << remove_static_compress_output_12_def.F;
T << remove_static_compress_output_12_def.T;
P << remove_static_compress_output_12_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_compress_output_12_def_void@
identifier F = compress_output_12;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_compress_output_12_def_void@
F << remove_static_compress_output_12_def_void.F;
P << remove_static_compress_output_12_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_compress_output_12_decl@
type T;
identifier F = compress_output_12;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_compress_output_12_decl@
F << remove_static_compress_output_12_decl.F;
T << remove_static_compress_output_12_decl.T;
P << remove_static_compress_output_12_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_compress_output_12_decl_void@
identifier F = compress_output_12;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_compress_output_12_decl_void@
F << remove_static_compress_output_12_decl_void.F;
P << remove_static_compress_output_12_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_compress_output_12_def@
type T;
identifier F = compress_output_12;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_compress_output_12_def@
F << extract_compress_output_12_def.F;
T << extract_compress_output_12_def.T;
P << extract_compress_output_12_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_compress_output_12_def_void@
identifier F = compress_output_12;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_compress_output_12_def_void@
F << extract_compress_output_12_def_void.F;
P << extract_compress_output_12_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_compress_output_12_decl@
type T;
identifier F = compress_output_12;
parameter list P;
@@
T F(P);

@script:python depends on extract_compress_output_12_decl@
F << extract_compress_output_12_decl.F;
T << extract_compress_output_12_decl.T;
P << extract_compress_output_12_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_compress_output_12_decl_void@
identifier F = compress_output_12;
parameter list P;
@@
void F(P);

@script:python depends on extract_compress_output_12_decl_void@
F << extract_compress_output_12_decl_void.F;
P << extract_compress_output_12_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: consume_markers
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_consume_markers_def@
type T;
identifier F = consume_markers;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_consume_markers_def@
F << remove_static_consume_markers_def.F;
T << remove_static_consume_markers_def.T;
P << remove_static_consume_markers_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_consume_markers_def_void@
identifier F = consume_markers;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_consume_markers_def_void@
F << remove_static_consume_markers_def_void.F;
P << remove_static_consume_markers_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_consume_markers_decl@
type T;
identifier F = consume_markers;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_consume_markers_decl@
F << remove_static_consume_markers_decl.F;
T << remove_static_consume_markers_decl.T;
P << remove_static_consume_markers_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_consume_markers_decl_void@
identifier F = consume_markers;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_consume_markers_decl_void@
F << remove_static_consume_markers_decl_void.F;
P << remove_static_consume_markers_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_consume_markers_def@
type T;
identifier F = consume_markers;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_consume_markers_def@
F << extract_consume_markers_def.F;
T << extract_consume_markers_def.T;
P << extract_consume_markers_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_consume_markers_def_void@
identifier F = consume_markers;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_consume_markers_def_void@
F << extract_consume_markers_def_void.F;
P << extract_consume_markers_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_consume_markers_decl@
type T;
identifier F = consume_markers;
parameter list P;
@@
T F(P);

@script:python depends on extract_consume_markers_decl@
F << extract_consume_markers_decl.F;
T << extract_consume_markers_decl.T;
P << extract_consume_markers_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_consume_markers_decl_void@
identifier F = consume_markers;
parameter list P;
@@
void F(P);

@script:python depends on extract_consume_markers_decl_void@
F << extract_consume_markers_decl_void.F;
P << extract_consume_markers_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: convsamp_float
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_convsamp_float_def@
type T;
identifier F = convsamp_float;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_convsamp_float_def@
F << remove_static_convsamp_float_def.F;
T << remove_static_convsamp_float_def.T;
P << remove_static_convsamp_float_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_convsamp_float_def_void@
identifier F = convsamp_float;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_convsamp_float_def_void@
F << remove_static_convsamp_float_def_void.F;
P << remove_static_convsamp_float_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_convsamp_float_decl@
type T;
identifier F = convsamp_float;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_convsamp_float_decl@
F << remove_static_convsamp_float_decl.F;
T << remove_static_convsamp_float_decl.T;
P << remove_static_convsamp_float_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_convsamp_float_decl_void@
identifier F = convsamp_float;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_convsamp_float_decl_void@
F << remove_static_convsamp_float_decl_void.F;
P << remove_static_convsamp_float_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_convsamp_float_def@
type T;
identifier F = convsamp_float;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_convsamp_float_def@
F << extract_convsamp_float_def.F;
T << extract_convsamp_float_def.T;
P << extract_convsamp_float_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_convsamp_float_def_void@
identifier F = convsamp_float;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_convsamp_float_def_void@
F << extract_convsamp_float_def_void.F;
P << extract_convsamp_float_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_convsamp_float_decl@
type T;
identifier F = convsamp_float;
parameter list P;
@@
T F(P);

@script:python depends on extract_convsamp_float_decl@
F << extract_convsamp_float_decl.F;
T << extract_convsamp_float_decl.T;
P << extract_convsamp_float_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_convsamp_float_decl_void@
identifier F = convsamp_float;
parameter list P;
@@
void F(P);

@script:python depends on extract_convsamp_float_decl_void@
F << extract_convsamp_float_decl_void.F;
P << extract_convsamp_float_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: copy_pixel_rows
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_copy_pixel_rows_def@
type T;
identifier F = copy_pixel_rows;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_copy_pixel_rows_def@
F << remove_static_copy_pixel_rows_def.F;
T << remove_static_copy_pixel_rows_def.T;
P << remove_static_copy_pixel_rows_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_copy_pixel_rows_def_void@
identifier F = copy_pixel_rows;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_copy_pixel_rows_def_void@
F << remove_static_copy_pixel_rows_def_void.F;
P << remove_static_copy_pixel_rows_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_copy_pixel_rows_decl@
type T;
identifier F = copy_pixel_rows;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_copy_pixel_rows_decl@
F << remove_static_copy_pixel_rows_decl.F;
T << remove_static_copy_pixel_rows_decl.T;
P << remove_static_copy_pixel_rows_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_copy_pixel_rows_decl_void@
identifier F = copy_pixel_rows;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_copy_pixel_rows_decl_void@
F << remove_static_copy_pixel_rows_decl_void.F;
P << remove_static_copy_pixel_rows_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_copy_pixel_rows_def@
type T;
identifier F = copy_pixel_rows;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_copy_pixel_rows_def@
F << extract_copy_pixel_rows_def.F;
T << extract_copy_pixel_rows_def.T;
P << extract_copy_pixel_rows_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_copy_pixel_rows_def_void@
identifier F = copy_pixel_rows;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_copy_pixel_rows_def_void@
F << extract_copy_pixel_rows_def_void.F;
P << extract_copy_pixel_rows_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_copy_pixel_rows_decl@
type T;
identifier F = copy_pixel_rows;
parameter list P;
@@
T F(P);

@script:python depends on extract_copy_pixel_rows_decl@
F << extract_copy_pixel_rows_decl.F;
T << extract_copy_pixel_rows_decl.T;
P << extract_copy_pixel_rows_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_copy_pixel_rows_decl_void@
identifier F = copy_pixel_rows;
parameter list P;
@@
void F(P);

@script:python depends on extract_copy_pixel_rows_decl_void@
F << extract_copy_pixel_rows_decl_void.F;
P << extract_copy_pixel_rows_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: decode_mcu_AC_first
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_decode_mcu_AC_first_def@
type T;
identifier F = decode_mcu_AC_first;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_decode_mcu_AC_first_def@
F << remove_static_decode_mcu_AC_first_def.F;
T << remove_static_decode_mcu_AC_first_def.T;
P << remove_static_decode_mcu_AC_first_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_decode_mcu_AC_first_def_void@
identifier F = decode_mcu_AC_first;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_decode_mcu_AC_first_def_void@
F << remove_static_decode_mcu_AC_first_def_void.F;
P << remove_static_decode_mcu_AC_first_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_decode_mcu_AC_first_decl@
type T;
identifier F = decode_mcu_AC_first;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_decode_mcu_AC_first_decl@
F << remove_static_decode_mcu_AC_first_decl.F;
T << remove_static_decode_mcu_AC_first_decl.T;
P << remove_static_decode_mcu_AC_first_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_decode_mcu_AC_first_decl_void@
identifier F = decode_mcu_AC_first;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_decode_mcu_AC_first_decl_void@
F << remove_static_decode_mcu_AC_first_decl_void.F;
P << remove_static_decode_mcu_AC_first_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_decode_mcu_AC_first_def@
type T;
identifier F = decode_mcu_AC_first;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_decode_mcu_AC_first_def@
F << extract_decode_mcu_AC_first_def.F;
T << extract_decode_mcu_AC_first_def.T;
P << extract_decode_mcu_AC_first_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_decode_mcu_AC_first_def_void@
identifier F = decode_mcu_AC_first;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_decode_mcu_AC_first_def_void@
F << extract_decode_mcu_AC_first_def_void.F;
P << extract_decode_mcu_AC_first_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_decode_mcu_AC_first_decl@
type T;
identifier F = decode_mcu_AC_first;
parameter list P;
@@
T F(P);

@script:python depends on extract_decode_mcu_AC_first_decl@
F << extract_decode_mcu_AC_first_decl.F;
T << extract_decode_mcu_AC_first_decl.T;
P << extract_decode_mcu_AC_first_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_decode_mcu_AC_first_decl_void@
identifier F = decode_mcu_AC_first;
parameter list P;
@@
void F(P);

@script:python depends on extract_decode_mcu_AC_first_decl_void@
F << extract_decode_mcu_AC_first_decl_void.F;
P << extract_decode_mcu_AC_first_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: decode_mcu_AC_refine
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_decode_mcu_AC_refine_def@
type T;
identifier F = decode_mcu_AC_refine;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_decode_mcu_AC_refine_def@
F << remove_static_decode_mcu_AC_refine_def.F;
T << remove_static_decode_mcu_AC_refine_def.T;
P << remove_static_decode_mcu_AC_refine_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_decode_mcu_AC_refine_def_void@
identifier F = decode_mcu_AC_refine;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_decode_mcu_AC_refine_def_void@
F << remove_static_decode_mcu_AC_refine_def_void.F;
P << remove_static_decode_mcu_AC_refine_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_decode_mcu_AC_refine_decl@
type T;
identifier F = decode_mcu_AC_refine;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_decode_mcu_AC_refine_decl@
F << remove_static_decode_mcu_AC_refine_decl.F;
T << remove_static_decode_mcu_AC_refine_decl.T;
P << remove_static_decode_mcu_AC_refine_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_decode_mcu_AC_refine_decl_void@
identifier F = decode_mcu_AC_refine;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_decode_mcu_AC_refine_decl_void@
F << remove_static_decode_mcu_AC_refine_decl_void.F;
P << remove_static_decode_mcu_AC_refine_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_decode_mcu_AC_refine_def@
type T;
identifier F = decode_mcu_AC_refine;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_decode_mcu_AC_refine_def@
F << extract_decode_mcu_AC_refine_def.F;
T << extract_decode_mcu_AC_refine_def.T;
P << extract_decode_mcu_AC_refine_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_decode_mcu_AC_refine_def_void@
identifier F = decode_mcu_AC_refine;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_decode_mcu_AC_refine_def_void@
F << extract_decode_mcu_AC_refine_def_void.F;
P << extract_decode_mcu_AC_refine_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_decode_mcu_AC_refine_decl@
type T;
identifier F = decode_mcu_AC_refine;
parameter list P;
@@
T F(P);

@script:python depends on extract_decode_mcu_AC_refine_decl@
F << extract_decode_mcu_AC_refine_decl.F;
T << extract_decode_mcu_AC_refine_decl.T;
P << extract_decode_mcu_AC_refine_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_decode_mcu_AC_refine_decl_void@
identifier F = decode_mcu_AC_refine;
parameter list P;
@@
void F(P);

@script:python depends on extract_decode_mcu_AC_refine_decl_void@
F << extract_decode_mcu_AC_refine_decl_void.F;
P << extract_decode_mcu_AC_refine_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: decode_mcu_DC_first
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_decode_mcu_DC_first_def@
type T;
identifier F = decode_mcu_DC_first;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_decode_mcu_DC_first_def@
F << remove_static_decode_mcu_DC_first_def.F;
T << remove_static_decode_mcu_DC_first_def.T;
P << remove_static_decode_mcu_DC_first_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_decode_mcu_DC_first_def_void@
identifier F = decode_mcu_DC_first;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_decode_mcu_DC_first_def_void@
F << remove_static_decode_mcu_DC_first_def_void.F;
P << remove_static_decode_mcu_DC_first_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_decode_mcu_DC_first_decl@
type T;
identifier F = decode_mcu_DC_first;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_decode_mcu_DC_first_decl@
F << remove_static_decode_mcu_DC_first_decl.F;
T << remove_static_decode_mcu_DC_first_decl.T;
P << remove_static_decode_mcu_DC_first_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_decode_mcu_DC_first_decl_void@
identifier F = decode_mcu_DC_first;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_decode_mcu_DC_first_decl_void@
F << remove_static_decode_mcu_DC_first_decl_void.F;
P << remove_static_decode_mcu_DC_first_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_decode_mcu_DC_first_def@
type T;
identifier F = decode_mcu_DC_first;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_decode_mcu_DC_first_def@
F << extract_decode_mcu_DC_first_def.F;
T << extract_decode_mcu_DC_first_def.T;
P << extract_decode_mcu_DC_first_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_decode_mcu_DC_first_def_void@
identifier F = decode_mcu_DC_first;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_decode_mcu_DC_first_def_void@
F << extract_decode_mcu_DC_first_def_void.F;
P << extract_decode_mcu_DC_first_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_decode_mcu_DC_first_decl@
type T;
identifier F = decode_mcu_DC_first;
parameter list P;
@@
T F(P);

@script:python depends on extract_decode_mcu_DC_first_decl@
F << extract_decode_mcu_DC_first_decl.F;
T << extract_decode_mcu_DC_first_decl.T;
P << extract_decode_mcu_DC_first_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_decode_mcu_DC_first_decl_void@
identifier F = decode_mcu_DC_first;
parameter list P;
@@
void F(P);

@script:python depends on extract_decode_mcu_DC_first_decl_void@
F << extract_decode_mcu_DC_first_decl_void.F;
P << extract_decode_mcu_DC_first_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: decode_mcu_DC_refine
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_decode_mcu_DC_refine_def@
type T;
identifier F = decode_mcu_DC_refine;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_decode_mcu_DC_refine_def@
F << remove_static_decode_mcu_DC_refine_def.F;
T << remove_static_decode_mcu_DC_refine_def.T;
P << remove_static_decode_mcu_DC_refine_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_decode_mcu_DC_refine_def_void@
identifier F = decode_mcu_DC_refine;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_decode_mcu_DC_refine_def_void@
F << remove_static_decode_mcu_DC_refine_def_void.F;
P << remove_static_decode_mcu_DC_refine_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_decode_mcu_DC_refine_decl@
type T;
identifier F = decode_mcu_DC_refine;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_decode_mcu_DC_refine_decl@
F << remove_static_decode_mcu_DC_refine_decl.F;
T << remove_static_decode_mcu_DC_refine_decl.T;
P << remove_static_decode_mcu_DC_refine_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_decode_mcu_DC_refine_decl_void@
identifier F = decode_mcu_DC_refine;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_decode_mcu_DC_refine_decl_void@
F << remove_static_decode_mcu_DC_refine_decl_void.F;
P << remove_static_decode_mcu_DC_refine_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_decode_mcu_DC_refine_def@
type T;
identifier F = decode_mcu_DC_refine;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_decode_mcu_DC_refine_def@
F << extract_decode_mcu_DC_refine_def.F;
T << extract_decode_mcu_DC_refine_def.T;
P << extract_decode_mcu_DC_refine_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_decode_mcu_DC_refine_def_void@
identifier F = decode_mcu_DC_refine;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_decode_mcu_DC_refine_def_void@
F << extract_decode_mcu_DC_refine_def_void.F;
P << extract_decode_mcu_DC_refine_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_decode_mcu_DC_refine_decl@
type T;
identifier F = decode_mcu_DC_refine;
parameter list P;
@@
T F(P);

@script:python depends on extract_decode_mcu_DC_refine_decl@
F << extract_decode_mcu_DC_refine_decl.F;
T << extract_decode_mcu_DC_refine_decl.T;
P << extract_decode_mcu_DC_refine_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_decode_mcu_DC_refine_decl_void@
identifier F = decode_mcu_DC_refine;
parameter list P;
@@
void F(P);

@script:python depends on extract_decode_mcu_DC_refine_decl_void@
F << extract_decode_mcu_DC_refine_decl_void.F;
P << extract_decode_mcu_DC_refine_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: dummy_consume_data
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_dummy_consume_data_def@
type T;
identifier F = dummy_consume_data;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_dummy_consume_data_def@
F << remove_static_dummy_consume_data_def.F;
T << remove_static_dummy_consume_data_def.T;
P << remove_static_dummy_consume_data_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_dummy_consume_data_def_void@
identifier F = dummy_consume_data;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_dummy_consume_data_def_void@
F << remove_static_dummy_consume_data_def_void.F;
P << remove_static_dummy_consume_data_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_dummy_consume_data_decl@
type T;
identifier F = dummy_consume_data;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_dummy_consume_data_decl@
F << remove_static_dummy_consume_data_decl.F;
T << remove_static_dummy_consume_data_decl.T;
P << remove_static_dummy_consume_data_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_dummy_consume_data_decl_void@
identifier F = dummy_consume_data;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_dummy_consume_data_decl_void@
F << remove_static_dummy_consume_data_decl_void.F;
P << remove_static_dummy_consume_data_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_dummy_consume_data_def@
type T;
identifier F = dummy_consume_data;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_dummy_consume_data_def@
F << extract_dummy_consume_data_def.F;
T << extract_dummy_consume_data_def.T;
P << extract_dummy_consume_data_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_dummy_consume_data_def_void@
identifier F = dummy_consume_data;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_dummy_consume_data_def_void@
F << extract_dummy_consume_data_def_void.F;
P << extract_dummy_consume_data_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_dummy_consume_data_decl@
type T;
identifier F = dummy_consume_data;
parameter list P;
@@
T F(P);

@script:python depends on extract_dummy_consume_data_decl@
F << extract_dummy_consume_data_decl.F;
T << extract_dummy_consume_data_decl.T;
P << extract_dummy_consume_data_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_dummy_consume_data_decl_void@
identifier F = dummy_consume_data;
parameter list P;
@@
void F(P);

@script:python depends on extract_dummy_consume_data_decl_void@
F << extract_dummy_consume_data_decl_void.F;
P << extract_dummy_consume_data_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: empty_mem_output_buffer
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_empty_mem_output_buffer_def@
type T;
identifier F = empty_mem_output_buffer;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_empty_mem_output_buffer_def@
F << remove_static_empty_mem_output_buffer_def.F;
T << remove_static_empty_mem_output_buffer_def.T;
P << remove_static_empty_mem_output_buffer_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_empty_mem_output_buffer_def_void@
identifier F = empty_mem_output_buffer;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_empty_mem_output_buffer_def_void@
F << remove_static_empty_mem_output_buffer_def_void.F;
P << remove_static_empty_mem_output_buffer_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_empty_mem_output_buffer_decl@
type T;
identifier F = empty_mem_output_buffer;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_empty_mem_output_buffer_decl@
F << remove_static_empty_mem_output_buffer_decl.F;
T << remove_static_empty_mem_output_buffer_decl.T;
P << remove_static_empty_mem_output_buffer_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_empty_mem_output_buffer_decl_void@
identifier F = empty_mem_output_buffer;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_empty_mem_output_buffer_decl_void@
F << remove_static_empty_mem_output_buffer_decl_void.F;
P << remove_static_empty_mem_output_buffer_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_empty_mem_output_buffer_def@
type T;
identifier F = empty_mem_output_buffer;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_empty_mem_output_buffer_def@
F << extract_empty_mem_output_buffer_def.F;
T << extract_empty_mem_output_buffer_def.T;
P << extract_empty_mem_output_buffer_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_empty_mem_output_buffer_def_void@
identifier F = empty_mem_output_buffer;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_empty_mem_output_buffer_def_void@
F << extract_empty_mem_output_buffer_def_void.F;
P << extract_empty_mem_output_buffer_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_empty_mem_output_buffer_decl@
type T;
identifier F = empty_mem_output_buffer;
parameter list P;
@@
T F(P);

@script:python depends on extract_empty_mem_output_buffer_decl@
F << extract_empty_mem_output_buffer_decl.F;
T << extract_empty_mem_output_buffer_decl.T;
P << extract_empty_mem_output_buffer_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_empty_mem_output_buffer_decl_void@
identifier F = empty_mem_output_buffer;
parameter list P;
@@
void F(P);

@script:python depends on extract_empty_mem_output_buffer_decl_void@
F << extract_empty_mem_output_buffer_decl_void.F;
P << extract_empty_mem_output_buffer_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: encode_mcu_AC_first
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_encode_mcu_AC_first_def@
type T;
identifier F = encode_mcu_AC_first;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_encode_mcu_AC_first_def@
F << remove_static_encode_mcu_AC_first_def.F;
T << remove_static_encode_mcu_AC_first_def.T;
P << remove_static_encode_mcu_AC_first_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_encode_mcu_AC_first_def_void@
identifier F = encode_mcu_AC_first;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_encode_mcu_AC_first_def_void@
F << remove_static_encode_mcu_AC_first_def_void.F;
P << remove_static_encode_mcu_AC_first_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_encode_mcu_AC_first_decl@
type T;
identifier F = encode_mcu_AC_first;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_encode_mcu_AC_first_decl@
F << remove_static_encode_mcu_AC_first_decl.F;
T << remove_static_encode_mcu_AC_first_decl.T;
P << remove_static_encode_mcu_AC_first_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_encode_mcu_AC_first_decl_void@
identifier F = encode_mcu_AC_first;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_encode_mcu_AC_first_decl_void@
F << remove_static_encode_mcu_AC_first_decl_void.F;
P << remove_static_encode_mcu_AC_first_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_encode_mcu_AC_first_def@
type T;
identifier F = encode_mcu_AC_first;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_encode_mcu_AC_first_def@
F << extract_encode_mcu_AC_first_def.F;
T << extract_encode_mcu_AC_first_def.T;
P << extract_encode_mcu_AC_first_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_encode_mcu_AC_first_def_void@
identifier F = encode_mcu_AC_first;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_encode_mcu_AC_first_def_void@
F << extract_encode_mcu_AC_first_def_void.F;
P << extract_encode_mcu_AC_first_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_encode_mcu_AC_first_decl@
type T;
identifier F = encode_mcu_AC_first;
parameter list P;
@@
T F(P);

@script:python depends on extract_encode_mcu_AC_first_decl@
F << extract_encode_mcu_AC_first_decl.F;
T << extract_encode_mcu_AC_first_decl.T;
P << extract_encode_mcu_AC_first_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_encode_mcu_AC_first_decl_void@
identifier F = encode_mcu_AC_first;
parameter list P;
@@
void F(P);

@script:python depends on extract_encode_mcu_AC_first_decl_void@
F << extract_encode_mcu_AC_first_decl_void.F;
P << extract_encode_mcu_AC_first_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: encode_mcu_AC_first_prepare
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_encode_mcu_AC_first_prepare_def@
type T;
identifier F = encode_mcu_AC_first_prepare;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_encode_mcu_AC_first_prepare_def@
F << remove_static_encode_mcu_AC_first_prepare_def.F;
T << remove_static_encode_mcu_AC_first_prepare_def.T;
P << remove_static_encode_mcu_AC_first_prepare_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_encode_mcu_AC_first_prepare_def_void@
identifier F = encode_mcu_AC_first_prepare;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_encode_mcu_AC_first_prepare_def_void@
F << remove_static_encode_mcu_AC_first_prepare_def_void.F;
P << remove_static_encode_mcu_AC_first_prepare_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_encode_mcu_AC_first_prepare_decl@
type T;
identifier F = encode_mcu_AC_first_prepare;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_encode_mcu_AC_first_prepare_decl@
F << remove_static_encode_mcu_AC_first_prepare_decl.F;
T << remove_static_encode_mcu_AC_first_prepare_decl.T;
P << remove_static_encode_mcu_AC_first_prepare_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_encode_mcu_AC_first_prepare_decl_void@
identifier F = encode_mcu_AC_first_prepare;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_encode_mcu_AC_first_prepare_decl_void@
F << remove_static_encode_mcu_AC_first_prepare_decl_void.F;
P << remove_static_encode_mcu_AC_first_prepare_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_encode_mcu_AC_first_prepare_def@
type T;
identifier F = encode_mcu_AC_first_prepare;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_encode_mcu_AC_first_prepare_def@
F << extract_encode_mcu_AC_first_prepare_def.F;
T << extract_encode_mcu_AC_first_prepare_def.T;
P << extract_encode_mcu_AC_first_prepare_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_encode_mcu_AC_first_prepare_def_void@
identifier F = encode_mcu_AC_first_prepare;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_encode_mcu_AC_first_prepare_def_void@
F << extract_encode_mcu_AC_first_prepare_def_void.F;
P << extract_encode_mcu_AC_first_prepare_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_encode_mcu_AC_first_prepare_decl@
type T;
identifier F = encode_mcu_AC_first_prepare;
parameter list P;
@@
T F(P);

@script:python depends on extract_encode_mcu_AC_first_prepare_decl@
F << extract_encode_mcu_AC_first_prepare_decl.F;
T << extract_encode_mcu_AC_first_prepare_decl.T;
P << extract_encode_mcu_AC_first_prepare_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_encode_mcu_AC_first_prepare_decl_void@
identifier F = encode_mcu_AC_first_prepare;
parameter list P;
@@
void F(P);

@script:python depends on extract_encode_mcu_AC_first_prepare_decl_void@
F << extract_encode_mcu_AC_first_prepare_decl_void.F;
P << extract_encode_mcu_AC_first_prepare_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: encode_mcu_AC_refine
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_encode_mcu_AC_refine_def@
type T;
identifier F = encode_mcu_AC_refine;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_encode_mcu_AC_refine_def@
F << remove_static_encode_mcu_AC_refine_def.F;
T << remove_static_encode_mcu_AC_refine_def.T;
P << remove_static_encode_mcu_AC_refine_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_encode_mcu_AC_refine_def_void@
identifier F = encode_mcu_AC_refine;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_encode_mcu_AC_refine_def_void@
F << remove_static_encode_mcu_AC_refine_def_void.F;
P << remove_static_encode_mcu_AC_refine_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_encode_mcu_AC_refine_decl@
type T;
identifier F = encode_mcu_AC_refine;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_encode_mcu_AC_refine_decl@
F << remove_static_encode_mcu_AC_refine_decl.F;
T << remove_static_encode_mcu_AC_refine_decl.T;
P << remove_static_encode_mcu_AC_refine_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_encode_mcu_AC_refine_decl_void@
identifier F = encode_mcu_AC_refine;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_encode_mcu_AC_refine_decl_void@
F << remove_static_encode_mcu_AC_refine_decl_void.F;
P << remove_static_encode_mcu_AC_refine_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_encode_mcu_AC_refine_def@
type T;
identifier F = encode_mcu_AC_refine;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_encode_mcu_AC_refine_def@
F << extract_encode_mcu_AC_refine_def.F;
T << extract_encode_mcu_AC_refine_def.T;
P << extract_encode_mcu_AC_refine_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_encode_mcu_AC_refine_def_void@
identifier F = encode_mcu_AC_refine;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_encode_mcu_AC_refine_def_void@
F << extract_encode_mcu_AC_refine_def_void.F;
P << extract_encode_mcu_AC_refine_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_encode_mcu_AC_refine_decl@
type T;
identifier F = encode_mcu_AC_refine;
parameter list P;
@@
T F(P);

@script:python depends on extract_encode_mcu_AC_refine_decl@
F << extract_encode_mcu_AC_refine_decl.F;
T << extract_encode_mcu_AC_refine_decl.T;
P << extract_encode_mcu_AC_refine_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_encode_mcu_AC_refine_decl_void@
identifier F = encode_mcu_AC_refine;
parameter list P;
@@
void F(P);

@script:python depends on extract_encode_mcu_AC_refine_decl_void@
F << extract_encode_mcu_AC_refine_decl_void.F;
P << extract_encode_mcu_AC_refine_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: encode_mcu_AC_refine_prepare
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_encode_mcu_AC_refine_prepare_def@
type T;
identifier F = encode_mcu_AC_refine_prepare;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_encode_mcu_AC_refine_prepare_def@
F << remove_static_encode_mcu_AC_refine_prepare_def.F;
T << remove_static_encode_mcu_AC_refine_prepare_def.T;
P << remove_static_encode_mcu_AC_refine_prepare_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_encode_mcu_AC_refine_prepare_def_void@
identifier F = encode_mcu_AC_refine_prepare;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_encode_mcu_AC_refine_prepare_def_void@
F << remove_static_encode_mcu_AC_refine_prepare_def_void.F;
P << remove_static_encode_mcu_AC_refine_prepare_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_encode_mcu_AC_refine_prepare_decl@
type T;
identifier F = encode_mcu_AC_refine_prepare;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_encode_mcu_AC_refine_prepare_decl@
F << remove_static_encode_mcu_AC_refine_prepare_decl.F;
T << remove_static_encode_mcu_AC_refine_prepare_decl.T;
P << remove_static_encode_mcu_AC_refine_prepare_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_encode_mcu_AC_refine_prepare_decl_void@
identifier F = encode_mcu_AC_refine_prepare;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_encode_mcu_AC_refine_prepare_decl_void@
F << remove_static_encode_mcu_AC_refine_prepare_decl_void.F;
P << remove_static_encode_mcu_AC_refine_prepare_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_encode_mcu_AC_refine_prepare_def@
type T;
identifier F = encode_mcu_AC_refine_prepare;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_encode_mcu_AC_refine_prepare_def@
F << extract_encode_mcu_AC_refine_prepare_def.F;
T << extract_encode_mcu_AC_refine_prepare_def.T;
P << extract_encode_mcu_AC_refine_prepare_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_encode_mcu_AC_refine_prepare_def_void@
identifier F = encode_mcu_AC_refine_prepare;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_encode_mcu_AC_refine_prepare_def_void@
F << extract_encode_mcu_AC_refine_prepare_def_void.F;
P << extract_encode_mcu_AC_refine_prepare_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_encode_mcu_AC_refine_prepare_decl@
type T;
identifier F = encode_mcu_AC_refine_prepare;
parameter list P;
@@
T F(P);

@script:python depends on extract_encode_mcu_AC_refine_prepare_decl@
F << extract_encode_mcu_AC_refine_prepare_decl.F;
T << extract_encode_mcu_AC_refine_prepare_decl.T;
P << extract_encode_mcu_AC_refine_prepare_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_encode_mcu_AC_refine_prepare_decl_void@
identifier F = encode_mcu_AC_refine_prepare;
parameter list P;
@@
void F(P);

@script:python depends on extract_encode_mcu_AC_refine_prepare_decl_void@
F << extract_encode_mcu_AC_refine_prepare_decl_void.F;
P << extract_encode_mcu_AC_refine_prepare_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: encode_mcu_DC_first
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_encode_mcu_DC_first_def@
type T;
identifier F = encode_mcu_DC_first;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_encode_mcu_DC_first_def@
F << remove_static_encode_mcu_DC_first_def.F;
T << remove_static_encode_mcu_DC_first_def.T;
P << remove_static_encode_mcu_DC_first_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_encode_mcu_DC_first_def_void@
identifier F = encode_mcu_DC_first;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_encode_mcu_DC_first_def_void@
F << remove_static_encode_mcu_DC_first_def_void.F;
P << remove_static_encode_mcu_DC_first_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_encode_mcu_DC_first_decl@
type T;
identifier F = encode_mcu_DC_first;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_encode_mcu_DC_first_decl@
F << remove_static_encode_mcu_DC_first_decl.F;
T << remove_static_encode_mcu_DC_first_decl.T;
P << remove_static_encode_mcu_DC_first_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_encode_mcu_DC_first_decl_void@
identifier F = encode_mcu_DC_first;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_encode_mcu_DC_first_decl_void@
F << remove_static_encode_mcu_DC_first_decl_void.F;
P << remove_static_encode_mcu_DC_first_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_encode_mcu_DC_first_def@
type T;
identifier F = encode_mcu_DC_first;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_encode_mcu_DC_first_def@
F << extract_encode_mcu_DC_first_def.F;
T << extract_encode_mcu_DC_first_def.T;
P << extract_encode_mcu_DC_first_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_encode_mcu_DC_first_def_void@
identifier F = encode_mcu_DC_first;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_encode_mcu_DC_first_def_void@
F << extract_encode_mcu_DC_first_def_void.F;
P << extract_encode_mcu_DC_first_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_encode_mcu_DC_first_decl@
type T;
identifier F = encode_mcu_DC_first;
parameter list P;
@@
T F(P);

@script:python depends on extract_encode_mcu_DC_first_decl@
F << extract_encode_mcu_DC_first_decl.F;
T << extract_encode_mcu_DC_first_decl.T;
P << extract_encode_mcu_DC_first_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_encode_mcu_DC_first_decl_void@
identifier F = encode_mcu_DC_first;
parameter list P;
@@
void F(P);

@script:python depends on extract_encode_mcu_DC_first_decl_void@
F << extract_encode_mcu_DC_first_decl_void.F;
P << extract_encode_mcu_DC_first_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: encode_mcu_DC_refine
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_encode_mcu_DC_refine_def@
type T;
identifier F = encode_mcu_DC_refine;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_encode_mcu_DC_refine_def@
F << remove_static_encode_mcu_DC_refine_def.F;
T << remove_static_encode_mcu_DC_refine_def.T;
P << remove_static_encode_mcu_DC_refine_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_encode_mcu_DC_refine_def_void@
identifier F = encode_mcu_DC_refine;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_encode_mcu_DC_refine_def_void@
F << remove_static_encode_mcu_DC_refine_def_void.F;
P << remove_static_encode_mcu_DC_refine_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_encode_mcu_DC_refine_decl@
type T;
identifier F = encode_mcu_DC_refine;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_encode_mcu_DC_refine_decl@
F << remove_static_encode_mcu_DC_refine_decl.F;
T << remove_static_encode_mcu_DC_refine_decl.T;
P << remove_static_encode_mcu_DC_refine_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_encode_mcu_DC_refine_decl_void@
identifier F = encode_mcu_DC_refine;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_encode_mcu_DC_refine_decl_void@
F << remove_static_encode_mcu_DC_refine_decl_void.F;
P << remove_static_encode_mcu_DC_refine_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_encode_mcu_DC_refine_def@
type T;
identifier F = encode_mcu_DC_refine;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_encode_mcu_DC_refine_def@
F << extract_encode_mcu_DC_refine_def.F;
T << extract_encode_mcu_DC_refine_def.T;
P << extract_encode_mcu_DC_refine_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_encode_mcu_DC_refine_def_void@
identifier F = encode_mcu_DC_refine;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_encode_mcu_DC_refine_def_void@
F << extract_encode_mcu_DC_refine_def_void.F;
P << extract_encode_mcu_DC_refine_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_encode_mcu_DC_refine_decl@
type T;
identifier F = encode_mcu_DC_refine;
parameter list P;
@@
T F(P);

@script:python depends on extract_encode_mcu_DC_refine_decl@
F << extract_encode_mcu_DC_refine_decl.F;
T << extract_encode_mcu_DC_refine_decl.T;
P << extract_encode_mcu_DC_refine_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_encode_mcu_DC_refine_decl_void@
identifier F = encode_mcu_DC_refine;
parameter list P;
@@
void F(P);

@script:python depends on extract_encode_mcu_DC_refine_decl_void@
F << extract_encode_mcu_DC_refine_decl_void.F;
P << extract_encode_mcu_DC_refine_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: encode_mcu_gather
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_encode_mcu_gather_def@
type T;
identifier F = encode_mcu_gather;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_encode_mcu_gather_def@
F << remove_static_encode_mcu_gather_def.F;
T << remove_static_encode_mcu_gather_def.T;
P << remove_static_encode_mcu_gather_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_encode_mcu_gather_def_void@
identifier F = encode_mcu_gather;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_encode_mcu_gather_def_void@
F << remove_static_encode_mcu_gather_def_void.F;
P << remove_static_encode_mcu_gather_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_encode_mcu_gather_decl@
type T;
identifier F = encode_mcu_gather;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_encode_mcu_gather_decl@
F << remove_static_encode_mcu_gather_decl.F;
T << remove_static_encode_mcu_gather_decl.T;
P << remove_static_encode_mcu_gather_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_encode_mcu_gather_decl_void@
identifier F = encode_mcu_gather;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_encode_mcu_gather_decl_void@
F << remove_static_encode_mcu_gather_decl_void.F;
P << remove_static_encode_mcu_gather_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_encode_mcu_gather_def@
type T;
identifier F = encode_mcu_gather;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_encode_mcu_gather_def@
F << extract_encode_mcu_gather_def.F;
T << extract_encode_mcu_gather_def.T;
P << extract_encode_mcu_gather_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_encode_mcu_gather_def_void@
identifier F = encode_mcu_gather;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_encode_mcu_gather_def_void@
F << extract_encode_mcu_gather_def_void.F;
P << extract_encode_mcu_gather_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_encode_mcu_gather_decl@
type T;
identifier F = encode_mcu_gather;
parameter list P;
@@
T F(P);

@script:python depends on extract_encode_mcu_gather_decl@
F << extract_encode_mcu_gather_decl.F;
T << extract_encode_mcu_gather_decl.T;
P << extract_encode_mcu_gather_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_encode_mcu_gather_decl_void@
identifier F = encode_mcu_gather;
parameter list P;
@@
void F(P);

@script:python depends on extract_encode_mcu_gather_decl_void@
F << extract_encode_mcu_gather_decl_void.F;
P << extract_encode_mcu_gather_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: encode_mcu_huff
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_encode_mcu_huff_def@
type T;
identifier F = encode_mcu_huff;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_encode_mcu_huff_def@
F << remove_static_encode_mcu_huff_def.F;
T << remove_static_encode_mcu_huff_def.T;
P << remove_static_encode_mcu_huff_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_encode_mcu_huff_def_void@
identifier F = encode_mcu_huff;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_encode_mcu_huff_def_void@
F << remove_static_encode_mcu_huff_def_void.F;
P << remove_static_encode_mcu_huff_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_encode_mcu_huff_decl@
type T;
identifier F = encode_mcu_huff;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_encode_mcu_huff_decl@
F << remove_static_encode_mcu_huff_decl.F;
T << remove_static_encode_mcu_huff_decl.T;
P << remove_static_encode_mcu_huff_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_encode_mcu_huff_decl_void@
identifier F = encode_mcu_huff;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_encode_mcu_huff_decl_void@
F << remove_static_encode_mcu_huff_decl_void.F;
P << remove_static_encode_mcu_huff_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_encode_mcu_huff_def@
type T;
identifier F = encode_mcu_huff;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_encode_mcu_huff_def@
F << extract_encode_mcu_huff_def.F;
T << extract_encode_mcu_huff_def.T;
P << extract_encode_mcu_huff_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_encode_mcu_huff_def_void@
identifier F = encode_mcu_huff;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_encode_mcu_huff_def_void@
F << extract_encode_mcu_huff_def_void.F;
P << extract_encode_mcu_huff_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_encode_mcu_huff_decl@
type T;
identifier F = encode_mcu_huff;
parameter list P;
@@
T F(P);

@script:python depends on extract_encode_mcu_huff_decl@
F << extract_encode_mcu_huff_decl.F;
T << extract_encode_mcu_huff_decl.T;
P << extract_encode_mcu_huff_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_encode_mcu_huff_decl_void@
identifier F = encode_mcu_huff;
parameter list P;
@@
void F(P);

@script:python depends on extract_encode_mcu_huff_decl_void@
F << extract_encode_mcu_huff_decl_void.F;
P << extract_encode_mcu_huff_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: encode_mcus_gather
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_encode_mcus_gather_def@
type T;
identifier F = encode_mcus_gather;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_encode_mcus_gather_def@
F << remove_static_encode_mcus_gather_def.F;
T << remove_static_encode_mcus_gather_def.T;
P << remove_static_encode_mcus_gather_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_encode_mcus_gather_def_void@
identifier F = encode_mcus_gather;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_encode_mcus_gather_def_void@
F << remove_static_encode_mcus_gather_def_void.F;
P << remove_static_encode_mcus_gather_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_encode_mcus_gather_decl@
type T;
identifier F = encode_mcus_gather;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_encode_mcus_gather_decl@
F << remove_static_encode_mcus_gather_decl.F;
T << remove_static_encode_mcus_gather_decl.T;
P << remove_static_encode_mcus_gather_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_encode_mcus_gather_decl_void@
identifier F = encode_mcus_gather;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_encode_mcus_gather_decl_void@
F << remove_static_encode_mcus_gather_decl_void.F;
P << remove_static_encode_mcus_gather_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_encode_mcus_gather_def@
type T;
identifier F = encode_mcus_gather;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_encode_mcus_gather_def@
F << extract_encode_mcus_gather_def.F;
T << extract_encode_mcus_gather_def.T;
P << extract_encode_mcus_gather_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_encode_mcus_gather_def_void@
identifier F = encode_mcus_gather;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_encode_mcus_gather_def_void@
F << extract_encode_mcus_gather_def_void.F;
P << extract_encode_mcus_gather_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_encode_mcus_gather_decl@
type T;
identifier F = encode_mcus_gather;
parameter list P;
@@
T F(P);

@script:python depends on extract_encode_mcus_gather_decl@
F << extract_encode_mcus_gather_decl.F;
T << extract_encode_mcus_gather_decl.T;
P << extract_encode_mcus_gather_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_encode_mcus_gather_decl_void@
identifier F = encode_mcus_gather;
parameter list P;
@@
void F(P);

@script:python depends on extract_encode_mcus_gather_decl_void@
F << extract_encode_mcus_gather_decl_void.F;
P << extract_encode_mcus_gather_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: encode_mcus_huff
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_encode_mcus_huff_def@
type T;
identifier F = encode_mcus_huff;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_encode_mcus_huff_def@
F << remove_static_encode_mcus_huff_def.F;
T << remove_static_encode_mcus_huff_def.T;
P << remove_static_encode_mcus_huff_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_encode_mcus_huff_def_void@
identifier F = encode_mcus_huff;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_encode_mcus_huff_def_void@
F << remove_static_encode_mcus_huff_def_void.F;
P << remove_static_encode_mcus_huff_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_encode_mcus_huff_decl@
type T;
identifier F = encode_mcus_huff;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_encode_mcus_huff_decl@
F << remove_static_encode_mcus_huff_decl.F;
T << remove_static_encode_mcus_huff_decl.T;
P << remove_static_encode_mcus_huff_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_encode_mcus_huff_decl_void@
identifier F = encode_mcus_huff;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_encode_mcus_huff_decl_void@
F << remove_static_encode_mcus_huff_decl_void.F;
P << remove_static_encode_mcus_huff_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_encode_mcus_huff_def@
type T;
identifier F = encode_mcus_huff;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_encode_mcus_huff_def@
F << extract_encode_mcus_huff_def.F;
T << extract_encode_mcus_huff_def.T;
P << extract_encode_mcus_huff_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_encode_mcus_huff_def_void@
identifier F = encode_mcus_huff;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_encode_mcus_huff_def_void@
F << extract_encode_mcus_huff_def_void.F;
P << extract_encode_mcus_huff_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_encode_mcus_huff_decl@
type T;
identifier F = encode_mcus_huff;
parameter list P;
@@
T F(P);

@script:python depends on extract_encode_mcus_huff_decl@
F << extract_encode_mcus_huff_decl.F;
T << extract_encode_mcus_huff_decl.T;
P << extract_encode_mcus_huff_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_encode_mcus_huff_decl_void@
identifier F = encode_mcus_huff;
parameter list P;
@@
void F(P);

@script:python depends on extract_encode_mcus_huff_decl_void@
F << extract_encode_mcus_huff_decl_void.F;
P << extract_encode_mcus_huff_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: fill_mem_input_buffer
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_fill_mem_input_buffer_def@
type T;
identifier F = fill_mem_input_buffer;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_fill_mem_input_buffer_def@
F << remove_static_fill_mem_input_buffer_def.F;
T << remove_static_fill_mem_input_buffer_def.T;
P << remove_static_fill_mem_input_buffer_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_fill_mem_input_buffer_def_void@
identifier F = fill_mem_input_buffer;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_fill_mem_input_buffer_def_void@
F << remove_static_fill_mem_input_buffer_def_void.F;
P << remove_static_fill_mem_input_buffer_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_fill_mem_input_buffer_decl@
type T;
identifier F = fill_mem_input_buffer;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_fill_mem_input_buffer_decl@
F << remove_static_fill_mem_input_buffer_decl.F;
T << remove_static_fill_mem_input_buffer_decl.T;
P << remove_static_fill_mem_input_buffer_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_fill_mem_input_buffer_decl_void@
identifier F = fill_mem_input_buffer;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_fill_mem_input_buffer_decl_void@
F << remove_static_fill_mem_input_buffer_decl_void.F;
P << remove_static_fill_mem_input_buffer_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_fill_mem_input_buffer_def@
type T;
identifier F = fill_mem_input_buffer;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_fill_mem_input_buffer_def@
F << extract_fill_mem_input_buffer_def.F;
T << extract_fill_mem_input_buffer_def.T;
P << extract_fill_mem_input_buffer_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_fill_mem_input_buffer_def_void@
identifier F = fill_mem_input_buffer;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_fill_mem_input_buffer_def_void@
F << extract_fill_mem_input_buffer_def_void.F;
P << extract_fill_mem_input_buffer_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_fill_mem_input_buffer_decl@
type T;
identifier F = fill_mem_input_buffer;
parameter list P;
@@
T F(P);

@script:python depends on extract_fill_mem_input_buffer_decl@
F << extract_fill_mem_input_buffer_decl.F;
T << extract_fill_mem_input_buffer_decl.T;
P << extract_fill_mem_input_buffer_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_fill_mem_input_buffer_decl_void@
identifier F = fill_mem_input_buffer;
parameter list P;
@@
void F(P);

@script:python depends on extract_fill_mem_input_buffer_decl_void@
F << extract_fill_mem_input_buffer_decl_void.F;
P << extract_fill_mem_input_buffer_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: finish_input_bmp
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_finish_input_bmp_def@
type T;
identifier F = finish_input_bmp;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_finish_input_bmp_def@
F << remove_static_finish_input_bmp_def.F;
T << remove_static_finish_input_bmp_def.T;
P << remove_static_finish_input_bmp_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_finish_input_bmp_def_void@
identifier F = finish_input_bmp;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_finish_input_bmp_def_void@
F << remove_static_finish_input_bmp_def_void.F;
P << remove_static_finish_input_bmp_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_finish_input_bmp_decl@
type T;
identifier F = finish_input_bmp;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_finish_input_bmp_decl@
F << remove_static_finish_input_bmp_decl.F;
T << remove_static_finish_input_bmp_decl.T;
P << remove_static_finish_input_bmp_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_finish_input_bmp_decl_void@
identifier F = finish_input_bmp;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_finish_input_bmp_decl_void@
F << remove_static_finish_input_bmp_decl_void.F;
P << remove_static_finish_input_bmp_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_finish_input_bmp_def@
type T;
identifier F = finish_input_bmp;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_finish_input_bmp_def@
F << extract_finish_input_bmp_def.F;
T << extract_finish_input_bmp_def.T;
P << extract_finish_input_bmp_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_finish_input_bmp_def_void@
identifier F = finish_input_bmp;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_finish_input_bmp_def_void@
F << extract_finish_input_bmp_def_void.F;
P << extract_finish_input_bmp_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_finish_input_bmp_decl@
type T;
identifier F = finish_input_bmp;
parameter list P;
@@
T F(P);

@script:python depends on extract_finish_input_bmp_decl@
F << extract_finish_input_bmp_decl.F;
T << extract_finish_input_bmp_decl.T;
P << extract_finish_input_bmp_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_finish_input_bmp_decl_void@
identifier F = finish_input_bmp;
parameter list P;
@@
void F(P);

@script:python depends on extract_finish_input_bmp_decl_void@
F << extract_finish_input_bmp_decl_void.F;
P << extract_finish_input_bmp_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: finish_input_gif
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_finish_input_gif_def@
type T;
identifier F = finish_input_gif;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_finish_input_gif_def@
F << remove_static_finish_input_gif_def.F;
T << remove_static_finish_input_gif_def.T;
P << remove_static_finish_input_gif_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_finish_input_gif_def_void@
identifier F = finish_input_gif;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_finish_input_gif_def_void@
F << remove_static_finish_input_gif_def_void.F;
P << remove_static_finish_input_gif_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_finish_input_gif_decl@
type T;
identifier F = finish_input_gif;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_finish_input_gif_decl@
F << remove_static_finish_input_gif_decl.F;
T << remove_static_finish_input_gif_decl.T;
P << remove_static_finish_input_gif_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_finish_input_gif_decl_void@
identifier F = finish_input_gif;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_finish_input_gif_decl_void@
F << remove_static_finish_input_gif_decl_void.F;
P << remove_static_finish_input_gif_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_finish_input_gif_def@
type T;
identifier F = finish_input_gif;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_finish_input_gif_def@
F << extract_finish_input_gif_def.F;
T << extract_finish_input_gif_def.T;
P << extract_finish_input_gif_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_finish_input_gif_def_void@
identifier F = finish_input_gif;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_finish_input_gif_def_void@
F << extract_finish_input_gif_def_void.F;
P << extract_finish_input_gif_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_finish_input_gif_decl@
type T;
identifier F = finish_input_gif;
parameter list P;
@@
T F(P);

@script:python depends on extract_finish_input_gif_decl@
F << extract_finish_input_gif_decl.F;
T << extract_finish_input_gif_decl.T;
P << extract_finish_input_gif_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_finish_input_gif_decl_void@
identifier F = finish_input_gif;
parameter list P;
@@
void F(P);

@script:python depends on extract_finish_input_gif_decl_void@
F << extract_finish_input_gif_decl_void.F;
P << extract_finish_input_gif_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: finish_input_ppm
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_finish_input_ppm_def@
type T;
identifier F = finish_input_ppm;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_finish_input_ppm_def@
F << remove_static_finish_input_ppm_def.F;
T << remove_static_finish_input_ppm_def.T;
P << remove_static_finish_input_ppm_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_finish_input_ppm_def_void@
identifier F = finish_input_ppm;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_finish_input_ppm_def_void@
F << remove_static_finish_input_ppm_def_void.F;
P << remove_static_finish_input_ppm_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_finish_input_ppm_decl@
type T;
identifier F = finish_input_ppm;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_finish_input_ppm_decl@
F << remove_static_finish_input_ppm_decl.F;
T << remove_static_finish_input_ppm_decl.T;
P << remove_static_finish_input_ppm_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_finish_input_ppm_decl_void@
identifier F = finish_input_ppm;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_finish_input_ppm_decl_void@
F << remove_static_finish_input_ppm_decl_void.F;
P << remove_static_finish_input_ppm_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_finish_input_ppm_def@
type T;
identifier F = finish_input_ppm;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_finish_input_ppm_def@
F << extract_finish_input_ppm_def.F;
T << extract_finish_input_ppm_def.T;
P << extract_finish_input_ppm_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_finish_input_ppm_def_void@
identifier F = finish_input_ppm;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_finish_input_ppm_def_void@
F << extract_finish_input_ppm_def_void.F;
P << extract_finish_input_ppm_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_finish_input_ppm_decl@
type T;
identifier F = finish_input_ppm;
parameter list P;
@@
T F(P);

@script:python depends on extract_finish_input_ppm_decl@
F << extract_finish_input_ppm_decl.F;
T << extract_finish_input_ppm_decl.T;
P << extract_finish_input_ppm_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_finish_input_ppm_decl_void@
identifier F = finish_input_ppm;
parameter list P;
@@
void F(P);

@script:python depends on extract_finish_input_ppm_decl_void@
F << extract_finish_input_ppm_decl_void.F;
P << extract_finish_input_ppm_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: finish_input_tga
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_finish_input_tga_def@
type T;
identifier F = finish_input_tga;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_finish_input_tga_def@
F << remove_static_finish_input_tga_def.F;
T << remove_static_finish_input_tga_def.T;
P << remove_static_finish_input_tga_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_finish_input_tga_def_void@
identifier F = finish_input_tga;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_finish_input_tga_def_void@
F << remove_static_finish_input_tga_def_void.F;
P << remove_static_finish_input_tga_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_finish_input_tga_decl@
type T;
identifier F = finish_input_tga;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_finish_input_tga_decl@
F << remove_static_finish_input_tga_decl.F;
T << remove_static_finish_input_tga_decl.T;
P << remove_static_finish_input_tga_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_finish_input_tga_decl_void@
identifier F = finish_input_tga;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_finish_input_tga_decl_void@
F << remove_static_finish_input_tga_decl_void.F;
P << remove_static_finish_input_tga_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_finish_input_tga_def@
type T;
identifier F = finish_input_tga;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_finish_input_tga_def@
F << extract_finish_input_tga_def.F;
T << extract_finish_input_tga_def.T;
P << extract_finish_input_tga_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_finish_input_tga_def_void@
identifier F = finish_input_tga;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_finish_input_tga_def_void@
F << extract_finish_input_tga_def_void.F;
P << extract_finish_input_tga_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_finish_input_tga_decl@
type T;
identifier F = finish_input_tga;
parameter list P;
@@
T F(P);

@script:python depends on extract_finish_input_tga_decl@
F << extract_finish_input_tga_decl.F;
T << extract_finish_input_tga_decl.T;
P << extract_finish_input_tga_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_finish_input_tga_decl_void@
identifier F = finish_input_tga;
parameter list P;
@@
void F(P);

@script:python depends on extract_finish_input_tga_decl_void@
F << extract_finish_input_tga_decl_void.F;
P << extract_finish_input_tga_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: finish_output_bmp
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_finish_output_bmp_def@
type T;
identifier F = finish_output_bmp;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_finish_output_bmp_def@
F << remove_static_finish_output_bmp_def.F;
T << remove_static_finish_output_bmp_def.T;
P << remove_static_finish_output_bmp_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_finish_output_bmp_def_void@
identifier F = finish_output_bmp;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_finish_output_bmp_def_void@
F << remove_static_finish_output_bmp_def_void.F;
P << remove_static_finish_output_bmp_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_finish_output_bmp_decl@
type T;
identifier F = finish_output_bmp;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_finish_output_bmp_decl@
F << remove_static_finish_output_bmp_decl.F;
T << remove_static_finish_output_bmp_decl.T;
P << remove_static_finish_output_bmp_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_finish_output_bmp_decl_void@
identifier F = finish_output_bmp;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_finish_output_bmp_decl_void@
F << remove_static_finish_output_bmp_decl_void.F;
P << remove_static_finish_output_bmp_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_finish_output_bmp_def@
type T;
identifier F = finish_output_bmp;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_finish_output_bmp_def@
F << extract_finish_output_bmp_def.F;
T << extract_finish_output_bmp_def.T;
P << extract_finish_output_bmp_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_finish_output_bmp_def_void@
identifier F = finish_output_bmp;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_finish_output_bmp_def_void@
F << extract_finish_output_bmp_def_void.F;
P << extract_finish_output_bmp_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_finish_output_bmp_decl@
type T;
identifier F = finish_output_bmp;
parameter list P;
@@
T F(P);

@script:python depends on extract_finish_output_bmp_decl@
F << extract_finish_output_bmp_decl.F;
T << extract_finish_output_bmp_decl.T;
P << extract_finish_output_bmp_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_finish_output_bmp_decl_void@
identifier F = finish_output_bmp;
parameter list P;
@@
void F(P);

@script:python depends on extract_finish_output_bmp_decl_void@
F << extract_finish_output_bmp_decl_void.F;
P << extract_finish_output_bmp_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: finish_output_gif
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_finish_output_gif_def@
type T;
identifier F = finish_output_gif;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_finish_output_gif_def@
F << remove_static_finish_output_gif_def.F;
T << remove_static_finish_output_gif_def.T;
P << remove_static_finish_output_gif_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_finish_output_gif_def_void@
identifier F = finish_output_gif;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_finish_output_gif_def_void@
F << remove_static_finish_output_gif_def_void.F;
P << remove_static_finish_output_gif_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_finish_output_gif_decl@
type T;
identifier F = finish_output_gif;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_finish_output_gif_decl@
F << remove_static_finish_output_gif_decl.F;
T << remove_static_finish_output_gif_decl.T;
P << remove_static_finish_output_gif_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_finish_output_gif_decl_void@
identifier F = finish_output_gif;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_finish_output_gif_decl_void@
F << remove_static_finish_output_gif_decl_void.F;
P << remove_static_finish_output_gif_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_finish_output_gif_def@
type T;
identifier F = finish_output_gif;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_finish_output_gif_def@
F << extract_finish_output_gif_def.F;
T << extract_finish_output_gif_def.T;
P << extract_finish_output_gif_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_finish_output_gif_def_void@
identifier F = finish_output_gif;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_finish_output_gif_def_void@
F << extract_finish_output_gif_def_void.F;
P << extract_finish_output_gif_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_finish_output_gif_decl@
type T;
identifier F = finish_output_gif;
parameter list P;
@@
T F(P);

@script:python depends on extract_finish_output_gif_decl@
F << extract_finish_output_gif_decl.F;
T << extract_finish_output_gif_decl.T;
P << extract_finish_output_gif_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_finish_output_gif_decl_void@
identifier F = finish_output_gif;
parameter list P;
@@
void F(P);

@script:python depends on extract_finish_output_gif_decl_void@
F << extract_finish_output_gif_decl_void.F;
P << extract_finish_output_gif_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: finish_output_ppm
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_finish_output_ppm_def@
type T;
identifier F = finish_output_ppm;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_finish_output_ppm_def@
F << remove_static_finish_output_ppm_def.F;
T << remove_static_finish_output_ppm_def.T;
P << remove_static_finish_output_ppm_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_finish_output_ppm_def_void@
identifier F = finish_output_ppm;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_finish_output_ppm_def_void@
F << remove_static_finish_output_ppm_def_void.F;
P << remove_static_finish_output_ppm_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_finish_output_ppm_decl@
type T;
identifier F = finish_output_ppm;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_finish_output_ppm_decl@
F << remove_static_finish_output_ppm_decl.F;
T << remove_static_finish_output_ppm_decl.T;
P << remove_static_finish_output_ppm_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_finish_output_ppm_decl_void@
identifier F = finish_output_ppm;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_finish_output_ppm_decl_void@
F << remove_static_finish_output_ppm_decl_void.F;
P << remove_static_finish_output_ppm_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_finish_output_ppm_def@
type T;
identifier F = finish_output_ppm;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_finish_output_ppm_def@
F << extract_finish_output_ppm_def.F;
T << extract_finish_output_ppm_def.T;
P << extract_finish_output_ppm_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_finish_output_ppm_def_void@
identifier F = finish_output_ppm;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_finish_output_ppm_def_void@
F << extract_finish_output_ppm_def_void.F;
P << extract_finish_output_ppm_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_finish_output_ppm_decl@
type T;
identifier F = finish_output_ppm;
parameter list P;
@@
T F(P);

@script:python depends on extract_finish_output_ppm_decl@
F << extract_finish_output_ppm_decl.F;
T << extract_finish_output_ppm_decl.T;
P << extract_finish_output_ppm_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_finish_output_ppm_decl_void@
identifier F = finish_output_ppm;
parameter list P;
@@
void F(P);

@script:python depends on extract_finish_output_ppm_decl_void@
F << extract_finish_output_ppm_decl_void.F;
P << extract_finish_output_ppm_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: finish_output_tga
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_finish_output_tga_def@
type T;
identifier F = finish_output_tga;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_finish_output_tga_def@
F << remove_static_finish_output_tga_def.F;
T << remove_static_finish_output_tga_def.T;
P << remove_static_finish_output_tga_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_finish_output_tga_def_void@
identifier F = finish_output_tga;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_finish_output_tga_def_void@
F << remove_static_finish_output_tga_def_void.F;
P << remove_static_finish_output_tga_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_finish_output_tga_decl@
type T;
identifier F = finish_output_tga;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_finish_output_tga_decl@
F << remove_static_finish_output_tga_decl.F;
T << remove_static_finish_output_tga_decl.T;
P << remove_static_finish_output_tga_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_finish_output_tga_decl_void@
identifier F = finish_output_tga;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_finish_output_tga_decl_void@
F << remove_static_finish_output_tga_decl_void.F;
P << remove_static_finish_output_tga_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_finish_output_tga_def@
type T;
identifier F = finish_output_tga;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_finish_output_tga_def@
F << extract_finish_output_tga_def.F;
T << extract_finish_output_tga_def.T;
P << extract_finish_output_tga_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_finish_output_tga_def_void@
identifier F = finish_output_tga;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_finish_output_tga_def_void@
F << extract_finish_output_tga_def_void.F;
P << extract_finish_output_tga_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_finish_output_tga_decl@
type T;
identifier F = finish_output_tga;
parameter list P;
@@
T F(P);

@script:python depends on extract_finish_output_tga_decl@
F << extract_finish_output_tga_decl.F;
T << extract_finish_output_tga_decl.T;
P << extract_finish_output_tga_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_finish_output_tga_decl_void@
identifier F = finish_output_tga;
parameter list P;
@@
void F(P);

@script:python depends on extract_finish_output_tga_decl_void@
F << extract_finish_output_tga_decl_void.F;
P << extract_finish_output_tga_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: finish_pass1
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_finish_pass1_def@
type T;
identifier F = finish_pass1;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_finish_pass1_def@
F << remove_static_finish_pass1_def.F;
T << remove_static_finish_pass1_def.T;
P << remove_static_finish_pass1_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_finish_pass1_def_void@
identifier F = finish_pass1;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_finish_pass1_def_void@
F << remove_static_finish_pass1_def_void.F;
P << remove_static_finish_pass1_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_finish_pass1_decl@
type T;
identifier F = finish_pass1;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_finish_pass1_decl@
F << remove_static_finish_pass1_decl.F;
T << remove_static_finish_pass1_decl.T;
P << remove_static_finish_pass1_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_finish_pass1_decl_void@
identifier F = finish_pass1;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_finish_pass1_decl_void@
F << remove_static_finish_pass1_decl_void.F;
P << remove_static_finish_pass1_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_finish_pass1_def@
type T;
identifier F = finish_pass1;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_finish_pass1_def@
F << extract_finish_pass1_def.F;
T << extract_finish_pass1_def.T;
P << extract_finish_pass1_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_finish_pass1_def_void@
identifier F = finish_pass1;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_finish_pass1_def_void@
F << extract_finish_pass1_def_void.F;
P << extract_finish_pass1_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_finish_pass1_decl@
type T;
identifier F = finish_pass1;
parameter list P;
@@
T F(P);

@script:python depends on extract_finish_pass1_decl@
F << extract_finish_pass1_decl.F;
T << extract_finish_pass1_decl.T;
P << extract_finish_pass1_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_finish_pass1_decl_void@
identifier F = finish_pass1;
parameter list P;
@@
void F(P);

@script:python depends on extract_finish_pass1_decl_void@
F << extract_finish_pass1_decl_void.F;
P << extract_finish_pass1_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: finish_pass2
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_finish_pass2_def@
type T;
identifier F = finish_pass2;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_finish_pass2_def@
F << remove_static_finish_pass2_def.F;
T << remove_static_finish_pass2_def.T;
P << remove_static_finish_pass2_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_finish_pass2_def_void@
identifier F = finish_pass2;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_finish_pass2_def_void@
F << remove_static_finish_pass2_def_void.F;
P << remove_static_finish_pass2_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_finish_pass2_decl@
type T;
identifier F = finish_pass2;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_finish_pass2_decl@
F << remove_static_finish_pass2_decl.F;
T << remove_static_finish_pass2_decl.T;
P << remove_static_finish_pass2_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_finish_pass2_decl_void@
identifier F = finish_pass2;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_finish_pass2_decl_void@
F << remove_static_finish_pass2_decl_void.F;
P << remove_static_finish_pass2_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_finish_pass2_def@
type T;
identifier F = finish_pass2;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_finish_pass2_def@
F << extract_finish_pass2_def.F;
T << extract_finish_pass2_def.T;
P << extract_finish_pass2_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_finish_pass2_def_void@
identifier F = finish_pass2;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_finish_pass2_def_void@
F << extract_finish_pass2_def_void.F;
P << extract_finish_pass2_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_finish_pass2_decl@
type T;
identifier F = finish_pass2;
parameter list P;
@@
T F(P);

@script:python depends on extract_finish_pass2_decl@
F << extract_finish_pass2_decl.F;
T << extract_finish_pass2_decl.T;
P << extract_finish_pass2_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_finish_pass2_decl_void@
identifier F = finish_pass2;
parameter list P;
@@
void F(P);

@script:python depends on extract_finish_pass2_decl_void@
F << extract_finish_pass2_decl_void.F;
P << extract_finish_pass2_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: finish_pass_1_quant
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_finish_pass_1_quant_def@
type T;
identifier F = finish_pass_1_quant;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_finish_pass_1_quant_def@
F << remove_static_finish_pass_1_quant_def.F;
T << remove_static_finish_pass_1_quant_def.T;
P << remove_static_finish_pass_1_quant_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_finish_pass_1_quant_def_void@
identifier F = finish_pass_1_quant;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_finish_pass_1_quant_def_void@
F << remove_static_finish_pass_1_quant_def_void.F;
P << remove_static_finish_pass_1_quant_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_finish_pass_1_quant_decl@
type T;
identifier F = finish_pass_1_quant;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_finish_pass_1_quant_decl@
F << remove_static_finish_pass_1_quant_decl.F;
T << remove_static_finish_pass_1_quant_decl.T;
P << remove_static_finish_pass_1_quant_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_finish_pass_1_quant_decl_void@
identifier F = finish_pass_1_quant;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_finish_pass_1_quant_decl_void@
F << remove_static_finish_pass_1_quant_decl_void.F;
P << remove_static_finish_pass_1_quant_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_finish_pass_1_quant_def@
type T;
identifier F = finish_pass_1_quant;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_finish_pass_1_quant_def@
F << extract_finish_pass_1_quant_def.F;
T << extract_finish_pass_1_quant_def.T;
P << extract_finish_pass_1_quant_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_finish_pass_1_quant_def_void@
identifier F = finish_pass_1_quant;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_finish_pass_1_quant_def_void@
F << extract_finish_pass_1_quant_def_void.F;
P << extract_finish_pass_1_quant_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_finish_pass_1_quant_decl@
type T;
identifier F = finish_pass_1_quant;
parameter list P;
@@
T F(P);

@script:python depends on extract_finish_pass_1_quant_decl@
F << extract_finish_pass_1_quant_decl.F;
T << extract_finish_pass_1_quant_decl.T;
P << extract_finish_pass_1_quant_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_finish_pass_1_quant_decl_void@
identifier F = finish_pass_1_quant;
parameter list P;
@@
void F(P);

@script:python depends on extract_finish_pass_1_quant_decl_void@
F << extract_finish_pass_1_quant_decl_void.F;
P << extract_finish_pass_1_quant_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: finish_pass_gather
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_finish_pass_gather_def@
type T;
identifier F = finish_pass_gather;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_finish_pass_gather_def@
F << remove_static_finish_pass_gather_def.F;
T << remove_static_finish_pass_gather_def.T;
P << remove_static_finish_pass_gather_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_finish_pass_gather_def_void@
identifier F = finish_pass_gather;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_finish_pass_gather_def_void@
F << remove_static_finish_pass_gather_def_void.F;
P << remove_static_finish_pass_gather_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_finish_pass_gather_decl@
type T;
identifier F = finish_pass_gather;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_finish_pass_gather_decl@
F << remove_static_finish_pass_gather_decl.F;
T << remove_static_finish_pass_gather_decl.T;
P << remove_static_finish_pass_gather_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_finish_pass_gather_decl_void@
identifier F = finish_pass_gather;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_finish_pass_gather_decl_void@
F << remove_static_finish_pass_gather_decl_void.F;
P << remove_static_finish_pass_gather_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_finish_pass_gather_def@
type T;
identifier F = finish_pass_gather;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_finish_pass_gather_def@
F << extract_finish_pass_gather_def.F;
T << extract_finish_pass_gather_def.T;
P << extract_finish_pass_gather_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_finish_pass_gather_def_void@
identifier F = finish_pass_gather;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_finish_pass_gather_def_void@
F << extract_finish_pass_gather_def_void.F;
P << extract_finish_pass_gather_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_finish_pass_gather_decl@
type T;
identifier F = finish_pass_gather;
parameter list P;
@@
T F(P);

@script:python depends on extract_finish_pass_gather_decl@
F << extract_finish_pass_gather_decl.F;
T << extract_finish_pass_gather_decl.T;
P << extract_finish_pass_gather_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_finish_pass_gather_decl_void@
identifier F = finish_pass_gather;
parameter list P;
@@
void F(P);

@script:python depends on extract_finish_pass_gather_decl_void@
F << extract_finish_pass_gather_decl_void.F;
P << extract_finish_pass_gather_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: finish_pass_gather_phuff
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_finish_pass_gather_phuff_def@
type T;
identifier F = finish_pass_gather_phuff;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_finish_pass_gather_phuff_def@
F << remove_static_finish_pass_gather_phuff_def.F;
T << remove_static_finish_pass_gather_phuff_def.T;
P << remove_static_finish_pass_gather_phuff_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_finish_pass_gather_phuff_def_void@
identifier F = finish_pass_gather_phuff;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_finish_pass_gather_phuff_def_void@
F << remove_static_finish_pass_gather_phuff_def_void.F;
P << remove_static_finish_pass_gather_phuff_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_finish_pass_gather_phuff_decl@
type T;
identifier F = finish_pass_gather_phuff;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_finish_pass_gather_phuff_decl@
F << remove_static_finish_pass_gather_phuff_decl.F;
T << remove_static_finish_pass_gather_phuff_decl.T;
P << remove_static_finish_pass_gather_phuff_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_finish_pass_gather_phuff_decl_void@
identifier F = finish_pass_gather_phuff;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_finish_pass_gather_phuff_decl_void@
F << remove_static_finish_pass_gather_phuff_decl_void.F;
P << remove_static_finish_pass_gather_phuff_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_finish_pass_gather_phuff_def@
type T;
identifier F = finish_pass_gather_phuff;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_finish_pass_gather_phuff_def@
F << extract_finish_pass_gather_phuff_def.F;
T << extract_finish_pass_gather_phuff_def.T;
P << extract_finish_pass_gather_phuff_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_finish_pass_gather_phuff_def_void@
identifier F = finish_pass_gather_phuff;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_finish_pass_gather_phuff_def_void@
F << extract_finish_pass_gather_phuff_def_void.F;
P << extract_finish_pass_gather_phuff_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_finish_pass_gather_phuff_decl@
type T;
identifier F = finish_pass_gather_phuff;
parameter list P;
@@
T F(P);

@script:python depends on extract_finish_pass_gather_phuff_decl@
F << extract_finish_pass_gather_phuff_decl.F;
T << extract_finish_pass_gather_phuff_decl.T;
P << extract_finish_pass_gather_phuff_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_finish_pass_gather_phuff_decl_void@
identifier F = finish_pass_gather_phuff;
parameter list P;
@@
void F(P);

@script:python depends on extract_finish_pass_gather_phuff_decl_void@
F << extract_finish_pass_gather_phuff_decl_void.F;
P << extract_finish_pass_gather_phuff_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: finish_pass_huff
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_finish_pass_huff_def@
type T;
identifier F = finish_pass_huff;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_finish_pass_huff_def@
F << remove_static_finish_pass_huff_def.F;
T << remove_static_finish_pass_huff_def.T;
P << remove_static_finish_pass_huff_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_finish_pass_huff_def_void@
identifier F = finish_pass_huff;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_finish_pass_huff_def_void@
F << remove_static_finish_pass_huff_def_void.F;
P << remove_static_finish_pass_huff_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_finish_pass_huff_decl@
type T;
identifier F = finish_pass_huff;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_finish_pass_huff_decl@
F << remove_static_finish_pass_huff_decl.F;
T << remove_static_finish_pass_huff_decl.T;
P << remove_static_finish_pass_huff_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_finish_pass_huff_decl_void@
identifier F = finish_pass_huff;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_finish_pass_huff_decl_void@
F << remove_static_finish_pass_huff_decl_void.F;
P << remove_static_finish_pass_huff_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_finish_pass_huff_def@
type T;
identifier F = finish_pass_huff;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_finish_pass_huff_def@
F << extract_finish_pass_huff_def.F;
T << extract_finish_pass_huff_def.T;
P << extract_finish_pass_huff_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_finish_pass_huff_def_void@
identifier F = finish_pass_huff;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_finish_pass_huff_def_void@
F << extract_finish_pass_huff_def_void.F;
P << extract_finish_pass_huff_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_finish_pass_huff_decl@
type T;
identifier F = finish_pass_huff;
parameter list P;
@@
T F(P);

@script:python depends on extract_finish_pass_huff_decl@
F << extract_finish_pass_huff_decl.F;
T << extract_finish_pass_huff_decl.T;
P << extract_finish_pass_huff_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_finish_pass_huff_decl_void@
identifier F = finish_pass_huff;
parameter list P;
@@
void F(P);

@script:python depends on extract_finish_pass_huff_decl_void@
F << extract_finish_pass_huff_decl_void.F;
P << extract_finish_pass_huff_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: finish_pass_master
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_finish_pass_master_def@
type T;
identifier F = finish_pass_master;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_finish_pass_master_def@
F << remove_static_finish_pass_master_def.F;
T << remove_static_finish_pass_master_def.T;
P << remove_static_finish_pass_master_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_finish_pass_master_def_void@
identifier F = finish_pass_master;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_finish_pass_master_def_void@
F << remove_static_finish_pass_master_def_void.F;
P << remove_static_finish_pass_master_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_finish_pass_master_decl@
type T;
identifier F = finish_pass_master;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_finish_pass_master_decl@
F << remove_static_finish_pass_master_decl.F;
T << remove_static_finish_pass_master_decl.T;
P << remove_static_finish_pass_master_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_finish_pass_master_decl_void@
identifier F = finish_pass_master;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_finish_pass_master_decl_void@
F << remove_static_finish_pass_master_decl_void.F;
P << remove_static_finish_pass_master_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_finish_pass_master_def@
type T;
identifier F = finish_pass_master;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_finish_pass_master_def@
F << extract_finish_pass_master_def.F;
T << extract_finish_pass_master_def.T;
P << extract_finish_pass_master_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_finish_pass_master_def_void@
identifier F = finish_pass_master;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_finish_pass_master_def_void@
F << extract_finish_pass_master_def_void.F;
P << extract_finish_pass_master_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_finish_pass_master_decl@
type T;
identifier F = finish_pass_master;
parameter list P;
@@
T F(P);

@script:python depends on extract_finish_pass_master_decl@
F << extract_finish_pass_master_decl.F;
T << extract_finish_pass_master_decl.T;
P << extract_finish_pass_master_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_finish_pass_master_decl_void@
identifier F = finish_pass_master;
parameter list P;
@@
void F(P);

@script:python depends on extract_finish_pass_master_decl_void@
F << extract_finish_pass_master_decl_void.F;
P << extract_finish_pass_master_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: finish_pass_phuff
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_finish_pass_phuff_def@
type T;
identifier F = finish_pass_phuff;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_finish_pass_phuff_def@
F << remove_static_finish_pass_phuff_def.F;
T << remove_static_finish_pass_phuff_def.T;
P << remove_static_finish_pass_phuff_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_finish_pass_phuff_def_void@
identifier F = finish_pass_phuff;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_finish_pass_phuff_def_void@
F << remove_static_finish_pass_phuff_def_void.F;
P << remove_static_finish_pass_phuff_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_finish_pass_phuff_decl@
type T;
identifier F = finish_pass_phuff;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_finish_pass_phuff_decl@
F << remove_static_finish_pass_phuff_decl.F;
T << remove_static_finish_pass_phuff_decl.T;
P << remove_static_finish_pass_phuff_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_finish_pass_phuff_decl_void@
identifier F = finish_pass_phuff;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_finish_pass_phuff_decl_void@
F << remove_static_finish_pass_phuff_decl_void.F;
P << remove_static_finish_pass_phuff_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_finish_pass_phuff_def@
type T;
identifier F = finish_pass_phuff;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_finish_pass_phuff_def@
F << extract_finish_pass_phuff_def.F;
T << extract_finish_pass_phuff_def.T;
P << extract_finish_pass_phuff_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_finish_pass_phuff_def_void@
identifier F = finish_pass_phuff;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_finish_pass_phuff_def_void@
F << extract_finish_pass_phuff_def_void.F;
P << extract_finish_pass_phuff_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_finish_pass_phuff_decl@
type T;
identifier F = finish_pass_phuff;
parameter list P;
@@
T F(P);

@script:python depends on extract_finish_pass_phuff_decl@
F << extract_finish_pass_phuff_decl.F;
T << extract_finish_pass_phuff_decl.T;
P << extract_finish_pass_phuff_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_finish_pass_phuff_decl_void@
identifier F = finish_pass_phuff;
parameter list P;
@@
void F(P);

@script:python depends on extract_finish_pass_phuff_decl_void@
F << extract_finish_pass_phuff_decl_void.F;
P << extract_finish_pass_phuff_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: fuzzer_emit_message
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_fuzzer_emit_message_def@
type T;
identifier F = fuzzer_emit_message;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_fuzzer_emit_message_def@
F << remove_static_fuzzer_emit_message_def.F;
T << remove_static_fuzzer_emit_message_def.T;
P << remove_static_fuzzer_emit_message_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_fuzzer_emit_message_def_void@
identifier F = fuzzer_emit_message;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_fuzzer_emit_message_def_void@
F << remove_static_fuzzer_emit_message_def_void.F;
P << remove_static_fuzzer_emit_message_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_fuzzer_emit_message_decl@
type T;
identifier F = fuzzer_emit_message;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_fuzzer_emit_message_decl@
F << remove_static_fuzzer_emit_message_decl.F;
T << remove_static_fuzzer_emit_message_decl.T;
P << remove_static_fuzzer_emit_message_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_fuzzer_emit_message_decl_void@
identifier F = fuzzer_emit_message;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_fuzzer_emit_message_decl_void@
F << remove_static_fuzzer_emit_message_decl_void.F;
P << remove_static_fuzzer_emit_message_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_fuzzer_emit_message_def@
type T;
identifier F = fuzzer_emit_message;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_fuzzer_emit_message_def@
F << extract_fuzzer_emit_message_def.F;
T << extract_fuzzer_emit_message_def.T;
P << extract_fuzzer_emit_message_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_fuzzer_emit_message_def_void@
identifier F = fuzzer_emit_message;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_fuzzer_emit_message_def_void@
F << extract_fuzzer_emit_message_def_void.F;
P << extract_fuzzer_emit_message_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_fuzzer_emit_message_decl@
type T;
identifier F = fuzzer_emit_message;
parameter list P;
@@
T F(P);

@script:python depends on extract_fuzzer_emit_message_decl@
F << extract_fuzzer_emit_message_decl.F;
T << extract_fuzzer_emit_message_decl.T;
P << extract_fuzzer_emit_message_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_fuzzer_emit_message_decl_void@
identifier F = fuzzer_emit_message;
parameter list P;
@@
void F(P);

@script:python depends on extract_fuzzer_emit_message_decl_void@
F << extract_fuzzer_emit_message_decl_void.F;
P << extract_fuzzer_emit_message_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: fuzzer_error_exit
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_fuzzer_error_exit_def@
type T;
identifier F = fuzzer_error_exit;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_fuzzer_error_exit_def@
F << remove_static_fuzzer_error_exit_def.F;
T << remove_static_fuzzer_error_exit_def.T;
P << remove_static_fuzzer_error_exit_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_fuzzer_error_exit_def_void@
identifier F = fuzzer_error_exit;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_fuzzer_error_exit_def_void@
F << remove_static_fuzzer_error_exit_def_void.F;
P << remove_static_fuzzer_error_exit_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_fuzzer_error_exit_decl@
type T;
identifier F = fuzzer_error_exit;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_fuzzer_error_exit_decl@
F << remove_static_fuzzer_error_exit_decl.F;
T << remove_static_fuzzer_error_exit_decl.T;
P << remove_static_fuzzer_error_exit_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_fuzzer_error_exit_decl_void@
identifier F = fuzzer_error_exit;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_fuzzer_error_exit_decl_void@
F << remove_static_fuzzer_error_exit_decl_void.F;
P << remove_static_fuzzer_error_exit_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_fuzzer_error_exit_def@
type T;
identifier F = fuzzer_error_exit;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_fuzzer_error_exit_def@
F << extract_fuzzer_error_exit_def.F;
T << extract_fuzzer_error_exit_def.T;
P << extract_fuzzer_error_exit_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_fuzzer_error_exit_def_void@
identifier F = fuzzer_error_exit;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_fuzzer_error_exit_def_void@
F << extract_fuzzer_error_exit_def_void.F;
P << extract_fuzzer_error_exit_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_fuzzer_error_exit_decl@
type T;
identifier F = fuzzer_error_exit;
parameter list P;
@@
T F(P);

@script:python depends on extract_fuzzer_error_exit_decl@
F << extract_fuzzer_error_exit_decl.F;
T << extract_fuzzer_error_exit_decl.T;
P << extract_fuzzer_error_exit_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_fuzzer_error_exit_decl_void@
identifier F = fuzzer_error_exit;
parameter list P;
@@
void F(P);

@script:python depends on extract_fuzzer_error_exit_decl_void@
F << extract_fuzzer_error_exit_decl_void.F;
P << extract_fuzzer_error_exit_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: get_16bit_row
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_get_16bit_row_def@
type T;
identifier F = get_16bit_row;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_get_16bit_row_def@
F << remove_static_get_16bit_row_def.F;
T << remove_static_get_16bit_row_def.T;
P << remove_static_get_16bit_row_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_get_16bit_row_def_void@
identifier F = get_16bit_row;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_get_16bit_row_def_void@
F << remove_static_get_16bit_row_def_void.F;
P << remove_static_get_16bit_row_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_get_16bit_row_decl@
type T;
identifier F = get_16bit_row;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_get_16bit_row_decl@
F << remove_static_get_16bit_row_decl.F;
T << remove_static_get_16bit_row_decl.T;
P << remove_static_get_16bit_row_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_get_16bit_row_decl_void@
identifier F = get_16bit_row;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_get_16bit_row_decl_void@
F << remove_static_get_16bit_row_decl_void.F;
P << remove_static_get_16bit_row_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_get_16bit_row_def@
type T;
identifier F = get_16bit_row;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_get_16bit_row_def@
F << extract_get_16bit_row_def.F;
T << extract_get_16bit_row_def.T;
P << extract_get_16bit_row_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_get_16bit_row_def_void@
identifier F = get_16bit_row;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_get_16bit_row_def_void@
F << extract_get_16bit_row_def_void.F;
P << extract_get_16bit_row_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_get_16bit_row_decl@
type T;
identifier F = get_16bit_row;
parameter list P;
@@
T F(P);

@script:python depends on extract_get_16bit_row_decl@
F << extract_get_16bit_row_decl.F;
T << extract_get_16bit_row_decl.T;
P << extract_get_16bit_row_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_get_16bit_row_decl_void@
identifier F = get_16bit_row;
parameter list P;
@@
void F(P);

@script:python depends on extract_get_16bit_row_decl_void@
F << extract_get_16bit_row_decl_void.F;
P << extract_get_16bit_row_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: get_24bit_row
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_get_24bit_row_def@
type T;
identifier F = get_24bit_row;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_get_24bit_row_def@
F << remove_static_get_24bit_row_def.F;
T << remove_static_get_24bit_row_def.T;
P << remove_static_get_24bit_row_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_get_24bit_row_def_void@
identifier F = get_24bit_row;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_get_24bit_row_def_void@
F << remove_static_get_24bit_row_def_void.F;
P << remove_static_get_24bit_row_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_get_24bit_row_decl@
type T;
identifier F = get_24bit_row;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_get_24bit_row_decl@
F << remove_static_get_24bit_row_decl.F;
T << remove_static_get_24bit_row_decl.T;
P << remove_static_get_24bit_row_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_get_24bit_row_decl_void@
identifier F = get_24bit_row;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_get_24bit_row_decl_void@
F << remove_static_get_24bit_row_decl_void.F;
P << remove_static_get_24bit_row_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_get_24bit_row_def@
type T;
identifier F = get_24bit_row;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_get_24bit_row_def@
F << extract_get_24bit_row_def.F;
T << extract_get_24bit_row_def.T;
P << extract_get_24bit_row_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_get_24bit_row_def_void@
identifier F = get_24bit_row;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_get_24bit_row_def_void@
F << extract_get_24bit_row_def_void.F;
P << extract_get_24bit_row_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_get_24bit_row_decl@
type T;
identifier F = get_24bit_row;
parameter list P;
@@
T F(P);

@script:python depends on extract_get_24bit_row_decl@
F << extract_get_24bit_row_decl.F;
T << extract_get_24bit_row_decl.T;
P << extract_get_24bit_row_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_get_24bit_row_decl_void@
identifier F = get_24bit_row;
parameter list P;
@@
void F(P);

@script:python depends on extract_get_24bit_row_decl_void@
F << extract_get_24bit_row_decl_void.F;
P << extract_get_24bit_row_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: get_32bit_row
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_get_32bit_row_def@
type T;
identifier F = get_32bit_row;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_get_32bit_row_def@
F << remove_static_get_32bit_row_def.F;
T << remove_static_get_32bit_row_def.T;
P << remove_static_get_32bit_row_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_get_32bit_row_def_void@
identifier F = get_32bit_row;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_get_32bit_row_def_void@
F << remove_static_get_32bit_row_def_void.F;
P << remove_static_get_32bit_row_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_get_32bit_row_decl@
type T;
identifier F = get_32bit_row;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_get_32bit_row_decl@
F << remove_static_get_32bit_row_decl.F;
T << remove_static_get_32bit_row_decl.T;
P << remove_static_get_32bit_row_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_get_32bit_row_decl_void@
identifier F = get_32bit_row;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_get_32bit_row_decl_void@
F << remove_static_get_32bit_row_decl_void.F;
P << remove_static_get_32bit_row_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_get_32bit_row_def@
type T;
identifier F = get_32bit_row;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_get_32bit_row_def@
F << extract_get_32bit_row_def.F;
T << extract_get_32bit_row_def.T;
P << extract_get_32bit_row_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_get_32bit_row_def_void@
identifier F = get_32bit_row;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_get_32bit_row_def_void@
F << extract_get_32bit_row_def_void.F;
P << extract_get_32bit_row_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_get_32bit_row_decl@
type T;
identifier F = get_32bit_row;
parameter list P;
@@
T F(P);

@script:python depends on extract_get_32bit_row_decl@
F << extract_get_32bit_row_decl.F;
T << extract_get_32bit_row_decl.T;
P << extract_get_32bit_row_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_get_32bit_row_decl_void@
identifier F = get_32bit_row;
parameter list P;
@@
void F(P);

@script:python depends on extract_get_32bit_row_decl_void@
F << extract_get_32bit_row_decl_void.F;
P << extract_get_32bit_row_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: get_8bit_gray_row
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_get_8bit_gray_row_def@
type T;
identifier F = get_8bit_gray_row;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_get_8bit_gray_row_def@
F << remove_static_get_8bit_gray_row_def.F;
T << remove_static_get_8bit_gray_row_def.T;
P << remove_static_get_8bit_gray_row_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_get_8bit_gray_row_def_void@
identifier F = get_8bit_gray_row;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_get_8bit_gray_row_def_void@
F << remove_static_get_8bit_gray_row_def_void.F;
P << remove_static_get_8bit_gray_row_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_get_8bit_gray_row_decl@
type T;
identifier F = get_8bit_gray_row;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_get_8bit_gray_row_decl@
F << remove_static_get_8bit_gray_row_decl.F;
T << remove_static_get_8bit_gray_row_decl.T;
P << remove_static_get_8bit_gray_row_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_get_8bit_gray_row_decl_void@
identifier F = get_8bit_gray_row;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_get_8bit_gray_row_decl_void@
F << remove_static_get_8bit_gray_row_decl_void.F;
P << remove_static_get_8bit_gray_row_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_get_8bit_gray_row_def@
type T;
identifier F = get_8bit_gray_row;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_get_8bit_gray_row_def@
F << extract_get_8bit_gray_row_def.F;
T << extract_get_8bit_gray_row_def.T;
P << extract_get_8bit_gray_row_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_get_8bit_gray_row_def_void@
identifier F = get_8bit_gray_row;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_get_8bit_gray_row_def_void@
F << extract_get_8bit_gray_row_def_void.F;
P << extract_get_8bit_gray_row_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_get_8bit_gray_row_decl@
type T;
identifier F = get_8bit_gray_row;
parameter list P;
@@
T F(P);

@script:python depends on extract_get_8bit_gray_row_decl@
F << extract_get_8bit_gray_row_decl.F;
T << extract_get_8bit_gray_row_decl.T;
P << extract_get_8bit_gray_row_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_get_8bit_gray_row_decl_void@
identifier F = get_8bit_gray_row;
parameter list P;
@@
void F(P);

@script:python depends on extract_get_8bit_gray_row_decl_void@
F << extract_get_8bit_gray_row_decl_void.F;
P << extract_get_8bit_gray_row_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: get_8bit_row
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_get_8bit_row_def@
type T;
identifier F = get_8bit_row;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_get_8bit_row_def@
F << remove_static_get_8bit_row_def.F;
T << remove_static_get_8bit_row_def.T;
P << remove_static_get_8bit_row_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_get_8bit_row_def_void@
identifier F = get_8bit_row;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_get_8bit_row_def_void@
F << remove_static_get_8bit_row_def_void.F;
P << remove_static_get_8bit_row_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_get_8bit_row_decl@
type T;
identifier F = get_8bit_row;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_get_8bit_row_decl@
F << remove_static_get_8bit_row_decl.F;
T << remove_static_get_8bit_row_decl.T;
P << remove_static_get_8bit_row_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_get_8bit_row_decl_void@
identifier F = get_8bit_row;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_get_8bit_row_decl_void@
F << remove_static_get_8bit_row_decl_void.F;
P << remove_static_get_8bit_row_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_get_8bit_row_def@
type T;
identifier F = get_8bit_row;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_get_8bit_row_def@
F << extract_get_8bit_row_def.F;
T << extract_get_8bit_row_def.T;
P << extract_get_8bit_row_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_get_8bit_row_def_void@
identifier F = get_8bit_row;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_get_8bit_row_def_void@
F << extract_get_8bit_row_def_void.F;
P << extract_get_8bit_row_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_get_8bit_row_decl@
type T;
identifier F = get_8bit_row;
parameter list P;
@@
T F(P);

@script:python depends on extract_get_8bit_row_decl@
F << extract_get_8bit_row_decl.F;
T << extract_get_8bit_row_decl.T;
P << extract_get_8bit_row_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_get_8bit_row_decl_void@
identifier F = get_8bit_row;
parameter list P;
@@
void F(P);

@script:python depends on extract_get_8bit_row_decl_void@
F << extract_get_8bit_row_decl_void.F;
P << extract_get_8bit_row_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: get_gray_cmyk_row
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_get_gray_cmyk_row_def@
type T;
identifier F = get_gray_cmyk_row;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_get_gray_cmyk_row_def@
F << remove_static_get_gray_cmyk_row_def.F;
T << remove_static_get_gray_cmyk_row_def.T;
P << remove_static_get_gray_cmyk_row_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_get_gray_cmyk_row_def_void@
identifier F = get_gray_cmyk_row;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_get_gray_cmyk_row_def_void@
F << remove_static_get_gray_cmyk_row_def_void.F;
P << remove_static_get_gray_cmyk_row_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_get_gray_cmyk_row_decl@
type T;
identifier F = get_gray_cmyk_row;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_get_gray_cmyk_row_decl@
F << remove_static_get_gray_cmyk_row_decl.F;
T << remove_static_get_gray_cmyk_row_decl.T;
P << remove_static_get_gray_cmyk_row_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_get_gray_cmyk_row_decl_void@
identifier F = get_gray_cmyk_row;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_get_gray_cmyk_row_decl_void@
F << remove_static_get_gray_cmyk_row_decl_void.F;
P << remove_static_get_gray_cmyk_row_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_get_gray_cmyk_row_def@
type T;
identifier F = get_gray_cmyk_row;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_get_gray_cmyk_row_def@
F << extract_get_gray_cmyk_row_def.F;
T << extract_get_gray_cmyk_row_def.T;
P << extract_get_gray_cmyk_row_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_get_gray_cmyk_row_def_void@
identifier F = get_gray_cmyk_row;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_get_gray_cmyk_row_def_void@
F << extract_get_gray_cmyk_row_def_void.F;
P << extract_get_gray_cmyk_row_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_get_gray_cmyk_row_decl@
type T;
identifier F = get_gray_cmyk_row;
parameter list P;
@@
T F(P);

@script:python depends on extract_get_gray_cmyk_row_decl@
F << extract_get_gray_cmyk_row_decl.F;
T << extract_get_gray_cmyk_row_decl.T;
P << extract_get_gray_cmyk_row_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_get_gray_cmyk_row_decl_void@
identifier F = get_gray_cmyk_row;
parameter list P;
@@
void F(P);

@script:python depends on extract_get_gray_cmyk_row_decl_void@
F << extract_get_gray_cmyk_row_decl_void.F;
P << extract_get_gray_cmyk_row_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: get_gray_rgb_row
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_get_gray_rgb_row_def@
type T;
identifier F = get_gray_rgb_row;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_get_gray_rgb_row_def@
F << remove_static_get_gray_rgb_row_def.F;
T << remove_static_get_gray_rgb_row_def.T;
P << remove_static_get_gray_rgb_row_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_get_gray_rgb_row_def_void@
identifier F = get_gray_rgb_row;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_get_gray_rgb_row_def_void@
F << remove_static_get_gray_rgb_row_def_void.F;
P << remove_static_get_gray_rgb_row_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_get_gray_rgb_row_decl@
type T;
identifier F = get_gray_rgb_row;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_get_gray_rgb_row_decl@
F << remove_static_get_gray_rgb_row_decl.F;
T << remove_static_get_gray_rgb_row_decl.T;
P << remove_static_get_gray_rgb_row_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_get_gray_rgb_row_decl_void@
identifier F = get_gray_rgb_row;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_get_gray_rgb_row_decl_void@
F << remove_static_get_gray_rgb_row_decl_void.F;
P << remove_static_get_gray_rgb_row_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_get_gray_rgb_row_def@
type T;
identifier F = get_gray_rgb_row;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_get_gray_rgb_row_def@
F << extract_get_gray_rgb_row_def.F;
T << extract_get_gray_rgb_row_def.T;
P << extract_get_gray_rgb_row_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_get_gray_rgb_row_def_void@
identifier F = get_gray_rgb_row;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_get_gray_rgb_row_def_void@
F << extract_get_gray_rgb_row_def_void.F;
P << extract_get_gray_rgb_row_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_get_gray_rgb_row_decl@
type T;
identifier F = get_gray_rgb_row;
parameter list P;
@@
T F(P);

@script:python depends on extract_get_gray_rgb_row_decl@
F << extract_get_gray_rgb_row_decl.F;
T << extract_get_gray_rgb_row_decl.T;
P << extract_get_gray_rgb_row_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_get_gray_rgb_row_decl_void@
identifier F = get_gray_rgb_row;
parameter list P;
@@
void F(P);

@script:python depends on extract_get_gray_rgb_row_decl_void@
F << extract_get_gray_rgb_row_decl_void.F;
P << extract_get_gray_rgb_row_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: get_interlaced_row
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_get_interlaced_row_def@
type T;
identifier F = get_interlaced_row;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_get_interlaced_row_def@
F << remove_static_get_interlaced_row_def.F;
T << remove_static_get_interlaced_row_def.T;
P << remove_static_get_interlaced_row_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_get_interlaced_row_def_void@
identifier F = get_interlaced_row;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_get_interlaced_row_def_void@
F << remove_static_get_interlaced_row_def_void.F;
P << remove_static_get_interlaced_row_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_get_interlaced_row_decl@
type T;
identifier F = get_interlaced_row;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_get_interlaced_row_decl@
F << remove_static_get_interlaced_row_decl.F;
T << remove_static_get_interlaced_row_decl.T;
P << remove_static_get_interlaced_row_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_get_interlaced_row_decl_void@
identifier F = get_interlaced_row;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_get_interlaced_row_decl_void@
F << remove_static_get_interlaced_row_decl_void.F;
P << remove_static_get_interlaced_row_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_get_interlaced_row_def@
type T;
identifier F = get_interlaced_row;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_get_interlaced_row_def@
F << extract_get_interlaced_row_def.F;
T << extract_get_interlaced_row_def.T;
P << extract_get_interlaced_row_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_get_interlaced_row_def_void@
identifier F = get_interlaced_row;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_get_interlaced_row_def_void@
F << extract_get_interlaced_row_def_void.F;
P << extract_get_interlaced_row_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_get_interlaced_row_decl@
type T;
identifier F = get_interlaced_row;
parameter list P;
@@
T F(P);

@script:python depends on extract_get_interlaced_row_decl@
F << extract_get_interlaced_row_decl.F;
T << extract_get_interlaced_row_decl.T;
P << extract_get_interlaced_row_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_get_interlaced_row_decl_void@
identifier F = get_interlaced_row;
parameter list P;
@@
void F(P);

@script:python depends on extract_get_interlaced_row_decl_void@
F << extract_get_interlaced_row_decl_void.F;
P << extract_get_interlaced_row_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: get_memory_row
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_get_memory_row_def@
type T;
identifier F = get_memory_row;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_get_memory_row_def@
F << remove_static_get_memory_row_def.F;
T << remove_static_get_memory_row_def.T;
P << remove_static_get_memory_row_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_get_memory_row_def_void@
identifier F = get_memory_row;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_get_memory_row_def_void@
F << remove_static_get_memory_row_def_void.F;
P << remove_static_get_memory_row_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_get_memory_row_decl@
type T;
identifier F = get_memory_row;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_get_memory_row_decl@
F << remove_static_get_memory_row_decl.F;
T << remove_static_get_memory_row_decl.T;
P << remove_static_get_memory_row_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_get_memory_row_decl_void@
identifier F = get_memory_row;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_get_memory_row_decl_void@
F << remove_static_get_memory_row_decl_void.F;
P << remove_static_get_memory_row_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_get_memory_row_def@
type T;
identifier F = get_memory_row;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_get_memory_row_def@
F << extract_get_memory_row_def.F;
T << extract_get_memory_row_def.T;
P << extract_get_memory_row_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_get_memory_row_def_void@
identifier F = get_memory_row;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_get_memory_row_def_void@
F << extract_get_memory_row_def_void.F;
P << extract_get_memory_row_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_get_memory_row_decl@
type T;
identifier F = get_memory_row;
parameter list P;
@@
T F(P);

@script:python depends on extract_get_memory_row_decl@
F << extract_get_memory_row_decl.F;
T << extract_get_memory_row_decl.T;
P << extract_get_memory_row_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_get_memory_row_decl_void@
identifier F = get_memory_row;
parameter list P;
@@
void F(P);

@script:python depends on extract_get_memory_row_decl_void@
F << extract_get_memory_row_decl_void.F;
P << extract_get_memory_row_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: get_raw_row
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_get_raw_row_def@
type T;
identifier F = get_raw_row;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_get_raw_row_def@
F << remove_static_get_raw_row_def.F;
T << remove_static_get_raw_row_def.T;
P << remove_static_get_raw_row_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_get_raw_row_def_void@
identifier F = get_raw_row;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_get_raw_row_def_void@
F << remove_static_get_raw_row_def_void.F;
P << remove_static_get_raw_row_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_get_raw_row_decl@
type T;
identifier F = get_raw_row;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_get_raw_row_decl@
F << remove_static_get_raw_row_decl.F;
T << remove_static_get_raw_row_decl.T;
P << remove_static_get_raw_row_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_get_raw_row_decl_void@
identifier F = get_raw_row;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_get_raw_row_decl_void@
F << remove_static_get_raw_row_decl_void.F;
P << remove_static_get_raw_row_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_get_raw_row_def@
type T;
identifier F = get_raw_row;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_get_raw_row_def@
F << extract_get_raw_row_def.F;
T << extract_get_raw_row_def.T;
P << extract_get_raw_row_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_get_raw_row_def_void@
identifier F = get_raw_row;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_get_raw_row_def_void@
F << extract_get_raw_row_def_void.F;
P << extract_get_raw_row_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_get_raw_row_decl@
type T;
identifier F = get_raw_row;
parameter list P;
@@
T F(P);

@script:python depends on extract_get_raw_row_decl@
F << extract_get_raw_row_decl.F;
T << extract_get_raw_row_decl.T;
P << extract_get_raw_row_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_get_raw_row_decl_void@
identifier F = get_raw_row;
parameter list P;
@@
void F(P);

@script:python depends on extract_get_raw_row_decl_void@
F << extract_get_raw_row_decl_void.F;
P << extract_get_raw_row_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: get_rgb_cmyk_row
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_get_rgb_cmyk_row_def@
type T;
identifier F = get_rgb_cmyk_row;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_get_rgb_cmyk_row_def@
F << remove_static_get_rgb_cmyk_row_def.F;
T << remove_static_get_rgb_cmyk_row_def.T;
P << remove_static_get_rgb_cmyk_row_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_get_rgb_cmyk_row_def_void@
identifier F = get_rgb_cmyk_row;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_get_rgb_cmyk_row_def_void@
F << remove_static_get_rgb_cmyk_row_def_void.F;
P << remove_static_get_rgb_cmyk_row_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_get_rgb_cmyk_row_decl@
type T;
identifier F = get_rgb_cmyk_row;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_get_rgb_cmyk_row_decl@
F << remove_static_get_rgb_cmyk_row_decl.F;
T << remove_static_get_rgb_cmyk_row_decl.T;
P << remove_static_get_rgb_cmyk_row_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_get_rgb_cmyk_row_decl_void@
identifier F = get_rgb_cmyk_row;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_get_rgb_cmyk_row_decl_void@
F << remove_static_get_rgb_cmyk_row_decl_void.F;
P << remove_static_get_rgb_cmyk_row_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_get_rgb_cmyk_row_def@
type T;
identifier F = get_rgb_cmyk_row;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_get_rgb_cmyk_row_def@
F << extract_get_rgb_cmyk_row_def.F;
T << extract_get_rgb_cmyk_row_def.T;
P << extract_get_rgb_cmyk_row_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_get_rgb_cmyk_row_def_void@
identifier F = get_rgb_cmyk_row;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_get_rgb_cmyk_row_def_void@
F << extract_get_rgb_cmyk_row_def_void.F;
P << extract_get_rgb_cmyk_row_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_get_rgb_cmyk_row_decl@
type T;
identifier F = get_rgb_cmyk_row;
parameter list P;
@@
T F(P);

@script:python depends on extract_get_rgb_cmyk_row_decl@
F << extract_get_rgb_cmyk_row_decl.F;
T << extract_get_rgb_cmyk_row_decl.T;
P << extract_get_rgb_cmyk_row_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_get_rgb_cmyk_row_decl_void@
identifier F = get_rgb_cmyk_row;
parameter list P;
@@
void F(P);

@script:python depends on extract_get_rgb_cmyk_row_decl_void@
F << extract_get_rgb_cmyk_row_decl_void.F;
P << extract_get_rgb_cmyk_row_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: get_rgb_row
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_get_rgb_row_def@
type T;
identifier F = get_rgb_row;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_get_rgb_row_def@
F << remove_static_get_rgb_row_def.F;
T << remove_static_get_rgb_row_def.T;
P << remove_static_get_rgb_row_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_get_rgb_row_def_void@
identifier F = get_rgb_row;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_get_rgb_row_def_void@
F << remove_static_get_rgb_row_def_void.F;
P << remove_static_get_rgb_row_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_get_rgb_row_decl@
type T;
identifier F = get_rgb_row;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_get_rgb_row_decl@
F << remove_static_get_rgb_row_decl.F;
T << remove_static_get_rgb_row_decl.T;
P << remove_static_get_rgb_row_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_get_rgb_row_decl_void@
identifier F = get_rgb_row;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_get_rgb_row_decl_void@
F << remove_static_get_rgb_row_decl_void.F;
P << remove_static_get_rgb_row_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_get_rgb_row_def@
type T;
identifier F = get_rgb_row;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_get_rgb_row_def@
F << extract_get_rgb_row_def.F;
T << extract_get_rgb_row_def.T;
P << extract_get_rgb_row_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_get_rgb_row_def_void@
identifier F = get_rgb_row;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_get_rgb_row_def_void@
F << extract_get_rgb_row_def_void.F;
P << extract_get_rgb_row_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_get_rgb_row_decl@
type T;
identifier F = get_rgb_row;
parameter list P;
@@
T F(P);

@script:python depends on extract_get_rgb_row_decl@
F << extract_get_rgb_row_decl.F;
T << extract_get_rgb_row_decl.T;
P << extract_get_rgb_row_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_get_rgb_row_decl_void@
identifier F = get_rgb_row;
parameter list P;
@@
void F(P);

@script:python depends on extract_get_rgb_row_decl_void@
F << extract_get_rgb_row_decl_void.F;
P << extract_get_rgb_row_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: get_scaled_gray_row
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_get_scaled_gray_row_def@
type T;
identifier F = get_scaled_gray_row;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_get_scaled_gray_row_def@
F << remove_static_get_scaled_gray_row_def.F;
T << remove_static_get_scaled_gray_row_def.T;
P << remove_static_get_scaled_gray_row_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_get_scaled_gray_row_def_void@
identifier F = get_scaled_gray_row;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_get_scaled_gray_row_def_void@
F << remove_static_get_scaled_gray_row_def_void.F;
P << remove_static_get_scaled_gray_row_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_get_scaled_gray_row_decl@
type T;
identifier F = get_scaled_gray_row;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_get_scaled_gray_row_decl@
F << remove_static_get_scaled_gray_row_decl.F;
T << remove_static_get_scaled_gray_row_decl.T;
P << remove_static_get_scaled_gray_row_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_get_scaled_gray_row_decl_void@
identifier F = get_scaled_gray_row;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_get_scaled_gray_row_decl_void@
F << remove_static_get_scaled_gray_row_decl_void.F;
P << remove_static_get_scaled_gray_row_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_get_scaled_gray_row_def@
type T;
identifier F = get_scaled_gray_row;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_get_scaled_gray_row_def@
F << extract_get_scaled_gray_row_def.F;
T << extract_get_scaled_gray_row_def.T;
P << extract_get_scaled_gray_row_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_get_scaled_gray_row_def_void@
identifier F = get_scaled_gray_row;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_get_scaled_gray_row_def_void@
F << extract_get_scaled_gray_row_def_void.F;
P << extract_get_scaled_gray_row_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_get_scaled_gray_row_decl@
type T;
identifier F = get_scaled_gray_row;
parameter list P;
@@
T F(P);

@script:python depends on extract_get_scaled_gray_row_decl@
F << extract_get_scaled_gray_row_decl.F;
T << extract_get_scaled_gray_row_decl.T;
P << extract_get_scaled_gray_row_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_get_scaled_gray_row_decl_void@
identifier F = get_scaled_gray_row;
parameter list P;
@@
void F(P);

@script:python depends on extract_get_scaled_gray_row_decl_void@
F << extract_get_scaled_gray_row_decl_void.F;
P << extract_get_scaled_gray_row_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: get_text_gray_cmyk_row
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_get_text_gray_cmyk_row_def@
type T;
identifier F = get_text_gray_cmyk_row;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_get_text_gray_cmyk_row_def@
F << remove_static_get_text_gray_cmyk_row_def.F;
T << remove_static_get_text_gray_cmyk_row_def.T;
P << remove_static_get_text_gray_cmyk_row_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_get_text_gray_cmyk_row_def_void@
identifier F = get_text_gray_cmyk_row;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_get_text_gray_cmyk_row_def_void@
F << remove_static_get_text_gray_cmyk_row_def_void.F;
P << remove_static_get_text_gray_cmyk_row_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_get_text_gray_cmyk_row_decl@
type T;
identifier F = get_text_gray_cmyk_row;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_get_text_gray_cmyk_row_decl@
F << remove_static_get_text_gray_cmyk_row_decl.F;
T << remove_static_get_text_gray_cmyk_row_decl.T;
P << remove_static_get_text_gray_cmyk_row_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_get_text_gray_cmyk_row_decl_void@
identifier F = get_text_gray_cmyk_row;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_get_text_gray_cmyk_row_decl_void@
F << remove_static_get_text_gray_cmyk_row_decl_void.F;
P << remove_static_get_text_gray_cmyk_row_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_get_text_gray_cmyk_row_def@
type T;
identifier F = get_text_gray_cmyk_row;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_get_text_gray_cmyk_row_def@
F << extract_get_text_gray_cmyk_row_def.F;
T << extract_get_text_gray_cmyk_row_def.T;
P << extract_get_text_gray_cmyk_row_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_get_text_gray_cmyk_row_def_void@
identifier F = get_text_gray_cmyk_row;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_get_text_gray_cmyk_row_def_void@
F << extract_get_text_gray_cmyk_row_def_void.F;
P << extract_get_text_gray_cmyk_row_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_get_text_gray_cmyk_row_decl@
type T;
identifier F = get_text_gray_cmyk_row;
parameter list P;
@@
T F(P);

@script:python depends on extract_get_text_gray_cmyk_row_decl@
F << extract_get_text_gray_cmyk_row_decl.F;
T << extract_get_text_gray_cmyk_row_decl.T;
P << extract_get_text_gray_cmyk_row_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_get_text_gray_cmyk_row_decl_void@
identifier F = get_text_gray_cmyk_row;
parameter list P;
@@
void F(P);

@script:python depends on extract_get_text_gray_cmyk_row_decl_void@
F << extract_get_text_gray_cmyk_row_decl_void.F;
P << extract_get_text_gray_cmyk_row_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: get_text_gray_rgb_row
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_get_text_gray_rgb_row_def@
type T;
identifier F = get_text_gray_rgb_row;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_get_text_gray_rgb_row_def@
F << remove_static_get_text_gray_rgb_row_def.F;
T << remove_static_get_text_gray_rgb_row_def.T;
P << remove_static_get_text_gray_rgb_row_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_get_text_gray_rgb_row_def_void@
identifier F = get_text_gray_rgb_row;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_get_text_gray_rgb_row_def_void@
F << remove_static_get_text_gray_rgb_row_def_void.F;
P << remove_static_get_text_gray_rgb_row_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_get_text_gray_rgb_row_decl@
type T;
identifier F = get_text_gray_rgb_row;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_get_text_gray_rgb_row_decl@
F << remove_static_get_text_gray_rgb_row_decl.F;
T << remove_static_get_text_gray_rgb_row_decl.T;
P << remove_static_get_text_gray_rgb_row_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_get_text_gray_rgb_row_decl_void@
identifier F = get_text_gray_rgb_row;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_get_text_gray_rgb_row_decl_void@
F << remove_static_get_text_gray_rgb_row_decl_void.F;
P << remove_static_get_text_gray_rgb_row_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_get_text_gray_rgb_row_def@
type T;
identifier F = get_text_gray_rgb_row;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_get_text_gray_rgb_row_def@
F << extract_get_text_gray_rgb_row_def.F;
T << extract_get_text_gray_rgb_row_def.T;
P << extract_get_text_gray_rgb_row_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_get_text_gray_rgb_row_def_void@
identifier F = get_text_gray_rgb_row;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_get_text_gray_rgb_row_def_void@
F << extract_get_text_gray_rgb_row_def_void.F;
P << extract_get_text_gray_rgb_row_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_get_text_gray_rgb_row_decl@
type T;
identifier F = get_text_gray_rgb_row;
parameter list P;
@@
T F(P);

@script:python depends on extract_get_text_gray_rgb_row_decl@
F << extract_get_text_gray_rgb_row_decl.F;
T << extract_get_text_gray_rgb_row_decl.T;
P << extract_get_text_gray_rgb_row_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_get_text_gray_rgb_row_decl_void@
identifier F = get_text_gray_rgb_row;
parameter list P;
@@
void F(P);

@script:python depends on extract_get_text_gray_rgb_row_decl_void@
F << extract_get_text_gray_rgb_row_decl_void.F;
P << extract_get_text_gray_rgb_row_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: get_text_gray_row
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_get_text_gray_row_def@
type T;
identifier F = get_text_gray_row;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_get_text_gray_row_def@
F << remove_static_get_text_gray_row_def.F;
T << remove_static_get_text_gray_row_def.T;
P << remove_static_get_text_gray_row_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_get_text_gray_row_def_void@
identifier F = get_text_gray_row;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_get_text_gray_row_def_void@
F << remove_static_get_text_gray_row_def_void.F;
P << remove_static_get_text_gray_row_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_get_text_gray_row_decl@
type T;
identifier F = get_text_gray_row;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_get_text_gray_row_decl@
F << remove_static_get_text_gray_row_decl.F;
T << remove_static_get_text_gray_row_decl.T;
P << remove_static_get_text_gray_row_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_get_text_gray_row_decl_void@
identifier F = get_text_gray_row;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_get_text_gray_row_decl_void@
F << remove_static_get_text_gray_row_decl_void.F;
P << remove_static_get_text_gray_row_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_get_text_gray_row_def@
type T;
identifier F = get_text_gray_row;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_get_text_gray_row_def@
F << extract_get_text_gray_row_def.F;
T << extract_get_text_gray_row_def.T;
P << extract_get_text_gray_row_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_get_text_gray_row_def_void@
identifier F = get_text_gray_row;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_get_text_gray_row_def_void@
F << extract_get_text_gray_row_def_void.F;
P << extract_get_text_gray_row_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_get_text_gray_row_decl@
type T;
identifier F = get_text_gray_row;
parameter list P;
@@
T F(P);

@script:python depends on extract_get_text_gray_row_decl@
F << extract_get_text_gray_row_decl.F;
T << extract_get_text_gray_row_decl.T;
P << extract_get_text_gray_row_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_get_text_gray_row_decl_void@
identifier F = get_text_gray_row;
parameter list P;
@@
void F(P);

@script:python depends on extract_get_text_gray_row_decl_void@
F << extract_get_text_gray_row_decl_void.F;
P << extract_get_text_gray_row_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: get_text_rgb_cmyk_row
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_get_text_rgb_cmyk_row_def@
type T;
identifier F = get_text_rgb_cmyk_row;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_get_text_rgb_cmyk_row_def@
F << remove_static_get_text_rgb_cmyk_row_def.F;
T << remove_static_get_text_rgb_cmyk_row_def.T;
P << remove_static_get_text_rgb_cmyk_row_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_get_text_rgb_cmyk_row_def_void@
identifier F = get_text_rgb_cmyk_row;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_get_text_rgb_cmyk_row_def_void@
F << remove_static_get_text_rgb_cmyk_row_def_void.F;
P << remove_static_get_text_rgb_cmyk_row_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_get_text_rgb_cmyk_row_decl@
type T;
identifier F = get_text_rgb_cmyk_row;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_get_text_rgb_cmyk_row_decl@
F << remove_static_get_text_rgb_cmyk_row_decl.F;
T << remove_static_get_text_rgb_cmyk_row_decl.T;
P << remove_static_get_text_rgb_cmyk_row_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_get_text_rgb_cmyk_row_decl_void@
identifier F = get_text_rgb_cmyk_row;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_get_text_rgb_cmyk_row_decl_void@
F << remove_static_get_text_rgb_cmyk_row_decl_void.F;
P << remove_static_get_text_rgb_cmyk_row_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_get_text_rgb_cmyk_row_def@
type T;
identifier F = get_text_rgb_cmyk_row;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_get_text_rgb_cmyk_row_def@
F << extract_get_text_rgb_cmyk_row_def.F;
T << extract_get_text_rgb_cmyk_row_def.T;
P << extract_get_text_rgb_cmyk_row_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_get_text_rgb_cmyk_row_def_void@
identifier F = get_text_rgb_cmyk_row;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_get_text_rgb_cmyk_row_def_void@
F << extract_get_text_rgb_cmyk_row_def_void.F;
P << extract_get_text_rgb_cmyk_row_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_get_text_rgb_cmyk_row_decl@
type T;
identifier F = get_text_rgb_cmyk_row;
parameter list P;
@@
T F(P);

@script:python depends on extract_get_text_rgb_cmyk_row_decl@
F << extract_get_text_rgb_cmyk_row_decl.F;
T << extract_get_text_rgb_cmyk_row_decl.T;
P << extract_get_text_rgb_cmyk_row_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_get_text_rgb_cmyk_row_decl_void@
identifier F = get_text_rgb_cmyk_row;
parameter list P;
@@
void F(P);

@script:python depends on extract_get_text_rgb_cmyk_row_decl_void@
F << extract_get_text_rgb_cmyk_row_decl_void.F;
P << extract_get_text_rgb_cmyk_row_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: get_text_rgb_row
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_get_text_rgb_row_def@
type T;
identifier F = get_text_rgb_row;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_get_text_rgb_row_def@
F << remove_static_get_text_rgb_row_def.F;
T << remove_static_get_text_rgb_row_def.T;
P << remove_static_get_text_rgb_row_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_get_text_rgb_row_def_void@
identifier F = get_text_rgb_row;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_get_text_rgb_row_def_void@
F << remove_static_get_text_rgb_row_def_void.F;
P << remove_static_get_text_rgb_row_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_get_text_rgb_row_decl@
type T;
identifier F = get_text_rgb_row;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_get_text_rgb_row_decl@
F << remove_static_get_text_rgb_row_decl.F;
T << remove_static_get_text_rgb_row_decl.T;
P << remove_static_get_text_rgb_row_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_get_text_rgb_row_decl_void@
identifier F = get_text_rgb_row;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_get_text_rgb_row_decl_void@
F << remove_static_get_text_rgb_row_decl_void.F;
P << remove_static_get_text_rgb_row_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_get_text_rgb_row_def@
type T;
identifier F = get_text_rgb_row;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_get_text_rgb_row_def@
F << extract_get_text_rgb_row_def.F;
T << extract_get_text_rgb_row_def.T;
P << extract_get_text_rgb_row_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_get_text_rgb_row_def_void@
identifier F = get_text_rgb_row;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_get_text_rgb_row_def_void@
F << extract_get_text_rgb_row_def_void.F;
P << extract_get_text_rgb_row_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_get_text_rgb_row_decl@
type T;
identifier F = get_text_rgb_row;
parameter list P;
@@
T F(P);

@script:python depends on extract_get_text_rgb_row_decl@
F << extract_get_text_rgb_row_decl.F;
T << extract_get_text_rgb_row_decl.T;
P << extract_get_text_rgb_row_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_get_text_rgb_row_decl_void@
identifier F = get_text_rgb_row;
parameter list P;
@@
void F(P);

@script:python depends on extract_get_text_rgb_row_decl_void@
F << extract_get_text_rgb_row_decl_void.F;
P << extract_get_text_rgb_row_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: get_word_gray_cmyk_row
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_get_word_gray_cmyk_row_def@
type T;
identifier F = get_word_gray_cmyk_row;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_get_word_gray_cmyk_row_def@
F << remove_static_get_word_gray_cmyk_row_def.F;
T << remove_static_get_word_gray_cmyk_row_def.T;
P << remove_static_get_word_gray_cmyk_row_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_get_word_gray_cmyk_row_def_void@
identifier F = get_word_gray_cmyk_row;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_get_word_gray_cmyk_row_def_void@
F << remove_static_get_word_gray_cmyk_row_def_void.F;
P << remove_static_get_word_gray_cmyk_row_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_get_word_gray_cmyk_row_decl@
type T;
identifier F = get_word_gray_cmyk_row;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_get_word_gray_cmyk_row_decl@
F << remove_static_get_word_gray_cmyk_row_decl.F;
T << remove_static_get_word_gray_cmyk_row_decl.T;
P << remove_static_get_word_gray_cmyk_row_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_get_word_gray_cmyk_row_decl_void@
identifier F = get_word_gray_cmyk_row;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_get_word_gray_cmyk_row_decl_void@
F << remove_static_get_word_gray_cmyk_row_decl_void.F;
P << remove_static_get_word_gray_cmyk_row_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_get_word_gray_cmyk_row_def@
type T;
identifier F = get_word_gray_cmyk_row;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_get_word_gray_cmyk_row_def@
F << extract_get_word_gray_cmyk_row_def.F;
T << extract_get_word_gray_cmyk_row_def.T;
P << extract_get_word_gray_cmyk_row_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_get_word_gray_cmyk_row_def_void@
identifier F = get_word_gray_cmyk_row;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_get_word_gray_cmyk_row_def_void@
F << extract_get_word_gray_cmyk_row_def_void.F;
P << extract_get_word_gray_cmyk_row_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_get_word_gray_cmyk_row_decl@
type T;
identifier F = get_word_gray_cmyk_row;
parameter list P;
@@
T F(P);

@script:python depends on extract_get_word_gray_cmyk_row_decl@
F << extract_get_word_gray_cmyk_row_decl.F;
T << extract_get_word_gray_cmyk_row_decl.T;
P << extract_get_word_gray_cmyk_row_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_get_word_gray_cmyk_row_decl_void@
identifier F = get_word_gray_cmyk_row;
parameter list P;
@@
void F(P);

@script:python depends on extract_get_word_gray_cmyk_row_decl_void@
F << extract_get_word_gray_cmyk_row_decl_void.F;
P << extract_get_word_gray_cmyk_row_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: get_word_gray_rgb_row
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_get_word_gray_rgb_row_def@
type T;
identifier F = get_word_gray_rgb_row;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_get_word_gray_rgb_row_def@
F << remove_static_get_word_gray_rgb_row_def.F;
T << remove_static_get_word_gray_rgb_row_def.T;
P << remove_static_get_word_gray_rgb_row_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_get_word_gray_rgb_row_def_void@
identifier F = get_word_gray_rgb_row;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_get_word_gray_rgb_row_def_void@
F << remove_static_get_word_gray_rgb_row_def_void.F;
P << remove_static_get_word_gray_rgb_row_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_get_word_gray_rgb_row_decl@
type T;
identifier F = get_word_gray_rgb_row;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_get_word_gray_rgb_row_decl@
F << remove_static_get_word_gray_rgb_row_decl.F;
T << remove_static_get_word_gray_rgb_row_decl.T;
P << remove_static_get_word_gray_rgb_row_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_get_word_gray_rgb_row_decl_void@
identifier F = get_word_gray_rgb_row;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_get_word_gray_rgb_row_decl_void@
F << remove_static_get_word_gray_rgb_row_decl_void.F;
P << remove_static_get_word_gray_rgb_row_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_get_word_gray_rgb_row_def@
type T;
identifier F = get_word_gray_rgb_row;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_get_word_gray_rgb_row_def@
F << extract_get_word_gray_rgb_row_def.F;
T << extract_get_word_gray_rgb_row_def.T;
P << extract_get_word_gray_rgb_row_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_get_word_gray_rgb_row_def_void@
identifier F = get_word_gray_rgb_row;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_get_word_gray_rgb_row_def_void@
F << extract_get_word_gray_rgb_row_def_void.F;
P << extract_get_word_gray_rgb_row_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_get_word_gray_rgb_row_decl@
type T;
identifier F = get_word_gray_rgb_row;
parameter list P;
@@
T F(P);

@script:python depends on extract_get_word_gray_rgb_row_decl@
F << extract_get_word_gray_rgb_row_decl.F;
T << extract_get_word_gray_rgb_row_decl.T;
P << extract_get_word_gray_rgb_row_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_get_word_gray_rgb_row_decl_void@
identifier F = get_word_gray_rgb_row;
parameter list P;
@@
void F(P);

@script:python depends on extract_get_word_gray_rgb_row_decl_void@
F << extract_get_word_gray_rgb_row_decl_void.F;
P << extract_get_word_gray_rgb_row_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: get_word_gray_row
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_get_word_gray_row_def@
type T;
identifier F = get_word_gray_row;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_get_word_gray_row_def@
F << remove_static_get_word_gray_row_def.F;
T << remove_static_get_word_gray_row_def.T;
P << remove_static_get_word_gray_row_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_get_word_gray_row_def_void@
identifier F = get_word_gray_row;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_get_word_gray_row_def_void@
F << remove_static_get_word_gray_row_def_void.F;
P << remove_static_get_word_gray_row_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_get_word_gray_row_decl@
type T;
identifier F = get_word_gray_row;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_get_word_gray_row_decl@
F << remove_static_get_word_gray_row_decl.F;
T << remove_static_get_word_gray_row_decl.T;
P << remove_static_get_word_gray_row_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_get_word_gray_row_decl_void@
identifier F = get_word_gray_row;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_get_word_gray_row_decl_void@
F << remove_static_get_word_gray_row_decl_void.F;
P << remove_static_get_word_gray_row_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_get_word_gray_row_def@
type T;
identifier F = get_word_gray_row;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_get_word_gray_row_def@
F << extract_get_word_gray_row_def.F;
T << extract_get_word_gray_row_def.T;
P << extract_get_word_gray_row_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_get_word_gray_row_def_void@
identifier F = get_word_gray_row;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_get_word_gray_row_def_void@
F << extract_get_word_gray_row_def_void.F;
P << extract_get_word_gray_row_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_get_word_gray_row_decl@
type T;
identifier F = get_word_gray_row;
parameter list P;
@@
T F(P);

@script:python depends on extract_get_word_gray_row_decl@
F << extract_get_word_gray_row_decl.F;
T << extract_get_word_gray_row_decl.T;
P << extract_get_word_gray_row_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_get_word_gray_row_decl_void@
identifier F = get_word_gray_row;
parameter list P;
@@
void F(P);

@script:python depends on extract_get_word_gray_row_decl_void@
F << extract_get_word_gray_row_decl_void.F;
P << extract_get_word_gray_row_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: get_word_rgb_cmyk_row
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_get_word_rgb_cmyk_row_def@
type T;
identifier F = get_word_rgb_cmyk_row;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_get_word_rgb_cmyk_row_def@
F << remove_static_get_word_rgb_cmyk_row_def.F;
T << remove_static_get_word_rgb_cmyk_row_def.T;
P << remove_static_get_word_rgb_cmyk_row_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_get_word_rgb_cmyk_row_def_void@
identifier F = get_word_rgb_cmyk_row;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_get_word_rgb_cmyk_row_def_void@
F << remove_static_get_word_rgb_cmyk_row_def_void.F;
P << remove_static_get_word_rgb_cmyk_row_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_get_word_rgb_cmyk_row_decl@
type T;
identifier F = get_word_rgb_cmyk_row;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_get_word_rgb_cmyk_row_decl@
F << remove_static_get_word_rgb_cmyk_row_decl.F;
T << remove_static_get_word_rgb_cmyk_row_decl.T;
P << remove_static_get_word_rgb_cmyk_row_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_get_word_rgb_cmyk_row_decl_void@
identifier F = get_word_rgb_cmyk_row;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_get_word_rgb_cmyk_row_decl_void@
F << remove_static_get_word_rgb_cmyk_row_decl_void.F;
P << remove_static_get_word_rgb_cmyk_row_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_get_word_rgb_cmyk_row_def@
type T;
identifier F = get_word_rgb_cmyk_row;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_get_word_rgb_cmyk_row_def@
F << extract_get_word_rgb_cmyk_row_def.F;
T << extract_get_word_rgb_cmyk_row_def.T;
P << extract_get_word_rgb_cmyk_row_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_get_word_rgb_cmyk_row_def_void@
identifier F = get_word_rgb_cmyk_row;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_get_word_rgb_cmyk_row_def_void@
F << extract_get_word_rgb_cmyk_row_def_void.F;
P << extract_get_word_rgb_cmyk_row_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_get_word_rgb_cmyk_row_decl@
type T;
identifier F = get_word_rgb_cmyk_row;
parameter list P;
@@
T F(P);

@script:python depends on extract_get_word_rgb_cmyk_row_decl@
F << extract_get_word_rgb_cmyk_row_decl.F;
T << extract_get_word_rgb_cmyk_row_decl.T;
P << extract_get_word_rgb_cmyk_row_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_get_word_rgb_cmyk_row_decl_void@
identifier F = get_word_rgb_cmyk_row;
parameter list P;
@@
void F(P);

@script:python depends on extract_get_word_rgb_cmyk_row_decl_void@
F << extract_get_word_rgb_cmyk_row_decl_void.F;
P << extract_get_word_rgb_cmyk_row_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: get_word_rgb_row
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_get_word_rgb_row_def@
type T;
identifier F = get_word_rgb_row;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_get_word_rgb_row_def@
F << remove_static_get_word_rgb_row_def.F;
T << remove_static_get_word_rgb_row_def.T;
P << remove_static_get_word_rgb_row_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_get_word_rgb_row_def_void@
identifier F = get_word_rgb_row;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_get_word_rgb_row_def_void@
F << remove_static_get_word_rgb_row_def_void.F;
P << remove_static_get_word_rgb_row_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_get_word_rgb_row_decl@
type T;
identifier F = get_word_rgb_row;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_get_word_rgb_row_decl@
F << remove_static_get_word_rgb_row_decl.F;
T << remove_static_get_word_rgb_row_decl.T;
P << remove_static_get_word_rgb_row_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_get_word_rgb_row_decl_void@
identifier F = get_word_rgb_row;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_get_word_rgb_row_decl_void@
F << remove_static_get_word_rgb_row_decl_void.F;
P << remove_static_get_word_rgb_row_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_get_word_rgb_row_def@
type T;
identifier F = get_word_rgb_row;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_get_word_rgb_row_def@
F << extract_get_word_rgb_row_def.F;
T << extract_get_word_rgb_row_def.T;
P << extract_get_word_rgb_row_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_get_word_rgb_row_def_void@
identifier F = get_word_rgb_row;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_get_word_rgb_row_def_void@
F << extract_get_word_rgb_row_def_void.F;
P << extract_get_word_rgb_row_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_get_word_rgb_row_decl@
type T;
identifier F = get_word_rgb_row;
parameter list P;
@@
T F(P);

@script:python depends on extract_get_word_rgb_row_decl@
F << extract_get_word_rgb_row_decl.F;
T << extract_get_word_rgb_row_decl.T;
P << extract_get_word_rgb_row_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_get_word_rgb_row_decl_void@
identifier F = get_word_rgb_row;
parameter list P;
@@
void F(P);

@script:python depends on extract_get_word_rgb_row_decl_void@
F << extract_get_word_rgb_row_decl_void.F;
P << extract_get_word_rgb_row_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: h2v1_merged_upsample
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_h2v1_merged_upsample_def@
type T;
identifier F = h2v1_merged_upsample;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_h2v1_merged_upsample_def@
F << remove_static_h2v1_merged_upsample_def.F;
T << remove_static_h2v1_merged_upsample_def.T;
P << remove_static_h2v1_merged_upsample_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_h2v1_merged_upsample_def_void@
identifier F = h2v1_merged_upsample;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_h2v1_merged_upsample_def_void@
F << remove_static_h2v1_merged_upsample_def_void.F;
P << remove_static_h2v1_merged_upsample_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_h2v1_merged_upsample_decl@
type T;
identifier F = h2v1_merged_upsample;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_h2v1_merged_upsample_decl@
F << remove_static_h2v1_merged_upsample_decl.F;
T << remove_static_h2v1_merged_upsample_decl.T;
P << remove_static_h2v1_merged_upsample_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_h2v1_merged_upsample_decl_void@
identifier F = h2v1_merged_upsample;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_h2v1_merged_upsample_decl_void@
F << remove_static_h2v1_merged_upsample_decl_void.F;
P << remove_static_h2v1_merged_upsample_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_h2v1_merged_upsample_def@
type T;
identifier F = h2v1_merged_upsample;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_h2v1_merged_upsample_def@
F << extract_h2v1_merged_upsample_def.F;
T << extract_h2v1_merged_upsample_def.T;
P << extract_h2v1_merged_upsample_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_h2v1_merged_upsample_def_void@
identifier F = h2v1_merged_upsample;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_h2v1_merged_upsample_def_void@
F << extract_h2v1_merged_upsample_def_void.F;
P << extract_h2v1_merged_upsample_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_h2v1_merged_upsample_decl@
type T;
identifier F = h2v1_merged_upsample;
parameter list P;
@@
T F(P);

@script:python depends on extract_h2v1_merged_upsample_decl@
F << extract_h2v1_merged_upsample_decl.F;
T << extract_h2v1_merged_upsample_decl.T;
P << extract_h2v1_merged_upsample_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_h2v1_merged_upsample_decl_void@
identifier F = h2v1_merged_upsample;
parameter list P;
@@
void F(P);

@script:python depends on extract_h2v1_merged_upsample_decl_void@
F << extract_h2v1_merged_upsample_decl_void.F;
P << extract_h2v1_merged_upsample_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: h2v1_merged_upsample_565
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_h2v1_merged_upsample_565_def@
type T;
identifier F = h2v1_merged_upsample_565;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_h2v1_merged_upsample_565_def@
F << remove_static_h2v1_merged_upsample_565_def.F;
T << remove_static_h2v1_merged_upsample_565_def.T;
P << remove_static_h2v1_merged_upsample_565_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_h2v1_merged_upsample_565_def_void@
identifier F = h2v1_merged_upsample_565;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_h2v1_merged_upsample_565_def_void@
F << remove_static_h2v1_merged_upsample_565_def_void.F;
P << remove_static_h2v1_merged_upsample_565_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_h2v1_merged_upsample_565_decl@
type T;
identifier F = h2v1_merged_upsample_565;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_h2v1_merged_upsample_565_decl@
F << remove_static_h2v1_merged_upsample_565_decl.F;
T << remove_static_h2v1_merged_upsample_565_decl.T;
P << remove_static_h2v1_merged_upsample_565_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_h2v1_merged_upsample_565_decl_void@
identifier F = h2v1_merged_upsample_565;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_h2v1_merged_upsample_565_decl_void@
F << remove_static_h2v1_merged_upsample_565_decl_void.F;
P << remove_static_h2v1_merged_upsample_565_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_h2v1_merged_upsample_565_def@
type T;
identifier F = h2v1_merged_upsample_565;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_h2v1_merged_upsample_565_def@
F << extract_h2v1_merged_upsample_565_def.F;
T << extract_h2v1_merged_upsample_565_def.T;
P << extract_h2v1_merged_upsample_565_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_h2v1_merged_upsample_565_def_void@
identifier F = h2v1_merged_upsample_565;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_h2v1_merged_upsample_565_def_void@
F << extract_h2v1_merged_upsample_565_def_void.F;
P << extract_h2v1_merged_upsample_565_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_h2v1_merged_upsample_565_decl@
type T;
identifier F = h2v1_merged_upsample_565;
parameter list P;
@@
T F(P);

@script:python depends on extract_h2v1_merged_upsample_565_decl@
F << extract_h2v1_merged_upsample_565_decl.F;
T << extract_h2v1_merged_upsample_565_decl.T;
P << extract_h2v1_merged_upsample_565_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_h2v1_merged_upsample_565_decl_void@
identifier F = h2v1_merged_upsample_565;
parameter list P;
@@
void F(P);

@script:python depends on extract_h2v1_merged_upsample_565_decl_void@
F << extract_h2v1_merged_upsample_565_decl_void.F;
P << extract_h2v1_merged_upsample_565_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: h2v1_merged_upsample_565D
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_h2v1_merged_upsample_565D_def@
type T;
identifier F = h2v1_merged_upsample_565D;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_h2v1_merged_upsample_565D_def@
F << remove_static_h2v1_merged_upsample_565D_def.F;
T << remove_static_h2v1_merged_upsample_565D_def.T;
P << remove_static_h2v1_merged_upsample_565D_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_h2v1_merged_upsample_565D_def_void@
identifier F = h2v1_merged_upsample_565D;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_h2v1_merged_upsample_565D_def_void@
F << remove_static_h2v1_merged_upsample_565D_def_void.F;
P << remove_static_h2v1_merged_upsample_565D_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_h2v1_merged_upsample_565D_decl@
type T;
identifier F = h2v1_merged_upsample_565D;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_h2v1_merged_upsample_565D_decl@
F << remove_static_h2v1_merged_upsample_565D_decl.F;
T << remove_static_h2v1_merged_upsample_565D_decl.T;
P << remove_static_h2v1_merged_upsample_565D_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_h2v1_merged_upsample_565D_decl_void@
identifier F = h2v1_merged_upsample_565D;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_h2v1_merged_upsample_565D_decl_void@
F << remove_static_h2v1_merged_upsample_565D_decl_void.F;
P << remove_static_h2v1_merged_upsample_565D_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_h2v1_merged_upsample_565D_def@
type T;
identifier F = h2v1_merged_upsample_565D;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_h2v1_merged_upsample_565D_def@
F << extract_h2v1_merged_upsample_565D_def.F;
T << extract_h2v1_merged_upsample_565D_def.T;
P << extract_h2v1_merged_upsample_565D_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_h2v1_merged_upsample_565D_def_void@
identifier F = h2v1_merged_upsample_565D;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_h2v1_merged_upsample_565D_def_void@
F << extract_h2v1_merged_upsample_565D_def_void.F;
P << extract_h2v1_merged_upsample_565D_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_h2v1_merged_upsample_565D_decl@
type T;
identifier F = h2v1_merged_upsample_565D;
parameter list P;
@@
T F(P);

@script:python depends on extract_h2v1_merged_upsample_565D_decl@
F << extract_h2v1_merged_upsample_565D_decl.F;
T << extract_h2v1_merged_upsample_565D_decl.T;
P << extract_h2v1_merged_upsample_565D_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_h2v1_merged_upsample_565D_decl_void@
identifier F = h2v1_merged_upsample_565D;
parameter list P;
@@
void F(P);

@script:python depends on extract_h2v1_merged_upsample_565D_decl_void@
F << extract_h2v1_merged_upsample_565D_decl_void.F;
P << extract_h2v1_merged_upsample_565D_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: h2v2_merged_upsample
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_h2v2_merged_upsample_def@
type T;
identifier F = h2v2_merged_upsample;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_h2v2_merged_upsample_def@
F << remove_static_h2v2_merged_upsample_def.F;
T << remove_static_h2v2_merged_upsample_def.T;
P << remove_static_h2v2_merged_upsample_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_h2v2_merged_upsample_def_void@
identifier F = h2v2_merged_upsample;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_h2v2_merged_upsample_def_void@
F << remove_static_h2v2_merged_upsample_def_void.F;
P << remove_static_h2v2_merged_upsample_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_h2v2_merged_upsample_decl@
type T;
identifier F = h2v2_merged_upsample;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_h2v2_merged_upsample_decl@
F << remove_static_h2v2_merged_upsample_decl.F;
T << remove_static_h2v2_merged_upsample_decl.T;
P << remove_static_h2v2_merged_upsample_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_h2v2_merged_upsample_decl_void@
identifier F = h2v2_merged_upsample;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_h2v2_merged_upsample_decl_void@
F << remove_static_h2v2_merged_upsample_decl_void.F;
P << remove_static_h2v2_merged_upsample_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_h2v2_merged_upsample_def@
type T;
identifier F = h2v2_merged_upsample;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_h2v2_merged_upsample_def@
F << extract_h2v2_merged_upsample_def.F;
T << extract_h2v2_merged_upsample_def.T;
P << extract_h2v2_merged_upsample_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_h2v2_merged_upsample_def_void@
identifier F = h2v2_merged_upsample;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_h2v2_merged_upsample_def_void@
F << extract_h2v2_merged_upsample_def_void.F;
P << extract_h2v2_merged_upsample_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_h2v2_merged_upsample_decl@
type T;
identifier F = h2v2_merged_upsample;
parameter list P;
@@
T F(P);

@script:python depends on extract_h2v2_merged_upsample_decl@
F << extract_h2v2_merged_upsample_decl.F;
T << extract_h2v2_merged_upsample_decl.T;
P << extract_h2v2_merged_upsample_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_h2v2_merged_upsample_decl_void@
identifier F = h2v2_merged_upsample;
parameter list P;
@@
void F(P);

@script:python depends on extract_h2v2_merged_upsample_decl_void@
F << extract_h2v2_merged_upsample_decl_void.F;
P << extract_h2v2_merged_upsample_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: h2v2_merged_upsample_565
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_h2v2_merged_upsample_565_def@
type T;
identifier F = h2v2_merged_upsample_565;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_h2v2_merged_upsample_565_def@
F << remove_static_h2v2_merged_upsample_565_def.F;
T << remove_static_h2v2_merged_upsample_565_def.T;
P << remove_static_h2v2_merged_upsample_565_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_h2v2_merged_upsample_565_def_void@
identifier F = h2v2_merged_upsample_565;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_h2v2_merged_upsample_565_def_void@
F << remove_static_h2v2_merged_upsample_565_def_void.F;
P << remove_static_h2v2_merged_upsample_565_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_h2v2_merged_upsample_565_decl@
type T;
identifier F = h2v2_merged_upsample_565;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_h2v2_merged_upsample_565_decl@
F << remove_static_h2v2_merged_upsample_565_decl.F;
T << remove_static_h2v2_merged_upsample_565_decl.T;
P << remove_static_h2v2_merged_upsample_565_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_h2v2_merged_upsample_565_decl_void@
identifier F = h2v2_merged_upsample_565;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_h2v2_merged_upsample_565_decl_void@
F << remove_static_h2v2_merged_upsample_565_decl_void.F;
P << remove_static_h2v2_merged_upsample_565_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_h2v2_merged_upsample_565_def@
type T;
identifier F = h2v2_merged_upsample_565;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_h2v2_merged_upsample_565_def@
F << extract_h2v2_merged_upsample_565_def.F;
T << extract_h2v2_merged_upsample_565_def.T;
P << extract_h2v2_merged_upsample_565_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_h2v2_merged_upsample_565_def_void@
identifier F = h2v2_merged_upsample_565;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_h2v2_merged_upsample_565_def_void@
F << extract_h2v2_merged_upsample_565_def_void.F;
P << extract_h2v2_merged_upsample_565_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_h2v2_merged_upsample_565_decl@
type T;
identifier F = h2v2_merged_upsample_565;
parameter list P;
@@
T F(P);

@script:python depends on extract_h2v2_merged_upsample_565_decl@
F << extract_h2v2_merged_upsample_565_decl.F;
T << extract_h2v2_merged_upsample_565_decl.T;
P << extract_h2v2_merged_upsample_565_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_h2v2_merged_upsample_565_decl_void@
identifier F = h2v2_merged_upsample_565;
parameter list P;
@@
void F(P);

@script:python depends on extract_h2v2_merged_upsample_565_decl_void@
F << extract_h2v2_merged_upsample_565_decl_void.F;
P << extract_h2v2_merged_upsample_565_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: h2v2_merged_upsample_565D
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_h2v2_merged_upsample_565D_def@
type T;
identifier F = h2v2_merged_upsample_565D;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_h2v2_merged_upsample_565D_def@
F << remove_static_h2v2_merged_upsample_565D_def.F;
T << remove_static_h2v2_merged_upsample_565D_def.T;
P << remove_static_h2v2_merged_upsample_565D_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_h2v2_merged_upsample_565D_def_void@
identifier F = h2v2_merged_upsample_565D;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_h2v2_merged_upsample_565D_def_void@
F << remove_static_h2v2_merged_upsample_565D_def_void.F;
P << remove_static_h2v2_merged_upsample_565D_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_h2v2_merged_upsample_565D_decl@
type T;
identifier F = h2v2_merged_upsample_565D;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_h2v2_merged_upsample_565D_decl@
F << remove_static_h2v2_merged_upsample_565D_decl.F;
T << remove_static_h2v2_merged_upsample_565D_decl.T;
P << remove_static_h2v2_merged_upsample_565D_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_h2v2_merged_upsample_565D_decl_void@
identifier F = h2v2_merged_upsample_565D;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_h2v2_merged_upsample_565D_decl_void@
F << remove_static_h2v2_merged_upsample_565D_decl_void.F;
P << remove_static_h2v2_merged_upsample_565D_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_h2v2_merged_upsample_565D_def@
type T;
identifier F = h2v2_merged_upsample_565D;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_h2v2_merged_upsample_565D_def@
F << extract_h2v2_merged_upsample_565D_def.F;
T << extract_h2v2_merged_upsample_565D_def.T;
P << extract_h2v2_merged_upsample_565D_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_h2v2_merged_upsample_565D_def_void@
identifier F = h2v2_merged_upsample_565D;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_h2v2_merged_upsample_565D_def_void@
F << extract_h2v2_merged_upsample_565D_def_void.F;
P << extract_h2v2_merged_upsample_565D_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_h2v2_merged_upsample_565D_decl@
type T;
identifier F = h2v2_merged_upsample_565D;
parameter list P;
@@
T F(P);

@script:python depends on extract_h2v2_merged_upsample_565D_decl@
F << extract_h2v2_merged_upsample_565D_decl.F;
T << extract_h2v2_merged_upsample_565D_decl.T;
P << extract_h2v2_merged_upsample_565D_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_h2v2_merged_upsample_565D_decl_void@
identifier F = h2v2_merged_upsample_565D;
parameter list P;
@@
void F(P);

@script:python depends on extract_h2v2_merged_upsample_565D_decl_void@
F << extract_h2v2_merged_upsample_565D_decl_void.F;
P << extract_h2v2_merged_upsample_565D_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: init_mem_destination
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_init_mem_destination_def@
type T;
identifier F = init_mem_destination;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_init_mem_destination_def@
F << remove_static_init_mem_destination_def.F;
T << remove_static_init_mem_destination_def.T;
P << remove_static_init_mem_destination_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_init_mem_destination_def_void@
identifier F = init_mem_destination;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_init_mem_destination_def_void@
F << remove_static_init_mem_destination_def_void.F;
P << remove_static_init_mem_destination_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_init_mem_destination_decl@
type T;
identifier F = init_mem_destination;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_init_mem_destination_decl@
F << remove_static_init_mem_destination_decl.F;
T << remove_static_init_mem_destination_decl.T;
P << remove_static_init_mem_destination_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_init_mem_destination_decl_void@
identifier F = init_mem_destination;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_init_mem_destination_decl_void@
F << remove_static_init_mem_destination_decl_void.F;
P << remove_static_init_mem_destination_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_init_mem_destination_def@
type T;
identifier F = init_mem_destination;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_init_mem_destination_def@
F << extract_init_mem_destination_def.F;
T << extract_init_mem_destination_def.T;
P << extract_init_mem_destination_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_init_mem_destination_def_void@
identifier F = init_mem_destination;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_init_mem_destination_def_void@
F << extract_init_mem_destination_def_void.F;
P << extract_init_mem_destination_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_init_mem_destination_decl@
type T;
identifier F = init_mem_destination;
parameter list P;
@@
T F(P);

@script:python depends on extract_init_mem_destination_decl@
F << extract_init_mem_destination_decl.F;
T << extract_init_mem_destination_decl.T;
P << extract_init_mem_destination_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_init_mem_destination_decl_void@
identifier F = init_mem_destination;
parameter list P;
@@
void F(P);

@script:python depends on extract_init_mem_destination_decl_void@
F << extract_init_mem_destination_decl_void.F;
P << extract_init_mem_destination_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: init_mem_source
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_init_mem_source_def@
type T;
identifier F = init_mem_source;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_init_mem_source_def@
F << remove_static_init_mem_source_def.F;
T << remove_static_init_mem_source_def.T;
P << remove_static_init_mem_source_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_init_mem_source_def_void@
identifier F = init_mem_source;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_init_mem_source_def_void@
F << remove_static_init_mem_source_def_void.F;
P << remove_static_init_mem_source_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_init_mem_source_decl@
type T;
identifier F = init_mem_source;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_init_mem_source_decl@
F << remove_static_init_mem_source_decl.F;
T << remove_static_init_mem_source_decl.T;
P << remove_static_init_mem_source_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_init_mem_source_decl_void@
identifier F = init_mem_source;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_init_mem_source_decl_void@
F << remove_static_init_mem_source_decl_void.F;
P << remove_static_init_mem_source_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_init_mem_source_def@
type T;
identifier F = init_mem_source;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_init_mem_source_def@
F << extract_init_mem_source_def.F;
T << extract_init_mem_source_def.T;
P << extract_init_mem_source_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_init_mem_source_def_void@
identifier F = init_mem_source;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_init_mem_source_def_void@
F << extract_init_mem_source_def_void.F;
P << extract_init_mem_source_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_init_mem_source_decl@
type T;
identifier F = init_mem_source;
parameter list P;
@@
T F(P);

@script:python depends on extract_init_mem_source_decl@
F << extract_init_mem_source_decl.F;
T << extract_init_mem_source_decl.T;
P << extract_init_mem_source_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_init_mem_source_decl_void@
identifier F = init_mem_source;
parameter list P;
@@
void F(P);

@script:python depends on extract_init_mem_source_decl_void@
F << extract_init_mem_source_decl_void.F;
P << extract_init_mem_source_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: jpeg_resync_to_restart
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_jpeg_resync_to_restart_def@
type T;
identifier F = jpeg_resync_to_restart;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_jpeg_resync_to_restart_def@
F << remove_static_jpeg_resync_to_restart_def.F;
T << remove_static_jpeg_resync_to_restart_def.T;
P << remove_static_jpeg_resync_to_restart_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_jpeg_resync_to_restart_def_void@
identifier F = jpeg_resync_to_restart;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_jpeg_resync_to_restart_def_void@
F << remove_static_jpeg_resync_to_restart_def_void.F;
P << remove_static_jpeg_resync_to_restart_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_jpeg_resync_to_restart_decl@
type T;
identifier F = jpeg_resync_to_restart;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_jpeg_resync_to_restart_decl@
F << remove_static_jpeg_resync_to_restart_decl.F;
T << remove_static_jpeg_resync_to_restart_decl.T;
P << remove_static_jpeg_resync_to_restart_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_jpeg_resync_to_restart_decl_void@
identifier F = jpeg_resync_to_restart;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_jpeg_resync_to_restart_decl_void@
F << remove_static_jpeg_resync_to_restart_decl_void.F;
P << remove_static_jpeg_resync_to_restart_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_jpeg_resync_to_restart_def@
type T;
identifier F = jpeg_resync_to_restart;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_jpeg_resync_to_restart_def@
F << extract_jpeg_resync_to_restart_def.F;
T << extract_jpeg_resync_to_restart_def.T;
P << extract_jpeg_resync_to_restart_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_jpeg_resync_to_restart_def_void@
identifier F = jpeg_resync_to_restart;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_jpeg_resync_to_restart_def_void@
F << extract_jpeg_resync_to_restart_def_void.F;
P << extract_jpeg_resync_to_restart_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_jpeg_resync_to_restart_decl@
type T;
identifier F = jpeg_resync_to_restart;
parameter list P;
@@
T F(P);

@script:python depends on extract_jpeg_resync_to_restart_decl@
F << extract_jpeg_resync_to_restart_decl.F;
T << extract_jpeg_resync_to_restart_decl.T;
P << extract_jpeg_resync_to_restart_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_jpeg_resync_to_restart_decl_void@
identifier F = jpeg_resync_to_restart;
parameter list P;
@@
void F(P);

@script:python depends on extract_jpeg_resync_to_restart_decl_void@
F << extract_jpeg_resync_to_restart_decl_void.F;
P << extract_jpeg_resync_to_restart_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: jsimd_convsamp
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_jsimd_convsamp_def@
type T;
identifier F = jsimd_convsamp;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_jsimd_convsamp_def@
F << remove_static_jsimd_convsamp_def.F;
T << remove_static_jsimd_convsamp_def.T;
P << remove_static_jsimd_convsamp_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_jsimd_convsamp_def_void@
identifier F = jsimd_convsamp;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_jsimd_convsamp_def_void@
F << remove_static_jsimd_convsamp_def_void.F;
P << remove_static_jsimd_convsamp_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_jsimd_convsamp_decl@
type T;
identifier F = jsimd_convsamp;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_jsimd_convsamp_decl@
F << remove_static_jsimd_convsamp_decl.F;
T << remove_static_jsimd_convsamp_decl.T;
P << remove_static_jsimd_convsamp_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_jsimd_convsamp_decl_void@
identifier F = jsimd_convsamp;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_jsimd_convsamp_decl_void@
F << remove_static_jsimd_convsamp_decl_void.F;
P << remove_static_jsimd_convsamp_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_jsimd_convsamp_def@
type T;
identifier F = jsimd_convsamp;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_jsimd_convsamp_def@
F << extract_jsimd_convsamp_def.F;
T << extract_jsimd_convsamp_def.T;
P << extract_jsimd_convsamp_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_jsimd_convsamp_def_void@
identifier F = jsimd_convsamp;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_jsimd_convsamp_def_void@
F << extract_jsimd_convsamp_def_void.F;
P << extract_jsimd_convsamp_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_jsimd_convsamp_decl@
type T;
identifier F = jsimd_convsamp;
parameter list P;
@@
T F(P);

@script:python depends on extract_jsimd_convsamp_decl@
F << extract_jsimd_convsamp_decl.F;
T << extract_jsimd_convsamp_decl.T;
P << extract_jsimd_convsamp_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_jsimd_convsamp_decl_void@
identifier F = jsimd_convsamp;
parameter list P;
@@
void F(P);

@script:python depends on extract_jsimd_convsamp_decl_void@
F << extract_jsimd_convsamp_decl_void.F;
P << extract_jsimd_convsamp_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: jsimd_convsamp_float
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_jsimd_convsamp_float_def@
type T;
identifier F = jsimd_convsamp_float;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_jsimd_convsamp_float_def@
F << remove_static_jsimd_convsamp_float_def.F;
T << remove_static_jsimd_convsamp_float_def.T;
P << remove_static_jsimd_convsamp_float_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_jsimd_convsamp_float_def_void@
identifier F = jsimd_convsamp_float;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_jsimd_convsamp_float_def_void@
F << remove_static_jsimd_convsamp_float_def_void.F;
P << remove_static_jsimd_convsamp_float_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_jsimd_convsamp_float_decl@
type T;
identifier F = jsimd_convsamp_float;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_jsimd_convsamp_float_decl@
F << remove_static_jsimd_convsamp_float_decl.F;
T << remove_static_jsimd_convsamp_float_decl.T;
P << remove_static_jsimd_convsamp_float_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_jsimd_convsamp_float_decl_void@
identifier F = jsimd_convsamp_float;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_jsimd_convsamp_float_decl_void@
F << remove_static_jsimd_convsamp_float_decl_void.F;
P << remove_static_jsimd_convsamp_float_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_jsimd_convsamp_float_def@
type T;
identifier F = jsimd_convsamp_float;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_jsimd_convsamp_float_def@
F << extract_jsimd_convsamp_float_def.F;
T << extract_jsimd_convsamp_float_def.T;
P << extract_jsimd_convsamp_float_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_jsimd_convsamp_float_def_void@
identifier F = jsimd_convsamp_float;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_jsimd_convsamp_float_def_void@
F << extract_jsimd_convsamp_float_def_void.F;
P << extract_jsimd_convsamp_float_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_jsimd_convsamp_float_decl@
type T;
identifier F = jsimd_convsamp_float;
parameter list P;
@@
T F(P);

@script:python depends on extract_jsimd_convsamp_float_decl@
F << extract_jsimd_convsamp_float_decl.F;
T << extract_jsimd_convsamp_float_decl.T;
P << extract_jsimd_convsamp_float_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_jsimd_convsamp_float_decl_void@
identifier F = jsimd_convsamp_float;
parameter list P;
@@
void F(P);

@script:python depends on extract_jsimd_convsamp_float_decl_void@
F << extract_jsimd_convsamp_float_decl_void.F;
P << extract_jsimd_convsamp_float_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: jsimd_encode_mcu_AC_first_prepare
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_jsimd_encode_mcu_AC_first_prepare_def@
type T;
identifier F = jsimd_encode_mcu_AC_first_prepare;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_jsimd_encode_mcu_AC_first_prepare_def@
F << remove_static_jsimd_encode_mcu_AC_first_prepare_def.F;
T << remove_static_jsimd_encode_mcu_AC_first_prepare_def.T;
P << remove_static_jsimd_encode_mcu_AC_first_prepare_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_jsimd_encode_mcu_AC_first_prepare_def_void@
identifier F = jsimd_encode_mcu_AC_first_prepare;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_jsimd_encode_mcu_AC_first_prepare_def_void@
F << remove_static_jsimd_encode_mcu_AC_first_prepare_def_void.F;
P << remove_static_jsimd_encode_mcu_AC_first_prepare_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_jsimd_encode_mcu_AC_first_prepare_decl@
type T;
identifier F = jsimd_encode_mcu_AC_first_prepare;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_jsimd_encode_mcu_AC_first_prepare_decl@
F << remove_static_jsimd_encode_mcu_AC_first_prepare_decl.F;
T << remove_static_jsimd_encode_mcu_AC_first_prepare_decl.T;
P << remove_static_jsimd_encode_mcu_AC_first_prepare_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_jsimd_encode_mcu_AC_first_prepare_decl_void@
identifier F = jsimd_encode_mcu_AC_first_prepare;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_jsimd_encode_mcu_AC_first_prepare_decl_void@
F << remove_static_jsimd_encode_mcu_AC_first_prepare_decl_void.F;
P << remove_static_jsimd_encode_mcu_AC_first_prepare_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_jsimd_encode_mcu_AC_first_prepare_def@
type T;
identifier F = jsimd_encode_mcu_AC_first_prepare;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_jsimd_encode_mcu_AC_first_prepare_def@
F << extract_jsimd_encode_mcu_AC_first_prepare_def.F;
T << extract_jsimd_encode_mcu_AC_first_prepare_def.T;
P << extract_jsimd_encode_mcu_AC_first_prepare_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_jsimd_encode_mcu_AC_first_prepare_def_void@
identifier F = jsimd_encode_mcu_AC_first_prepare;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_jsimd_encode_mcu_AC_first_prepare_def_void@
F << extract_jsimd_encode_mcu_AC_first_prepare_def_void.F;
P << extract_jsimd_encode_mcu_AC_first_prepare_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_jsimd_encode_mcu_AC_first_prepare_decl@
type T;
identifier F = jsimd_encode_mcu_AC_first_prepare;
parameter list P;
@@
T F(P);

@script:python depends on extract_jsimd_encode_mcu_AC_first_prepare_decl@
F << extract_jsimd_encode_mcu_AC_first_prepare_decl.F;
T << extract_jsimd_encode_mcu_AC_first_prepare_decl.T;
P << extract_jsimd_encode_mcu_AC_first_prepare_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_jsimd_encode_mcu_AC_first_prepare_decl_void@
identifier F = jsimd_encode_mcu_AC_first_prepare;
parameter list P;
@@
void F(P);

@script:python depends on extract_jsimd_encode_mcu_AC_first_prepare_decl_void@
F << extract_jsimd_encode_mcu_AC_first_prepare_decl_void.F;
P << extract_jsimd_encode_mcu_AC_first_prepare_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: jsimd_encode_mcu_AC_refine_prepare
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_jsimd_encode_mcu_AC_refine_prepare_def@
type T;
identifier F = jsimd_encode_mcu_AC_refine_prepare;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_jsimd_encode_mcu_AC_refine_prepare_def@
F << remove_static_jsimd_encode_mcu_AC_refine_prepare_def.F;
T << remove_static_jsimd_encode_mcu_AC_refine_prepare_def.T;
P << remove_static_jsimd_encode_mcu_AC_refine_prepare_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_jsimd_encode_mcu_AC_refine_prepare_def_void@
identifier F = jsimd_encode_mcu_AC_refine_prepare;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_jsimd_encode_mcu_AC_refine_prepare_def_void@
F << remove_static_jsimd_encode_mcu_AC_refine_prepare_def_void.F;
P << remove_static_jsimd_encode_mcu_AC_refine_prepare_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_jsimd_encode_mcu_AC_refine_prepare_decl@
type T;
identifier F = jsimd_encode_mcu_AC_refine_prepare;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_jsimd_encode_mcu_AC_refine_prepare_decl@
F << remove_static_jsimd_encode_mcu_AC_refine_prepare_decl.F;
T << remove_static_jsimd_encode_mcu_AC_refine_prepare_decl.T;
P << remove_static_jsimd_encode_mcu_AC_refine_prepare_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_jsimd_encode_mcu_AC_refine_prepare_decl_void@
identifier F = jsimd_encode_mcu_AC_refine_prepare;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_jsimd_encode_mcu_AC_refine_prepare_decl_void@
F << remove_static_jsimd_encode_mcu_AC_refine_prepare_decl_void.F;
P << remove_static_jsimd_encode_mcu_AC_refine_prepare_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_jsimd_encode_mcu_AC_refine_prepare_def@
type T;
identifier F = jsimd_encode_mcu_AC_refine_prepare;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_jsimd_encode_mcu_AC_refine_prepare_def@
F << extract_jsimd_encode_mcu_AC_refine_prepare_def.F;
T << extract_jsimd_encode_mcu_AC_refine_prepare_def.T;
P << extract_jsimd_encode_mcu_AC_refine_prepare_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_jsimd_encode_mcu_AC_refine_prepare_def_void@
identifier F = jsimd_encode_mcu_AC_refine_prepare;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_jsimd_encode_mcu_AC_refine_prepare_def_void@
F << extract_jsimd_encode_mcu_AC_refine_prepare_def_void.F;
P << extract_jsimd_encode_mcu_AC_refine_prepare_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_jsimd_encode_mcu_AC_refine_prepare_decl@
type T;
identifier F = jsimd_encode_mcu_AC_refine_prepare;
parameter list P;
@@
T F(P);

@script:python depends on extract_jsimd_encode_mcu_AC_refine_prepare_decl@
F << extract_jsimd_encode_mcu_AC_refine_prepare_decl.F;
T << extract_jsimd_encode_mcu_AC_refine_prepare_decl.T;
P << extract_jsimd_encode_mcu_AC_refine_prepare_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_jsimd_encode_mcu_AC_refine_prepare_decl_void@
identifier F = jsimd_encode_mcu_AC_refine_prepare;
parameter list P;
@@
void F(P);

@script:python depends on extract_jsimd_encode_mcu_AC_refine_prepare_decl_void@
F << extract_jsimd_encode_mcu_AC_refine_prepare_decl_void.F;
P << extract_jsimd_encode_mcu_AC_refine_prepare_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: jsimd_fdct_ifast
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_jsimd_fdct_ifast_def@
type T;
identifier F = jsimd_fdct_ifast;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_jsimd_fdct_ifast_def@
F << remove_static_jsimd_fdct_ifast_def.F;
T << remove_static_jsimd_fdct_ifast_def.T;
P << remove_static_jsimd_fdct_ifast_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_jsimd_fdct_ifast_def_void@
identifier F = jsimd_fdct_ifast;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_jsimd_fdct_ifast_def_void@
F << remove_static_jsimd_fdct_ifast_def_void.F;
P << remove_static_jsimd_fdct_ifast_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_jsimd_fdct_ifast_decl@
type T;
identifier F = jsimd_fdct_ifast;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_jsimd_fdct_ifast_decl@
F << remove_static_jsimd_fdct_ifast_decl.F;
T << remove_static_jsimd_fdct_ifast_decl.T;
P << remove_static_jsimd_fdct_ifast_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_jsimd_fdct_ifast_decl_void@
identifier F = jsimd_fdct_ifast;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_jsimd_fdct_ifast_decl_void@
F << remove_static_jsimd_fdct_ifast_decl_void.F;
P << remove_static_jsimd_fdct_ifast_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_jsimd_fdct_ifast_def@
type T;
identifier F = jsimd_fdct_ifast;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_jsimd_fdct_ifast_def@
F << extract_jsimd_fdct_ifast_def.F;
T << extract_jsimd_fdct_ifast_def.T;
P << extract_jsimd_fdct_ifast_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_jsimd_fdct_ifast_def_void@
identifier F = jsimd_fdct_ifast;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_jsimd_fdct_ifast_def_void@
F << extract_jsimd_fdct_ifast_def_void.F;
P << extract_jsimd_fdct_ifast_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_jsimd_fdct_ifast_decl@
type T;
identifier F = jsimd_fdct_ifast;
parameter list P;
@@
T F(P);

@script:python depends on extract_jsimd_fdct_ifast_decl@
F << extract_jsimd_fdct_ifast_decl.F;
T << extract_jsimd_fdct_ifast_decl.T;
P << extract_jsimd_fdct_ifast_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_jsimd_fdct_ifast_decl_void@
identifier F = jsimd_fdct_ifast;
parameter list P;
@@
void F(P);

@script:python depends on extract_jsimd_fdct_ifast_decl_void@
F << extract_jsimd_fdct_ifast_decl_void.F;
P << extract_jsimd_fdct_ifast_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: jsimd_fdct_islow
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_jsimd_fdct_islow_def@
type T;
identifier F = jsimd_fdct_islow;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_jsimd_fdct_islow_def@
F << remove_static_jsimd_fdct_islow_def.F;
T << remove_static_jsimd_fdct_islow_def.T;
P << remove_static_jsimd_fdct_islow_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_jsimd_fdct_islow_def_void@
identifier F = jsimd_fdct_islow;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_jsimd_fdct_islow_def_void@
F << remove_static_jsimd_fdct_islow_def_void.F;
P << remove_static_jsimd_fdct_islow_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_jsimd_fdct_islow_decl@
type T;
identifier F = jsimd_fdct_islow;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_jsimd_fdct_islow_decl@
F << remove_static_jsimd_fdct_islow_decl.F;
T << remove_static_jsimd_fdct_islow_decl.T;
P << remove_static_jsimd_fdct_islow_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_jsimd_fdct_islow_decl_void@
identifier F = jsimd_fdct_islow;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_jsimd_fdct_islow_decl_void@
F << remove_static_jsimd_fdct_islow_decl_void.F;
P << remove_static_jsimd_fdct_islow_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_jsimd_fdct_islow_def@
type T;
identifier F = jsimd_fdct_islow;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_jsimd_fdct_islow_def@
F << extract_jsimd_fdct_islow_def.F;
T << extract_jsimd_fdct_islow_def.T;
P << extract_jsimd_fdct_islow_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_jsimd_fdct_islow_def_void@
identifier F = jsimd_fdct_islow;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_jsimd_fdct_islow_def_void@
F << extract_jsimd_fdct_islow_def_void.F;
P << extract_jsimd_fdct_islow_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_jsimd_fdct_islow_decl@
type T;
identifier F = jsimd_fdct_islow;
parameter list P;
@@
T F(P);

@script:python depends on extract_jsimd_fdct_islow_decl@
F << extract_jsimd_fdct_islow_decl.F;
T << extract_jsimd_fdct_islow_decl.T;
P << extract_jsimd_fdct_islow_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_jsimd_fdct_islow_decl_void@
identifier F = jsimd_fdct_islow;
parameter list P;
@@
void F(P);

@script:python depends on extract_jsimd_fdct_islow_decl_void@
F << extract_jsimd_fdct_islow_decl_void.F;
P << extract_jsimd_fdct_islow_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: jsimd_h2v1_merged_upsample
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_jsimd_h2v1_merged_upsample_def@
type T;
identifier F = jsimd_h2v1_merged_upsample;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_jsimd_h2v1_merged_upsample_def@
F << remove_static_jsimd_h2v1_merged_upsample_def.F;
T << remove_static_jsimd_h2v1_merged_upsample_def.T;
P << remove_static_jsimd_h2v1_merged_upsample_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_jsimd_h2v1_merged_upsample_def_void@
identifier F = jsimd_h2v1_merged_upsample;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_jsimd_h2v1_merged_upsample_def_void@
F << remove_static_jsimd_h2v1_merged_upsample_def_void.F;
P << remove_static_jsimd_h2v1_merged_upsample_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_jsimd_h2v1_merged_upsample_decl@
type T;
identifier F = jsimd_h2v1_merged_upsample;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_jsimd_h2v1_merged_upsample_decl@
F << remove_static_jsimd_h2v1_merged_upsample_decl.F;
T << remove_static_jsimd_h2v1_merged_upsample_decl.T;
P << remove_static_jsimd_h2v1_merged_upsample_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_jsimd_h2v1_merged_upsample_decl_void@
identifier F = jsimd_h2v1_merged_upsample;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_jsimd_h2v1_merged_upsample_decl_void@
F << remove_static_jsimd_h2v1_merged_upsample_decl_void.F;
P << remove_static_jsimd_h2v1_merged_upsample_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_jsimd_h2v1_merged_upsample_def@
type T;
identifier F = jsimd_h2v1_merged_upsample;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_jsimd_h2v1_merged_upsample_def@
F << extract_jsimd_h2v1_merged_upsample_def.F;
T << extract_jsimd_h2v1_merged_upsample_def.T;
P << extract_jsimd_h2v1_merged_upsample_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_jsimd_h2v1_merged_upsample_def_void@
identifier F = jsimd_h2v1_merged_upsample;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_jsimd_h2v1_merged_upsample_def_void@
F << extract_jsimd_h2v1_merged_upsample_def_void.F;
P << extract_jsimd_h2v1_merged_upsample_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_jsimd_h2v1_merged_upsample_decl@
type T;
identifier F = jsimd_h2v1_merged_upsample;
parameter list P;
@@
T F(P);

@script:python depends on extract_jsimd_h2v1_merged_upsample_decl@
F << extract_jsimd_h2v1_merged_upsample_decl.F;
T << extract_jsimd_h2v1_merged_upsample_decl.T;
P << extract_jsimd_h2v1_merged_upsample_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_jsimd_h2v1_merged_upsample_decl_void@
identifier F = jsimd_h2v1_merged_upsample;
parameter list P;
@@
void F(P);

@script:python depends on extract_jsimd_h2v1_merged_upsample_decl_void@
F << extract_jsimd_h2v1_merged_upsample_decl_void.F;
P << extract_jsimd_h2v1_merged_upsample_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: jsimd_h2v2_merged_upsample
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_jsimd_h2v2_merged_upsample_def@
type T;
identifier F = jsimd_h2v2_merged_upsample;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_jsimd_h2v2_merged_upsample_def@
F << remove_static_jsimd_h2v2_merged_upsample_def.F;
T << remove_static_jsimd_h2v2_merged_upsample_def.T;
P << remove_static_jsimd_h2v2_merged_upsample_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_jsimd_h2v2_merged_upsample_def_void@
identifier F = jsimd_h2v2_merged_upsample;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_jsimd_h2v2_merged_upsample_def_void@
F << remove_static_jsimd_h2v2_merged_upsample_def_void.F;
P << remove_static_jsimd_h2v2_merged_upsample_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_jsimd_h2v2_merged_upsample_decl@
type T;
identifier F = jsimd_h2v2_merged_upsample;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_jsimd_h2v2_merged_upsample_decl@
F << remove_static_jsimd_h2v2_merged_upsample_decl.F;
T << remove_static_jsimd_h2v2_merged_upsample_decl.T;
P << remove_static_jsimd_h2v2_merged_upsample_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_jsimd_h2v2_merged_upsample_decl_void@
identifier F = jsimd_h2v2_merged_upsample;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_jsimd_h2v2_merged_upsample_decl_void@
F << remove_static_jsimd_h2v2_merged_upsample_decl_void.F;
P << remove_static_jsimd_h2v2_merged_upsample_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_jsimd_h2v2_merged_upsample_def@
type T;
identifier F = jsimd_h2v2_merged_upsample;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_jsimd_h2v2_merged_upsample_def@
F << extract_jsimd_h2v2_merged_upsample_def.F;
T << extract_jsimd_h2v2_merged_upsample_def.T;
P << extract_jsimd_h2v2_merged_upsample_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_jsimd_h2v2_merged_upsample_def_void@
identifier F = jsimd_h2v2_merged_upsample;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_jsimd_h2v2_merged_upsample_def_void@
F << extract_jsimd_h2v2_merged_upsample_def_void.F;
P << extract_jsimd_h2v2_merged_upsample_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_jsimd_h2v2_merged_upsample_decl@
type T;
identifier F = jsimd_h2v2_merged_upsample;
parameter list P;
@@
T F(P);

@script:python depends on extract_jsimd_h2v2_merged_upsample_decl@
F << extract_jsimd_h2v2_merged_upsample_decl.F;
T << extract_jsimd_h2v2_merged_upsample_decl.T;
P << extract_jsimd_h2v2_merged_upsample_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_jsimd_h2v2_merged_upsample_decl_void@
identifier F = jsimd_h2v2_merged_upsample;
parameter list P;
@@
void F(P);

@script:python depends on extract_jsimd_h2v2_merged_upsample_decl_void@
F << extract_jsimd_h2v2_merged_upsample_decl_void.F;
P << extract_jsimd_h2v2_merged_upsample_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: jsimd_quantize
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_jsimd_quantize_def@
type T;
identifier F = jsimd_quantize;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_jsimd_quantize_def@
F << remove_static_jsimd_quantize_def.F;
T << remove_static_jsimd_quantize_def.T;
P << remove_static_jsimd_quantize_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_jsimd_quantize_def_void@
identifier F = jsimd_quantize;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_jsimd_quantize_def_void@
F << remove_static_jsimd_quantize_def_void.F;
P << remove_static_jsimd_quantize_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_jsimd_quantize_decl@
type T;
identifier F = jsimd_quantize;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_jsimd_quantize_decl@
F << remove_static_jsimd_quantize_decl.F;
T << remove_static_jsimd_quantize_decl.T;
P << remove_static_jsimd_quantize_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_jsimd_quantize_decl_void@
identifier F = jsimd_quantize;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_jsimd_quantize_decl_void@
F << remove_static_jsimd_quantize_decl_void.F;
P << remove_static_jsimd_quantize_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_jsimd_quantize_def@
type T;
identifier F = jsimd_quantize;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_jsimd_quantize_def@
F << extract_jsimd_quantize_def.F;
T << extract_jsimd_quantize_def.T;
P << extract_jsimd_quantize_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_jsimd_quantize_def_void@
identifier F = jsimd_quantize;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_jsimd_quantize_def_void@
F << extract_jsimd_quantize_def_void.F;
P << extract_jsimd_quantize_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_jsimd_quantize_decl@
type T;
identifier F = jsimd_quantize;
parameter list P;
@@
T F(P);

@script:python depends on extract_jsimd_quantize_decl@
F << extract_jsimd_quantize_decl.F;
T << extract_jsimd_quantize_decl.T;
P << extract_jsimd_quantize_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_jsimd_quantize_decl_void@
identifier F = jsimd_quantize;
parameter list P;
@@
void F(P);

@script:python depends on extract_jsimd_quantize_decl_void@
F << extract_jsimd_quantize_decl_void.F;
P << extract_jsimd_quantize_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: jsimd_quantize_float
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_jsimd_quantize_float_def@
type T;
identifier F = jsimd_quantize_float;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_jsimd_quantize_float_def@
F << remove_static_jsimd_quantize_float_def.F;
T << remove_static_jsimd_quantize_float_def.T;
P << remove_static_jsimd_quantize_float_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_jsimd_quantize_float_def_void@
identifier F = jsimd_quantize_float;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_jsimd_quantize_float_def_void@
F << remove_static_jsimd_quantize_float_def_void.F;
P << remove_static_jsimd_quantize_float_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_jsimd_quantize_float_decl@
type T;
identifier F = jsimd_quantize_float;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_jsimd_quantize_float_decl@
F << remove_static_jsimd_quantize_float_decl.F;
T << remove_static_jsimd_quantize_float_decl.T;
P << remove_static_jsimd_quantize_float_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_jsimd_quantize_float_decl_void@
identifier F = jsimd_quantize_float;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_jsimd_quantize_float_decl_void@
F << remove_static_jsimd_quantize_float_decl_void.F;
P << remove_static_jsimd_quantize_float_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_jsimd_quantize_float_def@
type T;
identifier F = jsimd_quantize_float;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_jsimd_quantize_float_def@
F << extract_jsimd_quantize_float_def.F;
T << extract_jsimd_quantize_float_def.T;
P << extract_jsimd_quantize_float_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_jsimd_quantize_float_def_void@
identifier F = jsimd_quantize_float;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_jsimd_quantize_float_def_void@
F << extract_jsimd_quantize_float_def_void.F;
P << extract_jsimd_quantize_float_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_jsimd_quantize_float_decl@
type T;
identifier F = jsimd_quantize_float;
parameter list P;
@@
T F(P);

@script:python depends on extract_jsimd_quantize_float_decl@
F << extract_jsimd_quantize_float_decl.F;
T << extract_jsimd_quantize_float_decl.T;
P << extract_jsimd_quantize_float_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_jsimd_quantize_float_decl_void@
identifier F = jsimd_quantize_float;
parameter list P;
@@
void F(P);

@script:python depends on extract_jsimd_quantize_float_decl_void@
F << extract_jsimd_quantize_float_decl_void.F;
P << extract_jsimd_quantize_float_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: load_interlaced_image
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_load_interlaced_image_def@
type T;
identifier F = load_interlaced_image;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_load_interlaced_image_def@
F << remove_static_load_interlaced_image_def.F;
T << remove_static_load_interlaced_image_def.T;
P << remove_static_load_interlaced_image_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_load_interlaced_image_def_void@
identifier F = load_interlaced_image;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_load_interlaced_image_def_void@
F << remove_static_load_interlaced_image_def_void.F;
P << remove_static_load_interlaced_image_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_load_interlaced_image_decl@
type T;
identifier F = load_interlaced_image;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_load_interlaced_image_decl@
F << remove_static_load_interlaced_image_decl.F;
T << remove_static_load_interlaced_image_decl.T;
P << remove_static_load_interlaced_image_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_load_interlaced_image_decl_void@
identifier F = load_interlaced_image;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_load_interlaced_image_decl_void@
F << remove_static_load_interlaced_image_decl_void.F;
P << remove_static_load_interlaced_image_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_load_interlaced_image_def@
type T;
identifier F = load_interlaced_image;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_load_interlaced_image_def@
F << extract_load_interlaced_image_def.F;
T << extract_load_interlaced_image_def.T;
P << extract_load_interlaced_image_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_load_interlaced_image_def_void@
identifier F = load_interlaced_image;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_load_interlaced_image_def_void@
F << extract_load_interlaced_image_def_void.F;
P << extract_load_interlaced_image_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_load_interlaced_image_decl@
type T;
identifier F = load_interlaced_image;
parameter list P;
@@
T F(P);

@script:python depends on extract_load_interlaced_image_decl@
F << extract_load_interlaced_image_decl.F;
T << extract_load_interlaced_image_decl.T;
P << extract_load_interlaced_image_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_load_interlaced_image_decl_void@
identifier F = load_interlaced_image;
parameter list P;
@@
void F(P);

@script:python depends on extract_load_interlaced_image_decl_void@
F << extract_load_interlaced_image_decl_void.F;
P << extract_load_interlaced_image_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: my_emit_message
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_my_emit_message_def@
type T;
identifier F = my_emit_message;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_my_emit_message_def@
F << remove_static_my_emit_message_def.F;
T << remove_static_my_emit_message_def.T;
P << remove_static_my_emit_message_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_my_emit_message_def_void@
identifier F = my_emit_message;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_my_emit_message_def_void@
F << remove_static_my_emit_message_def_void.F;
P << remove_static_my_emit_message_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_my_emit_message_decl@
type T;
identifier F = my_emit_message;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_my_emit_message_decl@
F << remove_static_my_emit_message_decl.F;
T << remove_static_my_emit_message_decl.T;
P << remove_static_my_emit_message_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_my_emit_message_decl_void@
identifier F = my_emit_message;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_my_emit_message_decl_void@
F << remove_static_my_emit_message_decl_void.F;
P << remove_static_my_emit_message_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_my_emit_message_def@
type T;
identifier F = my_emit_message;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_my_emit_message_def@
F << extract_my_emit_message_def.F;
T << extract_my_emit_message_def.T;
P << extract_my_emit_message_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_my_emit_message_def_void@
identifier F = my_emit_message;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_my_emit_message_def_void@
F << extract_my_emit_message_def_void.F;
P << extract_my_emit_message_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_my_emit_message_decl@
type T;
identifier F = my_emit_message;
parameter list P;
@@
T F(P);

@script:python depends on extract_my_emit_message_decl@
F << extract_my_emit_message_decl.F;
T << extract_my_emit_message_decl.T;
P << extract_my_emit_message_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_my_emit_message_decl_void@
identifier F = my_emit_message;
parameter list P;
@@
void F(P);

@script:python depends on extract_my_emit_message_decl_void@
F << extract_my_emit_message_decl_void.F;
P << extract_my_emit_message_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: my_error_exit
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_my_error_exit_def@
type T;
identifier F = my_error_exit;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_my_error_exit_def@
F << remove_static_my_error_exit_def.F;
T << remove_static_my_error_exit_def.T;
P << remove_static_my_error_exit_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_my_error_exit_def_void@
identifier F = my_error_exit;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_my_error_exit_def_void@
F << remove_static_my_error_exit_def_void.F;
P << remove_static_my_error_exit_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_my_error_exit_decl@
type T;
identifier F = my_error_exit;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_my_error_exit_decl@
F << remove_static_my_error_exit_decl.F;
T << remove_static_my_error_exit_decl.T;
P << remove_static_my_error_exit_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_my_error_exit_decl_void@
identifier F = my_error_exit;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_my_error_exit_decl_void@
F << remove_static_my_error_exit_decl_void.F;
P << remove_static_my_error_exit_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_my_error_exit_def@
type T;
identifier F = my_error_exit;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_my_error_exit_def@
F << extract_my_error_exit_def.F;
T << extract_my_error_exit_def.T;
P << extract_my_error_exit_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_my_error_exit_def_void@
identifier F = my_error_exit;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_my_error_exit_def_void@
F << extract_my_error_exit_def_void.F;
P << extract_my_error_exit_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_my_error_exit_decl@
type T;
identifier F = my_error_exit;
parameter list P;
@@
T F(P);

@script:python depends on extract_my_error_exit_decl@
F << extract_my_error_exit_decl.F;
T << extract_my_error_exit_decl.T;
P << extract_my_error_exit_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_my_error_exit_decl_void@
identifier F = my_error_exit;
parameter list P;
@@
void F(P);

@script:python depends on extract_my_error_exit_decl_void@
F << extract_my_error_exit_decl_void.F;
P << extract_my_error_exit_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: my_output_message
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_my_output_message_def@
type T;
identifier F = my_output_message;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_my_output_message_def@
F << remove_static_my_output_message_def.F;
T << remove_static_my_output_message_def.T;
P << remove_static_my_output_message_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_my_output_message_def_void@
identifier F = my_output_message;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_my_output_message_def_void@
F << remove_static_my_output_message_def_void.F;
P << remove_static_my_output_message_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_my_output_message_decl@
type T;
identifier F = my_output_message;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_my_output_message_decl@
F << remove_static_my_output_message_decl.F;
T << remove_static_my_output_message_decl.T;
P << remove_static_my_output_message_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_my_output_message_decl_void@
identifier F = my_output_message;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_my_output_message_decl_void@
F << remove_static_my_output_message_decl_void.F;
P << remove_static_my_output_message_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_my_output_message_def@
type T;
identifier F = my_output_message;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_my_output_message_def@
F << extract_my_output_message_def.F;
T << extract_my_output_message_def.T;
P << extract_my_output_message_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_my_output_message_def_void@
identifier F = my_output_message;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_my_output_message_def_void@
F << extract_my_output_message_def_void.F;
P << extract_my_output_message_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_my_output_message_decl@
type T;
identifier F = my_output_message;
parameter list P;
@@
T F(P);

@script:python depends on extract_my_output_message_decl@
F << extract_my_output_message_decl.F;
T << extract_my_output_message_decl.T;
P << extract_my_output_message_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_my_output_message_decl_void@
identifier F = my_output_message;
parameter list P;
@@
void F(P);

@script:python depends on extract_my_output_message_decl_void@
F << extract_my_output_message_decl_void.F;
P << extract_my_output_message_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: my_progress_monitor
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_my_progress_monitor_def@
type T;
identifier F = my_progress_monitor;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_my_progress_monitor_def@
F << remove_static_my_progress_monitor_def.F;
T << remove_static_my_progress_monitor_def.T;
P << remove_static_my_progress_monitor_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_my_progress_monitor_def_void@
identifier F = my_progress_monitor;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_my_progress_monitor_def_void@
F << remove_static_my_progress_monitor_def_void.F;
P << remove_static_my_progress_monitor_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_my_progress_monitor_decl@
type T;
identifier F = my_progress_monitor;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_my_progress_monitor_decl@
F << remove_static_my_progress_monitor_decl.F;
T << remove_static_my_progress_monitor_decl.T;
P << remove_static_my_progress_monitor_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_my_progress_monitor_decl_void@
identifier F = my_progress_monitor;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_my_progress_monitor_decl_void@
F << remove_static_my_progress_monitor_decl_void.F;
P << remove_static_my_progress_monitor_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_my_progress_monitor_def@
type T;
identifier F = my_progress_monitor;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_my_progress_monitor_def@
F << extract_my_progress_monitor_def.F;
T << extract_my_progress_monitor_def.T;
P << extract_my_progress_monitor_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_my_progress_monitor_def_void@
identifier F = my_progress_monitor;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_my_progress_monitor_def_void@
F << extract_my_progress_monitor_def_void.F;
P << extract_my_progress_monitor_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_my_progress_monitor_decl@
type T;
identifier F = my_progress_monitor;
parameter list P;
@@
T F(P);

@script:python depends on extract_my_progress_monitor_decl@
F << extract_my_progress_monitor_decl.F;
T << extract_my_progress_monitor_decl.T;
P << extract_my_progress_monitor_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_my_progress_monitor_decl_void@
identifier F = my_progress_monitor;
parameter list P;
@@
void F(P);

@script:python depends on extract_my_progress_monitor_decl_void@
F << extract_my_progress_monitor_decl_void.F;
P << extract_my_progress_monitor_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: my_read_markers
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_my_read_markers_def@
type T;
identifier F = my_read_markers;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_my_read_markers_def@
F << remove_static_my_read_markers_def.F;
T << remove_static_my_read_markers_def.T;
P << remove_static_my_read_markers_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_my_read_markers_def_void@
identifier F = my_read_markers;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_my_read_markers_def_void@
F << remove_static_my_read_markers_def_void.F;
P << remove_static_my_read_markers_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_my_read_markers_decl@
type T;
identifier F = my_read_markers;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_my_read_markers_decl@
F << remove_static_my_read_markers_decl.F;
T << remove_static_my_read_markers_decl.T;
P << remove_static_my_read_markers_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_my_read_markers_decl_void@
identifier F = my_read_markers;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_my_read_markers_decl_void@
F << remove_static_my_read_markers_decl_void.F;
P << remove_static_my_read_markers_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_my_read_markers_def@
type T;
identifier F = my_read_markers;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_my_read_markers_def@
F << extract_my_read_markers_def.F;
T << extract_my_read_markers_def.T;
P << extract_my_read_markers_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_my_read_markers_def_void@
identifier F = my_read_markers;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_my_read_markers_def_void@
F << extract_my_read_markers_def_void.F;
P << extract_my_read_markers_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_my_read_markers_decl@
type T;
identifier F = my_read_markers;
parameter list P;
@@
T F(P);

@script:python depends on extract_my_read_markers_decl@
F << extract_my_read_markers_decl.F;
T << extract_my_read_markers_decl.T;
P << extract_my_read_markers_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_my_read_markers_decl_void@
identifier F = my_read_markers;
parameter list P;
@@
void F(P);

@script:python depends on extract_my_read_markers_decl_void@
F << extract_my_read_markers_decl_void.F;
P << extract_my_read_markers_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: my_reset_marker_reader
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_my_reset_marker_reader_def@
type T;
identifier F = my_reset_marker_reader;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_my_reset_marker_reader_def@
F << remove_static_my_reset_marker_reader_def.F;
T << remove_static_my_reset_marker_reader_def.T;
P << remove_static_my_reset_marker_reader_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_my_reset_marker_reader_def_void@
identifier F = my_reset_marker_reader;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_my_reset_marker_reader_def_void@
F << remove_static_my_reset_marker_reader_def_void.F;
P << remove_static_my_reset_marker_reader_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_my_reset_marker_reader_decl@
type T;
identifier F = my_reset_marker_reader;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_my_reset_marker_reader_decl@
F << remove_static_my_reset_marker_reader_decl.F;
T << remove_static_my_reset_marker_reader_decl.T;
P << remove_static_my_reset_marker_reader_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_my_reset_marker_reader_decl_void@
identifier F = my_reset_marker_reader;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_my_reset_marker_reader_decl_void@
F << remove_static_my_reset_marker_reader_decl_void.F;
P << remove_static_my_reset_marker_reader_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_my_reset_marker_reader_def@
type T;
identifier F = my_reset_marker_reader;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_my_reset_marker_reader_def@
F << extract_my_reset_marker_reader_def.F;
T << extract_my_reset_marker_reader_def.T;
P << extract_my_reset_marker_reader_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_my_reset_marker_reader_def_void@
identifier F = my_reset_marker_reader;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_my_reset_marker_reader_def_void@
F << extract_my_reset_marker_reader_def_void.F;
P << extract_my_reset_marker_reader_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_my_reset_marker_reader_decl@
type T;
identifier F = my_reset_marker_reader;
parameter list P;
@@
T F(P);

@script:python depends on extract_my_reset_marker_reader_decl@
F << extract_my_reset_marker_reader_decl.F;
T << extract_my_reset_marker_reader_decl.T;
P << extract_my_reset_marker_reader_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_my_reset_marker_reader_decl_void@
identifier F = my_reset_marker_reader;
parameter list P;
@@
void F(P);

@script:python depends on extract_my_reset_marker_reader_decl_void@
F << extract_my_reset_marker_reader_decl_void.F;
P << extract_my_reset_marker_reader_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: new_color_map_1_quant
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_new_color_map_1_quant_def@
type T;
identifier F = new_color_map_1_quant;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_new_color_map_1_quant_def@
F << remove_static_new_color_map_1_quant_def.F;
T << remove_static_new_color_map_1_quant_def.T;
P << remove_static_new_color_map_1_quant_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_new_color_map_1_quant_def_void@
identifier F = new_color_map_1_quant;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_new_color_map_1_quant_def_void@
F << remove_static_new_color_map_1_quant_def_void.F;
P << remove_static_new_color_map_1_quant_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_new_color_map_1_quant_decl@
type T;
identifier F = new_color_map_1_quant;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_new_color_map_1_quant_decl@
F << remove_static_new_color_map_1_quant_decl.F;
T << remove_static_new_color_map_1_quant_decl.T;
P << remove_static_new_color_map_1_quant_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_new_color_map_1_quant_decl_void@
identifier F = new_color_map_1_quant;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_new_color_map_1_quant_decl_void@
F << remove_static_new_color_map_1_quant_decl_void.F;
P << remove_static_new_color_map_1_quant_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_new_color_map_1_quant_def@
type T;
identifier F = new_color_map_1_quant;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_new_color_map_1_quant_def@
F << extract_new_color_map_1_quant_def.F;
T << extract_new_color_map_1_quant_def.T;
P << extract_new_color_map_1_quant_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_new_color_map_1_quant_def_void@
identifier F = new_color_map_1_quant;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_new_color_map_1_quant_def_void@
F << extract_new_color_map_1_quant_def_void.F;
P << extract_new_color_map_1_quant_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_new_color_map_1_quant_decl@
type T;
identifier F = new_color_map_1_quant;
parameter list P;
@@
T F(P);

@script:python depends on extract_new_color_map_1_quant_decl@
F << extract_new_color_map_1_quant_decl.F;
T << extract_new_color_map_1_quant_decl.T;
P << extract_new_color_map_1_quant_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_new_color_map_1_quant_decl_void@
identifier F = new_color_map_1_quant;
parameter list P;
@@
void F(P);

@script:python depends on extract_new_color_map_1_quant_decl_void@
F << extract_new_color_map_1_quant_decl_void.F;
P << extract_new_color_map_1_quant_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: new_color_map_2_quant
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_new_color_map_2_quant_def@
type T;
identifier F = new_color_map_2_quant;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_new_color_map_2_quant_def@
F << remove_static_new_color_map_2_quant_def.F;
T << remove_static_new_color_map_2_quant_def.T;
P << remove_static_new_color_map_2_quant_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_new_color_map_2_quant_def_void@
identifier F = new_color_map_2_quant;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_new_color_map_2_quant_def_void@
F << remove_static_new_color_map_2_quant_def_void.F;
P << remove_static_new_color_map_2_quant_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_new_color_map_2_quant_decl@
type T;
identifier F = new_color_map_2_quant;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_new_color_map_2_quant_decl@
F << remove_static_new_color_map_2_quant_decl.F;
T << remove_static_new_color_map_2_quant_decl.T;
P << remove_static_new_color_map_2_quant_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_new_color_map_2_quant_decl_void@
identifier F = new_color_map_2_quant;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_new_color_map_2_quant_decl_void@
F << remove_static_new_color_map_2_quant_decl_void.F;
P << remove_static_new_color_map_2_quant_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_new_color_map_2_quant_def@
type T;
identifier F = new_color_map_2_quant;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_new_color_map_2_quant_def@
F << extract_new_color_map_2_quant_def.F;
T << extract_new_color_map_2_quant_def.T;
P << extract_new_color_map_2_quant_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_new_color_map_2_quant_def_void@
identifier F = new_color_map_2_quant;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_new_color_map_2_quant_def_void@
F << extract_new_color_map_2_quant_def_void.F;
P << extract_new_color_map_2_quant_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_new_color_map_2_quant_decl@
type T;
identifier F = new_color_map_2_quant;
parameter list P;
@@
T F(P);

@script:python depends on extract_new_color_map_2_quant_decl@
F << extract_new_color_map_2_quant_decl.F;
T << extract_new_color_map_2_quant_decl.T;
P << extract_new_color_map_2_quant_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_new_color_map_2_quant_decl_void@
identifier F = new_color_map_2_quant;
parameter list P;
@@
void F(P);

@script:python depends on extract_new_color_map_2_quant_decl_void@
F << extract_new_color_map_2_quant_decl_void.F;
P << extract_new_color_map_2_quant_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: noscale
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_noscale_def@
type T;
identifier F = noscale;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_noscale_def@
F << remove_static_noscale_def.F;
T << remove_static_noscale_def.T;
P << remove_static_noscale_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_noscale_def_void@
identifier F = noscale;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_noscale_def_void@
F << remove_static_noscale_def_void.F;
P << remove_static_noscale_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_noscale_decl@
type T;
identifier F = noscale;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_noscale_decl@
F << remove_static_noscale_decl.F;
T << remove_static_noscale_decl.T;
P << remove_static_noscale_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_noscale_decl_void@
identifier F = noscale;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_noscale_decl_void@
F << remove_static_noscale_decl_void.F;
P << remove_static_noscale_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_noscale_def@
type T;
identifier F = noscale;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_noscale_def@
F << extract_noscale_def.F;
T << extract_noscale_def.T;
P << extract_noscale_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_noscale_def_void@
identifier F = noscale;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_noscale_def_void@
F << extract_noscale_def_void.F;
P << extract_noscale_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_noscale_decl@
type T;
identifier F = noscale;
parameter list P;
@@
T F(P);

@script:python depends on extract_noscale_decl@
F << extract_noscale_decl.F;
T << extract_noscale_decl.T;
P << extract_noscale_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_noscale_decl_void@
identifier F = noscale;
parameter list P;
@@
void F(P);

@script:python depends on extract_noscale_decl_void@
F << extract_noscale_decl_void.F;
P << extract_noscale_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: null_method
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_null_method_def@
type T;
identifier F = null_method;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_null_method_def@
F << remove_static_null_method_def.F;
T << remove_static_null_method_def.T;
P << remove_static_null_method_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_null_method_def_void@
identifier F = null_method;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_null_method_def_void@
F << remove_static_null_method_def_void.F;
P << remove_static_null_method_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_null_method_decl@
type T;
identifier F = null_method;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_null_method_decl@
F << remove_static_null_method_decl.F;
T << remove_static_null_method_decl.T;
P << remove_static_null_method_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_null_method_decl_void@
identifier F = null_method;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_null_method_decl_void@
F << remove_static_null_method_decl_void.F;
P << remove_static_null_method_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_null_method_def@
type T;
identifier F = null_method;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_null_method_def@
F << extract_null_method_def.F;
T << extract_null_method_def.T;
P << extract_null_method_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_null_method_def_void@
identifier F = null_method;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_null_method_def_void@
F << extract_null_method_def_void.F;
P << extract_null_method_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_null_method_decl@
type T;
identifier F = null_method;
parameter list P;
@@
T F(P);

@script:python depends on extract_null_method_decl@
F << extract_null_method_decl.F;
T << extract_null_method_decl.T;
P << extract_null_method_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_null_method_decl_void@
identifier F = null_method;
parameter list P;
@@
void F(P);

@script:python depends on extract_null_method_decl_void@
F << extract_null_method_decl_void.F;
P << extract_null_method_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: old_read_markers
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_old_read_markers_def@
type T;
identifier F = old_read_markers;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_old_read_markers_def@
F << remove_static_old_read_markers_def.F;
T << remove_static_old_read_markers_def.T;
P << remove_static_old_read_markers_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_old_read_markers_def_void@
identifier F = old_read_markers;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_old_read_markers_def_void@
F << remove_static_old_read_markers_def_void.F;
P << remove_static_old_read_markers_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_old_read_markers_decl@
type T;
identifier F = old_read_markers;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_old_read_markers_decl@
F << remove_static_old_read_markers_decl.F;
T << remove_static_old_read_markers_decl.T;
P << remove_static_old_read_markers_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_old_read_markers_decl_void@
identifier F = old_read_markers;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_old_read_markers_decl_void@
F << remove_static_old_read_markers_decl_void.F;
P << remove_static_old_read_markers_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_old_read_markers_def@
type T;
identifier F = old_read_markers;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_old_read_markers_def@
F << extract_old_read_markers_def.F;
T << extract_old_read_markers_def.T;
P << extract_old_read_markers_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_old_read_markers_def_void@
identifier F = old_read_markers;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_old_read_markers_def_void@
F << extract_old_read_markers_def_void.F;
P << extract_old_read_markers_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_old_read_markers_decl@
type T;
identifier F = old_read_markers;
parameter list P;
@@
T F(P);

@script:python depends on extract_old_read_markers_decl@
F << extract_old_read_markers_decl.F;
T << extract_old_read_markers_decl.T;
P << extract_old_read_markers_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_old_read_markers_decl_void@
identifier F = old_read_markers;
parameter list P;
@@
void F(P);

@script:python depends on extract_old_read_markers_decl_void@
F << extract_old_read_markers_decl_void.F;
P << extract_old_read_markers_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: old_reset_marker_reader
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_old_reset_marker_reader_def@
type T;
identifier F = old_reset_marker_reader;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_old_reset_marker_reader_def@
F << remove_static_old_reset_marker_reader_def.F;
T << remove_static_old_reset_marker_reader_def.T;
P << remove_static_old_reset_marker_reader_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_old_reset_marker_reader_def_void@
identifier F = old_reset_marker_reader;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_old_reset_marker_reader_def_void@
F << remove_static_old_reset_marker_reader_def_void.F;
P << remove_static_old_reset_marker_reader_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_old_reset_marker_reader_decl@
type T;
identifier F = old_reset_marker_reader;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_old_reset_marker_reader_decl@
F << remove_static_old_reset_marker_reader_decl.F;
T << remove_static_old_reset_marker_reader_decl.T;
P << remove_static_old_reset_marker_reader_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_old_reset_marker_reader_decl_void@
identifier F = old_reset_marker_reader;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_old_reset_marker_reader_decl_void@
F << remove_static_old_reset_marker_reader_decl_void.F;
P << remove_static_old_reset_marker_reader_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_old_reset_marker_reader_def@
type T;
identifier F = old_reset_marker_reader;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_old_reset_marker_reader_def@
F << extract_old_reset_marker_reader_def.F;
T << extract_old_reset_marker_reader_def.T;
P << extract_old_reset_marker_reader_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_old_reset_marker_reader_def_void@
identifier F = old_reset_marker_reader;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_old_reset_marker_reader_def_void@
F << extract_old_reset_marker_reader_def_void.F;
P << extract_old_reset_marker_reader_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_old_reset_marker_reader_decl@
type T;
identifier F = old_reset_marker_reader;
parameter list P;
@@
T F(P);

@script:python depends on extract_old_reset_marker_reader_decl@
F << extract_old_reset_marker_reader_decl.F;
T << extract_old_reset_marker_reader_decl.T;
P << extract_old_reset_marker_reader_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_old_reset_marker_reader_decl_void@
identifier F = old_reset_marker_reader;
parameter list P;
@@
void F(P);

@script:python depends on extract_old_reset_marker_reader_decl_void@
F << extract_old_reset_marker_reader_decl_void.F;
P << extract_old_reset_marker_reader_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: preload_image
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_preload_image_def@
type T;
identifier F = preload_image;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_preload_image_def@
F << remove_static_preload_image_def.F;
T << remove_static_preload_image_def.T;
P << remove_static_preload_image_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_preload_image_def_void@
identifier F = preload_image;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_preload_image_def_void@
F << remove_static_preload_image_def_void.F;
P << remove_static_preload_image_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_preload_image_decl@
type T;
identifier F = preload_image;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_preload_image_decl@
F << remove_static_preload_image_decl.F;
T << remove_static_preload_image_decl.T;
P << remove_static_preload_image_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_preload_image_decl_void@
identifier F = preload_image;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_preload_image_decl_void@
F << remove_static_preload_image_decl_void.F;
P << remove_static_preload_image_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_preload_image_def@
type T;
identifier F = preload_image;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_preload_image_def@
F << extract_preload_image_def.F;
T << extract_preload_image_def.T;
P << extract_preload_image_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_preload_image_def_void@
identifier F = preload_image;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_preload_image_def_void@
F << extract_preload_image_def_void.F;
P << extract_preload_image_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_preload_image_decl@
type T;
identifier F = preload_image;
parameter list P;
@@
T F(P);

@script:python depends on extract_preload_image_decl@
F << extract_preload_image_decl.F;
T << extract_preload_image_decl.T;
P << extract_preload_image_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_preload_image_decl_void@
identifier F = preload_image;
parameter list P;
@@
void F(P);

@script:python depends on extract_preload_image_decl_void@
F << extract_preload_image_decl_void.F;
P << extract_preload_image_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: print_text_marker
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_print_text_marker_def@
type T;
identifier F = print_text_marker;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_print_text_marker_def@
F << remove_static_print_text_marker_def.F;
T << remove_static_print_text_marker_def.T;
P << remove_static_print_text_marker_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_print_text_marker_def_void@
identifier F = print_text_marker;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_print_text_marker_def_void@
F << remove_static_print_text_marker_def_void.F;
P << remove_static_print_text_marker_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_print_text_marker_decl@
type T;
identifier F = print_text_marker;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_print_text_marker_decl@
F << remove_static_print_text_marker_decl.F;
T << remove_static_print_text_marker_decl.T;
P << remove_static_print_text_marker_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_print_text_marker_decl_void@
identifier F = print_text_marker;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_print_text_marker_decl_void@
F << remove_static_print_text_marker_decl_void.F;
P << remove_static_print_text_marker_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_print_text_marker_def@
type T;
identifier F = print_text_marker;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_print_text_marker_def@
F << extract_print_text_marker_def.F;
T << extract_print_text_marker_def.T;
P << extract_print_text_marker_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_print_text_marker_def_void@
identifier F = print_text_marker;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_print_text_marker_def_void@
F << extract_print_text_marker_def_void.F;
P << extract_print_text_marker_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_print_text_marker_decl@
type T;
identifier F = print_text_marker;
parameter list P;
@@
T F(P);

@script:python depends on extract_print_text_marker_decl@
F << extract_print_text_marker_decl.F;
T << extract_print_text_marker_decl.T;
P << extract_print_text_marker_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_print_text_marker_decl_void@
identifier F = print_text_marker;
parameter list P;
@@
void F(P);

@script:python depends on extract_print_text_marker_decl_void@
F << extract_print_text_marker_decl_void.F;
P << extract_print_text_marker_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: processor
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_processor_def@
type T;
identifier F = processor;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_processor_def@
F << remove_static_processor_def.F;
T << remove_static_processor_def.T;
P << remove_static_processor_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_processor_def_void@
identifier F = processor;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_processor_def_void@
F << remove_static_processor_def_void.F;
P << remove_static_processor_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_processor_decl@
type T;
identifier F = processor;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_processor_decl@
F << remove_static_processor_decl.F;
T << remove_static_processor_decl.T;
P << remove_static_processor_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_processor_decl_void@
identifier F = processor;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_processor_decl_void@
F << remove_static_processor_decl_void.F;
P << remove_static_processor_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_processor_def@
type T;
identifier F = processor;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_processor_def@
F << extract_processor_def.F;
T << extract_processor_def.T;
P << extract_processor_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_processor_def_void@
identifier F = processor;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_processor_def_void@
F << extract_processor_def_void.F;
P << extract_processor_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_processor_decl@
type T;
identifier F = processor;
parameter list P;
@@
T F(P);

@script:python depends on extract_processor_decl@
F << extract_processor_decl.F;
T << extract_processor_decl.T;
P << extract_processor_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_processor_decl_void@
identifier F = processor;
parameter list P;
@@
void F(P);

@script:python depends on extract_processor_decl_void@
F << extract_processor_decl_void.F;
P << extract_processor_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: put_LZW_pixel_rows
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_put_LZW_pixel_rows_def@
type T;
identifier F = put_LZW_pixel_rows;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_put_LZW_pixel_rows_def@
F << remove_static_put_LZW_pixel_rows_def.F;
T << remove_static_put_LZW_pixel_rows_def.T;
P << remove_static_put_LZW_pixel_rows_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_put_LZW_pixel_rows_def_void@
identifier F = put_LZW_pixel_rows;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_put_LZW_pixel_rows_def_void@
F << remove_static_put_LZW_pixel_rows_def_void.F;
P << remove_static_put_LZW_pixel_rows_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_put_LZW_pixel_rows_decl@
type T;
identifier F = put_LZW_pixel_rows;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_put_LZW_pixel_rows_decl@
F << remove_static_put_LZW_pixel_rows_decl.F;
T << remove_static_put_LZW_pixel_rows_decl.T;
P << remove_static_put_LZW_pixel_rows_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_put_LZW_pixel_rows_decl_void@
identifier F = put_LZW_pixel_rows;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_put_LZW_pixel_rows_decl_void@
F << remove_static_put_LZW_pixel_rows_decl_void.F;
P << remove_static_put_LZW_pixel_rows_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_put_LZW_pixel_rows_def@
type T;
identifier F = put_LZW_pixel_rows;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_put_LZW_pixel_rows_def@
F << extract_put_LZW_pixel_rows_def.F;
T << extract_put_LZW_pixel_rows_def.T;
P << extract_put_LZW_pixel_rows_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_put_LZW_pixel_rows_def_void@
identifier F = put_LZW_pixel_rows;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_put_LZW_pixel_rows_def_void@
F << extract_put_LZW_pixel_rows_def_void.F;
P << extract_put_LZW_pixel_rows_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_put_LZW_pixel_rows_decl@
type T;
identifier F = put_LZW_pixel_rows;
parameter list P;
@@
T F(P);

@script:python depends on extract_put_LZW_pixel_rows_decl@
F << extract_put_LZW_pixel_rows_decl.F;
T << extract_put_LZW_pixel_rows_decl.T;
P << extract_put_LZW_pixel_rows_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_put_LZW_pixel_rows_decl_void@
identifier F = put_LZW_pixel_rows;
parameter list P;
@@
void F(P);

@script:python depends on extract_put_LZW_pixel_rows_decl_void@
F << extract_put_LZW_pixel_rows_decl_void.F;
P << extract_put_LZW_pixel_rows_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: put_cmyk
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_put_cmyk_def@
type T;
identifier F = put_cmyk;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_put_cmyk_def@
F << remove_static_put_cmyk_def.F;
T << remove_static_put_cmyk_def.T;
P << remove_static_put_cmyk_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_put_cmyk_def_void@
identifier F = put_cmyk;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_put_cmyk_def_void@
F << remove_static_put_cmyk_def_void.F;
P << remove_static_put_cmyk_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_put_cmyk_decl@
type T;
identifier F = put_cmyk;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_put_cmyk_decl@
F << remove_static_put_cmyk_decl.F;
T << remove_static_put_cmyk_decl.T;
P << remove_static_put_cmyk_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_put_cmyk_decl_void@
identifier F = put_cmyk;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_put_cmyk_decl_void@
F << remove_static_put_cmyk_decl_void.F;
P << remove_static_put_cmyk_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_put_cmyk_def@
type T;
identifier F = put_cmyk;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_put_cmyk_def@
F << extract_put_cmyk_def.F;
T << extract_put_cmyk_def.T;
P << extract_put_cmyk_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_put_cmyk_def_void@
identifier F = put_cmyk;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_put_cmyk_def_void@
F << extract_put_cmyk_def_void.F;
P << extract_put_cmyk_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_put_cmyk_decl@
type T;
identifier F = put_cmyk;
parameter list P;
@@
T F(P);

@script:python depends on extract_put_cmyk_decl@
F << extract_put_cmyk_decl.F;
T << extract_put_cmyk_decl.T;
P << extract_put_cmyk_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_put_cmyk_decl_void@
identifier F = put_cmyk;
parameter list P;
@@
void F(P);

@script:python depends on extract_put_cmyk_decl_void@
F << extract_put_cmyk_decl_void.F;
P << extract_put_cmyk_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: put_demapped_gray
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_put_demapped_gray_def@
type T;
identifier F = put_demapped_gray;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_put_demapped_gray_def@
F << remove_static_put_demapped_gray_def.F;
T << remove_static_put_demapped_gray_def.T;
P << remove_static_put_demapped_gray_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_put_demapped_gray_def_void@
identifier F = put_demapped_gray;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_put_demapped_gray_def_void@
F << remove_static_put_demapped_gray_def_void.F;
P << remove_static_put_demapped_gray_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_put_demapped_gray_decl@
type T;
identifier F = put_demapped_gray;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_put_demapped_gray_decl@
F << remove_static_put_demapped_gray_decl.F;
T << remove_static_put_demapped_gray_decl.T;
P << remove_static_put_demapped_gray_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_put_demapped_gray_decl_void@
identifier F = put_demapped_gray;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_put_demapped_gray_decl_void@
F << remove_static_put_demapped_gray_decl_void.F;
P << remove_static_put_demapped_gray_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_put_demapped_gray_def@
type T;
identifier F = put_demapped_gray;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_put_demapped_gray_def@
F << extract_put_demapped_gray_def.F;
T << extract_put_demapped_gray_def.T;
P << extract_put_demapped_gray_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_put_demapped_gray_def_void@
identifier F = put_demapped_gray;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_put_demapped_gray_def_void@
F << extract_put_demapped_gray_def_void.F;
P << extract_put_demapped_gray_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_put_demapped_gray_decl@
type T;
identifier F = put_demapped_gray;
parameter list P;
@@
T F(P);

@script:python depends on extract_put_demapped_gray_decl@
F << extract_put_demapped_gray_decl.F;
T << extract_put_demapped_gray_decl.T;
P << extract_put_demapped_gray_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_put_demapped_gray_decl_void@
identifier F = put_demapped_gray;
parameter list P;
@@
void F(P);

@script:python depends on extract_put_demapped_gray_decl_void@
F << extract_put_demapped_gray_decl_void.F;
P << extract_put_demapped_gray_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: put_demapped_rgb
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_put_demapped_rgb_def@
type T;
identifier F = put_demapped_rgb;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_put_demapped_rgb_def@
F << remove_static_put_demapped_rgb_def.F;
T << remove_static_put_demapped_rgb_def.T;
P << remove_static_put_demapped_rgb_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_put_demapped_rgb_def_void@
identifier F = put_demapped_rgb;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_put_demapped_rgb_def_void@
F << remove_static_put_demapped_rgb_def_void.F;
P << remove_static_put_demapped_rgb_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_put_demapped_rgb_decl@
type T;
identifier F = put_demapped_rgb;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_put_demapped_rgb_decl@
F << remove_static_put_demapped_rgb_decl.F;
T << remove_static_put_demapped_rgb_decl.T;
P << remove_static_put_demapped_rgb_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_put_demapped_rgb_decl_void@
identifier F = put_demapped_rgb;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_put_demapped_rgb_decl_void@
F << remove_static_put_demapped_rgb_decl_void.F;
P << remove_static_put_demapped_rgb_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_put_demapped_rgb_def@
type T;
identifier F = put_demapped_rgb;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_put_demapped_rgb_def@
F << extract_put_demapped_rgb_def.F;
T << extract_put_demapped_rgb_def.T;
P << extract_put_demapped_rgb_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_put_demapped_rgb_def_void@
identifier F = put_demapped_rgb;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_put_demapped_rgb_def_void@
F << extract_put_demapped_rgb_def_void.F;
P << extract_put_demapped_rgb_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_put_demapped_rgb_decl@
type T;
identifier F = put_demapped_rgb;
parameter list P;
@@
T F(P);

@script:python depends on extract_put_demapped_rgb_decl@
F << extract_put_demapped_rgb_decl.F;
T << extract_put_demapped_rgb_decl.T;
P << extract_put_demapped_rgb_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_put_demapped_rgb_decl_void@
identifier F = put_demapped_rgb;
parameter list P;
@@
void F(P);

@script:python depends on extract_put_demapped_rgb_decl_void@
F << extract_put_demapped_rgb_decl_void.F;
P << extract_put_demapped_rgb_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: put_gray_rows
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_put_gray_rows_def@
type T;
identifier F = put_gray_rows;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_put_gray_rows_def@
F << remove_static_put_gray_rows_def.F;
T << remove_static_put_gray_rows_def.T;
P << remove_static_put_gray_rows_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_put_gray_rows_def_void@
identifier F = put_gray_rows;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_put_gray_rows_def_void@
F << remove_static_put_gray_rows_def_void.F;
P << remove_static_put_gray_rows_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_put_gray_rows_decl@
type T;
identifier F = put_gray_rows;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_put_gray_rows_decl@
F << remove_static_put_gray_rows_decl.F;
T << remove_static_put_gray_rows_decl.T;
P << remove_static_put_gray_rows_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_put_gray_rows_decl_void@
identifier F = put_gray_rows;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_put_gray_rows_decl_void@
F << remove_static_put_gray_rows_decl_void.F;
P << remove_static_put_gray_rows_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_put_gray_rows_def@
type T;
identifier F = put_gray_rows;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_put_gray_rows_def@
F << extract_put_gray_rows_def.F;
T << extract_put_gray_rows_def.T;
P << extract_put_gray_rows_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_put_gray_rows_def_void@
identifier F = put_gray_rows;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_put_gray_rows_def_void@
F << extract_put_gray_rows_def_void.F;
P << extract_put_gray_rows_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_put_gray_rows_decl@
type T;
identifier F = put_gray_rows;
parameter list P;
@@
T F(P);

@script:python depends on extract_put_gray_rows_decl@
F << extract_put_gray_rows_decl.F;
T << extract_put_gray_rows_decl.T;
P << extract_put_gray_rows_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_put_gray_rows_decl_void@
identifier F = put_gray_rows;
parameter list P;
@@
void F(P);

@script:python depends on extract_put_gray_rows_decl_void@
F << extract_put_gray_rows_decl_void.F;
P << extract_put_gray_rows_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: put_raw_pixel_rows
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_put_raw_pixel_rows_def@
type T;
identifier F = put_raw_pixel_rows;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_put_raw_pixel_rows_def@
F << remove_static_put_raw_pixel_rows_def.F;
T << remove_static_put_raw_pixel_rows_def.T;
P << remove_static_put_raw_pixel_rows_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_put_raw_pixel_rows_def_void@
identifier F = put_raw_pixel_rows;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_put_raw_pixel_rows_def_void@
F << remove_static_put_raw_pixel_rows_def_void.F;
P << remove_static_put_raw_pixel_rows_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_put_raw_pixel_rows_decl@
type T;
identifier F = put_raw_pixel_rows;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_put_raw_pixel_rows_decl@
F << remove_static_put_raw_pixel_rows_decl.F;
T << remove_static_put_raw_pixel_rows_decl.T;
P << remove_static_put_raw_pixel_rows_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_put_raw_pixel_rows_decl_void@
identifier F = put_raw_pixel_rows;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_put_raw_pixel_rows_decl_void@
F << remove_static_put_raw_pixel_rows_decl_void.F;
P << remove_static_put_raw_pixel_rows_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_put_raw_pixel_rows_def@
type T;
identifier F = put_raw_pixel_rows;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_put_raw_pixel_rows_def@
F << extract_put_raw_pixel_rows_def.F;
T << extract_put_raw_pixel_rows_def.T;
P << extract_put_raw_pixel_rows_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_put_raw_pixel_rows_def_void@
identifier F = put_raw_pixel_rows;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_put_raw_pixel_rows_def_void@
F << extract_put_raw_pixel_rows_def_void.F;
P << extract_put_raw_pixel_rows_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_put_raw_pixel_rows_decl@
type T;
identifier F = put_raw_pixel_rows;
parameter list P;
@@
T F(P);

@script:python depends on extract_put_raw_pixel_rows_decl@
F << extract_put_raw_pixel_rows_decl.F;
T << extract_put_raw_pixel_rows_decl.T;
P << extract_put_raw_pixel_rows_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_put_raw_pixel_rows_decl_void@
identifier F = put_raw_pixel_rows;
parameter list P;
@@
void F(P);

@script:python depends on extract_put_raw_pixel_rows_decl_void@
F << extract_put_raw_pixel_rows_decl_void.F;
P << extract_put_raw_pixel_rows_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: put_rgb
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_put_rgb_def@
type T;
identifier F = put_rgb;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_put_rgb_def@
F << remove_static_put_rgb_def.F;
T << remove_static_put_rgb_def.T;
P << remove_static_put_rgb_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_put_rgb_def_void@
identifier F = put_rgb;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_put_rgb_def_void@
F << remove_static_put_rgb_def_void.F;
P << remove_static_put_rgb_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_put_rgb_decl@
type T;
identifier F = put_rgb;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_put_rgb_decl@
F << remove_static_put_rgb_decl.F;
T << remove_static_put_rgb_decl.T;
P << remove_static_put_rgb_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_put_rgb_decl_void@
identifier F = put_rgb;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_put_rgb_decl_void@
F << remove_static_put_rgb_decl_void.F;
P << remove_static_put_rgb_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_put_rgb_def@
type T;
identifier F = put_rgb;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_put_rgb_def@
F << extract_put_rgb_def.F;
T << extract_put_rgb_def.T;
P << extract_put_rgb_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_put_rgb_def_void@
identifier F = put_rgb;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_put_rgb_def_void@
F << extract_put_rgb_def_void.F;
P << extract_put_rgb_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_put_rgb_decl@
type T;
identifier F = put_rgb;
parameter list P;
@@
T F(P);

@script:python depends on extract_put_rgb_decl@
F << extract_put_rgb_decl.F;
T << extract_put_rgb_decl.T;
P << extract_put_rgb_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_put_rgb_decl_void@
identifier F = put_rgb;
parameter list P;
@@
void F(P);

@script:python depends on extract_put_rgb_decl_void@
F << extract_put_rgb_decl_void.F;
P << extract_put_rgb_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: quantize_float
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_quantize_float_def@
type T;
identifier F = quantize_float;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_quantize_float_def@
F << remove_static_quantize_float_def.F;
T << remove_static_quantize_float_def.T;
P << remove_static_quantize_float_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_quantize_float_def_void@
identifier F = quantize_float;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_quantize_float_def_void@
F << remove_static_quantize_float_def_void.F;
P << remove_static_quantize_float_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_quantize_float_decl@
type T;
identifier F = quantize_float;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_quantize_float_decl@
F << remove_static_quantize_float_decl.F;
T << remove_static_quantize_float_decl.T;
P << remove_static_quantize_float_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_quantize_float_decl_void@
identifier F = quantize_float;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_quantize_float_decl_void@
F << remove_static_quantize_float_decl_void.F;
P << remove_static_quantize_float_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_quantize_float_def@
type T;
identifier F = quantize_float;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_quantize_float_def@
F << extract_quantize_float_def.F;
T << extract_quantize_float_def.T;
P << extract_quantize_float_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_quantize_float_def_void@
identifier F = quantize_float;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_quantize_float_def_void@
F << extract_quantize_float_def_void.F;
P << extract_quantize_float_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_quantize_float_decl@
type T;
identifier F = quantize_float;
parameter list P;
@@
T F(P);

@script:python depends on extract_quantize_float_decl@
F << extract_quantize_float_decl.F;
T << extract_quantize_float_decl.T;
P << extract_quantize_float_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_quantize_float_decl_void@
identifier F = quantize_float;
parameter list P;
@@
void F(P);

@script:python depends on extract_quantize_float_decl_void@
F << extract_quantize_float_decl_void.F;
P << extract_quantize_float_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: read_non_rle_pixel
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_read_non_rle_pixel_def@
type T;
identifier F = read_non_rle_pixel;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_read_non_rle_pixel_def@
F << remove_static_read_non_rle_pixel_def.F;
T << remove_static_read_non_rle_pixel_def.T;
P << remove_static_read_non_rle_pixel_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_read_non_rle_pixel_def_void@
identifier F = read_non_rle_pixel;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_read_non_rle_pixel_def_void@
F << remove_static_read_non_rle_pixel_def_void.F;
P << remove_static_read_non_rle_pixel_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_read_non_rle_pixel_decl@
type T;
identifier F = read_non_rle_pixel;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_read_non_rle_pixel_decl@
F << remove_static_read_non_rle_pixel_decl.F;
T << remove_static_read_non_rle_pixel_decl.T;
P << remove_static_read_non_rle_pixel_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_read_non_rle_pixel_decl_void@
identifier F = read_non_rle_pixel;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_read_non_rle_pixel_decl_void@
F << remove_static_read_non_rle_pixel_decl_void.F;
P << remove_static_read_non_rle_pixel_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_read_non_rle_pixel_def@
type T;
identifier F = read_non_rle_pixel;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_read_non_rle_pixel_def@
F << extract_read_non_rle_pixel_def.F;
T << extract_read_non_rle_pixel_def.T;
P << extract_read_non_rle_pixel_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_read_non_rle_pixel_def_void@
identifier F = read_non_rle_pixel;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_read_non_rle_pixel_def_void@
F << extract_read_non_rle_pixel_def_void.F;
P << extract_read_non_rle_pixel_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_read_non_rle_pixel_decl@
type T;
identifier F = read_non_rle_pixel;
parameter list P;
@@
T F(P);

@script:python depends on extract_read_non_rle_pixel_decl@
F << extract_read_non_rle_pixel_decl.F;
T << extract_read_non_rle_pixel_decl.T;
P << extract_read_non_rle_pixel_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_read_non_rle_pixel_decl_void@
identifier F = read_non_rle_pixel;
parameter list P;
@@
void F(P);

@script:python depends on extract_read_non_rle_pixel_decl_void@
F << extract_read_non_rle_pixel_decl_void.F;
P << extract_read_non_rle_pixel_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: read_rle_pixel
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_read_rle_pixel_def@
type T;
identifier F = read_rle_pixel;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_read_rle_pixel_def@
F << remove_static_read_rle_pixel_def.F;
T << remove_static_read_rle_pixel_def.T;
P << remove_static_read_rle_pixel_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_read_rle_pixel_def_void@
identifier F = read_rle_pixel;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_read_rle_pixel_def_void@
F << remove_static_read_rle_pixel_def_void.F;
P << remove_static_read_rle_pixel_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_read_rle_pixel_decl@
type T;
identifier F = read_rle_pixel;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_read_rle_pixel_decl@
F << remove_static_read_rle_pixel_decl.F;
T << remove_static_read_rle_pixel_decl.T;
P << remove_static_read_rle_pixel_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_read_rle_pixel_decl_void@
identifier F = read_rle_pixel;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_read_rle_pixel_decl_void@
F << remove_static_read_rle_pixel_decl_void.F;
P << remove_static_read_rle_pixel_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_read_rle_pixel_def@
type T;
identifier F = read_rle_pixel;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_read_rle_pixel_def@
F << extract_read_rle_pixel_def.F;
T << extract_read_rle_pixel_def.T;
P << extract_read_rle_pixel_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_read_rle_pixel_def_void@
identifier F = read_rle_pixel;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_read_rle_pixel_def_void@
F << extract_read_rle_pixel_def_void.F;
P << extract_read_rle_pixel_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_read_rle_pixel_decl@
type T;
identifier F = read_rle_pixel;
parameter list P;
@@
T F(P);

@script:python depends on extract_read_rle_pixel_decl@
F << extract_read_rle_pixel_decl.F;
T << extract_read_rle_pixel_decl.T;
P << extract_read_rle_pixel_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_read_rle_pixel_decl_void@
identifier F = read_rle_pixel;
parameter list P;
@@
void F(P);

@script:python depends on extract_read_rle_pixel_decl_void@
F << extract_read_rle_pixel_decl_void.F;
P << extract_read_rle_pixel_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: rgb_ycc_start
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_rgb_ycc_start_def@
type T;
identifier F = rgb_ycc_start;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_rgb_ycc_start_def@
F << remove_static_rgb_ycc_start_def.F;
T << remove_static_rgb_ycc_start_def.T;
P << remove_static_rgb_ycc_start_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_rgb_ycc_start_def_void@
identifier F = rgb_ycc_start;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_rgb_ycc_start_def_void@
F << remove_static_rgb_ycc_start_def_void.F;
P << remove_static_rgb_ycc_start_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_rgb_ycc_start_decl@
type T;
identifier F = rgb_ycc_start;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_rgb_ycc_start_decl@
F << remove_static_rgb_ycc_start_decl.F;
T << remove_static_rgb_ycc_start_decl.T;
P << remove_static_rgb_ycc_start_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_rgb_ycc_start_decl_void@
identifier F = rgb_ycc_start;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_rgb_ycc_start_decl_void@
F << remove_static_rgb_ycc_start_decl_void.F;
P << remove_static_rgb_ycc_start_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_rgb_ycc_start_def@
type T;
identifier F = rgb_ycc_start;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_rgb_ycc_start_def@
F << extract_rgb_ycc_start_def.F;
T << extract_rgb_ycc_start_def.T;
P << extract_rgb_ycc_start_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_rgb_ycc_start_def_void@
identifier F = rgb_ycc_start;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_rgb_ycc_start_def_void@
F << extract_rgb_ycc_start_def_void.F;
P << extract_rgb_ycc_start_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_rgb_ycc_start_decl@
type T;
identifier F = rgb_ycc_start;
parameter list P;
@@
T F(P);

@script:python depends on extract_rgb_ycc_start_decl@
F << extract_rgb_ycc_start_decl.F;
T << extract_rgb_ycc_start_decl.T;
P << extract_rgb_ycc_start_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_rgb_ycc_start_decl_void@
identifier F = rgb_ycc_start;
parameter list P;
@@
void F(P);

@script:python depends on extract_rgb_ycc_start_decl_void@
F << extract_rgb_ycc_start_decl_void.F;
P << extract_rgb_ycc_start_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: simple_downscale
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_simple_downscale_def@
type T;
identifier F = simple_downscale;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_simple_downscale_def@
F << remove_static_simple_downscale_def.F;
T << remove_static_simple_downscale_def.T;
P << remove_static_simple_downscale_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_simple_downscale_def_void@
identifier F = simple_downscale;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_simple_downscale_def_void@
F << remove_static_simple_downscale_def_void.F;
P << remove_static_simple_downscale_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_simple_downscale_decl@
type T;
identifier F = simple_downscale;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_simple_downscale_decl@
F << remove_static_simple_downscale_decl.F;
T << remove_static_simple_downscale_decl.T;
P << remove_static_simple_downscale_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_simple_downscale_decl_void@
identifier F = simple_downscale;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_simple_downscale_decl_void@
F << remove_static_simple_downscale_decl_void.F;
P << remove_static_simple_downscale_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_simple_downscale_def@
type T;
identifier F = simple_downscale;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_simple_downscale_def@
F << extract_simple_downscale_def.F;
T << extract_simple_downscale_def.T;
P << extract_simple_downscale_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_simple_downscale_def_void@
identifier F = simple_downscale;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_simple_downscale_def_void@
F << extract_simple_downscale_def_void.F;
P << extract_simple_downscale_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_simple_downscale_decl@
type T;
identifier F = simple_downscale;
parameter list P;
@@
T F(P);

@script:python depends on extract_simple_downscale_decl@
F << extract_simple_downscale_decl.F;
T << extract_simple_downscale_decl.T;
P << extract_simple_downscale_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_simple_downscale_decl_void@
identifier F = simple_downscale;
parameter list P;
@@
void F(P);

@script:python depends on extract_simple_downscale_decl_void@
F << extract_simple_downscale_decl_void.F;
P << extract_simple_downscale_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: simple_upscale
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_simple_upscale_def@
type T;
identifier F = simple_upscale;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_simple_upscale_def@
F << remove_static_simple_upscale_def.F;
T << remove_static_simple_upscale_def.T;
P << remove_static_simple_upscale_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_simple_upscale_def_void@
identifier F = simple_upscale;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_simple_upscale_def_void@
F << remove_static_simple_upscale_def_void.F;
P << remove_static_simple_upscale_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_simple_upscale_decl@
type T;
identifier F = simple_upscale;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_simple_upscale_decl@
F << remove_static_simple_upscale_decl.F;
T << remove_static_simple_upscale_decl.T;
P << remove_static_simple_upscale_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_simple_upscale_decl_void@
identifier F = simple_upscale;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_simple_upscale_decl_void@
F << remove_static_simple_upscale_decl_void.F;
P << remove_static_simple_upscale_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_simple_upscale_def@
type T;
identifier F = simple_upscale;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_simple_upscale_def@
F << extract_simple_upscale_def.F;
T << extract_simple_upscale_def.T;
P << extract_simple_upscale_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_simple_upscale_def_void@
identifier F = simple_upscale;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_simple_upscale_def_void@
F << extract_simple_upscale_def_void.F;
P << extract_simple_upscale_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_simple_upscale_decl@
type T;
identifier F = simple_upscale;
parameter list P;
@@
T F(P);

@script:python depends on extract_simple_upscale_decl@
F << extract_simple_upscale_decl.F;
T << extract_simple_upscale_decl.T;
P << extract_simple_upscale_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_simple_upscale_decl_void@
identifier F = simple_upscale;
parameter list P;
@@
void F(P);

@script:python depends on extract_simple_upscale_decl_void@
F << extract_simple_upscale_decl_void.F;
P << extract_simple_upscale_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: skip_variable
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_skip_variable_def@
type T;
identifier F = skip_variable;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_skip_variable_def@
F << remove_static_skip_variable_def.F;
T << remove_static_skip_variable_def.T;
P << remove_static_skip_variable_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_skip_variable_def_void@
identifier F = skip_variable;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_skip_variable_def_void@
F << remove_static_skip_variable_def_void.F;
P << remove_static_skip_variable_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_skip_variable_decl@
type T;
identifier F = skip_variable;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_skip_variable_decl@
F << remove_static_skip_variable_decl.F;
T << remove_static_skip_variable_decl.T;
P << remove_static_skip_variable_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_skip_variable_decl_void@
identifier F = skip_variable;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_skip_variable_decl_void@
F << remove_static_skip_variable_decl_void.F;
P << remove_static_skip_variable_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_skip_variable_def@
type T;
identifier F = skip_variable;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_skip_variable_def@
F << extract_skip_variable_def.F;
T << extract_skip_variable_def.T;
P << extract_skip_variable_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_skip_variable_def_void@
identifier F = skip_variable;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_skip_variable_def_void@
F << extract_skip_variable_def_void.F;
P << extract_skip_variable_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_skip_variable_decl@
type T;
identifier F = skip_variable;
parameter list P;
@@
T F(P);

@script:python depends on extract_skip_variable_decl@
F << extract_skip_variable_decl.F;
T << extract_skip_variable_decl.T;
P << extract_skip_variable_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_skip_variable_decl_void@
identifier F = skip_variable;
parameter list P;
@@
void F(P);

@script:python depends on extract_skip_variable_decl_void@
F << extract_skip_variable_decl_void.F;
P << extract_skip_variable_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: start_input_bmp
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_start_input_bmp_def@
type T;
identifier F = start_input_bmp;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_start_input_bmp_def@
F << remove_static_start_input_bmp_def.F;
T << remove_static_start_input_bmp_def.T;
P << remove_static_start_input_bmp_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_start_input_bmp_def_void@
identifier F = start_input_bmp;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_start_input_bmp_def_void@
F << remove_static_start_input_bmp_def_void.F;
P << remove_static_start_input_bmp_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_start_input_bmp_decl@
type T;
identifier F = start_input_bmp;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_start_input_bmp_decl@
F << remove_static_start_input_bmp_decl.F;
T << remove_static_start_input_bmp_decl.T;
P << remove_static_start_input_bmp_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_start_input_bmp_decl_void@
identifier F = start_input_bmp;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_start_input_bmp_decl_void@
F << remove_static_start_input_bmp_decl_void.F;
P << remove_static_start_input_bmp_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_start_input_bmp_def@
type T;
identifier F = start_input_bmp;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_start_input_bmp_def@
F << extract_start_input_bmp_def.F;
T << extract_start_input_bmp_def.T;
P << extract_start_input_bmp_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_start_input_bmp_def_void@
identifier F = start_input_bmp;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_start_input_bmp_def_void@
F << extract_start_input_bmp_def_void.F;
P << extract_start_input_bmp_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_start_input_bmp_decl@
type T;
identifier F = start_input_bmp;
parameter list P;
@@
T F(P);

@script:python depends on extract_start_input_bmp_decl@
F << extract_start_input_bmp_decl.F;
T << extract_start_input_bmp_decl.T;
P << extract_start_input_bmp_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_start_input_bmp_decl_void@
identifier F = start_input_bmp;
parameter list P;
@@
void F(P);

@script:python depends on extract_start_input_bmp_decl_void@
F << extract_start_input_bmp_decl_void.F;
P << extract_start_input_bmp_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: start_input_gif
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_start_input_gif_def@
type T;
identifier F = start_input_gif;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_start_input_gif_def@
F << remove_static_start_input_gif_def.F;
T << remove_static_start_input_gif_def.T;
P << remove_static_start_input_gif_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_start_input_gif_def_void@
identifier F = start_input_gif;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_start_input_gif_def_void@
F << remove_static_start_input_gif_def_void.F;
P << remove_static_start_input_gif_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_start_input_gif_decl@
type T;
identifier F = start_input_gif;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_start_input_gif_decl@
F << remove_static_start_input_gif_decl.F;
T << remove_static_start_input_gif_decl.T;
P << remove_static_start_input_gif_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_start_input_gif_decl_void@
identifier F = start_input_gif;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_start_input_gif_decl_void@
F << remove_static_start_input_gif_decl_void.F;
P << remove_static_start_input_gif_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_start_input_gif_def@
type T;
identifier F = start_input_gif;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_start_input_gif_def@
F << extract_start_input_gif_def.F;
T << extract_start_input_gif_def.T;
P << extract_start_input_gif_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_start_input_gif_def_void@
identifier F = start_input_gif;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_start_input_gif_def_void@
F << extract_start_input_gif_def_void.F;
P << extract_start_input_gif_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_start_input_gif_decl@
type T;
identifier F = start_input_gif;
parameter list P;
@@
T F(P);

@script:python depends on extract_start_input_gif_decl@
F << extract_start_input_gif_decl.F;
T << extract_start_input_gif_decl.T;
P << extract_start_input_gif_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_start_input_gif_decl_void@
identifier F = start_input_gif;
parameter list P;
@@
void F(P);

@script:python depends on extract_start_input_gif_decl_void@
F << extract_start_input_gif_decl_void.F;
P << extract_start_input_gif_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: start_input_ppm
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_start_input_ppm_def@
type T;
identifier F = start_input_ppm;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_start_input_ppm_def@
F << remove_static_start_input_ppm_def.F;
T << remove_static_start_input_ppm_def.T;
P << remove_static_start_input_ppm_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_start_input_ppm_def_void@
identifier F = start_input_ppm;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_start_input_ppm_def_void@
F << remove_static_start_input_ppm_def_void.F;
P << remove_static_start_input_ppm_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_start_input_ppm_decl@
type T;
identifier F = start_input_ppm;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_start_input_ppm_decl@
F << remove_static_start_input_ppm_decl.F;
T << remove_static_start_input_ppm_decl.T;
P << remove_static_start_input_ppm_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_start_input_ppm_decl_void@
identifier F = start_input_ppm;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_start_input_ppm_decl_void@
F << remove_static_start_input_ppm_decl_void.F;
P << remove_static_start_input_ppm_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_start_input_ppm_def@
type T;
identifier F = start_input_ppm;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_start_input_ppm_def@
F << extract_start_input_ppm_def.F;
T << extract_start_input_ppm_def.T;
P << extract_start_input_ppm_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_start_input_ppm_def_void@
identifier F = start_input_ppm;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_start_input_ppm_def_void@
F << extract_start_input_ppm_def_void.F;
P << extract_start_input_ppm_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_start_input_ppm_decl@
type T;
identifier F = start_input_ppm;
parameter list P;
@@
T F(P);

@script:python depends on extract_start_input_ppm_decl@
F << extract_start_input_ppm_decl.F;
T << extract_start_input_ppm_decl.T;
P << extract_start_input_ppm_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_start_input_ppm_decl_void@
identifier F = start_input_ppm;
parameter list P;
@@
void F(P);

@script:python depends on extract_start_input_ppm_decl_void@
F << extract_start_input_ppm_decl_void.F;
P << extract_start_input_ppm_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: start_input_tga
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_start_input_tga_def@
type T;
identifier F = start_input_tga;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_start_input_tga_def@
F << remove_static_start_input_tga_def.F;
T << remove_static_start_input_tga_def.T;
P << remove_static_start_input_tga_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_start_input_tga_def_void@
identifier F = start_input_tga;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_start_input_tga_def_void@
F << remove_static_start_input_tga_def_void.F;
P << remove_static_start_input_tga_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_start_input_tga_decl@
type T;
identifier F = start_input_tga;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_start_input_tga_decl@
F << remove_static_start_input_tga_decl.F;
T << remove_static_start_input_tga_decl.T;
P << remove_static_start_input_tga_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_start_input_tga_decl_void@
identifier F = start_input_tga;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_start_input_tga_decl_void@
F << remove_static_start_input_tga_decl_void.F;
P << remove_static_start_input_tga_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_start_input_tga_def@
type T;
identifier F = start_input_tga;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_start_input_tga_def@
F << extract_start_input_tga_def.F;
T << extract_start_input_tga_def.T;
P << extract_start_input_tga_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_start_input_tga_def_void@
identifier F = start_input_tga;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_start_input_tga_def_void@
F << extract_start_input_tga_def_void.F;
P << extract_start_input_tga_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_start_input_tga_decl@
type T;
identifier F = start_input_tga;
parameter list P;
@@
T F(P);

@script:python depends on extract_start_input_tga_decl@
F << extract_start_input_tga_decl.F;
T << extract_start_input_tga_decl.T;
P << extract_start_input_tga_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_start_input_tga_decl_void@
identifier F = start_input_tga;
parameter list P;
@@
void F(P);

@script:python depends on extract_start_input_tga_decl_void@
F << extract_start_input_tga_decl_void.F;
P << extract_start_input_tga_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: start_output_bmp
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_start_output_bmp_def@
type T;
identifier F = start_output_bmp;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_start_output_bmp_def@
F << remove_static_start_output_bmp_def.F;
T << remove_static_start_output_bmp_def.T;
P << remove_static_start_output_bmp_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_start_output_bmp_def_void@
identifier F = start_output_bmp;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_start_output_bmp_def_void@
F << remove_static_start_output_bmp_def_void.F;
P << remove_static_start_output_bmp_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_start_output_bmp_decl@
type T;
identifier F = start_output_bmp;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_start_output_bmp_decl@
F << remove_static_start_output_bmp_decl.F;
T << remove_static_start_output_bmp_decl.T;
P << remove_static_start_output_bmp_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_start_output_bmp_decl_void@
identifier F = start_output_bmp;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_start_output_bmp_decl_void@
F << remove_static_start_output_bmp_decl_void.F;
P << remove_static_start_output_bmp_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_start_output_bmp_def@
type T;
identifier F = start_output_bmp;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_start_output_bmp_def@
F << extract_start_output_bmp_def.F;
T << extract_start_output_bmp_def.T;
P << extract_start_output_bmp_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_start_output_bmp_def_void@
identifier F = start_output_bmp;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_start_output_bmp_def_void@
F << extract_start_output_bmp_def_void.F;
P << extract_start_output_bmp_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_start_output_bmp_decl@
type T;
identifier F = start_output_bmp;
parameter list P;
@@
T F(P);

@script:python depends on extract_start_output_bmp_decl@
F << extract_start_output_bmp_decl.F;
T << extract_start_output_bmp_decl.T;
P << extract_start_output_bmp_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_start_output_bmp_decl_void@
identifier F = start_output_bmp;
parameter list P;
@@
void F(P);

@script:python depends on extract_start_output_bmp_decl_void@
F << extract_start_output_bmp_decl_void.F;
P << extract_start_output_bmp_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: start_output_gif
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_start_output_gif_def@
type T;
identifier F = start_output_gif;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_start_output_gif_def@
F << remove_static_start_output_gif_def.F;
T << remove_static_start_output_gif_def.T;
P << remove_static_start_output_gif_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_start_output_gif_def_void@
identifier F = start_output_gif;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_start_output_gif_def_void@
F << remove_static_start_output_gif_def_void.F;
P << remove_static_start_output_gif_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_start_output_gif_decl@
type T;
identifier F = start_output_gif;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_start_output_gif_decl@
F << remove_static_start_output_gif_decl.F;
T << remove_static_start_output_gif_decl.T;
P << remove_static_start_output_gif_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_start_output_gif_decl_void@
identifier F = start_output_gif;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_start_output_gif_decl_void@
F << remove_static_start_output_gif_decl_void.F;
P << remove_static_start_output_gif_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_start_output_gif_def@
type T;
identifier F = start_output_gif;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_start_output_gif_def@
F << extract_start_output_gif_def.F;
T << extract_start_output_gif_def.T;
P << extract_start_output_gif_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_start_output_gif_def_void@
identifier F = start_output_gif;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_start_output_gif_def_void@
F << extract_start_output_gif_def_void.F;
P << extract_start_output_gif_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_start_output_gif_decl@
type T;
identifier F = start_output_gif;
parameter list P;
@@
T F(P);

@script:python depends on extract_start_output_gif_decl@
F << extract_start_output_gif_decl.F;
T << extract_start_output_gif_decl.T;
P << extract_start_output_gif_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_start_output_gif_decl_void@
identifier F = start_output_gif;
parameter list P;
@@
void F(P);

@script:python depends on extract_start_output_gif_decl_void@
F << extract_start_output_gif_decl_void.F;
P << extract_start_output_gif_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: start_output_ppm
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_start_output_ppm_def@
type T;
identifier F = start_output_ppm;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_start_output_ppm_def@
F << remove_static_start_output_ppm_def.F;
T << remove_static_start_output_ppm_def.T;
P << remove_static_start_output_ppm_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_start_output_ppm_def_void@
identifier F = start_output_ppm;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_start_output_ppm_def_void@
F << remove_static_start_output_ppm_def_void.F;
P << remove_static_start_output_ppm_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_start_output_ppm_decl@
type T;
identifier F = start_output_ppm;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_start_output_ppm_decl@
F << remove_static_start_output_ppm_decl.F;
T << remove_static_start_output_ppm_decl.T;
P << remove_static_start_output_ppm_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_start_output_ppm_decl_void@
identifier F = start_output_ppm;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_start_output_ppm_decl_void@
F << remove_static_start_output_ppm_decl_void.F;
P << remove_static_start_output_ppm_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_start_output_ppm_def@
type T;
identifier F = start_output_ppm;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_start_output_ppm_def@
F << extract_start_output_ppm_def.F;
T << extract_start_output_ppm_def.T;
P << extract_start_output_ppm_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_start_output_ppm_def_void@
identifier F = start_output_ppm;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_start_output_ppm_def_void@
F << extract_start_output_ppm_def_void.F;
P << extract_start_output_ppm_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_start_output_ppm_decl@
type T;
identifier F = start_output_ppm;
parameter list P;
@@
T F(P);

@script:python depends on extract_start_output_ppm_decl@
F << extract_start_output_ppm_decl.F;
T << extract_start_output_ppm_decl.T;
P << extract_start_output_ppm_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_start_output_ppm_decl_void@
identifier F = start_output_ppm;
parameter list P;
@@
void F(P);

@script:python depends on extract_start_output_ppm_decl_void@
F << extract_start_output_ppm_decl_void.F;
P << extract_start_output_ppm_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: start_output_tga
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_start_output_tga_def@
type T;
identifier F = start_output_tga;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_start_output_tga_def@
F << remove_static_start_output_tga_def.F;
T << remove_static_start_output_tga_def.T;
P << remove_static_start_output_tga_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_start_output_tga_def_void@
identifier F = start_output_tga;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_start_output_tga_def_void@
F << remove_static_start_output_tga_def_void.F;
P << remove_static_start_output_tga_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_start_output_tga_decl@
type T;
identifier F = start_output_tga;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_start_output_tga_decl@
F << remove_static_start_output_tga_decl.F;
T << remove_static_start_output_tga_decl.T;
P << remove_static_start_output_tga_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_start_output_tga_decl_void@
identifier F = start_output_tga;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_start_output_tga_decl_void@
F << remove_static_start_output_tga_decl_void.F;
P << remove_static_start_output_tga_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_start_output_tga_def@
type T;
identifier F = start_output_tga;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_start_output_tga_def@
F << extract_start_output_tga_def.F;
T << extract_start_output_tga_def.T;
P << extract_start_output_tga_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_start_output_tga_def_void@
identifier F = start_output_tga;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_start_output_tga_def_void@
F << extract_start_output_tga_def_void.F;
P << extract_start_output_tga_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_start_output_tga_decl@
type T;
identifier F = start_output_tga;
parameter list P;
@@
T F(P);

@script:python depends on extract_start_output_tga_decl@
F << extract_start_output_tga_decl.F;
T << extract_start_output_tga_decl.T;
P << extract_start_output_tga_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_start_output_tga_decl_void@
identifier F = start_output_tga;
parameter list P;
@@
void F(P);

@script:python depends on extract_start_output_tga_decl_void@
F << extract_start_output_tga_decl_void.F;
P << extract_start_output_tga_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: start_pass_1_quant
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_start_pass_1_quant_def@
type T;
identifier F = start_pass_1_quant;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_start_pass_1_quant_def@
F << remove_static_start_pass_1_quant_def.F;
T << remove_static_start_pass_1_quant_def.T;
P << remove_static_start_pass_1_quant_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_start_pass_1_quant_def_void@
identifier F = start_pass_1_quant;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_start_pass_1_quant_def_void@
F << remove_static_start_pass_1_quant_def_void.F;
P << remove_static_start_pass_1_quant_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_start_pass_1_quant_decl@
type T;
identifier F = start_pass_1_quant;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_start_pass_1_quant_decl@
F << remove_static_start_pass_1_quant_decl.F;
T << remove_static_start_pass_1_quant_decl.T;
P << remove_static_start_pass_1_quant_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_start_pass_1_quant_decl_void@
identifier F = start_pass_1_quant;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_start_pass_1_quant_decl_void@
F << remove_static_start_pass_1_quant_decl_void.F;
P << remove_static_start_pass_1_quant_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_start_pass_1_quant_def@
type T;
identifier F = start_pass_1_quant;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_start_pass_1_quant_def@
F << extract_start_pass_1_quant_def.F;
T << extract_start_pass_1_quant_def.T;
P << extract_start_pass_1_quant_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_start_pass_1_quant_def_void@
identifier F = start_pass_1_quant;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_start_pass_1_quant_def_void@
F << extract_start_pass_1_quant_def_void.F;
P << extract_start_pass_1_quant_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_start_pass_1_quant_decl@
type T;
identifier F = start_pass_1_quant;
parameter list P;
@@
T F(P);

@script:python depends on extract_start_pass_1_quant_decl@
F << extract_start_pass_1_quant_decl.F;
T << extract_start_pass_1_quant_decl.T;
P << extract_start_pass_1_quant_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_start_pass_1_quant_decl_void@
identifier F = start_pass_1_quant;
parameter list P;
@@
void F(P);

@script:python depends on extract_start_pass_1_quant_decl_void@
F << extract_start_pass_1_quant_decl_void.F;
P << extract_start_pass_1_quant_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: start_pass_2_quant
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_start_pass_2_quant_def@
type T;
identifier F = start_pass_2_quant;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_start_pass_2_quant_def@
F << remove_static_start_pass_2_quant_def.F;
T << remove_static_start_pass_2_quant_def.T;
P << remove_static_start_pass_2_quant_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_start_pass_2_quant_def_void@
identifier F = start_pass_2_quant;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_start_pass_2_quant_def_void@
F << remove_static_start_pass_2_quant_def_void.F;
P << remove_static_start_pass_2_quant_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_start_pass_2_quant_decl@
type T;
identifier F = start_pass_2_quant;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_start_pass_2_quant_decl@
F << remove_static_start_pass_2_quant_decl.F;
T << remove_static_start_pass_2_quant_decl.T;
P << remove_static_start_pass_2_quant_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_start_pass_2_quant_decl_void@
identifier F = start_pass_2_quant;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_start_pass_2_quant_decl_void@
F << remove_static_start_pass_2_quant_decl_void.F;
P << remove_static_start_pass_2_quant_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_start_pass_2_quant_def@
type T;
identifier F = start_pass_2_quant;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_start_pass_2_quant_def@
F << extract_start_pass_2_quant_def.F;
T << extract_start_pass_2_quant_def.T;
P << extract_start_pass_2_quant_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_start_pass_2_quant_def_void@
identifier F = start_pass_2_quant;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_start_pass_2_quant_def_void@
F << extract_start_pass_2_quant_def_void.F;
P << extract_start_pass_2_quant_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_start_pass_2_quant_decl@
type T;
identifier F = start_pass_2_quant;
parameter list P;
@@
T F(P);

@script:python depends on extract_start_pass_2_quant_decl@
F << extract_start_pass_2_quant_decl.F;
T << extract_start_pass_2_quant_decl.T;
P << extract_start_pass_2_quant_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_start_pass_2_quant_decl_void@
identifier F = start_pass_2_quant;
parameter list P;
@@
void F(P);

@script:python depends on extract_start_pass_2_quant_decl_void@
F << extract_start_pass_2_quant_decl_void.F;
P << extract_start_pass_2_quant_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: start_pass_coef
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_start_pass_coef_def@
type T;
identifier F = start_pass_coef;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_start_pass_coef_def@
F << remove_static_start_pass_coef_def.F;
T << remove_static_start_pass_coef_def.T;
P << remove_static_start_pass_coef_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_start_pass_coef_def_void@
identifier F = start_pass_coef;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_start_pass_coef_def_void@
F << remove_static_start_pass_coef_def_void.F;
P << remove_static_start_pass_coef_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_start_pass_coef_decl@
type T;
identifier F = start_pass_coef;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_start_pass_coef_decl@
F << remove_static_start_pass_coef_decl.F;
T << remove_static_start_pass_coef_decl.T;
P << remove_static_start_pass_coef_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_start_pass_coef_decl_void@
identifier F = start_pass_coef;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_start_pass_coef_decl_void@
F << remove_static_start_pass_coef_decl_void.F;
P << remove_static_start_pass_coef_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_start_pass_coef_def@
type T;
identifier F = start_pass_coef;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_start_pass_coef_def@
F << extract_start_pass_coef_def.F;
T << extract_start_pass_coef_def.T;
P << extract_start_pass_coef_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_start_pass_coef_def_void@
identifier F = start_pass_coef;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_start_pass_coef_def_void@
F << extract_start_pass_coef_def_void.F;
P << extract_start_pass_coef_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_start_pass_coef_decl@
type T;
identifier F = start_pass_coef;
parameter list P;
@@
T F(P);

@script:python depends on extract_start_pass_coef_decl@
F << extract_start_pass_coef_decl.F;
T << extract_start_pass_coef_decl.T;
P << extract_start_pass_coef_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_start_pass_coef_decl_void@
identifier F = start_pass_coef;
parameter list P;
@@
void F(P);

@script:python depends on extract_start_pass_coef_decl_void@
F << extract_start_pass_coef_decl_void.F;
P << extract_start_pass_coef_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: start_pass_dcolor
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_start_pass_dcolor_def@
type T;
identifier F = start_pass_dcolor;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_start_pass_dcolor_def@
F << remove_static_start_pass_dcolor_def.F;
T << remove_static_start_pass_dcolor_def.T;
P << remove_static_start_pass_dcolor_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_start_pass_dcolor_def_void@
identifier F = start_pass_dcolor;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_start_pass_dcolor_def_void@
F << remove_static_start_pass_dcolor_def_void.F;
P << remove_static_start_pass_dcolor_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_start_pass_dcolor_decl@
type T;
identifier F = start_pass_dcolor;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_start_pass_dcolor_decl@
F << remove_static_start_pass_dcolor_decl.F;
T << remove_static_start_pass_dcolor_decl.T;
P << remove_static_start_pass_dcolor_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_start_pass_dcolor_decl_void@
identifier F = start_pass_dcolor;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_start_pass_dcolor_decl_void@
F << remove_static_start_pass_dcolor_decl_void.F;
P << remove_static_start_pass_dcolor_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_start_pass_dcolor_def@
type T;
identifier F = start_pass_dcolor;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_start_pass_dcolor_def@
F << extract_start_pass_dcolor_def.F;
T << extract_start_pass_dcolor_def.T;
P << extract_start_pass_dcolor_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_start_pass_dcolor_def_void@
identifier F = start_pass_dcolor;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_start_pass_dcolor_def_void@
F << extract_start_pass_dcolor_def_void.F;
P << extract_start_pass_dcolor_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_start_pass_dcolor_decl@
type T;
identifier F = start_pass_dcolor;
parameter list P;
@@
T F(P);

@script:python depends on extract_start_pass_dcolor_decl@
F << extract_start_pass_dcolor_decl.F;
T << extract_start_pass_dcolor_decl.T;
P << extract_start_pass_dcolor_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_start_pass_dcolor_decl_void@
identifier F = start_pass_dcolor;
parameter list P;
@@
void F(P);

@script:python depends on extract_start_pass_dcolor_decl_void@
F << extract_start_pass_dcolor_decl_void.F;
P << extract_start_pass_dcolor_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: start_pass_diff
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_start_pass_diff_def@
type T;
identifier F = start_pass_diff;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_start_pass_diff_def@
F << remove_static_start_pass_diff_def.F;
T << remove_static_start_pass_diff_def.T;
P << remove_static_start_pass_diff_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_start_pass_diff_def_void@
identifier F = start_pass_diff;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_start_pass_diff_def_void@
F << remove_static_start_pass_diff_def_void.F;
P << remove_static_start_pass_diff_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_start_pass_diff_decl@
type T;
identifier F = start_pass_diff;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_start_pass_diff_decl@
F << remove_static_start_pass_diff_decl.F;
T << remove_static_start_pass_diff_decl.T;
P << remove_static_start_pass_diff_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_start_pass_diff_decl_void@
identifier F = start_pass_diff;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_start_pass_diff_decl_void@
F << remove_static_start_pass_diff_decl_void.F;
P << remove_static_start_pass_diff_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_start_pass_diff_def@
type T;
identifier F = start_pass_diff;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_start_pass_diff_def@
F << extract_start_pass_diff_def.F;
T << extract_start_pass_diff_def.T;
P << extract_start_pass_diff_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_start_pass_diff_def_void@
identifier F = start_pass_diff;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_start_pass_diff_def_void@
F << extract_start_pass_diff_def_void.F;
P << extract_start_pass_diff_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_start_pass_diff_decl@
type T;
identifier F = start_pass_diff;
parameter list P;
@@
T F(P);

@script:python depends on extract_start_pass_diff_decl@
F << extract_start_pass_diff_decl.F;
T << extract_start_pass_diff_decl.T;
P << extract_start_pass_diff_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_start_pass_diff_decl_void@
identifier F = start_pass_diff;
parameter list P;
@@
void F(P);

@script:python depends on extract_start_pass_diff_decl_void@
F << extract_start_pass_diff_decl_void.F;
P << extract_start_pass_diff_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: start_pass_downsample
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_start_pass_downsample_def@
type T;
identifier F = start_pass_downsample;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_start_pass_downsample_def@
F << remove_static_start_pass_downsample_def.F;
T << remove_static_start_pass_downsample_def.T;
P << remove_static_start_pass_downsample_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_start_pass_downsample_def_void@
identifier F = start_pass_downsample;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_start_pass_downsample_def_void@
F << remove_static_start_pass_downsample_def_void.F;
P << remove_static_start_pass_downsample_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_start_pass_downsample_decl@
type T;
identifier F = start_pass_downsample;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_start_pass_downsample_decl@
F << remove_static_start_pass_downsample_decl.F;
T << remove_static_start_pass_downsample_decl.T;
P << remove_static_start_pass_downsample_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_start_pass_downsample_decl_void@
identifier F = start_pass_downsample;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_start_pass_downsample_decl_void@
F << remove_static_start_pass_downsample_decl_void.F;
P << remove_static_start_pass_downsample_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_start_pass_downsample_def@
type T;
identifier F = start_pass_downsample;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_start_pass_downsample_def@
F << extract_start_pass_downsample_def.F;
T << extract_start_pass_downsample_def.T;
P << extract_start_pass_downsample_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_start_pass_downsample_def_void@
identifier F = start_pass_downsample;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_start_pass_downsample_def_void@
F << extract_start_pass_downsample_def_void.F;
P << extract_start_pass_downsample_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_start_pass_downsample_decl@
type T;
identifier F = start_pass_downsample;
parameter list P;
@@
T F(P);

@script:python depends on extract_start_pass_downsample_decl@
F << extract_start_pass_downsample_decl.F;
T << extract_start_pass_downsample_decl.T;
P << extract_start_pass_downsample_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_start_pass_downsample_decl_void@
identifier F = start_pass_downsample;
parameter list P;
@@
void F(P);

@script:python depends on extract_start_pass_downsample_decl_void@
F << extract_start_pass_downsample_decl_void.F;
P << extract_start_pass_downsample_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: start_pass_dpost
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_start_pass_dpost_def@
type T;
identifier F = start_pass_dpost;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_start_pass_dpost_def@
F << remove_static_start_pass_dpost_def.F;
T << remove_static_start_pass_dpost_def.T;
P << remove_static_start_pass_dpost_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_start_pass_dpost_def_void@
identifier F = start_pass_dpost;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_start_pass_dpost_def_void@
F << remove_static_start_pass_dpost_def_void.F;
P << remove_static_start_pass_dpost_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_start_pass_dpost_decl@
type T;
identifier F = start_pass_dpost;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_start_pass_dpost_decl@
F << remove_static_start_pass_dpost_decl.F;
T << remove_static_start_pass_dpost_decl.T;
P << remove_static_start_pass_dpost_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_start_pass_dpost_decl_void@
identifier F = start_pass_dpost;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_start_pass_dpost_decl_void@
F << remove_static_start_pass_dpost_decl_void.F;
P << remove_static_start_pass_dpost_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_start_pass_dpost_def@
type T;
identifier F = start_pass_dpost;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_start_pass_dpost_def@
F << extract_start_pass_dpost_def.F;
T << extract_start_pass_dpost_def.T;
P << extract_start_pass_dpost_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_start_pass_dpost_def_void@
identifier F = start_pass_dpost;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_start_pass_dpost_def_void@
F << extract_start_pass_dpost_def_void.F;
P << extract_start_pass_dpost_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_start_pass_dpost_decl@
type T;
identifier F = start_pass_dpost;
parameter list P;
@@
T F(P);

@script:python depends on extract_start_pass_dpost_decl@
F << extract_start_pass_dpost_decl.F;
T << extract_start_pass_dpost_decl.T;
P << extract_start_pass_dpost_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_start_pass_dpost_decl_void@
identifier F = start_pass_dpost;
parameter list P;
@@
void F(P);

@script:python depends on extract_start_pass_dpost_decl_void@
F << extract_start_pass_dpost_decl_void.F;
P << extract_start_pass_dpost_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: start_pass_fdctmgr
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_start_pass_fdctmgr_def@
type T;
identifier F = start_pass_fdctmgr;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_start_pass_fdctmgr_def@
F << remove_static_start_pass_fdctmgr_def.F;
T << remove_static_start_pass_fdctmgr_def.T;
P << remove_static_start_pass_fdctmgr_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_start_pass_fdctmgr_def_void@
identifier F = start_pass_fdctmgr;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_start_pass_fdctmgr_def_void@
F << remove_static_start_pass_fdctmgr_def_void.F;
P << remove_static_start_pass_fdctmgr_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_start_pass_fdctmgr_decl@
type T;
identifier F = start_pass_fdctmgr;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_start_pass_fdctmgr_decl@
F << remove_static_start_pass_fdctmgr_decl.F;
T << remove_static_start_pass_fdctmgr_decl.T;
P << remove_static_start_pass_fdctmgr_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_start_pass_fdctmgr_decl_void@
identifier F = start_pass_fdctmgr;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_start_pass_fdctmgr_decl_void@
F << remove_static_start_pass_fdctmgr_decl_void.F;
P << remove_static_start_pass_fdctmgr_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_start_pass_fdctmgr_def@
type T;
identifier F = start_pass_fdctmgr;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_start_pass_fdctmgr_def@
F << extract_start_pass_fdctmgr_def.F;
T << extract_start_pass_fdctmgr_def.T;
P << extract_start_pass_fdctmgr_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_start_pass_fdctmgr_def_void@
identifier F = start_pass_fdctmgr;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_start_pass_fdctmgr_def_void@
F << extract_start_pass_fdctmgr_def_void.F;
P << extract_start_pass_fdctmgr_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_start_pass_fdctmgr_decl@
type T;
identifier F = start_pass_fdctmgr;
parameter list P;
@@
T F(P);

@script:python depends on extract_start_pass_fdctmgr_decl@
F << extract_start_pass_fdctmgr_decl.F;
T << extract_start_pass_fdctmgr_decl.T;
P << extract_start_pass_fdctmgr_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_start_pass_fdctmgr_decl_void@
identifier F = start_pass_fdctmgr;
parameter list P;
@@
void F(P);

@script:python depends on extract_start_pass_fdctmgr_decl_void@
F << extract_start_pass_fdctmgr_decl_void.F;
P << extract_start_pass_fdctmgr_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: start_pass_huff
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_start_pass_huff_def@
type T;
identifier F = start_pass_huff;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_start_pass_huff_def@
F << remove_static_start_pass_huff_def.F;
T << remove_static_start_pass_huff_def.T;
P << remove_static_start_pass_huff_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_start_pass_huff_def_void@
identifier F = start_pass_huff;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_start_pass_huff_def_void@
F << remove_static_start_pass_huff_def_void.F;
P << remove_static_start_pass_huff_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_start_pass_huff_decl@
type T;
identifier F = start_pass_huff;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_start_pass_huff_decl@
F << remove_static_start_pass_huff_decl.F;
T << remove_static_start_pass_huff_decl.T;
P << remove_static_start_pass_huff_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_start_pass_huff_decl_void@
identifier F = start_pass_huff;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_start_pass_huff_decl_void@
F << remove_static_start_pass_huff_decl_void.F;
P << remove_static_start_pass_huff_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_start_pass_huff_def@
type T;
identifier F = start_pass_huff;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_start_pass_huff_def@
F << extract_start_pass_huff_def.F;
T << extract_start_pass_huff_def.T;
P << extract_start_pass_huff_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_start_pass_huff_def_void@
identifier F = start_pass_huff;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_start_pass_huff_def_void@
F << extract_start_pass_huff_def_void.F;
P << extract_start_pass_huff_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_start_pass_huff_decl@
type T;
identifier F = start_pass_huff;
parameter list P;
@@
T F(P);

@script:python depends on extract_start_pass_huff_decl@
F << extract_start_pass_huff_decl.F;
T << extract_start_pass_huff_decl.T;
P << extract_start_pass_huff_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_start_pass_huff_decl_void@
identifier F = start_pass_huff;
parameter list P;
@@
void F(P);

@script:python depends on extract_start_pass_huff_decl_void@
F << extract_start_pass_huff_decl_void.F;
P << extract_start_pass_huff_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: start_pass_huff_decoder
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_start_pass_huff_decoder_def@
type T;
identifier F = start_pass_huff_decoder;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_start_pass_huff_decoder_def@
F << remove_static_start_pass_huff_decoder_def.F;
T << remove_static_start_pass_huff_decoder_def.T;
P << remove_static_start_pass_huff_decoder_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_start_pass_huff_decoder_def_void@
identifier F = start_pass_huff_decoder;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_start_pass_huff_decoder_def_void@
F << remove_static_start_pass_huff_decoder_def_void.F;
P << remove_static_start_pass_huff_decoder_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_start_pass_huff_decoder_decl@
type T;
identifier F = start_pass_huff_decoder;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_start_pass_huff_decoder_decl@
F << remove_static_start_pass_huff_decoder_decl.F;
T << remove_static_start_pass_huff_decoder_decl.T;
P << remove_static_start_pass_huff_decoder_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_start_pass_huff_decoder_decl_void@
identifier F = start_pass_huff_decoder;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_start_pass_huff_decoder_decl_void@
F << remove_static_start_pass_huff_decoder_decl_void.F;
P << remove_static_start_pass_huff_decoder_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_start_pass_huff_decoder_def@
type T;
identifier F = start_pass_huff_decoder;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_start_pass_huff_decoder_def@
F << extract_start_pass_huff_decoder_def.F;
T << extract_start_pass_huff_decoder_def.T;
P << extract_start_pass_huff_decoder_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_start_pass_huff_decoder_def_void@
identifier F = start_pass_huff_decoder;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_start_pass_huff_decoder_def_void@
F << extract_start_pass_huff_decoder_def_void.F;
P << extract_start_pass_huff_decoder_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_start_pass_huff_decoder_decl@
type T;
identifier F = start_pass_huff_decoder;
parameter list P;
@@
T F(P);

@script:python depends on extract_start_pass_huff_decoder_decl@
F << extract_start_pass_huff_decoder_decl.F;
T << extract_start_pass_huff_decoder_decl.T;
P << extract_start_pass_huff_decoder_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_start_pass_huff_decoder_decl_void@
identifier F = start_pass_huff_decoder;
parameter list P;
@@
void F(P);

@script:python depends on extract_start_pass_huff_decoder_decl_void@
F << extract_start_pass_huff_decoder_decl_void.F;
P << extract_start_pass_huff_decoder_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: start_pass_lhuff
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_start_pass_lhuff_def@
type T;
identifier F = start_pass_lhuff;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_start_pass_lhuff_def@
F << remove_static_start_pass_lhuff_def.F;
T << remove_static_start_pass_lhuff_def.T;
P << remove_static_start_pass_lhuff_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_start_pass_lhuff_def_void@
identifier F = start_pass_lhuff;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_start_pass_lhuff_def_void@
F << remove_static_start_pass_lhuff_def_void.F;
P << remove_static_start_pass_lhuff_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_start_pass_lhuff_decl@
type T;
identifier F = start_pass_lhuff;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_start_pass_lhuff_decl@
F << remove_static_start_pass_lhuff_decl.F;
T << remove_static_start_pass_lhuff_decl.T;
P << remove_static_start_pass_lhuff_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_start_pass_lhuff_decl_void@
identifier F = start_pass_lhuff;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_start_pass_lhuff_decl_void@
F << remove_static_start_pass_lhuff_decl_void.F;
P << remove_static_start_pass_lhuff_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_start_pass_lhuff_def@
type T;
identifier F = start_pass_lhuff;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_start_pass_lhuff_def@
F << extract_start_pass_lhuff_def.F;
T << extract_start_pass_lhuff_def.T;
P << extract_start_pass_lhuff_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_start_pass_lhuff_def_void@
identifier F = start_pass_lhuff;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_start_pass_lhuff_def_void@
F << extract_start_pass_lhuff_def_void.F;
P << extract_start_pass_lhuff_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_start_pass_lhuff_decl@
type T;
identifier F = start_pass_lhuff;
parameter list P;
@@
T F(P);

@script:python depends on extract_start_pass_lhuff_decl@
F << extract_start_pass_lhuff_decl.F;
T << extract_start_pass_lhuff_decl.T;
P << extract_start_pass_lhuff_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_start_pass_lhuff_decl_void@
identifier F = start_pass_lhuff;
parameter list P;
@@
void F(P);

@script:python depends on extract_start_pass_lhuff_decl_void@
F << extract_start_pass_lhuff_decl_void.F;
P << extract_start_pass_lhuff_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: start_pass_lhuff_decoder
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_start_pass_lhuff_decoder_def@
type T;
identifier F = start_pass_lhuff_decoder;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_start_pass_lhuff_decoder_def@
F << remove_static_start_pass_lhuff_decoder_def.F;
T << remove_static_start_pass_lhuff_decoder_def.T;
P << remove_static_start_pass_lhuff_decoder_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_start_pass_lhuff_decoder_def_void@
identifier F = start_pass_lhuff_decoder;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_start_pass_lhuff_decoder_def_void@
F << remove_static_start_pass_lhuff_decoder_def_void.F;
P << remove_static_start_pass_lhuff_decoder_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_start_pass_lhuff_decoder_decl@
type T;
identifier F = start_pass_lhuff_decoder;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_start_pass_lhuff_decoder_decl@
F << remove_static_start_pass_lhuff_decoder_decl.F;
T << remove_static_start_pass_lhuff_decoder_decl.T;
P << remove_static_start_pass_lhuff_decoder_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_start_pass_lhuff_decoder_decl_void@
identifier F = start_pass_lhuff_decoder;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_start_pass_lhuff_decoder_decl_void@
F << remove_static_start_pass_lhuff_decoder_decl_void.F;
P << remove_static_start_pass_lhuff_decoder_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_start_pass_lhuff_decoder_def@
type T;
identifier F = start_pass_lhuff_decoder;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_start_pass_lhuff_decoder_def@
F << extract_start_pass_lhuff_decoder_def.F;
T << extract_start_pass_lhuff_decoder_def.T;
P << extract_start_pass_lhuff_decoder_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_start_pass_lhuff_decoder_def_void@
identifier F = start_pass_lhuff_decoder;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_start_pass_lhuff_decoder_def_void@
F << extract_start_pass_lhuff_decoder_def_void.F;
P << extract_start_pass_lhuff_decoder_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_start_pass_lhuff_decoder_decl@
type T;
identifier F = start_pass_lhuff_decoder;
parameter list P;
@@
T F(P);

@script:python depends on extract_start_pass_lhuff_decoder_decl@
F << extract_start_pass_lhuff_decoder_decl.F;
T << extract_start_pass_lhuff_decoder_decl.T;
P << extract_start_pass_lhuff_decoder_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_start_pass_lhuff_decoder_decl_void@
identifier F = start_pass_lhuff_decoder;
parameter list P;
@@
void F(P);

@script:python depends on extract_start_pass_lhuff_decoder_decl_void@
F << extract_start_pass_lhuff_decoder_decl_void.F;
P << extract_start_pass_lhuff_decoder_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: start_pass_lossless
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_start_pass_lossless_def@
type T;
identifier F = start_pass_lossless;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_start_pass_lossless_def@
F << remove_static_start_pass_lossless_def.F;
T << remove_static_start_pass_lossless_def.T;
P << remove_static_start_pass_lossless_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_start_pass_lossless_def_void@
identifier F = start_pass_lossless;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_start_pass_lossless_def_void@
F << remove_static_start_pass_lossless_def_void.F;
P << remove_static_start_pass_lossless_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_start_pass_lossless_decl@
type T;
identifier F = start_pass_lossless;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_start_pass_lossless_decl@
F << remove_static_start_pass_lossless_decl.F;
T << remove_static_start_pass_lossless_decl.T;
P << remove_static_start_pass_lossless_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_start_pass_lossless_decl_void@
identifier F = start_pass_lossless;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_start_pass_lossless_decl_void@
F << remove_static_start_pass_lossless_decl_void.F;
P << remove_static_start_pass_lossless_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_start_pass_lossless_def@
type T;
identifier F = start_pass_lossless;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_start_pass_lossless_def@
F << extract_start_pass_lossless_def.F;
T << extract_start_pass_lossless_def.T;
P << extract_start_pass_lossless_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_start_pass_lossless_def_void@
identifier F = start_pass_lossless;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_start_pass_lossless_def_void@
F << extract_start_pass_lossless_def_void.F;
P << extract_start_pass_lossless_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_start_pass_lossless_decl@
type T;
identifier F = start_pass_lossless;
parameter list P;
@@
T F(P);

@script:python depends on extract_start_pass_lossless_decl@
F << extract_start_pass_lossless_decl.F;
T << extract_start_pass_lossless_decl.T;
P << extract_start_pass_lossless_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_start_pass_lossless_decl_void@
identifier F = start_pass_lossless;
parameter list P;
@@
void F(P);

@script:python depends on extract_start_pass_lossless_decl_void@
F << extract_start_pass_lossless_decl_void.F;
P << extract_start_pass_lossless_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: start_pass_main
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_start_pass_main_def@
type T;
identifier F = start_pass_main;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_start_pass_main_def@
F << remove_static_start_pass_main_def.F;
T << remove_static_start_pass_main_def.T;
P << remove_static_start_pass_main_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_start_pass_main_def_void@
identifier F = start_pass_main;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_start_pass_main_def_void@
F << remove_static_start_pass_main_def_void.F;
P << remove_static_start_pass_main_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_start_pass_main_decl@
type T;
identifier F = start_pass_main;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_start_pass_main_decl@
F << remove_static_start_pass_main_decl.F;
T << remove_static_start_pass_main_decl.T;
P << remove_static_start_pass_main_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_start_pass_main_decl_void@
identifier F = start_pass_main;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_start_pass_main_decl_void@
F << remove_static_start_pass_main_decl_void.F;
P << remove_static_start_pass_main_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_start_pass_main_def@
type T;
identifier F = start_pass_main;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_start_pass_main_def@
F << extract_start_pass_main_def.F;
T << extract_start_pass_main_def.T;
P << extract_start_pass_main_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_start_pass_main_def_void@
identifier F = start_pass_main;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_start_pass_main_def_void@
F << extract_start_pass_main_def_void.F;
P << extract_start_pass_main_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_start_pass_main_decl@
type T;
identifier F = start_pass_main;
parameter list P;
@@
T F(P);

@script:python depends on extract_start_pass_main_decl@
F << extract_start_pass_main_decl.F;
T << extract_start_pass_main_decl.T;
P << extract_start_pass_main_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_start_pass_main_decl_void@
identifier F = start_pass_main;
parameter list P;
@@
void F(P);

@script:python depends on extract_start_pass_main_decl_void@
F << extract_start_pass_main_decl_void.F;
P << extract_start_pass_main_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: start_pass_merged_upsample
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_start_pass_merged_upsample_def@
type T;
identifier F = start_pass_merged_upsample;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_start_pass_merged_upsample_def@
F << remove_static_start_pass_merged_upsample_def.F;
T << remove_static_start_pass_merged_upsample_def.T;
P << remove_static_start_pass_merged_upsample_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_start_pass_merged_upsample_def_void@
identifier F = start_pass_merged_upsample;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_start_pass_merged_upsample_def_void@
F << remove_static_start_pass_merged_upsample_def_void.F;
P << remove_static_start_pass_merged_upsample_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_start_pass_merged_upsample_decl@
type T;
identifier F = start_pass_merged_upsample;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_start_pass_merged_upsample_decl@
F << remove_static_start_pass_merged_upsample_decl.F;
T << remove_static_start_pass_merged_upsample_decl.T;
P << remove_static_start_pass_merged_upsample_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_start_pass_merged_upsample_decl_void@
identifier F = start_pass_merged_upsample;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_start_pass_merged_upsample_decl_void@
F << remove_static_start_pass_merged_upsample_decl_void.F;
P << remove_static_start_pass_merged_upsample_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_start_pass_merged_upsample_def@
type T;
identifier F = start_pass_merged_upsample;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_start_pass_merged_upsample_def@
F << extract_start_pass_merged_upsample_def.F;
T << extract_start_pass_merged_upsample_def.T;
P << extract_start_pass_merged_upsample_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_start_pass_merged_upsample_def_void@
identifier F = start_pass_merged_upsample;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_start_pass_merged_upsample_def_void@
F << extract_start_pass_merged_upsample_def_void.F;
P << extract_start_pass_merged_upsample_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_start_pass_merged_upsample_decl@
type T;
identifier F = start_pass_merged_upsample;
parameter list P;
@@
T F(P);

@script:python depends on extract_start_pass_merged_upsample_decl@
F << extract_start_pass_merged_upsample_decl.F;
T << extract_start_pass_merged_upsample_decl.T;
P << extract_start_pass_merged_upsample_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_start_pass_merged_upsample_decl_void@
identifier F = start_pass_merged_upsample;
parameter list P;
@@
void F(P);

@script:python depends on extract_start_pass_merged_upsample_decl_void@
F << extract_start_pass_merged_upsample_decl_void.F;
P << extract_start_pass_merged_upsample_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: start_pass_phuff
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_start_pass_phuff_def@
type T;
identifier F = start_pass_phuff;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_start_pass_phuff_def@
F << remove_static_start_pass_phuff_def.F;
T << remove_static_start_pass_phuff_def.T;
P << remove_static_start_pass_phuff_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_start_pass_phuff_def_void@
identifier F = start_pass_phuff;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_start_pass_phuff_def_void@
F << remove_static_start_pass_phuff_def_void.F;
P << remove_static_start_pass_phuff_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_start_pass_phuff_decl@
type T;
identifier F = start_pass_phuff;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_start_pass_phuff_decl@
F << remove_static_start_pass_phuff_decl.F;
T << remove_static_start_pass_phuff_decl.T;
P << remove_static_start_pass_phuff_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_start_pass_phuff_decl_void@
identifier F = start_pass_phuff;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_start_pass_phuff_decl_void@
F << remove_static_start_pass_phuff_decl_void.F;
P << remove_static_start_pass_phuff_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_start_pass_phuff_def@
type T;
identifier F = start_pass_phuff;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_start_pass_phuff_def@
F << extract_start_pass_phuff_def.F;
T << extract_start_pass_phuff_def.T;
P << extract_start_pass_phuff_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_start_pass_phuff_def_void@
identifier F = start_pass_phuff;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_start_pass_phuff_def_void@
F << extract_start_pass_phuff_def_void.F;
P << extract_start_pass_phuff_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_start_pass_phuff_decl@
type T;
identifier F = start_pass_phuff;
parameter list P;
@@
T F(P);

@script:python depends on extract_start_pass_phuff_decl@
F << extract_start_pass_phuff_decl.F;
T << extract_start_pass_phuff_decl.T;
P << extract_start_pass_phuff_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_start_pass_phuff_decl_void@
identifier F = start_pass_phuff;
parameter list P;
@@
void F(P);

@script:python depends on extract_start_pass_phuff_decl_void@
F << extract_start_pass_phuff_decl_void.F;
P << extract_start_pass_phuff_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: start_pass_phuff_decoder
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_start_pass_phuff_decoder_def@
type T;
identifier F = start_pass_phuff_decoder;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_start_pass_phuff_decoder_def@
F << remove_static_start_pass_phuff_decoder_def.F;
T << remove_static_start_pass_phuff_decoder_def.T;
P << remove_static_start_pass_phuff_decoder_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_start_pass_phuff_decoder_def_void@
identifier F = start_pass_phuff_decoder;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_start_pass_phuff_decoder_def_void@
F << remove_static_start_pass_phuff_decoder_def_void.F;
P << remove_static_start_pass_phuff_decoder_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_start_pass_phuff_decoder_decl@
type T;
identifier F = start_pass_phuff_decoder;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_start_pass_phuff_decoder_decl@
F << remove_static_start_pass_phuff_decoder_decl.F;
T << remove_static_start_pass_phuff_decoder_decl.T;
P << remove_static_start_pass_phuff_decoder_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_start_pass_phuff_decoder_decl_void@
identifier F = start_pass_phuff_decoder;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_start_pass_phuff_decoder_decl_void@
F << remove_static_start_pass_phuff_decoder_decl_void.F;
P << remove_static_start_pass_phuff_decoder_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_start_pass_phuff_decoder_def@
type T;
identifier F = start_pass_phuff_decoder;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_start_pass_phuff_decoder_def@
F << extract_start_pass_phuff_decoder_def.F;
T << extract_start_pass_phuff_decoder_def.T;
P << extract_start_pass_phuff_decoder_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_start_pass_phuff_decoder_def_void@
identifier F = start_pass_phuff_decoder;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_start_pass_phuff_decoder_def_void@
F << extract_start_pass_phuff_decoder_def_void.F;
P << extract_start_pass_phuff_decoder_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_start_pass_phuff_decoder_decl@
type T;
identifier F = start_pass_phuff_decoder;
parameter list P;
@@
T F(P);

@script:python depends on extract_start_pass_phuff_decoder_decl@
F << extract_start_pass_phuff_decoder_decl.F;
T << extract_start_pass_phuff_decoder_decl.T;
P << extract_start_pass_phuff_decoder_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_start_pass_phuff_decoder_decl_void@
identifier F = start_pass_phuff_decoder;
parameter list P;
@@
void F(P);

@script:python depends on extract_start_pass_phuff_decoder_decl_void@
F << extract_start_pass_phuff_decoder_decl_void.F;
P << extract_start_pass_phuff_decoder_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: start_pass_prep
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_start_pass_prep_def@
type T;
identifier F = start_pass_prep;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_start_pass_prep_def@
F << remove_static_start_pass_prep_def.F;
T << remove_static_start_pass_prep_def.T;
P << remove_static_start_pass_prep_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_start_pass_prep_def_void@
identifier F = start_pass_prep;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_start_pass_prep_def_void@
F << remove_static_start_pass_prep_def_void.F;
P << remove_static_start_pass_prep_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_start_pass_prep_decl@
type T;
identifier F = start_pass_prep;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_start_pass_prep_decl@
F << remove_static_start_pass_prep_decl.F;
T << remove_static_start_pass_prep_decl.T;
P << remove_static_start_pass_prep_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_start_pass_prep_decl_void@
identifier F = start_pass_prep;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_start_pass_prep_decl_void@
F << remove_static_start_pass_prep_decl_void.F;
P << remove_static_start_pass_prep_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_start_pass_prep_def@
type T;
identifier F = start_pass_prep;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_start_pass_prep_def@
F << extract_start_pass_prep_def.F;
T << extract_start_pass_prep_def.T;
P << extract_start_pass_prep_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_start_pass_prep_def_void@
identifier F = start_pass_prep;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_start_pass_prep_def_void@
F << extract_start_pass_prep_def_void.F;
P << extract_start_pass_prep_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_start_pass_prep_decl@
type T;
identifier F = start_pass_prep;
parameter list P;
@@
T F(P);

@script:python depends on extract_start_pass_prep_decl@
F << extract_start_pass_prep_decl.F;
T << extract_start_pass_prep_decl.T;
P << extract_start_pass_prep_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_start_pass_prep_decl_void@
identifier F = start_pass_prep;
parameter list P;
@@
void F(P);

@script:python depends on extract_start_pass_prep_decl_void@
F << extract_start_pass_prep_decl_void.F;
P << extract_start_pass_prep_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: start_pass_upsample
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_start_pass_upsample_def@
type T;
identifier F = start_pass_upsample;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_start_pass_upsample_def@
F << remove_static_start_pass_upsample_def.F;
T << remove_static_start_pass_upsample_def.T;
P << remove_static_start_pass_upsample_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_start_pass_upsample_def_void@
identifier F = start_pass_upsample;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_start_pass_upsample_def_void@
F << remove_static_start_pass_upsample_def_void.F;
P << remove_static_start_pass_upsample_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_start_pass_upsample_decl@
type T;
identifier F = start_pass_upsample;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_start_pass_upsample_decl@
F << remove_static_start_pass_upsample_decl.F;
T << remove_static_start_pass_upsample_decl.T;
P << remove_static_start_pass_upsample_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_start_pass_upsample_decl_void@
identifier F = start_pass_upsample;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_start_pass_upsample_decl_void@
F << remove_static_start_pass_upsample_decl_void.F;
P << remove_static_start_pass_upsample_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_start_pass_upsample_def@
type T;
identifier F = start_pass_upsample;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_start_pass_upsample_def@
F << extract_start_pass_upsample_def.F;
T << extract_start_pass_upsample_def.T;
P << extract_start_pass_upsample_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_start_pass_upsample_def_void@
identifier F = start_pass_upsample;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_start_pass_upsample_def_void@
F << extract_start_pass_upsample_def_void.F;
P << extract_start_pass_upsample_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_start_pass_upsample_decl@
type T;
identifier F = start_pass_upsample;
parameter list P;
@@
T F(P);

@script:python depends on extract_start_pass_upsample_decl@
F << extract_start_pass_upsample_decl.F;
T << extract_start_pass_upsample_decl.T;
P << extract_start_pass_upsample_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_start_pass_upsample_decl_void@
identifier F = start_pass_upsample;
parameter list P;
@@
void F(P);

@script:python depends on extract_start_pass_upsample_decl_void@
F << extract_start_pass_upsample_decl_void.F;
P << extract_start_pass_upsample_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Rules for function: term_mem_destination
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_term_mem_destination_def@
type T;
identifier F = term_mem_destination;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_term_mem_destination_def@
F << remove_static_term_mem_destination_def.F;
T << remove_static_term_mem_destination_def.T;
P << remove_static_term_mem_destination_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_term_mem_destination_def_void@
identifier F = term_mem_destination;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_term_mem_destination_def_void@
F << remove_static_term_mem_destination_def_void.F;
P << remove_static_term_mem_destination_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_term_mem_destination_decl@
type T;
identifier F = term_mem_destination;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_term_mem_destination_decl@
F << remove_static_term_mem_destination_decl.F;
T << remove_static_term_mem_destination_decl.T;
P << remove_static_term_mem_destination_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_term_mem_destination_decl_void@
identifier F = term_mem_destination;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_term_mem_destination_decl_void@
F << remove_static_term_mem_destination_decl_void.F;
P << remove_static_term_mem_destination_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_term_mem_destination_def@
type T;
identifier F = term_mem_destination;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_term_mem_destination_def@
F << extract_term_mem_destination_def.F;
T << extract_term_mem_destination_def.T;
P << extract_term_mem_destination_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_term_mem_destination_def_void@
identifier F = term_mem_destination;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_term_mem_destination_def_void@
F << extract_term_mem_destination_def_void.F;
P << extract_term_mem_destination_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_term_mem_destination_decl@
type T;
identifier F = term_mem_destination;
parameter list P;
@@
T F(P);

@script:python depends on extract_term_mem_destination_decl@
F << extract_term_mem_destination_decl.F;
T << extract_term_mem_destination_decl.T;
P << extract_term_mem_destination_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_term_mem_destination_decl_void@
identifier F = term_mem_destination;
parameter list P;
@@
void F(P);

@script:python depends on extract_term_mem_destination_decl_void@
F << extract_term_mem_destination_decl_void.F;
P << extract_term_mem_destination_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// ============================================================
// Consolidation Script
// ============================================================

@script:python@
@@
import os
import glob

print("\n>>> CONSOLIDATING FUNCTION DECLARATIONS")

target_functions = ["_jpeg_fdct_ifast", "_jpeg_fdct_islow", "calc_buffer_dimensions_gif", "calc_buffer_dimensions_ppm", "calc_buffer_dimensions_tga", "compress_output", "compress_output_12", "consume_markers", "convsamp_float", "copy_pixel_rows", "decode_mcu_AC_first", "decode_mcu_AC_refine", "decode_mcu_DC_first", "decode_mcu_DC_refine", "dummy_consume_data", "empty_mem_output_buffer", "encode_mcu_AC_first", "encode_mcu_AC_first_prepare", "encode_mcu_AC_refine", "encode_mcu_AC_refine_prepare", "encode_mcu_DC_first", "encode_mcu_DC_refine", "encode_mcu_gather", "encode_mcu_huff", "encode_mcus_gather", "encode_mcus_huff", "fill_mem_input_buffer", "finish_input_bmp", "finish_input_gif", "finish_input_ppm", "finish_input_tga", "finish_output_bmp", "finish_output_gif", "finish_output_ppm", "finish_output_tga", "finish_pass1", "finish_pass2", "finish_pass_1_quant", "finish_pass_gather", "finish_pass_gather_phuff", "finish_pass_huff", "finish_pass_master", "finish_pass_phuff", "fuzzer_emit_message", "fuzzer_error_exit", "get_16bit_row", "get_24bit_row", "get_32bit_row", "get_8bit_gray_row", "get_8bit_row", "get_gray_cmyk_row", "get_gray_rgb_row", "get_interlaced_row", "get_memory_row", "get_raw_row", "get_rgb_cmyk_row", "get_rgb_row", "get_scaled_gray_row", "get_text_gray_cmyk_row", "get_text_gray_rgb_row", "get_text_gray_row", "get_text_rgb_cmyk_row", "get_text_rgb_row", "get_word_gray_cmyk_row", "get_word_gray_rgb_row", "get_word_gray_row", "get_word_rgb_cmyk_row", "get_word_rgb_row", "h2v1_merged_upsample", "h2v1_merged_upsample_565", "h2v1_merged_upsample_565D", "h2v2_merged_upsample", "h2v2_merged_upsample_565", "h2v2_merged_upsample_565D", "init_mem_destination", "init_mem_source", "jpeg_resync_to_restart", "jsimd_convsamp", "jsimd_convsamp_float", "jsimd_encode_mcu_AC_first_prepare", "jsimd_encode_mcu_AC_refine_prepare", "jsimd_fdct_ifast", "jsimd_fdct_islow", "jsimd_h2v1_merged_upsample", "jsimd_h2v2_merged_upsample", "jsimd_quantize", "jsimd_quantize_float", "load_interlaced_image", "my_emit_message", "my_error_exit", "my_output_message", "my_progress_monitor", "my_read_markers", "my_reset_marker_reader", "new_color_map_1_quant", "new_color_map_2_quant", "noscale", "null_method", "old_read_markers", "old_reset_marker_reader", "preload_image", "print_text_marker", "processor", "put_LZW_pixel_rows", "put_cmyk", "put_demapped_gray", "put_demapped_rgb", "put_gray_rows", "put_raw_pixel_rows", "put_rgb", "quantize_float", "read_non_rle_pixel", "read_rle_pixel", "rgb_ycc_start", "simple_downscale", "simple_upscale", "skip_variable", "start_input_bmp", "start_input_gif", "start_input_ppm", "start_input_tga", "start_output_bmp", "start_output_gif", "start_output_ppm", "start_output_tga", "start_pass_1_quant", "start_pass_2_quant", "start_pass_coef", "start_pass_dcolor", "start_pass_diff", "start_pass_downsample", "start_pass_dpost", "start_pass_fdctmgr", "start_pass_huff", "start_pass_huff_decoder", "start_pass_lhuff", "start_pass_lhuff_decoder", "start_pass_lossless", "start_pass_main", "start_pass_merged_upsample", "start_pass_phuff", "start_pass_phuff_decoder", "start_pass_prep", "start_pass_upsample", "term_mem_destination"]

def_files = glob.glob("definitions/*.txt")
if not def_files:
    print(">>> No function declarations found to consolidate")
else:
    print(">>> Found %d function declarations" % len(def_files))
    
    # Read all declarations
    declarations = {}
    for def_file in sorted(def_files):
        func_name = os.path.basename(def_file).replace('.txt', '')
        try:
            with open(def_file, 'r') as f:
                signature = f.read().strip()
            declarations[func_name] = signature
        except Exception as e:
            print(">>> [ERROR] Failed to read %s: %s" % (def_file, e))
    
    # Write consolidated header file
    header_path = "extracted_declarations.h"
    try:
        with open(header_path, 'w') as f:
            f.write("/* Extracted function declarations */\n")
            f.write("/* Generated by Coccinelle script */\n")
            f.write("/* Static keyword removed where applicable */\n\n")
            f.write("#ifndef EXTRACTED_DECLARATIONS_H\n")
            f.write("#define EXTRACTED_DECLARATIONS_H\n\n")
            
            # Write declarations in sorted order
            for func_name in sorted(declarations.keys()):
                f.write(declarations[func_name] + "\n")
            
            f.write("\n#endif /* EXTRACTED_DECLARATIONS_H */\n")
        
        print(">>> Successfully created header: %s" % header_path)
        print(">>> Total declarations extracted: %d" % len(declarations))
        
        # Report missing functions
        missing = [f for f in target_functions if f not in declarations]
        if missing:
            print(">>> Missing declarations: %d" % len(missing))
            for m in missing[:10]:
                print(">>>   - %s" % m)
            if len(missing) > 10:
                print(">>>   ... and %d more" % (len(missing) - 10))
            
    except Exception as e:
        print(">>> [ERROR] Failed to create header: %s" % e)

print(">>> Consolidation complete")

@finalize:python@
@@
print("\n>>> PROCESSING COMPLETE")
print(">>> Total target functions: 145")
print(">>> Successfully extracted: %d" % len(processed_functions))
print(">>> Individual declarations: definitions/*.txt")
print(">>> Consolidated header: extracted_declarations.h")
