// Auto-generated Coccinelle script for function pointer call transformation
// Generated from JSON input
// 
// Special handling:
//   - Functions starting with 'x' are replaced with fp_name itself
//   - Functions in remove list are excluded
//
// Patterns:
//   1. return E->fp_name(args);
//   2. return E.fp_name(args);
//   3. E1 = E2->fp_name(args);
//   4. E1 = E2.fp_name(args);
//   5. E->fp_name(args);
//   6. E.fp_name(args);
//
// Usage: spatch --sp-file transform.cocci --dir <source_dir> --in-place

// ===== RETURN ARROW TRANSFORMATION RULES =====
// Pattern: return E->fp_name(args);


// FP: aggregate_context
// Candidates: sqlite3_aggregate_context

@transform_return_aggregate_context_arrow@
expression E;
identifier FP_NAME = aggregate_context;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_aggregate_context(args);


// FP: auto_extension
// Candidates: sqlite3_vtab_config

@transform_return_auto_extension_arrow@
expression E;
identifier FP_NAME = auto_extension;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_vtab_config(args);


// FP: backup_finish
// Candidates: sqlite3_result_error_code

@transform_return_backup_finish_arrow@
expression E;
identifier FP_NAME = backup_finish;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_result_error_code(args);


// FP: backup_init
// Candidates: sqlite3_test_control

@transform_return_backup_init_arrow@
expression E;
identifier FP_NAME = backup_init;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_test_control(args);


// FP: backup_pagecount
// Candidates: sqlite3_randomness

@transform_return_backup_pagecount_arrow@
expression E;
identifier FP_NAME = backup_pagecount;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_randomness(args);


// FP: backup_remaining
// Candidates: sqlite3_context_db_handle

@transform_return_backup_remaining_arrow@
expression E;
identifier FP_NAME = backup_remaining;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_context_db_handle(args);


// FP: backup_step
// Candidates: sqlite3_extended_result_codes

@transform_return_backup_step_arrow@
expression E;
identifier FP_NAME = backup_step;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_extended_result_codes(args);


// FP: bind_blob64
// Candidates: sqlite3_vtab_on_conflict

@transform_return_bind_blob64_arrow@
expression E;
identifier FP_NAME = bind_blob64;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_vtab_on_conflict(args);


// FP: bind_int
// Candidates: sqlite3_bind_double

@transform_return_bind_int_arrow@
expression E;
identifier FP_NAME = bind_int;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_bind_double(args);


// FP: bind_int64
// Candidates: sqlite3_bind_int

@transform_return_bind_int64_arrow@
expression E;
identifier FP_NAME = bind_int64;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_bind_int(args);


// FP: bind_null
// Candidates: sqlite3_bind_int64

@transform_return_bind_null_arrow@
expression E;
identifier FP_NAME = bind_null;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_bind_int64(args);


// FP: bind_parameter_count
// Candidates: sqlite3_bind_null

@transform_return_bind_parameter_count_arrow@
expression E;
identifier FP_NAME = bind_parameter_count;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_bind_null(args);


// FP: bind_parameter_index
// Candidates: sqlite3_bind_parameter_count

@transform_return_bind_parameter_index_arrow@
expression E;
identifier FP_NAME = bind_parameter_index;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_bind_parameter_count(args);


// FP: bind_parameter_name
// Candidates: sqlite3_bind_parameter_index

@transform_return_bind_parameter_name_arrow@
expression E;
identifier FP_NAME = bind_parameter_name;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_bind_parameter_index(args);


// FP: bind_text
// Candidates: sqlite3_bind_parameter_name

@transform_return_bind_text_arrow@
expression E;
identifier FP_NAME = bind_text;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_bind_parameter_name(args);


// FP: bind_text16
// Candidates: sqlite3_bind_text

@transform_return_bind_text16_arrow@
expression E;
identifier FP_NAME = bind_text16;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_bind_text(args);


// FP: bind_text64
// Candidates: sqlite3_close_v2

@transform_return_bind_text64_arrow@
expression E;
identifier FP_NAME = bind_text64;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_close_v2(args);


// FP: bind_value
// Candidates: sqlite3_bind_text16

@transform_return_bind_value_arrow@
expression E;
identifier FP_NAME = bind_value;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_bind_text16(args);


// FP: bind_zeroblob
// Candidates: sqlite3_prepare_v2

@transform_return_bind_zeroblob_arrow@
expression E;
identifier FP_NAME = bind_zeroblob;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_prepare_v2(args);


// FP: bind_zeroblob64
// Candidates: sqlite3_auto_extension

@transform_return_bind_zeroblob64_arrow@
expression E;
identifier FP_NAME = bind_zeroblob64;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_auto_extension(args);


// FP: blob_bytes
// Candidates: sqlite3_prepare16_v2

@transform_return_blob_bytes_arrow@
expression E;
identifier FP_NAME = blob_bytes;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_prepare16_v2(args);


// FP: blob_close
// Candidates: sqlite3_clear_bindings

@transform_return_blob_close_arrow@
expression E;
identifier FP_NAME = blob_close;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_clear_bindings(args);


// FP: blob_open
// Candidates: sqlite3_create_module_v2

@transform_return_blob_open_arrow@
expression E;
identifier FP_NAME = blob_open;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_create_module_v2(args);


// FP: blob_read
// Candidates: sqlite3_bind_zeroblob

@transform_return_blob_read_arrow@
expression E;
identifier FP_NAME = blob_read;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_bind_zeroblob(args);


// FP: blob_reopen
// Candidates: sqlite3_db_status

@transform_return_blob_reopen_arrow@
expression E;
identifier FP_NAME = blob_reopen;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_db_status(args);


// FP: blob_write
// Candidates: sqlite3_blob_bytes

@transform_return_blob_write_arrow@
expression E;
identifier FP_NAME = blob_write;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_blob_bytes(args);


// FP: busy_handler
// Candidates: sqlite3_bind_value

@transform_return_busy_handler_arrow@
expression E;
identifier FP_NAME = busy_handler;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_bind_value(args);


// FP: busy_timeout
// Candidates: sqlite3_busy_handler

@transform_return_busy_timeout_arrow@
expression E;
identifier FP_NAME = busy_timeout;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_busy_handler(args);


// FP: cancel_auto_extension
// Candidates: sqlite3_db_filename

@transform_return_cancel_auto_extension_arrow@
expression E;
identifier FP_NAME = cancel_auto_extension;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_db_filename(args);


// FP: changes
// Candidates: sqlite3_busy_timeout

@transform_return_changes_arrow@
expression E;
identifier FP_NAME = changes;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_busy_timeout(args);


// FP: changes64
// Candidates: sqlite3_str_value

@transform_return_changes64_arrow@
expression E;
identifier FP_NAME = changes64;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_str_value(args);


// FP: clear_bindings
// Candidates: sqlite3_vmprintf

@transform_return_clear_bindings_arrow@
expression E;
identifier FP_NAME = clear_bindings;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_vmprintf(args);


// FP: close
// Candidates: sqlite3_changes

@transform_return_close_arrow@
expression E;
identifier FP_NAME = close;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_changes(args);


// FP: close_v2
// Candidates: sqlite3_soft_heap_limit64

@transform_return_close_v2_arrow@
expression E;
identifier FP_NAME = close_v2;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_soft_heap_limit64(args);


// FP: collation_needed
// Candidates: sqlite3_close

@transform_return_collation_needed_arrow@
expression E;
identifier FP_NAME = collation_needed;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_close(args);


// FP: collation_needed16
// Candidates: sqlite3_collation_needed

@transform_return_collation_needed16_arrow@
expression E;
identifier FP_NAME = collation_needed16;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_collation_needed(args);


// FP: column_blob
// Candidates: sqlite3_collation_needed16

@transform_return_column_blob_arrow@
expression E;
identifier FP_NAME = column_blob;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_collation_needed16(args);


// FP: column_bytes
// Candidates: sqlite3_column_blob

@transform_return_column_bytes_arrow@
expression E;
identifier FP_NAME = column_bytes;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_column_blob(args);


// FP: column_bytes16
// Candidates: sqlite3_column_bytes

@transform_return_column_bytes16_arrow@
expression E;
identifier FP_NAME = column_bytes16;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_column_bytes(args);


// FP: column_count
// Candidates: sqlite3_column_bytes16

@transform_return_column_count_arrow@
expression E;
identifier FP_NAME = column_count;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_column_bytes16(args);


// FP: column_database_name
// Candidates: sqlite3_column_count

@transform_return_column_database_name_arrow@
expression E;
identifier FP_NAME = column_database_name;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_column_count(args);


// FP: column_database_name16
// Candidates: sqlite3_column_database_name

@transform_return_column_database_name16_arrow@
expression E;
identifier FP_NAME = column_database_name16;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_column_database_name(args);


// FP: column_decltype
// Candidates: sqlite3_column_database_name16

@transform_return_column_decltype_arrow@
expression E;
identifier FP_NAME = column_decltype;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_column_database_name16(args);


// FP: column_decltype16
// Candidates: sqlite3_column_decltype

@transform_return_column_decltype16_arrow@
expression E;
identifier FP_NAME = column_decltype16;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_column_decltype(args);


// FP: column_double
// Candidates: sqlite3_column_decltype16

@transform_return_column_double_arrow@
expression E;
identifier FP_NAME = column_double;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_column_decltype16(args);


// FP: column_int
// Candidates: sqlite3_column_double

@transform_return_column_int_arrow@
expression E;
identifier FP_NAME = column_int;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_column_double(args);


// FP: column_int64
// Candidates: sqlite3_column_int

@transform_return_column_int64_arrow@
expression E;
identifier FP_NAME = column_int64;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_column_int(args);


// FP: column_name
// Candidates: sqlite3_column_int64

@transform_return_column_name_arrow@
expression E;
identifier FP_NAME = column_name;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_column_int64(args);


// FP: column_name16
// Candidates: sqlite3_column_name

@transform_return_column_name16_arrow@
expression E;
identifier FP_NAME = column_name16;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_column_name(args);


// FP: column_origin_name
// Candidates: sqlite3_column_name16

@transform_return_column_origin_name_arrow@
expression E;
identifier FP_NAME = column_origin_name;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_column_name16(args);


// FP: column_origin_name16
// Candidates: sqlite3_column_origin_name

@transform_return_column_origin_name16_arrow@
expression E;
identifier FP_NAME = column_origin_name16;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_column_origin_name(args);


// FP: column_table_name
// Candidates: sqlite3_column_origin_name16

@transform_return_column_table_name_arrow@
expression E;
identifier FP_NAME = column_table_name;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_column_origin_name16(args);


// FP: column_table_name16
// Candidates: sqlite3_column_table_name

@transform_return_column_table_name16_arrow@
expression E;
identifier FP_NAME = column_table_name16;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_column_table_name(args);


// FP: column_text
// Candidates: sqlite3_column_table_name16

@transform_return_column_text_arrow@
expression E;
identifier FP_NAME = column_text;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_column_table_name16(args);


// FP: column_text16
// Candidates: sqlite3_column_text

@transform_return_column_text16_arrow@
expression E;
identifier FP_NAME = column_text16;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_column_text(args);


// FP: column_type
// Candidates: sqlite3_column_text16

@transform_return_column_type_arrow@
expression E;
identifier FP_NAME = column_type;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_column_text16(args);


// FP: column_value
// Candidates: sqlite3_column_type

@transform_return_column_value_arrow@
expression E;
identifier FP_NAME = column_value;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_column_type(args);


// FP: commit_hook
// Candidates: sqlite3_column_value

@transform_return_commit_hook_arrow@
expression E;
identifier FP_NAME = commit_hook;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_column_value(args);


// FP: compileoption_get
// Candidates: sqlite3_limit

@transform_return_compileoption_get_arrow@
expression E;
identifier FP_NAME = compileoption_get;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_limit(args);


// FP: compileoption_used
// Candidates: sqlite3_next_stmt

@transform_return_compileoption_used_arrow@
expression E;
identifier FP_NAME = compileoption_used;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_next_stmt(args);


// FP: complete
// Candidates: sqlite3_commit_hook

@transform_return_complete_arrow@
expression E;
identifier FP_NAME = complete;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_commit_hook(args);


// FP: complete16
// Candidates: sqlite3_complete

@transform_return_complete16_arrow@
expression E;
identifier FP_NAME = complete16;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_complete(args);


// FP: context_db_handle
// Candidates: sqlite3_soft_heap_limit

@transform_return_context_db_handle_arrow@
expression E;
identifier FP_NAME = context_db_handle;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_soft_heap_limit(args);


// FP: create_collation
// Candidates: sqlite3_complete16

@transform_return_create_collation_arrow@
expression E;
identifier FP_NAME = create_collation;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_complete16(args);


// FP: create_collation16
// Candidates: sqlite3_create_collation

@transform_return_create_collation16_arrow@
expression E;
identifier FP_NAME = create_collation16;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_create_collation(args);


// FP: create_collation_v2
// Candidates: sqlite3_blob_close

@transform_return_create_collation_v2_arrow@
expression E;
identifier FP_NAME = create_collation_v2;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_blob_close(args);


// FP: create_filename
// Candidates: sqlite3_str_appendchar

@transform_return_create_filename_arrow@
expression E;
identifier FP_NAME = create_filename;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_str_appendchar(args);


// FP: create_function
// Candidates: sqlite3_create_collation16

@transform_return_create_function_arrow@
expression E;
identifier FP_NAME = create_function;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_create_collation16(args);


// FP: create_function16
// Candidates: sqlite3_create_function

@transform_return_create_function16_arrow@
expression E;
identifier FP_NAME = create_function16;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_create_function(args);


// FP: create_function_v2
// Candidates: sqlite3_sql

@transform_return_create_function_v2_arrow@
expression E;
identifier FP_NAME = create_function_v2;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_sql(args);


// FP: create_module
// Candidates: sqlite3_create_function16

@transform_return_create_module_arrow@
expression E;
identifier FP_NAME = create_module;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_create_function16(args);


// FP: create_module_v2
// Candidates: sqlite3_overload_function

@transform_return_create_module_v2_arrow@
expression E;
identifier FP_NAME = create_module_v2;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_overload_function(args);


// FP: create_window_function
// Candidates: sqlite3_vtab_collation

@transform_return_create_window_function_arrow@
expression E;
identifier FP_NAME = create_window_function;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_vtab_collation(args);


// FP: data_count
// Candidates: sqlite3_create_module

@transform_return_data_count_arrow@
expression E;
identifier FP_NAME = data_count;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_create_module(args);


// FP: database_file_object
// Candidates: sqlite3_str_errcode

@transform_return_database_file_object_arrow@
expression E;
identifier FP_NAME = database_file_object;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_str_errcode(args);


// FP: db_cacheflush
// Candidates: sqlite3_malloc64

@transform_return_db_cacheflush_arrow@
expression E;
identifier FP_NAME = db_cacheflush;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_malloc64(args);


// FP: db_config
// Candidates: sqlite3_status

@transform_return_db_config_arrow@
expression E;
identifier FP_NAME = db_config;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_status(args);


// FP: db_filename
// Candidates: sqlite3_sourceid

@transform_return_db_filename_arrow@
expression E;
identifier FP_NAME = db_filename;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_sourceid(args);


// FP: db_handle
// Candidates: sqlite3_data_count

@transform_return_db_handle_arrow@
expression E;
identifier FP_NAME = db_handle;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_data_count(args);


// FP: db_mutex
// Candidates: sqlite3_backup_finish

@transform_return_db_mutex_arrow@
expression E;
identifier FP_NAME = db_mutex;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_backup_finish(args);


// FP: db_name
// Candidates: sqlite3_filename_journal

@transform_return_db_name_arrow@
expression E;
identifier FP_NAME = db_name;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_filename_journal(args);


// FP: db_readonly
// Candidates: sqlite3_stmt_status

@transform_return_db_readonly_arrow@
expression E;
identifier FP_NAME = db_readonly;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_stmt_status(args);


// FP: db_release_memory
// Candidates: sqlite3_strnicmp

@transform_return_db_release_memory_arrow@
expression E;
identifier FP_NAME = db_release_memory;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_strnicmp(args);


// FP: db_status
// Candidates: sqlite3_backup_init

@transform_return_db_status_arrow@
expression E;
identifier FP_NAME = db_status;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_backup_init(args);


// FP: declare_vtab
// Candidates: sqlite3_db_handle

@transform_return_declare_vtab_arrow@
expression E;
identifier FP_NAME = declare_vtab;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_db_handle(args);


// FP: deserialize
// Candidates: sqlite3_uri_key

@transform_return_deserialize_arrow@
expression E;
identifier FP_NAME = deserialize;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_uri_key(args);


// FP: drop_modules
// Candidates: sqlite3_str_new

@transform_return_drop_modules_arrow@
expression E;
identifier FP_NAME = drop_modules;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_str_new(args);


// FP: enable_shared_cache
// Candidates: sqlite3_declare_vtab

@transform_return_enable_shared_cache_arrow@
expression E;
identifier FP_NAME = enable_shared_cache;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_declare_vtab(args);


// FP: errcode
// Candidates: sqlite3_enable_shared_cache

@transform_return_errcode_arrow@
expression E;
identifier FP_NAME = errcode;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_enable_shared_cache(args);


// FP: errmsg
// Candidates: sqlite3_errcode

@transform_return_errmsg_arrow@
expression E;
identifier FP_NAME = errmsg;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_errcode(args);


// FP: errmsg16
// Candidates: sqlite3_errmsg

@transform_return_errmsg16_arrow@
expression E;
identifier FP_NAME = errmsg16;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_errmsg(args);


// FP: exec
// Candidates: sqlite3_errmsg16

@transform_return_exec_arrow@
expression E;
identifier FP_NAME = exec;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_errmsg16(args);


// FP: expanded_sql
// Candidates: sqlite3_reset_auto_extension

@transform_return_expanded_sql_arrow@
expression E;
identifier FP_NAME = expanded_sql;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_reset_auto_extension(args);


// FP: expired
// Candidates: 0, sqlite3_exec

@transform_return_expired_arrow@
expression E;
identifier FP_NAME = expired;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->expired_signature, expired_signatures[expired_0_enum], sizeof(E->expired_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->expired_signature, expired_signatures[expired_sqlite3_exec_enum], sizeof(E->expired_signature)) == 0) {
+     return sqlite3_exec(args);
+ }


// FP: extended_errcode
// Candidates: sqlite3_backup_pagecount

@transform_return_extended_errcode_arrow@
expression E;
identifier FP_NAME = extended_errcode;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_backup_pagecount(args);


// FP: extended_result_codes
// Candidates: sqlite3_vfs_find

@transform_return_extended_result_codes_arrow@
expression E;
identifier FP_NAME = extended_result_codes;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_vfs_find(args);


// FP: file_control
// Candidates: sqlite3_blob_open

@transform_return_file_control_arrow@
expression E;
identifier FP_NAME = file_control;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_blob_open(args);


// FP: filename_database
// Candidates: sqlite3_str_vappendf

@transform_return_filename_database_arrow@
expression E;
identifier FP_NAME = filename_database;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_str_vappendf(args);


// FP: filename_journal
// Candidates: sqlite3_str_append

@transform_return_filename_journal_arrow@
expression E;
identifier FP_NAME = filename_journal;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_str_append(args);


// FP: filename_wal
// Candidates: sqlite3_str_appendall

@transform_return_filename_wal_arrow@
expression E;
identifier FP_NAME = filename_wal;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_str_appendall(args);


// FP: free_filename
// Candidates: sqlite3_str_reset

@transform_return_free_filename_arrow@
expression E;
identifier FP_NAME = free_filename;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_str_reset(args);


// FP: get_autocommit
// Candidates: sqlite3_free

@transform_return_get_autocommit_arrow@
expression E;
identifier FP_NAME = get_autocommit;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_free(args);


// FP: get_auxdata
// Candidates: sqlite3_free_table

@transform_return_get_auxdata_arrow@
expression E;
identifier FP_NAME = get_auxdata;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_free_table(args);


// FP: get_clientdata
// Candidates: sqlite3_database_file_object

@transform_return_get_clientdata_arrow@
expression E;
identifier FP_NAME = get_clientdata;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_database_file_object(args);


// FP: get_table
// Candidates: sqlite3_get_autocommit

@transform_return_get_table_arrow@
expression E;
identifier FP_NAME = get_table;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_get_autocommit(args);


// FP: global_recover
// Candidates: sqlite3_get_auxdata

@transform_return_global_recover_arrow@
expression E;
identifier FP_NAME = global_recover;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_get_auxdata(args);


// FP: hard_heap_limit64
// Candidates: sqlite3_str_finish

@transform_return_hard_heap_limit64_arrow@
expression E;
identifier FP_NAME = hard_heap_limit64;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_str_finish(args);


// FP: interruptx
// Candidates: sqlite3_get_table

@transform_return_interruptx_arrow@
expression E;
identifier FP_NAME = interruptx;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_get_table(args);


// FP: is_interrupted
// Candidates: sqlite3_create_filename

@transform_return_is_interrupted_arrow@
expression E;
identifier FP_NAME = is_interrupted;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_create_filename(args);


// FP: keyword_check
// Candidates: sqlite3_db_cacheflush

@transform_return_keyword_check_arrow@
expression E;
identifier FP_NAME = keyword_check;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_db_cacheflush(args);


// FP: keyword_count
// Candidates: sqlite3_status64

@transform_return_keyword_count_arrow@
expression E;
identifier FP_NAME = keyword_count;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_status64(args);


// FP: keyword_name
// Candidates: sqlite3_strlike

@transform_return_keyword_name_arrow@
expression E;
identifier FP_NAME = keyword_name;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_strlike(args);


// FP: last_insert_rowid
// Candidates: 0

@transform_return_last_insert_rowid_arrow@
expression E;
identifier FP_NAME = last_insert_rowid;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return 0(args);


// FP: libversion
// Candidates: sqlite3_interrupt

@transform_return_libversion_arrow@
expression E;
identifier FP_NAME = libversion;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_interrupt(args);


// FP: libversion_number
// Candidates: sqlite3_last_insert_rowid

@transform_return_libversion_number_arrow@
expression E;
identifier FP_NAME = libversion_number;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_last_insert_rowid(args);


// FP: limit
// Candidates: sqlite3_vfs_register

@transform_return_limit_arrow@
expression E;
identifier FP_NAME = limit;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_vfs_register(args);


// FP: load_extension
// Candidates: sqlite3_db_readonly

@transform_return_load_extension_arrow@
expression E;
identifier FP_NAME = load_extension;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_db_readonly(args);


// FP: log
// Candidates: sqlite3_backup_remaining

@transform_return_log_arrow@
expression E;
identifier FP_NAME = log;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_backup_remaining(args);


// FP: malloc
// Candidates: sqlite3_libversion

@transform_return_malloc_arrow@
expression E;
identifier FP_NAME = malloc;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_libversion(args);


// FP: malloc64
// Candidates: sqlite3_db_release_memory

@transform_return_malloc64_arrow@
expression E;
identifier FP_NAME = malloc64;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_db_release_memory(args);


// FP: memory_highwater
// Candidates: sqlite3_blob_read

@transform_return_memory_highwater_arrow@
expression E;
identifier FP_NAME = memory_highwater;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_blob_read(args);


// FP: memory_used
// Candidates: sqlite3_blob_write

@transform_return_memory_used_arrow@
expression E;
identifier FP_NAME = memory_used;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_blob_write(args);


// FP: mprintf
// Candidates: sqlite3_libversion_number

@transform_return_mprintf_arrow@
expression E;
identifier FP_NAME = mprintf;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_libversion_number(args);


// FP: msize
// Candidates: sqlite3_errstr

@transform_return_msize_arrow@
expression E;
identifier FP_NAME = msize;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_errstr(args);


// FP: mutex_alloc
// Candidates: sqlite3_create_collation_v2

@transform_return_mutex_alloc_arrow@
expression E;
identifier FP_NAME = mutex_alloc;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_create_collation_v2(args);


// FP: mutex_enter
// Candidates: sqlite3_file_control

@transform_return_mutex_enter_arrow@
expression E;
identifier FP_NAME = mutex_enter;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_file_control(args);


// FP: mutex_free
// Candidates: sqlite3_memory_highwater

@transform_return_mutex_free_arrow@
expression E;
identifier FP_NAME = mutex_free;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_memory_highwater(args);


// FP: mutex_leave
// Candidates: sqlite3_memory_used

@transform_return_mutex_leave_arrow@
expression E;
identifier FP_NAME = mutex_leave;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_memory_used(args);


// FP: next_stmt
// Candidates: sqlite3_vfs_unregister

@transform_return_next_stmt_arrow@
expression E;
identifier FP_NAME = next_stmt;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_vfs_unregister(args);


// FP: normalized_sql
// Candidates: sqlite3_keyword_count

@transform_return_normalized_sql_arrow@
expression E;
identifier FP_NAME = normalized_sql;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_keyword_count(args);


// FP: open
// Candidates: sqlite3_malloc

@transform_return_open_arrow@
expression E;
identifier FP_NAME = open;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_malloc(args);


// FP: open16
// Candidates: sqlite3_mprintf

@transform_return_open16_arrow@
expression E;
identifier FP_NAME = open16;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_mprintf(args);


// FP: open_v2
// Candidates: 0

@transform_return_open_v2_arrow@
expression E;
identifier FP_NAME = open_v2;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return 0(args);


// FP: overload_function
// Candidates: sqlite3_value_text16be

@transform_return_overload_function_arrow@
expression E;
identifier FP_NAME = overload_function;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_value_text16be(args);


// FP: prepare
// Candidates: sqlite3_open

@transform_return_prepare_arrow@
expression E;
identifier FP_NAME = prepare;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_open(args);


// FP: prepare16
// Candidates: sqlite3_open16

@transform_return_prepare16_arrow@
expression E;
identifier FP_NAME = prepare16;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_open16(args);


// FP: prepare16_v2
// Candidates: sqlite3_value_type

@transform_return_prepare16_v2_arrow@
expression E;
identifier FP_NAME = prepare16_v2;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_value_type(args);


// FP: prepare16_v3
// Candidates: sqlite3_strglob

@transform_return_prepare16_v3_arrow@
expression E;
identifier FP_NAME = prepare16_v3;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_strglob(args);


// FP: prepare_v2
// Candidates: sqlite3_value_text16le

@transform_return_prepare_v2_arrow@
expression E;
identifier FP_NAME = prepare_v2;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_value_text16le(args);


// FP: prepare_v3
// Candidates: sqlite3_result_text64

@transform_return_prepare_v3_arrow@
expression E;
identifier FP_NAME = prepare_v3;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_result_text64(args);


// FP: profile
// Candidates: sqlite3_prepare

@transform_return_profile_arrow@
expression E;
identifier FP_NAME = profile;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_prepare(args);


// FP: progress_handler
// Candidates: sqlite3_prepare16

@transform_return_progress_handler_arrow@
expression E;
identifier FP_NAME = progress_handler;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_prepare16(args);


// FP: randomness
// Candidates: sqlite3_sleep

@transform_return_randomness_arrow@
expression E;
identifier FP_NAME = randomness;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_sleep(args);


// FP: realloc
// Candidates: sqlite3_profile

@transform_return_realloc_arrow@
expression E;
identifier FP_NAME = realloc;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_profile(args);


// FP: realloc64
// Candidates: sqlite3_stmt_busy

@transform_return_realloc64_arrow@
expression E;
identifier FP_NAME = realloc64;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_stmt_busy(args);


// FP: release_memory
// Candidates: 0

@transform_return_release_memory_arrow@
expression E;
identifier FP_NAME = release_memory;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return 0(args);


// FP: reset
// Candidates: sqlite3_progress_handler

@transform_return_reset_arrow@
expression E;
identifier FP_NAME = reset;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_progress_handler(args);


// FP: reset_auto_extension
// Candidates: sqlite3_stmt_readonly

@transform_return_reset_auto_extension_arrow@
expression E;
identifier FP_NAME = reset_auto_extension;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_stmt_readonly(args);


// FP: result_blob
// Candidates: sqlite3_realloc

@transform_return_result_blob_arrow@
expression E;
identifier FP_NAME = result_blob;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_realloc(args);


// FP: result_blob64
// Candidates: sqlite3_stricmp

@transform_return_result_blob64_arrow@
expression E;
identifier FP_NAME = result_blob64;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_stricmp(args);


// FP: result_double
// Candidates: sqlite3_reset

@transform_return_result_double_arrow@
expression E;
identifier FP_NAME = result_double;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_reset(args);


// FP: result_error
// Candidates: sqlite3_result_blob

@transform_return_result_error_arrow@
expression E;
identifier FP_NAME = result_error;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_result_blob(args);


// FP: result_error16
// Candidates: sqlite3_result_double

@transform_return_result_error16_arrow@
expression E;
identifier FP_NAME = result_error16;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_result_double(args);


// FP: result_error_code
// Candidates: sqlite3_result_error_nomem

@transform_return_result_error_code_arrow@
expression E;
identifier FP_NAME = result_error_code;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_result_error_nomem(args);


// FP: result_error_nomem
// Candidates: 0

@transform_return_result_error_nomem_arrow@
expression E;
identifier FP_NAME = result_error_nomem;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return 0(args);


// FP: result_error_toobig
// Candidates: 0

@transform_return_result_error_toobig_arrow@
expression E;
identifier FP_NAME = result_error_toobig;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return 0(args);


// FP: result_int
// Candidates: sqlite3_result_error

@transform_return_result_int_arrow@
expression E;
identifier FP_NAME = result_int;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_result_error(args);


// FP: result_int64
// Candidates: sqlite3_result_error16

@transform_return_result_int64_arrow@
expression E;
identifier FP_NAME = result_int64;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_result_error16(args);


// FP: result_null
// Candidates: sqlite3_result_int

@transform_return_result_null_arrow@
expression E;
identifier FP_NAME = result_null;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_result_int(args);


// FP: result_pointer
// Candidates: sqlite3_value_free

@transform_return_result_pointer_arrow@
expression E;
identifier FP_NAME = result_pointer;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_value_free(args);


// FP: result_subtype
// Candidates: sqlite3_bind_text64

@transform_return_result_subtype_arrow@
expression E;
identifier FP_NAME = result_subtype;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_bind_text64(args);


// FP: result_text
// Candidates: sqlite3_result_int64

@transform_return_result_text_arrow@
expression E;
identifier FP_NAME = result_text;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_result_int64(args);


// FP: result_text16
// Candidates: sqlite3_result_null

@transform_return_result_text16_arrow@
expression E;
identifier FP_NAME = result_text16;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_result_null(args);


// FP: result_text16be
// Candidates: sqlite3_result_text

@transform_return_result_text16be_arrow@
expression E;
identifier FP_NAME = result_text16be;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_result_text(args);


// FP: result_text16le
// Candidates: sqlite3_result_text16

@transform_return_result_text16le_arrow@
expression E;
identifier FP_NAME = result_text16le;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_result_text16(args);


// FP: result_text64
// Candidates: sqlite3_uri_boolean

@transform_return_result_text64_arrow@
expression E;
identifier FP_NAME = result_text64;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_uri_boolean(args);


// FP: result_value
// Candidates: sqlite3_result_text16be

@transform_return_result_value_arrow@
expression E;
identifier FP_NAME = result_value;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_result_text16be(args);


// FP: result_zeroblob
// Candidates: sqlite3_release_memory

@transform_return_result_zeroblob_arrow@
expression E;
identifier FP_NAME = result_zeroblob;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_release_memory(args);


// FP: result_zeroblob64
// Candidates: sqlite3_wal_checkpoint_v2

@transform_return_result_zeroblob64_arrow@
expression E;
identifier FP_NAME = result_zeroblob64;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_wal_checkpoint_v2(args);


// FP: rollback_hook
// Candidates: sqlite3_result_text16le

@transform_return_rollback_hook_arrow@
expression E;
identifier FP_NAME = rollback_hook;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_result_text16le(args);


// FP: serialize
// Candidates: sqlite3_filename_database

@transform_return_serialize_arrow@
expression E;
identifier FP_NAME = serialize;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_filename_database(args);


// FP: set_authorizer
// Candidates: sqlite3_result_value

@transform_return_set_authorizer_arrow@
expression E;
identifier FP_NAME = set_authorizer;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_result_value(args);


// FP: set_auxdata
// Candidates: sqlite3_rollback_hook

@transform_return_set_auxdata_arrow@
expression E;
identifier FP_NAME = set_auxdata;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_rollback_hook(args);


// FP: set_clientdata
// Candidates: sqlite3_txn_state

@transform_return_set_clientdata_arrow@
expression E;
identifier FP_NAME = set_clientdata;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_txn_state(args);


// FP: set_errmsg
// Candidates: sqlite3_total_changes64

@transform_return_set_errmsg_arrow@
expression E;
identifier FP_NAME = set_errmsg;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_total_changes64(args);


// FP: set_last_insert_rowid
// Candidates: sqlite3_result_blob64

@transform_return_set_last_insert_rowid_arrow@
expression E;
identifier FP_NAME = set_last_insert_rowid;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_result_blob64(args);


// FP: setlk_timeout
// Candidates: sqlite3_changes64

@transform_return_setlk_timeout_arrow@
expression E;
identifier FP_NAME = setlk_timeout;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_changes64(args);


// FP: soft_heap_limit
// Candidates: sqlite3_mutex_enter

@transform_return_soft_heap_limit_arrow@
expression E;
identifier FP_NAME = soft_heap_limit;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_mutex_enter(args);


// FP: soft_heap_limit64
// Candidates: sqlite3_backup_step

@transform_return_soft_heap_limit64_arrow@
expression E;
identifier FP_NAME = soft_heap_limit64;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_backup_step(args);


// FP: sql
// Candidates: sqlite3_threadsafe

@transform_return_sql_arrow@
expression E;
identifier FP_NAME = sql;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_threadsafe(args);


// FP: status
// Candidates: sqlite3_result_zeroblob

@transform_return_status_arrow@
expression E;
identifier FP_NAME = status;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_result_zeroblob(args);


// FP: status64
// Candidates: sqlite3_cancel_auto_extension

@transform_return_status64_arrow@
expression E;
identifier FP_NAME = status64;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_cancel_auto_extension(args);


// FP: step
// Candidates: sqlite3_set_auxdata

@transform_return_step_arrow@
expression E;
identifier FP_NAME = step;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_set_auxdata(args);


// FP: stmt_explain
// Candidates: sqlite3_free_filename

@transform_return_stmt_explain_arrow@
expression E;
identifier FP_NAME = stmt_explain;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_free_filename(args);


// FP: stmt_isexplain
// Candidates: sqlite3_keyword_name

@transform_return_stmt_isexplain_arrow@
expression E;
identifier FP_NAME = stmt_isexplain;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_keyword_name(args);


// FP: stmt_status
// Candidates: sqlite3_compileoption_used

@transform_return_stmt_status_arrow@
expression E;
identifier FP_NAME = stmt_status;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_compileoption_used(args);


// FP: str_append
// Candidates: sqlite3_prepare_v3

@transform_return_str_append_arrow@
expression E;
identifier FP_NAME = str_append;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_prepare_v3(args);


// FP: str_appendall
// Candidates: sqlite3_prepare16_v3

@transform_return_str_appendall_arrow@
expression E;
identifier FP_NAME = str_appendall;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_prepare16_v3(args);


// FP: str_appendchar
// Candidates: sqlite3_bind_pointer

@transform_return_str_appendchar_arrow@
expression E;
identifier FP_NAME = str_appendchar;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_bind_pointer(args);


// FP: str_appendf
// Candidates: sqlite3_expanded_sql

@transform_return_str_appendf_arrow@
expression E;
identifier FP_NAME = str_appendf;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_expanded_sql(args);


// FP: str_errcode
// Candidates: sqlite3_value_pointer

@transform_return_str_errcode_arrow@
expression E;
identifier FP_NAME = str_errcode;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_value_pointer(args);


// FP: str_finish
// Candidates: sqlite3_trace_v2

@transform_return_str_finish_arrow@
expression E;
identifier FP_NAME = str_finish;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_trace_v2(args);


// FP: str_length
// Candidates: sqlite3_vtab_nochange

@transform_return_str_length_arrow@
expression E;
identifier FP_NAME = str_length;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_vtab_nochange(args);


// FP: str_new
// Candidates: sqlite3_system_errno

@transform_return_str_new_arrow@
expression E;
identifier FP_NAME = str_new;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_system_errno(args);


// FP: str_reset
// Candidates: sqlite3_result_pointer

@transform_return_str_reset_arrow@
expression E;
identifier FP_NAME = str_reset;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_result_pointer(args);


// FP: str_value
// Candidates: sqlite3_value_nochange

@transform_return_str_value_arrow@
expression E;
identifier FP_NAME = str_value;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_value_nochange(args);


// FP: str_vappendf
// Candidates: sqlite3_set_last_insert_rowid

@transform_return_str_vappendf_arrow@
expression E;
identifier FP_NAME = str_vappendf;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_set_last_insert_rowid(args);


// FP: strglob
// Candidates: sqlite3_uri_int64

@transform_return_strglob_arrow@
expression E;
identifier FP_NAME = strglob;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_uri_int64(args);


// FP: stricmp
// Candidates: sqlite3_wal_checkpoint

@transform_return_stricmp_arrow@
expression E;
identifier FP_NAME = stricmp;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_wal_checkpoint(args);


// FP: strlike
// Candidates: sqlite3_load_extension

@transform_return_strlike_arrow@
expression E;
identifier FP_NAME = strlike;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_load_extension(args);


// FP: system_errno
// Candidates: sqlite3_msize

@transform_return_system_errno_arrow@
expression E;
identifier FP_NAME = system_errno;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_msize(args);


// FP: table_column_metadata
// Candidates: sqlite3_snprintf

@transform_return_table_column_metadata_arrow@
expression E;
identifier FP_NAME = table_column_metadata;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_snprintf(args);


// FP: test_control
// Candidates: sqlite3_result_error_toobig

@transform_return_test_control_arrow@
expression E;
identifier FP_NAME = test_control;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_result_error_toobig(args);


// FP: thread_cleanup
// Candidates: sqlite3_step

@transform_return_thread_cleanup_arrow@
expression E;
identifier FP_NAME = thread_cleanup;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_step(args);


// FP: total_changes
// Candidates: sqlite3_table_column_metadata

@transform_return_total_changes_arrow@
expression E;
identifier FP_NAME = total_changes;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_table_column_metadata(args);


// FP: total_changes64
// Candidates: sqlite3_create_window_function

@transform_return_total_changes64_arrow@
expression E;
identifier FP_NAME = total_changes64;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_create_window_function(args);


// FP: trace_v2
// Candidates: sqlite3_realloc64

@transform_return_trace_v2_arrow@
expression E;
identifier FP_NAME = trace_v2;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_realloc64(args);


// FP: txn_state
// Candidates: sqlite3_str_length

@transform_return_txn_state_arrow@
expression E;
identifier FP_NAME = txn_state;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_str_length(args);


// FP: unlock_notify
// Candidates: 0

@transform_return_unlock_notify_arrow@
expression E;
identifier FP_NAME = unlock_notify;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return 0(args);


// FP: uri_boolean
// Candidates: sqlite3_wal_hook

@transform_return_uri_boolean_arrow@
expression E;
identifier FP_NAME = uri_boolean;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_wal_hook(args);


// FP: uri_key
// Candidates: sqlite3_str_appendf

@transform_return_uri_key_arrow@
expression E;
identifier FP_NAME = uri_key;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_str_appendf(args);


// FP: uri_parameter
// Candidates: 0

@transform_return_uri_parameter_arrow@
expression E;
identifier FP_NAME = uri_parameter;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return 0(args);


// FP: user_data
// Candidates: sqlite3_trace

@transform_return_user_data_arrow@
expression E;
identifier FP_NAME = user_data;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_trace(args);


// FP: value_double
// Candidates: sqlite3_user_data

@transform_return_value_double_arrow@
expression E;
identifier FP_NAME = value_double;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_user_data(args);


// FP: value_dup
// Candidates: sqlite3_uri_parameter

@transform_return_value_dup_arrow@
expression E;
identifier FP_NAME = value_dup;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_uri_parameter(args);


// FP: value_encoding
// Candidates: sqlite3_filename_wal

@transform_return_value_encoding_arrow@
expression E;
identifier FP_NAME = value_encoding;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_filename_wal(args);


// FP: value_free
// Candidates: sqlite3_vsnprintf

@transform_return_value_free_arrow@
expression E;
identifier FP_NAME = value_free;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_vsnprintf(args);


// FP: value_frombind
// Candidates: sqlite3_keyword_check

@transform_return_value_frombind_arrow@
expression E;
identifier FP_NAME = value_frombind;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_keyword_check(args);


// FP: value_int
// Candidates: sqlite3_value_blob

@transform_return_value_int_arrow@
expression E;
identifier FP_NAME = value_int;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_value_blob(args);


// FP: value_int64
// Candidates: sqlite3_value_bytes

@transform_return_value_int64_arrow@
expression E;
identifier FP_NAME = value_int64;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_value_bytes(args);


// FP: value_nochange
// Candidates: sqlite3_value_subtype

@transform_return_value_nochange_arrow@
expression E;
identifier FP_NAME = value_nochange;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_value_subtype(args);


// FP: value_numeric_type
// Candidates: sqlite3_value_bytes16

@transform_return_value_numeric_type_arrow@
expression E;
identifier FP_NAME = value_numeric_type;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_value_bytes16(args);


// FP: value_pointer
// Candidates: sqlite3_result_zeroblob64

@transform_return_value_pointer_arrow@
expression E;
identifier FP_NAME = value_pointer;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_result_zeroblob64(args);


// FP: value_subtype
// Candidates: sqlite3_bind_blob64

@transform_return_value_subtype_arrow@
expression E;
identifier FP_NAME = value_subtype;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_bind_blob64(args);


// FP: value_text
// Candidates: sqlite3_value_double

@transform_return_value_text_arrow@
expression E;
identifier FP_NAME = value_text;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_value_double(args);


// FP: value_text16
// Candidates: sqlite3_value_int

@transform_return_value_text16_arrow@
expression E;
identifier FP_NAME = value_text16;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_value_int(args);


// FP: value_text16be
// Candidates: sqlite3_value_int64

@transform_return_value_text16be_arrow@
expression E;
identifier FP_NAME = value_text16be;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_value_int64(args);


// FP: value_text16le
// Candidates: sqlite3_value_numeric_type

@transform_return_value_text16le_arrow@
expression E;
identifier FP_NAME = value_text16le;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_value_numeric_type(args);


// FP: value_type
// Candidates: sqlite3_value_text

@transform_return_value_type_arrow@
expression E;
identifier FP_NAME = value_type;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_value_text(args);


// FP: vfs_find
// Candidates: sqlite3_mutex_free

@transform_return_vfs_find_arrow@
expression E;
identifier FP_NAME = vfs_find;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_mutex_free(args);


// FP: vfs_register
// Candidates: sqlite3_mutex_leave

@transform_return_vfs_register_arrow@
expression E;
identifier FP_NAME = vfs_register;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_mutex_leave(args);


// FP: vfs_unregister
// Candidates: sqlite3_mutex_try

@transform_return_vfs_unregister_arrow@
expression E;
identifier FP_NAME = vfs_unregister;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_mutex_try(args);


// FP: vmprintf
// Candidates: sqlite3_value_text16

@transform_return_vmprintf_arrow@
expression E;
identifier FP_NAME = vmprintf;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_value_text16(args);


// FP: vtab_collation
// Candidates: sqlite3_result_subtype

@transform_return_vtab_collation_arrow@
expression E;
identifier FP_NAME = vtab_collation;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_result_subtype(args);


// FP: vtab_config
// Candidates: sqlite3_extended_errcode

@transform_return_vtab_config_arrow@
expression E;
identifier FP_NAME = vtab_config;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_extended_errcode(args);


// FP: vtab_distinct
// Candidates: sqlite3_value_frombind

@transform_return_vtab_distinct_arrow@
expression E;
identifier FP_NAME = vtab_distinct;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_value_frombind(args);


// FP: vtab_nochange
// Candidates: sqlite3_bind_zeroblob64

@transform_return_vtab_nochange_arrow@
expression E;
identifier FP_NAME = vtab_nochange;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_bind_zeroblob64(args);


// FP: vtab_on_conflict
// Candidates: sqlite3_log

@transform_return_vtab_on_conflict_arrow@
expression E;
identifier FP_NAME = vtab_on_conflict;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_log(args);


// FP: wal_checkpoint
// Candidates: sqlite3_db_config

@transform_return_wal_checkpoint_arrow@
expression E;
identifier FP_NAME = wal_checkpoint;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_db_config(args);


// FP: wal_hook
// Candidates: sqlite3_db_mutex

@transform_return_wal_hook_arrow@
expression E;
identifier FP_NAME = wal_hook;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_db_mutex(args);


// FP: xAccess
// Candidates: apndAccess, memdbAccess, vfstraceAccess, unixAccess

@transform_return_xAccess_arrow@
expression E;
identifier FP_NAME = xAccess;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xAccess_signature, xAccess_signatures[xAccess_apndAccess_enum], sizeof(E->xAccess_signature)) == 0) {
+     return apndAccess(args);
+ }
+ else if (memcmp(E->xAccess_signature, xAccess_signatures[xAccess_memdbAccess_enum], sizeof(E->xAccess_signature)) == 0) {
+     return memdbAccess(args);
+ }
+ else if (memcmp(E->xAccess_signature, xAccess_signatures[xAccess_vfstraceAccess_enum], sizeof(E->xAccess_signature)) == 0) {
+     return vfstraceAccess(args);
+ }
+ else if (memcmp(E->xAccess_signature, xAccess_signatures[xAccess_unixAccess_enum], sizeof(E->xAccess_signature)) == 0) {
+     return unixAccess(args);
+ }


// FP: xAltLocaltime
// Candidates: 0

@transform_return_xAltLocaltime_arrow@
expression E;
identifier FP_NAME = xAltLocaltime;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return 0(args);


// FP: xAutovacDestr
// Candidates: 0, rtreeMatchArgFree, sqlite3VdbeValueListFree

@transform_return_xAutovacDestr_arrow@
expression E;
identifier FP_NAME = xAutovacDestr;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xAutovacDestr_signature, xAutovacDestr_signatures[xAutovacDestr_0_enum], sizeof(E->xAutovacDestr_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xAutovacDestr_signature, xAutovacDestr_signatures[xAutovacDestr_rtreeMatchArgFree_enum], sizeof(E->xAutovacDestr_signature)) == 0) {
+     return rtreeMatchArgFree(args);
+ }
+ else if (memcmp(E->xAutovacDestr_signature, xAutovacDestr_signatures[xAutovacDestr_sqlite3VdbeValueListFree_enum], sizeof(E->xAutovacDestr_signature)) == 0) {
+     return sqlite3VdbeValueListFree(args);
+ }


// FP: xAutovacPages
// Candidates: 0, sql_trace_callback, sqlite3WalDefaultHook

@transform_return_xAutovacPages_arrow@
expression E;
identifier FP_NAME = xAutovacPages;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xAutovacPages_signature, xAutovacPages_signatures[xAutovacPages_0_enum], sizeof(E->xAutovacPages_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xAutovacPages_signature, xAutovacPages_signatures[xAutovacPages_sql_trace_callback_enum], sizeof(E->xAutovacPages_signature)) == 0) {
+     return sql_trace_callback(args);
+ }
+ else if (memcmp(E->xAutovacPages_signature, xAutovacPages_signatures[xAutovacPages_sqlite3WalDefaultHook_enum], sizeof(E->xAutovacPages_signature)) == 0) {
+     return sqlite3WalDefaultHook(args);
+ }


// FP: xBegin
// Candidates: 0, dbpageBegin, fts3BeginMethod, rtreeBeginTransaction, zipfileBegin

@transform_return_xBegin_arrow@
expression E;
identifier FP_NAME = xBegin;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xBegin_signature, xBegin_signatures[xBegin_0_enum], sizeof(E->xBegin_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xBegin_signature, xBegin_signatures[xBegin_dbpageBegin_enum], sizeof(E->xBegin_signature)) == 0) {
+     return dbpageBegin(args);
+ }
+ else if (memcmp(E->xBegin_signature, xBegin_signatures[xBegin_fts3BeginMethod_enum], sizeof(E->xBegin_signature)) == 0) {
+     return fts3BeginMethod(args);
+ }
+ else if (memcmp(E->xBegin_signature, xBegin_signatures[xBegin_rtreeBeginTransaction_enum], sizeof(E->xBegin_signature)) == 0) {
+     return rtreeBeginTransaction(args);
+ }
+ else if (memcmp(E->xBegin_signature, xBegin_signatures[xBegin_zipfileBegin_enum], sizeof(E->xBegin_signature)) == 0) {
+     return zipfileBegin(args);
+ }


// FP: xBestIndex
// Candidates: bytecodevtabBestIndex, completionBestIndex, dbdataBestIndex, dbpageBestIndex, expertBestIndex, fsdirBestIndex, fts3BestIndexMethod, fts3auxBestIndexMethod, fts3tokBestIndexMethod, jsonEachBestIndex, pragmaVtabBestIndex, rtreeBestIndex, seriesBestIndex, statBestIndex, stmtBestIndex, zipfileBestIndex

@transform_return_xBestIndex_arrow@
expression E;
identifier FP_NAME = xBestIndex;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xBestIndex_signature, xBestIndex_signatures[xBestIndex_bytecodevtabBestIndex_enum], sizeof(E->xBestIndex_signature)) == 0) {
+     return bytecodevtabBestIndex(args);
+ }
+ else if (memcmp(E->xBestIndex_signature, xBestIndex_signatures[xBestIndex_completionBestIndex_enum], sizeof(E->xBestIndex_signature)) == 0) {
+     return completionBestIndex(args);
+ }
+ else if (memcmp(E->xBestIndex_signature, xBestIndex_signatures[xBestIndex_dbdataBestIndex_enum], sizeof(E->xBestIndex_signature)) == 0) {
+     return dbdataBestIndex(args);
+ }
+ else if (memcmp(E->xBestIndex_signature, xBestIndex_signatures[xBestIndex_dbpageBestIndex_enum], sizeof(E->xBestIndex_signature)) == 0) {
+     return dbpageBestIndex(args);
+ }
+ else if (memcmp(E->xBestIndex_signature, xBestIndex_signatures[xBestIndex_expertBestIndex_enum], sizeof(E->xBestIndex_signature)) == 0) {
+     return expertBestIndex(args);
+ }
+ else if (memcmp(E->xBestIndex_signature, xBestIndex_signatures[xBestIndex_fsdirBestIndex_enum], sizeof(E->xBestIndex_signature)) == 0) {
+     return fsdirBestIndex(args);
+ }
+ else if (memcmp(E->xBestIndex_signature, xBestIndex_signatures[xBestIndex_fts3BestIndexMethod_enum], sizeof(E->xBestIndex_signature)) == 0) {
+     return fts3BestIndexMethod(args);
+ }
+ else if (memcmp(E->xBestIndex_signature, xBestIndex_signatures[xBestIndex_fts3auxBestIndexMethod_enum], sizeof(E->xBestIndex_signature)) == 0) {
+     return fts3auxBestIndexMethod(args);
+ }
+ else if (memcmp(E->xBestIndex_signature, xBestIndex_signatures[xBestIndex_fts3tokBestIndexMethod_enum], sizeof(E->xBestIndex_signature)) == 0) {
+     return fts3tokBestIndexMethod(args);
+ }
+ else if (memcmp(E->xBestIndex_signature, xBestIndex_signatures[xBestIndex_jsonEachBestIndex_enum], sizeof(E->xBestIndex_signature)) == 0) {
+     return jsonEachBestIndex(args);
+ }
+ else if (memcmp(E->xBestIndex_signature, xBestIndex_signatures[xBestIndex_pragmaVtabBestIndex_enum], sizeof(E->xBestIndex_signature)) == 0) {
+     return pragmaVtabBestIndex(args);
+ }
+ else if (memcmp(E->xBestIndex_signature, xBestIndex_signatures[xBestIndex_rtreeBestIndex_enum], sizeof(E->xBestIndex_signature)) == 0) {
+     return rtreeBestIndex(args);
+ }
+ else if (memcmp(E->xBestIndex_signature, xBestIndex_signatures[xBestIndex_seriesBestIndex_enum], sizeof(E->xBestIndex_signature)) == 0) {
+     return seriesBestIndex(args);
+ }
+ else if (memcmp(E->xBestIndex_signature, xBestIndex_signatures[xBestIndex_statBestIndex_enum], sizeof(E->xBestIndex_signature)) == 0) {
+     return statBestIndex(args);
+ }
+ else if (memcmp(E->xBestIndex_signature, xBestIndex_signatures[xBestIndex_stmtBestIndex_enum], sizeof(E->xBestIndex_signature)) == 0) {
+     return stmtBestIndex(args);
+ }
+ else if (memcmp(E->xBestIndex_signature, xBestIndex_signatures[xBestIndex_zipfileBestIndex_enum], sizeof(E->xBestIndex_signature)) == 0) {
+     return zipfileBestIndex(args);
+ }


// FP: xBusyHandler
// Candidates: 0, btreeInvokeBusyHandler, sqliteDefaultBusyCallback, xBusyHandler

@transform_return_xBusyHandler_arrow@
expression E;
identifier FP_NAME = xBusyHandler;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xBusyHandler_signature, xBusyHandler_signatures[xBusyHandler_0_enum], sizeof(E->xBusyHandler_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xBusyHandler_signature, xBusyHandler_signatures[xBusyHandler_btreeInvokeBusyHandler_enum], sizeof(E->xBusyHandler_signature)) == 0) {
+     return btreeInvokeBusyHandler(args);
+ }
+ else if (memcmp(E->xBusyHandler_signature, xBusyHandler_signatures[xBusyHandler_sqliteDefaultBusyCallback_enum], sizeof(E->xBusyHandler_signature)) == 0) {
+     return sqliteDefaultBusyCallback(args);
+ }
+ else if (memcmp(E->xBusyHandler_signature, xBusyHandler_signatures[xBusyHandler_xBusyHandler_enum], sizeof(E->xBusyHandler_signature)) == 0) {
+     return xBusyHandler(args);
+ }


// FP: xCachesize
// Candidates: pcache1Cachesize, pcachetraceCachesize

@transform_return_xCachesize_arrow@
expression E;
identifier FP_NAME = xCachesize;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xCachesize_signature, xCachesize_signatures[xCachesize_pcache1Cachesize_enum], sizeof(E->xCachesize_signature)) == 0) {
+     return pcache1Cachesize(args);
+ }
+ else if (memcmp(E->xCachesize_signature, xCachesize_signatures[xCachesize_pcachetraceCachesize_enum], sizeof(E->xCachesize_signature)) == 0) {
+     return pcachetraceCachesize(args);
+ }


// FP: xCellSize
// Candidates: cellSizePtr, cellSizePtrIdxLeaf, cellSizePtrNoPayload, cellSizePtrTableLeaf

@transform_return_xCellSize_arrow@
expression E;
identifier FP_NAME = xCellSize;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xCellSize_signature, xCellSize_signatures[xCellSize_cellSizePtr_enum], sizeof(E->xCellSize_signature)) == 0) {
+     return cellSizePtr(args);
+ }
+ else if (memcmp(E->xCellSize_signature, xCellSize_signatures[xCellSize_cellSizePtrIdxLeaf_enum], sizeof(E->xCellSize_signature)) == 0) {
+     return cellSizePtrIdxLeaf(args);
+ }
+ else if (memcmp(E->xCellSize_signature, xCellSize_signatures[xCellSize_cellSizePtrNoPayload_enum], sizeof(E->xCellSize_signature)) == 0) {
+     return cellSizePtrNoPayload(args);
+ }
+ else if (memcmp(E->xCellSize_signature, xCellSize_signatures[xCellSize_cellSizePtrTableLeaf_enum], sizeof(E->xCellSize_signature)) == 0) {
+     return cellSizePtrTableLeaf(args);
+ }


// FP: xCheckReservedLock
// Candidates: 0, apndCheckReservedLock, recoverVfsCheckReservedLock, vfstraceCheckReservedLock

@transform_return_xCheckReservedLock_arrow@
expression E;
identifier FP_NAME = xCheckReservedLock;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xCheckReservedLock_signature, xCheckReservedLock_signatures[xCheckReservedLock_0_enum], sizeof(E->xCheckReservedLock_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xCheckReservedLock_signature, xCheckReservedLock_signatures[xCheckReservedLock_apndCheckReservedLock_enum], sizeof(E->xCheckReservedLock_signature)) == 0) {
+     return apndCheckReservedLock(args);
+ }
+ else if (memcmp(E->xCheckReservedLock_signature, xCheckReservedLock_signatures[xCheckReservedLock_recoverVfsCheckReservedLock_enum], sizeof(E->xCheckReservedLock_signature)) == 0) {
+     return recoverVfsCheckReservedLock(args);
+ }
+ else if (memcmp(E->xCheckReservedLock_signature, xCheckReservedLock_signatures[xCheckReservedLock_vfstraceCheckReservedLock_enum], sizeof(E->xCheckReservedLock_signature)) == 0) {
+     return vfstraceCheckReservedLock(args);
+ }


// FP: xCleanup
// Candidates: agginfoFree, sqlite3DbFree, sqlite3DeleteReturning, sqlite3DeleteTableGeneric, sqlite3ExprDeleteGeneric, sqlite3ExprListDeleteGeneric, sqlite3SelectDeleteGeneric, sqlite3WithDeleteGeneric, whereIndexedExprCleanup

@transform_return_xCleanup_arrow@
expression E;
identifier FP_NAME = xCleanup;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xCleanup_signature, xCleanup_signatures[xCleanup_agginfoFree_enum], sizeof(E->xCleanup_signature)) == 0) {
+     return agginfoFree(args);
+ }
+ else if (memcmp(E->xCleanup_signature, xCleanup_signatures[xCleanup_sqlite3DbFree_enum], sizeof(E->xCleanup_signature)) == 0) {
+     return sqlite3DbFree(args);
+ }
+ else if (memcmp(E->xCleanup_signature, xCleanup_signatures[xCleanup_sqlite3DeleteReturning_enum], sizeof(E->xCleanup_signature)) == 0) {
+     return sqlite3DeleteReturning(args);
+ }
+ else if (memcmp(E->xCleanup_signature, xCleanup_signatures[xCleanup_sqlite3DeleteTableGeneric_enum], sizeof(E->xCleanup_signature)) == 0) {
+     return sqlite3DeleteTableGeneric(args);
+ }
+ else if (memcmp(E->xCleanup_signature, xCleanup_signatures[xCleanup_sqlite3ExprDeleteGeneric_enum], sizeof(E->xCleanup_signature)) == 0) {
+     return sqlite3ExprDeleteGeneric(args);
+ }
+ else if (memcmp(E->xCleanup_signature, xCleanup_signatures[xCleanup_sqlite3ExprListDeleteGeneric_enum], sizeof(E->xCleanup_signature)) == 0) {
+     return sqlite3ExprListDeleteGeneric(args);
+ }
+ else if (memcmp(E->xCleanup_signature, xCleanup_signatures[xCleanup_sqlite3SelectDeleteGeneric_enum], sizeof(E->xCleanup_signature)) == 0) {
+     return sqlite3SelectDeleteGeneric(args);
+ }
+ else if (memcmp(E->xCleanup_signature, xCleanup_signatures[xCleanup_sqlite3WithDeleteGeneric_enum], sizeof(E->xCleanup_signature)) == 0) {
+     return sqlite3WithDeleteGeneric(args);
+ }
+ else if (memcmp(E->xCleanup_signature, xCleanup_signatures[xCleanup_whereIndexedExprCleanup_enum], sizeof(E->xCleanup_signature)) == 0) {
+     return whereIndexedExprCleanup(args);
+ }


// FP: xClose
// Candidates: apndClose, bytecodevtabClose, completionClose, dbdataClose, dbpageClose, expertClose, fsdirClose, fts3CloseMethod, fts3auxCloseMethod, fts3tokCloseMethod, jsonEachClose, memdbClose, memjrnlClose, porterClose, pragmaVtabClose, recoverVfsClose, rtreeClose, seriesClose, simpleClose, statClose, stmtClose, unicodeClose, vfstraceClose, zipfileClose

@transform_return_xClose_arrow@
expression E;
identifier FP_NAME = xClose;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xClose_signature, xClose_signatures[xClose_apndClose_enum], sizeof(E->xClose_signature)) == 0) {
+     return apndClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_bytecodevtabClose_enum], sizeof(E->xClose_signature)) == 0) {
+     return bytecodevtabClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_completionClose_enum], sizeof(E->xClose_signature)) == 0) {
+     return completionClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_dbdataClose_enum], sizeof(E->xClose_signature)) == 0) {
+     return dbdataClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_dbpageClose_enum], sizeof(E->xClose_signature)) == 0) {
+     return dbpageClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_expertClose_enum], sizeof(E->xClose_signature)) == 0) {
+     return expertClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_fsdirClose_enum], sizeof(E->xClose_signature)) == 0) {
+     return fsdirClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_fts3CloseMethod_enum], sizeof(E->xClose_signature)) == 0) {
+     return fts3CloseMethod(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_fts3auxCloseMethod_enum], sizeof(E->xClose_signature)) == 0) {
+     return fts3auxCloseMethod(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_fts3tokCloseMethod_enum], sizeof(E->xClose_signature)) == 0) {
+     return fts3tokCloseMethod(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_jsonEachClose_enum], sizeof(E->xClose_signature)) == 0) {
+     return jsonEachClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_memdbClose_enum], sizeof(E->xClose_signature)) == 0) {
+     return memdbClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_memjrnlClose_enum], sizeof(E->xClose_signature)) == 0) {
+     return memjrnlClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_porterClose_enum], sizeof(E->xClose_signature)) == 0) {
+     return porterClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_pragmaVtabClose_enum], sizeof(E->xClose_signature)) == 0) {
+     return pragmaVtabClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_recoverVfsClose_enum], sizeof(E->xClose_signature)) == 0) {
+     return recoverVfsClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_rtreeClose_enum], sizeof(E->xClose_signature)) == 0) {
+     return rtreeClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_seriesClose_enum], sizeof(E->xClose_signature)) == 0) {
+     return seriesClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_simpleClose_enum], sizeof(E->xClose_signature)) == 0) {
+     return simpleClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_statClose_enum], sizeof(E->xClose_signature)) == 0) {
+     return statClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_stmtClose_enum], sizeof(E->xClose_signature)) == 0) {
+     return stmtClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_unicodeClose_enum], sizeof(E->xClose_signature)) == 0) {
+     return unicodeClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_vfstraceClose_enum], sizeof(E->xClose_signature)) == 0) {
+     return vfstraceClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_zipfileClose_enum], sizeof(E->xClose_signature)) == 0) {
+     return zipfileClose(args);
+ }


// FP: xCmp
// Candidates: 0, binCollFunc, decimalCollFunc, dummyCompare, icuCollationColl, nocaseCollatingFunc, rtrimCollFunc, uintCollFunc

@transform_return_xCmp_arrow@
expression E;
identifier FP_NAME = xCmp;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xCmp_signature, xCmp_signatures[xCmp_0_enum], sizeof(E->xCmp_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xCmp_signature, xCmp_signatures[xCmp_binCollFunc_enum], sizeof(E->xCmp_signature)) == 0) {
+     return binCollFunc(args);
+ }
+ else if (memcmp(E->xCmp_signature, xCmp_signatures[xCmp_decimalCollFunc_enum], sizeof(E->xCmp_signature)) == 0) {
+     return decimalCollFunc(args);
+ }
+ else if (memcmp(E->xCmp_signature, xCmp_signatures[xCmp_dummyCompare_enum], sizeof(E->xCmp_signature)) == 0) {
+     return dummyCompare(args);
+ }
+ else if (memcmp(E->xCmp_signature, xCmp_signatures[xCmp_icuCollationColl_enum], sizeof(E->xCmp_signature)) == 0) {
+     return icuCollationColl(args);
+ }
+ else if (memcmp(E->xCmp_signature, xCmp_signatures[xCmp_nocaseCollatingFunc_enum], sizeof(E->xCmp_signature)) == 0) {
+     return nocaseCollatingFunc(args);
+ }
+ else if (memcmp(E->xCmp_signature, xCmp_signatures[xCmp_rtrimCollFunc_enum], sizeof(E->xCmp_signature)) == 0) {
+     return rtrimCollFunc(args);
+ }
+ else if (memcmp(E->xCmp_signature, xCmp_signatures[xCmp_uintCollFunc_enum], sizeof(E->xCmp_signature)) == 0) {
+     return uintCollFunc(args);
+ }


// FP: xCollNeeded16
// Candidates: 0

@transform_return_xCollNeeded16_arrow@
expression E;
identifier FP_NAME = xCollNeeded16;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return 0(args);


// FP: xColumn
// Candidates: bytecodevtabColumn, completionColumn, dbdataColumn, dbpageColumn, expertColumn, fsdirColumn, fts3ColumnMethod, fts3auxColumnMethod, fts3tokColumnMethod, geopolyColumn, jsonEachColumn, pragmaVtabColumn, rtreeColumn, seriesColumn, statColumn, stmtColumn, zipfileColumn

@transform_return_xColumn_arrow@
expression E;
identifier FP_NAME = xColumn;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_bytecodevtabColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+     return bytecodevtabColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_completionColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+     return completionColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_dbdataColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+     return dbdataColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_dbpageColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+     return dbpageColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_expertColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+     return expertColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_fsdirColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+     return fsdirColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_fts3ColumnMethod_enum], sizeof(E->xColumn_signature)) == 0) {
+     return fts3ColumnMethod(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_fts3auxColumnMethod_enum], sizeof(E->xColumn_signature)) == 0) {
+     return fts3auxColumnMethod(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_fts3tokColumnMethod_enum], sizeof(E->xColumn_signature)) == 0) {
+     return fts3tokColumnMethod(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_geopolyColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+     return geopolyColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_jsonEachColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+     return jsonEachColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_pragmaVtabColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+     return pragmaVtabColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_rtreeColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+     return rtreeColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_seriesColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+     return seriesColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_statColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+     return statColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_stmtColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+     return stmtColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_zipfileColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+     return zipfileColumn(args);
+ }


// FP: xCommit
// Candidates: 0, fts3CommitMethod, rtreeEndTransaction, zipfileCommit

@transform_return_xCommit_arrow@
expression E;
identifier FP_NAME = xCommit;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xCommit_signature, xCommit_signatures[xCommit_0_enum], sizeof(E->xCommit_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xCommit_signature, xCommit_signatures[xCommit_fts3CommitMethod_enum], sizeof(E->xCommit_signature)) == 0) {
+     return fts3CommitMethod(args);
+ }
+ else if (memcmp(E->xCommit_signature, xCommit_signatures[xCommit_rtreeEndTransaction_enum], sizeof(E->xCommit_signature)) == 0) {
+     return rtreeEndTransaction(args);
+ }
+ else if (memcmp(E->xCommit_signature, xCommit_signatures[xCommit_zipfileCommit_enum], sizeof(E->xCommit_signature)) == 0) {
+     return zipfileCommit(args);
+ }


// FP: xCommitCallback
// Candidates: 0, sql_trace_callback, sqlite3WalDefaultHook

@transform_return_xCommitCallback_arrow@
expression E;
identifier FP_NAME = xCommitCallback;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xCommitCallback_signature, xCommitCallback_signatures[xCommitCallback_0_enum], sizeof(E->xCommitCallback_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xCommitCallback_signature, xCommitCallback_signatures[xCommitCallback_sql_trace_callback_enum], sizeof(E->xCommitCallback_signature)) == 0) {
+     return sql_trace_callback(args);
+ }
+ else if (memcmp(E->xCommitCallback_signature, xCommitCallback_signatures[xCommitCallback_sqlite3WalDefaultHook_enum], sizeof(E->xCommitCallback_signature)) == 0) {
+     return sqlite3WalDefaultHook(args);
+ }


// FP: xConnect
// Candidates: bytecodevtabConnect, dbpageConnect, fts3ConnectMethod, fts3auxConnectMethod, fts3tokConnectMethod, jsonEachConnect, pragmaVtabConnect, rtreeConnect, statConnect, stmtConnect

@transform_return_xConnect_arrow@
expression E;
identifier FP_NAME = xConnect;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_bytecodevtabConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+     return bytecodevtabConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_dbpageConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+     return dbpageConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_fts3ConnectMethod_enum], sizeof(E->xConnect_signature)) == 0) {
+     return fts3ConnectMethod(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_fts3auxConnectMethod_enum], sizeof(E->xConnect_signature)) == 0) {
+     return fts3auxConnectMethod(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_fts3tokConnectMethod_enum], sizeof(E->xConnect_signature)) == 0) {
+     return fts3tokConnectMethod(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_jsonEachConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+     return jsonEachConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_pragmaVtabConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+     return pragmaVtabConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_rtreeConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+     return rtreeConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_statConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+     return statConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_stmtConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+     return stmtConnect(args);
+ }


// FP: xCount
// Candidates: sessionDiffCount, sessionPreupdateCount, sessionStat1Count

@transform_return_xCount_arrow@
expression E;
identifier FP_NAME = xCount;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xCount_signature, xCount_signatures[xCount_sessionDiffCount_enum], sizeof(E->xCount_signature)) == 0) {
+     return sessionDiffCount(args);
+ }
+ else if (memcmp(E->xCount_signature, xCount_signatures[xCount_sessionPreupdateCount_enum], sizeof(E->xCount_signature)) == 0) {
+     return sessionPreupdateCount(args);
+ }
+ else if (memcmp(E->xCount_signature, xCount_signatures[xCount_sessionStat1Count_enum], sizeof(E->xCount_signature)) == 0) {
+     return sessionStat1Count(args);
+ }


// FP: xCreate
// Candidates: 0, dbpageConnect, fts3CreateMethod, fts3auxConnectMethod, fts3tokConnectMethod, geopolyCreate, pcache1Create, pcachetraceCreate, porterCreate, rtreeCreate, simpleCreate, statConnect, unicodeCreate

@transform_return_xCreate_arrow@
expression E;
identifier FP_NAME = xCreate;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_0_enum], sizeof(E->xCreate_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_dbpageConnect_enum], sizeof(E->xCreate_signature)) == 0) {
+     return dbpageConnect(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_fts3CreateMethod_enum], sizeof(E->xCreate_signature)) == 0) {
+     return fts3CreateMethod(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_fts3auxConnectMethod_enum], sizeof(E->xCreate_signature)) == 0) {
+     return fts3auxConnectMethod(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_fts3tokConnectMethod_enum], sizeof(E->xCreate_signature)) == 0) {
+     return fts3tokConnectMethod(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_geopolyCreate_enum], sizeof(E->xCreate_signature)) == 0) {
+     return geopolyCreate(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_pcache1Create_enum], sizeof(E->xCreate_signature)) == 0) {
+     return pcache1Create(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_pcachetraceCreate_enum], sizeof(E->xCreate_signature)) == 0) {
+     return pcachetraceCreate(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_porterCreate_enum], sizeof(E->xCreate_signature)) == 0) {
+     return porterCreate(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_rtreeCreate_enum], sizeof(E->xCreate_signature)) == 0) {
+     return rtreeCreate(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_simpleCreate_enum], sizeof(E->xCreate_signature)) == 0) {
+     return simpleCreate(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_statConnect_enum], sizeof(E->xCreate_signature)) == 0) {
+     return statConnect(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_unicodeCreate_enum], sizeof(E->xCreate_signature)) == 0) {
+     return unicodeCreate(args);
+ }


// FP: xCurrentTime
// Candidates: 0, apndCurrentTime, vfstraceCurrentTime, unixCurrentTime

@transform_return_xCurrentTime_arrow@
expression E;
identifier FP_NAME = xCurrentTime;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xCurrentTime_signature, xCurrentTime_signatures[xCurrentTime_0_enum], sizeof(E->xCurrentTime_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xCurrentTime_signature, xCurrentTime_signatures[xCurrentTime_apndCurrentTime_enum], sizeof(E->xCurrentTime_signature)) == 0) {
+     return apndCurrentTime(args);
+ }
+ else if (memcmp(E->xCurrentTime_signature, xCurrentTime_signatures[xCurrentTime_vfstraceCurrentTime_enum], sizeof(E->xCurrentTime_signature)) == 0) {
+     return vfstraceCurrentTime(args);
+ }
+ else if (memcmp(E->xCurrentTime_signature, xCurrentTime_signatures[xCurrentTime_unixCurrentTime_enum], sizeof(E->xCurrentTime_signature)) == 0) {
+     return unixCurrentTime(args);
+ }


// FP: xCurrentTimeInt64
// Candidates: apndCurrentTimeInt64, memdbCurrentTimeInt64, unixCurrentTimeInt64

@transform_return_xCurrentTimeInt64_arrow@
expression E;
identifier FP_NAME = xCurrentTimeInt64;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xCurrentTimeInt64_signature, xCurrentTimeInt64_signatures[xCurrentTimeInt64_apndCurrentTimeInt64_enum], sizeof(E->xCurrentTimeInt64_signature)) == 0) {
+     return apndCurrentTimeInt64(args);
+ }
+ else if (memcmp(E->xCurrentTimeInt64_signature, xCurrentTimeInt64_signatures[xCurrentTimeInt64_memdbCurrentTimeInt64_enum], sizeof(E->xCurrentTimeInt64_signature)) == 0) {
+     return memdbCurrentTimeInt64(args);
+ }
+ else if (memcmp(E->xCurrentTimeInt64_signature, xCurrentTimeInt64_signatures[xCurrentTimeInt64_unixCurrentTimeInt64_enum], sizeof(E->xCurrentTimeInt64_signature)) == 0) {
+     return unixCurrentTimeInt64(args);
+ }


// FP: xDel
// Candidates: 0, SQLITE_DYNAMIC, SQLITE_STATIC, SQLITE_TRANSIENT, rtreeMatchArgFree, sqlite3RCStrUnref, sqlite3RowSetDelete, sqlite3SchemaClear, sqlite3VdbeFrameMemDel, sqlite3VdbeValueListFree, sqlite3_free, statAccumDestructor, xDel, zipfileFree

@transform_return_xDel_arrow@
expression E;
identifier FP_NAME = xDel;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xDel_signature, xDel_signatures[xDel_0_enum], sizeof(E->xDel_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xDel_signature, xDel_signatures[xDel_SQLITE_DYNAMIC_enum], sizeof(E->xDel_signature)) == 0) {
+     return SQLITE_DYNAMIC(args);
+ }
+ else if (memcmp(E->xDel_signature, xDel_signatures[xDel_SQLITE_STATIC_enum], sizeof(E->xDel_signature)) == 0) {
+     return SQLITE_STATIC(args);
+ }
+ else if (memcmp(E->xDel_signature, xDel_signatures[xDel_SQLITE_TRANSIENT_enum], sizeof(E->xDel_signature)) == 0) {
+     return SQLITE_TRANSIENT(args);
+ }
+ else if (memcmp(E->xDel_signature, xDel_signatures[xDel_rtreeMatchArgFree_enum], sizeof(E->xDel_signature)) == 0) {
+     return rtreeMatchArgFree(args);
+ }
+ else if (memcmp(E->xDel_signature, xDel_signatures[xDel_sqlite3RCStrUnref_enum], sizeof(E->xDel_signature)) == 0) {
+     return sqlite3RCStrUnref(args);
+ }
+ else if (memcmp(E->xDel_signature, xDel_signatures[xDel_sqlite3RowSetDelete_enum], sizeof(E->xDel_signature)) == 0) {
+     return sqlite3RowSetDelete(args);
+ }
+ else if (memcmp(E->xDel_signature, xDel_signatures[xDel_sqlite3SchemaClear_enum], sizeof(E->xDel_signature)) == 0) {
+     return sqlite3SchemaClear(args);
+ }
+ else if (memcmp(E->xDel_signature, xDel_signatures[xDel_sqlite3VdbeFrameMemDel_enum], sizeof(E->xDel_signature)) == 0) {
+     return sqlite3VdbeFrameMemDel(args);
+ }
+ else if (memcmp(E->xDel_signature, xDel_signatures[xDel_sqlite3VdbeValueListFree_enum], sizeof(E->xDel_signature)) == 0) {
+     return sqlite3VdbeValueListFree(args);
+ }
+ else if (memcmp(E->xDel_signature, xDel_signatures[xDel_sqlite3_free_enum], sizeof(E->xDel_signature)) == 0) {
+     return sqlite3_free(args);
+ }
+ else if (memcmp(E->xDel_signature, xDel_signatures[xDel_statAccumDestructor_enum], sizeof(E->xDel_signature)) == 0) {
+     return statAccumDestructor(args);
+ }
+ else if (memcmp(E->xDel_signature, xDel_signatures[xDel_xDel_enum], sizeof(E->xDel_signature)) == 0) {
+     return xDel(args);
+ }
+ else if (memcmp(E->xDel_signature, xDel_signatures[xDel_zipfileFree_enum], sizeof(E->xDel_signature)) == 0) {
+     return zipfileFree(args);
+ }


// FP: xDelete
// Candidates: 0, apndDelete, jsonCacheDeleteGeneric, kvstorageDelete, sqlite3_free, vfstraceDelete, unixDelete

@transform_return_xDelete_arrow@
expression E;
identifier FP_NAME = xDelete;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xDelete_signature, xDelete_signatures[xDelete_0_enum], sizeof(E->xDelete_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xDelete_signature, xDelete_signatures[xDelete_apndDelete_enum], sizeof(E->xDelete_signature)) == 0) {
+     return apndDelete(args);
+ }
+ else if (memcmp(E->xDelete_signature, xDelete_signatures[xDelete_jsonCacheDeleteGeneric_enum], sizeof(E->xDelete_signature)) == 0) {
+     return jsonCacheDeleteGeneric(args);
+ }
+ else if (memcmp(E->xDelete_signature, xDelete_signatures[xDelete_kvstorageDelete_enum], sizeof(E->xDelete_signature)) == 0) {
+     return kvstorageDelete(args);
+ }
+ else if (memcmp(E->xDelete_signature, xDelete_signatures[xDelete_sqlite3_free_enum], sizeof(E->xDelete_signature)) == 0) {
+     return sqlite3_free(args);
+ }
+ else if (memcmp(E->xDelete_signature, xDelete_signatures[xDelete_vfstraceDelete_enum], sizeof(E->xDelete_signature)) == 0) {
+     return vfstraceDelete(args);
+ }
+ else if (memcmp(E->xDelete_signature, xDelete_signatures[xDelete_unixDelete_enum], sizeof(E->xDelete_signature)) == 0) {
+     return unixDelete(args);
+ }


// FP: xDeleteAux
// Candidates: jsonCacheDeleteGeneric, sqlite3_free

@transform_return_xDeleteAux_arrow@
expression E;
identifier FP_NAME = xDeleteAux;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xDeleteAux_signature, xDeleteAux_signatures[xDeleteAux_jsonCacheDeleteGeneric_enum], sizeof(E->xDeleteAux_signature)) == 0) {
+     return jsonCacheDeleteGeneric(args);
+ }
+ else if (memcmp(E->xDeleteAux_signature, xDeleteAux_signatures[xDeleteAux_sqlite3_free_enum], sizeof(E->xDeleteAux_signature)) == 0) {
+     return sqlite3_free(args);
+ }


// FP: xDepth
// Candidates: sessionDiffDepth, sessionPreupdateDepth, sessionStat1Depth

@transform_return_xDepth_arrow@
expression E;
identifier FP_NAME = xDepth;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xDepth_signature, xDepth_signatures[xDepth_sessionDiffDepth_enum], sizeof(E->xDepth_signature)) == 0) {
+     return sessionDiffDepth(args);
+ }
+ else if (memcmp(E->xDepth_signature, xDepth_signatures[xDepth_sessionPreupdateDepth_enum], sizeof(E->xDepth_signature)) == 0) {
+     return sessionPreupdateDepth(args);
+ }
+ else if (memcmp(E->xDepth_signature, xDepth_signatures[xDepth_sessionStat1Depth_enum], sizeof(E->xDepth_signature)) == 0) {
+     return sessionStat1Depth(args);
+ }


// FP: xDestroy
// Candidates: 0, dbpageDisconnect, expertDisconnect, fts3DestroyMethod, fts3auxDisconnectMethod, fts3tokDisconnectMethod, hashDestroy, pcache1Destroy, pcachetraceDestroy, porterDestroy, rtreeDestroy, rtreeFreeCallback, simpleDestroy, sqlite3_free, statDisconnect, unicodeDestroy, zipfileDisconnect

@transform_return_xDestroy_arrow@
expression E;
identifier FP_NAME = xDestroy;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xDestroy_signature, xDestroy_signatures[xDestroy_0_enum], sizeof(E->xDestroy_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xDestroy_signature, xDestroy_signatures[xDestroy_dbpageDisconnect_enum], sizeof(E->xDestroy_signature)) == 0) {
+     return dbpageDisconnect(args);
+ }
+ else if (memcmp(E->xDestroy_signature, xDestroy_signatures[xDestroy_expertDisconnect_enum], sizeof(E->xDestroy_signature)) == 0) {
+     return expertDisconnect(args);
+ }
+ else if (memcmp(E->xDestroy_signature, xDestroy_signatures[xDestroy_fts3DestroyMethod_enum], sizeof(E->xDestroy_signature)) == 0) {
+     return fts3DestroyMethod(args);
+ }
+ else if (memcmp(E->xDestroy_signature, xDestroy_signatures[xDestroy_fts3auxDisconnectMethod_enum], sizeof(E->xDestroy_signature)) == 0) {
+     return fts3auxDisconnectMethod(args);
+ }
+ else if (memcmp(E->xDestroy_signature, xDestroy_signatures[xDestroy_fts3tokDisconnectMethod_enum], sizeof(E->xDestroy_signature)) == 0) {
+     return fts3tokDisconnectMethod(args);
+ }
+ else if (memcmp(E->xDestroy_signature, xDestroy_signatures[xDestroy_hashDestroy_enum], sizeof(E->xDestroy_signature)) == 0) {
+     return hashDestroy(args);
+ }
+ else if (memcmp(E->xDestroy_signature, xDestroy_signatures[xDestroy_pcache1Destroy_enum], sizeof(E->xDestroy_signature)) == 0) {
+     return pcache1Destroy(args);
+ }
+ else if (memcmp(E->xDestroy_signature, xDestroy_signatures[xDestroy_pcachetraceDestroy_enum], sizeof(E->xDestroy_signature)) == 0) {
+     return pcachetraceDestroy(args);
+ }
+ else if (memcmp(E->xDestroy_signature, xDestroy_signatures[xDestroy_porterDestroy_enum], sizeof(E->xDestroy_signature)) == 0) {
+     return porterDestroy(args);
+ }
+ else if (memcmp(E->xDestroy_signature, xDestroy_signatures[xDestroy_rtreeDestroy_enum], sizeof(E->xDestroy_signature)) == 0) {
+     return rtreeDestroy(args);
+ }
+ else if (memcmp(E->xDestroy_signature, xDestroy_signatures[xDestroy_rtreeFreeCallback_enum], sizeof(E->xDestroy_signature)) == 0) {
+     return rtreeFreeCallback(args);
+ }
+ else if (memcmp(E->xDestroy_signature, xDestroy_signatures[xDestroy_simpleDestroy_enum], sizeof(E->xDestroy_signature)) == 0) {
+     return simpleDestroy(args);
+ }
+ else if (memcmp(E->xDestroy_signature, xDestroy_signatures[xDestroy_sqlite3_free_enum], sizeof(E->xDestroy_signature)) == 0) {
+     return sqlite3_free(args);
+ }
+ else if (memcmp(E->xDestroy_signature, xDestroy_signatures[xDestroy_statDisconnect_enum], sizeof(E->xDestroy_signature)) == 0) {
+     return statDisconnect(args);
+ }
+ else if (memcmp(E->xDestroy_signature, xDestroy_signatures[xDestroy_unicodeDestroy_enum], sizeof(E->xDestroy_signature)) == 0) {
+     return unicodeDestroy(args);
+ }
+ else if (memcmp(E->xDestroy_signature, xDestroy_signatures[xDestroy_zipfileDisconnect_enum], sizeof(E->xDestroy_signature)) == 0) {
+     return zipfileDisconnect(args);
+ }


// FP: xDestructor
// Candidates: 0, rtreeMatchArgFree, sqlite3VdbeValueListFree

@transform_return_xDestructor_arrow@
expression E;
identifier FP_NAME = xDestructor;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xDestructor_signature, xDestructor_signatures[xDestructor_0_enum], sizeof(E->xDestructor_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xDestructor_signature, xDestructor_signatures[xDestructor_rtreeMatchArgFree_enum], sizeof(E->xDestructor_signature)) == 0) {
+     return rtreeMatchArgFree(args);
+ }
+ else if (memcmp(E->xDestructor_signature, xDestructor_signatures[xDestructor_sqlite3VdbeValueListFree_enum], sizeof(E->xDestructor_signature)) == 0) {
+     return sqlite3VdbeValueListFree(args);
+ }


// FP: xDeviceCharacteristics
// Candidates: 0, apndDeviceCharacteristics, memdbDeviceCharacteristics, recoverVfsDeviceCharacteristics, vfstraceDeviceCharacteristics

@transform_return_xDeviceCharacteristics_arrow@
expression E;
identifier FP_NAME = xDeviceCharacteristics;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xDeviceCharacteristics_signature, xDeviceCharacteristics_signatures[xDeviceCharacteristics_0_enum], sizeof(E->xDeviceCharacteristics_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xDeviceCharacteristics_signature, xDeviceCharacteristics_signatures[xDeviceCharacteristics_apndDeviceCharacteristics_enum], sizeof(E->xDeviceCharacteristics_signature)) == 0) {
+     return apndDeviceCharacteristics(args);
+ }
+ else if (memcmp(E->xDeviceCharacteristics_signature, xDeviceCharacteristics_signatures[xDeviceCharacteristics_memdbDeviceCharacteristics_enum], sizeof(E->xDeviceCharacteristics_signature)) == 0) {
+     return memdbDeviceCharacteristics(args);
+ }
+ else if (memcmp(E->xDeviceCharacteristics_signature, xDeviceCharacteristics_signatures[xDeviceCharacteristics_recoverVfsDeviceCharacteristics_enum], sizeof(E->xDeviceCharacteristics_signature)) == 0) {
+     return recoverVfsDeviceCharacteristics(args);
+ }
+ else if (memcmp(E->xDeviceCharacteristics_signature, xDeviceCharacteristics_signatures[xDeviceCharacteristics_vfstraceDeviceCharacteristics_enum], sizeof(E->xDeviceCharacteristics_signature)) == 0) {
+     return vfstraceDeviceCharacteristics(args);
+ }


// FP: xDisconnect
// Candidates: bytecodevtabDisconnect, completionDisconnect, dbdataDisconnect, dbpageDisconnect, expertDisconnect, fsdirDisconnect, fts3DisconnectMethod, fts3auxDisconnectMethod, fts3tokDisconnectMethod, jsonEachDisconnect, pragmaVtabDisconnect, rtreeDisconnect, seriesDisconnect, statDisconnect, stmtDisconnect, zipfileDisconnect

@transform_return_xDisconnect_arrow@
expression E;
identifier FP_NAME = xDisconnect;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xDisconnect_signature, xDisconnect_signatures[xDisconnect_bytecodevtabDisconnect_enum], sizeof(E->xDisconnect_signature)) == 0) {
+     return bytecodevtabDisconnect(args);
+ }
+ else if (memcmp(E->xDisconnect_signature, xDisconnect_signatures[xDisconnect_completionDisconnect_enum], sizeof(E->xDisconnect_signature)) == 0) {
+     return completionDisconnect(args);
+ }
+ else if (memcmp(E->xDisconnect_signature, xDisconnect_signatures[xDisconnect_dbdataDisconnect_enum], sizeof(E->xDisconnect_signature)) == 0) {
+     return dbdataDisconnect(args);
+ }
+ else if (memcmp(E->xDisconnect_signature, xDisconnect_signatures[xDisconnect_dbpageDisconnect_enum], sizeof(E->xDisconnect_signature)) == 0) {
+     return dbpageDisconnect(args);
+ }
+ else if (memcmp(E->xDisconnect_signature, xDisconnect_signatures[xDisconnect_expertDisconnect_enum], sizeof(E->xDisconnect_signature)) == 0) {
+     return expertDisconnect(args);
+ }
+ else if (memcmp(E->xDisconnect_signature, xDisconnect_signatures[xDisconnect_fsdirDisconnect_enum], sizeof(E->xDisconnect_signature)) == 0) {
+     return fsdirDisconnect(args);
+ }
+ else if (memcmp(E->xDisconnect_signature, xDisconnect_signatures[xDisconnect_fts3DisconnectMethod_enum], sizeof(E->xDisconnect_signature)) == 0) {
+     return fts3DisconnectMethod(args);
+ }
+ else if (memcmp(E->xDisconnect_signature, xDisconnect_signatures[xDisconnect_fts3auxDisconnectMethod_enum], sizeof(E->xDisconnect_signature)) == 0) {
+     return fts3auxDisconnectMethod(args);
+ }
+ else if (memcmp(E->xDisconnect_signature, xDisconnect_signatures[xDisconnect_fts3tokDisconnectMethod_enum], sizeof(E->xDisconnect_signature)) == 0) {
+     return fts3tokDisconnectMethod(args);
+ }
+ else if (memcmp(E->xDisconnect_signature, xDisconnect_signatures[xDisconnect_jsonEachDisconnect_enum], sizeof(E->xDisconnect_signature)) == 0) {
+     return jsonEachDisconnect(args);
+ }
+ else if (memcmp(E->xDisconnect_signature, xDisconnect_signatures[xDisconnect_pragmaVtabDisconnect_enum], sizeof(E->xDisconnect_signature)) == 0) {
+     return pragmaVtabDisconnect(args);
+ }
+ else if (memcmp(E->xDisconnect_signature, xDisconnect_signatures[xDisconnect_rtreeDisconnect_enum], sizeof(E->xDisconnect_signature)) == 0) {
+     return rtreeDisconnect(args);
+ }
+ else if (memcmp(E->xDisconnect_signature, xDisconnect_signatures[xDisconnect_seriesDisconnect_enum], sizeof(E->xDisconnect_signature)) == 0) {
+     return seriesDisconnect(args);
+ }
+ else if (memcmp(E->xDisconnect_signature, xDisconnect_signatures[xDisconnect_statDisconnect_enum], sizeof(E->xDisconnect_signature)) == 0) {
+     return statDisconnect(args);
+ }
+ else if (memcmp(E->xDisconnect_signature, xDisconnect_signatures[xDisconnect_stmtDisconnect_enum], sizeof(E->xDisconnect_signature)) == 0) {
+     return stmtDisconnect(args);
+ }
+ else if (memcmp(E->xDisconnect_signature, xDisconnect_signatures[xDisconnect_zipfileDisconnect_enum], sizeof(E->xDisconnect_signature)) == 0) {
+     return zipfileDisconnect(args);
+ }


// FP: xDlClose
// Candidates: 0, apndDlClose, memdbDlClose, unixDlClose

@transform_return_xDlClose_arrow@
expression E;
identifier FP_NAME = xDlClose;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xDlClose_signature, xDlClose_signatures[xDlClose_0_enum], sizeof(E->xDlClose_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xDlClose_signature, xDlClose_signatures[xDlClose_apndDlClose_enum], sizeof(E->xDlClose_signature)) == 0) {
+     return apndDlClose(args);
+ }
+ else if (memcmp(E->xDlClose_signature, xDlClose_signatures[xDlClose_memdbDlClose_enum], sizeof(E->xDlClose_signature)) == 0) {
+     return memdbDlClose(args);
+ }
+ else if (memcmp(E->xDlClose_signature, xDlClose_signatures[xDlClose_unixDlClose_enum], sizeof(E->xDlClose_signature)) == 0) {
+     return unixDlClose(args);
+ }


// FP: xDlError
// Candidates: 0, apndDlError, memdbDlError, unixDlError

@transform_return_xDlError_arrow@
expression E;
identifier FP_NAME = xDlError;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xDlError_signature, xDlError_signatures[xDlError_0_enum], sizeof(E->xDlError_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xDlError_signature, xDlError_signatures[xDlError_apndDlError_enum], sizeof(E->xDlError_signature)) == 0) {
+     return apndDlError(args);
+ }
+ else if (memcmp(E->xDlError_signature, xDlError_signatures[xDlError_memdbDlError_enum], sizeof(E->xDlError_signature)) == 0) {
+     return memdbDlError(args);
+ }
+ else if (memcmp(E->xDlError_signature, xDlError_signatures[xDlError_unixDlError_enum], sizeof(E->xDlError_signature)) == 0) {
+     return unixDlError(args);
+ }


// FP: xDlOpen
// Candidates: apndDlOpen, memdbDlOpen, unixDlOpen

@transform_return_xDlOpen_arrow@
expression E;
identifier FP_NAME = xDlOpen;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xDlOpen_signature, xDlOpen_signatures[xDlOpen_apndDlOpen_enum], sizeof(E->xDlOpen_signature)) == 0) {
+     return apndDlOpen(args);
+ }
+ else if (memcmp(E->xDlOpen_signature, xDlOpen_signatures[xDlOpen_memdbDlOpen_enum], sizeof(E->xDlOpen_signature)) == 0) {
+     return memdbDlOpen(args);
+ }
+ else if (memcmp(E->xDlOpen_signature, xDlOpen_signatures[xDlOpen_unixDlOpen_enum], sizeof(E->xDlOpen_signature)) == 0) {
+     return unixDlOpen(args);
+ }


// FP: xDlSym
// Candidates: 0, apndDlSym, memdbDlSym, rbuVfsDlSym, winDlSym, unixDlSym

@transform_return_xDlSym_arrow@
expression E;
identifier FP_NAME = xDlSym;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xDlSym_signature, xDlSym_signatures[xDlSym_0_enum], sizeof(E->xDlSym_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xDlSym_signature, xDlSym_signatures[xDlSym_apndDlSym_enum], sizeof(E->xDlSym_signature)) == 0) {
+     return apndDlSym(args);
+ }
+ else if (memcmp(E->xDlSym_signature, xDlSym_signatures[xDlSym_memdbDlSym_enum], sizeof(E->xDlSym_signature)) == 0) {
+     return memdbDlSym(args);
+ }
+ else if (memcmp(E->xDlSym_signature, xDlSym_signatures[xDlSym_rbuVfsDlSym_enum], sizeof(E->xDlSym_signature)) == 0) {
+     return rbuVfsDlSym(args);
+ }
+ else if (memcmp(E->xDlSym_signature, xDlSym_signatures[xDlSym_winDlSym_enum], sizeof(E->xDlSym_signature)) == 0) {
+     return winDlSym(args);
+ }
+ else if (memcmp(E->xDlSym_signature, xDlSym_signatures[xDlSym_unixDlSym_enum], sizeof(E->xDlSym_signature)) == 0) {
+     return unixDlSym(args);
+ }


// FP: xEof
// Candidates: bytecodevtabEof, completionEof, dbdataEof, dbpageEof, expertEof, fsdirEof, fts3EofMethod, fts3auxEofMethod, fts3tokEofMethod, jsonEachEof, pragmaVtabEof, rtreeEof, seriesEof, statEof, stmtEof, zipfileEof

@transform_return_xEof_arrow@
expression E;
identifier FP_NAME = xEof;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xEof_signature, xEof_signatures[xEof_bytecodevtabEof_enum], sizeof(E->xEof_signature)) == 0) {
+     return bytecodevtabEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_completionEof_enum], sizeof(E->xEof_signature)) == 0) {
+     return completionEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_dbdataEof_enum], sizeof(E->xEof_signature)) == 0) {
+     return dbdataEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_dbpageEof_enum], sizeof(E->xEof_signature)) == 0) {
+     return dbpageEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_expertEof_enum], sizeof(E->xEof_signature)) == 0) {
+     return expertEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_fsdirEof_enum], sizeof(E->xEof_signature)) == 0) {
+     return fsdirEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_fts3EofMethod_enum], sizeof(E->xEof_signature)) == 0) {
+     return fts3EofMethod(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_fts3auxEofMethod_enum], sizeof(E->xEof_signature)) == 0) {
+     return fts3auxEofMethod(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_fts3tokEofMethod_enum], sizeof(E->xEof_signature)) == 0) {
+     return fts3tokEofMethod(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_jsonEachEof_enum], sizeof(E->xEof_signature)) == 0) {
+     return jsonEachEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_pragmaVtabEof_enum], sizeof(E->xEof_signature)) == 0) {
+     return pragmaVtabEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_rtreeEof_enum], sizeof(E->xEof_signature)) == 0) {
+     return rtreeEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_seriesEof_enum], sizeof(E->xEof_signature)) == 0) {
+     return seriesEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_statEof_enum], sizeof(E->xEof_signature)) == 0) {
+     return statEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_stmtEof_enum], sizeof(E->xEof_signature)) == 0) {
+     return stmtEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_zipfileEof_enum], sizeof(E->xEof_signature)) == 0) {
+     return zipfileEof(args);
+ }


// FP: xExprCallback
// Candidates: agginfoPersistExprCb, aggregateIdxEprRefToColCallback, analyzeAggregate, checkConstraintExprNode, codeCursorHintCheckExpr, codeCursorHintFixExpr, codeCursorHintIsOrFunction, disallowAggregatesInOrderByCb, exprColumnFlagUnion, exprIdxCover, exprNodeCanReturnSubtype, exprNodeIsConstant, exprNodeIsConstantOrGroupBy, exprNodeIsDeterministic, exprRefToSrcList, fixExprCb, gatherSelectWindowsCallback, havingToWhereExprCb, impliesNotNullRow, incrAggDepth, markImmutableExprStep, propagateConstantExprRewrite, recomputeColumnsUsedExpr, renameColumnExprCb, renameQuotefixExprCb, renameTableExprCb, renameUnmapExprCb, renumberCursorsCb, resolveExprStep, resolveRemoveWindowsCb, selectCheckOnClausesExpr, selectWindowRewriteExprCb, sqlite3CursorRangeHintExprCheck, sqlite3ExprWalkNoop, sqlite3ReturningSubqueryVarSelect, sqlite3WindowExtraAggFuncDepth, whereIsCoveringIndexWalkCallback

@transform_return_xExprCallback_arrow@
expression E;
identifier FP_NAME = xExprCallback;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_agginfoPersistExprCb_enum], sizeof(E->xExprCallback_signature)) == 0) {
+     return agginfoPersistExprCb(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_aggregateIdxEprRefToColCallback_enum], sizeof(E->xExprCallback_signature)) == 0) {
+     return aggregateIdxEprRefToColCallback(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_analyzeAggregate_enum], sizeof(E->xExprCallback_signature)) == 0) {
+     return analyzeAggregate(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_checkConstraintExprNode_enum], sizeof(E->xExprCallback_signature)) == 0) {
+     return checkConstraintExprNode(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_codeCursorHintCheckExpr_enum], sizeof(E->xExprCallback_signature)) == 0) {
+     return codeCursorHintCheckExpr(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_codeCursorHintFixExpr_enum], sizeof(E->xExprCallback_signature)) == 0) {
+     return codeCursorHintFixExpr(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_codeCursorHintIsOrFunction_enum], sizeof(E->xExprCallback_signature)) == 0) {
+     return codeCursorHintIsOrFunction(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_disallowAggregatesInOrderByCb_enum], sizeof(E->xExprCallback_signature)) == 0) {
+     return disallowAggregatesInOrderByCb(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprColumnFlagUnion_enum], sizeof(E->xExprCallback_signature)) == 0) {
+     return exprColumnFlagUnion(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprIdxCover_enum], sizeof(E->xExprCallback_signature)) == 0) {
+     return exprIdxCover(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprNodeCanReturnSubtype_enum], sizeof(E->xExprCallback_signature)) == 0) {
+     return exprNodeCanReturnSubtype(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprNodeIsConstant_enum], sizeof(E->xExprCallback_signature)) == 0) {
+     return exprNodeIsConstant(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprNodeIsConstantOrGroupBy_enum], sizeof(E->xExprCallback_signature)) == 0) {
+     return exprNodeIsConstantOrGroupBy(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprNodeIsDeterministic_enum], sizeof(E->xExprCallback_signature)) == 0) {
+     return exprNodeIsDeterministic(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprRefToSrcList_enum], sizeof(E->xExprCallback_signature)) == 0) {
+     return exprRefToSrcList(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_fixExprCb_enum], sizeof(E->xExprCallback_signature)) == 0) {
+     return fixExprCb(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_gatherSelectWindowsCallback_enum], sizeof(E->xExprCallback_signature)) == 0) {
+     return gatherSelectWindowsCallback(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_havingToWhereExprCb_enum], sizeof(E->xExprCallback_signature)) == 0) {
+     return havingToWhereExprCb(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_impliesNotNullRow_enum], sizeof(E->xExprCallback_signature)) == 0) {
+     return impliesNotNullRow(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_incrAggDepth_enum], sizeof(E->xExprCallback_signature)) == 0) {
+     return incrAggDepth(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_markImmutableExprStep_enum], sizeof(E->xExprCallback_signature)) == 0) {
+     return markImmutableExprStep(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_propagateConstantExprRewrite_enum], sizeof(E->xExprCallback_signature)) == 0) {
+     return propagateConstantExprRewrite(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_recomputeColumnsUsedExpr_enum], sizeof(E->xExprCallback_signature)) == 0) {
+     return recomputeColumnsUsedExpr(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_renameColumnExprCb_enum], sizeof(E->xExprCallback_signature)) == 0) {
+     return renameColumnExprCb(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_renameQuotefixExprCb_enum], sizeof(E->xExprCallback_signature)) == 0) {
+     return renameQuotefixExprCb(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_renameTableExprCb_enum], sizeof(E->xExprCallback_signature)) == 0) {
+     return renameTableExprCb(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_renameUnmapExprCb_enum], sizeof(E->xExprCallback_signature)) == 0) {
+     return renameUnmapExprCb(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_renumberCursorsCb_enum], sizeof(E->xExprCallback_signature)) == 0) {
+     return renumberCursorsCb(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_resolveExprStep_enum], sizeof(E->xExprCallback_signature)) == 0) {
+     return resolveExprStep(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_resolveRemoveWindowsCb_enum], sizeof(E->xExprCallback_signature)) == 0) {
+     return resolveRemoveWindowsCb(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_selectCheckOnClausesExpr_enum], sizeof(E->xExprCallback_signature)) == 0) {
+     return selectCheckOnClausesExpr(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_selectWindowRewriteExprCb_enum], sizeof(E->xExprCallback_signature)) == 0) {
+     return selectWindowRewriteExprCb(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_sqlite3CursorRangeHintExprCheck_enum], sizeof(E->xExprCallback_signature)) == 0) {
+     return sqlite3CursorRangeHintExprCheck(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_sqlite3ExprWalkNoop_enum], sizeof(E->xExprCallback_signature)) == 0) {
+     return sqlite3ExprWalkNoop(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_sqlite3ReturningSubqueryVarSelect_enum], sizeof(E->xExprCallback_signature)) == 0) {
+     return sqlite3ReturningSubqueryVarSelect(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_sqlite3WindowExtraAggFuncDepth_enum], sizeof(E->xExprCallback_signature)) == 0) {
+     return sqlite3WindowExtraAggFuncDepth(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_whereIsCoveringIndexWalkCallback_enum], sizeof(E->xExprCallback_signature)) == 0) {
+     return whereIsCoveringIndexWalkCallback(args);
+ }


// FP: xFetch
// Candidates: 0, apndFetch, memdbFetch, pcache1Fetch, pcachetraceFetch, recoverVfsFetch

@transform_return_xFetch_arrow@
expression E;
identifier FP_NAME = xFetch;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xFetch_signature, xFetch_signatures[xFetch_0_enum], sizeof(E->xFetch_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xFetch_signature, xFetch_signatures[xFetch_apndFetch_enum], sizeof(E->xFetch_signature)) == 0) {
+     return apndFetch(args);
+ }
+ else if (memcmp(E->xFetch_signature, xFetch_signatures[xFetch_memdbFetch_enum], sizeof(E->xFetch_signature)) == 0) {
+     return memdbFetch(args);
+ }
+ else if (memcmp(E->xFetch_signature, xFetch_signatures[xFetch_pcache1Fetch_enum], sizeof(E->xFetch_signature)) == 0) {
+     return pcache1Fetch(args);
+ }
+ else if (memcmp(E->xFetch_signature, xFetch_signatures[xFetch_pcachetraceFetch_enum], sizeof(E->xFetch_signature)) == 0) {
+     return pcachetraceFetch(args);
+ }
+ else if (memcmp(E->xFetch_signature, xFetch_signatures[xFetch_recoverVfsFetch_enum], sizeof(E->xFetch_signature)) == 0) {
+     return recoverVfsFetch(args);
+ }


// FP: xFileControl
// Candidates: 0, apndFileControl, memdbFileControl, recoverVfsFileControl, vfstraceFileControl

@transform_return_xFileControl_arrow@
expression E;
identifier FP_NAME = xFileControl;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xFileControl_signature, xFileControl_signatures[xFileControl_0_enum], sizeof(E->xFileControl_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xFileControl_signature, xFileControl_signatures[xFileControl_apndFileControl_enum], sizeof(E->xFileControl_signature)) == 0) {
+     return apndFileControl(args);
+ }
+ else if (memcmp(E->xFileControl_signature, xFileControl_signatures[xFileControl_memdbFileControl_enum], sizeof(E->xFileControl_signature)) == 0) {
+     return memdbFileControl(args);
+ }
+ else if (memcmp(E->xFileControl_signature, xFileControl_signatures[xFileControl_recoverVfsFileControl_enum], sizeof(E->xFileControl_signature)) == 0) {
+     return recoverVfsFileControl(args);
+ }
+ else if (memcmp(E->xFileControl_signature, xFileControl_signatures[xFileControl_vfstraceFileControl_enum], sizeof(E->xFileControl_signature)) == 0) {
+     return vfstraceFileControl(args);
+ }


// FP: xFileSize
// Candidates: apndFileSize, memdbFileSize, memjrnlFileSize, recoverVfsFileSize, vfstraceFileSize

@transform_return_xFileSize_arrow@
expression E;
identifier FP_NAME = xFileSize;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xFileSize_signature, xFileSize_signatures[xFileSize_apndFileSize_enum], sizeof(E->xFileSize_signature)) == 0) {
+     return apndFileSize(args);
+ }
+ else if (memcmp(E->xFileSize_signature, xFileSize_signatures[xFileSize_memdbFileSize_enum], sizeof(E->xFileSize_signature)) == 0) {
+     return memdbFileSize(args);
+ }
+ else if (memcmp(E->xFileSize_signature, xFileSize_signatures[xFileSize_memjrnlFileSize_enum], sizeof(E->xFileSize_signature)) == 0) {
+     return memjrnlFileSize(args);
+ }
+ else if (memcmp(E->xFileSize_signature, xFileSize_signatures[xFileSize_recoverVfsFileSize_enum], sizeof(E->xFileSize_signature)) == 0) {
+     return recoverVfsFileSize(args);
+ }
+ else if (memcmp(E->xFileSize_signature, xFileSize_signatures[xFileSize_vfstraceFileSize_enum], sizeof(E->xFileSize_signature)) == 0) {
+     return vfstraceFileSize(args);
+ }


// FP: xFilter
// Candidates: bytecodevtabFilter, completionFilter, dbdataFilter, dbpageFilter, expertFilter, fsdirFilter, fts3FilterMethod, fts3auxFilterMethod, fts3tokFilterMethod, geopolyFilter, jsonEachFilter, pragmaVtabFilter, rtreeFilter, seriesFilter, statFilter, stmtFilter, zipfileFilter

@transform_return_xFilter_arrow@
expression E;
identifier FP_NAME = xFilter;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_bytecodevtabFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+     return bytecodevtabFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_completionFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+     return completionFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_dbdataFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+     return dbdataFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_dbpageFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+     return dbpageFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_expertFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+     return expertFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_fsdirFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+     return fsdirFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_fts3FilterMethod_enum], sizeof(E->xFilter_signature)) == 0) {
+     return fts3FilterMethod(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_fts3auxFilterMethod_enum], sizeof(E->xFilter_signature)) == 0) {
+     return fts3auxFilterMethod(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_fts3tokFilterMethod_enum], sizeof(E->xFilter_signature)) == 0) {
+     return fts3tokFilterMethod(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_geopolyFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+     return geopolyFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_jsonEachFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+     return jsonEachFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_pragmaVtabFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+     return pragmaVtabFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_rtreeFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+     return rtreeFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_seriesFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+     return seriesFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_statFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+     return statFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_stmtFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+     return stmtFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_zipfileFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+     return zipfileFilter(args);
+ }


// FP: xFinalize
// Candidates: 0, decimalSumFinalize, dummyUDFvalue, percentFinal, sha3AggFinal, zipfileFinal

@transform_return_xFinalize_arrow@
expression E;
identifier FP_NAME = xFinalize;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xFinalize_signature, xFinalize_signatures[xFinalize_0_enum], sizeof(E->xFinalize_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xFinalize_signature, xFinalize_signatures[xFinalize_decimalSumFinalize_enum], sizeof(E->xFinalize_signature)) == 0) {
+     return decimalSumFinalize(args);
+ }
+ else if (memcmp(E->xFinalize_signature, xFinalize_signatures[xFinalize_dummyUDFvalue_enum], sizeof(E->xFinalize_signature)) == 0) {
+     return dummyUDFvalue(args);
+ }
+ else if (memcmp(E->xFinalize_signature, xFinalize_signatures[xFinalize_percentFinal_enum], sizeof(E->xFinalize_signature)) == 0) {
+     return percentFinal(args);
+ }
+ else if (memcmp(E->xFinalize_signature, xFinalize_signatures[xFinalize_sha3AggFinal_enum], sizeof(E->xFinalize_signature)) == 0) {
+     return sha3AggFinal(args);
+ }
+ else if (memcmp(E->xFinalize_signature, xFinalize_signatures[xFinalize_zipfileFinal_enum], sizeof(E->xFinalize_signature)) == 0) {
+     return zipfileFinal(args);
+ }


// FP: xFindFunction
// Candidates: 0, fts3FindFunctionMethod, zipfileFindFunction

@transform_return_xFindFunction_arrow@
expression E;
identifier FP_NAME = xFindFunction;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xFindFunction_signature, xFindFunction_signatures[xFindFunction_0_enum], sizeof(E->xFindFunction_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xFindFunction_signature, xFindFunction_signatures[xFindFunction_fts3FindFunctionMethod_enum], sizeof(E->xFindFunction_signature)) == 0) {
+     return fts3FindFunctionMethod(args);
+ }
+ else if (memcmp(E->xFindFunction_signature, xFindFunction_signatures[xFindFunction_zipfileFindFunction_enum], sizeof(E->xFindFunction_signature)) == 0) {
+     return zipfileFindFunction(args);
+ }


// FP: xFree
// Candidates: memtraceFree, sqlite3MemFree

@transform_return_xFree_arrow@
expression E;
identifier FP_NAME = xFree;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xFree_signature, xFree_signatures[xFree_memtraceFree_enum], sizeof(E->xFree_signature)) == 0) {
+     return memtraceFree(args);
+ }
+ else if (memcmp(E->xFree_signature, xFree_signatures[xFree_sqlite3MemFree_enum], sizeof(E->xFree_signature)) == 0) {
+     return sqlite3MemFree(args);
+ }


// FP: xFreeSchema
// Candidates: 0, sqlite3RCStrUnref, sqlite3SchemaClear

@transform_return_xFreeSchema_arrow@
expression E;
identifier FP_NAME = xFreeSchema;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xFreeSchema_signature, xFreeSchema_signatures[xFreeSchema_0_enum], sizeof(E->xFreeSchema_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xFreeSchema_signature, xFreeSchema_signatures[xFreeSchema_sqlite3RCStrUnref_enum], sizeof(E->xFreeSchema_signature)) == 0) {
+     return sqlite3RCStrUnref(args);
+ }
+ else if (memcmp(E->xFreeSchema_signature, xFreeSchema_signatures[xFreeSchema_sqlite3SchemaClear_enum], sizeof(E->xFreeSchema_signature)) == 0) {
+     return sqlite3SchemaClear(args);
+ }


// FP: xFullPathname
// Candidates: apndFullPathname, memdbFullPathname, vfstraceFullPathname, unixFullPathname

@transform_return_xFullPathname_arrow@
expression E;
identifier FP_NAME = xFullPathname;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xFullPathname_signature, xFullPathname_signatures[xFullPathname_apndFullPathname_enum], sizeof(E->xFullPathname_signature)) == 0) {
+     return apndFullPathname(args);
+ }
+ else if (memcmp(E->xFullPathname_signature, xFullPathname_signatures[xFullPathname_memdbFullPathname_enum], sizeof(E->xFullPathname_signature)) == 0) {
+     return memdbFullPathname(args);
+ }
+ else if (memcmp(E->xFullPathname_signature, xFullPathname_signatures[xFullPathname_vfstraceFullPathname_enum], sizeof(E->xFullPathname_signature)) == 0) {
+     return vfstraceFullPathname(args);
+ }
+ else if (memcmp(E->xFullPathname_signature, xFullPathname_signatures[xFullPathname_unixFullPathname_enum], sizeof(E->xFullPathname_signature)) == 0) {
+     return unixFullPathname(args);
+ }


// FP: xFunc
// Candidates: 0, base64, base85, dummyUDF, editFunc, fts3AllocateMSI, fts3ExprGlobalHitsCb, fts3ExprLoadDoclistsCb, fts3ExprLocalHitsCb, fts3ExprPhraseCountCb, fts3ExprRestartIfCb, fts3ExprTermOffsetInit, fts3ExprTest, fts3ExprTestRebalance, fts3MatchinfoLcsCb, fts3SnippetFindPositions, fts3TokenizerFunc, geomCallback, idxRemFunc, idxSampleFunc, intTestFunc, intckParseCreateIndexFunc, is_base85, lsModeFunc, rbuFossilDeltaFunc, rbuIndexCntFunc, rbuTargetNameFunc, rbuTmpInsertFunc, re_bytecode_func, re_sql_func, readfileFunc, rtreecheck, rtreedepth, rtreenode, sha1Func, sha1QueryFunc, sha3Func, sha3QueryFunc, shellAddSchemaName, shellDtostr, shellFkeyCollateClause, shellModuleSchema, shellPutsFunc, shellStrtod, shellUSleepFunc, sqlarCompressFunc, sqlarUncompressFunc, sqlite3InvalidFunction, stmtrandFunc, testFunc, writefileFunc

@transform_return_xFunc_arrow@
expression E;
identifier FP_NAME = xFunc;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_0_enum], sizeof(E->xFunc_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_base64_enum], sizeof(E->xFunc_signature)) == 0) {
+     return base64(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_base85_enum], sizeof(E->xFunc_signature)) == 0) {
+     return base85(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_dummyUDF_enum], sizeof(E->xFunc_signature)) == 0) {
+     return dummyUDF(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_editFunc_enum], sizeof(E->xFunc_signature)) == 0) {
+     return editFunc(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_fts3AllocateMSI_enum], sizeof(E->xFunc_signature)) == 0) {
+     return fts3AllocateMSI(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_fts3ExprGlobalHitsCb_enum], sizeof(E->xFunc_signature)) == 0) {
+     return fts3ExprGlobalHitsCb(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_fts3ExprLoadDoclistsCb_enum], sizeof(E->xFunc_signature)) == 0) {
+     return fts3ExprLoadDoclistsCb(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_fts3ExprLocalHitsCb_enum], sizeof(E->xFunc_signature)) == 0) {
+     return fts3ExprLocalHitsCb(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_fts3ExprPhraseCountCb_enum], sizeof(E->xFunc_signature)) == 0) {
+     return fts3ExprPhraseCountCb(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_fts3ExprRestartIfCb_enum], sizeof(E->xFunc_signature)) == 0) {
+     return fts3ExprRestartIfCb(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_fts3ExprTermOffsetInit_enum], sizeof(E->xFunc_signature)) == 0) {
+     return fts3ExprTermOffsetInit(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_fts3ExprTest_enum], sizeof(E->xFunc_signature)) == 0) {
+     return fts3ExprTest(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_fts3ExprTestRebalance_enum], sizeof(E->xFunc_signature)) == 0) {
+     return fts3ExprTestRebalance(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_fts3MatchinfoLcsCb_enum], sizeof(E->xFunc_signature)) == 0) {
+     return fts3MatchinfoLcsCb(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_fts3SnippetFindPositions_enum], sizeof(E->xFunc_signature)) == 0) {
+     return fts3SnippetFindPositions(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_fts3TokenizerFunc_enum], sizeof(E->xFunc_signature)) == 0) {
+     return fts3TokenizerFunc(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_geomCallback_enum], sizeof(E->xFunc_signature)) == 0) {
+     return geomCallback(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_idxRemFunc_enum], sizeof(E->xFunc_signature)) == 0) {
+     return idxRemFunc(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_idxSampleFunc_enum], sizeof(E->xFunc_signature)) == 0) {
+     return idxSampleFunc(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_intTestFunc_enum], sizeof(E->xFunc_signature)) == 0) {
+     return intTestFunc(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_intckParseCreateIndexFunc_enum], sizeof(E->xFunc_signature)) == 0) {
+     return intckParseCreateIndexFunc(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_is_base85_enum], sizeof(E->xFunc_signature)) == 0) {
+     return is_base85(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_lsModeFunc_enum], sizeof(E->xFunc_signature)) == 0) {
+     return lsModeFunc(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_rbuFossilDeltaFunc_enum], sizeof(E->xFunc_signature)) == 0) {
+     return rbuFossilDeltaFunc(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_rbuIndexCntFunc_enum], sizeof(E->xFunc_signature)) == 0) {
+     return rbuIndexCntFunc(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_rbuTargetNameFunc_enum], sizeof(E->xFunc_signature)) == 0) {
+     return rbuTargetNameFunc(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_rbuTmpInsertFunc_enum], sizeof(E->xFunc_signature)) == 0) {
+     return rbuTmpInsertFunc(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_re_bytecode_func_enum], sizeof(E->xFunc_signature)) == 0) {
+     return re_bytecode_func(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_re_sql_func_enum], sizeof(E->xFunc_signature)) == 0) {
+     return re_sql_func(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_readfileFunc_enum], sizeof(E->xFunc_signature)) == 0) {
+     return readfileFunc(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_rtreecheck_enum], sizeof(E->xFunc_signature)) == 0) {
+     return rtreecheck(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_rtreedepth_enum], sizeof(E->xFunc_signature)) == 0) {
+     return rtreedepth(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_rtreenode_enum], sizeof(E->xFunc_signature)) == 0) {
+     return rtreenode(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_sha1Func_enum], sizeof(E->xFunc_signature)) == 0) {
+     return sha1Func(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_sha1QueryFunc_enum], sizeof(E->xFunc_signature)) == 0) {
+     return sha1QueryFunc(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_sha3Func_enum], sizeof(E->xFunc_signature)) == 0) {
+     return sha3Func(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_sha3QueryFunc_enum], sizeof(E->xFunc_signature)) == 0) {
+     return sha3QueryFunc(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_shellAddSchemaName_enum], sizeof(E->xFunc_signature)) == 0) {
+     return shellAddSchemaName(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_shellDtostr_enum], sizeof(E->xFunc_signature)) == 0) {
+     return shellDtostr(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_shellFkeyCollateClause_enum], sizeof(E->xFunc_signature)) == 0) {
+     return shellFkeyCollateClause(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_shellModuleSchema_enum], sizeof(E->xFunc_signature)) == 0) {
+     return shellModuleSchema(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_shellPutsFunc_enum], sizeof(E->xFunc_signature)) == 0) {
+     return shellPutsFunc(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_shellStrtod_enum], sizeof(E->xFunc_signature)) == 0) {
+     return shellStrtod(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_shellUSleepFunc_enum], sizeof(E->xFunc_signature)) == 0) {
+     return shellUSleepFunc(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_sqlarCompressFunc_enum], sizeof(E->xFunc_signature)) == 0) {
+     return sqlarCompressFunc(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_sqlarUncompressFunc_enum], sizeof(E->xFunc_signature)) == 0) {
+     return sqlarUncompressFunc(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_sqlite3InvalidFunction_enum], sizeof(E->xFunc_signature)) == 0) {
+     return sqlite3InvalidFunction(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_stmtrandFunc_enum], sizeof(E->xFunc_signature)) == 0) {
+     return stmtrandFunc(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_testFunc_enum], sizeof(E->xFunc_signature)) == 0) {
+     return testFunc(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_writefileFunc_enum], sizeof(E->xFunc_signature)) == 0) {
+     return writefileFunc(args);
+ }


// FP: xGeom
// Candidates: 0

@transform_return_xGeom_arrow@
expression E;
identifier FP_NAME = xGeom;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return 0(args);


// FP: xGet
// Candidates: getPageError, getPageMMap, getPageNormal

@transform_return_xGet_arrow@
expression E;
identifier FP_NAME = xGet;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xGet_signature, xGet_signatures[xGet_getPageError_enum], sizeof(E->xGet_signature)) == 0) {
+     return getPageError(args);
+ }
+ else if (memcmp(E->xGet_signature, xGet_signatures[xGet_getPageMMap_enum], sizeof(E->xGet_signature)) == 0) {
+     return getPageMMap(args);
+ }
+ else if (memcmp(E->xGet_signature, xGet_signatures[xGet_getPageNormal_enum], sizeof(E->xGet_signature)) == 0) {
+     return getPageNormal(args);
+ }


// FP: xGetLastError
// Candidates: 0, apndGetLastError, memdbGetLastError, unixGetLastError

@transform_return_xGetLastError_arrow@
expression E;
identifier FP_NAME = xGetLastError;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xGetLastError_signature, xGetLastError_signatures[xGetLastError_0_enum], sizeof(E->xGetLastError_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xGetLastError_signature, xGetLastError_signatures[xGetLastError_apndGetLastError_enum], sizeof(E->xGetLastError_signature)) == 0) {
+     return apndGetLastError(args);
+ }
+ else if (memcmp(E->xGetLastError_signature, xGetLastError_signatures[xGetLastError_memdbGetLastError_enum], sizeof(E->xGetLastError_signature)) == 0) {
+     return memdbGetLastError(args);
+ }
+ else if (memcmp(E->xGetLastError_signature, xGetLastError_signatures[xGetLastError_unixGetLastError_enum], sizeof(E->xGetLastError_signature)) == 0) {
+     return unixGetLastError(args);
+ }


// FP: xGetSystemCall
// Candidates: 0, apndGetSystemCall, unixGetSystemCall

@transform_return_xGetSystemCall_arrow@
expression E;
identifier FP_NAME = xGetSystemCall;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xGetSystemCall_signature, xGetSystemCall_signatures[xGetSystemCall_0_enum], sizeof(E->xGetSystemCall_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xGetSystemCall_signature, xGetSystemCall_signatures[xGetSystemCall_apndGetSystemCall_enum], sizeof(E->xGetSystemCall_signature)) == 0) {
+     return apndGetSystemCall(args);
+ }
+ else if (memcmp(E->xGetSystemCall_signature, xGetSystemCall_signatures[xGetSystemCall_unixGetSystemCall_enum], sizeof(E->xGetSystemCall_signature)) == 0) {
+     return unixGetSystemCall(args);
+ }


// FP: xInit
// Candidates: memtraceInit, pcache1Init, pcachetraceInit, sqlite3MemInit

@transform_return_xInit_arrow@
expression E;
identifier FP_NAME = xInit;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xInit_signature, xInit_signatures[xInit_memtraceInit_enum], sizeof(E->xInit_signature)) == 0) {
+     return memtraceInit(args);
+ }
+ else if (memcmp(E->xInit_signature, xInit_signatures[xInit_pcache1Init_enum], sizeof(E->xInit_signature)) == 0) {
+     return pcache1Init(args);
+ }
+ else if (memcmp(E->xInit_signature, xInit_signatures[xInit_pcachetraceInit_enum], sizeof(E->xInit_signature)) == 0) {
+     return pcachetraceInit(args);
+ }
+ else if (memcmp(E->xInit_signature, xInit_signatures[xInit_sqlite3MemInit_enum], sizeof(E->xInit_signature)) == 0) {
+     return sqlite3MemInit(args);
+ }


// FP: xInput
// Candidates: 0

@transform_return_xInput_arrow@
expression E;
identifier FP_NAME = xInput;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return 0(args);


// FP: xIntegrity
// Candidates: 0, fts3IntegrityMethod, rtreeIntegrity

@transform_return_xIntegrity_arrow@
expression E;
identifier FP_NAME = xIntegrity;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xIntegrity_signature, xIntegrity_signatures[xIntegrity_0_enum], sizeof(E->xIntegrity_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xIntegrity_signature, xIntegrity_signatures[xIntegrity_fts3IntegrityMethod_enum], sizeof(E->xIntegrity_signature)) == 0) {
+     return fts3IntegrityMethod(args);
+ }
+ else if (memcmp(E->xIntegrity_signature, xIntegrity_signatures[xIntegrity_rtreeIntegrity_enum], sizeof(E->xIntegrity_signature)) == 0) {
+     return rtreeIntegrity(args);
+ }


// FP: xInverse
// Candidates: 0, decimalSumInverse, percentInverse

@transform_return_xInverse_arrow@
expression E;
identifier FP_NAME = xInverse;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xInverse_signature, xInverse_signatures[xInverse_0_enum], sizeof(E->xInverse_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xInverse_signature, xInverse_signatures[xInverse_decimalSumInverse_enum], sizeof(E->xInverse_signature)) == 0) {
+     return decimalSumInverse(args);
+ }
+ else if (memcmp(E->xInverse_signature, xInverse_signatures[xInverse_percentInverse_enum], sizeof(E->xInverse_signature)) == 0) {
+     return percentInverse(args);
+ }


// FP: xLanguageid
// Candidates: 0

@transform_return_xLanguageid_arrow@
expression E;
identifier FP_NAME = xLanguageid;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return 0(args);


// FP: xLock
// Candidates: 0, apndLock, memdbLock, recoverVfsLock, vfstraceLock

@transform_return_xLock_arrow@
expression E;
identifier FP_NAME = xLock;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xLock_signature, xLock_signatures[xLock_0_enum], sizeof(E->xLock_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xLock_signature, xLock_signatures[xLock_apndLock_enum], sizeof(E->xLock_signature)) == 0) {
+     return apndLock(args);
+ }
+ else if (memcmp(E->xLock_signature, xLock_signatures[xLock_memdbLock_enum], sizeof(E->xLock_signature)) == 0) {
+     return memdbLock(args);
+ }
+ else if (memcmp(E->xLock_signature, xLock_signatures[xLock_recoverVfsLock_enum], sizeof(E->xLock_signature)) == 0) {
+     return recoverVfsLock(args);
+ }
+ else if (memcmp(E->xLock_signature, xLock_signatures[xLock_vfstraceLock_enum], sizeof(E->xLock_signature)) == 0) {
+     return vfstraceLock(args);
+ }


// FP: xLog
// Candidates: 0

@transform_return_xLog_arrow@
expression E;
identifier FP_NAME = xLog;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return 0(args);


// FP: xMalloc
// Candidates: memtraceMalloc, sqlite3MemMalloc

@transform_return_xMalloc_arrow@
expression E;
identifier FP_NAME = xMalloc;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xMalloc_signature, xMalloc_signatures[xMalloc_memtraceMalloc_enum], sizeof(E->xMalloc_signature)) == 0) {
+     return memtraceMalloc(args);
+ }
+ else if (memcmp(E->xMalloc_signature, xMalloc_signatures[xMalloc_sqlite3MemMalloc_enum], sizeof(E->xMalloc_signature)) == 0) {
+     return sqlite3MemMalloc(args);
+ }


// FP: xMutexAlloc
// Candidates: checkMutexAlloc, debugMutexAlloc, noopMutexAlloc, pthreadMutexAlloc, winMutexAlloc

@transform_return_xMutexAlloc_arrow@
expression E;
identifier FP_NAME = xMutexAlloc;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_checkMutexAlloc_enum], sizeof(E->xMutexAlloc_signature)) == 0) {
+     return checkMutexAlloc(args);
+ }
+ else if (memcmp(E->xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_debugMutexAlloc_enum], sizeof(E->xMutexAlloc_signature)) == 0) {
+     return debugMutexAlloc(args);
+ }
+ else if (memcmp(E->xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_noopMutexAlloc_enum], sizeof(E->xMutexAlloc_signature)) == 0) {
+     return noopMutexAlloc(args);
+ }
+ else if (memcmp(E->xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_pthreadMutexAlloc_enum], sizeof(E->xMutexAlloc_signature)) == 0) {
+     return pthreadMutexAlloc(args);
+ }
+ else if (memcmp(E->xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_winMutexAlloc_enum], sizeof(E->xMutexAlloc_signature)) == 0) {
+     return winMutexAlloc(args);
+ }


// FP: xMutexEnd
// Candidates: checkMutexEnd, debugMutexEnd, noopMutexEnd, pthreadMutexEnd, winMutexEnd

@transform_return_xMutexEnd_arrow@
expression E;
identifier FP_NAME = xMutexEnd;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_checkMutexEnd_enum], sizeof(E->xMutexEnd_signature)) == 0) {
+     return checkMutexEnd(args);
+ }
+ else if (memcmp(E->xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_debugMutexEnd_enum], sizeof(E->xMutexEnd_signature)) == 0) {
+     return debugMutexEnd(args);
+ }
+ else if (memcmp(E->xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_noopMutexEnd_enum], sizeof(E->xMutexEnd_signature)) == 0) {
+     return noopMutexEnd(args);
+ }
+ else if (memcmp(E->xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_pthreadMutexEnd_enum], sizeof(E->xMutexEnd_signature)) == 0) {
+     return pthreadMutexEnd(args);
+ }
+ else if (memcmp(E->xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_winMutexEnd_enum], sizeof(E->xMutexEnd_signature)) == 0) {
+     return winMutexEnd(args);
+ }


// FP: xMutexEnter
// Candidates: checkMutexEnter, debugMutexEnter, noopMutexEnter, pthreadMutexEnter, winMutexEnter

@transform_return_xMutexEnter_arrow@
expression E;
identifier FP_NAME = xMutexEnter;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_checkMutexEnter_enum], sizeof(E->xMutexEnter_signature)) == 0) {
+     return checkMutexEnter(args);
+ }
+ else if (memcmp(E->xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_debugMutexEnter_enum], sizeof(E->xMutexEnter_signature)) == 0) {
+     return debugMutexEnter(args);
+ }
+ else if (memcmp(E->xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_noopMutexEnter_enum], sizeof(E->xMutexEnter_signature)) == 0) {
+     return noopMutexEnter(args);
+ }
+ else if (memcmp(E->xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_pthreadMutexEnter_enum], sizeof(E->xMutexEnter_signature)) == 0) {
+     return pthreadMutexEnter(args);
+ }
+ else if (memcmp(E->xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_winMutexEnter_enum], sizeof(E->xMutexEnter_signature)) == 0) {
+     return winMutexEnter(args);
+ }


// FP: xMutexFree
// Candidates: checkMutexFree, debugMutexFree, noopMutexFree, pthreadMutexFree, winMutexFree

@transform_return_xMutexFree_arrow@
expression E;
identifier FP_NAME = xMutexFree;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xMutexFree_signature, xMutexFree_signatures[xMutexFree_checkMutexFree_enum], sizeof(E->xMutexFree_signature)) == 0) {
+     return checkMutexFree(args);
+ }
+ else if (memcmp(E->xMutexFree_signature, xMutexFree_signatures[xMutexFree_debugMutexFree_enum], sizeof(E->xMutexFree_signature)) == 0) {
+     return debugMutexFree(args);
+ }
+ else if (memcmp(E->xMutexFree_signature, xMutexFree_signatures[xMutexFree_noopMutexFree_enum], sizeof(E->xMutexFree_signature)) == 0) {
+     return noopMutexFree(args);
+ }
+ else if (memcmp(E->xMutexFree_signature, xMutexFree_signatures[xMutexFree_pthreadMutexFree_enum], sizeof(E->xMutexFree_signature)) == 0) {
+     return pthreadMutexFree(args);
+ }
+ else if (memcmp(E->xMutexFree_signature, xMutexFree_signatures[xMutexFree_winMutexFree_enum], sizeof(E->xMutexFree_signature)) == 0) {
+     return winMutexFree(args);
+ }


// FP: xMutexHeld
// Candidates: 0, debugMutexHeld

@transform_return_xMutexHeld_arrow@
expression E;
identifier FP_NAME = xMutexHeld;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xMutexHeld_signature, xMutexHeld_signatures[xMutexHeld_0_enum], sizeof(E->xMutexHeld_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xMutexHeld_signature, xMutexHeld_signatures[xMutexHeld_debugMutexHeld_enum], sizeof(E->xMutexHeld_signature)) == 0) {
+     return debugMutexHeld(args);
+ }


// FP: xMutexInit
// Candidates: checkMutexInit, debugMutexInit, noopMutexInit, pthreadMutexInit, winMutexInit

@transform_return_xMutexInit_arrow@
expression E;
identifier FP_NAME = xMutexInit;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xMutexInit_signature, xMutexInit_signatures[xMutexInit_checkMutexInit_enum], sizeof(E->xMutexInit_signature)) == 0) {
+     return checkMutexInit(args);
+ }
+ else if (memcmp(E->xMutexInit_signature, xMutexInit_signatures[xMutexInit_debugMutexInit_enum], sizeof(E->xMutexInit_signature)) == 0) {
+     return debugMutexInit(args);
+ }
+ else if (memcmp(E->xMutexInit_signature, xMutexInit_signatures[xMutexInit_noopMutexInit_enum], sizeof(E->xMutexInit_signature)) == 0) {
+     return noopMutexInit(args);
+ }
+ else if (memcmp(E->xMutexInit_signature, xMutexInit_signatures[xMutexInit_pthreadMutexInit_enum], sizeof(E->xMutexInit_signature)) == 0) {
+     return pthreadMutexInit(args);
+ }
+ else if (memcmp(E->xMutexInit_signature, xMutexInit_signatures[xMutexInit_winMutexInit_enum], sizeof(E->xMutexInit_signature)) == 0) {
+     return winMutexInit(args);
+ }


// FP: xMutexLeave
// Candidates: checkMutexLeave, debugMutexLeave, noopMutexLeave, pthreadMutexLeave, winMutexLeave

@transform_return_xMutexLeave_arrow@
expression E;
identifier FP_NAME = xMutexLeave;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_checkMutexLeave_enum], sizeof(E->xMutexLeave_signature)) == 0) {
+     return checkMutexLeave(args);
+ }
+ else if (memcmp(E->xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_debugMutexLeave_enum], sizeof(E->xMutexLeave_signature)) == 0) {
+     return debugMutexLeave(args);
+ }
+ else if (memcmp(E->xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_noopMutexLeave_enum], sizeof(E->xMutexLeave_signature)) == 0) {
+     return noopMutexLeave(args);
+ }
+ else if (memcmp(E->xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_pthreadMutexLeave_enum], sizeof(E->xMutexLeave_signature)) == 0) {
+     return pthreadMutexLeave(args);
+ }
+ else if (memcmp(E->xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_winMutexLeave_enum], sizeof(E->xMutexLeave_signature)) == 0) {
+     return winMutexLeave(args);
+ }


// FP: xMutexNotheld
// Candidates: 0, debugMutexNotheld

@transform_return_xMutexNotheld_arrow@
expression E;
identifier FP_NAME = xMutexNotheld;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xMutexNotheld_signature, xMutexNotheld_signatures[xMutexNotheld_0_enum], sizeof(E->xMutexNotheld_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xMutexNotheld_signature, xMutexNotheld_signatures[xMutexNotheld_debugMutexNotheld_enum], sizeof(E->xMutexNotheld_signature)) == 0) {
+     return debugMutexNotheld(args);
+ }


// FP: xMutexTry
// Candidates: checkMutexTry, debugMutexTry, noopMutexTry, pthreadMutexTry, winMutexTry

@transform_return_xMutexTry_arrow@
expression E;
identifier FP_NAME = xMutexTry;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xMutexTry_signature, xMutexTry_signatures[xMutexTry_checkMutexTry_enum], sizeof(E->xMutexTry_signature)) == 0) {
+     return checkMutexTry(args);
+ }
+ else if (memcmp(E->xMutexTry_signature, xMutexTry_signatures[xMutexTry_debugMutexTry_enum], sizeof(E->xMutexTry_signature)) == 0) {
+     return debugMutexTry(args);
+ }
+ else if (memcmp(E->xMutexTry_signature, xMutexTry_signatures[xMutexTry_noopMutexTry_enum], sizeof(E->xMutexTry_signature)) == 0) {
+     return noopMutexTry(args);
+ }
+ else if (memcmp(E->xMutexTry_signature, xMutexTry_signatures[xMutexTry_pthreadMutexTry_enum], sizeof(E->xMutexTry_signature)) == 0) {
+     return pthreadMutexTry(args);
+ }
+ else if (memcmp(E->xMutexTry_signature, xMutexTry_signatures[xMutexTry_winMutexTry_enum], sizeof(E->xMutexTry_signature)) == 0) {
+     return winMutexTry(args);
+ }


// FP: xNew
// Candidates: sessionDiffNew, sessionPreupdateNew, sessionStat1New

@transform_return_xNew_arrow@
expression E;
identifier FP_NAME = xNew;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xNew_signature, xNew_signatures[xNew_sessionDiffNew_enum], sizeof(E->xNew_signature)) == 0) {
+     return sessionDiffNew(args);
+ }
+ else if (memcmp(E->xNew_signature, xNew_signatures[xNew_sessionPreupdateNew_enum], sizeof(E->xNew_signature)) == 0) {
+     return sessionPreupdateNew(args);
+ }
+ else if (memcmp(E->xNew_signature, xNew_signatures[xNew_sessionStat1New_enum], sizeof(E->xNew_signature)) == 0) {
+     return sessionStat1New(args);
+ }


// FP: xNext
// Candidates: 0, bytecodevtabNext, completionNext, dbdataNext, dbpageNext, expertNext, fsdirNext, fts3NextMethod, fts3auxNextMethod, fts3tokNextMethod, jsonEachNext, porterNext, pragmaVtabNext, rtreeNext, seriesNext, simpleNext, statNext, stmtNext, unicodeNext, zipfileNext

@transform_return_xNext_arrow@
expression E;
identifier FP_NAME = xNext;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xNext_signature, xNext_signatures[xNext_0_enum], sizeof(E->xNext_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_bytecodevtabNext_enum], sizeof(E->xNext_signature)) == 0) {
+     return bytecodevtabNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_completionNext_enum], sizeof(E->xNext_signature)) == 0) {
+     return completionNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_dbdataNext_enum], sizeof(E->xNext_signature)) == 0) {
+     return dbdataNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_dbpageNext_enum], sizeof(E->xNext_signature)) == 0) {
+     return dbpageNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_expertNext_enum], sizeof(E->xNext_signature)) == 0) {
+     return expertNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_fsdirNext_enum], sizeof(E->xNext_signature)) == 0) {
+     return fsdirNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_fts3NextMethod_enum], sizeof(E->xNext_signature)) == 0) {
+     return fts3NextMethod(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_fts3auxNextMethod_enum], sizeof(E->xNext_signature)) == 0) {
+     return fts3auxNextMethod(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_fts3tokNextMethod_enum], sizeof(E->xNext_signature)) == 0) {
+     return fts3tokNextMethod(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_jsonEachNext_enum], sizeof(E->xNext_signature)) == 0) {
+     return jsonEachNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_porterNext_enum], sizeof(E->xNext_signature)) == 0) {
+     return porterNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_pragmaVtabNext_enum], sizeof(E->xNext_signature)) == 0) {
+     return pragmaVtabNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_rtreeNext_enum], sizeof(E->xNext_signature)) == 0) {
+     return rtreeNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_seriesNext_enum], sizeof(E->xNext_signature)) == 0) {
+     return seriesNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_simpleNext_enum], sizeof(E->xNext_signature)) == 0) {
+     return simpleNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_statNext_enum], sizeof(E->xNext_signature)) == 0) {
+     return statNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_stmtNext_enum], sizeof(E->xNext_signature)) == 0) {
+     return stmtNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_unicodeNext_enum], sizeof(E->xNext_signature)) == 0) {
+     return unicodeNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_zipfileNext_enum], sizeof(E->xNext_signature)) == 0) {
+     return zipfileNext(args);
+ }


// FP: xNextSystemCall
// Candidates: 0, apndNextSystemCall, rbuVfsGetLastError, unixNextSystemCall

@transform_return_xNextSystemCall_arrow@
expression E;
identifier FP_NAME = xNextSystemCall;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xNextSystemCall_signature, xNextSystemCall_signatures[xNextSystemCall_0_enum], sizeof(E->xNextSystemCall_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xNextSystemCall_signature, xNextSystemCall_signatures[xNextSystemCall_apndNextSystemCall_enum], sizeof(E->xNextSystemCall_signature)) == 0) {
+     return apndNextSystemCall(args);
+ }
+ else if (memcmp(E->xNextSystemCall_signature, xNextSystemCall_signatures[xNextSystemCall_rbuVfsGetLastError_enum], sizeof(E->xNextSystemCall_signature)) == 0) {
+     return rbuVfsGetLastError(args);
+ }
+ else if (memcmp(E->xNextSystemCall_signature, xNextSystemCall_signatures[xNextSystemCall_unixNextSystemCall_enum], sizeof(E->xNextSystemCall_signature)) == 0) {
+     return unixNextSystemCall(args);
+ }


// FP: xOld
// Candidates: sessionDiffOld, sessionPreupdateOld, sessionStat1Old

@transform_return_xOld_arrow@
expression E;
identifier FP_NAME = xOld;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xOld_signature, xOld_signatures[xOld_sessionDiffOld_enum], sizeof(E->xOld_signature)) == 0) {
+     return sessionDiffOld(args);
+ }
+ else if (memcmp(E->xOld_signature, xOld_signatures[xOld_sessionPreupdateOld_enum], sizeof(E->xOld_signature)) == 0) {
+     return sessionPreupdateOld(args);
+ }
+ else if (memcmp(E->xOld_signature, xOld_signatures[xOld_sessionStat1Old_enum], sizeof(E->xOld_signature)) == 0) {
+     return sessionStat1Old(args);
+ }


// FP: xOpen
// Candidates: apndOpen, bytecodevtabOpen, completionOpen, dbdataOpen, dbpageOpen, expertOpen, fsdirOpen, fts3OpenMethod, fts3auxOpenMethod, fts3tokOpenMethod, jsonEachOpen, memdbOpen, porterOpen, pragmaVtabOpen, rtreeOpen, seriesOpen, simpleOpen, statOpen, stmtOpen, unicodeOpen, vfstraceOpen, zipfileOpen, unixOpen

@transform_return_xOpen_arrow@
expression E;
identifier FP_NAME = xOpen;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_apndOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+     return apndOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_bytecodevtabOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+     return bytecodevtabOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_completionOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+     return completionOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_dbdataOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+     return dbdataOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_dbpageOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+     return dbpageOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_expertOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+     return expertOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_fsdirOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+     return fsdirOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_fts3OpenMethod_enum], sizeof(E->xOpen_signature)) == 0) {
+     return fts3OpenMethod(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_fts3auxOpenMethod_enum], sizeof(E->xOpen_signature)) == 0) {
+     return fts3auxOpenMethod(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_fts3tokOpenMethod_enum], sizeof(E->xOpen_signature)) == 0) {
+     return fts3tokOpenMethod(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_jsonEachOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+     return jsonEachOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_memdbOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+     return memdbOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_porterOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+     return porterOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_pragmaVtabOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+     return pragmaVtabOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_rtreeOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+     return rtreeOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_seriesOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+     return seriesOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_simpleOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+     return simpleOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_statOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+     return statOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_stmtOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+     return stmtOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_unicodeOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+     return unicodeOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_vfstraceOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+     return vfstraceOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_zipfileOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+     return zipfileOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_unixOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+     return unixOpen(args);
+ }


// FP: xOut
// Candidates: vfstraceOut

@transform_return_xOut_arrow@
expression E;
identifier FP_NAME = xOut;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return vfstraceOut(args);


// FP: xPagecount
// Candidates: pcache1Pagecount, pcachetracePagecount

@transform_return_xPagecount_arrow@
expression E;
identifier FP_NAME = xPagecount;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xPagecount_signature, xPagecount_signatures[xPagecount_pcache1Pagecount_enum], sizeof(E->xPagecount_signature)) == 0) {
+     return pcache1Pagecount(args);
+ }
+ else if (memcmp(E->xPagecount_signature, xPagecount_signatures[xPagecount_pcachetracePagecount_enum], sizeof(E->xPagecount_signature)) == 0) {
+     return pcachetracePagecount(args);
+ }


// FP: xParseCell
// Candidates: btreeParseCellPtr, btreeParseCellPtrIndex, btreeParseCellPtrNoPayload

@transform_return_xParseCell_arrow@
expression E;
identifier FP_NAME = xParseCell;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xParseCell_signature, xParseCell_signatures[xParseCell_btreeParseCellPtr_enum], sizeof(E->xParseCell_signature)) == 0) {
+     return btreeParseCellPtr(args);
+ }
+ else if (memcmp(E->xParseCell_signature, xParseCell_signatures[xParseCell_btreeParseCellPtrIndex_enum], sizeof(E->xParseCell_signature)) == 0) {
+     return btreeParseCellPtrIndex(args);
+ }
+ else if (memcmp(E->xParseCell_signature, xParseCell_signatures[xParseCell_btreeParseCellPtrNoPayload_enum], sizeof(E->xParseCell_signature)) == 0) {
+     return btreeParseCellPtrNoPayload(args);
+ }


// FP: xPreUpdateCallback
// Candidates: 0, sql_trace_callback, sqlite3WalDefaultHook

@transform_return_xPreUpdateCallback_arrow@
expression E;
identifier FP_NAME = xPreUpdateCallback;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xPreUpdateCallback_signature, xPreUpdateCallback_signatures[xPreUpdateCallback_0_enum], sizeof(E->xPreUpdateCallback_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xPreUpdateCallback_signature, xPreUpdateCallback_signatures[xPreUpdateCallback_sql_trace_callback_enum], sizeof(E->xPreUpdateCallback_signature)) == 0) {
+     return sql_trace_callback(args);
+ }
+ else if (memcmp(E->xPreUpdateCallback_signature, xPreUpdateCallback_signatures[xPreUpdateCallback_sqlite3WalDefaultHook_enum], sizeof(E->xPreUpdateCallback_signature)) == 0) {
+     return sqlite3WalDefaultHook(args);
+ }


// FP: xQueryFunc
// Candidates: 0

@transform_return_xQueryFunc_arrow@
expression E;
identifier FP_NAME = xQueryFunc;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return 0(args);


// FP: xRandomness
// Candidates: apndRandomness, memdbRandomness, vfstraceRandomness, unixRandomness

@transform_return_xRandomness_arrow@
expression E;
identifier FP_NAME = xRandomness;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xRandomness_signature, xRandomness_signatures[xRandomness_apndRandomness_enum], sizeof(E->xRandomness_signature)) == 0) {
+     return apndRandomness(args);
+ }
+ else if (memcmp(E->xRandomness_signature, xRandomness_signatures[xRandomness_memdbRandomness_enum], sizeof(E->xRandomness_signature)) == 0) {
+     return memdbRandomness(args);
+ }
+ else if (memcmp(E->xRandomness_signature, xRandomness_signatures[xRandomness_vfstraceRandomness_enum], sizeof(E->xRandomness_signature)) == 0) {
+     return vfstraceRandomness(args);
+ }
+ else if (memcmp(E->xRandomness_signature, xRandomness_signatures[xRandomness_unixRandomness_enum], sizeof(E->xRandomness_signature)) == 0) {
+     return unixRandomness(args);
+ }


// FP: xRead
// Candidates: apndRead, memdbRead, memjrnlRead, recoverVfsRead, vfstraceRead

@transform_return_xRead_arrow@
expression E;
identifier FP_NAME = xRead;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xRead_signature, xRead_signatures[xRead_apndRead_enum], sizeof(E->xRead_signature)) == 0) {
+     return apndRead(args);
+ }
+ else if (memcmp(E->xRead_signature, xRead_signatures[xRead_memdbRead_enum], sizeof(E->xRead_signature)) == 0) {
+     return memdbRead(args);
+ }
+ else if (memcmp(E->xRead_signature, xRead_signatures[xRead_memjrnlRead_enum], sizeof(E->xRead_signature)) == 0) {
+     return memjrnlRead(args);
+ }
+ else if (memcmp(E->xRead_signature, xRead_signatures[xRead_recoverVfsRead_enum], sizeof(E->xRead_signature)) == 0) {
+     return recoverVfsRead(args);
+ }
+ else if (memcmp(E->xRead_signature, xRead_signatures[xRead_vfstraceRead_enum], sizeof(E->xRead_signature)) == 0) {
+     return vfstraceRead(args);
+ }


// FP: xRealloc
// Candidates: memtraceRealloc, sqlite3MemRealloc

@transform_return_xRealloc_arrow@
expression E;
identifier FP_NAME = xRealloc;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xRealloc_signature, xRealloc_signatures[xRealloc_memtraceRealloc_enum], sizeof(E->xRealloc_signature)) == 0) {
+     return memtraceRealloc(args);
+ }
+ else if (memcmp(E->xRealloc_signature, xRealloc_signatures[xRealloc_sqlite3MemRealloc_enum], sizeof(E->xRealloc_signature)) == 0) {
+     return sqlite3MemRealloc(args);
+ }


// FP: xRekey
// Candidates: pcache1Rekey, pcachetraceRekey

@transform_return_xRekey_arrow@
expression E;
identifier FP_NAME = xRekey;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xRekey_signature, xRekey_signatures[xRekey_pcache1Rekey_enum], sizeof(E->xRekey_signature)) == 0) {
+     return pcache1Rekey(args);
+ }
+ else if (memcmp(E->xRekey_signature, xRekey_signatures[xRekey_pcachetraceRekey_enum], sizeof(E->xRekey_signature)) == 0) {
+     return pcachetraceRekey(args);
+ }


// FP: xRelease
// Candidates: 0, fts3ReleaseMethod

@transform_return_xRelease_arrow@
expression E;
identifier FP_NAME = xRelease;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xRelease_signature, xRelease_signatures[xRelease_0_enum], sizeof(E->xRelease_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xRelease_signature, xRelease_signatures[xRelease_fts3ReleaseMethod_enum], sizeof(E->xRelease_signature)) == 0) {
+     return fts3ReleaseMethod(args);
+ }


// FP: xRename
// Candidates: 0, fts3RenameMethod, rtreeRename, xRename

@transform_return_xRename_arrow@
expression E;
identifier FP_NAME = xRename;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xRename_signature, xRename_signatures[xRename_0_enum], sizeof(E->xRename_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xRename_signature, xRename_signatures[xRename_fts3RenameMethod_enum], sizeof(E->xRename_signature)) == 0) {
+     return fts3RenameMethod(args);
+ }
+ else if (memcmp(E->xRename_signature, xRename_signatures[xRename_rtreeRename_enum], sizeof(E->xRename_signature)) == 0) {
+     return rtreeRename(args);
+ }
+ else if (memcmp(E->xRename_signature, xRename_signatures[xRename_xRename_enum], sizeof(E->xRename_signature)) == 0) {
+     return xRename(args);
+ }


// FP: xRollback
// Candidates: 0, fts3RollbackMethod, rtreeEndTransaction, rtreeRollback, zipfileRollback

@transform_return_xRollback_arrow@
expression E;
identifier FP_NAME = xRollback;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xRollback_signature, xRollback_signatures[xRollback_0_enum], sizeof(E->xRollback_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xRollback_signature, xRollback_signatures[xRollback_fts3RollbackMethod_enum], sizeof(E->xRollback_signature)) == 0) {
+     return fts3RollbackMethod(args);
+ }
+ else if (memcmp(E->xRollback_signature, xRollback_signatures[xRollback_rtreeEndTransaction_enum], sizeof(E->xRollback_signature)) == 0) {
+     return rtreeEndTransaction(args);
+ }
+ else if (memcmp(E->xRollback_signature, xRollback_signatures[xRollback_rtreeRollback_enum], sizeof(E->xRollback_signature)) == 0) {
+     return rtreeRollback(args);
+ }
+ else if (memcmp(E->xRollback_signature, xRollback_signatures[xRollback_zipfileRollback_enum], sizeof(E->xRollback_signature)) == 0) {
+     return zipfileRollback(args);
+ }


// FP: xRollbackCallback
// Candidates: 0, sql_trace_callback, sqlite3WalDefaultHook

@transform_return_xRollbackCallback_arrow@
expression E;
identifier FP_NAME = xRollbackCallback;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xRollbackCallback_signature, xRollbackCallback_signatures[xRollbackCallback_0_enum], sizeof(E->xRollbackCallback_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xRollbackCallback_signature, xRollbackCallback_signatures[xRollbackCallback_sql_trace_callback_enum], sizeof(E->xRollbackCallback_signature)) == 0) {
+     return sql_trace_callback(args);
+ }
+ else if (memcmp(E->xRollbackCallback_signature, xRollbackCallback_signatures[xRollbackCallback_sqlite3WalDefaultHook_enum], sizeof(E->xRollbackCallback_signature)) == 0) {
+     return sqlite3WalDefaultHook(args);
+ }


// FP: xRollbackTo
// Candidates: 0, dbpageRollbackTo, fts3RollbackToMethod

@transform_return_xRollbackTo_arrow@
expression E;
identifier FP_NAME = xRollbackTo;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xRollbackTo_signature, xRollbackTo_signatures[xRollbackTo_0_enum], sizeof(E->xRollbackTo_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xRollbackTo_signature, xRollbackTo_signatures[xRollbackTo_dbpageRollbackTo_enum], sizeof(E->xRollbackTo_signature)) == 0) {
+     return dbpageRollbackTo(args);
+ }
+ else if (memcmp(E->xRollbackTo_signature, xRollbackTo_signatures[xRollbackTo_fts3RollbackToMethod_enum], sizeof(E->xRollbackTo_signature)) == 0) {
+     return fts3RollbackToMethod(args);
+ }


// FP: xRoundup
// Candidates: memtraceRoundup, sqlite3MemRoundup

@transform_return_xRoundup_arrow@
expression E;
identifier FP_NAME = xRoundup;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xRoundup_signature, xRoundup_signatures[xRoundup_memtraceRoundup_enum], sizeof(E->xRoundup_signature)) == 0) {
+     return memtraceRoundup(args);
+ }
+ else if (memcmp(E->xRoundup_signature, xRoundup_signatures[xRoundup_sqlite3MemRoundup_enum], sizeof(E->xRoundup_signature)) == 0) {
+     return sqlite3MemRoundup(args);
+ }


// FP: xRowid
// Candidates: 0, bytecodevtabRowid, completionRowid, dbdataRowid, dbpageRowid, expertRowid, fsdirRowid, fts3RowidMethod, fts3auxRowidMethod, fts3tokRowidMethod, jsonEachRowid, pragmaVtabRowid, rtreeRowid, seriesRowid, statRowid, stmtRowid

@transform_return_xRowid_arrow@
expression E;
identifier FP_NAME = xRowid;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_0_enum], sizeof(E->xRowid_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_bytecodevtabRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+     return bytecodevtabRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_completionRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+     return completionRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_dbdataRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+     return dbdataRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_dbpageRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+     return dbpageRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_expertRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+     return expertRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_fsdirRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+     return fsdirRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_fts3RowidMethod_enum], sizeof(E->xRowid_signature)) == 0) {
+     return fts3RowidMethod(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_fts3auxRowidMethod_enum], sizeof(E->xRowid_signature)) == 0) {
+     return fts3auxRowidMethod(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_fts3tokRowidMethod_enum], sizeof(E->xRowid_signature)) == 0) {
+     return fts3tokRowidMethod(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_jsonEachRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+     return jsonEachRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_pragmaVtabRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+     return pragmaVtabRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_rtreeRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+     return rtreeRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_seriesRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+     return seriesRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_statRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+     return statRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_stmtRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+     return stmtRowid(args);
+ }


// FP: xSFunc
// Candidates: 0, attachFunc, base64, base85, detachFunc, dummyUDF, editFunc, fts3AllocateMSI, fts3ExprGlobalHitsCb, fts3ExprLoadDoclistsCb, fts3ExprLocalHitsCb, fts3ExprPhraseCountCb, fts3ExprRestartIfCb, fts3ExprTermOffsetInit, fts3ExprTest, fts3ExprTestRebalance, fts3MatchinfoLcsCb, fts3SnippetFindPositions, fts3TokenizerFunc, geomCallback, idxRemFunc, idxSampleFunc, intTestFunc, intckParseCreateIndexFunc, is_base85, likeFunc, lsModeFunc, rbuFossilDeltaFunc, rbuIndexCntFunc, rbuTargetNameFunc, rbuTmpInsertFunc, re_bytecode_func, re_sql_func, readfileFunc, rtreecheck, rtreedepth, rtreenode, sha1Func, sha1QueryFunc, sha3Func, sha3QueryFunc, shellAddSchemaName, shellDtostr, shellFkeyCollateClause, shellModuleSchema, shellPutsFunc, shellStrtod, shellUSleepFunc, sqlarCompressFunc, sqlarUncompressFunc, sqlite3InvalidFunction, statGet, statInit, statPush, stmtrandFunc, testFunc, writefileFunc

@transform_return_xSFunc_arrow@
expression E;
identifier FP_NAME = xSFunc;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_0_enum], sizeof(E->xSFunc_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_attachFunc_enum], sizeof(E->xSFunc_signature)) == 0) {
+     return attachFunc(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_base64_enum], sizeof(E->xSFunc_signature)) == 0) {
+     return base64(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_base85_enum], sizeof(E->xSFunc_signature)) == 0) {
+     return base85(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_detachFunc_enum], sizeof(E->xSFunc_signature)) == 0) {
+     return detachFunc(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_dummyUDF_enum], sizeof(E->xSFunc_signature)) == 0) {
+     return dummyUDF(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_editFunc_enum], sizeof(E->xSFunc_signature)) == 0) {
+     return editFunc(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_fts3AllocateMSI_enum], sizeof(E->xSFunc_signature)) == 0) {
+     return fts3AllocateMSI(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_fts3ExprGlobalHitsCb_enum], sizeof(E->xSFunc_signature)) == 0) {
+     return fts3ExprGlobalHitsCb(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_fts3ExprLoadDoclistsCb_enum], sizeof(E->xSFunc_signature)) == 0) {
+     return fts3ExprLoadDoclistsCb(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_fts3ExprLocalHitsCb_enum], sizeof(E->xSFunc_signature)) == 0) {
+     return fts3ExprLocalHitsCb(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_fts3ExprPhraseCountCb_enum], sizeof(E->xSFunc_signature)) == 0) {
+     return fts3ExprPhraseCountCb(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_fts3ExprRestartIfCb_enum], sizeof(E->xSFunc_signature)) == 0) {
+     return fts3ExprRestartIfCb(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_fts3ExprTermOffsetInit_enum], sizeof(E->xSFunc_signature)) == 0) {
+     return fts3ExprTermOffsetInit(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_fts3ExprTest_enum], sizeof(E->xSFunc_signature)) == 0) {
+     return fts3ExprTest(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_fts3ExprTestRebalance_enum], sizeof(E->xSFunc_signature)) == 0) {
+     return fts3ExprTestRebalance(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_fts3MatchinfoLcsCb_enum], sizeof(E->xSFunc_signature)) == 0) {
+     return fts3MatchinfoLcsCb(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_fts3SnippetFindPositions_enum], sizeof(E->xSFunc_signature)) == 0) {
+     return fts3SnippetFindPositions(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_fts3TokenizerFunc_enum], sizeof(E->xSFunc_signature)) == 0) {
+     return fts3TokenizerFunc(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_geomCallback_enum], sizeof(E->xSFunc_signature)) == 0) {
+     return geomCallback(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_idxRemFunc_enum], sizeof(E->xSFunc_signature)) == 0) {
+     return idxRemFunc(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_idxSampleFunc_enum], sizeof(E->xSFunc_signature)) == 0) {
+     return idxSampleFunc(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_intTestFunc_enum], sizeof(E->xSFunc_signature)) == 0) {
+     return intTestFunc(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_intckParseCreateIndexFunc_enum], sizeof(E->xSFunc_signature)) == 0) {
+     return intckParseCreateIndexFunc(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_is_base85_enum], sizeof(E->xSFunc_signature)) == 0) {
+     return is_base85(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_likeFunc_enum], sizeof(E->xSFunc_signature)) == 0) {
+     return likeFunc(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_lsModeFunc_enum], sizeof(E->xSFunc_signature)) == 0) {
+     return lsModeFunc(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_rbuFossilDeltaFunc_enum], sizeof(E->xSFunc_signature)) == 0) {
+     return rbuFossilDeltaFunc(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_rbuIndexCntFunc_enum], sizeof(E->xSFunc_signature)) == 0) {
+     return rbuIndexCntFunc(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_rbuTargetNameFunc_enum], sizeof(E->xSFunc_signature)) == 0) {
+     return rbuTargetNameFunc(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_rbuTmpInsertFunc_enum], sizeof(E->xSFunc_signature)) == 0) {
+     return rbuTmpInsertFunc(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_re_bytecode_func_enum], sizeof(E->xSFunc_signature)) == 0) {
+     return re_bytecode_func(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_re_sql_func_enum], sizeof(E->xSFunc_signature)) == 0) {
+     return re_sql_func(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_readfileFunc_enum], sizeof(E->xSFunc_signature)) == 0) {
+     return readfileFunc(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_rtreecheck_enum], sizeof(E->xSFunc_signature)) == 0) {
+     return rtreecheck(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_rtreedepth_enum], sizeof(E->xSFunc_signature)) == 0) {
+     return rtreedepth(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_rtreenode_enum], sizeof(E->xSFunc_signature)) == 0) {
+     return rtreenode(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_sha1Func_enum], sizeof(E->xSFunc_signature)) == 0) {
+     return sha1Func(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_sha1QueryFunc_enum], sizeof(E->xSFunc_signature)) == 0) {
+     return sha1QueryFunc(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_sha3Func_enum], sizeof(E->xSFunc_signature)) == 0) {
+     return sha3Func(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_sha3QueryFunc_enum], sizeof(E->xSFunc_signature)) == 0) {
+     return sha3QueryFunc(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_shellAddSchemaName_enum], sizeof(E->xSFunc_signature)) == 0) {
+     return shellAddSchemaName(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_shellDtostr_enum], sizeof(E->xSFunc_signature)) == 0) {
+     return shellDtostr(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_shellFkeyCollateClause_enum], sizeof(E->xSFunc_signature)) == 0) {
+     return shellFkeyCollateClause(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_shellModuleSchema_enum], sizeof(E->xSFunc_signature)) == 0) {
+     return shellModuleSchema(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_shellPutsFunc_enum], sizeof(E->xSFunc_signature)) == 0) {
+     return shellPutsFunc(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_shellStrtod_enum], sizeof(E->xSFunc_signature)) == 0) {
+     return shellStrtod(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_shellUSleepFunc_enum], sizeof(E->xSFunc_signature)) == 0) {
+     return shellUSleepFunc(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_sqlarCompressFunc_enum], sizeof(E->xSFunc_signature)) == 0) {
+     return sqlarCompressFunc(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_sqlarUncompressFunc_enum], sizeof(E->xSFunc_signature)) == 0) {
+     return sqlarUncompressFunc(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_sqlite3InvalidFunction_enum], sizeof(E->xSFunc_signature)) == 0) {
+     return sqlite3InvalidFunction(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_statGet_enum], sizeof(E->xSFunc_signature)) == 0) {
+     return statGet(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_statInit_enum], sizeof(E->xSFunc_signature)) == 0) {
+     return statInit(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_statPush_enum], sizeof(E->xSFunc_signature)) == 0) {
+     return statPush(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_stmtrandFunc_enum], sizeof(E->xSFunc_signature)) == 0) {
+     return stmtrandFunc(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_testFunc_enum], sizeof(E->xSFunc_signature)) == 0) {
+     return testFunc(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_writefileFunc_enum], sizeof(E->xSFunc_signature)) == 0) {
+     return writefileFunc(args);
+ }


// FP: xSavepoint
// Candidates: 0, fts3SavepointMethod, rtreeSavepoint

@transform_return_xSavepoint_arrow@
expression E;
identifier FP_NAME = xSavepoint;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xSavepoint_signature, xSavepoint_signatures[xSavepoint_0_enum], sizeof(E->xSavepoint_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xSavepoint_signature, xSavepoint_signatures[xSavepoint_fts3SavepointMethod_enum], sizeof(E->xSavepoint_signature)) == 0) {
+     return fts3SavepointMethod(args);
+ }
+ else if (memcmp(E->xSavepoint_signature, xSavepoint_signatures[xSavepoint_rtreeSavepoint_enum], sizeof(E->xSavepoint_signature)) == 0) {
+     return rtreeSavepoint(args);
+ }


// FP: xSectorSize
// Candidates: 0, apndSectorSize, recoverVfsSectorSize, vfstraceSectorSize

@transform_return_xSectorSize_arrow@
expression E;
identifier FP_NAME = xSectorSize;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xSectorSize_signature, xSectorSize_signatures[xSectorSize_0_enum], sizeof(E->xSectorSize_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xSectorSize_signature, xSectorSize_signatures[xSectorSize_apndSectorSize_enum], sizeof(E->xSectorSize_signature)) == 0) {
+     return apndSectorSize(args);
+ }
+ else if (memcmp(E->xSectorSize_signature, xSectorSize_signatures[xSectorSize_recoverVfsSectorSize_enum], sizeof(E->xSectorSize_signature)) == 0) {
+     return recoverVfsSectorSize(args);
+ }
+ else if (memcmp(E->xSectorSize_signature, xSectorSize_signatures[xSectorSize_vfstraceSectorSize_enum], sizeof(E->xSectorSize_signature)) == 0) {
+     return vfstraceSectorSize(args);
+ }


// FP: xSelectCallback
// Candidates: 0, convertCompoundSelectToSubquery, exprSelectWalkTableConstant, fixSelectCb, gatherSelectWindowsSelectCallback, renameColumnSelectCb, renameTableSelectCb, renameUnmapSelectCb, resolveSelectStep, selectCheckOnClausesSelect, selectExpander, selectRefEnter, selectWindowRewriteSelectCb, sqlite3ReturningSubqueryCorrelated, sqlite3SelectWalkFail, sqlite3SelectWalkNoop, sqlite3WalkerDepthIncrease

@transform_return_xSelectCallback_arrow@
expression E;
identifier FP_NAME = xSelectCallback;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_0_enum], sizeof(E->xSelectCallback_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_convertCompoundSelectToSubquery_enum], sizeof(E->xSelectCallback_signature)) == 0) {
+     return convertCompoundSelectToSubquery(args);
+ }
+ else if (memcmp(E->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_exprSelectWalkTableConstant_enum], sizeof(E->xSelectCallback_signature)) == 0) {
+     return exprSelectWalkTableConstant(args);
+ }
+ else if (memcmp(E->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_fixSelectCb_enum], sizeof(E->xSelectCallback_signature)) == 0) {
+     return fixSelectCb(args);
+ }
+ else if (memcmp(E->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_gatherSelectWindowsSelectCallback_enum], sizeof(E->xSelectCallback_signature)) == 0) {
+     return gatherSelectWindowsSelectCallback(args);
+ }
+ else if (memcmp(E->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_renameColumnSelectCb_enum], sizeof(E->xSelectCallback_signature)) == 0) {
+     return renameColumnSelectCb(args);
+ }
+ else if (memcmp(E->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_renameTableSelectCb_enum], sizeof(E->xSelectCallback_signature)) == 0) {
+     return renameTableSelectCb(args);
+ }
+ else if (memcmp(E->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_renameUnmapSelectCb_enum], sizeof(E->xSelectCallback_signature)) == 0) {
+     return renameUnmapSelectCb(args);
+ }
+ else if (memcmp(E->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_resolveSelectStep_enum], sizeof(E->xSelectCallback_signature)) == 0) {
+     return resolveSelectStep(args);
+ }
+ else if (memcmp(E->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_selectCheckOnClausesSelect_enum], sizeof(E->xSelectCallback_signature)) == 0) {
+     return selectCheckOnClausesSelect(args);
+ }
+ else if (memcmp(E->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_selectExpander_enum], sizeof(E->xSelectCallback_signature)) == 0) {
+     return selectExpander(args);
+ }
+ else if (memcmp(E->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_selectRefEnter_enum], sizeof(E->xSelectCallback_signature)) == 0) {
+     return selectRefEnter(args);
+ }
+ else if (memcmp(E->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_selectWindowRewriteSelectCb_enum], sizeof(E->xSelectCallback_signature)) == 0) {
+     return selectWindowRewriteSelectCb(args);
+ }
+ else if (memcmp(E->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_sqlite3ReturningSubqueryCorrelated_enum], sizeof(E->xSelectCallback_signature)) == 0) {
+     return sqlite3ReturningSubqueryCorrelated(args);
+ }
+ else if (memcmp(E->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_sqlite3SelectWalkFail_enum], sizeof(E->xSelectCallback_signature)) == 0) {
+     return sqlite3SelectWalkFail(args);
+ }
+ else if (memcmp(E->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_sqlite3SelectWalkNoop_enum], sizeof(E->xSelectCallback_signature)) == 0) {
+     return sqlite3SelectWalkNoop(args);
+ }
+ else if (memcmp(E->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_sqlite3WalkerDepthIncrease_enum], sizeof(E->xSelectCallback_signature)) == 0) {
+     return sqlite3WalkerDepthIncrease(args);
+ }


// FP: xSelectCallback2
// Candidates: 0, selectAddSubqueryTypeInfo, selectRefLeave, sqlite3SelectPopWith, sqlite3WalkWinDefnDummyCallback, sqlite3WalkerDepthDecrease

@transform_return_xSelectCallback2_arrow@
expression E;
identifier FP_NAME = xSelectCallback2;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_0_enum], sizeof(E->xSelectCallback2_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_selectAddSubqueryTypeInfo_enum], sizeof(E->xSelectCallback2_signature)) == 0) {
+     return selectAddSubqueryTypeInfo(args);
+ }
+ else if (memcmp(E->xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_selectRefLeave_enum], sizeof(E->xSelectCallback2_signature)) == 0) {
+     return selectRefLeave(args);
+ }
+ else if (memcmp(E->xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_sqlite3SelectPopWith_enum], sizeof(E->xSelectCallback2_signature)) == 0) {
+     return sqlite3SelectPopWith(args);
+ }
+ else if (memcmp(E->xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_sqlite3WalkWinDefnDummyCallback_enum], sizeof(E->xSelectCallback2_signature)) == 0) {
+     return sqlite3WalkWinDefnDummyCallback(args);
+ }
+ else if (memcmp(E->xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_sqlite3WalkerDepthDecrease_enum], sizeof(E->xSelectCallback2_signature)) == 0) {
+     return sqlite3WalkerDepthDecrease(args);
+ }


// FP: xSetSystemCall
// Candidates: 0, apndSetSystemCall, rbuVfsSleep, unixSetSystemCall

@transform_return_xSetSystemCall_arrow@
expression E;
identifier FP_NAME = xSetSystemCall;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xSetSystemCall_signature, xSetSystemCall_signatures[xSetSystemCall_0_enum], sizeof(E->xSetSystemCall_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xSetSystemCall_signature, xSetSystemCall_signatures[xSetSystemCall_apndSetSystemCall_enum], sizeof(E->xSetSystemCall_signature)) == 0) {
+     return apndSetSystemCall(args);
+ }
+ else if (memcmp(E->xSetSystemCall_signature, xSetSystemCall_signatures[xSetSystemCall_rbuVfsSleep_enum], sizeof(E->xSetSystemCall_signature)) == 0) {
+     return rbuVfsSleep(args);
+ }
+ else if (memcmp(E->xSetSystemCall_signature, xSetSystemCall_signatures[xSetSystemCall_unixSetSystemCall_enum], sizeof(E->xSetSystemCall_signature)) == 0) {
+     return unixSetSystemCall(args);
+ }


// FP: xShadowName
// Candidates: 0, fts3ShadowName, rtreeShadowName

@transform_return_xShadowName_arrow@
expression E;
identifier FP_NAME = xShadowName;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xShadowName_signature, xShadowName_signatures[xShadowName_0_enum], sizeof(E->xShadowName_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xShadowName_signature, xShadowName_signatures[xShadowName_fts3ShadowName_enum], sizeof(E->xShadowName_signature)) == 0) {
+     return fts3ShadowName(args);
+ }
+ else if (memcmp(E->xShadowName_signature, xShadowName_signatures[xShadowName_rtreeShadowName_enum], sizeof(E->xShadowName_signature)) == 0) {
+     return rtreeShadowName(args);
+ }


// FP: xShmBarrier
// Candidates: 0, apndShmBarrier, recoverVfsShmBarrier

@transform_return_xShmBarrier_arrow@
expression E;
identifier FP_NAME = xShmBarrier;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xShmBarrier_signature, xShmBarrier_signatures[xShmBarrier_0_enum], sizeof(E->xShmBarrier_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xShmBarrier_signature, xShmBarrier_signatures[xShmBarrier_apndShmBarrier_enum], sizeof(E->xShmBarrier_signature)) == 0) {
+     return apndShmBarrier(args);
+ }
+ else if (memcmp(E->xShmBarrier_signature, xShmBarrier_signatures[xShmBarrier_recoverVfsShmBarrier_enum], sizeof(E->xShmBarrier_signature)) == 0) {
+     return recoverVfsShmBarrier(args);
+ }


// FP: xShmLock
// Candidates: 0, apndShmLock, recoverVfsShmLock

@transform_return_xShmLock_arrow@
expression E;
identifier FP_NAME = xShmLock;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xShmLock_signature, xShmLock_signatures[xShmLock_0_enum], sizeof(E->xShmLock_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xShmLock_signature, xShmLock_signatures[xShmLock_apndShmLock_enum], sizeof(E->xShmLock_signature)) == 0) {
+     return apndShmLock(args);
+ }
+ else if (memcmp(E->xShmLock_signature, xShmLock_signatures[xShmLock_recoverVfsShmLock_enum], sizeof(E->xShmLock_signature)) == 0) {
+     return recoverVfsShmLock(args);
+ }


// FP: xShmMap
// Candidates: 0, apndShmMap, recoverVfsShmMap

@transform_return_xShmMap_arrow@
expression E;
identifier FP_NAME = xShmMap;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xShmMap_signature, xShmMap_signatures[xShmMap_0_enum], sizeof(E->xShmMap_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xShmMap_signature, xShmMap_signatures[xShmMap_apndShmMap_enum], sizeof(E->xShmMap_signature)) == 0) {
+     return apndShmMap(args);
+ }
+ else if (memcmp(E->xShmMap_signature, xShmMap_signatures[xShmMap_recoverVfsShmMap_enum], sizeof(E->xShmMap_signature)) == 0) {
+     return recoverVfsShmMap(args);
+ }


// FP: xShmUnmap
// Candidates: 0, apndShmUnmap, recoverVfsShmUnmap

@transform_return_xShmUnmap_arrow@
expression E;
identifier FP_NAME = xShmUnmap;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xShmUnmap_signature, xShmUnmap_signatures[xShmUnmap_0_enum], sizeof(E->xShmUnmap_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xShmUnmap_signature, xShmUnmap_signatures[xShmUnmap_apndShmUnmap_enum], sizeof(E->xShmUnmap_signature)) == 0) {
+     return apndShmUnmap(args);
+ }
+ else if (memcmp(E->xShmUnmap_signature, xShmUnmap_signatures[xShmUnmap_recoverVfsShmUnmap_enum], sizeof(E->xShmUnmap_signature)) == 0) {
+     return recoverVfsShmUnmap(args);
+ }


// FP: xShrink
// Candidates: pcache1Shrink, pcachetraceShrink

@transform_return_xShrink_arrow@
expression E;
identifier FP_NAME = xShrink;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xShrink_signature, xShrink_signatures[xShrink_pcache1Shrink_enum], sizeof(E->xShrink_signature)) == 0) {
+     return pcache1Shrink(args);
+ }
+ else if (memcmp(E->xShrink_signature, xShrink_signatures[xShrink_pcachetraceShrink_enum], sizeof(E->xShrink_signature)) == 0) {
+     return pcachetraceShrink(args);
+ }


// FP: xShutdown
// Candidates: memtraceShutdown, pcache1Shutdown, pcachetraceShutdown, sqlite3MemShutdown

@transform_return_xShutdown_arrow@
expression E;
identifier FP_NAME = xShutdown;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xShutdown_signature, xShutdown_signatures[xShutdown_memtraceShutdown_enum], sizeof(E->xShutdown_signature)) == 0) {
+     return memtraceShutdown(args);
+ }
+ else if (memcmp(E->xShutdown_signature, xShutdown_signatures[xShutdown_pcache1Shutdown_enum], sizeof(E->xShutdown_signature)) == 0) {
+     return pcache1Shutdown(args);
+ }
+ else if (memcmp(E->xShutdown_signature, xShutdown_signatures[xShutdown_pcachetraceShutdown_enum], sizeof(E->xShutdown_signature)) == 0) {
+     return pcachetraceShutdown(args);
+ }
+ else if (memcmp(E->xShutdown_signature, xShutdown_signatures[xShutdown_sqlite3MemShutdown_enum], sizeof(E->xShutdown_signature)) == 0) {
+     return sqlite3MemShutdown(args);
+ }


// FP: xSize
// Candidates: memtraceSize, sqlite3MemSize

@transform_return_xSize_arrow@
expression E;
identifier FP_NAME = xSize;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xSize_signature, xSize_signatures[xSize_memtraceSize_enum], sizeof(E->xSize_signature)) == 0) {
+     return memtraceSize(args);
+ }
+ else if (memcmp(E->xSize_signature, xSize_signatures[xSize_sqlite3MemSize_enum], sizeof(E->xSize_signature)) == 0) {
+     return sqlite3MemSize(args);
+ }


// FP: xSleep
// Candidates: 0, apndSleep, memdbSleep, vfstraceSleep, unixSleep

@transform_return_xSleep_arrow@
expression E;
identifier FP_NAME = xSleep;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xSleep_signature, xSleep_signatures[xSleep_0_enum], sizeof(E->xSleep_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xSleep_signature, xSleep_signatures[xSleep_apndSleep_enum], sizeof(E->xSleep_signature)) == 0) {
+     return apndSleep(args);
+ }
+ else if (memcmp(E->xSleep_signature, xSleep_signatures[xSleep_memdbSleep_enum], sizeof(E->xSleep_signature)) == 0) {
+     return memdbSleep(args);
+ }
+ else if (memcmp(E->xSleep_signature, xSleep_signatures[xSleep_vfstraceSleep_enum], sizeof(E->xSleep_signature)) == 0) {
+     return vfstraceSleep(args);
+ }
+ else if (memcmp(E->xSleep_signature, xSleep_signatures[xSleep_unixSleep_enum], sizeof(E->xSleep_signature)) == 0) {
+     return unixSleep(args);
+ }


// FP: xSql
// Candidates: 0, recoverSqlCb

@transform_return_xSql_arrow@
expression E;
identifier FP_NAME = xSql;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xSql_signature, xSql_signatures[xSql_0_enum], sizeof(E->xSql_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xSql_signature, xSql_signatures[xSql_recoverSqlCb_enum], sizeof(E->xSql_signature)) == 0) {
+     return recoverSqlCb(args);
+ }


// FP: xSync
// Candidates: 0, apndSync, dbpageSync, fts3SyncMethod, memdbSync, memjrnlSync, recoverVfsSync, rtreeEndTransaction, vfstraceSync

@transform_return_xSync_arrow@
expression E;
identifier FP_NAME = xSync;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xSync_signature, xSync_signatures[xSync_0_enum], sizeof(E->xSync_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xSync_signature, xSync_signatures[xSync_apndSync_enum], sizeof(E->xSync_signature)) == 0) {
+     return apndSync(args);
+ }
+ else if (memcmp(E->xSync_signature, xSync_signatures[xSync_dbpageSync_enum], sizeof(E->xSync_signature)) == 0) {
+     return dbpageSync(args);
+ }
+ else if (memcmp(E->xSync_signature, xSync_signatures[xSync_fts3SyncMethod_enum], sizeof(E->xSync_signature)) == 0) {
+     return fts3SyncMethod(args);
+ }
+ else if (memcmp(E->xSync_signature, xSync_signatures[xSync_memdbSync_enum], sizeof(E->xSync_signature)) == 0) {
+     return memdbSync(args);
+ }
+ else if (memcmp(E->xSync_signature, xSync_signatures[xSync_memjrnlSync_enum], sizeof(E->xSync_signature)) == 0) {
+     return memjrnlSync(args);
+ }
+ else if (memcmp(E->xSync_signature, xSync_signatures[xSync_recoverVfsSync_enum], sizeof(E->xSync_signature)) == 0) {
+     return recoverVfsSync(args);
+ }
+ else if (memcmp(E->xSync_signature, xSync_signatures[xSync_rtreeEndTransaction_enum], sizeof(E->xSync_signature)) == 0) {
+     return rtreeEndTransaction(args);
+ }
+ else if (memcmp(E->xSync_signature, xSync_signatures[xSync_vfstraceSync_enum], sizeof(E->xSync_signature)) == 0) {
+     return vfstraceSync(args);
+ }


// FP: xTableFilter
// Candidates: 0, session_filter

@transform_return_xTableFilter_arrow@
expression E;
identifier FP_NAME = xTableFilter;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xTableFilter_signature, xTableFilter_signatures[xTableFilter_0_enum], sizeof(E->xTableFilter_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xTableFilter_signature, xTableFilter_signatures[xTableFilter_session_filter_enum], sizeof(E->xTableFilter_signature)) == 0) {
+     return session_filter(args);
+ }


// FP: xTask
// Candidates: 0, vdbeSorterFlushThread, vdbeIncrPopulateThread, vdbePmaReaderBgIncrInit

@transform_return_xTask_arrow@
expression E;
identifier FP_NAME = xTask;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xTask_signature, xTask_signatures[xTask_0_enum], sizeof(E->xTask_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xTask_signature, xTask_signatures[xTask_vdbeSorterFlushThread_enum], sizeof(E->xTask_signature)) == 0) {
+     return vdbeSorterFlushThread(args);
+ }
+ else if (memcmp(E->xTask_signature, xTask_signatures[xTask_vdbeIncrPopulateThread_enum], sizeof(E->xTask_signature)) == 0) {
+     return vdbeIncrPopulateThread(args);
+ }
+ else if (memcmp(E->xTask_signature, xTask_signatures[xTask_vdbePmaReaderBgIncrInit_enum], sizeof(E->xTask_signature)) == 0) {
+     return vdbePmaReaderBgIncrInit(args);
+ }


// FP: xTruncate
// Candidates: apndTruncate, memdbTruncate, memjrnlTruncate, pcache1Truncate, pcachetraceTruncate, recoverVfsTruncate, vfstraceTruncate

@transform_return_xTruncate_arrow@
expression E;
identifier FP_NAME = xTruncate;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xTruncate_signature, xTruncate_signatures[xTruncate_apndTruncate_enum], sizeof(E->xTruncate_signature)) == 0) {
+     return apndTruncate(args);
+ }
+ else if (memcmp(E->xTruncate_signature, xTruncate_signatures[xTruncate_memdbTruncate_enum], sizeof(E->xTruncate_signature)) == 0) {
+     return memdbTruncate(args);
+ }
+ else if (memcmp(E->xTruncate_signature, xTruncate_signatures[xTruncate_memjrnlTruncate_enum], sizeof(E->xTruncate_signature)) == 0) {
+     return memjrnlTruncate(args);
+ }
+ else if (memcmp(E->xTruncate_signature, xTruncate_signatures[xTruncate_pcache1Truncate_enum], sizeof(E->xTruncate_signature)) == 0) {
+     return pcache1Truncate(args);
+ }
+ else if (memcmp(E->xTruncate_signature, xTruncate_signatures[xTruncate_pcachetraceTruncate_enum], sizeof(E->xTruncate_signature)) == 0) {
+     return pcachetraceTruncate(args);
+ }
+ else if (memcmp(E->xTruncate_signature, xTruncate_signatures[xTruncate_recoverVfsTruncate_enum], sizeof(E->xTruncate_signature)) == 0) {
+     return recoverVfsTruncate(args);
+ }
+ else if (memcmp(E->xTruncate_signature, xTruncate_signatures[xTruncate_vfstraceTruncate_enum], sizeof(E->xTruncate_signature)) == 0) {
+     return vfstraceTruncate(args);
+ }


// FP: xUnfetch
// Candidates: 0, apndUnfetch, memdbUnfetch, recoverVfsUnfetch

@transform_return_xUnfetch_arrow@
expression E;
identifier FP_NAME = xUnfetch;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xUnfetch_signature, xUnfetch_signatures[xUnfetch_0_enum], sizeof(E->xUnfetch_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xUnfetch_signature, xUnfetch_signatures[xUnfetch_apndUnfetch_enum], sizeof(E->xUnfetch_signature)) == 0) {
+     return apndUnfetch(args);
+ }
+ else if (memcmp(E->xUnfetch_signature, xUnfetch_signatures[xUnfetch_memdbUnfetch_enum], sizeof(E->xUnfetch_signature)) == 0) {
+     return memdbUnfetch(args);
+ }
+ else if (memcmp(E->xUnfetch_signature, xUnfetch_signatures[xUnfetch_recoverVfsUnfetch_enum], sizeof(E->xUnfetch_signature)) == 0) {
+     return recoverVfsUnfetch(args);
+ }


// FP: xUnlock
// Candidates: 0, apndUnlock, memdbUnlock, recoverVfsUnlock, vfstraceUnlock

@transform_return_xUnlock_arrow@
expression E;
identifier FP_NAME = xUnlock;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xUnlock_signature, xUnlock_signatures[xUnlock_0_enum], sizeof(E->xUnlock_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xUnlock_signature, xUnlock_signatures[xUnlock_apndUnlock_enum], sizeof(E->xUnlock_signature)) == 0) {
+     return apndUnlock(args);
+ }
+ else if (memcmp(E->xUnlock_signature, xUnlock_signatures[xUnlock_memdbUnlock_enum], sizeof(E->xUnlock_signature)) == 0) {
+     return memdbUnlock(args);
+ }
+ else if (memcmp(E->xUnlock_signature, xUnlock_signatures[xUnlock_recoverVfsUnlock_enum], sizeof(E->xUnlock_signature)) == 0) {
+     return recoverVfsUnlock(args);
+ }
+ else if (memcmp(E->xUnlock_signature, xUnlock_signatures[xUnlock_vfstraceUnlock_enum], sizeof(E->xUnlock_signature)) == 0) {
+     return vfstraceUnlock(args);
+ }


// FP: xUnlockNotify
// Candidates: 0, xUnlockNotify

@transform_return_xUnlockNotify_arrow@
expression E;
identifier FP_NAME = xUnlockNotify;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xUnlockNotify_signature, xUnlockNotify_signatures[xUnlockNotify_0_enum], sizeof(E->xUnlockNotify_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xUnlockNotify_signature, xUnlockNotify_signatures[xUnlockNotify_xUnlockNotify_enum], sizeof(E->xUnlockNotify_signature)) == 0) {
+     return xUnlockNotify(args);
+ }


// FP: xUnpin
// Candidates: pcache1Unpin, pcachetraceUnpin

@transform_return_xUnpin_arrow@
expression E;
identifier FP_NAME = xUnpin;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xUnpin_signature, xUnpin_signatures[xUnpin_pcache1Unpin_enum], sizeof(E->xUnpin_signature)) == 0) {
+     return pcache1Unpin(args);
+ }
+ else if (memcmp(E->xUnpin_signature, xUnpin_signatures[xUnpin_pcachetraceUnpin_enum], sizeof(E->xUnpin_signature)) == 0) {
+     return pcachetraceUnpin(args);
+ }


// FP: xUpdate
// Candidates: 0, dbpageUpdate, expertUpdate, fts3UpdateMethod, geopolyUpdate, rtreeUpdate, zipfileUpdate

@transform_return_xUpdate_arrow@
expression E;
identifier FP_NAME = xUpdate;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xUpdate_signature, xUpdate_signatures[xUpdate_0_enum], sizeof(E->xUpdate_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xUpdate_signature, xUpdate_signatures[xUpdate_dbpageUpdate_enum], sizeof(E->xUpdate_signature)) == 0) {
+     return dbpageUpdate(args);
+ }
+ else if (memcmp(E->xUpdate_signature, xUpdate_signatures[xUpdate_expertUpdate_enum], sizeof(E->xUpdate_signature)) == 0) {
+     return expertUpdate(args);
+ }
+ else if (memcmp(E->xUpdate_signature, xUpdate_signatures[xUpdate_fts3UpdateMethod_enum], sizeof(E->xUpdate_signature)) == 0) {
+     return fts3UpdateMethod(args);
+ }
+ else if (memcmp(E->xUpdate_signature, xUpdate_signatures[xUpdate_geopolyUpdate_enum], sizeof(E->xUpdate_signature)) == 0) {
+     return geopolyUpdate(args);
+ }
+ else if (memcmp(E->xUpdate_signature, xUpdate_signatures[xUpdate_rtreeUpdate_enum], sizeof(E->xUpdate_signature)) == 0) {
+     return rtreeUpdate(args);
+ }
+ else if (memcmp(E->xUpdate_signature, xUpdate_signatures[xUpdate_zipfileUpdate_enum], sizeof(E->xUpdate_signature)) == 0) {
+     return zipfileUpdate(args);
+ }


// FP: xUpdateCallback
// Candidates: 0, sql_trace_callback, sqlite3WalDefaultHook

@transform_return_xUpdateCallback_arrow@
expression E;
identifier FP_NAME = xUpdateCallback;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xUpdateCallback_signature, xUpdateCallback_signatures[xUpdateCallback_0_enum], sizeof(E->xUpdateCallback_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xUpdateCallback_signature, xUpdateCallback_signatures[xUpdateCallback_sql_trace_callback_enum], sizeof(E->xUpdateCallback_signature)) == 0) {
+     return sql_trace_callback(args);
+ }
+ else if (memcmp(E->xUpdateCallback_signature, xUpdateCallback_signatures[xUpdateCallback_sqlite3WalDefaultHook_enum], sizeof(E->xUpdateCallback_signature)) == 0) {
+     return sqlite3WalDefaultHook(args);
+ }


// FP: xV2
// Candidates: 0, sql_trace_callback

@transform_return_xV2_arrow@
expression E;
identifier FP_NAME = xV2;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xV2_signature, xV2_signatures[xV2_0_enum], sizeof(E->xV2_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xV2_signature, xV2_signatures[xV2_sql_trace_callback_enum], sizeof(E->xV2_signature)) == 0) {
+     return sql_trace_callback(args);
+ }


// FP: xValue
// Candidates: 0, decimalSumValue, percentValue, sqlite3changeset_new, sqlite3changeset_old

@transform_return_xValue_arrow@
expression E;
identifier FP_NAME = xValue;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xValue_signature, xValue_signatures[xValue_0_enum], sizeof(E->xValue_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xValue_signature, xValue_signatures[xValue_decimalSumValue_enum], sizeof(E->xValue_signature)) == 0) {
+     return decimalSumValue(args);
+ }
+ else if (memcmp(E->xValue_signature, xValue_signatures[xValue_percentValue_enum], sizeof(E->xValue_signature)) == 0) {
+     return percentValue(args);
+ }
+ else if (memcmp(E->xValue_signature, xValue_signatures[xValue_sqlite3changeset_new_enum], sizeof(E->xValue_signature)) == 0) {
+     return sqlite3changeset_new(args);
+ }
+ else if (memcmp(E->xValue_signature, xValue_signatures[xValue_sqlite3changeset_old_enum], sizeof(E->xValue_signature)) == 0) {
+     return sqlite3changeset_old(args);
+ }


// FP: xWrite
// Candidates: apndWrite, kvstorageWrite, memdbWrite, memjrnlWrite, recoverVfsWrite, vfstraceWrite

@transform_return_xWrite_arrow@
expression E;
identifier FP_NAME = xWrite;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ if (memcmp(E->xWrite_signature, xWrite_signatures[xWrite_apndWrite_enum], sizeof(E->xWrite_signature)) == 0) {
+     return apndWrite(args);
+ }
+ else if (memcmp(E->xWrite_signature, xWrite_signatures[xWrite_kvstorageWrite_enum], sizeof(E->xWrite_signature)) == 0) {
+     return kvstorageWrite(args);
+ }
+ else if (memcmp(E->xWrite_signature, xWrite_signatures[xWrite_memdbWrite_enum], sizeof(E->xWrite_signature)) == 0) {
+     return memdbWrite(args);
+ }
+ else if (memcmp(E->xWrite_signature, xWrite_signatures[xWrite_memjrnlWrite_enum], sizeof(E->xWrite_signature)) == 0) {
+     return memjrnlWrite(args);
+ }
+ else if (memcmp(E->xWrite_signature, xWrite_signatures[xWrite_recoverVfsWrite_enum], sizeof(E->xWrite_signature)) == 0) {
+     return recoverVfsWrite(args);
+ }
+ else if (memcmp(E->xWrite_signature, xWrite_signatures[xWrite_vfstraceWrite_enum], sizeof(E->xWrite_signature)) == 0) {
+     return vfstraceWrite(args);
+ }


// FP: xsnprintf
// Candidates: sqlite3_set_authorizer

@transform_return_xsnprintf_arrow@
expression E;
identifier FP_NAME = xsnprintf;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return sqlite3_set_authorizer(args);


// FP: xvsnprintf
// Candidates: 0

@transform_return_xvsnprintf_arrow@
expression E;
identifier FP_NAME = xvsnprintf;
expression list args;
@@
- return E->FP_NAME(args);
+ // return E->FP_NAME(args);
+ return 0(args);

// Total return arrow rules: 359

// ===== RETURN DOT TRANSFORMATION RULES =====
// Pattern: return E.fp_name(args);


// FP: aggregate_context

@transform_return_aggregate_context_dot@
expression E;
identifier FP_NAME = aggregate_context;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_aggregate_context(args);

// FP: auto_extension

@transform_return_auto_extension_dot@
expression E;
identifier FP_NAME = auto_extension;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_vtab_config(args);

// FP: backup_finish

@transform_return_backup_finish_dot@
expression E;
identifier FP_NAME = backup_finish;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_result_error_code(args);

// FP: backup_init

@transform_return_backup_init_dot@
expression E;
identifier FP_NAME = backup_init;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_test_control(args);

// FP: backup_pagecount

@transform_return_backup_pagecount_dot@
expression E;
identifier FP_NAME = backup_pagecount;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_randomness(args);

// FP: backup_remaining

@transform_return_backup_remaining_dot@
expression E;
identifier FP_NAME = backup_remaining;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_context_db_handle(args);

// FP: backup_step

@transform_return_backup_step_dot@
expression E;
identifier FP_NAME = backup_step;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_extended_result_codes(args);

// FP: bind_blob64

@transform_return_bind_blob64_dot@
expression E;
identifier FP_NAME = bind_blob64;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_vtab_on_conflict(args);

// FP: bind_int

@transform_return_bind_int_dot@
expression E;
identifier FP_NAME = bind_int;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_bind_double(args);

// FP: bind_int64

@transform_return_bind_int64_dot@
expression E;
identifier FP_NAME = bind_int64;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_bind_int(args);

// FP: bind_null

@transform_return_bind_null_dot@
expression E;
identifier FP_NAME = bind_null;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_bind_int64(args);

// FP: bind_parameter_count

@transform_return_bind_parameter_count_dot@
expression E;
identifier FP_NAME = bind_parameter_count;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_bind_null(args);

// FP: bind_parameter_index

@transform_return_bind_parameter_index_dot@
expression E;
identifier FP_NAME = bind_parameter_index;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_bind_parameter_count(args);

// FP: bind_parameter_name

@transform_return_bind_parameter_name_dot@
expression E;
identifier FP_NAME = bind_parameter_name;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_bind_parameter_index(args);

// FP: bind_text

@transform_return_bind_text_dot@
expression E;
identifier FP_NAME = bind_text;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_bind_parameter_name(args);

// FP: bind_text16

@transform_return_bind_text16_dot@
expression E;
identifier FP_NAME = bind_text16;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_bind_text(args);

// FP: bind_text64

@transform_return_bind_text64_dot@
expression E;
identifier FP_NAME = bind_text64;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_close_v2(args);

// FP: bind_value

@transform_return_bind_value_dot@
expression E;
identifier FP_NAME = bind_value;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_bind_text16(args);

// FP: bind_zeroblob

@transform_return_bind_zeroblob_dot@
expression E;
identifier FP_NAME = bind_zeroblob;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_prepare_v2(args);

// FP: bind_zeroblob64

@transform_return_bind_zeroblob64_dot@
expression E;
identifier FP_NAME = bind_zeroblob64;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_auto_extension(args);

// FP: blob_bytes

@transform_return_blob_bytes_dot@
expression E;
identifier FP_NAME = blob_bytes;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_prepare16_v2(args);

// FP: blob_close

@transform_return_blob_close_dot@
expression E;
identifier FP_NAME = blob_close;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_clear_bindings(args);

// FP: blob_open

@transform_return_blob_open_dot@
expression E;
identifier FP_NAME = blob_open;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_create_module_v2(args);

// FP: blob_read

@transform_return_blob_read_dot@
expression E;
identifier FP_NAME = blob_read;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_bind_zeroblob(args);

// FP: blob_reopen

@transform_return_blob_reopen_dot@
expression E;
identifier FP_NAME = blob_reopen;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_db_status(args);

// FP: blob_write

@transform_return_blob_write_dot@
expression E;
identifier FP_NAME = blob_write;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_blob_bytes(args);

// FP: busy_handler

@transform_return_busy_handler_dot@
expression E;
identifier FP_NAME = busy_handler;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_bind_value(args);

// FP: busy_timeout

@transform_return_busy_timeout_dot@
expression E;
identifier FP_NAME = busy_timeout;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_busy_handler(args);

// FP: cancel_auto_extension

@transform_return_cancel_auto_extension_dot@
expression E;
identifier FP_NAME = cancel_auto_extension;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_db_filename(args);

// FP: changes

@transform_return_changes_dot@
expression E;
identifier FP_NAME = changes;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_busy_timeout(args);

// FP: changes64

@transform_return_changes64_dot@
expression E;
identifier FP_NAME = changes64;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_str_value(args);

// FP: clear_bindings

@transform_return_clear_bindings_dot@
expression E;
identifier FP_NAME = clear_bindings;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_vmprintf(args);

// FP: close

@transform_return_close_dot@
expression E;
identifier FP_NAME = close;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_changes(args);

// FP: close_v2

@transform_return_close_v2_dot@
expression E;
identifier FP_NAME = close_v2;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_soft_heap_limit64(args);

// FP: collation_needed

@transform_return_collation_needed_dot@
expression E;
identifier FP_NAME = collation_needed;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_close(args);

// FP: collation_needed16

@transform_return_collation_needed16_dot@
expression E;
identifier FP_NAME = collation_needed16;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_collation_needed(args);

// FP: column_blob

@transform_return_column_blob_dot@
expression E;
identifier FP_NAME = column_blob;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_collation_needed16(args);

// FP: column_bytes

@transform_return_column_bytes_dot@
expression E;
identifier FP_NAME = column_bytes;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_column_blob(args);

// FP: column_bytes16

@transform_return_column_bytes16_dot@
expression E;
identifier FP_NAME = column_bytes16;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_column_bytes(args);

// FP: column_count

@transform_return_column_count_dot@
expression E;
identifier FP_NAME = column_count;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_column_bytes16(args);

// FP: column_database_name

@transform_return_column_database_name_dot@
expression E;
identifier FP_NAME = column_database_name;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_column_count(args);

// FP: column_database_name16

@transform_return_column_database_name16_dot@
expression E;
identifier FP_NAME = column_database_name16;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_column_database_name(args);

// FP: column_decltype

@transform_return_column_decltype_dot@
expression E;
identifier FP_NAME = column_decltype;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_column_database_name16(args);

// FP: column_decltype16

@transform_return_column_decltype16_dot@
expression E;
identifier FP_NAME = column_decltype16;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_column_decltype(args);

// FP: column_double

@transform_return_column_double_dot@
expression E;
identifier FP_NAME = column_double;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_column_decltype16(args);

// FP: column_int

@transform_return_column_int_dot@
expression E;
identifier FP_NAME = column_int;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_column_double(args);

// FP: column_int64

@transform_return_column_int64_dot@
expression E;
identifier FP_NAME = column_int64;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_column_int(args);

// FP: column_name

@transform_return_column_name_dot@
expression E;
identifier FP_NAME = column_name;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_column_int64(args);

// FP: column_name16

@transform_return_column_name16_dot@
expression E;
identifier FP_NAME = column_name16;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_column_name(args);

// FP: column_origin_name

@transform_return_column_origin_name_dot@
expression E;
identifier FP_NAME = column_origin_name;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_column_name16(args);

// FP: column_origin_name16

@transform_return_column_origin_name16_dot@
expression E;
identifier FP_NAME = column_origin_name16;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_column_origin_name(args);

// FP: column_table_name

@transform_return_column_table_name_dot@
expression E;
identifier FP_NAME = column_table_name;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_column_origin_name16(args);

// FP: column_table_name16

@transform_return_column_table_name16_dot@
expression E;
identifier FP_NAME = column_table_name16;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_column_table_name(args);

// FP: column_text

@transform_return_column_text_dot@
expression E;
identifier FP_NAME = column_text;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_column_table_name16(args);

// FP: column_text16

@transform_return_column_text16_dot@
expression E;
identifier FP_NAME = column_text16;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_column_text(args);

// FP: column_type

@transform_return_column_type_dot@
expression E;
identifier FP_NAME = column_type;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_column_text16(args);

// FP: column_value

@transform_return_column_value_dot@
expression E;
identifier FP_NAME = column_value;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_column_type(args);

// FP: commit_hook

@transform_return_commit_hook_dot@
expression E;
identifier FP_NAME = commit_hook;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_column_value(args);

// FP: compileoption_get

@transform_return_compileoption_get_dot@
expression E;
identifier FP_NAME = compileoption_get;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_limit(args);

// FP: compileoption_used

@transform_return_compileoption_used_dot@
expression E;
identifier FP_NAME = compileoption_used;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_next_stmt(args);

// FP: complete

@transform_return_complete_dot@
expression E;
identifier FP_NAME = complete;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_commit_hook(args);

// FP: complete16

@transform_return_complete16_dot@
expression E;
identifier FP_NAME = complete16;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_complete(args);

// FP: context_db_handle

@transform_return_context_db_handle_dot@
expression E;
identifier FP_NAME = context_db_handle;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_soft_heap_limit(args);

// FP: create_collation

@transform_return_create_collation_dot@
expression E;
identifier FP_NAME = create_collation;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_complete16(args);

// FP: create_collation16

@transform_return_create_collation16_dot@
expression E;
identifier FP_NAME = create_collation16;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_create_collation(args);

// FP: create_collation_v2

@transform_return_create_collation_v2_dot@
expression E;
identifier FP_NAME = create_collation_v2;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_blob_close(args);

// FP: create_filename

@transform_return_create_filename_dot@
expression E;
identifier FP_NAME = create_filename;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_str_appendchar(args);

// FP: create_function

@transform_return_create_function_dot@
expression E;
identifier FP_NAME = create_function;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_create_collation16(args);

// FP: create_function16

@transform_return_create_function16_dot@
expression E;
identifier FP_NAME = create_function16;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_create_function(args);

// FP: create_function_v2

@transform_return_create_function_v2_dot@
expression E;
identifier FP_NAME = create_function_v2;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_sql(args);

// FP: create_module

@transform_return_create_module_dot@
expression E;
identifier FP_NAME = create_module;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_create_function16(args);

// FP: create_module_v2

@transform_return_create_module_v2_dot@
expression E;
identifier FP_NAME = create_module_v2;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_overload_function(args);

// FP: create_window_function

@transform_return_create_window_function_dot@
expression E;
identifier FP_NAME = create_window_function;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_vtab_collation(args);

// FP: data_count

@transform_return_data_count_dot@
expression E;
identifier FP_NAME = data_count;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_create_module(args);

// FP: database_file_object

@transform_return_database_file_object_dot@
expression E;
identifier FP_NAME = database_file_object;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_str_errcode(args);

// FP: db_cacheflush

@transform_return_db_cacheflush_dot@
expression E;
identifier FP_NAME = db_cacheflush;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_malloc64(args);

// FP: db_config

@transform_return_db_config_dot@
expression E;
identifier FP_NAME = db_config;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_status(args);

// FP: db_filename

@transform_return_db_filename_dot@
expression E;
identifier FP_NAME = db_filename;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_sourceid(args);

// FP: db_handle

@transform_return_db_handle_dot@
expression E;
identifier FP_NAME = db_handle;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_data_count(args);

// FP: db_mutex

@transform_return_db_mutex_dot@
expression E;
identifier FP_NAME = db_mutex;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_backup_finish(args);

// FP: db_name

@transform_return_db_name_dot@
expression E;
identifier FP_NAME = db_name;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_filename_journal(args);

// FP: db_readonly

@transform_return_db_readonly_dot@
expression E;
identifier FP_NAME = db_readonly;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_stmt_status(args);

// FP: db_release_memory

@transform_return_db_release_memory_dot@
expression E;
identifier FP_NAME = db_release_memory;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_strnicmp(args);

// FP: db_status

@transform_return_db_status_dot@
expression E;
identifier FP_NAME = db_status;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_backup_init(args);

// FP: declare_vtab

@transform_return_declare_vtab_dot@
expression E;
identifier FP_NAME = declare_vtab;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_db_handle(args);

// FP: deserialize

@transform_return_deserialize_dot@
expression E;
identifier FP_NAME = deserialize;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_uri_key(args);

// FP: drop_modules

@transform_return_drop_modules_dot@
expression E;
identifier FP_NAME = drop_modules;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_str_new(args);

// FP: enable_shared_cache

@transform_return_enable_shared_cache_dot@
expression E;
identifier FP_NAME = enable_shared_cache;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_declare_vtab(args);

// FP: errcode

@transform_return_errcode_dot@
expression E;
identifier FP_NAME = errcode;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_enable_shared_cache(args);

// FP: errmsg

@transform_return_errmsg_dot@
expression E;
identifier FP_NAME = errmsg;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_errcode(args);

// FP: errmsg16

@transform_return_errmsg16_dot@
expression E;
identifier FP_NAME = errmsg16;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_errmsg(args);

// FP: exec

@transform_return_exec_dot@
expression E;
identifier FP_NAME = exec;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_errmsg16(args);

// FP: expanded_sql

@transform_return_expanded_sql_dot@
expression E;
identifier FP_NAME = expanded_sql;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_reset_auto_extension(args);

// FP: expired

@transform_return_expired_dot@
expression E;
identifier FP_NAME = expired;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.expired_signature, expired_signatures[expired_0_enum], sizeof(E.expired_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.expired_signature, expired_signatures[expired_sqlite3_exec_enum], sizeof(E.expired_signature)) == 0) {
+     return sqlite3_exec(args);
+ }


// FP: extended_errcode

@transform_return_extended_errcode_dot@
expression E;
identifier FP_NAME = extended_errcode;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_backup_pagecount(args);

// FP: extended_result_codes

@transform_return_extended_result_codes_dot@
expression E;
identifier FP_NAME = extended_result_codes;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_vfs_find(args);

// FP: file_control

@transform_return_file_control_dot@
expression E;
identifier FP_NAME = file_control;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_blob_open(args);

// FP: filename_database

@transform_return_filename_database_dot@
expression E;
identifier FP_NAME = filename_database;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_str_vappendf(args);

// FP: filename_journal

@transform_return_filename_journal_dot@
expression E;
identifier FP_NAME = filename_journal;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_str_append(args);

// FP: filename_wal

@transform_return_filename_wal_dot@
expression E;
identifier FP_NAME = filename_wal;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_str_appendall(args);

// FP: free_filename

@transform_return_free_filename_dot@
expression E;
identifier FP_NAME = free_filename;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_str_reset(args);

// FP: get_autocommit

@transform_return_get_autocommit_dot@
expression E;
identifier FP_NAME = get_autocommit;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_free(args);

// FP: get_auxdata

@transform_return_get_auxdata_dot@
expression E;
identifier FP_NAME = get_auxdata;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_free_table(args);

// FP: get_clientdata

@transform_return_get_clientdata_dot@
expression E;
identifier FP_NAME = get_clientdata;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_database_file_object(args);

// FP: get_table

@transform_return_get_table_dot@
expression E;
identifier FP_NAME = get_table;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_get_autocommit(args);

// FP: global_recover

@transform_return_global_recover_dot@
expression E;
identifier FP_NAME = global_recover;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_get_auxdata(args);

// FP: hard_heap_limit64

@transform_return_hard_heap_limit64_dot@
expression E;
identifier FP_NAME = hard_heap_limit64;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_str_finish(args);

// FP: interruptx

@transform_return_interruptx_dot@
expression E;
identifier FP_NAME = interruptx;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_get_table(args);

// FP: is_interrupted

@transform_return_is_interrupted_dot@
expression E;
identifier FP_NAME = is_interrupted;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_create_filename(args);

// FP: keyword_check

@transform_return_keyword_check_dot@
expression E;
identifier FP_NAME = keyword_check;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_db_cacheflush(args);

// FP: keyword_count

@transform_return_keyword_count_dot@
expression E;
identifier FP_NAME = keyword_count;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_status64(args);

// FP: keyword_name

@transform_return_keyword_name_dot@
expression E;
identifier FP_NAME = keyword_name;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_strlike(args);

// FP: last_insert_rowid

@transform_return_last_insert_rowid_dot@
expression E;
identifier FP_NAME = last_insert_rowid;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ return 0;

// FP: libversion

@transform_return_libversion_dot@
expression E;
identifier FP_NAME = libversion;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_interrupt(args);

// FP: libversion_number

@transform_return_libversion_number_dot@
expression E;
identifier FP_NAME = libversion_number;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_last_insert_rowid(args);

// FP: limit

@transform_return_limit_dot@
expression E;
identifier FP_NAME = limit;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_vfs_register(args);

// FP: load_extension

@transform_return_load_extension_dot@
expression E;
identifier FP_NAME = load_extension;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_db_readonly(args);

// FP: log

@transform_return_log_dot@
expression E;
identifier FP_NAME = log;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_backup_remaining(args);

// FP: malloc

@transform_return_malloc_dot@
expression E;
identifier FP_NAME = malloc;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_libversion(args);

// FP: malloc64

@transform_return_malloc64_dot@
expression E;
identifier FP_NAME = malloc64;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_db_release_memory(args);

// FP: memory_highwater

@transform_return_memory_highwater_dot@
expression E;
identifier FP_NAME = memory_highwater;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_blob_read(args);

// FP: memory_used

@transform_return_memory_used_dot@
expression E;
identifier FP_NAME = memory_used;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_blob_write(args);

// FP: mprintf

@transform_return_mprintf_dot@
expression E;
identifier FP_NAME = mprintf;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_libversion_number(args);

// FP: msize

@transform_return_msize_dot@
expression E;
identifier FP_NAME = msize;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_errstr(args);

// FP: mutex_alloc

@transform_return_mutex_alloc_dot@
expression E;
identifier FP_NAME = mutex_alloc;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_create_collation_v2(args);

// FP: mutex_enter

@transform_return_mutex_enter_dot@
expression E;
identifier FP_NAME = mutex_enter;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_file_control(args);

// FP: mutex_free

@transform_return_mutex_free_dot@
expression E;
identifier FP_NAME = mutex_free;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_memory_highwater(args);

// FP: mutex_leave

@transform_return_mutex_leave_dot@
expression E;
identifier FP_NAME = mutex_leave;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_memory_used(args);

// FP: next_stmt

@transform_return_next_stmt_dot@
expression E;
identifier FP_NAME = next_stmt;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_vfs_unregister(args);

// FP: normalized_sql

@transform_return_normalized_sql_dot@
expression E;
identifier FP_NAME = normalized_sql;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_keyword_count(args);

// FP: open

@transform_return_open_dot@
expression E;
identifier FP_NAME = open;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_malloc(args);

// FP: open16

@transform_return_open16_dot@
expression E;
identifier FP_NAME = open16;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_mprintf(args);

// FP: open_v2

@transform_return_open_v2_dot@
expression E;
identifier FP_NAME = open_v2;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ return 0;

// FP: overload_function

@transform_return_overload_function_dot@
expression E;
identifier FP_NAME = overload_function;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_value_text16be(args);

// FP: prepare

@transform_return_prepare_dot@
expression E;
identifier FP_NAME = prepare;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_open(args);

// FP: prepare16

@transform_return_prepare16_dot@
expression E;
identifier FP_NAME = prepare16;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_open16(args);

// FP: prepare16_v2

@transform_return_prepare16_v2_dot@
expression E;
identifier FP_NAME = prepare16_v2;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_value_type(args);

// FP: prepare16_v3

@transform_return_prepare16_v3_dot@
expression E;
identifier FP_NAME = prepare16_v3;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_strglob(args);

// FP: prepare_v2

@transform_return_prepare_v2_dot@
expression E;
identifier FP_NAME = prepare_v2;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_value_text16le(args);

// FP: prepare_v3

@transform_return_prepare_v3_dot@
expression E;
identifier FP_NAME = prepare_v3;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_result_text64(args);

// FP: profile

@transform_return_profile_dot@
expression E;
identifier FP_NAME = profile;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_prepare(args);

// FP: progress_handler

@transform_return_progress_handler_dot@
expression E;
identifier FP_NAME = progress_handler;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_prepare16(args);

// FP: randomness

@transform_return_randomness_dot@
expression E;
identifier FP_NAME = randomness;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_sleep(args);

// FP: realloc

@transform_return_realloc_dot@
expression E;
identifier FP_NAME = realloc;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_profile(args);

// FP: realloc64

@transform_return_realloc64_dot@
expression E;
identifier FP_NAME = realloc64;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_stmt_busy(args);

// FP: release_memory

@transform_return_release_memory_dot@
expression E;
identifier FP_NAME = release_memory;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ return 0;

// FP: reset

@transform_return_reset_dot@
expression E;
identifier FP_NAME = reset;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_progress_handler(args);

// FP: reset_auto_extension

@transform_return_reset_auto_extension_dot@
expression E;
identifier FP_NAME = reset_auto_extension;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_stmt_readonly(args);

// FP: result_blob

@transform_return_result_blob_dot@
expression E;
identifier FP_NAME = result_blob;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_realloc(args);

// FP: result_blob64

@transform_return_result_blob64_dot@
expression E;
identifier FP_NAME = result_blob64;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_stricmp(args);

// FP: result_double

@transform_return_result_double_dot@
expression E;
identifier FP_NAME = result_double;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_reset(args);

// FP: result_error

@transform_return_result_error_dot@
expression E;
identifier FP_NAME = result_error;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_result_blob(args);

// FP: result_error16

@transform_return_result_error16_dot@
expression E;
identifier FP_NAME = result_error16;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_result_double(args);

// FP: result_error_code

@transform_return_result_error_code_dot@
expression E;
identifier FP_NAME = result_error_code;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_result_error_nomem(args);

// FP: result_error_nomem

@transform_return_result_error_nomem_dot@
expression E;
identifier FP_NAME = result_error_nomem;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ return 0;

// FP: result_error_toobig

@transform_return_result_error_toobig_dot@
expression E;
identifier FP_NAME = result_error_toobig;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ return 0;

// FP: result_int

@transform_return_result_int_dot@
expression E;
identifier FP_NAME = result_int;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_result_error(args);

// FP: result_int64

@transform_return_result_int64_dot@
expression E;
identifier FP_NAME = result_int64;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_result_error16(args);

// FP: result_null

@transform_return_result_null_dot@
expression E;
identifier FP_NAME = result_null;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_result_int(args);

// FP: result_pointer

@transform_return_result_pointer_dot@
expression E;
identifier FP_NAME = result_pointer;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_value_free(args);

// FP: result_subtype

@transform_return_result_subtype_dot@
expression E;
identifier FP_NAME = result_subtype;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_bind_text64(args);

// FP: result_text

@transform_return_result_text_dot@
expression E;
identifier FP_NAME = result_text;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_result_int64(args);

// FP: result_text16

@transform_return_result_text16_dot@
expression E;
identifier FP_NAME = result_text16;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_result_null(args);

// FP: result_text16be

@transform_return_result_text16be_dot@
expression E;
identifier FP_NAME = result_text16be;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_result_text(args);

// FP: result_text16le

@transform_return_result_text16le_dot@
expression E;
identifier FP_NAME = result_text16le;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_result_text16(args);

// FP: result_text64

@transform_return_result_text64_dot@
expression E;
identifier FP_NAME = result_text64;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_uri_boolean(args);

// FP: result_value

@transform_return_result_value_dot@
expression E;
identifier FP_NAME = result_value;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_result_text16be(args);

// FP: result_zeroblob

@transform_return_result_zeroblob_dot@
expression E;
identifier FP_NAME = result_zeroblob;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_release_memory(args);

// FP: result_zeroblob64

@transform_return_result_zeroblob64_dot@
expression E;
identifier FP_NAME = result_zeroblob64;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_wal_checkpoint_v2(args);

// FP: rollback_hook

@transform_return_rollback_hook_dot@
expression E;
identifier FP_NAME = rollback_hook;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_result_text16le(args);

// FP: serialize

@transform_return_serialize_dot@
expression E;
identifier FP_NAME = serialize;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_filename_database(args);

// FP: set_authorizer

@transform_return_set_authorizer_dot@
expression E;
identifier FP_NAME = set_authorizer;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_result_value(args);

// FP: set_auxdata

@transform_return_set_auxdata_dot@
expression E;
identifier FP_NAME = set_auxdata;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_rollback_hook(args);

// FP: set_clientdata

@transform_return_set_clientdata_dot@
expression E;
identifier FP_NAME = set_clientdata;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_txn_state(args);

// FP: set_errmsg

@transform_return_set_errmsg_dot@
expression E;
identifier FP_NAME = set_errmsg;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_total_changes64(args);

// FP: set_last_insert_rowid

@transform_return_set_last_insert_rowid_dot@
expression E;
identifier FP_NAME = set_last_insert_rowid;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_result_blob64(args);

// FP: setlk_timeout

@transform_return_setlk_timeout_dot@
expression E;
identifier FP_NAME = setlk_timeout;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_changes64(args);

// FP: soft_heap_limit

@transform_return_soft_heap_limit_dot@
expression E;
identifier FP_NAME = soft_heap_limit;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_mutex_enter(args);

// FP: soft_heap_limit64

@transform_return_soft_heap_limit64_dot@
expression E;
identifier FP_NAME = soft_heap_limit64;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_backup_step(args);

// FP: sql

@transform_return_sql_dot@
expression E;
identifier FP_NAME = sql;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_threadsafe(args);

// FP: status

@transform_return_status_dot@
expression E;
identifier FP_NAME = status;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_result_zeroblob(args);

// FP: status64

@transform_return_status64_dot@
expression E;
identifier FP_NAME = status64;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_cancel_auto_extension(args);

// FP: step

@transform_return_step_dot@
expression E;
identifier FP_NAME = step;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_set_auxdata(args);

// FP: stmt_explain

@transform_return_stmt_explain_dot@
expression E;
identifier FP_NAME = stmt_explain;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_free_filename(args);

// FP: stmt_isexplain

@transform_return_stmt_isexplain_dot@
expression E;
identifier FP_NAME = stmt_isexplain;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_keyword_name(args);

// FP: stmt_status

@transform_return_stmt_status_dot@
expression E;
identifier FP_NAME = stmt_status;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_compileoption_used(args);

// FP: str_append

@transform_return_str_append_dot@
expression E;
identifier FP_NAME = str_append;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_prepare_v3(args);

// FP: str_appendall

@transform_return_str_appendall_dot@
expression E;
identifier FP_NAME = str_appendall;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_prepare16_v3(args);

// FP: str_appendchar

@transform_return_str_appendchar_dot@
expression E;
identifier FP_NAME = str_appendchar;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_bind_pointer(args);

// FP: str_appendf

@transform_return_str_appendf_dot@
expression E;
identifier FP_NAME = str_appendf;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_expanded_sql(args);

// FP: str_errcode

@transform_return_str_errcode_dot@
expression E;
identifier FP_NAME = str_errcode;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_value_pointer(args);

// FP: str_finish

@transform_return_str_finish_dot@
expression E;
identifier FP_NAME = str_finish;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_trace_v2(args);

// FP: str_length

@transform_return_str_length_dot@
expression E;
identifier FP_NAME = str_length;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_vtab_nochange(args);

// FP: str_new

@transform_return_str_new_dot@
expression E;
identifier FP_NAME = str_new;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_system_errno(args);

// FP: str_reset

@transform_return_str_reset_dot@
expression E;
identifier FP_NAME = str_reset;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_result_pointer(args);

// FP: str_value

@transform_return_str_value_dot@
expression E;
identifier FP_NAME = str_value;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_value_nochange(args);

// FP: str_vappendf

@transform_return_str_vappendf_dot@
expression E;
identifier FP_NAME = str_vappendf;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_set_last_insert_rowid(args);

// FP: strglob

@transform_return_strglob_dot@
expression E;
identifier FP_NAME = strglob;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_uri_int64(args);

// FP: stricmp

@transform_return_stricmp_dot@
expression E;
identifier FP_NAME = stricmp;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_wal_checkpoint(args);

// FP: strlike

@transform_return_strlike_dot@
expression E;
identifier FP_NAME = strlike;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_load_extension(args);

// FP: system_errno

@transform_return_system_errno_dot@
expression E;
identifier FP_NAME = system_errno;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_msize(args);

// FP: table_column_metadata

@transform_return_table_column_metadata_dot@
expression E;
identifier FP_NAME = table_column_metadata;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_snprintf(args);

// FP: test_control

@transform_return_test_control_dot@
expression E;
identifier FP_NAME = test_control;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_result_error_toobig(args);

// FP: thread_cleanup

@transform_return_thread_cleanup_dot@
expression E;
identifier FP_NAME = thread_cleanup;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_step(args);

// FP: total_changes

@transform_return_total_changes_dot@
expression E;
identifier FP_NAME = total_changes;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_table_column_metadata(args);

// FP: total_changes64

@transform_return_total_changes64_dot@
expression E;
identifier FP_NAME = total_changes64;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_create_window_function(args);

// FP: trace_v2

@transform_return_trace_v2_dot@
expression E;
identifier FP_NAME = trace_v2;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_realloc64(args);

// FP: txn_state

@transform_return_txn_state_dot@
expression E;
identifier FP_NAME = txn_state;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_str_length(args);

// FP: unlock_notify

@transform_return_unlock_notify_dot@
expression E;
identifier FP_NAME = unlock_notify;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ return 0;

// FP: uri_boolean

@transform_return_uri_boolean_dot@
expression E;
identifier FP_NAME = uri_boolean;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_wal_hook(args);

// FP: uri_key

@transform_return_uri_key_dot@
expression E;
identifier FP_NAME = uri_key;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_str_appendf(args);

// FP: uri_parameter

@transform_return_uri_parameter_dot@
expression E;
identifier FP_NAME = uri_parameter;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ return 0;

// FP: user_data

@transform_return_user_data_dot@
expression E;
identifier FP_NAME = user_data;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_trace(args);

// FP: value_double

@transform_return_value_double_dot@
expression E;
identifier FP_NAME = value_double;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_user_data(args);

// FP: value_dup

@transform_return_value_dup_dot@
expression E;
identifier FP_NAME = value_dup;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_uri_parameter(args);

// FP: value_encoding

@transform_return_value_encoding_dot@
expression E;
identifier FP_NAME = value_encoding;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_filename_wal(args);

// FP: value_free

@transform_return_value_free_dot@
expression E;
identifier FP_NAME = value_free;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_vsnprintf(args);

// FP: value_frombind

@transform_return_value_frombind_dot@
expression E;
identifier FP_NAME = value_frombind;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_keyword_check(args);

// FP: value_int

@transform_return_value_int_dot@
expression E;
identifier FP_NAME = value_int;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_value_blob(args);

// FP: value_int64

@transform_return_value_int64_dot@
expression E;
identifier FP_NAME = value_int64;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_value_bytes(args);

// FP: value_nochange

@transform_return_value_nochange_dot@
expression E;
identifier FP_NAME = value_nochange;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_value_subtype(args);

// FP: value_numeric_type

@transform_return_value_numeric_type_dot@
expression E;
identifier FP_NAME = value_numeric_type;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_value_bytes16(args);

// FP: value_pointer

@transform_return_value_pointer_dot@
expression E;
identifier FP_NAME = value_pointer;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_result_zeroblob64(args);

// FP: value_subtype

@transform_return_value_subtype_dot@
expression E;
identifier FP_NAME = value_subtype;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_bind_blob64(args);

// FP: value_text

@transform_return_value_text_dot@
expression E;
identifier FP_NAME = value_text;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_value_double(args);

// FP: value_text16

@transform_return_value_text16_dot@
expression E;
identifier FP_NAME = value_text16;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_value_int(args);

// FP: value_text16be

@transform_return_value_text16be_dot@
expression E;
identifier FP_NAME = value_text16be;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_value_int64(args);

// FP: value_text16le

@transform_return_value_text16le_dot@
expression E;
identifier FP_NAME = value_text16le;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_value_numeric_type(args);

// FP: value_type

@transform_return_value_type_dot@
expression E;
identifier FP_NAME = value_type;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_value_text(args);

// FP: vfs_find

@transform_return_vfs_find_dot@
expression E;
identifier FP_NAME = vfs_find;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_mutex_free(args);

// FP: vfs_register

@transform_return_vfs_register_dot@
expression E;
identifier FP_NAME = vfs_register;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_mutex_leave(args);

// FP: vfs_unregister

@transform_return_vfs_unregister_dot@
expression E;
identifier FP_NAME = vfs_unregister;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_mutex_try(args);

// FP: vmprintf

@transform_return_vmprintf_dot@
expression E;
identifier FP_NAME = vmprintf;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_value_text16(args);

// FP: vtab_collation

@transform_return_vtab_collation_dot@
expression E;
identifier FP_NAME = vtab_collation;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_result_subtype(args);

// FP: vtab_config

@transform_return_vtab_config_dot@
expression E;
identifier FP_NAME = vtab_config;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_extended_errcode(args);

// FP: vtab_distinct

@transform_return_vtab_distinct_dot@
expression E;
identifier FP_NAME = vtab_distinct;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_value_frombind(args);

// FP: vtab_nochange

@transform_return_vtab_nochange_dot@
expression E;
identifier FP_NAME = vtab_nochange;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_bind_zeroblob64(args);

// FP: vtab_on_conflict

@transform_return_vtab_on_conflict_dot@
expression E;
identifier FP_NAME = vtab_on_conflict;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_log(args);

// FP: wal_checkpoint

@transform_return_wal_checkpoint_dot@
expression E;
identifier FP_NAME = wal_checkpoint;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_db_config(args);

// FP: wal_hook

@transform_return_wal_hook_dot@
expression E;
identifier FP_NAME = wal_hook;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_db_mutex(args);

// FP: xAccess

@transform_return_xAccess_dot@
expression E;
identifier FP_NAME = xAccess;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xAccess_signature, xAccess_signatures[xAccess_apndAccess_enum], sizeof(E.xAccess_signature)) == 0) {
+     return apndAccess(args);
+ }
+ else if (memcmp(E.xAccess_signature, xAccess_signatures[xAccess_memdbAccess_enum], sizeof(E.xAccess_signature)) == 0) {
+     return memdbAccess(args);
+ }
+ else if (memcmp(E.xAccess_signature, xAccess_signatures[xAccess_vfstraceAccess_enum], sizeof(E.xAccess_signature)) == 0) {
+     return vfstraceAccess(args);
+ }
+ else if (memcmp(E.xAccess_signature, xAccess_signatures[xAccess_unixAccess_enum], sizeof(E.xAccess_signature)) == 0) {
+     return unixAccess(args);
+ }


// FP: xAltLocaltime

@transform_return_xAltLocaltime_dot@
expression E;
identifier FP_NAME = xAltLocaltime;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ return 0;

// FP: xAutovacDestr

@transform_return_xAutovacDestr_dot@
expression E;
identifier FP_NAME = xAutovacDestr;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xAutovacDestr_signature, xAutovacDestr_signatures[xAutovacDestr_0_enum], sizeof(E.xAutovacDestr_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xAutovacDestr_signature, xAutovacDestr_signatures[xAutovacDestr_rtreeMatchArgFree_enum], sizeof(E.xAutovacDestr_signature)) == 0) {
+     return rtreeMatchArgFree(args);
+ }
+ else if (memcmp(E.xAutovacDestr_signature, xAutovacDestr_signatures[xAutovacDestr_sqlite3VdbeValueListFree_enum], sizeof(E.xAutovacDestr_signature)) == 0) {
+     return sqlite3VdbeValueListFree(args);
+ }


// FP: xAutovacPages

@transform_return_xAutovacPages_dot@
expression E;
identifier FP_NAME = xAutovacPages;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xAutovacPages_signature, xAutovacPages_signatures[xAutovacPages_0_enum], sizeof(E.xAutovacPages_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xAutovacPages_signature, xAutovacPages_signatures[xAutovacPages_sql_trace_callback_enum], sizeof(E.xAutovacPages_signature)) == 0) {
+     return sql_trace_callback(args);
+ }
+ else if (memcmp(E.xAutovacPages_signature, xAutovacPages_signatures[xAutovacPages_sqlite3WalDefaultHook_enum], sizeof(E.xAutovacPages_signature)) == 0) {
+     return sqlite3WalDefaultHook(args);
+ }


// FP: xBegin

@transform_return_xBegin_dot@
expression E;
identifier FP_NAME = xBegin;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xBegin_signature, xBegin_signatures[xBegin_0_enum], sizeof(E.xBegin_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xBegin_signature, xBegin_signatures[xBegin_dbpageBegin_enum], sizeof(E.xBegin_signature)) == 0) {
+     return dbpageBegin(args);
+ }
+ else if (memcmp(E.xBegin_signature, xBegin_signatures[xBegin_fts3BeginMethod_enum], sizeof(E.xBegin_signature)) == 0) {
+     return fts3BeginMethod(args);
+ }
+ else if (memcmp(E.xBegin_signature, xBegin_signatures[xBegin_rtreeBeginTransaction_enum], sizeof(E.xBegin_signature)) == 0) {
+     return rtreeBeginTransaction(args);
+ }
+ else if (memcmp(E.xBegin_signature, xBegin_signatures[xBegin_zipfileBegin_enum], sizeof(E.xBegin_signature)) == 0) {
+     return zipfileBegin(args);
+ }


// FP: xBestIndex

@transform_return_xBestIndex_dot@
expression E;
identifier FP_NAME = xBestIndex;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xBestIndex_signature, xBestIndex_signatures[xBestIndex_bytecodevtabBestIndex_enum], sizeof(E.xBestIndex_signature)) == 0) {
+     return bytecodevtabBestIndex(args);
+ }
+ else if (memcmp(E.xBestIndex_signature, xBestIndex_signatures[xBestIndex_completionBestIndex_enum], sizeof(E.xBestIndex_signature)) == 0) {
+     return completionBestIndex(args);
+ }
+ else if (memcmp(E.xBestIndex_signature, xBestIndex_signatures[xBestIndex_dbdataBestIndex_enum], sizeof(E.xBestIndex_signature)) == 0) {
+     return dbdataBestIndex(args);
+ }
+ else if (memcmp(E.xBestIndex_signature, xBestIndex_signatures[xBestIndex_dbpageBestIndex_enum], sizeof(E.xBestIndex_signature)) == 0) {
+     return dbpageBestIndex(args);
+ }
+ else if (memcmp(E.xBestIndex_signature, xBestIndex_signatures[xBestIndex_expertBestIndex_enum], sizeof(E.xBestIndex_signature)) == 0) {
+     return expertBestIndex(args);
+ }
+ else if (memcmp(E.xBestIndex_signature, xBestIndex_signatures[xBestIndex_fsdirBestIndex_enum], sizeof(E.xBestIndex_signature)) == 0) {
+     return fsdirBestIndex(args);
+ }
+ else if (memcmp(E.xBestIndex_signature, xBestIndex_signatures[xBestIndex_fts3BestIndexMethod_enum], sizeof(E.xBestIndex_signature)) == 0) {
+     return fts3BestIndexMethod(args);
+ }
+ else if (memcmp(E.xBestIndex_signature, xBestIndex_signatures[xBestIndex_fts3auxBestIndexMethod_enum], sizeof(E.xBestIndex_signature)) == 0) {
+     return fts3auxBestIndexMethod(args);
+ }
+ else if (memcmp(E.xBestIndex_signature, xBestIndex_signatures[xBestIndex_fts3tokBestIndexMethod_enum], sizeof(E.xBestIndex_signature)) == 0) {
+     return fts3tokBestIndexMethod(args);
+ }
+ else if (memcmp(E.xBestIndex_signature, xBestIndex_signatures[xBestIndex_jsonEachBestIndex_enum], sizeof(E.xBestIndex_signature)) == 0) {
+     return jsonEachBestIndex(args);
+ }
+ else if (memcmp(E.xBestIndex_signature, xBestIndex_signatures[xBestIndex_pragmaVtabBestIndex_enum], sizeof(E.xBestIndex_signature)) == 0) {
+     return pragmaVtabBestIndex(args);
+ }
+ else if (memcmp(E.xBestIndex_signature, xBestIndex_signatures[xBestIndex_rtreeBestIndex_enum], sizeof(E.xBestIndex_signature)) == 0) {
+     return rtreeBestIndex(args);
+ }
+ else if (memcmp(E.xBestIndex_signature, xBestIndex_signatures[xBestIndex_seriesBestIndex_enum], sizeof(E.xBestIndex_signature)) == 0) {
+     return seriesBestIndex(args);
+ }
+ else if (memcmp(E.xBestIndex_signature, xBestIndex_signatures[xBestIndex_statBestIndex_enum], sizeof(E.xBestIndex_signature)) == 0) {
+     return statBestIndex(args);
+ }
+ else if (memcmp(E.xBestIndex_signature, xBestIndex_signatures[xBestIndex_stmtBestIndex_enum], sizeof(E.xBestIndex_signature)) == 0) {
+     return stmtBestIndex(args);
+ }
+ else if (memcmp(E.xBestIndex_signature, xBestIndex_signatures[xBestIndex_zipfileBestIndex_enum], sizeof(E.xBestIndex_signature)) == 0) {
+     return zipfileBestIndex(args);
+ }


// FP: xBusyHandler

@transform_return_xBusyHandler_dot@
expression E;
identifier FP_NAME = xBusyHandler;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xBusyHandler_signature, xBusyHandler_signatures[xBusyHandler_0_enum], sizeof(E.xBusyHandler_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xBusyHandler_signature, xBusyHandler_signatures[xBusyHandler_btreeInvokeBusyHandler_enum], sizeof(E.xBusyHandler_signature)) == 0) {
+     return btreeInvokeBusyHandler(args);
+ }
+ else if (memcmp(E.xBusyHandler_signature, xBusyHandler_signatures[xBusyHandler_sqliteDefaultBusyCallback_enum], sizeof(E.xBusyHandler_signature)) == 0) {
+     return sqliteDefaultBusyCallback(args);
+ }
+ else if (memcmp(E.xBusyHandler_signature, xBusyHandler_signatures[xBusyHandler_xBusyHandler_enum], sizeof(E.xBusyHandler_signature)) == 0) {
+     return xBusyHandler(args);
+ }


// FP: xCachesize

@transform_return_xCachesize_dot@
expression E;
identifier FP_NAME = xCachesize;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xCachesize_signature, xCachesize_signatures[xCachesize_pcache1Cachesize_enum], sizeof(E.xCachesize_signature)) == 0) {
+     return pcache1Cachesize(args);
+ }
+ else if (memcmp(E.xCachesize_signature, xCachesize_signatures[xCachesize_pcachetraceCachesize_enum], sizeof(E.xCachesize_signature)) == 0) {
+     return pcachetraceCachesize(args);
+ }


// FP: xCellSize

@transform_return_xCellSize_dot@
expression E;
identifier FP_NAME = xCellSize;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xCellSize_signature, xCellSize_signatures[xCellSize_cellSizePtr_enum], sizeof(E.xCellSize_signature)) == 0) {
+     return cellSizePtr(args);
+ }
+ else if (memcmp(E.xCellSize_signature, xCellSize_signatures[xCellSize_cellSizePtrIdxLeaf_enum], sizeof(E.xCellSize_signature)) == 0) {
+     return cellSizePtrIdxLeaf(args);
+ }
+ else if (memcmp(E.xCellSize_signature, xCellSize_signatures[xCellSize_cellSizePtrNoPayload_enum], sizeof(E.xCellSize_signature)) == 0) {
+     return cellSizePtrNoPayload(args);
+ }
+ else if (memcmp(E.xCellSize_signature, xCellSize_signatures[xCellSize_cellSizePtrTableLeaf_enum], sizeof(E.xCellSize_signature)) == 0) {
+     return cellSizePtrTableLeaf(args);
+ }


// FP: xCheckReservedLock

@transform_return_xCheckReservedLock_dot@
expression E;
identifier FP_NAME = xCheckReservedLock;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xCheckReservedLock_signature, xCheckReservedLock_signatures[xCheckReservedLock_0_enum], sizeof(E.xCheckReservedLock_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xCheckReservedLock_signature, xCheckReservedLock_signatures[xCheckReservedLock_apndCheckReservedLock_enum], sizeof(E.xCheckReservedLock_signature)) == 0) {
+     return apndCheckReservedLock(args);
+ }
+ else if (memcmp(E.xCheckReservedLock_signature, xCheckReservedLock_signatures[xCheckReservedLock_recoverVfsCheckReservedLock_enum], sizeof(E.xCheckReservedLock_signature)) == 0) {
+     return recoverVfsCheckReservedLock(args);
+ }
+ else if (memcmp(E.xCheckReservedLock_signature, xCheckReservedLock_signatures[xCheckReservedLock_vfstraceCheckReservedLock_enum], sizeof(E.xCheckReservedLock_signature)) == 0) {
+     return vfstraceCheckReservedLock(args);
+ }


// FP: xCleanup

@transform_return_xCleanup_dot@
expression E;
identifier FP_NAME = xCleanup;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xCleanup_signature, xCleanup_signatures[xCleanup_agginfoFree_enum], sizeof(E.xCleanup_signature)) == 0) {
+     return agginfoFree(args);
+ }
+ else if (memcmp(E.xCleanup_signature, xCleanup_signatures[xCleanup_sqlite3DbFree_enum], sizeof(E.xCleanup_signature)) == 0) {
+     return sqlite3DbFree(args);
+ }
+ else if (memcmp(E.xCleanup_signature, xCleanup_signatures[xCleanup_sqlite3DeleteReturning_enum], sizeof(E.xCleanup_signature)) == 0) {
+     return sqlite3DeleteReturning(args);
+ }
+ else if (memcmp(E.xCleanup_signature, xCleanup_signatures[xCleanup_sqlite3DeleteTableGeneric_enum], sizeof(E.xCleanup_signature)) == 0) {
+     return sqlite3DeleteTableGeneric(args);
+ }
+ else if (memcmp(E.xCleanup_signature, xCleanup_signatures[xCleanup_sqlite3ExprDeleteGeneric_enum], sizeof(E.xCleanup_signature)) == 0) {
+     return sqlite3ExprDeleteGeneric(args);
+ }
+ else if (memcmp(E.xCleanup_signature, xCleanup_signatures[xCleanup_sqlite3ExprListDeleteGeneric_enum], sizeof(E.xCleanup_signature)) == 0) {
+     return sqlite3ExprListDeleteGeneric(args);
+ }
+ else if (memcmp(E.xCleanup_signature, xCleanup_signatures[xCleanup_sqlite3SelectDeleteGeneric_enum], sizeof(E.xCleanup_signature)) == 0) {
+     return sqlite3SelectDeleteGeneric(args);
+ }
+ else if (memcmp(E.xCleanup_signature, xCleanup_signatures[xCleanup_sqlite3WithDeleteGeneric_enum], sizeof(E.xCleanup_signature)) == 0) {
+     return sqlite3WithDeleteGeneric(args);
+ }
+ else if (memcmp(E.xCleanup_signature, xCleanup_signatures[xCleanup_whereIndexedExprCleanup_enum], sizeof(E.xCleanup_signature)) == 0) {
+     return whereIndexedExprCleanup(args);
+ }


// FP: xClose

@transform_return_xClose_dot@
expression E;
identifier FP_NAME = xClose;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xClose_signature, xClose_signatures[xClose_apndClose_enum], sizeof(E.xClose_signature)) == 0) {
+     return apndClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_bytecodevtabClose_enum], sizeof(E.xClose_signature)) == 0) {
+     return bytecodevtabClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_completionClose_enum], sizeof(E.xClose_signature)) == 0) {
+     return completionClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_dbdataClose_enum], sizeof(E.xClose_signature)) == 0) {
+     return dbdataClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_dbpageClose_enum], sizeof(E.xClose_signature)) == 0) {
+     return dbpageClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_expertClose_enum], sizeof(E.xClose_signature)) == 0) {
+     return expertClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_fsdirClose_enum], sizeof(E.xClose_signature)) == 0) {
+     return fsdirClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_fts3CloseMethod_enum], sizeof(E.xClose_signature)) == 0) {
+     return fts3CloseMethod(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_fts3auxCloseMethod_enum], sizeof(E.xClose_signature)) == 0) {
+     return fts3auxCloseMethod(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_fts3tokCloseMethod_enum], sizeof(E.xClose_signature)) == 0) {
+     return fts3tokCloseMethod(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_jsonEachClose_enum], sizeof(E.xClose_signature)) == 0) {
+     return jsonEachClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_memdbClose_enum], sizeof(E.xClose_signature)) == 0) {
+     return memdbClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_memjrnlClose_enum], sizeof(E.xClose_signature)) == 0) {
+     return memjrnlClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_porterClose_enum], sizeof(E.xClose_signature)) == 0) {
+     return porterClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_pragmaVtabClose_enum], sizeof(E.xClose_signature)) == 0) {
+     return pragmaVtabClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_recoverVfsClose_enum], sizeof(E.xClose_signature)) == 0) {
+     return recoverVfsClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_rtreeClose_enum], sizeof(E.xClose_signature)) == 0) {
+     return rtreeClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_seriesClose_enum], sizeof(E.xClose_signature)) == 0) {
+     return seriesClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_simpleClose_enum], sizeof(E.xClose_signature)) == 0) {
+     return simpleClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_statClose_enum], sizeof(E.xClose_signature)) == 0) {
+     return statClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_stmtClose_enum], sizeof(E.xClose_signature)) == 0) {
+     return stmtClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_unicodeClose_enum], sizeof(E.xClose_signature)) == 0) {
+     return unicodeClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_vfstraceClose_enum], sizeof(E.xClose_signature)) == 0) {
+     return vfstraceClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_zipfileClose_enum], sizeof(E.xClose_signature)) == 0) {
+     return zipfileClose(args);
+ }


// FP: xCmp

@transform_return_xCmp_dot@
expression E;
identifier FP_NAME = xCmp;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xCmp_signature, xCmp_signatures[xCmp_0_enum], sizeof(E.xCmp_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xCmp_signature, xCmp_signatures[xCmp_binCollFunc_enum], sizeof(E.xCmp_signature)) == 0) {
+     return binCollFunc(args);
+ }
+ else if (memcmp(E.xCmp_signature, xCmp_signatures[xCmp_decimalCollFunc_enum], sizeof(E.xCmp_signature)) == 0) {
+     return decimalCollFunc(args);
+ }
+ else if (memcmp(E.xCmp_signature, xCmp_signatures[xCmp_dummyCompare_enum], sizeof(E.xCmp_signature)) == 0) {
+     return dummyCompare(args);
+ }
+ else if (memcmp(E.xCmp_signature, xCmp_signatures[xCmp_icuCollationColl_enum], sizeof(E.xCmp_signature)) == 0) {
+     return icuCollationColl(args);
+ }
+ else if (memcmp(E.xCmp_signature, xCmp_signatures[xCmp_nocaseCollatingFunc_enum], sizeof(E.xCmp_signature)) == 0) {
+     return nocaseCollatingFunc(args);
+ }
+ else if (memcmp(E.xCmp_signature, xCmp_signatures[xCmp_rtrimCollFunc_enum], sizeof(E.xCmp_signature)) == 0) {
+     return rtrimCollFunc(args);
+ }
+ else if (memcmp(E.xCmp_signature, xCmp_signatures[xCmp_uintCollFunc_enum], sizeof(E.xCmp_signature)) == 0) {
+     return uintCollFunc(args);
+ }


// FP: xCollNeeded16

@transform_return_xCollNeeded16_dot@
expression E;
identifier FP_NAME = xCollNeeded16;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ return 0;

// FP: xColumn

@transform_return_xColumn_dot@
expression E;
identifier FP_NAME = xColumn;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_bytecodevtabColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+     return bytecodevtabColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_completionColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+     return completionColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_dbdataColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+     return dbdataColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_dbpageColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+     return dbpageColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_expertColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+     return expertColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_fsdirColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+     return fsdirColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_fts3ColumnMethod_enum], sizeof(E.xColumn_signature)) == 0) {
+     return fts3ColumnMethod(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_fts3auxColumnMethod_enum], sizeof(E.xColumn_signature)) == 0) {
+     return fts3auxColumnMethod(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_fts3tokColumnMethod_enum], sizeof(E.xColumn_signature)) == 0) {
+     return fts3tokColumnMethod(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_geopolyColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+     return geopolyColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_jsonEachColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+     return jsonEachColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_pragmaVtabColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+     return pragmaVtabColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_rtreeColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+     return rtreeColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_seriesColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+     return seriesColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_statColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+     return statColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_stmtColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+     return stmtColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_zipfileColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+     return zipfileColumn(args);
+ }


// FP: xCommit

@transform_return_xCommit_dot@
expression E;
identifier FP_NAME = xCommit;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xCommit_signature, xCommit_signatures[xCommit_0_enum], sizeof(E.xCommit_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xCommit_signature, xCommit_signatures[xCommit_fts3CommitMethod_enum], sizeof(E.xCommit_signature)) == 0) {
+     return fts3CommitMethod(args);
+ }
+ else if (memcmp(E.xCommit_signature, xCommit_signatures[xCommit_rtreeEndTransaction_enum], sizeof(E.xCommit_signature)) == 0) {
+     return rtreeEndTransaction(args);
+ }
+ else if (memcmp(E.xCommit_signature, xCommit_signatures[xCommit_zipfileCommit_enum], sizeof(E.xCommit_signature)) == 0) {
+     return zipfileCommit(args);
+ }


// FP: xCommitCallback

@transform_return_xCommitCallback_dot@
expression E;
identifier FP_NAME = xCommitCallback;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xCommitCallback_signature, xCommitCallback_signatures[xCommitCallback_0_enum], sizeof(E.xCommitCallback_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xCommitCallback_signature, xCommitCallback_signatures[xCommitCallback_sql_trace_callback_enum], sizeof(E.xCommitCallback_signature)) == 0) {
+     return sql_trace_callback(args);
+ }
+ else if (memcmp(E.xCommitCallback_signature, xCommitCallback_signatures[xCommitCallback_sqlite3WalDefaultHook_enum], sizeof(E.xCommitCallback_signature)) == 0) {
+     return sqlite3WalDefaultHook(args);
+ }


// FP: xConnect

@transform_return_xConnect_dot@
expression E;
identifier FP_NAME = xConnect;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_bytecodevtabConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+     return bytecodevtabConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_dbpageConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+     return dbpageConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_fts3ConnectMethod_enum], sizeof(E.xConnect_signature)) == 0) {
+     return fts3ConnectMethod(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_fts3auxConnectMethod_enum], sizeof(E.xConnect_signature)) == 0) {
+     return fts3auxConnectMethod(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_fts3tokConnectMethod_enum], sizeof(E.xConnect_signature)) == 0) {
+     return fts3tokConnectMethod(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_jsonEachConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+     return jsonEachConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_pragmaVtabConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+     return pragmaVtabConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_rtreeConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+     return rtreeConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_statConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+     return statConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_stmtConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+     return stmtConnect(args);
+ }


// FP: xCount

@transform_return_xCount_dot@
expression E;
identifier FP_NAME = xCount;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xCount_signature, xCount_signatures[xCount_sessionDiffCount_enum], sizeof(E.xCount_signature)) == 0) {
+     return sessionDiffCount(args);
+ }
+ else if (memcmp(E.xCount_signature, xCount_signatures[xCount_sessionPreupdateCount_enum], sizeof(E.xCount_signature)) == 0) {
+     return sessionPreupdateCount(args);
+ }
+ else if (memcmp(E.xCount_signature, xCount_signatures[xCount_sessionStat1Count_enum], sizeof(E.xCount_signature)) == 0) {
+     return sessionStat1Count(args);
+ }


// FP: xCreate

@transform_return_xCreate_dot@
expression E;
identifier FP_NAME = xCreate;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_0_enum], sizeof(E.xCreate_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_dbpageConnect_enum], sizeof(E.xCreate_signature)) == 0) {
+     return dbpageConnect(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_fts3CreateMethod_enum], sizeof(E.xCreate_signature)) == 0) {
+     return fts3CreateMethod(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_fts3auxConnectMethod_enum], sizeof(E.xCreate_signature)) == 0) {
+     return fts3auxConnectMethod(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_fts3tokConnectMethod_enum], sizeof(E.xCreate_signature)) == 0) {
+     return fts3tokConnectMethod(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_geopolyCreate_enum], sizeof(E.xCreate_signature)) == 0) {
+     return geopolyCreate(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_pcache1Create_enum], sizeof(E.xCreate_signature)) == 0) {
+     return pcache1Create(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_pcachetraceCreate_enum], sizeof(E.xCreate_signature)) == 0) {
+     return pcachetraceCreate(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_porterCreate_enum], sizeof(E.xCreate_signature)) == 0) {
+     return porterCreate(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_rtreeCreate_enum], sizeof(E.xCreate_signature)) == 0) {
+     return rtreeCreate(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_simpleCreate_enum], sizeof(E.xCreate_signature)) == 0) {
+     return simpleCreate(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_statConnect_enum], sizeof(E.xCreate_signature)) == 0) {
+     return statConnect(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_unicodeCreate_enum], sizeof(E.xCreate_signature)) == 0) {
+     return unicodeCreate(args);
+ }


// FP: xCurrentTime

@transform_return_xCurrentTime_dot@
expression E;
identifier FP_NAME = xCurrentTime;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xCurrentTime_signature, xCurrentTime_signatures[xCurrentTime_0_enum], sizeof(E.xCurrentTime_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xCurrentTime_signature, xCurrentTime_signatures[xCurrentTime_apndCurrentTime_enum], sizeof(E.xCurrentTime_signature)) == 0) {
+     return apndCurrentTime(args);
+ }
+ else if (memcmp(E.xCurrentTime_signature, xCurrentTime_signatures[xCurrentTime_vfstraceCurrentTime_enum], sizeof(E.xCurrentTime_signature)) == 0) {
+     return vfstraceCurrentTime(args);
+ }
+ else if (memcmp(E.xCurrentTime_signature, xCurrentTime_signatures[xCurrentTime_unixCurrentTime_enum], sizeof(E.xCurrentTime_signature)) == 0) {
+     return unixCurrentTime(args);
+ }


// FP: xCurrentTimeInt64

@transform_return_xCurrentTimeInt64_dot@
expression E;
identifier FP_NAME = xCurrentTimeInt64;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xCurrentTimeInt64_signature, xCurrentTimeInt64_signatures[xCurrentTimeInt64_apndCurrentTimeInt64_enum], sizeof(E.xCurrentTimeInt64_signature)) == 0) {
+     return apndCurrentTimeInt64(args);
+ }
+ else if (memcmp(E.xCurrentTimeInt64_signature, xCurrentTimeInt64_signatures[xCurrentTimeInt64_memdbCurrentTimeInt64_enum], sizeof(E.xCurrentTimeInt64_signature)) == 0) {
+     return memdbCurrentTimeInt64(args);
+ }
+ else if (memcmp(E.xCurrentTimeInt64_signature, xCurrentTimeInt64_signatures[xCurrentTimeInt64_unixCurrentTimeInt64_enum], sizeof(E.xCurrentTimeInt64_signature)) == 0) {
+     return unixCurrentTimeInt64(args);
+ }


// FP: xDel

@transform_return_xDel_dot@
expression E;
identifier FP_NAME = xDel;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xDel_signature, xDel_signatures[xDel_0_enum], sizeof(E.xDel_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xDel_signature, xDel_signatures[xDel_SQLITE_DYNAMIC_enum], sizeof(E.xDel_signature)) == 0) {
+     return SQLITE_DYNAMIC(args);
+ }
+ else if (memcmp(E.xDel_signature, xDel_signatures[xDel_SQLITE_STATIC_enum], sizeof(E.xDel_signature)) == 0) {
+     return SQLITE_STATIC(args);
+ }
+ else if (memcmp(E.xDel_signature, xDel_signatures[xDel_SQLITE_TRANSIENT_enum], sizeof(E.xDel_signature)) == 0) {
+     return SQLITE_TRANSIENT(args);
+ }
+ else if (memcmp(E.xDel_signature, xDel_signatures[xDel_rtreeMatchArgFree_enum], sizeof(E.xDel_signature)) == 0) {
+     return rtreeMatchArgFree(args);
+ }
+ else if (memcmp(E.xDel_signature, xDel_signatures[xDel_sqlite3RCStrUnref_enum], sizeof(E.xDel_signature)) == 0) {
+     return sqlite3RCStrUnref(args);
+ }
+ else if (memcmp(E.xDel_signature, xDel_signatures[xDel_sqlite3RowSetDelete_enum], sizeof(E.xDel_signature)) == 0) {
+     return sqlite3RowSetDelete(args);
+ }
+ else if (memcmp(E.xDel_signature, xDel_signatures[xDel_sqlite3SchemaClear_enum], sizeof(E.xDel_signature)) == 0) {
+     return sqlite3SchemaClear(args);
+ }
+ else if (memcmp(E.xDel_signature, xDel_signatures[xDel_sqlite3VdbeFrameMemDel_enum], sizeof(E.xDel_signature)) == 0) {
+     return sqlite3VdbeFrameMemDel(args);
+ }
+ else if (memcmp(E.xDel_signature, xDel_signatures[xDel_sqlite3VdbeValueListFree_enum], sizeof(E.xDel_signature)) == 0) {
+     return sqlite3VdbeValueListFree(args);
+ }
+ else if (memcmp(E.xDel_signature, xDel_signatures[xDel_sqlite3_free_enum], sizeof(E.xDel_signature)) == 0) {
+     return sqlite3_free(args);
+ }
+ else if (memcmp(E.xDel_signature, xDel_signatures[xDel_statAccumDestructor_enum], sizeof(E.xDel_signature)) == 0) {
+     return statAccumDestructor(args);
+ }
+ else if (memcmp(E.xDel_signature, xDel_signatures[xDel_xDel_enum], sizeof(E.xDel_signature)) == 0) {
+     return xDel(args);
+ }
+ else if (memcmp(E.xDel_signature, xDel_signatures[xDel_zipfileFree_enum], sizeof(E.xDel_signature)) == 0) {
+     return zipfileFree(args);
+ }


// FP: xDelete

@transform_return_xDelete_dot@
expression E;
identifier FP_NAME = xDelete;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xDelete_signature, xDelete_signatures[xDelete_0_enum], sizeof(E.xDelete_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xDelete_signature, xDelete_signatures[xDelete_apndDelete_enum], sizeof(E.xDelete_signature)) == 0) {
+     return apndDelete(args);
+ }
+ else if (memcmp(E.xDelete_signature, xDelete_signatures[xDelete_jsonCacheDeleteGeneric_enum], sizeof(E.xDelete_signature)) == 0) {
+     return jsonCacheDeleteGeneric(args);
+ }
+ else if (memcmp(E.xDelete_signature, xDelete_signatures[xDelete_kvstorageDelete_enum], sizeof(E.xDelete_signature)) == 0) {
+     return kvstorageDelete(args);
+ }
+ else if (memcmp(E.xDelete_signature, xDelete_signatures[xDelete_sqlite3_free_enum], sizeof(E.xDelete_signature)) == 0) {
+     return sqlite3_free(args);
+ }
+ else if (memcmp(E.xDelete_signature, xDelete_signatures[xDelete_vfstraceDelete_enum], sizeof(E.xDelete_signature)) == 0) {
+     return vfstraceDelete(args);
+ }
+ else if (memcmp(E.xDelete_signature, xDelete_signatures[xDelete_unixDelete_enum], sizeof(E.xDelete_signature)) == 0) {
+     return unixDelete(args);
+ }


// FP: xDeleteAux

@transform_return_xDeleteAux_dot@
expression E;
identifier FP_NAME = xDeleteAux;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xDeleteAux_signature, xDeleteAux_signatures[xDeleteAux_jsonCacheDeleteGeneric_enum], sizeof(E.xDeleteAux_signature)) == 0) {
+     return jsonCacheDeleteGeneric(args);
+ }
+ else if (memcmp(E.xDeleteAux_signature, xDeleteAux_signatures[xDeleteAux_sqlite3_free_enum], sizeof(E.xDeleteAux_signature)) == 0) {
+     return sqlite3_free(args);
+ }


// FP: xDepth

@transform_return_xDepth_dot@
expression E;
identifier FP_NAME = xDepth;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xDepth_signature, xDepth_signatures[xDepth_sessionDiffDepth_enum], sizeof(E.xDepth_signature)) == 0) {
+     return sessionDiffDepth(args);
+ }
+ else if (memcmp(E.xDepth_signature, xDepth_signatures[xDepth_sessionPreupdateDepth_enum], sizeof(E.xDepth_signature)) == 0) {
+     return sessionPreupdateDepth(args);
+ }
+ else if (memcmp(E.xDepth_signature, xDepth_signatures[xDepth_sessionStat1Depth_enum], sizeof(E.xDepth_signature)) == 0) {
+     return sessionStat1Depth(args);
+ }


// FP: xDestroy

@transform_return_xDestroy_dot@
expression E;
identifier FP_NAME = xDestroy;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xDestroy_signature, xDestroy_signatures[xDestroy_0_enum], sizeof(E.xDestroy_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xDestroy_signature, xDestroy_signatures[xDestroy_dbpageDisconnect_enum], sizeof(E.xDestroy_signature)) == 0) {
+     return dbpageDisconnect(args);
+ }
+ else if (memcmp(E.xDestroy_signature, xDestroy_signatures[xDestroy_expertDisconnect_enum], sizeof(E.xDestroy_signature)) == 0) {
+     return expertDisconnect(args);
+ }
+ else if (memcmp(E.xDestroy_signature, xDestroy_signatures[xDestroy_fts3DestroyMethod_enum], sizeof(E.xDestroy_signature)) == 0) {
+     return fts3DestroyMethod(args);
+ }
+ else if (memcmp(E.xDestroy_signature, xDestroy_signatures[xDestroy_fts3auxDisconnectMethod_enum], sizeof(E.xDestroy_signature)) == 0) {
+     return fts3auxDisconnectMethod(args);
+ }
+ else if (memcmp(E.xDestroy_signature, xDestroy_signatures[xDestroy_fts3tokDisconnectMethod_enum], sizeof(E.xDestroy_signature)) == 0) {
+     return fts3tokDisconnectMethod(args);
+ }
+ else if (memcmp(E.xDestroy_signature, xDestroy_signatures[xDestroy_hashDestroy_enum], sizeof(E.xDestroy_signature)) == 0) {
+     return hashDestroy(args);
+ }
+ else if (memcmp(E.xDestroy_signature, xDestroy_signatures[xDestroy_pcache1Destroy_enum], sizeof(E.xDestroy_signature)) == 0) {
+     return pcache1Destroy(args);
+ }
+ else if (memcmp(E.xDestroy_signature, xDestroy_signatures[xDestroy_pcachetraceDestroy_enum], sizeof(E.xDestroy_signature)) == 0) {
+     return pcachetraceDestroy(args);
+ }
+ else if (memcmp(E.xDestroy_signature, xDestroy_signatures[xDestroy_porterDestroy_enum], sizeof(E.xDestroy_signature)) == 0) {
+     return porterDestroy(args);
+ }
+ else if (memcmp(E.xDestroy_signature, xDestroy_signatures[xDestroy_rtreeDestroy_enum], sizeof(E.xDestroy_signature)) == 0) {
+     return rtreeDestroy(args);
+ }
+ else if (memcmp(E.xDestroy_signature, xDestroy_signatures[xDestroy_rtreeFreeCallback_enum], sizeof(E.xDestroy_signature)) == 0) {
+     return rtreeFreeCallback(args);
+ }
+ else if (memcmp(E.xDestroy_signature, xDestroy_signatures[xDestroy_simpleDestroy_enum], sizeof(E.xDestroy_signature)) == 0) {
+     return simpleDestroy(args);
+ }
+ else if (memcmp(E.xDestroy_signature, xDestroy_signatures[xDestroy_sqlite3_free_enum], sizeof(E.xDestroy_signature)) == 0) {
+     return sqlite3_free(args);
+ }
+ else if (memcmp(E.xDestroy_signature, xDestroy_signatures[xDestroy_statDisconnect_enum], sizeof(E.xDestroy_signature)) == 0) {
+     return statDisconnect(args);
+ }
+ else if (memcmp(E.xDestroy_signature, xDestroy_signatures[xDestroy_unicodeDestroy_enum], sizeof(E.xDestroy_signature)) == 0) {
+     return unicodeDestroy(args);
+ }
+ else if (memcmp(E.xDestroy_signature, xDestroy_signatures[xDestroy_zipfileDisconnect_enum], sizeof(E.xDestroy_signature)) == 0) {
+     return zipfileDisconnect(args);
+ }


// FP: xDestructor

@transform_return_xDestructor_dot@
expression E;
identifier FP_NAME = xDestructor;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xDestructor_signature, xDestructor_signatures[xDestructor_0_enum], sizeof(E.xDestructor_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xDestructor_signature, xDestructor_signatures[xDestructor_rtreeMatchArgFree_enum], sizeof(E.xDestructor_signature)) == 0) {
+     return rtreeMatchArgFree(args);
+ }
+ else if (memcmp(E.xDestructor_signature, xDestructor_signatures[xDestructor_sqlite3VdbeValueListFree_enum], sizeof(E.xDestructor_signature)) == 0) {
+     return sqlite3VdbeValueListFree(args);
+ }


// FP: xDeviceCharacteristics

@transform_return_xDeviceCharacteristics_dot@
expression E;
identifier FP_NAME = xDeviceCharacteristics;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xDeviceCharacteristics_signature, xDeviceCharacteristics_signatures[xDeviceCharacteristics_0_enum], sizeof(E.xDeviceCharacteristics_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xDeviceCharacteristics_signature, xDeviceCharacteristics_signatures[xDeviceCharacteristics_apndDeviceCharacteristics_enum], sizeof(E.xDeviceCharacteristics_signature)) == 0) {
+     return apndDeviceCharacteristics(args);
+ }
+ else if (memcmp(E.xDeviceCharacteristics_signature, xDeviceCharacteristics_signatures[xDeviceCharacteristics_memdbDeviceCharacteristics_enum], sizeof(E.xDeviceCharacteristics_signature)) == 0) {
+     return memdbDeviceCharacteristics(args);
+ }
+ else if (memcmp(E.xDeviceCharacteristics_signature, xDeviceCharacteristics_signatures[xDeviceCharacteristics_recoverVfsDeviceCharacteristics_enum], sizeof(E.xDeviceCharacteristics_signature)) == 0) {
+     return recoverVfsDeviceCharacteristics(args);
+ }
+ else if (memcmp(E.xDeviceCharacteristics_signature, xDeviceCharacteristics_signatures[xDeviceCharacteristics_vfstraceDeviceCharacteristics_enum], sizeof(E.xDeviceCharacteristics_signature)) == 0) {
+     return vfstraceDeviceCharacteristics(args);
+ }


// FP: xDisconnect

@transform_return_xDisconnect_dot@
expression E;
identifier FP_NAME = xDisconnect;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xDisconnect_signature, xDisconnect_signatures[xDisconnect_bytecodevtabDisconnect_enum], sizeof(E.xDisconnect_signature)) == 0) {
+     return bytecodevtabDisconnect(args);
+ }
+ else if (memcmp(E.xDisconnect_signature, xDisconnect_signatures[xDisconnect_completionDisconnect_enum], sizeof(E.xDisconnect_signature)) == 0) {
+     return completionDisconnect(args);
+ }
+ else if (memcmp(E.xDisconnect_signature, xDisconnect_signatures[xDisconnect_dbdataDisconnect_enum], sizeof(E.xDisconnect_signature)) == 0) {
+     return dbdataDisconnect(args);
+ }
+ else if (memcmp(E.xDisconnect_signature, xDisconnect_signatures[xDisconnect_dbpageDisconnect_enum], sizeof(E.xDisconnect_signature)) == 0) {
+     return dbpageDisconnect(args);
+ }
+ else if (memcmp(E.xDisconnect_signature, xDisconnect_signatures[xDisconnect_expertDisconnect_enum], sizeof(E.xDisconnect_signature)) == 0) {
+     return expertDisconnect(args);
+ }
+ else if (memcmp(E.xDisconnect_signature, xDisconnect_signatures[xDisconnect_fsdirDisconnect_enum], sizeof(E.xDisconnect_signature)) == 0) {
+     return fsdirDisconnect(args);
+ }
+ else if (memcmp(E.xDisconnect_signature, xDisconnect_signatures[xDisconnect_fts3DisconnectMethod_enum], sizeof(E.xDisconnect_signature)) == 0) {
+     return fts3DisconnectMethod(args);
+ }
+ else if (memcmp(E.xDisconnect_signature, xDisconnect_signatures[xDisconnect_fts3auxDisconnectMethod_enum], sizeof(E.xDisconnect_signature)) == 0) {
+     return fts3auxDisconnectMethod(args);
+ }
+ else if (memcmp(E.xDisconnect_signature, xDisconnect_signatures[xDisconnect_fts3tokDisconnectMethod_enum], sizeof(E.xDisconnect_signature)) == 0) {
+     return fts3tokDisconnectMethod(args);
+ }
+ else if (memcmp(E.xDisconnect_signature, xDisconnect_signatures[xDisconnect_jsonEachDisconnect_enum], sizeof(E.xDisconnect_signature)) == 0) {
+     return jsonEachDisconnect(args);
+ }
+ else if (memcmp(E.xDisconnect_signature, xDisconnect_signatures[xDisconnect_pragmaVtabDisconnect_enum], sizeof(E.xDisconnect_signature)) == 0) {
+     return pragmaVtabDisconnect(args);
+ }
+ else if (memcmp(E.xDisconnect_signature, xDisconnect_signatures[xDisconnect_rtreeDisconnect_enum], sizeof(E.xDisconnect_signature)) == 0) {
+     return rtreeDisconnect(args);
+ }
+ else if (memcmp(E.xDisconnect_signature, xDisconnect_signatures[xDisconnect_seriesDisconnect_enum], sizeof(E.xDisconnect_signature)) == 0) {
+     return seriesDisconnect(args);
+ }
+ else if (memcmp(E.xDisconnect_signature, xDisconnect_signatures[xDisconnect_statDisconnect_enum], sizeof(E.xDisconnect_signature)) == 0) {
+     return statDisconnect(args);
+ }
+ else if (memcmp(E.xDisconnect_signature, xDisconnect_signatures[xDisconnect_stmtDisconnect_enum], sizeof(E.xDisconnect_signature)) == 0) {
+     return stmtDisconnect(args);
+ }
+ else if (memcmp(E.xDisconnect_signature, xDisconnect_signatures[xDisconnect_zipfileDisconnect_enum], sizeof(E.xDisconnect_signature)) == 0) {
+     return zipfileDisconnect(args);
+ }


// FP: xDlClose

@transform_return_xDlClose_dot@
expression E;
identifier FP_NAME = xDlClose;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xDlClose_signature, xDlClose_signatures[xDlClose_0_enum], sizeof(E.xDlClose_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xDlClose_signature, xDlClose_signatures[xDlClose_apndDlClose_enum], sizeof(E.xDlClose_signature)) == 0) {
+     return apndDlClose(args);
+ }
+ else if (memcmp(E.xDlClose_signature, xDlClose_signatures[xDlClose_memdbDlClose_enum], sizeof(E.xDlClose_signature)) == 0) {
+     return memdbDlClose(args);
+ }
+ else if (memcmp(E.xDlClose_signature, xDlClose_signatures[xDlClose_unixDlClose_enum], sizeof(E.xDlClose_signature)) == 0) {
+     return unixDlClose(args);
+ }


// FP: xDlError

@transform_return_xDlError_dot@
expression E;
identifier FP_NAME = xDlError;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xDlError_signature, xDlError_signatures[xDlError_0_enum], sizeof(E.xDlError_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xDlError_signature, xDlError_signatures[xDlError_apndDlError_enum], sizeof(E.xDlError_signature)) == 0) {
+     return apndDlError(args);
+ }
+ else if (memcmp(E.xDlError_signature, xDlError_signatures[xDlError_memdbDlError_enum], sizeof(E.xDlError_signature)) == 0) {
+     return memdbDlError(args);
+ }
+ else if (memcmp(E.xDlError_signature, xDlError_signatures[xDlError_unixDlError_enum], sizeof(E.xDlError_signature)) == 0) {
+     return unixDlError(args);
+ }


// FP: xDlOpen

@transform_return_xDlOpen_dot@
expression E;
identifier FP_NAME = xDlOpen;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xDlOpen_signature, xDlOpen_signatures[xDlOpen_apndDlOpen_enum], sizeof(E.xDlOpen_signature)) == 0) {
+     return apndDlOpen(args);
+ }
+ else if (memcmp(E.xDlOpen_signature, xDlOpen_signatures[xDlOpen_memdbDlOpen_enum], sizeof(E.xDlOpen_signature)) == 0) {
+     return memdbDlOpen(args);
+ }
+ else if (memcmp(E.xDlOpen_signature, xDlOpen_signatures[xDlOpen_unixDlOpen_enum], sizeof(E.xDlOpen_signature)) == 0) {
+     return unixDlOpen(args);
+ }


// FP: xDlSym

@transform_return_xDlSym_dot@
expression E;
identifier FP_NAME = xDlSym;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xDlSym_signature, xDlSym_signatures[xDlSym_0_enum], sizeof(E.xDlSym_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xDlSym_signature, xDlSym_signatures[xDlSym_apndDlSym_enum], sizeof(E.xDlSym_signature)) == 0) {
+     return apndDlSym(args);
+ }
+ else if (memcmp(E.xDlSym_signature, xDlSym_signatures[xDlSym_memdbDlSym_enum], sizeof(E.xDlSym_signature)) == 0) {
+     return memdbDlSym(args);
+ }
+ else if (memcmp(E.xDlSym_signature, xDlSym_signatures[xDlSym_rbuVfsDlSym_enum], sizeof(E.xDlSym_signature)) == 0) {
+     return rbuVfsDlSym(args);
+ }
+ else if (memcmp(E.xDlSym_signature, xDlSym_signatures[xDlSym_winDlSym_enum], sizeof(E.xDlSym_signature)) == 0) {
+     return winDlSym(args);
+ }
+ else if (memcmp(E.xDlSym_signature, xDlSym_signatures[xDlSym_unixDlSym_enum], sizeof(E.xDlSym_signature)) == 0) {
+     return unixDlSym(args);
+ }


// FP: xEof

@transform_return_xEof_dot@
expression E;
identifier FP_NAME = xEof;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xEof_signature, xEof_signatures[xEof_bytecodevtabEof_enum], sizeof(E.xEof_signature)) == 0) {
+     return bytecodevtabEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_completionEof_enum], sizeof(E.xEof_signature)) == 0) {
+     return completionEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_dbdataEof_enum], sizeof(E.xEof_signature)) == 0) {
+     return dbdataEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_dbpageEof_enum], sizeof(E.xEof_signature)) == 0) {
+     return dbpageEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_expertEof_enum], sizeof(E.xEof_signature)) == 0) {
+     return expertEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_fsdirEof_enum], sizeof(E.xEof_signature)) == 0) {
+     return fsdirEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_fts3EofMethod_enum], sizeof(E.xEof_signature)) == 0) {
+     return fts3EofMethod(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_fts3auxEofMethod_enum], sizeof(E.xEof_signature)) == 0) {
+     return fts3auxEofMethod(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_fts3tokEofMethod_enum], sizeof(E.xEof_signature)) == 0) {
+     return fts3tokEofMethod(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_jsonEachEof_enum], sizeof(E.xEof_signature)) == 0) {
+     return jsonEachEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_pragmaVtabEof_enum], sizeof(E.xEof_signature)) == 0) {
+     return pragmaVtabEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_rtreeEof_enum], sizeof(E.xEof_signature)) == 0) {
+     return rtreeEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_seriesEof_enum], sizeof(E.xEof_signature)) == 0) {
+     return seriesEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_statEof_enum], sizeof(E.xEof_signature)) == 0) {
+     return statEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_stmtEof_enum], sizeof(E.xEof_signature)) == 0) {
+     return stmtEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_zipfileEof_enum], sizeof(E.xEof_signature)) == 0) {
+     return zipfileEof(args);
+ }


// FP: xExprCallback

@transform_return_xExprCallback_dot@
expression E;
identifier FP_NAME = xExprCallback;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_agginfoPersistExprCb_enum], sizeof(E.xExprCallback_signature)) == 0) {
+     return agginfoPersistExprCb(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_aggregateIdxEprRefToColCallback_enum], sizeof(E.xExprCallback_signature)) == 0) {
+     return aggregateIdxEprRefToColCallback(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_analyzeAggregate_enum], sizeof(E.xExprCallback_signature)) == 0) {
+     return analyzeAggregate(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_checkConstraintExprNode_enum], sizeof(E.xExprCallback_signature)) == 0) {
+     return checkConstraintExprNode(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_codeCursorHintCheckExpr_enum], sizeof(E.xExprCallback_signature)) == 0) {
+     return codeCursorHintCheckExpr(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_codeCursorHintFixExpr_enum], sizeof(E.xExprCallback_signature)) == 0) {
+     return codeCursorHintFixExpr(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_codeCursorHintIsOrFunction_enum], sizeof(E.xExprCallback_signature)) == 0) {
+     return codeCursorHintIsOrFunction(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_disallowAggregatesInOrderByCb_enum], sizeof(E.xExprCallback_signature)) == 0) {
+     return disallowAggregatesInOrderByCb(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprColumnFlagUnion_enum], sizeof(E.xExprCallback_signature)) == 0) {
+     return exprColumnFlagUnion(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprIdxCover_enum], sizeof(E.xExprCallback_signature)) == 0) {
+     return exprIdxCover(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprNodeCanReturnSubtype_enum], sizeof(E.xExprCallback_signature)) == 0) {
+     return exprNodeCanReturnSubtype(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprNodeIsConstant_enum], sizeof(E.xExprCallback_signature)) == 0) {
+     return exprNodeIsConstant(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprNodeIsConstantOrGroupBy_enum], sizeof(E.xExprCallback_signature)) == 0) {
+     return exprNodeIsConstantOrGroupBy(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprNodeIsDeterministic_enum], sizeof(E.xExprCallback_signature)) == 0) {
+     return exprNodeIsDeterministic(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprRefToSrcList_enum], sizeof(E.xExprCallback_signature)) == 0) {
+     return exprRefToSrcList(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_fixExprCb_enum], sizeof(E.xExprCallback_signature)) == 0) {
+     return fixExprCb(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_gatherSelectWindowsCallback_enum], sizeof(E.xExprCallback_signature)) == 0) {
+     return gatherSelectWindowsCallback(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_havingToWhereExprCb_enum], sizeof(E.xExprCallback_signature)) == 0) {
+     return havingToWhereExprCb(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_impliesNotNullRow_enum], sizeof(E.xExprCallback_signature)) == 0) {
+     return impliesNotNullRow(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_incrAggDepth_enum], sizeof(E.xExprCallback_signature)) == 0) {
+     return incrAggDepth(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_markImmutableExprStep_enum], sizeof(E.xExprCallback_signature)) == 0) {
+     return markImmutableExprStep(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_propagateConstantExprRewrite_enum], sizeof(E.xExprCallback_signature)) == 0) {
+     return propagateConstantExprRewrite(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_recomputeColumnsUsedExpr_enum], sizeof(E.xExprCallback_signature)) == 0) {
+     return recomputeColumnsUsedExpr(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_renameColumnExprCb_enum], sizeof(E.xExprCallback_signature)) == 0) {
+     return renameColumnExprCb(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_renameQuotefixExprCb_enum], sizeof(E.xExprCallback_signature)) == 0) {
+     return renameQuotefixExprCb(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_renameTableExprCb_enum], sizeof(E.xExprCallback_signature)) == 0) {
+     return renameTableExprCb(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_renameUnmapExprCb_enum], sizeof(E.xExprCallback_signature)) == 0) {
+     return renameUnmapExprCb(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_renumberCursorsCb_enum], sizeof(E.xExprCallback_signature)) == 0) {
+     return renumberCursorsCb(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_resolveExprStep_enum], sizeof(E.xExprCallback_signature)) == 0) {
+     return resolveExprStep(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_resolveRemoveWindowsCb_enum], sizeof(E.xExprCallback_signature)) == 0) {
+     return resolveRemoveWindowsCb(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_selectCheckOnClausesExpr_enum], sizeof(E.xExprCallback_signature)) == 0) {
+     return selectCheckOnClausesExpr(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_selectWindowRewriteExprCb_enum], sizeof(E.xExprCallback_signature)) == 0) {
+     return selectWindowRewriteExprCb(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_sqlite3CursorRangeHintExprCheck_enum], sizeof(E.xExprCallback_signature)) == 0) {
+     return sqlite3CursorRangeHintExprCheck(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_sqlite3ExprWalkNoop_enum], sizeof(E.xExprCallback_signature)) == 0) {
+     return sqlite3ExprWalkNoop(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_sqlite3ReturningSubqueryVarSelect_enum], sizeof(E.xExprCallback_signature)) == 0) {
+     return sqlite3ReturningSubqueryVarSelect(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_sqlite3WindowExtraAggFuncDepth_enum], sizeof(E.xExprCallback_signature)) == 0) {
+     return sqlite3WindowExtraAggFuncDepth(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_whereIsCoveringIndexWalkCallback_enum], sizeof(E.xExprCallback_signature)) == 0) {
+     return whereIsCoveringIndexWalkCallback(args);
+ }


// FP: xFetch

@transform_return_xFetch_dot@
expression E;
identifier FP_NAME = xFetch;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xFetch_signature, xFetch_signatures[xFetch_0_enum], sizeof(E.xFetch_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xFetch_signature, xFetch_signatures[xFetch_apndFetch_enum], sizeof(E.xFetch_signature)) == 0) {
+     return apndFetch(args);
+ }
+ else if (memcmp(E.xFetch_signature, xFetch_signatures[xFetch_memdbFetch_enum], sizeof(E.xFetch_signature)) == 0) {
+     return memdbFetch(args);
+ }
+ else if (memcmp(E.xFetch_signature, xFetch_signatures[xFetch_pcache1Fetch_enum], sizeof(E.xFetch_signature)) == 0) {
+     return pcache1Fetch(args);
+ }
+ else if (memcmp(E.xFetch_signature, xFetch_signatures[xFetch_pcachetraceFetch_enum], sizeof(E.xFetch_signature)) == 0) {
+     return pcachetraceFetch(args);
+ }
+ else if (memcmp(E.xFetch_signature, xFetch_signatures[xFetch_recoverVfsFetch_enum], sizeof(E.xFetch_signature)) == 0) {
+     return recoverVfsFetch(args);
+ }


// FP: xFileControl

@transform_return_xFileControl_dot@
expression E;
identifier FP_NAME = xFileControl;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xFileControl_signature, xFileControl_signatures[xFileControl_0_enum], sizeof(E.xFileControl_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xFileControl_signature, xFileControl_signatures[xFileControl_apndFileControl_enum], sizeof(E.xFileControl_signature)) == 0) {
+     return apndFileControl(args);
+ }
+ else if (memcmp(E.xFileControl_signature, xFileControl_signatures[xFileControl_memdbFileControl_enum], sizeof(E.xFileControl_signature)) == 0) {
+     return memdbFileControl(args);
+ }
+ else if (memcmp(E.xFileControl_signature, xFileControl_signatures[xFileControl_recoverVfsFileControl_enum], sizeof(E.xFileControl_signature)) == 0) {
+     return recoverVfsFileControl(args);
+ }
+ else if (memcmp(E.xFileControl_signature, xFileControl_signatures[xFileControl_vfstraceFileControl_enum], sizeof(E.xFileControl_signature)) == 0) {
+     return vfstraceFileControl(args);
+ }


// FP: xFileSize

@transform_return_xFileSize_dot@
expression E;
identifier FP_NAME = xFileSize;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xFileSize_signature, xFileSize_signatures[xFileSize_apndFileSize_enum], sizeof(E.xFileSize_signature)) == 0) {
+     return apndFileSize(args);
+ }
+ else if (memcmp(E.xFileSize_signature, xFileSize_signatures[xFileSize_memdbFileSize_enum], sizeof(E.xFileSize_signature)) == 0) {
+     return memdbFileSize(args);
+ }
+ else if (memcmp(E.xFileSize_signature, xFileSize_signatures[xFileSize_memjrnlFileSize_enum], sizeof(E.xFileSize_signature)) == 0) {
+     return memjrnlFileSize(args);
+ }
+ else if (memcmp(E.xFileSize_signature, xFileSize_signatures[xFileSize_recoverVfsFileSize_enum], sizeof(E.xFileSize_signature)) == 0) {
+     return recoverVfsFileSize(args);
+ }
+ else if (memcmp(E.xFileSize_signature, xFileSize_signatures[xFileSize_vfstraceFileSize_enum], sizeof(E.xFileSize_signature)) == 0) {
+     return vfstraceFileSize(args);
+ }


// FP: xFilter

@transform_return_xFilter_dot@
expression E;
identifier FP_NAME = xFilter;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_bytecodevtabFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+     return bytecodevtabFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_completionFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+     return completionFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_dbdataFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+     return dbdataFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_dbpageFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+     return dbpageFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_expertFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+     return expertFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_fsdirFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+     return fsdirFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_fts3FilterMethod_enum], sizeof(E.xFilter_signature)) == 0) {
+     return fts3FilterMethod(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_fts3auxFilterMethod_enum], sizeof(E.xFilter_signature)) == 0) {
+     return fts3auxFilterMethod(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_fts3tokFilterMethod_enum], sizeof(E.xFilter_signature)) == 0) {
+     return fts3tokFilterMethod(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_geopolyFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+     return geopolyFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_jsonEachFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+     return jsonEachFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_pragmaVtabFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+     return pragmaVtabFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_rtreeFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+     return rtreeFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_seriesFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+     return seriesFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_statFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+     return statFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_stmtFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+     return stmtFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_zipfileFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+     return zipfileFilter(args);
+ }


// FP: xFinalize

@transform_return_xFinalize_dot@
expression E;
identifier FP_NAME = xFinalize;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xFinalize_signature, xFinalize_signatures[xFinalize_0_enum], sizeof(E.xFinalize_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xFinalize_signature, xFinalize_signatures[xFinalize_decimalSumFinalize_enum], sizeof(E.xFinalize_signature)) == 0) {
+     return decimalSumFinalize(args);
+ }
+ else if (memcmp(E.xFinalize_signature, xFinalize_signatures[xFinalize_dummyUDFvalue_enum], sizeof(E.xFinalize_signature)) == 0) {
+     return dummyUDFvalue(args);
+ }
+ else if (memcmp(E.xFinalize_signature, xFinalize_signatures[xFinalize_percentFinal_enum], sizeof(E.xFinalize_signature)) == 0) {
+     return percentFinal(args);
+ }
+ else if (memcmp(E.xFinalize_signature, xFinalize_signatures[xFinalize_sha3AggFinal_enum], sizeof(E.xFinalize_signature)) == 0) {
+     return sha3AggFinal(args);
+ }
+ else if (memcmp(E.xFinalize_signature, xFinalize_signatures[xFinalize_zipfileFinal_enum], sizeof(E.xFinalize_signature)) == 0) {
+     return zipfileFinal(args);
+ }


// FP: xFindFunction

@transform_return_xFindFunction_dot@
expression E;
identifier FP_NAME = xFindFunction;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xFindFunction_signature, xFindFunction_signatures[xFindFunction_0_enum], sizeof(E.xFindFunction_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xFindFunction_signature, xFindFunction_signatures[xFindFunction_fts3FindFunctionMethod_enum], sizeof(E.xFindFunction_signature)) == 0) {
+     return fts3FindFunctionMethod(args);
+ }
+ else if (memcmp(E.xFindFunction_signature, xFindFunction_signatures[xFindFunction_zipfileFindFunction_enum], sizeof(E.xFindFunction_signature)) == 0) {
+     return zipfileFindFunction(args);
+ }


// FP: xFree

@transform_return_xFree_dot@
expression E;
identifier FP_NAME = xFree;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xFree_signature, xFree_signatures[xFree_memtraceFree_enum], sizeof(E.xFree_signature)) == 0) {
+     return memtraceFree(args);
+ }
+ else if (memcmp(E.xFree_signature, xFree_signatures[xFree_sqlite3MemFree_enum], sizeof(E.xFree_signature)) == 0) {
+     return sqlite3MemFree(args);
+ }


// FP: xFreeSchema

@transform_return_xFreeSchema_dot@
expression E;
identifier FP_NAME = xFreeSchema;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xFreeSchema_signature, xFreeSchema_signatures[xFreeSchema_0_enum], sizeof(E.xFreeSchema_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xFreeSchema_signature, xFreeSchema_signatures[xFreeSchema_sqlite3RCStrUnref_enum], sizeof(E.xFreeSchema_signature)) == 0) {
+     return sqlite3RCStrUnref(args);
+ }
+ else if (memcmp(E.xFreeSchema_signature, xFreeSchema_signatures[xFreeSchema_sqlite3SchemaClear_enum], sizeof(E.xFreeSchema_signature)) == 0) {
+     return sqlite3SchemaClear(args);
+ }


// FP: xFullPathname

@transform_return_xFullPathname_dot@
expression E;
identifier FP_NAME = xFullPathname;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xFullPathname_signature, xFullPathname_signatures[xFullPathname_apndFullPathname_enum], sizeof(E.xFullPathname_signature)) == 0) {
+     return apndFullPathname(args);
+ }
+ else if (memcmp(E.xFullPathname_signature, xFullPathname_signatures[xFullPathname_memdbFullPathname_enum], sizeof(E.xFullPathname_signature)) == 0) {
+     return memdbFullPathname(args);
+ }
+ else if (memcmp(E.xFullPathname_signature, xFullPathname_signatures[xFullPathname_vfstraceFullPathname_enum], sizeof(E.xFullPathname_signature)) == 0) {
+     return vfstraceFullPathname(args);
+ }
+ else if (memcmp(E.xFullPathname_signature, xFullPathname_signatures[xFullPathname_unixFullPathname_enum], sizeof(E.xFullPathname_signature)) == 0) {
+     return unixFullPathname(args);
+ }


// FP: xFunc

@transform_return_xFunc_dot@
expression E;
identifier FP_NAME = xFunc;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_0_enum], sizeof(E.xFunc_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_base64_enum], sizeof(E.xFunc_signature)) == 0) {
+     return base64(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_base85_enum], sizeof(E.xFunc_signature)) == 0) {
+     return base85(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_dummyUDF_enum], sizeof(E.xFunc_signature)) == 0) {
+     return dummyUDF(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_editFunc_enum], sizeof(E.xFunc_signature)) == 0) {
+     return editFunc(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_fts3AllocateMSI_enum], sizeof(E.xFunc_signature)) == 0) {
+     return fts3AllocateMSI(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_fts3ExprGlobalHitsCb_enum], sizeof(E.xFunc_signature)) == 0) {
+     return fts3ExprGlobalHitsCb(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_fts3ExprLoadDoclistsCb_enum], sizeof(E.xFunc_signature)) == 0) {
+     return fts3ExprLoadDoclistsCb(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_fts3ExprLocalHitsCb_enum], sizeof(E.xFunc_signature)) == 0) {
+     return fts3ExprLocalHitsCb(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_fts3ExprPhraseCountCb_enum], sizeof(E.xFunc_signature)) == 0) {
+     return fts3ExprPhraseCountCb(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_fts3ExprRestartIfCb_enum], sizeof(E.xFunc_signature)) == 0) {
+     return fts3ExprRestartIfCb(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_fts3ExprTermOffsetInit_enum], sizeof(E.xFunc_signature)) == 0) {
+     return fts3ExprTermOffsetInit(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_fts3ExprTest_enum], sizeof(E.xFunc_signature)) == 0) {
+     return fts3ExprTest(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_fts3ExprTestRebalance_enum], sizeof(E.xFunc_signature)) == 0) {
+     return fts3ExprTestRebalance(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_fts3MatchinfoLcsCb_enum], sizeof(E.xFunc_signature)) == 0) {
+     return fts3MatchinfoLcsCb(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_fts3SnippetFindPositions_enum], sizeof(E.xFunc_signature)) == 0) {
+     return fts3SnippetFindPositions(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_fts3TokenizerFunc_enum], sizeof(E.xFunc_signature)) == 0) {
+     return fts3TokenizerFunc(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_geomCallback_enum], sizeof(E.xFunc_signature)) == 0) {
+     return geomCallback(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_idxRemFunc_enum], sizeof(E.xFunc_signature)) == 0) {
+     return idxRemFunc(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_idxSampleFunc_enum], sizeof(E.xFunc_signature)) == 0) {
+     return idxSampleFunc(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_intTestFunc_enum], sizeof(E.xFunc_signature)) == 0) {
+     return intTestFunc(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_intckParseCreateIndexFunc_enum], sizeof(E.xFunc_signature)) == 0) {
+     return intckParseCreateIndexFunc(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_is_base85_enum], sizeof(E.xFunc_signature)) == 0) {
+     return is_base85(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_lsModeFunc_enum], sizeof(E.xFunc_signature)) == 0) {
+     return lsModeFunc(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_rbuFossilDeltaFunc_enum], sizeof(E.xFunc_signature)) == 0) {
+     return rbuFossilDeltaFunc(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_rbuIndexCntFunc_enum], sizeof(E.xFunc_signature)) == 0) {
+     return rbuIndexCntFunc(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_rbuTargetNameFunc_enum], sizeof(E.xFunc_signature)) == 0) {
+     return rbuTargetNameFunc(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_rbuTmpInsertFunc_enum], sizeof(E.xFunc_signature)) == 0) {
+     return rbuTmpInsertFunc(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_re_bytecode_func_enum], sizeof(E.xFunc_signature)) == 0) {
+     return re_bytecode_func(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_re_sql_func_enum], sizeof(E.xFunc_signature)) == 0) {
+     return re_sql_func(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_readfileFunc_enum], sizeof(E.xFunc_signature)) == 0) {
+     return readfileFunc(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_rtreecheck_enum], sizeof(E.xFunc_signature)) == 0) {
+     return rtreecheck(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_rtreedepth_enum], sizeof(E.xFunc_signature)) == 0) {
+     return rtreedepth(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_rtreenode_enum], sizeof(E.xFunc_signature)) == 0) {
+     return rtreenode(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_sha1Func_enum], sizeof(E.xFunc_signature)) == 0) {
+     return sha1Func(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_sha1QueryFunc_enum], sizeof(E.xFunc_signature)) == 0) {
+     return sha1QueryFunc(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_sha3Func_enum], sizeof(E.xFunc_signature)) == 0) {
+     return sha3Func(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_sha3QueryFunc_enum], sizeof(E.xFunc_signature)) == 0) {
+     return sha3QueryFunc(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_shellAddSchemaName_enum], sizeof(E.xFunc_signature)) == 0) {
+     return shellAddSchemaName(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_shellDtostr_enum], sizeof(E.xFunc_signature)) == 0) {
+     return shellDtostr(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_shellFkeyCollateClause_enum], sizeof(E.xFunc_signature)) == 0) {
+     return shellFkeyCollateClause(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_shellModuleSchema_enum], sizeof(E.xFunc_signature)) == 0) {
+     return shellModuleSchema(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_shellPutsFunc_enum], sizeof(E.xFunc_signature)) == 0) {
+     return shellPutsFunc(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_shellStrtod_enum], sizeof(E.xFunc_signature)) == 0) {
+     return shellStrtod(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_shellUSleepFunc_enum], sizeof(E.xFunc_signature)) == 0) {
+     return shellUSleepFunc(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_sqlarCompressFunc_enum], sizeof(E.xFunc_signature)) == 0) {
+     return sqlarCompressFunc(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_sqlarUncompressFunc_enum], sizeof(E.xFunc_signature)) == 0) {
+     return sqlarUncompressFunc(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_sqlite3InvalidFunction_enum], sizeof(E.xFunc_signature)) == 0) {
+     return sqlite3InvalidFunction(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_stmtrandFunc_enum], sizeof(E.xFunc_signature)) == 0) {
+     return stmtrandFunc(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_testFunc_enum], sizeof(E.xFunc_signature)) == 0) {
+     return testFunc(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_writefileFunc_enum], sizeof(E.xFunc_signature)) == 0) {
+     return writefileFunc(args);
+ }


// FP: xGeom

@transform_return_xGeom_dot@
expression E;
identifier FP_NAME = xGeom;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ return 0;

// FP: xGet

@transform_return_xGet_dot@
expression E;
identifier FP_NAME = xGet;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xGet_signature, xGet_signatures[xGet_getPageError_enum], sizeof(E.xGet_signature)) == 0) {
+     return getPageError(args);
+ }
+ else if (memcmp(E.xGet_signature, xGet_signatures[xGet_getPageMMap_enum], sizeof(E.xGet_signature)) == 0) {
+     return getPageMMap(args);
+ }
+ else if (memcmp(E.xGet_signature, xGet_signatures[xGet_getPageNormal_enum], sizeof(E.xGet_signature)) == 0) {
+     return getPageNormal(args);
+ }


// FP: xGetLastError

@transform_return_xGetLastError_dot@
expression E;
identifier FP_NAME = xGetLastError;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xGetLastError_signature, xGetLastError_signatures[xGetLastError_0_enum], sizeof(E.xGetLastError_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xGetLastError_signature, xGetLastError_signatures[xGetLastError_apndGetLastError_enum], sizeof(E.xGetLastError_signature)) == 0) {
+     return apndGetLastError(args);
+ }
+ else if (memcmp(E.xGetLastError_signature, xGetLastError_signatures[xGetLastError_memdbGetLastError_enum], sizeof(E.xGetLastError_signature)) == 0) {
+     return memdbGetLastError(args);
+ }
+ else if (memcmp(E.xGetLastError_signature, xGetLastError_signatures[xGetLastError_unixGetLastError_enum], sizeof(E.xGetLastError_signature)) == 0) {
+     return unixGetLastError(args);
+ }


// FP: xGetSystemCall

@transform_return_xGetSystemCall_dot@
expression E;
identifier FP_NAME = xGetSystemCall;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xGetSystemCall_signature, xGetSystemCall_signatures[xGetSystemCall_0_enum], sizeof(E.xGetSystemCall_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xGetSystemCall_signature, xGetSystemCall_signatures[xGetSystemCall_apndGetSystemCall_enum], sizeof(E.xGetSystemCall_signature)) == 0) {
+     return apndGetSystemCall(args);
+ }
+ else if (memcmp(E.xGetSystemCall_signature, xGetSystemCall_signatures[xGetSystemCall_unixGetSystemCall_enum], sizeof(E.xGetSystemCall_signature)) == 0) {
+     return unixGetSystemCall(args);
+ }


// FP: xInit

@transform_return_xInit_dot@
expression E;
identifier FP_NAME = xInit;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xInit_signature, xInit_signatures[xInit_memtraceInit_enum], sizeof(E.xInit_signature)) == 0) {
+     return memtraceInit(args);
+ }
+ else if (memcmp(E.xInit_signature, xInit_signatures[xInit_pcache1Init_enum], sizeof(E.xInit_signature)) == 0) {
+     return pcache1Init(args);
+ }
+ else if (memcmp(E.xInit_signature, xInit_signatures[xInit_pcachetraceInit_enum], sizeof(E.xInit_signature)) == 0) {
+     return pcachetraceInit(args);
+ }
+ else if (memcmp(E.xInit_signature, xInit_signatures[xInit_sqlite3MemInit_enum], sizeof(E.xInit_signature)) == 0) {
+     return sqlite3MemInit(args);
+ }


// FP: xInput

@transform_return_xInput_dot@
expression E;
identifier FP_NAME = xInput;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ return 0;

// FP: xIntegrity

@transform_return_xIntegrity_dot@
expression E;
identifier FP_NAME = xIntegrity;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xIntegrity_signature, xIntegrity_signatures[xIntegrity_0_enum], sizeof(E.xIntegrity_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xIntegrity_signature, xIntegrity_signatures[xIntegrity_fts3IntegrityMethod_enum], sizeof(E.xIntegrity_signature)) == 0) {
+     return fts3IntegrityMethod(args);
+ }
+ else if (memcmp(E.xIntegrity_signature, xIntegrity_signatures[xIntegrity_rtreeIntegrity_enum], sizeof(E.xIntegrity_signature)) == 0) {
+     return rtreeIntegrity(args);
+ }


// FP: xInverse

@transform_return_xInverse_dot@
expression E;
identifier FP_NAME = xInverse;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xInverse_signature, xInverse_signatures[xInverse_0_enum], sizeof(E.xInverse_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xInverse_signature, xInverse_signatures[xInverse_decimalSumInverse_enum], sizeof(E.xInverse_signature)) == 0) {
+     return decimalSumInverse(args);
+ }
+ else if (memcmp(E.xInverse_signature, xInverse_signatures[xInverse_percentInverse_enum], sizeof(E.xInverse_signature)) == 0) {
+     return percentInverse(args);
+ }


// FP: xLanguageid

@transform_return_xLanguageid_dot@
expression E;
identifier FP_NAME = xLanguageid;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ return 0;

// FP: xLock

@transform_return_xLock_dot@
expression E;
identifier FP_NAME = xLock;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xLock_signature, xLock_signatures[xLock_0_enum], sizeof(E.xLock_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xLock_signature, xLock_signatures[xLock_apndLock_enum], sizeof(E.xLock_signature)) == 0) {
+     return apndLock(args);
+ }
+ else if (memcmp(E.xLock_signature, xLock_signatures[xLock_memdbLock_enum], sizeof(E.xLock_signature)) == 0) {
+     return memdbLock(args);
+ }
+ else if (memcmp(E.xLock_signature, xLock_signatures[xLock_recoverVfsLock_enum], sizeof(E.xLock_signature)) == 0) {
+     return recoverVfsLock(args);
+ }
+ else if (memcmp(E.xLock_signature, xLock_signatures[xLock_vfstraceLock_enum], sizeof(E.xLock_signature)) == 0) {
+     return vfstraceLock(args);
+ }


// FP: xLog

@transform_return_xLog_dot@
expression E;
identifier FP_NAME = xLog;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ return 0;

// FP: xMalloc

@transform_return_xMalloc_dot@
expression E;
identifier FP_NAME = xMalloc;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xMalloc_signature, xMalloc_signatures[xMalloc_memtraceMalloc_enum], sizeof(E.xMalloc_signature)) == 0) {
+     return memtraceMalloc(args);
+ }
+ else if (memcmp(E.xMalloc_signature, xMalloc_signatures[xMalloc_sqlite3MemMalloc_enum], sizeof(E.xMalloc_signature)) == 0) {
+     return sqlite3MemMalloc(args);
+ }


// FP: xMutexAlloc

@transform_return_xMutexAlloc_dot@
expression E;
identifier FP_NAME = xMutexAlloc;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_checkMutexAlloc_enum], sizeof(E.xMutexAlloc_signature)) == 0) {
+     return checkMutexAlloc(args);
+ }
+ else if (memcmp(E.xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_debugMutexAlloc_enum], sizeof(E.xMutexAlloc_signature)) == 0) {
+     return debugMutexAlloc(args);
+ }
+ else if (memcmp(E.xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_noopMutexAlloc_enum], sizeof(E.xMutexAlloc_signature)) == 0) {
+     return noopMutexAlloc(args);
+ }
+ else if (memcmp(E.xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_pthreadMutexAlloc_enum], sizeof(E.xMutexAlloc_signature)) == 0) {
+     return pthreadMutexAlloc(args);
+ }
+ else if (memcmp(E.xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_winMutexAlloc_enum], sizeof(E.xMutexAlloc_signature)) == 0) {
+     return winMutexAlloc(args);
+ }


// FP: xMutexEnd

@transform_return_xMutexEnd_dot@
expression E;
identifier FP_NAME = xMutexEnd;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_checkMutexEnd_enum], sizeof(E.xMutexEnd_signature)) == 0) {
+     return checkMutexEnd(args);
+ }
+ else if (memcmp(E.xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_debugMutexEnd_enum], sizeof(E.xMutexEnd_signature)) == 0) {
+     return debugMutexEnd(args);
+ }
+ else if (memcmp(E.xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_noopMutexEnd_enum], sizeof(E.xMutexEnd_signature)) == 0) {
+     return noopMutexEnd(args);
+ }
+ else if (memcmp(E.xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_pthreadMutexEnd_enum], sizeof(E.xMutexEnd_signature)) == 0) {
+     return pthreadMutexEnd(args);
+ }
+ else if (memcmp(E.xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_winMutexEnd_enum], sizeof(E.xMutexEnd_signature)) == 0) {
+     return winMutexEnd(args);
+ }


// FP: xMutexEnter

@transform_return_xMutexEnter_dot@
expression E;
identifier FP_NAME = xMutexEnter;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_checkMutexEnter_enum], sizeof(E.xMutexEnter_signature)) == 0) {
+     return checkMutexEnter(args);
+ }
+ else if (memcmp(E.xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_debugMutexEnter_enum], sizeof(E.xMutexEnter_signature)) == 0) {
+     return debugMutexEnter(args);
+ }
+ else if (memcmp(E.xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_noopMutexEnter_enum], sizeof(E.xMutexEnter_signature)) == 0) {
+     return noopMutexEnter(args);
+ }
+ else if (memcmp(E.xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_pthreadMutexEnter_enum], sizeof(E.xMutexEnter_signature)) == 0) {
+     return pthreadMutexEnter(args);
+ }
+ else if (memcmp(E.xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_winMutexEnter_enum], sizeof(E.xMutexEnter_signature)) == 0) {
+     return winMutexEnter(args);
+ }


// FP: xMutexFree

@transform_return_xMutexFree_dot@
expression E;
identifier FP_NAME = xMutexFree;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xMutexFree_signature, xMutexFree_signatures[xMutexFree_checkMutexFree_enum], sizeof(E.xMutexFree_signature)) == 0) {
+     return checkMutexFree(args);
+ }
+ else if (memcmp(E.xMutexFree_signature, xMutexFree_signatures[xMutexFree_debugMutexFree_enum], sizeof(E.xMutexFree_signature)) == 0) {
+     return debugMutexFree(args);
+ }
+ else if (memcmp(E.xMutexFree_signature, xMutexFree_signatures[xMutexFree_noopMutexFree_enum], sizeof(E.xMutexFree_signature)) == 0) {
+     return noopMutexFree(args);
+ }
+ else if (memcmp(E.xMutexFree_signature, xMutexFree_signatures[xMutexFree_pthreadMutexFree_enum], sizeof(E.xMutexFree_signature)) == 0) {
+     return pthreadMutexFree(args);
+ }
+ else if (memcmp(E.xMutexFree_signature, xMutexFree_signatures[xMutexFree_winMutexFree_enum], sizeof(E.xMutexFree_signature)) == 0) {
+     return winMutexFree(args);
+ }


// FP: xMutexHeld

@transform_return_xMutexHeld_dot@
expression E;
identifier FP_NAME = xMutexHeld;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xMutexHeld_signature, xMutexHeld_signatures[xMutexHeld_0_enum], sizeof(E.xMutexHeld_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xMutexHeld_signature, xMutexHeld_signatures[xMutexHeld_debugMutexHeld_enum], sizeof(E.xMutexHeld_signature)) == 0) {
+     return debugMutexHeld(args);
+ }


// FP: xMutexInit

@transform_return_xMutexInit_dot@
expression E;
identifier FP_NAME = xMutexInit;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xMutexInit_signature, xMutexInit_signatures[xMutexInit_checkMutexInit_enum], sizeof(E.xMutexInit_signature)) == 0) {
+     return checkMutexInit(args);
+ }
+ else if (memcmp(E.xMutexInit_signature, xMutexInit_signatures[xMutexInit_debugMutexInit_enum], sizeof(E.xMutexInit_signature)) == 0) {
+     return debugMutexInit(args);
+ }
+ else if (memcmp(E.xMutexInit_signature, xMutexInit_signatures[xMutexInit_noopMutexInit_enum], sizeof(E.xMutexInit_signature)) == 0) {
+     return noopMutexInit(args);
+ }
+ else if (memcmp(E.xMutexInit_signature, xMutexInit_signatures[xMutexInit_pthreadMutexInit_enum], sizeof(E.xMutexInit_signature)) == 0) {
+     return pthreadMutexInit(args);
+ }
+ else if (memcmp(E.xMutexInit_signature, xMutexInit_signatures[xMutexInit_winMutexInit_enum], sizeof(E.xMutexInit_signature)) == 0) {
+     return winMutexInit(args);
+ }


// FP: xMutexLeave

@transform_return_xMutexLeave_dot@
expression E;
identifier FP_NAME = xMutexLeave;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_checkMutexLeave_enum], sizeof(E.xMutexLeave_signature)) == 0) {
+     return checkMutexLeave(args);
+ }
+ else if (memcmp(E.xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_debugMutexLeave_enum], sizeof(E.xMutexLeave_signature)) == 0) {
+     return debugMutexLeave(args);
+ }
+ else if (memcmp(E.xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_noopMutexLeave_enum], sizeof(E.xMutexLeave_signature)) == 0) {
+     return noopMutexLeave(args);
+ }
+ else if (memcmp(E.xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_pthreadMutexLeave_enum], sizeof(E.xMutexLeave_signature)) == 0) {
+     return pthreadMutexLeave(args);
+ }
+ else if (memcmp(E.xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_winMutexLeave_enum], sizeof(E.xMutexLeave_signature)) == 0) {
+     return winMutexLeave(args);
+ }


// FP: xMutexNotheld

@transform_return_xMutexNotheld_dot@
expression E;
identifier FP_NAME = xMutexNotheld;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xMutexNotheld_signature, xMutexNotheld_signatures[xMutexNotheld_0_enum], sizeof(E.xMutexNotheld_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xMutexNotheld_signature, xMutexNotheld_signatures[xMutexNotheld_debugMutexNotheld_enum], sizeof(E.xMutexNotheld_signature)) == 0) {
+     return debugMutexNotheld(args);
+ }


// FP: xMutexTry

@transform_return_xMutexTry_dot@
expression E;
identifier FP_NAME = xMutexTry;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xMutexTry_signature, xMutexTry_signatures[xMutexTry_checkMutexTry_enum], sizeof(E.xMutexTry_signature)) == 0) {
+     return checkMutexTry(args);
+ }
+ else if (memcmp(E.xMutexTry_signature, xMutexTry_signatures[xMutexTry_debugMutexTry_enum], sizeof(E.xMutexTry_signature)) == 0) {
+     return debugMutexTry(args);
+ }
+ else if (memcmp(E.xMutexTry_signature, xMutexTry_signatures[xMutexTry_noopMutexTry_enum], sizeof(E.xMutexTry_signature)) == 0) {
+     return noopMutexTry(args);
+ }
+ else if (memcmp(E.xMutexTry_signature, xMutexTry_signatures[xMutexTry_pthreadMutexTry_enum], sizeof(E.xMutexTry_signature)) == 0) {
+     return pthreadMutexTry(args);
+ }
+ else if (memcmp(E.xMutexTry_signature, xMutexTry_signatures[xMutexTry_winMutexTry_enum], sizeof(E.xMutexTry_signature)) == 0) {
+     return winMutexTry(args);
+ }


// FP: xNew

@transform_return_xNew_dot@
expression E;
identifier FP_NAME = xNew;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xNew_signature, xNew_signatures[xNew_sessionDiffNew_enum], sizeof(E.xNew_signature)) == 0) {
+     return sessionDiffNew(args);
+ }
+ else if (memcmp(E.xNew_signature, xNew_signatures[xNew_sessionPreupdateNew_enum], sizeof(E.xNew_signature)) == 0) {
+     return sessionPreupdateNew(args);
+ }
+ else if (memcmp(E.xNew_signature, xNew_signatures[xNew_sessionStat1New_enum], sizeof(E.xNew_signature)) == 0) {
+     return sessionStat1New(args);
+ }


// FP: xNext

@transform_return_xNext_dot@
expression E;
identifier FP_NAME = xNext;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xNext_signature, xNext_signatures[xNext_0_enum], sizeof(E.xNext_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_bytecodevtabNext_enum], sizeof(E.xNext_signature)) == 0) {
+     return bytecodevtabNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_completionNext_enum], sizeof(E.xNext_signature)) == 0) {
+     return completionNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_dbdataNext_enum], sizeof(E.xNext_signature)) == 0) {
+     return dbdataNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_dbpageNext_enum], sizeof(E.xNext_signature)) == 0) {
+     return dbpageNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_expertNext_enum], sizeof(E.xNext_signature)) == 0) {
+     return expertNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_fsdirNext_enum], sizeof(E.xNext_signature)) == 0) {
+     return fsdirNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_fts3NextMethod_enum], sizeof(E.xNext_signature)) == 0) {
+     return fts3NextMethod(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_fts3auxNextMethod_enum], sizeof(E.xNext_signature)) == 0) {
+     return fts3auxNextMethod(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_fts3tokNextMethod_enum], sizeof(E.xNext_signature)) == 0) {
+     return fts3tokNextMethod(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_jsonEachNext_enum], sizeof(E.xNext_signature)) == 0) {
+     return jsonEachNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_porterNext_enum], sizeof(E.xNext_signature)) == 0) {
+     return porterNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_pragmaVtabNext_enum], sizeof(E.xNext_signature)) == 0) {
+     return pragmaVtabNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_rtreeNext_enum], sizeof(E.xNext_signature)) == 0) {
+     return rtreeNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_seriesNext_enum], sizeof(E.xNext_signature)) == 0) {
+     return seriesNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_simpleNext_enum], sizeof(E.xNext_signature)) == 0) {
+     return simpleNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_statNext_enum], sizeof(E.xNext_signature)) == 0) {
+     return statNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_stmtNext_enum], sizeof(E.xNext_signature)) == 0) {
+     return stmtNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_unicodeNext_enum], sizeof(E.xNext_signature)) == 0) {
+     return unicodeNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_zipfileNext_enum], sizeof(E.xNext_signature)) == 0) {
+     return zipfileNext(args);
+ }


// FP: xNextSystemCall

@transform_return_xNextSystemCall_dot@
expression E;
identifier FP_NAME = xNextSystemCall;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xNextSystemCall_signature, xNextSystemCall_signatures[xNextSystemCall_0_enum], sizeof(E.xNextSystemCall_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xNextSystemCall_signature, xNextSystemCall_signatures[xNextSystemCall_apndNextSystemCall_enum], sizeof(E.xNextSystemCall_signature)) == 0) {
+     return apndNextSystemCall(args);
+ }
+ else if (memcmp(E.xNextSystemCall_signature, xNextSystemCall_signatures[xNextSystemCall_rbuVfsGetLastError_enum], sizeof(E.xNextSystemCall_signature)) == 0) {
+     return rbuVfsGetLastError(args);
+ }
+ else if (memcmp(E.xNextSystemCall_signature, xNextSystemCall_signatures[xNextSystemCall_unixNextSystemCall_enum], sizeof(E.xNextSystemCall_signature)) == 0) {
+     return unixNextSystemCall(args);
+ }


// FP: xOld

@transform_return_xOld_dot@
expression E;
identifier FP_NAME = xOld;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xOld_signature, xOld_signatures[xOld_sessionDiffOld_enum], sizeof(E.xOld_signature)) == 0) {
+     return sessionDiffOld(args);
+ }
+ else if (memcmp(E.xOld_signature, xOld_signatures[xOld_sessionPreupdateOld_enum], sizeof(E.xOld_signature)) == 0) {
+     return sessionPreupdateOld(args);
+ }
+ else if (memcmp(E.xOld_signature, xOld_signatures[xOld_sessionStat1Old_enum], sizeof(E.xOld_signature)) == 0) {
+     return sessionStat1Old(args);
+ }


// FP: xOpen

@transform_return_xOpen_dot@
expression E;
identifier FP_NAME = xOpen;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_apndOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+     return apndOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_bytecodevtabOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+     return bytecodevtabOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_completionOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+     return completionOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_dbdataOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+     return dbdataOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_dbpageOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+     return dbpageOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_expertOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+     return expertOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_fsdirOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+     return fsdirOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_fts3OpenMethod_enum], sizeof(E.xOpen_signature)) == 0) {
+     return fts3OpenMethod(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_fts3auxOpenMethod_enum], sizeof(E.xOpen_signature)) == 0) {
+     return fts3auxOpenMethod(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_fts3tokOpenMethod_enum], sizeof(E.xOpen_signature)) == 0) {
+     return fts3tokOpenMethod(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_jsonEachOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+     return jsonEachOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_memdbOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+     return memdbOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_porterOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+     return porterOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_pragmaVtabOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+     return pragmaVtabOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_rtreeOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+     return rtreeOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_seriesOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+     return seriesOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_simpleOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+     return simpleOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_statOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+     return statOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_stmtOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+     return stmtOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_unicodeOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+     return unicodeOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_vfstraceOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+     return vfstraceOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_zipfileOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+     return zipfileOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_unixOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+     return unixOpen(args);
+ }


// FP: xOut

@transform_return_xOut_dot@
expression E;
identifier FP_NAME = xOut;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return vfstraceOut(args);

// FP: xPagecount

@transform_return_xPagecount_dot@
expression E;
identifier FP_NAME = xPagecount;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xPagecount_signature, xPagecount_signatures[xPagecount_pcache1Pagecount_enum], sizeof(E.xPagecount_signature)) == 0) {
+     return pcache1Pagecount(args);
+ }
+ else if (memcmp(E.xPagecount_signature, xPagecount_signatures[xPagecount_pcachetracePagecount_enum], sizeof(E.xPagecount_signature)) == 0) {
+     return pcachetracePagecount(args);
+ }


// FP: xParseCell

@transform_return_xParseCell_dot@
expression E;
identifier FP_NAME = xParseCell;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xParseCell_signature, xParseCell_signatures[xParseCell_btreeParseCellPtr_enum], sizeof(E.xParseCell_signature)) == 0) {
+     return btreeParseCellPtr(args);
+ }
+ else if (memcmp(E.xParseCell_signature, xParseCell_signatures[xParseCell_btreeParseCellPtrIndex_enum], sizeof(E.xParseCell_signature)) == 0) {
+     return btreeParseCellPtrIndex(args);
+ }
+ else if (memcmp(E.xParseCell_signature, xParseCell_signatures[xParseCell_btreeParseCellPtrNoPayload_enum], sizeof(E.xParseCell_signature)) == 0) {
+     return btreeParseCellPtrNoPayload(args);
+ }


// FP: xPreUpdateCallback

@transform_return_xPreUpdateCallback_dot@
expression E;
identifier FP_NAME = xPreUpdateCallback;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xPreUpdateCallback_signature, xPreUpdateCallback_signatures[xPreUpdateCallback_0_enum], sizeof(E.xPreUpdateCallback_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xPreUpdateCallback_signature, xPreUpdateCallback_signatures[xPreUpdateCallback_sql_trace_callback_enum], sizeof(E.xPreUpdateCallback_signature)) == 0) {
+     return sql_trace_callback(args);
+ }
+ else if (memcmp(E.xPreUpdateCallback_signature, xPreUpdateCallback_signatures[xPreUpdateCallback_sqlite3WalDefaultHook_enum], sizeof(E.xPreUpdateCallback_signature)) == 0) {
+     return sqlite3WalDefaultHook(args);
+ }


// FP: xQueryFunc

@transform_return_xQueryFunc_dot@
expression E;
identifier FP_NAME = xQueryFunc;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ return 0;

// FP: xRandomness

@transform_return_xRandomness_dot@
expression E;
identifier FP_NAME = xRandomness;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xRandomness_signature, xRandomness_signatures[xRandomness_apndRandomness_enum], sizeof(E.xRandomness_signature)) == 0) {
+     return apndRandomness(args);
+ }
+ else if (memcmp(E.xRandomness_signature, xRandomness_signatures[xRandomness_memdbRandomness_enum], sizeof(E.xRandomness_signature)) == 0) {
+     return memdbRandomness(args);
+ }
+ else if (memcmp(E.xRandomness_signature, xRandomness_signatures[xRandomness_vfstraceRandomness_enum], sizeof(E.xRandomness_signature)) == 0) {
+     return vfstraceRandomness(args);
+ }
+ else if (memcmp(E.xRandomness_signature, xRandomness_signatures[xRandomness_unixRandomness_enum], sizeof(E.xRandomness_signature)) == 0) {
+     return unixRandomness(args);
+ }


// FP: xRead

@transform_return_xRead_dot@
expression E;
identifier FP_NAME = xRead;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xRead_signature, xRead_signatures[xRead_apndRead_enum], sizeof(E.xRead_signature)) == 0) {
+     return apndRead(args);
+ }
+ else if (memcmp(E.xRead_signature, xRead_signatures[xRead_memdbRead_enum], sizeof(E.xRead_signature)) == 0) {
+     return memdbRead(args);
+ }
+ else if (memcmp(E.xRead_signature, xRead_signatures[xRead_memjrnlRead_enum], sizeof(E.xRead_signature)) == 0) {
+     return memjrnlRead(args);
+ }
+ else if (memcmp(E.xRead_signature, xRead_signatures[xRead_recoverVfsRead_enum], sizeof(E.xRead_signature)) == 0) {
+     return recoverVfsRead(args);
+ }
+ else if (memcmp(E.xRead_signature, xRead_signatures[xRead_vfstraceRead_enum], sizeof(E.xRead_signature)) == 0) {
+     return vfstraceRead(args);
+ }


// FP: xRealloc

@transform_return_xRealloc_dot@
expression E;
identifier FP_NAME = xRealloc;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xRealloc_signature, xRealloc_signatures[xRealloc_memtraceRealloc_enum], sizeof(E.xRealloc_signature)) == 0) {
+     return memtraceRealloc(args);
+ }
+ else if (memcmp(E.xRealloc_signature, xRealloc_signatures[xRealloc_sqlite3MemRealloc_enum], sizeof(E.xRealloc_signature)) == 0) {
+     return sqlite3MemRealloc(args);
+ }


// FP: xRekey

@transform_return_xRekey_dot@
expression E;
identifier FP_NAME = xRekey;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xRekey_signature, xRekey_signatures[xRekey_pcache1Rekey_enum], sizeof(E.xRekey_signature)) == 0) {
+     return pcache1Rekey(args);
+ }
+ else if (memcmp(E.xRekey_signature, xRekey_signatures[xRekey_pcachetraceRekey_enum], sizeof(E.xRekey_signature)) == 0) {
+     return pcachetraceRekey(args);
+ }


// FP: xRelease

@transform_return_xRelease_dot@
expression E;
identifier FP_NAME = xRelease;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xRelease_signature, xRelease_signatures[xRelease_0_enum], sizeof(E.xRelease_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xRelease_signature, xRelease_signatures[xRelease_fts3ReleaseMethod_enum], sizeof(E.xRelease_signature)) == 0) {
+     return fts3ReleaseMethod(args);
+ }


// FP: xRename

@transform_return_xRename_dot@
expression E;
identifier FP_NAME = xRename;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xRename_signature, xRename_signatures[xRename_0_enum], sizeof(E.xRename_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xRename_signature, xRename_signatures[xRename_fts3RenameMethod_enum], sizeof(E.xRename_signature)) == 0) {
+     return fts3RenameMethod(args);
+ }
+ else if (memcmp(E.xRename_signature, xRename_signatures[xRename_rtreeRename_enum], sizeof(E.xRename_signature)) == 0) {
+     return rtreeRename(args);
+ }
+ else if (memcmp(E.xRename_signature, xRename_signatures[xRename_xRename_enum], sizeof(E.xRename_signature)) == 0) {
+     return xRename(args);
+ }


// FP: xRollback

@transform_return_xRollback_dot@
expression E;
identifier FP_NAME = xRollback;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xRollback_signature, xRollback_signatures[xRollback_0_enum], sizeof(E.xRollback_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xRollback_signature, xRollback_signatures[xRollback_fts3RollbackMethod_enum], sizeof(E.xRollback_signature)) == 0) {
+     return fts3RollbackMethod(args);
+ }
+ else if (memcmp(E.xRollback_signature, xRollback_signatures[xRollback_rtreeEndTransaction_enum], sizeof(E.xRollback_signature)) == 0) {
+     return rtreeEndTransaction(args);
+ }
+ else if (memcmp(E.xRollback_signature, xRollback_signatures[xRollback_rtreeRollback_enum], sizeof(E.xRollback_signature)) == 0) {
+     return rtreeRollback(args);
+ }
+ else if (memcmp(E.xRollback_signature, xRollback_signatures[xRollback_zipfileRollback_enum], sizeof(E.xRollback_signature)) == 0) {
+     return zipfileRollback(args);
+ }


// FP: xRollbackCallback

@transform_return_xRollbackCallback_dot@
expression E;
identifier FP_NAME = xRollbackCallback;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xRollbackCallback_signature, xRollbackCallback_signatures[xRollbackCallback_0_enum], sizeof(E.xRollbackCallback_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xRollbackCallback_signature, xRollbackCallback_signatures[xRollbackCallback_sql_trace_callback_enum], sizeof(E.xRollbackCallback_signature)) == 0) {
+     return sql_trace_callback(args);
+ }
+ else if (memcmp(E.xRollbackCallback_signature, xRollbackCallback_signatures[xRollbackCallback_sqlite3WalDefaultHook_enum], sizeof(E.xRollbackCallback_signature)) == 0) {
+     return sqlite3WalDefaultHook(args);
+ }


// FP: xRollbackTo

@transform_return_xRollbackTo_dot@
expression E;
identifier FP_NAME = xRollbackTo;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xRollbackTo_signature, xRollbackTo_signatures[xRollbackTo_0_enum], sizeof(E.xRollbackTo_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xRollbackTo_signature, xRollbackTo_signatures[xRollbackTo_dbpageRollbackTo_enum], sizeof(E.xRollbackTo_signature)) == 0) {
+     return dbpageRollbackTo(args);
+ }
+ else if (memcmp(E.xRollbackTo_signature, xRollbackTo_signatures[xRollbackTo_fts3RollbackToMethod_enum], sizeof(E.xRollbackTo_signature)) == 0) {
+     return fts3RollbackToMethod(args);
+ }


// FP: xRoundup

@transform_return_xRoundup_dot@
expression E;
identifier FP_NAME = xRoundup;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xRoundup_signature, xRoundup_signatures[xRoundup_memtraceRoundup_enum], sizeof(E.xRoundup_signature)) == 0) {
+     return memtraceRoundup(args);
+ }
+ else if (memcmp(E.xRoundup_signature, xRoundup_signatures[xRoundup_sqlite3MemRoundup_enum], sizeof(E.xRoundup_signature)) == 0) {
+     return sqlite3MemRoundup(args);
+ }


// FP: xRowid

@transform_return_xRowid_dot@
expression E;
identifier FP_NAME = xRowid;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_0_enum], sizeof(E.xRowid_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_bytecodevtabRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+     return bytecodevtabRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_completionRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+     return completionRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_dbdataRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+     return dbdataRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_dbpageRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+     return dbpageRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_expertRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+     return expertRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_fsdirRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+     return fsdirRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_fts3RowidMethod_enum], sizeof(E.xRowid_signature)) == 0) {
+     return fts3RowidMethod(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_fts3auxRowidMethod_enum], sizeof(E.xRowid_signature)) == 0) {
+     return fts3auxRowidMethod(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_fts3tokRowidMethod_enum], sizeof(E.xRowid_signature)) == 0) {
+     return fts3tokRowidMethod(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_jsonEachRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+     return jsonEachRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_pragmaVtabRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+     return pragmaVtabRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_rtreeRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+     return rtreeRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_seriesRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+     return seriesRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_statRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+     return statRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_stmtRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+     return stmtRowid(args);
+ }


// FP: xSFunc

@transform_return_xSFunc_dot@
expression E;
identifier FP_NAME = xSFunc;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_0_enum], sizeof(E.xSFunc_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_attachFunc_enum], sizeof(E.xSFunc_signature)) == 0) {
+     return attachFunc(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_base64_enum], sizeof(E.xSFunc_signature)) == 0) {
+     return base64(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_base85_enum], sizeof(E.xSFunc_signature)) == 0) {
+     return base85(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_detachFunc_enum], sizeof(E.xSFunc_signature)) == 0) {
+     return detachFunc(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_dummyUDF_enum], sizeof(E.xSFunc_signature)) == 0) {
+     return dummyUDF(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_editFunc_enum], sizeof(E.xSFunc_signature)) == 0) {
+     return editFunc(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_fts3AllocateMSI_enum], sizeof(E.xSFunc_signature)) == 0) {
+     return fts3AllocateMSI(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_fts3ExprGlobalHitsCb_enum], sizeof(E.xSFunc_signature)) == 0) {
+     return fts3ExprGlobalHitsCb(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_fts3ExprLoadDoclistsCb_enum], sizeof(E.xSFunc_signature)) == 0) {
+     return fts3ExprLoadDoclistsCb(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_fts3ExprLocalHitsCb_enum], sizeof(E.xSFunc_signature)) == 0) {
+     return fts3ExprLocalHitsCb(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_fts3ExprPhraseCountCb_enum], sizeof(E.xSFunc_signature)) == 0) {
+     return fts3ExprPhraseCountCb(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_fts3ExprRestartIfCb_enum], sizeof(E.xSFunc_signature)) == 0) {
+     return fts3ExprRestartIfCb(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_fts3ExprTermOffsetInit_enum], sizeof(E.xSFunc_signature)) == 0) {
+     return fts3ExprTermOffsetInit(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_fts3ExprTest_enum], sizeof(E.xSFunc_signature)) == 0) {
+     return fts3ExprTest(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_fts3ExprTestRebalance_enum], sizeof(E.xSFunc_signature)) == 0) {
+     return fts3ExprTestRebalance(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_fts3MatchinfoLcsCb_enum], sizeof(E.xSFunc_signature)) == 0) {
+     return fts3MatchinfoLcsCb(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_fts3SnippetFindPositions_enum], sizeof(E.xSFunc_signature)) == 0) {
+     return fts3SnippetFindPositions(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_fts3TokenizerFunc_enum], sizeof(E.xSFunc_signature)) == 0) {
+     return fts3TokenizerFunc(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_geomCallback_enum], sizeof(E.xSFunc_signature)) == 0) {
+     return geomCallback(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_idxRemFunc_enum], sizeof(E.xSFunc_signature)) == 0) {
+     return idxRemFunc(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_idxSampleFunc_enum], sizeof(E.xSFunc_signature)) == 0) {
+     return idxSampleFunc(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_intTestFunc_enum], sizeof(E.xSFunc_signature)) == 0) {
+     return intTestFunc(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_intckParseCreateIndexFunc_enum], sizeof(E.xSFunc_signature)) == 0) {
+     return intckParseCreateIndexFunc(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_is_base85_enum], sizeof(E.xSFunc_signature)) == 0) {
+     return is_base85(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_likeFunc_enum], sizeof(E.xSFunc_signature)) == 0) {
+     return likeFunc(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_lsModeFunc_enum], sizeof(E.xSFunc_signature)) == 0) {
+     return lsModeFunc(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_rbuFossilDeltaFunc_enum], sizeof(E.xSFunc_signature)) == 0) {
+     return rbuFossilDeltaFunc(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_rbuIndexCntFunc_enum], sizeof(E.xSFunc_signature)) == 0) {
+     return rbuIndexCntFunc(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_rbuTargetNameFunc_enum], sizeof(E.xSFunc_signature)) == 0) {
+     return rbuTargetNameFunc(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_rbuTmpInsertFunc_enum], sizeof(E.xSFunc_signature)) == 0) {
+     return rbuTmpInsertFunc(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_re_bytecode_func_enum], sizeof(E.xSFunc_signature)) == 0) {
+     return re_bytecode_func(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_re_sql_func_enum], sizeof(E.xSFunc_signature)) == 0) {
+     return re_sql_func(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_readfileFunc_enum], sizeof(E.xSFunc_signature)) == 0) {
+     return readfileFunc(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_rtreecheck_enum], sizeof(E.xSFunc_signature)) == 0) {
+     return rtreecheck(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_rtreedepth_enum], sizeof(E.xSFunc_signature)) == 0) {
+     return rtreedepth(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_rtreenode_enum], sizeof(E.xSFunc_signature)) == 0) {
+     return rtreenode(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_sha1Func_enum], sizeof(E.xSFunc_signature)) == 0) {
+     return sha1Func(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_sha1QueryFunc_enum], sizeof(E.xSFunc_signature)) == 0) {
+     return sha1QueryFunc(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_sha3Func_enum], sizeof(E.xSFunc_signature)) == 0) {
+     return sha3Func(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_sha3QueryFunc_enum], sizeof(E.xSFunc_signature)) == 0) {
+     return sha3QueryFunc(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_shellAddSchemaName_enum], sizeof(E.xSFunc_signature)) == 0) {
+     return shellAddSchemaName(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_shellDtostr_enum], sizeof(E.xSFunc_signature)) == 0) {
+     return shellDtostr(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_shellFkeyCollateClause_enum], sizeof(E.xSFunc_signature)) == 0) {
+     return shellFkeyCollateClause(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_shellModuleSchema_enum], sizeof(E.xSFunc_signature)) == 0) {
+     return shellModuleSchema(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_shellPutsFunc_enum], sizeof(E.xSFunc_signature)) == 0) {
+     return shellPutsFunc(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_shellStrtod_enum], sizeof(E.xSFunc_signature)) == 0) {
+     return shellStrtod(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_shellUSleepFunc_enum], sizeof(E.xSFunc_signature)) == 0) {
+     return shellUSleepFunc(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_sqlarCompressFunc_enum], sizeof(E.xSFunc_signature)) == 0) {
+     return sqlarCompressFunc(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_sqlarUncompressFunc_enum], sizeof(E.xSFunc_signature)) == 0) {
+     return sqlarUncompressFunc(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_sqlite3InvalidFunction_enum], sizeof(E.xSFunc_signature)) == 0) {
+     return sqlite3InvalidFunction(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_statGet_enum], sizeof(E.xSFunc_signature)) == 0) {
+     return statGet(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_statInit_enum], sizeof(E.xSFunc_signature)) == 0) {
+     return statInit(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_statPush_enum], sizeof(E.xSFunc_signature)) == 0) {
+     return statPush(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_stmtrandFunc_enum], sizeof(E.xSFunc_signature)) == 0) {
+     return stmtrandFunc(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_testFunc_enum], sizeof(E.xSFunc_signature)) == 0) {
+     return testFunc(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_writefileFunc_enum], sizeof(E.xSFunc_signature)) == 0) {
+     return writefileFunc(args);
+ }


// FP: xSavepoint

@transform_return_xSavepoint_dot@
expression E;
identifier FP_NAME = xSavepoint;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xSavepoint_signature, xSavepoint_signatures[xSavepoint_0_enum], sizeof(E.xSavepoint_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xSavepoint_signature, xSavepoint_signatures[xSavepoint_fts3SavepointMethod_enum], sizeof(E.xSavepoint_signature)) == 0) {
+     return fts3SavepointMethod(args);
+ }
+ else if (memcmp(E.xSavepoint_signature, xSavepoint_signatures[xSavepoint_rtreeSavepoint_enum], sizeof(E.xSavepoint_signature)) == 0) {
+     return rtreeSavepoint(args);
+ }


// FP: xSectorSize

@transform_return_xSectorSize_dot@
expression E;
identifier FP_NAME = xSectorSize;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xSectorSize_signature, xSectorSize_signatures[xSectorSize_0_enum], sizeof(E.xSectorSize_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xSectorSize_signature, xSectorSize_signatures[xSectorSize_apndSectorSize_enum], sizeof(E.xSectorSize_signature)) == 0) {
+     return apndSectorSize(args);
+ }
+ else if (memcmp(E.xSectorSize_signature, xSectorSize_signatures[xSectorSize_recoverVfsSectorSize_enum], sizeof(E.xSectorSize_signature)) == 0) {
+     return recoverVfsSectorSize(args);
+ }
+ else if (memcmp(E.xSectorSize_signature, xSectorSize_signatures[xSectorSize_vfstraceSectorSize_enum], sizeof(E.xSectorSize_signature)) == 0) {
+     return vfstraceSectorSize(args);
+ }


// FP: xSelectCallback

@transform_return_xSelectCallback_dot@
expression E;
identifier FP_NAME = xSelectCallback;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_0_enum], sizeof(E.xSelectCallback_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_convertCompoundSelectToSubquery_enum], sizeof(E.xSelectCallback_signature)) == 0) {
+     return convertCompoundSelectToSubquery(args);
+ }
+ else if (memcmp(E.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_exprSelectWalkTableConstant_enum], sizeof(E.xSelectCallback_signature)) == 0) {
+     return exprSelectWalkTableConstant(args);
+ }
+ else if (memcmp(E.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_fixSelectCb_enum], sizeof(E.xSelectCallback_signature)) == 0) {
+     return fixSelectCb(args);
+ }
+ else if (memcmp(E.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_gatherSelectWindowsSelectCallback_enum], sizeof(E.xSelectCallback_signature)) == 0) {
+     return gatherSelectWindowsSelectCallback(args);
+ }
+ else if (memcmp(E.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_renameColumnSelectCb_enum], sizeof(E.xSelectCallback_signature)) == 0) {
+     return renameColumnSelectCb(args);
+ }
+ else if (memcmp(E.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_renameTableSelectCb_enum], sizeof(E.xSelectCallback_signature)) == 0) {
+     return renameTableSelectCb(args);
+ }
+ else if (memcmp(E.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_renameUnmapSelectCb_enum], sizeof(E.xSelectCallback_signature)) == 0) {
+     return renameUnmapSelectCb(args);
+ }
+ else if (memcmp(E.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_resolveSelectStep_enum], sizeof(E.xSelectCallback_signature)) == 0) {
+     return resolveSelectStep(args);
+ }
+ else if (memcmp(E.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_selectCheckOnClausesSelect_enum], sizeof(E.xSelectCallback_signature)) == 0) {
+     return selectCheckOnClausesSelect(args);
+ }
+ else if (memcmp(E.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_selectExpander_enum], sizeof(E.xSelectCallback_signature)) == 0) {
+     return selectExpander(args);
+ }
+ else if (memcmp(E.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_selectRefEnter_enum], sizeof(E.xSelectCallback_signature)) == 0) {
+     return selectRefEnter(args);
+ }
+ else if (memcmp(E.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_selectWindowRewriteSelectCb_enum], sizeof(E.xSelectCallback_signature)) == 0) {
+     return selectWindowRewriteSelectCb(args);
+ }
+ else if (memcmp(E.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_sqlite3ReturningSubqueryCorrelated_enum], sizeof(E.xSelectCallback_signature)) == 0) {
+     return sqlite3ReturningSubqueryCorrelated(args);
+ }
+ else if (memcmp(E.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_sqlite3SelectWalkFail_enum], sizeof(E.xSelectCallback_signature)) == 0) {
+     return sqlite3SelectWalkFail(args);
+ }
+ else if (memcmp(E.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_sqlite3SelectWalkNoop_enum], sizeof(E.xSelectCallback_signature)) == 0) {
+     return sqlite3SelectWalkNoop(args);
+ }
+ else if (memcmp(E.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_sqlite3WalkerDepthIncrease_enum], sizeof(E.xSelectCallback_signature)) == 0) {
+     return sqlite3WalkerDepthIncrease(args);
+ }


// FP: xSelectCallback2

@transform_return_xSelectCallback2_dot@
expression E;
identifier FP_NAME = xSelectCallback2;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_0_enum], sizeof(E.xSelectCallback2_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_selectAddSubqueryTypeInfo_enum], sizeof(E.xSelectCallback2_signature)) == 0) {
+     return selectAddSubqueryTypeInfo(args);
+ }
+ else if (memcmp(E.xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_selectRefLeave_enum], sizeof(E.xSelectCallback2_signature)) == 0) {
+     return selectRefLeave(args);
+ }
+ else if (memcmp(E.xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_sqlite3SelectPopWith_enum], sizeof(E.xSelectCallback2_signature)) == 0) {
+     return sqlite3SelectPopWith(args);
+ }
+ else if (memcmp(E.xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_sqlite3WalkWinDefnDummyCallback_enum], sizeof(E.xSelectCallback2_signature)) == 0) {
+     return sqlite3WalkWinDefnDummyCallback(args);
+ }
+ else if (memcmp(E.xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_sqlite3WalkerDepthDecrease_enum], sizeof(E.xSelectCallback2_signature)) == 0) {
+     return sqlite3WalkerDepthDecrease(args);
+ }


// FP: xSetSystemCall

@transform_return_xSetSystemCall_dot@
expression E;
identifier FP_NAME = xSetSystemCall;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xSetSystemCall_signature, xSetSystemCall_signatures[xSetSystemCall_0_enum], sizeof(E.xSetSystemCall_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xSetSystemCall_signature, xSetSystemCall_signatures[xSetSystemCall_apndSetSystemCall_enum], sizeof(E.xSetSystemCall_signature)) == 0) {
+     return apndSetSystemCall(args);
+ }
+ else if (memcmp(E.xSetSystemCall_signature, xSetSystemCall_signatures[xSetSystemCall_rbuVfsSleep_enum], sizeof(E.xSetSystemCall_signature)) == 0) {
+     return rbuVfsSleep(args);
+ }
+ else if (memcmp(E.xSetSystemCall_signature, xSetSystemCall_signatures[xSetSystemCall_unixSetSystemCall_enum], sizeof(E.xSetSystemCall_signature)) == 0) {
+     return unixSetSystemCall(args);
+ }


// FP: xShadowName

@transform_return_xShadowName_dot@
expression E;
identifier FP_NAME = xShadowName;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xShadowName_signature, xShadowName_signatures[xShadowName_0_enum], sizeof(E.xShadowName_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xShadowName_signature, xShadowName_signatures[xShadowName_fts3ShadowName_enum], sizeof(E.xShadowName_signature)) == 0) {
+     return fts3ShadowName(args);
+ }
+ else if (memcmp(E.xShadowName_signature, xShadowName_signatures[xShadowName_rtreeShadowName_enum], sizeof(E.xShadowName_signature)) == 0) {
+     return rtreeShadowName(args);
+ }


// FP: xShmBarrier

@transform_return_xShmBarrier_dot@
expression E;
identifier FP_NAME = xShmBarrier;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xShmBarrier_signature, xShmBarrier_signatures[xShmBarrier_0_enum], sizeof(E.xShmBarrier_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xShmBarrier_signature, xShmBarrier_signatures[xShmBarrier_apndShmBarrier_enum], sizeof(E.xShmBarrier_signature)) == 0) {
+     return apndShmBarrier(args);
+ }
+ else if (memcmp(E.xShmBarrier_signature, xShmBarrier_signatures[xShmBarrier_recoverVfsShmBarrier_enum], sizeof(E.xShmBarrier_signature)) == 0) {
+     return recoverVfsShmBarrier(args);
+ }


// FP: xShmLock

@transform_return_xShmLock_dot@
expression E;
identifier FP_NAME = xShmLock;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xShmLock_signature, xShmLock_signatures[xShmLock_0_enum], sizeof(E.xShmLock_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xShmLock_signature, xShmLock_signatures[xShmLock_apndShmLock_enum], sizeof(E.xShmLock_signature)) == 0) {
+     return apndShmLock(args);
+ }
+ else if (memcmp(E.xShmLock_signature, xShmLock_signatures[xShmLock_recoverVfsShmLock_enum], sizeof(E.xShmLock_signature)) == 0) {
+     return recoverVfsShmLock(args);
+ }


// FP: xShmMap

@transform_return_xShmMap_dot@
expression E;
identifier FP_NAME = xShmMap;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xShmMap_signature, xShmMap_signatures[xShmMap_0_enum], sizeof(E.xShmMap_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xShmMap_signature, xShmMap_signatures[xShmMap_apndShmMap_enum], sizeof(E.xShmMap_signature)) == 0) {
+     return apndShmMap(args);
+ }
+ else if (memcmp(E.xShmMap_signature, xShmMap_signatures[xShmMap_recoverVfsShmMap_enum], sizeof(E.xShmMap_signature)) == 0) {
+     return recoverVfsShmMap(args);
+ }


// FP: xShmUnmap

@transform_return_xShmUnmap_dot@
expression E;
identifier FP_NAME = xShmUnmap;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xShmUnmap_signature, xShmUnmap_signatures[xShmUnmap_0_enum], sizeof(E.xShmUnmap_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xShmUnmap_signature, xShmUnmap_signatures[xShmUnmap_apndShmUnmap_enum], sizeof(E.xShmUnmap_signature)) == 0) {
+     return apndShmUnmap(args);
+ }
+ else if (memcmp(E.xShmUnmap_signature, xShmUnmap_signatures[xShmUnmap_recoverVfsShmUnmap_enum], sizeof(E.xShmUnmap_signature)) == 0) {
+     return recoverVfsShmUnmap(args);
+ }


// FP: xShrink

@transform_return_xShrink_dot@
expression E;
identifier FP_NAME = xShrink;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xShrink_signature, xShrink_signatures[xShrink_pcache1Shrink_enum], sizeof(E.xShrink_signature)) == 0) {
+     return pcache1Shrink(args);
+ }
+ else if (memcmp(E.xShrink_signature, xShrink_signatures[xShrink_pcachetraceShrink_enum], sizeof(E.xShrink_signature)) == 0) {
+     return pcachetraceShrink(args);
+ }


// FP: xShutdown

@transform_return_xShutdown_dot@
expression E;
identifier FP_NAME = xShutdown;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xShutdown_signature, xShutdown_signatures[xShutdown_memtraceShutdown_enum], sizeof(E.xShutdown_signature)) == 0) {
+     return memtraceShutdown(args);
+ }
+ else if (memcmp(E.xShutdown_signature, xShutdown_signatures[xShutdown_pcache1Shutdown_enum], sizeof(E.xShutdown_signature)) == 0) {
+     return pcache1Shutdown(args);
+ }
+ else if (memcmp(E.xShutdown_signature, xShutdown_signatures[xShutdown_pcachetraceShutdown_enum], sizeof(E.xShutdown_signature)) == 0) {
+     return pcachetraceShutdown(args);
+ }
+ else if (memcmp(E.xShutdown_signature, xShutdown_signatures[xShutdown_sqlite3MemShutdown_enum], sizeof(E.xShutdown_signature)) == 0) {
+     return sqlite3MemShutdown(args);
+ }


// FP: xSize

@transform_return_xSize_dot@
expression E;
identifier FP_NAME = xSize;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xSize_signature, xSize_signatures[xSize_memtraceSize_enum], sizeof(E.xSize_signature)) == 0) {
+     return memtraceSize(args);
+ }
+ else if (memcmp(E.xSize_signature, xSize_signatures[xSize_sqlite3MemSize_enum], sizeof(E.xSize_signature)) == 0) {
+     return sqlite3MemSize(args);
+ }


// FP: xSleep

@transform_return_xSleep_dot@
expression E;
identifier FP_NAME = xSleep;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xSleep_signature, xSleep_signatures[xSleep_0_enum], sizeof(E.xSleep_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xSleep_signature, xSleep_signatures[xSleep_apndSleep_enum], sizeof(E.xSleep_signature)) == 0) {
+     return apndSleep(args);
+ }
+ else if (memcmp(E.xSleep_signature, xSleep_signatures[xSleep_memdbSleep_enum], sizeof(E.xSleep_signature)) == 0) {
+     return memdbSleep(args);
+ }
+ else if (memcmp(E.xSleep_signature, xSleep_signatures[xSleep_vfstraceSleep_enum], sizeof(E.xSleep_signature)) == 0) {
+     return vfstraceSleep(args);
+ }
+ else if (memcmp(E.xSleep_signature, xSleep_signatures[xSleep_unixSleep_enum], sizeof(E.xSleep_signature)) == 0) {
+     return unixSleep(args);
+ }


// FP: xSql

@transform_return_xSql_dot@
expression E;
identifier FP_NAME = xSql;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xSql_signature, xSql_signatures[xSql_0_enum], sizeof(E.xSql_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xSql_signature, xSql_signatures[xSql_recoverSqlCb_enum], sizeof(E.xSql_signature)) == 0) {
+     return recoverSqlCb(args);
+ }


// FP: xSync

@transform_return_xSync_dot@
expression E;
identifier FP_NAME = xSync;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xSync_signature, xSync_signatures[xSync_0_enum], sizeof(E.xSync_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xSync_signature, xSync_signatures[xSync_apndSync_enum], sizeof(E.xSync_signature)) == 0) {
+     return apndSync(args);
+ }
+ else if (memcmp(E.xSync_signature, xSync_signatures[xSync_dbpageSync_enum], sizeof(E.xSync_signature)) == 0) {
+     return dbpageSync(args);
+ }
+ else if (memcmp(E.xSync_signature, xSync_signatures[xSync_fts3SyncMethod_enum], sizeof(E.xSync_signature)) == 0) {
+     return fts3SyncMethod(args);
+ }
+ else if (memcmp(E.xSync_signature, xSync_signatures[xSync_memdbSync_enum], sizeof(E.xSync_signature)) == 0) {
+     return memdbSync(args);
+ }
+ else if (memcmp(E.xSync_signature, xSync_signatures[xSync_memjrnlSync_enum], sizeof(E.xSync_signature)) == 0) {
+     return memjrnlSync(args);
+ }
+ else if (memcmp(E.xSync_signature, xSync_signatures[xSync_recoverVfsSync_enum], sizeof(E.xSync_signature)) == 0) {
+     return recoverVfsSync(args);
+ }
+ else if (memcmp(E.xSync_signature, xSync_signatures[xSync_rtreeEndTransaction_enum], sizeof(E.xSync_signature)) == 0) {
+     return rtreeEndTransaction(args);
+ }
+ else if (memcmp(E.xSync_signature, xSync_signatures[xSync_vfstraceSync_enum], sizeof(E.xSync_signature)) == 0) {
+     return vfstraceSync(args);
+ }


// FP: xTableFilter

@transform_return_xTableFilter_dot@
expression E;
identifier FP_NAME = xTableFilter;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xTableFilter_signature, xTableFilter_signatures[xTableFilter_0_enum], sizeof(E.xTableFilter_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xTableFilter_signature, xTableFilter_signatures[xTableFilter_session_filter_enum], sizeof(E.xTableFilter_signature)) == 0) {
+     return session_filter(args);
+ }


// FP: xTask

@transform_return_xTask_dot@
expression E;
identifier FP_NAME = xTask;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xTask_signature, xTask_signatures[xTask_0_enum], sizeof(E.xTask_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xTask_signature, xTask_signatures[xTask_vdbeSorterFlushThread_enum], sizeof(E.xTask_signature)) == 0) {
+     return vdbeSorterFlushThread(args);
+ }
+ else if (memcmp(E.xTask_signature, xTask_signatures[xTask_vdbeIncrPopulateThread_enum], sizeof(E.xTask_signature)) == 0) {
+     return vdbeIncrPopulateThread(args);
+ }
+ else if (memcmp(E.xTask_signature, xTask_signatures[xTask_vdbePmaReaderBgIncrInit_enum], sizeof(E.xTask_signature)) == 0) {
+     return vdbePmaReaderBgIncrInit(args);
+ }


// FP: xTruncate

@transform_return_xTruncate_dot@
expression E;
identifier FP_NAME = xTruncate;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xTruncate_signature, xTruncate_signatures[xTruncate_apndTruncate_enum], sizeof(E.xTruncate_signature)) == 0) {
+     return apndTruncate(args);
+ }
+ else if (memcmp(E.xTruncate_signature, xTruncate_signatures[xTruncate_memdbTruncate_enum], sizeof(E.xTruncate_signature)) == 0) {
+     return memdbTruncate(args);
+ }
+ else if (memcmp(E.xTruncate_signature, xTruncate_signatures[xTruncate_memjrnlTruncate_enum], sizeof(E.xTruncate_signature)) == 0) {
+     return memjrnlTruncate(args);
+ }
+ else if (memcmp(E.xTruncate_signature, xTruncate_signatures[xTruncate_pcache1Truncate_enum], sizeof(E.xTruncate_signature)) == 0) {
+     return pcache1Truncate(args);
+ }
+ else if (memcmp(E.xTruncate_signature, xTruncate_signatures[xTruncate_pcachetraceTruncate_enum], sizeof(E.xTruncate_signature)) == 0) {
+     return pcachetraceTruncate(args);
+ }
+ else if (memcmp(E.xTruncate_signature, xTruncate_signatures[xTruncate_recoverVfsTruncate_enum], sizeof(E.xTruncate_signature)) == 0) {
+     return recoverVfsTruncate(args);
+ }
+ else if (memcmp(E.xTruncate_signature, xTruncate_signatures[xTruncate_vfstraceTruncate_enum], sizeof(E.xTruncate_signature)) == 0) {
+     return vfstraceTruncate(args);
+ }


// FP: xUnfetch

@transform_return_xUnfetch_dot@
expression E;
identifier FP_NAME = xUnfetch;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xUnfetch_signature, xUnfetch_signatures[xUnfetch_0_enum], sizeof(E.xUnfetch_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xUnfetch_signature, xUnfetch_signatures[xUnfetch_apndUnfetch_enum], sizeof(E.xUnfetch_signature)) == 0) {
+     return apndUnfetch(args);
+ }
+ else if (memcmp(E.xUnfetch_signature, xUnfetch_signatures[xUnfetch_memdbUnfetch_enum], sizeof(E.xUnfetch_signature)) == 0) {
+     return memdbUnfetch(args);
+ }
+ else if (memcmp(E.xUnfetch_signature, xUnfetch_signatures[xUnfetch_recoverVfsUnfetch_enum], sizeof(E.xUnfetch_signature)) == 0) {
+     return recoverVfsUnfetch(args);
+ }


// FP: xUnlock

@transform_return_xUnlock_dot@
expression E;
identifier FP_NAME = xUnlock;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xUnlock_signature, xUnlock_signatures[xUnlock_0_enum], sizeof(E.xUnlock_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xUnlock_signature, xUnlock_signatures[xUnlock_apndUnlock_enum], sizeof(E.xUnlock_signature)) == 0) {
+     return apndUnlock(args);
+ }
+ else if (memcmp(E.xUnlock_signature, xUnlock_signatures[xUnlock_memdbUnlock_enum], sizeof(E.xUnlock_signature)) == 0) {
+     return memdbUnlock(args);
+ }
+ else if (memcmp(E.xUnlock_signature, xUnlock_signatures[xUnlock_recoverVfsUnlock_enum], sizeof(E.xUnlock_signature)) == 0) {
+     return recoverVfsUnlock(args);
+ }
+ else if (memcmp(E.xUnlock_signature, xUnlock_signatures[xUnlock_vfstraceUnlock_enum], sizeof(E.xUnlock_signature)) == 0) {
+     return vfstraceUnlock(args);
+ }


// FP: xUnlockNotify

@transform_return_xUnlockNotify_dot@
expression E;
identifier FP_NAME = xUnlockNotify;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xUnlockNotify_signature, xUnlockNotify_signatures[xUnlockNotify_0_enum], sizeof(E.xUnlockNotify_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xUnlockNotify_signature, xUnlockNotify_signatures[xUnlockNotify_xUnlockNotify_enum], sizeof(E.xUnlockNotify_signature)) == 0) {
+     return xUnlockNotify(args);
+ }


// FP: xUnpin

@transform_return_xUnpin_dot@
expression E;
identifier FP_NAME = xUnpin;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xUnpin_signature, xUnpin_signatures[xUnpin_pcache1Unpin_enum], sizeof(E.xUnpin_signature)) == 0) {
+     return pcache1Unpin(args);
+ }
+ else if (memcmp(E.xUnpin_signature, xUnpin_signatures[xUnpin_pcachetraceUnpin_enum], sizeof(E.xUnpin_signature)) == 0) {
+     return pcachetraceUnpin(args);
+ }


// FP: xUpdate

@transform_return_xUpdate_dot@
expression E;
identifier FP_NAME = xUpdate;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xUpdate_signature, xUpdate_signatures[xUpdate_0_enum], sizeof(E.xUpdate_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xUpdate_signature, xUpdate_signatures[xUpdate_dbpageUpdate_enum], sizeof(E.xUpdate_signature)) == 0) {
+     return dbpageUpdate(args);
+ }
+ else if (memcmp(E.xUpdate_signature, xUpdate_signatures[xUpdate_expertUpdate_enum], sizeof(E.xUpdate_signature)) == 0) {
+     return expertUpdate(args);
+ }
+ else if (memcmp(E.xUpdate_signature, xUpdate_signatures[xUpdate_fts3UpdateMethod_enum], sizeof(E.xUpdate_signature)) == 0) {
+     return fts3UpdateMethod(args);
+ }
+ else if (memcmp(E.xUpdate_signature, xUpdate_signatures[xUpdate_geopolyUpdate_enum], sizeof(E.xUpdate_signature)) == 0) {
+     return geopolyUpdate(args);
+ }
+ else if (memcmp(E.xUpdate_signature, xUpdate_signatures[xUpdate_rtreeUpdate_enum], sizeof(E.xUpdate_signature)) == 0) {
+     return rtreeUpdate(args);
+ }
+ else if (memcmp(E.xUpdate_signature, xUpdate_signatures[xUpdate_zipfileUpdate_enum], sizeof(E.xUpdate_signature)) == 0) {
+     return zipfileUpdate(args);
+ }


// FP: xUpdateCallback

@transform_return_xUpdateCallback_dot@
expression E;
identifier FP_NAME = xUpdateCallback;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xUpdateCallback_signature, xUpdateCallback_signatures[xUpdateCallback_0_enum], sizeof(E.xUpdateCallback_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xUpdateCallback_signature, xUpdateCallback_signatures[xUpdateCallback_sql_trace_callback_enum], sizeof(E.xUpdateCallback_signature)) == 0) {
+     return sql_trace_callback(args);
+ }
+ else if (memcmp(E.xUpdateCallback_signature, xUpdateCallback_signatures[xUpdateCallback_sqlite3WalDefaultHook_enum], sizeof(E.xUpdateCallback_signature)) == 0) {
+     return sqlite3WalDefaultHook(args);
+ }


// FP: xV2

@transform_return_xV2_dot@
expression E;
identifier FP_NAME = xV2;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xV2_signature, xV2_signatures[xV2_0_enum], sizeof(E.xV2_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xV2_signature, xV2_signatures[xV2_sql_trace_callback_enum], sizeof(E.xV2_signature)) == 0) {
+     return sql_trace_callback(args);
+ }


// FP: xValue

@transform_return_xValue_dot@
expression E;
identifier FP_NAME = xValue;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xValue_signature, xValue_signatures[xValue_0_enum], sizeof(E.xValue_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xValue_signature, xValue_signatures[xValue_decimalSumValue_enum], sizeof(E.xValue_signature)) == 0) {
+     return decimalSumValue(args);
+ }
+ else if (memcmp(E.xValue_signature, xValue_signatures[xValue_percentValue_enum], sizeof(E.xValue_signature)) == 0) {
+     return percentValue(args);
+ }
+ else if (memcmp(E.xValue_signature, xValue_signatures[xValue_sqlite3changeset_new_enum], sizeof(E.xValue_signature)) == 0) {
+     return sqlite3changeset_new(args);
+ }
+ else if (memcmp(E.xValue_signature, xValue_signatures[xValue_sqlite3changeset_old_enum], sizeof(E.xValue_signature)) == 0) {
+     return sqlite3changeset_old(args);
+ }


// FP: xWrite

@transform_return_xWrite_dot@
expression E;
identifier FP_NAME = xWrite;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ if (memcmp(E.xWrite_signature, xWrite_signatures[xWrite_apndWrite_enum], sizeof(E.xWrite_signature)) == 0) {
+     return apndWrite(args);
+ }
+ else if (memcmp(E.xWrite_signature, xWrite_signatures[xWrite_kvstorageWrite_enum], sizeof(E.xWrite_signature)) == 0) {
+     return kvstorageWrite(args);
+ }
+ else if (memcmp(E.xWrite_signature, xWrite_signatures[xWrite_memdbWrite_enum], sizeof(E.xWrite_signature)) == 0) {
+     return memdbWrite(args);
+ }
+ else if (memcmp(E.xWrite_signature, xWrite_signatures[xWrite_memjrnlWrite_enum], sizeof(E.xWrite_signature)) == 0) {
+     return memjrnlWrite(args);
+ }
+ else if (memcmp(E.xWrite_signature, xWrite_signatures[xWrite_recoverVfsWrite_enum], sizeof(E.xWrite_signature)) == 0) {
+     return recoverVfsWrite(args);
+ }
+ else if (memcmp(E.xWrite_signature, xWrite_signatures[xWrite_vfstraceWrite_enum], sizeof(E.xWrite_signature)) == 0) {
+     return vfstraceWrite(args);
+ }


// FP: xsnprintf

@transform_return_xsnprintf_dot@
expression E;
identifier FP_NAME = xsnprintf;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+     return sqlite3_set_authorizer(args);

// FP: xvsnprintf

@transform_return_xvsnprintf_dot@
expression E;
identifier FP_NAME = xvsnprintf;
expression list args;
@@
- return E.FP_NAME(args);
+ // return E.FP_NAME(args);
+ return 0;
// Total return dot rules: 359

// ===== ASSIGNMENT ARROW TRANSFORMATION RULES =====
// Pattern: E1 = E2->fp_name(args);


// FP: aggregate_context

@transform_assign_aggregate_context_arrow@
expression E1, E2;
identifier FP_NAME = aggregate_context;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_aggregate_context(args);


// FP: auto_extension

@transform_assign_auto_extension_arrow@
expression E1, E2;
identifier FP_NAME = auto_extension;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_vtab_config(args);


// FP: backup_finish

@transform_assign_backup_finish_arrow@
expression E1, E2;
identifier FP_NAME = backup_finish;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_result_error_code(args);


// FP: backup_init

@transform_assign_backup_init_arrow@
expression E1, E2;
identifier FP_NAME = backup_init;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_test_control(args);


// FP: backup_pagecount

@transform_assign_backup_pagecount_arrow@
expression E1, E2;
identifier FP_NAME = backup_pagecount;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_randomness(args);


// FP: backup_remaining

@transform_assign_backup_remaining_arrow@
expression E1, E2;
identifier FP_NAME = backup_remaining;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_context_db_handle(args);


// FP: backup_step

@transform_assign_backup_step_arrow@
expression E1, E2;
identifier FP_NAME = backup_step;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_extended_result_codes(args);


// FP: bind_blob64

@transform_assign_bind_blob64_arrow@
expression E1, E2;
identifier FP_NAME = bind_blob64;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_vtab_on_conflict(args);


// FP: bind_int

@transform_assign_bind_int_arrow@
expression E1, E2;
identifier FP_NAME = bind_int;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_bind_double(args);


// FP: bind_int64

@transform_assign_bind_int64_arrow@
expression E1, E2;
identifier FP_NAME = bind_int64;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_bind_int(args);


// FP: bind_null

@transform_assign_bind_null_arrow@
expression E1, E2;
identifier FP_NAME = bind_null;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_bind_int64(args);


// FP: bind_parameter_count

@transform_assign_bind_parameter_count_arrow@
expression E1, E2;
identifier FP_NAME = bind_parameter_count;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_bind_null(args);


// FP: bind_parameter_index

@transform_assign_bind_parameter_index_arrow@
expression E1, E2;
identifier FP_NAME = bind_parameter_index;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_bind_parameter_count(args);


// FP: bind_parameter_name

@transform_assign_bind_parameter_name_arrow@
expression E1, E2;
identifier FP_NAME = bind_parameter_name;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_bind_parameter_index(args);


// FP: bind_text

@transform_assign_bind_text_arrow@
expression E1, E2;
identifier FP_NAME = bind_text;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_bind_parameter_name(args);


// FP: bind_text16

@transform_assign_bind_text16_arrow@
expression E1, E2;
identifier FP_NAME = bind_text16;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_bind_text(args);


// FP: bind_text64

@transform_assign_bind_text64_arrow@
expression E1, E2;
identifier FP_NAME = bind_text64;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_close_v2(args);


// FP: bind_value

@transform_assign_bind_value_arrow@
expression E1, E2;
identifier FP_NAME = bind_value;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_bind_text16(args);


// FP: bind_zeroblob

@transform_assign_bind_zeroblob_arrow@
expression E1, E2;
identifier FP_NAME = bind_zeroblob;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_prepare_v2(args);


// FP: bind_zeroblob64

@transform_assign_bind_zeroblob64_arrow@
expression E1, E2;
identifier FP_NAME = bind_zeroblob64;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_auto_extension(args);


// FP: blob_bytes

@transform_assign_blob_bytes_arrow@
expression E1, E2;
identifier FP_NAME = blob_bytes;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_prepare16_v2(args);


// FP: blob_close

@transform_assign_blob_close_arrow@
expression E1, E2;
identifier FP_NAME = blob_close;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_clear_bindings(args);


// FP: blob_open

@transform_assign_blob_open_arrow@
expression E1, E2;
identifier FP_NAME = blob_open;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_create_module_v2(args);


// FP: blob_read

@transform_assign_blob_read_arrow@
expression E1, E2;
identifier FP_NAME = blob_read;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_bind_zeroblob(args);


// FP: blob_reopen

@transform_assign_blob_reopen_arrow@
expression E1, E2;
identifier FP_NAME = blob_reopen;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_db_status(args);


// FP: blob_write

@transform_assign_blob_write_arrow@
expression E1, E2;
identifier FP_NAME = blob_write;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_blob_bytes(args);


// FP: busy_handler

@transform_assign_busy_handler_arrow@
expression E1, E2;
identifier FP_NAME = busy_handler;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_bind_value(args);


// FP: busy_timeout

@transform_assign_busy_timeout_arrow@
expression E1, E2;
identifier FP_NAME = busy_timeout;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_busy_handler(args);


// FP: cancel_auto_extension

@transform_assign_cancel_auto_extension_arrow@
expression E1, E2;
identifier FP_NAME = cancel_auto_extension;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_db_filename(args);


// FP: changes

@transform_assign_changes_arrow@
expression E1, E2;
identifier FP_NAME = changes;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_busy_timeout(args);


// FP: changes64

@transform_assign_changes64_arrow@
expression E1, E2;
identifier FP_NAME = changes64;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_str_value(args);


// FP: clear_bindings

@transform_assign_clear_bindings_arrow@
expression E1, E2;
identifier FP_NAME = clear_bindings;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_vmprintf(args);


// FP: close

@transform_assign_close_arrow@
expression E1, E2;
identifier FP_NAME = close;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_changes(args);


// FP: close_v2

@transform_assign_close_v2_arrow@
expression E1, E2;
identifier FP_NAME = close_v2;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_soft_heap_limit64(args);


// FP: collation_needed

@transform_assign_collation_needed_arrow@
expression E1, E2;
identifier FP_NAME = collation_needed;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_close(args);


// FP: collation_needed16

@transform_assign_collation_needed16_arrow@
expression E1, E2;
identifier FP_NAME = collation_needed16;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_collation_needed(args);


// FP: column_blob

@transform_assign_column_blob_arrow@
expression E1, E2;
identifier FP_NAME = column_blob;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_collation_needed16(args);


// FP: column_bytes

@transform_assign_column_bytes_arrow@
expression E1, E2;
identifier FP_NAME = column_bytes;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_column_blob(args);


// FP: column_bytes16

@transform_assign_column_bytes16_arrow@
expression E1, E2;
identifier FP_NAME = column_bytes16;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_column_bytes(args);


// FP: column_count

@transform_assign_column_count_arrow@
expression E1, E2;
identifier FP_NAME = column_count;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_column_bytes16(args);


// FP: column_database_name

@transform_assign_column_database_name_arrow@
expression E1, E2;
identifier FP_NAME = column_database_name;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_column_count(args);


// FP: column_database_name16

@transform_assign_column_database_name16_arrow@
expression E1, E2;
identifier FP_NAME = column_database_name16;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_column_database_name(args);


// FP: column_decltype

@transform_assign_column_decltype_arrow@
expression E1, E2;
identifier FP_NAME = column_decltype;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_column_database_name16(args);


// FP: column_decltype16

@transform_assign_column_decltype16_arrow@
expression E1, E2;
identifier FP_NAME = column_decltype16;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_column_decltype(args);


// FP: column_double

@transform_assign_column_double_arrow@
expression E1, E2;
identifier FP_NAME = column_double;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_column_decltype16(args);


// FP: column_int

@transform_assign_column_int_arrow@
expression E1, E2;
identifier FP_NAME = column_int;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_column_double(args);


// FP: column_int64

@transform_assign_column_int64_arrow@
expression E1, E2;
identifier FP_NAME = column_int64;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_column_int(args);


// FP: column_name

@transform_assign_column_name_arrow@
expression E1, E2;
identifier FP_NAME = column_name;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_column_int64(args);


// FP: column_name16

@transform_assign_column_name16_arrow@
expression E1, E2;
identifier FP_NAME = column_name16;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_column_name(args);


// FP: column_origin_name

@transform_assign_column_origin_name_arrow@
expression E1, E2;
identifier FP_NAME = column_origin_name;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_column_name16(args);


// FP: column_origin_name16

@transform_assign_column_origin_name16_arrow@
expression E1, E2;
identifier FP_NAME = column_origin_name16;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_column_origin_name(args);


// FP: column_table_name

@transform_assign_column_table_name_arrow@
expression E1, E2;
identifier FP_NAME = column_table_name;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_column_origin_name16(args);


// FP: column_table_name16

@transform_assign_column_table_name16_arrow@
expression E1, E2;
identifier FP_NAME = column_table_name16;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_column_table_name(args);


// FP: column_text

@transform_assign_column_text_arrow@
expression E1, E2;
identifier FP_NAME = column_text;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_column_table_name16(args);


// FP: column_text16

@transform_assign_column_text16_arrow@
expression E1, E2;
identifier FP_NAME = column_text16;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_column_text(args);


// FP: column_type

@transform_assign_column_type_arrow@
expression E1, E2;
identifier FP_NAME = column_type;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_column_text16(args);


// FP: column_value

@transform_assign_column_value_arrow@
expression E1, E2;
identifier FP_NAME = column_value;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_column_type(args);


// FP: commit_hook

@transform_assign_commit_hook_arrow@
expression E1, E2;
identifier FP_NAME = commit_hook;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_column_value(args);


// FP: compileoption_get

@transform_assign_compileoption_get_arrow@
expression E1, E2;
identifier FP_NAME = compileoption_get;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_limit(args);


// FP: compileoption_used

@transform_assign_compileoption_used_arrow@
expression E1, E2;
identifier FP_NAME = compileoption_used;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_next_stmt(args);


// FP: complete

@transform_assign_complete_arrow@
expression E1, E2;
identifier FP_NAME = complete;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_commit_hook(args);


// FP: complete16

@transform_assign_complete16_arrow@
expression E1, E2;
identifier FP_NAME = complete16;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_complete(args);


// FP: context_db_handle

@transform_assign_context_db_handle_arrow@
expression E1, E2;
identifier FP_NAME = context_db_handle;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_soft_heap_limit(args);


// FP: create_collation

@transform_assign_create_collation_arrow@
expression E1, E2;
identifier FP_NAME = create_collation;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_complete16(args);


// FP: create_collation16

@transform_assign_create_collation16_arrow@
expression E1, E2;
identifier FP_NAME = create_collation16;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_create_collation(args);


// FP: create_collation_v2

@transform_assign_create_collation_v2_arrow@
expression E1, E2;
identifier FP_NAME = create_collation_v2;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_blob_close(args);


// FP: create_filename

@transform_assign_create_filename_arrow@
expression E1, E2;
identifier FP_NAME = create_filename;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_str_appendchar(args);


// FP: create_function

@transform_assign_create_function_arrow@
expression E1, E2;
identifier FP_NAME = create_function;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_create_collation16(args);


// FP: create_function16

@transform_assign_create_function16_arrow@
expression E1, E2;
identifier FP_NAME = create_function16;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_create_function(args);


// FP: create_function_v2

@transform_assign_create_function_v2_arrow@
expression E1, E2;
identifier FP_NAME = create_function_v2;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_sql(args);


// FP: create_module

@transform_assign_create_module_arrow@
expression E1, E2;
identifier FP_NAME = create_module;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_create_function16(args);


// FP: create_module_v2

@transform_assign_create_module_v2_arrow@
expression E1, E2;
identifier FP_NAME = create_module_v2;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_overload_function(args);


// FP: create_window_function

@transform_assign_create_window_function_arrow@
expression E1, E2;
identifier FP_NAME = create_window_function;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_vtab_collation(args);


// FP: data_count

@transform_assign_data_count_arrow@
expression E1, E2;
identifier FP_NAME = data_count;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_create_module(args);


// FP: database_file_object

@transform_assign_database_file_object_arrow@
expression E1, E2;
identifier FP_NAME = database_file_object;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_str_errcode(args);


// FP: db_cacheflush

@transform_assign_db_cacheflush_arrow@
expression E1, E2;
identifier FP_NAME = db_cacheflush;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_malloc64(args);


// FP: db_config

@transform_assign_db_config_arrow@
expression E1, E2;
identifier FP_NAME = db_config;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_status(args);


// FP: db_filename

@transform_assign_db_filename_arrow@
expression E1, E2;
identifier FP_NAME = db_filename;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_sourceid(args);


// FP: db_handle

@transform_assign_db_handle_arrow@
expression E1, E2;
identifier FP_NAME = db_handle;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_data_count(args);


// FP: db_mutex

@transform_assign_db_mutex_arrow@
expression E1, E2;
identifier FP_NAME = db_mutex;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_backup_finish(args);


// FP: db_name

@transform_assign_db_name_arrow@
expression E1, E2;
identifier FP_NAME = db_name;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_filename_journal(args);


// FP: db_readonly

@transform_assign_db_readonly_arrow@
expression E1, E2;
identifier FP_NAME = db_readonly;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_stmt_status(args);


// FP: db_release_memory

@transform_assign_db_release_memory_arrow@
expression E1, E2;
identifier FP_NAME = db_release_memory;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_strnicmp(args);


// FP: db_status

@transform_assign_db_status_arrow@
expression E1, E2;
identifier FP_NAME = db_status;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_backup_init(args);


// FP: declare_vtab

@transform_assign_declare_vtab_arrow@
expression E1, E2;
identifier FP_NAME = declare_vtab;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_db_handle(args);


// FP: deserialize

@transform_assign_deserialize_arrow@
expression E1, E2;
identifier FP_NAME = deserialize;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_uri_key(args);


// FP: drop_modules

@transform_assign_drop_modules_arrow@
expression E1, E2;
identifier FP_NAME = drop_modules;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_str_new(args);


// FP: enable_shared_cache

@transform_assign_enable_shared_cache_arrow@
expression E1, E2;
identifier FP_NAME = enable_shared_cache;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_declare_vtab(args);


// FP: errcode

@transform_assign_errcode_arrow@
expression E1, E2;
identifier FP_NAME = errcode;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_enable_shared_cache(args);


// FP: errmsg

@transform_assign_errmsg_arrow@
expression E1, E2;
identifier FP_NAME = errmsg;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_errcode(args);


// FP: errmsg16

@transform_assign_errmsg16_arrow@
expression E1, E2;
identifier FP_NAME = errmsg16;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_errmsg(args);


// FP: exec

@transform_assign_exec_arrow@
expression E1, E2;
identifier FP_NAME = exec;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_errmsg16(args);


// FP: expanded_sql

@transform_assign_expanded_sql_arrow@
expression E1, E2;
identifier FP_NAME = expanded_sql;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_reset_auto_extension(args);


// FP: expired

@transform_assign_expired_arrow@
expression E1, E2;
identifier FP_NAME = expired;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->expired_signature, expired_signatures[expired_0_enum], sizeof(E2->expired_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->expired_signature, expired_signatures[expired_sqlite3_exec_enum], sizeof(E2->expired_signature)) == 0) {
+ E1 = sqlite3_exec(args);
+ }


// FP: extended_errcode

@transform_assign_extended_errcode_arrow@
expression E1, E2;
identifier FP_NAME = extended_errcode;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_backup_pagecount(args);


// FP: extended_result_codes

@transform_assign_extended_result_codes_arrow@
expression E1, E2;
identifier FP_NAME = extended_result_codes;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_vfs_find(args);


// FP: file_control

@transform_assign_file_control_arrow@
expression E1, E2;
identifier FP_NAME = file_control;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_blob_open(args);


// FP: filename_database

@transform_assign_filename_database_arrow@
expression E1, E2;
identifier FP_NAME = filename_database;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_str_vappendf(args);


// FP: filename_journal

@transform_assign_filename_journal_arrow@
expression E1, E2;
identifier FP_NAME = filename_journal;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_str_append(args);


// FP: filename_wal

@transform_assign_filename_wal_arrow@
expression E1, E2;
identifier FP_NAME = filename_wal;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_str_appendall(args);


// FP: free_filename

@transform_assign_free_filename_arrow@
expression E1, E2;
identifier FP_NAME = free_filename;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_str_reset(args);


// FP: get_autocommit

@transform_assign_get_autocommit_arrow@
expression E1, E2;
identifier FP_NAME = get_autocommit;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_free(args);


// FP: get_auxdata

@transform_assign_get_auxdata_arrow@
expression E1, E2;
identifier FP_NAME = get_auxdata;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_free_table(args);


// FP: get_clientdata

@transform_assign_get_clientdata_arrow@
expression E1, E2;
identifier FP_NAME = get_clientdata;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_database_file_object(args);


// FP: get_table

@transform_assign_get_table_arrow@
expression E1, E2;
identifier FP_NAME = get_table;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_get_autocommit(args);


// FP: global_recover

@transform_assign_global_recover_arrow@
expression E1, E2;
identifier FP_NAME = global_recover;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_get_auxdata(args);


// FP: hard_heap_limit64

@transform_assign_hard_heap_limit64_arrow@
expression E1, E2;
identifier FP_NAME = hard_heap_limit64;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_str_finish(args);


// FP: interruptx

@transform_assign_interruptx_arrow@
expression E1, E2;
identifier FP_NAME = interruptx;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_get_table(args);


// FP: is_interrupted

@transform_assign_is_interrupted_arrow@
expression E1, E2;
identifier FP_NAME = is_interrupted;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_create_filename(args);


// FP: keyword_check

@transform_assign_keyword_check_arrow@
expression E1, E2;
identifier FP_NAME = keyword_check;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_db_cacheflush(args);


// FP: keyword_count

@transform_assign_keyword_count_arrow@
expression E1, E2;
identifier FP_NAME = keyword_count;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_status64(args);


// FP: keyword_name

@transform_assign_keyword_name_arrow@
expression E1, E2;
identifier FP_NAME = keyword_name;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_strlike(args);


// FP: last_insert_rowid

@transform_assign_last_insert_rowid_arrow@
expression E1, E2;
identifier FP_NAME = last_insert_rowid;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = 0;


// FP: libversion

@transform_assign_libversion_arrow@
expression E1, E2;
identifier FP_NAME = libversion;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_interrupt(args);


// FP: libversion_number

@transform_assign_libversion_number_arrow@
expression E1, E2;
identifier FP_NAME = libversion_number;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_last_insert_rowid(args);


// FP: limit

@transform_assign_limit_arrow@
expression E1, E2;
identifier FP_NAME = limit;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_vfs_register(args);


// FP: load_extension

@transform_assign_load_extension_arrow@
expression E1, E2;
identifier FP_NAME = load_extension;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_db_readonly(args);


// FP: log

@transform_assign_log_arrow@
expression E1, E2;
identifier FP_NAME = log;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_backup_remaining(args);


// FP: malloc

@transform_assign_malloc_arrow@
expression E1, E2;
identifier FP_NAME = malloc;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_libversion(args);


// FP: malloc64

@transform_assign_malloc64_arrow@
expression E1, E2;
identifier FP_NAME = malloc64;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_db_release_memory(args);


// FP: memory_highwater

@transform_assign_memory_highwater_arrow@
expression E1, E2;
identifier FP_NAME = memory_highwater;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_blob_read(args);


// FP: memory_used

@transform_assign_memory_used_arrow@
expression E1, E2;
identifier FP_NAME = memory_used;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_blob_write(args);


// FP: mprintf

@transform_assign_mprintf_arrow@
expression E1, E2;
identifier FP_NAME = mprintf;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_libversion_number(args);


// FP: msize

@transform_assign_msize_arrow@
expression E1, E2;
identifier FP_NAME = msize;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_errstr(args);


// FP: mutex_alloc

@transform_assign_mutex_alloc_arrow@
expression E1, E2;
identifier FP_NAME = mutex_alloc;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_create_collation_v2(args);


// FP: mutex_enter

@transform_assign_mutex_enter_arrow@
expression E1, E2;
identifier FP_NAME = mutex_enter;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_file_control(args);


// FP: mutex_free

@transform_assign_mutex_free_arrow@
expression E1, E2;
identifier FP_NAME = mutex_free;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_memory_highwater(args);


// FP: mutex_leave

@transform_assign_mutex_leave_arrow@
expression E1, E2;
identifier FP_NAME = mutex_leave;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_memory_used(args);


// FP: next_stmt

@transform_assign_next_stmt_arrow@
expression E1, E2;
identifier FP_NAME = next_stmt;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_vfs_unregister(args);


// FP: normalized_sql

@transform_assign_normalized_sql_arrow@
expression E1, E2;
identifier FP_NAME = normalized_sql;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_keyword_count(args);


// FP: open

@transform_assign_open_arrow@
expression E1, E2;
identifier FP_NAME = open;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_malloc(args);


// FP: open16

@transform_assign_open16_arrow@
expression E1, E2;
identifier FP_NAME = open16;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_mprintf(args);


// FP: open_v2

@transform_assign_open_v2_arrow@
expression E1, E2;
identifier FP_NAME = open_v2;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = 0;


// FP: overload_function

@transform_assign_overload_function_arrow@
expression E1, E2;
identifier FP_NAME = overload_function;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_value_text16be(args);


// FP: prepare

@transform_assign_prepare_arrow@
expression E1, E2;
identifier FP_NAME = prepare;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_open(args);


// FP: prepare16

@transform_assign_prepare16_arrow@
expression E1, E2;
identifier FP_NAME = prepare16;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_open16(args);


// FP: prepare16_v2

@transform_assign_prepare16_v2_arrow@
expression E1, E2;
identifier FP_NAME = prepare16_v2;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_value_type(args);


// FP: prepare16_v3

@transform_assign_prepare16_v3_arrow@
expression E1, E2;
identifier FP_NAME = prepare16_v3;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_strglob(args);


// FP: prepare_v2

@transform_assign_prepare_v2_arrow@
expression E1, E2;
identifier FP_NAME = prepare_v2;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_value_text16le(args);


// FP: prepare_v3

@transform_assign_prepare_v3_arrow@
expression E1, E2;
identifier FP_NAME = prepare_v3;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_result_text64(args);


// FP: profile

@transform_assign_profile_arrow@
expression E1, E2;
identifier FP_NAME = profile;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_prepare(args);


// FP: progress_handler

@transform_assign_progress_handler_arrow@
expression E1, E2;
identifier FP_NAME = progress_handler;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_prepare16(args);


// FP: randomness

@transform_assign_randomness_arrow@
expression E1, E2;
identifier FP_NAME = randomness;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_sleep(args);


// FP: realloc

@transform_assign_realloc_arrow@
expression E1, E2;
identifier FP_NAME = realloc;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_profile(args);


// FP: realloc64

@transform_assign_realloc64_arrow@
expression E1, E2;
identifier FP_NAME = realloc64;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_stmt_busy(args);


// FP: release_memory

@transform_assign_release_memory_arrow@
expression E1, E2;
identifier FP_NAME = release_memory;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = 0;


// FP: reset

@transform_assign_reset_arrow@
expression E1, E2;
identifier FP_NAME = reset;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_progress_handler(args);


// FP: reset_auto_extension

@transform_assign_reset_auto_extension_arrow@
expression E1, E2;
identifier FP_NAME = reset_auto_extension;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_stmt_readonly(args);


// FP: result_blob

@transform_assign_result_blob_arrow@
expression E1, E2;
identifier FP_NAME = result_blob;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_realloc(args);


// FP: result_blob64

@transform_assign_result_blob64_arrow@
expression E1, E2;
identifier FP_NAME = result_blob64;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_stricmp(args);


// FP: result_double

@transform_assign_result_double_arrow@
expression E1, E2;
identifier FP_NAME = result_double;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_reset(args);


// FP: result_error

@transform_assign_result_error_arrow@
expression E1, E2;
identifier FP_NAME = result_error;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_result_blob(args);


// FP: result_error16

@transform_assign_result_error16_arrow@
expression E1, E2;
identifier FP_NAME = result_error16;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_result_double(args);


// FP: result_error_code

@transform_assign_result_error_code_arrow@
expression E1, E2;
identifier FP_NAME = result_error_code;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_result_error_nomem(args);


// FP: result_error_nomem

@transform_assign_result_error_nomem_arrow@
expression E1, E2;
identifier FP_NAME = result_error_nomem;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = 0;


// FP: result_error_toobig

@transform_assign_result_error_toobig_arrow@
expression E1, E2;
identifier FP_NAME = result_error_toobig;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = 0;


// FP: result_int

@transform_assign_result_int_arrow@
expression E1, E2;
identifier FP_NAME = result_int;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_result_error(args);


// FP: result_int64

@transform_assign_result_int64_arrow@
expression E1, E2;
identifier FP_NAME = result_int64;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_result_error16(args);


// FP: result_null

@transform_assign_result_null_arrow@
expression E1, E2;
identifier FP_NAME = result_null;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_result_int(args);


// FP: result_pointer

@transform_assign_result_pointer_arrow@
expression E1, E2;
identifier FP_NAME = result_pointer;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_value_free(args);


// FP: result_subtype

@transform_assign_result_subtype_arrow@
expression E1, E2;
identifier FP_NAME = result_subtype;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_bind_text64(args);


// FP: result_text

@transform_assign_result_text_arrow@
expression E1, E2;
identifier FP_NAME = result_text;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_result_int64(args);


// FP: result_text16

@transform_assign_result_text16_arrow@
expression E1, E2;
identifier FP_NAME = result_text16;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_result_null(args);


// FP: result_text16be

@transform_assign_result_text16be_arrow@
expression E1, E2;
identifier FP_NAME = result_text16be;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_result_text(args);


// FP: result_text16le

@transform_assign_result_text16le_arrow@
expression E1, E2;
identifier FP_NAME = result_text16le;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_result_text16(args);


// FP: result_text64

@transform_assign_result_text64_arrow@
expression E1, E2;
identifier FP_NAME = result_text64;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_uri_boolean(args);


// FP: result_value

@transform_assign_result_value_arrow@
expression E1, E2;
identifier FP_NAME = result_value;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_result_text16be(args);


// FP: result_zeroblob

@transform_assign_result_zeroblob_arrow@
expression E1, E2;
identifier FP_NAME = result_zeroblob;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_release_memory(args);


// FP: result_zeroblob64

@transform_assign_result_zeroblob64_arrow@
expression E1, E2;
identifier FP_NAME = result_zeroblob64;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_wal_checkpoint_v2(args);


// FP: rollback_hook

@transform_assign_rollback_hook_arrow@
expression E1, E2;
identifier FP_NAME = rollback_hook;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_result_text16le(args);


// FP: serialize

@transform_assign_serialize_arrow@
expression E1, E2;
identifier FP_NAME = serialize;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_filename_database(args);


// FP: set_authorizer

@transform_assign_set_authorizer_arrow@
expression E1, E2;
identifier FP_NAME = set_authorizer;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_result_value(args);


// FP: set_auxdata

@transform_assign_set_auxdata_arrow@
expression E1, E2;
identifier FP_NAME = set_auxdata;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_rollback_hook(args);


// FP: set_clientdata

@transform_assign_set_clientdata_arrow@
expression E1, E2;
identifier FP_NAME = set_clientdata;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_txn_state(args);


// FP: set_errmsg

@transform_assign_set_errmsg_arrow@
expression E1, E2;
identifier FP_NAME = set_errmsg;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_total_changes64(args);


// FP: set_last_insert_rowid

@transform_assign_set_last_insert_rowid_arrow@
expression E1, E2;
identifier FP_NAME = set_last_insert_rowid;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_result_blob64(args);


// FP: setlk_timeout

@transform_assign_setlk_timeout_arrow@
expression E1, E2;
identifier FP_NAME = setlk_timeout;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_changes64(args);


// FP: soft_heap_limit

@transform_assign_soft_heap_limit_arrow@
expression E1, E2;
identifier FP_NAME = soft_heap_limit;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_mutex_enter(args);


// FP: soft_heap_limit64

@transform_assign_soft_heap_limit64_arrow@
expression E1, E2;
identifier FP_NAME = soft_heap_limit64;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_backup_step(args);


// FP: sql

@transform_assign_sql_arrow@
expression E1, E2;
identifier FP_NAME = sql;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_threadsafe(args);


// FP: status

@transform_assign_status_arrow@
expression E1, E2;
identifier FP_NAME = status;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_result_zeroblob(args);


// FP: status64

@transform_assign_status64_arrow@
expression E1, E2;
identifier FP_NAME = status64;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_cancel_auto_extension(args);


// FP: step

@transform_assign_step_arrow@
expression E1, E2;
identifier FP_NAME = step;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_set_auxdata(args);


// FP: stmt_explain

@transform_assign_stmt_explain_arrow@
expression E1, E2;
identifier FP_NAME = stmt_explain;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_free_filename(args);


// FP: stmt_isexplain

@transform_assign_stmt_isexplain_arrow@
expression E1, E2;
identifier FP_NAME = stmt_isexplain;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_keyword_name(args);


// FP: stmt_status

@transform_assign_stmt_status_arrow@
expression E1, E2;
identifier FP_NAME = stmt_status;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_compileoption_used(args);


// FP: str_append

@transform_assign_str_append_arrow@
expression E1, E2;
identifier FP_NAME = str_append;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_prepare_v3(args);


// FP: str_appendall

@transform_assign_str_appendall_arrow@
expression E1, E2;
identifier FP_NAME = str_appendall;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_prepare16_v3(args);


// FP: str_appendchar

@transform_assign_str_appendchar_arrow@
expression E1, E2;
identifier FP_NAME = str_appendchar;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_bind_pointer(args);


// FP: str_appendf

@transform_assign_str_appendf_arrow@
expression E1, E2;
identifier FP_NAME = str_appendf;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_expanded_sql(args);


// FP: str_errcode

@transform_assign_str_errcode_arrow@
expression E1, E2;
identifier FP_NAME = str_errcode;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_value_pointer(args);


// FP: str_finish

@transform_assign_str_finish_arrow@
expression E1, E2;
identifier FP_NAME = str_finish;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_trace_v2(args);


// FP: str_length

@transform_assign_str_length_arrow@
expression E1, E2;
identifier FP_NAME = str_length;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_vtab_nochange(args);


// FP: str_new

@transform_assign_str_new_arrow@
expression E1, E2;
identifier FP_NAME = str_new;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_system_errno(args);


// FP: str_reset

@transform_assign_str_reset_arrow@
expression E1, E2;
identifier FP_NAME = str_reset;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_result_pointer(args);


// FP: str_value

@transform_assign_str_value_arrow@
expression E1, E2;
identifier FP_NAME = str_value;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_value_nochange(args);


// FP: str_vappendf

@transform_assign_str_vappendf_arrow@
expression E1, E2;
identifier FP_NAME = str_vappendf;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_set_last_insert_rowid(args);


// FP: strglob

@transform_assign_strglob_arrow@
expression E1, E2;
identifier FP_NAME = strglob;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_uri_int64(args);


// FP: stricmp

@transform_assign_stricmp_arrow@
expression E1, E2;
identifier FP_NAME = stricmp;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_wal_checkpoint(args);


// FP: strlike

@transform_assign_strlike_arrow@
expression E1, E2;
identifier FP_NAME = strlike;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_load_extension(args);


// FP: system_errno

@transform_assign_system_errno_arrow@
expression E1, E2;
identifier FP_NAME = system_errno;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_msize(args);


// FP: table_column_metadata

@transform_assign_table_column_metadata_arrow@
expression E1, E2;
identifier FP_NAME = table_column_metadata;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_snprintf(args);


// FP: test_control

@transform_assign_test_control_arrow@
expression E1, E2;
identifier FP_NAME = test_control;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_result_error_toobig(args);


// FP: thread_cleanup

@transform_assign_thread_cleanup_arrow@
expression E1, E2;
identifier FP_NAME = thread_cleanup;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_step(args);


// FP: total_changes

@transform_assign_total_changes_arrow@
expression E1, E2;
identifier FP_NAME = total_changes;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_table_column_metadata(args);


// FP: total_changes64

@transform_assign_total_changes64_arrow@
expression E1, E2;
identifier FP_NAME = total_changes64;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_create_window_function(args);


// FP: trace_v2

@transform_assign_trace_v2_arrow@
expression E1, E2;
identifier FP_NAME = trace_v2;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_realloc64(args);


// FP: txn_state

@transform_assign_txn_state_arrow@
expression E1, E2;
identifier FP_NAME = txn_state;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_str_length(args);


// FP: unlock_notify

@transform_assign_unlock_notify_arrow@
expression E1, E2;
identifier FP_NAME = unlock_notify;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = 0;


// FP: uri_boolean

@transform_assign_uri_boolean_arrow@
expression E1, E2;
identifier FP_NAME = uri_boolean;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_wal_hook(args);


// FP: uri_key

@transform_assign_uri_key_arrow@
expression E1, E2;
identifier FP_NAME = uri_key;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_str_appendf(args);


// FP: uri_parameter

@transform_assign_uri_parameter_arrow@
expression E1, E2;
identifier FP_NAME = uri_parameter;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = 0;


// FP: user_data

@transform_assign_user_data_arrow@
expression E1, E2;
identifier FP_NAME = user_data;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_trace(args);


// FP: value_double

@transform_assign_value_double_arrow@
expression E1, E2;
identifier FP_NAME = value_double;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_user_data(args);


// FP: value_dup

@transform_assign_value_dup_arrow@
expression E1, E2;
identifier FP_NAME = value_dup;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_uri_parameter(args);


// FP: value_encoding

@transform_assign_value_encoding_arrow@
expression E1, E2;
identifier FP_NAME = value_encoding;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_filename_wal(args);


// FP: value_free

@transform_assign_value_free_arrow@
expression E1, E2;
identifier FP_NAME = value_free;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_vsnprintf(args);


// FP: value_frombind

@transform_assign_value_frombind_arrow@
expression E1, E2;
identifier FP_NAME = value_frombind;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_keyword_check(args);


// FP: value_int

@transform_assign_value_int_arrow@
expression E1, E2;
identifier FP_NAME = value_int;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_value_blob(args);


// FP: value_int64

@transform_assign_value_int64_arrow@
expression E1, E2;
identifier FP_NAME = value_int64;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_value_bytes(args);


// FP: value_nochange

@transform_assign_value_nochange_arrow@
expression E1, E2;
identifier FP_NAME = value_nochange;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_value_subtype(args);


// FP: value_numeric_type

@transform_assign_value_numeric_type_arrow@
expression E1, E2;
identifier FP_NAME = value_numeric_type;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_value_bytes16(args);


// FP: value_pointer

@transform_assign_value_pointer_arrow@
expression E1, E2;
identifier FP_NAME = value_pointer;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_result_zeroblob64(args);


// FP: value_subtype

@transform_assign_value_subtype_arrow@
expression E1, E2;
identifier FP_NAME = value_subtype;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_bind_blob64(args);


// FP: value_text

@transform_assign_value_text_arrow@
expression E1, E2;
identifier FP_NAME = value_text;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_value_double(args);


// FP: value_text16

@transform_assign_value_text16_arrow@
expression E1, E2;
identifier FP_NAME = value_text16;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_value_int(args);


// FP: value_text16be

@transform_assign_value_text16be_arrow@
expression E1, E2;
identifier FP_NAME = value_text16be;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_value_int64(args);


// FP: value_text16le

@transform_assign_value_text16le_arrow@
expression E1, E2;
identifier FP_NAME = value_text16le;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_value_numeric_type(args);


// FP: value_type

@transform_assign_value_type_arrow@
expression E1, E2;
identifier FP_NAME = value_type;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_value_text(args);


// FP: vfs_find

@transform_assign_vfs_find_arrow@
expression E1, E2;
identifier FP_NAME = vfs_find;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_mutex_free(args);


// FP: vfs_register

@transform_assign_vfs_register_arrow@
expression E1, E2;
identifier FP_NAME = vfs_register;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_mutex_leave(args);


// FP: vfs_unregister

@transform_assign_vfs_unregister_arrow@
expression E1, E2;
identifier FP_NAME = vfs_unregister;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_mutex_try(args);


// FP: vmprintf

@transform_assign_vmprintf_arrow@
expression E1, E2;
identifier FP_NAME = vmprintf;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_value_text16(args);


// FP: vtab_collation

@transform_assign_vtab_collation_arrow@
expression E1, E2;
identifier FP_NAME = vtab_collation;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_result_subtype(args);


// FP: vtab_config

@transform_assign_vtab_config_arrow@
expression E1, E2;
identifier FP_NAME = vtab_config;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_extended_errcode(args);


// FP: vtab_distinct

@transform_assign_vtab_distinct_arrow@
expression E1, E2;
identifier FP_NAME = vtab_distinct;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_value_frombind(args);


// FP: vtab_nochange

@transform_assign_vtab_nochange_arrow@
expression E1, E2;
identifier FP_NAME = vtab_nochange;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_bind_zeroblob64(args);


// FP: vtab_on_conflict

@transform_assign_vtab_on_conflict_arrow@
expression E1, E2;
identifier FP_NAME = vtab_on_conflict;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_log(args);


// FP: wal_checkpoint

@transform_assign_wal_checkpoint_arrow@
expression E1, E2;
identifier FP_NAME = wal_checkpoint;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_db_config(args);


// FP: wal_hook

@transform_assign_wal_hook_arrow@
expression E1, E2;
identifier FP_NAME = wal_hook;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_db_mutex(args);


// FP: xAccess

@transform_assign_xAccess_arrow@
expression E1, E2;
identifier FP_NAME = xAccess;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xAccess_signature, xAccess_signatures[xAccess_apndAccess_enum], sizeof(E2->xAccess_signature)) == 0) {
+ E1 = apndAccess(args);
+ }
+ else if (memcmp(E2->xAccess_signature, xAccess_signatures[xAccess_memdbAccess_enum], sizeof(E2->xAccess_signature)) == 0) {
+ E1 = memdbAccess(args);
+ }
+ else if (memcmp(E2->xAccess_signature, xAccess_signatures[xAccess_vfstraceAccess_enum], sizeof(E2->xAccess_signature)) == 0) {
+ E1 = vfstraceAccess(args);
+ }
+ else if (memcmp(E2->xAccess_signature, xAccess_signatures[xAccess_unixAccess_enum], sizeof(E2->xAccess_signature)) == 0) {
+ E1 = unixAccess(args);
+ }


// FP: xAltLocaltime

@transform_assign_xAltLocaltime_arrow@
expression E1, E2;
identifier FP_NAME = xAltLocaltime;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = 0;


// FP: xAutovacDestr

@transform_assign_xAutovacDestr_arrow@
expression E1, E2;
identifier FP_NAME = xAutovacDestr;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xAutovacDestr_signature, xAutovacDestr_signatures[xAutovacDestr_0_enum], sizeof(E2->xAutovacDestr_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xAutovacDestr_signature, xAutovacDestr_signatures[xAutovacDestr_rtreeMatchArgFree_enum], sizeof(E2->xAutovacDestr_signature)) == 0) {
+ E1 = rtreeMatchArgFree(args);
+ }
+ else if (memcmp(E2->xAutovacDestr_signature, xAutovacDestr_signatures[xAutovacDestr_sqlite3VdbeValueListFree_enum], sizeof(E2->xAutovacDestr_signature)) == 0) {
+ E1 = sqlite3VdbeValueListFree(args);
+ }


// FP: xAutovacPages

@transform_assign_xAutovacPages_arrow@
expression E1, E2;
identifier FP_NAME = xAutovacPages;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xAutovacPages_signature, xAutovacPages_signatures[xAutovacPages_0_enum], sizeof(E2->xAutovacPages_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xAutovacPages_signature, xAutovacPages_signatures[xAutovacPages_sql_trace_callback_enum], sizeof(E2->xAutovacPages_signature)) == 0) {
+ E1 = sql_trace_callback(args);
+ }
+ else if (memcmp(E2->xAutovacPages_signature, xAutovacPages_signatures[xAutovacPages_sqlite3WalDefaultHook_enum], sizeof(E2->xAutovacPages_signature)) == 0) {
+ E1 = sqlite3WalDefaultHook(args);
+ }


// FP: xBegin

@transform_assign_xBegin_arrow@
expression E1, E2;
identifier FP_NAME = xBegin;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xBegin_signature, xBegin_signatures[xBegin_0_enum], sizeof(E2->xBegin_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xBegin_signature, xBegin_signatures[xBegin_dbpageBegin_enum], sizeof(E2->xBegin_signature)) == 0) {
+ E1 = dbpageBegin(args);
+ }
+ else if (memcmp(E2->xBegin_signature, xBegin_signatures[xBegin_fts3BeginMethod_enum], sizeof(E2->xBegin_signature)) == 0) {
+ E1 = fts3BeginMethod(args);
+ }
+ else if (memcmp(E2->xBegin_signature, xBegin_signatures[xBegin_rtreeBeginTransaction_enum], sizeof(E2->xBegin_signature)) == 0) {
+ E1 = rtreeBeginTransaction(args);
+ }
+ else if (memcmp(E2->xBegin_signature, xBegin_signatures[xBegin_zipfileBegin_enum], sizeof(E2->xBegin_signature)) == 0) {
+ E1 = zipfileBegin(args);
+ }


// FP: xBestIndex

@transform_assign_xBestIndex_arrow@
expression E1, E2;
identifier FP_NAME = xBestIndex;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xBestIndex_signature, xBestIndex_signatures[xBestIndex_bytecodevtabBestIndex_enum], sizeof(E2->xBestIndex_signature)) == 0) {
+ E1 = bytecodevtabBestIndex(args);
+ }
+ else if (memcmp(E2->xBestIndex_signature, xBestIndex_signatures[xBestIndex_completionBestIndex_enum], sizeof(E2->xBestIndex_signature)) == 0) {
+ E1 = completionBestIndex(args);
+ }
+ else if (memcmp(E2->xBestIndex_signature, xBestIndex_signatures[xBestIndex_dbdataBestIndex_enum], sizeof(E2->xBestIndex_signature)) == 0) {
+ E1 = dbdataBestIndex(args);
+ }
+ else if (memcmp(E2->xBestIndex_signature, xBestIndex_signatures[xBestIndex_dbpageBestIndex_enum], sizeof(E2->xBestIndex_signature)) == 0) {
+ E1 = dbpageBestIndex(args);
+ }
+ else if (memcmp(E2->xBestIndex_signature, xBestIndex_signatures[xBestIndex_expertBestIndex_enum], sizeof(E2->xBestIndex_signature)) == 0) {
+ E1 = expertBestIndex(args);
+ }
+ else if (memcmp(E2->xBestIndex_signature, xBestIndex_signatures[xBestIndex_fsdirBestIndex_enum], sizeof(E2->xBestIndex_signature)) == 0) {
+ E1 = fsdirBestIndex(args);
+ }
+ else if (memcmp(E2->xBestIndex_signature, xBestIndex_signatures[xBestIndex_fts3BestIndexMethod_enum], sizeof(E2->xBestIndex_signature)) == 0) {
+ E1 = fts3BestIndexMethod(args);
+ }
+ else if (memcmp(E2->xBestIndex_signature, xBestIndex_signatures[xBestIndex_fts3auxBestIndexMethod_enum], sizeof(E2->xBestIndex_signature)) == 0) {
+ E1 = fts3auxBestIndexMethod(args);
+ }
+ else if (memcmp(E2->xBestIndex_signature, xBestIndex_signatures[xBestIndex_fts3tokBestIndexMethod_enum], sizeof(E2->xBestIndex_signature)) == 0) {
+ E1 = fts3tokBestIndexMethod(args);
+ }
+ else if (memcmp(E2->xBestIndex_signature, xBestIndex_signatures[xBestIndex_jsonEachBestIndex_enum], sizeof(E2->xBestIndex_signature)) == 0) {
+ E1 = jsonEachBestIndex(args);
+ }
+ else if (memcmp(E2->xBestIndex_signature, xBestIndex_signatures[xBestIndex_pragmaVtabBestIndex_enum], sizeof(E2->xBestIndex_signature)) == 0) {
+ E1 = pragmaVtabBestIndex(args);
+ }
+ else if (memcmp(E2->xBestIndex_signature, xBestIndex_signatures[xBestIndex_rtreeBestIndex_enum], sizeof(E2->xBestIndex_signature)) == 0) {
+ E1 = rtreeBestIndex(args);
+ }
+ else if (memcmp(E2->xBestIndex_signature, xBestIndex_signatures[xBestIndex_seriesBestIndex_enum], sizeof(E2->xBestIndex_signature)) == 0) {
+ E1 = seriesBestIndex(args);
+ }
+ else if (memcmp(E2->xBestIndex_signature, xBestIndex_signatures[xBestIndex_statBestIndex_enum], sizeof(E2->xBestIndex_signature)) == 0) {
+ E1 = statBestIndex(args);
+ }
+ else if (memcmp(E2->xBestIndex_signature, xBestIndex_signatures[xBestIndex_stmtBestIndex_enum], sizeof(E2->xBestIndex_signature)) == 0) {
+ E1 = stmtBestIndex(args);
+ }
+ else if (memcmp(E2->xBestIndex_signature, xBestIndex_signatures[xBestIndex_zipfileBestIndex_enum], sizeof(E2->xBestIndex_signature)) == 0) {
+ E1 = zipfileBestIndex(args);
+ }


// FP: xBusyHandler

@transform_assign_xBusyHandler_arrow@
expression E1, E2;
identifier FP_NAME = xBusyHandler;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xBusyHandler_signature, xBusyHandler_signatures[xBusyHandler_0_enum], sizeof(E2->xBusyHandler_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xBusyHandler_signature, xBusyHandler_signatures[xBusyHandler_btreeInvokeBusyHandler_enum], sizeof(E2->xBusyHandler_signature)) == 0) {
+ E1 = btreeInvokeBusyHandler(args);
+ }
+ else if (memcmp(E2->xBusyHandler_signature, xBusyHandler_signatures[xBusyHandler_sqliteDefaultBusyCallback_enum], sizeof(E2->xBusyHandler_signature)) == 0) {
+ E1 = sqliteDefaultBusyCallback(args);
+ }
+ else if (memcmp(E2->xBusyHandler_signature, xBusyHandler_signatures[xBusyHandler_xBusyHandler_enum], sizeof(E2->xBusyHandler_signature)) == 0) {
+ E1 = xBusyHandler(args);
+ }


// FP: xCachesize

@transform_assign_xCachesize_arrow@
expression E1, E2;
identifier FP_NAME = xCachesize;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xCachesize_signature, xCachesize_signatures[xCachesize_pcache1Cachesize_enum], sizeof(E2->xCachesize_signature)) == 0) {
+ E1 = pcache1Cachesize(args);
+ }
+ else if (memcmp(E2->xCachesize_signature, xCachesize_signatures[xCachesize_pcachetraceCachesize_enum], sizeof(E2->xCachesize_signature)) == 0) {
+ E1 = pcachetraceCachesize(args);
+ }


// FP: xCellSize

@transform_assign_xCellSize_arrow@
expression E1, E2;
identifier FP_NAME = xCellSize;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xCellSize_signature, xCellSize_signatures[xCellSize_cellSizePtr_enum], sizeof(E2->xCellSize_signature)) == 0) {
+ E1 = cellSizePtr(args);
+ }
+ else if (memcmp(E2->xCellSize_signature, xCellSize_signatures[xCellSize_cellSizePtrIdxLeaf_enum], sizeof(E2->xCellSize_signature)) == 0) {
+ E1 = cellSizePtrIdxLeaf(args);
+ }
+ else if (memcmp(E2->xCellSize_signature, xCellSize_signatures[xCellSize_cellSizePtrNoPayload_enum], sizeof(E2->xCellSize_signature)) == 0) {
+ E1 = cellSizePtrNoPayload(args);
+ }
+ else if (memcmp(E2->xCellSize_signature, xCellSize_signatures[xCellSize_cellSizePtrTableLeaf_enum], sizeof(E2->xCellSize_signature)) == 0) {
+ E1 = cellSizePtrTableLeaf(args);
+ }


// FP: xCheckReservedLock

@transform_assign_xCheckReservedLock_arrow@
expression E1, E2;
identifier FP_NAME = xCheckReservedLock;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xCheckReservedLock_signature, xCheckReservedLock_signatures[xCheckReservedLock_0_enum], sizeof(E2->xCheckReservedLock_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xCheckReservedLock_signature, xCheckReservedLock_signatures[xCheckReservedLock_apndCheckReservedLock_enum], sizeof(E2->xCheckReservedLock_signature)) == 0) {
+ E1 = apndCheckReservedLock(args);
+ }
+ else if (memcmp(E2->xCheckReservedLock_signature, xCheckReservedLock_signatures[xCheckReservedLock_recoverVfsCheckReservedLock_enum], sizeof(E2->xCheckReservedLock_signature)) == 0) {
+ E1 = recoverVfsCheckReservedLock(args);
+ }
+ else if (memcmp(E2->xCheckReservedLock_signature, xCheckReservedLock_signatures[xCheckReservedLock_vfstraceCheckReservedLock_enum], sizeof(E2->xCheckReservedLock_signature)) == 0) {
+ E1 = vfstraceCheckReservedLock(args);
+ }


// FP: xCleanup

@transform_assign_xCleanup_arrow@
expression E1, E2;
identifier FP_NAME = xCleanup;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xCleanup_signature, xCleanup_signatures[xCleanup_agginfoFree_enum], sizeof(E2->xCleanup_signature)) == 0) {
+ E1 = agginfoFree(args);
+ }
+ else if (memcmp(E2->xCleanup_signature, xCleanup_signatures[xCleanup_sqlite3DbFree_enum], sizeof(E2->xCleanup_signature)) == 0) {
+ E1 = sqlite3DbFree(args);
+ }
+ else if (memcmp(E2->xCleanup_signature, xCleanup_signatures[xCleanup_sqlite3DeleteReturning_enum], sizeof(E2->xCleanup_signature)) == 0) {
+ E1 = sqlite3DeleteReturning(args);
+ }
+ else if (memcmp(E2->xCleanup_signature, xCleanup_signatures[xCleanup_sqlite3DeleteTableGeneric_enum], sizeof(E2->xCleanup_signature)) == 0) {
+ E1 = sqlite3DeleteTableGeneric(args);
+ }
+ else if (memcmp(E2->xCleanup_signature, xCleanup_signatures[xCleanup_sqlite3ExprDeleteGeneric_enum], sizeof(E2->xCleanup_signature)) == 0) {
+ E1 = sqlite3ExprDeleteGeneric(args);
+ }
+ else if (memcmp(E2->xCleanup_signature, xCleanup_signatures[xCleanup_sqlite3ExprListDeleteGeneric_enum], sizeof(E2->xCleanup_signature)) == 0) {
+ E1 = sqlite3ExprListDeleteGeneric(args);
+ }
+ else if (memcmp(E2->xCleanup_signature, xCleanup_signatures[xCleanup_sqlite3SelectDeleteGeneric_enum], sizeof(E2->xCleanup_signature)) == 0) {
+ E1 = sqlite3SelectDeleteGeneric(args);
+ }
+ else if (memcmp(E2->xCleanup_signature, xCleanup_signatures[xCleanup_sqlite3WithDeleteGeneric_enum], sizeof(E2->xCleanup_signature)) == 0) {
+ E1 = sqlite3WithDeleteGeneric(args);
+ }
+ else if (memcmp(E2->xCleanup_signature, xCleanup_signatures[xCleanup_whereIndexedExprCleanup_enum], sizeof(E2->xCleanup_signature)) == 0) {
+ E1 = whereIndexedExprCleanup(args);
+ }


// FP: xClose

@transform_assign_xClose_arrow@
expression E1, E2;
identifier FP_NAME = xClose;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xClose_signature, xClose_signatures[xClose_apndClose_enum], sizeof(E2->xClose_signature)) == 0) {
+ E1 = apndClose(args);
+ }
+ else if (memcmp(E2->xClose_signature, xClose_signatures[xClose_bytecodevtabClose_enum], sizeof(E2->xClose_signature)) == 0) {
+ E1 = bytecodevtabClose(args);
+ }
+ else if (memcmp(E2->xClose_signature, xClose_signatures[xClose_completionClose_enum], sizeof(E2->xClose_signature)) == 0) {
+ E1 = completionClose(args);
+ }
+ else if (memcmp(E2->xClose_signature, xClose_signatures[xClose_dbdataClose_enum], sizeof(E2->xClose_signature)) == 0) {
+ E1 = dbdataClose(args);
+ }
+ else if (memcmp(E2->xClose_signature, xClose_signatures[xClose_dbpageClose_enum], sizeof(E2->xClose_signature)) == 0) {
+ E1 = dbpageClose(args);
+ }
+ else if (memcmp(E2->xClose_signature, xClose_signatures[xClose_expertClose_enum], sizeof(E2->xClose_signature)) == 0) {
+ E1 = expertClose(args);
+ }
+ else if (memcmp(E2->xClose_signature, xClose_signatures[xClose_fsdirClose_enum], sizeof(E2->xClose_signature)) == 0) {
+ E1 = fsdirClose(args);
+ }
+ else if (memcmp(E2->xClose_signature, xClose_signatures[xClose_fts3CloseMethod_enum], sizeof(E2->xClose_signature)) == 0) {
+ E1 = fts3CloseMethod(args);
+ }
+ else if (memcmp(E2->xClose_signature, xClose_signatures[xClose_fts3auxCloseMethod_enum], sizeof(E2->xClose_signature)) == 0) {
+ E1 = fts3auxCloseMethod(args);
+ }
+ else if (memcmp(E2->xClose_signature, xClose_signatures[xClose_fts3tokCloseMethod_enum], sizeof(E2->xClose_signature)) == 0) {
+ E1 = fts3tokCloseMethod(args);
+ }
+ else if (memcmp(E2->xClose_signature, xClose_signatures[xClose_jsonEachClose_enum], sizeof(E2->xClose_signature)) == 0) {
+ E1 = jsonEachClose(args);
+ }
+ else if (memcmp(E2->xClose_signature, xClose_signatures[xClose_memdbClose_enum], sizeof(E2->xClose_signature)) == 0) {
+ E1 = memdbClose(args);
+ }
+ else if (memcmp(E2->xClose_signature, xClose_signatures[xClose_memjrnlClose_enum], sizeof(E2->xClose_signature)) == 0) {
+ E1 = memjrnlClose(args);
+ }
+ else if (memcmp(E2->xClose_signature, xClose_signatures[xClose_porterClose_enum], sizeof(E2->xClose_signature)) == 0) {
+ E1 = porterClose(args);
+ }
+ else if (memcmp(E2->xClose_signature, xClose_signatures[xClose_pragmaVtabClose_enum], sizeof(E2->xClose_signature)) == 0) {
+ E1 = pragmaVtabClose(args);
+ }
+ else if (memcmp(E2->xClose_signature, xClose_signatures[xClose_recoverVfsClose_enum], sizeof(E2->xClose_signature)) == 0) {
+ E1 = recoverVfsClose(args);
+ }
+ else if (memcmp(E2->xClose_signature, xClose_signatures[xClose_rtreeClose_enum], sizeof(E2->xClose_signature)) == 0) {
+ E1 = rtreeClose(args);
+ }
+ else if (memcmp(E2->xClose_signature, xClose_signatures[xClose_seriesClose_enum], sizeof(E2->xClose_signature)) == 0) {
+ E1 = seriesClose(args);
+ }
+ else if (memcmp(E2->xClose_signature, xClose_signatures[xClose_simpleClose_enum], sizeof(E2->xClose_signature)) == 0) {
+ E1 = simpleClose(args);
+ }
+ else if (memcmp(E2->xClose_signature, xClose_signatures[xClose_statClose_enum], sizeof(E2->xClose_signature)) == 0) {
+ E1 = statClose(args);
+ }
+ else if (memcmp(E2->xClose_signature, xClose_signatures[xClose_stmtClose_enum], sizeof(E2->xClose_signature)) == 0) {
+ E1 = stmtClose(args);
+ }
+ else if (memcmp(E2->xClose_signature, xClose_signatures[xClose_unicodeClose_enum], sizeof(E2->xClose_signature)) == 0) {
+ E1 = unicodeClose(args);
+ }
+ else if (memcmp(E2->xClose_signature, xClose_signatures[xClose_vfstraceClose_enum], sizeof(E2->xClose_signature)) == 0) {
+ E1 = vfstraceClose(args);
+ }
+ else if (memcmp(E2->xClose_signature, xClose_signatures[xClose_zipfileClose_enum], sizeof(E2->xClose_signature)) == 0) {
+ E1 = zipfileClose(args);
+ }


// FP: xCmp

@transform_assign_xCmp_arrow@
expression E1, E2;
identifier FP_NAME = xCmp;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xCmp_signature, xCmp_signatures[xCmp_0_enum], sizeof(E2->xCmp_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xCmp_signature, xCmp_signatures[xCmp_binCollFunc_enum], sizeof(E2->xCmp_signature)) == 0) {
+ E1 = binCollFunc(args);
+ }
+ else if (memcmp(E2->xCmp_signature, xCmp_signatures[xCmp_decimalCollFunc_enum], sizeof(E2->xCmp_signature)) == 0) {
+ E1 = decimalCollFunc(args);
+ }
+ else if (memcmp(E2->xCmp_signature, xCmp_signatures[xCmp_dummyCompare_enum], sizeof(E2->xCmp_signature)) == 0) {
+ E1 = dummyCompare(args);
+ }
+ else if (memcmp(E2->xCmp_signature, xCmp_signatures[xCmp_icuCollationColl_enum], sizeof(E2->xCmp_signature)) == 0) {
+ E1 = icuCollationColl(args);
+ }
+ else if (memcmp(E2->xCmp_signature, xCmp_signatures[xCmp_nocaseCollatingFunc_enum], sizeof(E2->xCmp_signature)) == 0) {
+ E1 = nocaseCollatingFunc(args);
+ }
+ else if (memcmp(E2->xCmp_signature, xCmp_signatures[xCmp_rtrimCollFunc_enum], sizeof(E2->xCmp_signature)) == 0) {
+ E1 = rtrimCollFunc(args);
+ }
+ else if (memcmp(E2->xCmp_signature, xCmp_signatures[xCmp_uintCollFunc_enum], sizeof(E2->xCmp_signature)) == 0) {
+ E1 = uintCollFunc(args);
+ }


// FP: xCollNeeded16

@transform_assign_xCollNeeded16_arrow@
expression E1, E2;
identifier FP_NAME = xCollNeeded16;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = 0;


// FP: xColumn

@transform_assign_xColumn_arrow@
expression E1, E2;
identifier FP_NAME = xColumn;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xColumn_signature, xColumn_signatures[xColumn_bytecodevtabColumn_enum], sizeof(E2->xColumn_signature)) == 0) {
+ E1 = bytecodevtabColumn(args);
+ }
+ else if (memcmp(E2->xColumn_signature, xColumn_signatures[xColumn_completionColumn_enum], sizeof(E2->xColumn_signature)) == 0) {
+ E1 = completionColumn(args);
+ }
+ else if (memcmp(E2->xColumn_signature, xColumn_signatures[xColumn_dbdataColumn_enum], sizeof(E2->xColumn_signature)) == 0) {
+ E1 = dbdataColumn(args);
+ }
+ else if (memcmp(E2->xColumn_signature, xColumn_signatures[xColumn_dbpageColumn_enum], sizeof(E2->xColumn_signature)) == 0) {
+ E1 = dbpageColumn(args);
+ }
+ else if (memcmp(E2->xColumn_signature, xColumn_signatures[xColumn_expertColumn_enum], sizeof(E2->xColumn_signature)) == 0) {
+ E1 = expertColumn(args);
+ }
+ else if (memcmp(E2->xColumn_signature, xColumn_signatures[xColumn_fsdirColumn_enum], sizeof(E2->xColumn_signature)) == 0) {
+ E1 = fsdirColumn(args);
+ }
+ else if (memcmp(E2->xColumn_signature, xColumn_signatures[xColumn_fts3ColumnMethod_enum], sizeof(E2->xColumn_signature)) == 0) {
+ E1 = fts3ColumnMethod(args);
+ }
+ else if (memcmp(E2->xColumn_signature, xColumn_signatures[xColumn_fts3auxColumnMethod_enum], sizeof(E2->xColumn_signature)) == 0) {
+ E1 = fts3auxColumnMethod(args);
+ }
+ else if (memcmp(E2->xColumn_signature, xColumn_signatures[xColumn_fts3tokColumnMethod_enum], sizeof(E2->xColumn_signature)) == 0) {
+ E1 = fts3tokColumnMethod(args);
+ }
+ else if (memcmp(E2->xColumn_signature, xColumn_signatures[xColumn_geopolyColumn_enum], sizeof(E2->xColumn_signature)) == 0) {
+ E1 = geopolyColumn(args);
+ }
+ else if (memcmp(E2->xColumn_signature, xColumn_signatures[xColumn_jsonEachColumn_enum], sizeof(E2->xColumn_signature)) == 0) {
+ E1 = jsonEachColumn(args);
+ }
+ else if (memcmp(E2->xColumn_signature, xColumn_signatures[xColumn_pragmaVtabColumn_enum], sizeof(E2->xColumn_signature)) == 0) {
+ E1 = pragmaVtabColumn(args);
+ }
+ else if (memcmp(E2->xColumn_signature, xColumn_signatures[xColumn_rtreeColumn_enum], sizeof(E2->xColumn_signature)) == 0) {
+ E1 = rtreeColumn(args);
+ }
+ else if (memcmp(E2->xColumn_signature, xColumn_signatures[xColumn_seriesColumn_enum], sizeof(E2->xColumn_signature)) == 0) {
+ E1 = seriesColumn(args);
+ }
+ else if (memcmp(E2->xColumn_signature, xColumn_signatures[xColumn_statColumn_enum], sizeof(E2->xColumn_signature)) == 0) {
+ E1 = statColumn(args);
+ }
+ else if (memcmp(E2->xColumn_signature, xColumn_signatures[xColumn_stmtColumn_enum], sizeof(E2->xColumn_signature)) == 0) {
+ E1 = stmtColumn(args);
+ }
+ else if (memcmp(E2->xColumn_signature, xColumn_signatures[xColumn_zipfileColumn_enum], sizeof(E2->xColumn_signature)) == 0) {
+ E1 = zipfileColumn(args);
+ }


// FP: xCommit

@transform_assign_xCommit_arrow@
expression E1, E2;
identifier FP_NAME = xCommit;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xCommit_signature, xCommit_signatures[xCommit_0_enum], sizeof(E2->xCommit_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xCommit_signature, xCommit_signatures[xCommit_fts3CommitMethod_enum], sizeof(E2->xCommit_signature)) == 0) {
+ E1 = fts3CommitMethod(args);
+ }
+ else if (memcmp(E2->xCommit_signature, xCommit_signatures[xCommit_rtreeEndTransaction_enum], sizeof(E2->xCommit_signature)) == 0) {
+ E1 = rtreeEndTransaction(args);
+ }
+ else if (memcmp(E2->xCommit_signature, xCommit_signatures[xCommit_zipfileCommit_enum], sizeof(E2->xCommit_signature)) == 0) {
+ E1 = zipfileCommit(args);
+ }


// FP: xCommitCallback

@transform_assign_xCommitCallback_arrow@
expression E1, E2;
identifier FP_NAME = xCommitCallback;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xCommitCallback_signature, xCommitCallback_signatures[xCommitCallback_0_enum], sizeof(E2->xCommitCallback_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xCommitCallback_signature, xCommitCallback_signatures[xCommitCallback_sql_trace_callback_enum], sizeof(E2->xCommitCallback_signature)) == 0) {
+ E1 = sql_trace_callback(args);
+ }
+ else if (memcmp(E2->xCommitCallback_signature, xCommitCallback_signatures[xCommitCallback_sqlite3WalDefaultHook_enum], sizeof(E2->xCommitCallback_signature)) == 0) {
+ E1 = sqlite3WalDefaultHook(args);
+ }


// FP: xConnect

@transform_assign_xConnect_arrow@
expression E1, E2;
identifier FP_NAME = xConnect;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xConnect_signature, xConnect_signatures[xConnect_bytecodevtabConnect_enum], sizeof(E2->xConnect_signature)) == 0) {
+ E1 = bytecodevtabConnect(args);
+ }
+ else if (memcmp(E2->xConnect_signature, xConnect_signatures[xConnect_dbpageConnect_enum], sizeof(E2->xConnect_signature)) == 0) {
+ E1 = dbpageConnect(args);
+ }
+ else if (memcmp(E2->xConnect_signature, xConnect_signatures[xConnect_fts3ConnectMethod_enum], sizeof(E2->xConnect_signature)) == 0) {
+ E1 = fts3ConnectMethod(args);
+ }
+ else if (memcmp(E2->xConnect_signature, xConnect_signatures[xConnect_fts3auxConnectMethod_enum], sizeof(E2->xConnect_signature)) == 0) {
+ E1 = fts3auxConnectMethod(args);
+ }
+ else if (memcmp(E2->xConnect_signature, xConnect_signatures[xConnect_fts3tokConnectMethod_enum], sizeof(E2->xConnect_signature)) == 0) {
+ E1 = fts3tokConnectMethod(args);
+ }
+ else if (memcmp(E2->xConnect_signature, xConnect_signatures[xConnect_jsonEachConnect_enum], sizeof(E2->xConnect_signature)) == 0) {
+ E1 = jsonEachConnect(args);
+ }
+ else if (memcmp(E2->xConnect_signature, xConnect_signatures[xConnect_pragmaVtabConnect_enum], sizeof(E2->xConnect_signature)) == 0) {
+ E1 = pragmaVtabConnect(args);
+ }
+ else if (memcmp(E2->xConnect_signature, xConnect_signatures[xConnect_rtreeConnect_enum], sizeof(E2->xConnect_signature)) == 0) {
+ E1 = rtreeConnect(args);
+ }
+ else if (memcmp(E2->xConnect_signature, xConnect_signatures[xConnect_statConnect_enum], sizeof(E2->xConnect_signature)) == 0) {
+ E1 = statConnect(args);
+ }
+ else if (memcmp(E2->xConnect_signature, xConnect_signatures[xConnect_stmtConnect_enum], sizeof(E2->xConnect_signature)) == 0) {
+ E1 = stmtConnect(args);
+ }


// FP: xCount

@transform_assign_xCount_arrow@
expression E1, E2;
identifier FP_NAME = xCount;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xCount_signature, xCount_signatures[xCount_sessionDiffCount_enum], sizeof(E2->xCount_signature)) == 0) {
+ E1 = sessionDiffCount(args);
+ }
+ else if (memcmp(E2->xCount_signature, xCount_signatures[xCount_sessionPreupdateCount_enum], sizeof(E2->xCount_signature)) == 0) {
+ E1 = sessionPreupdateCount(args);
+ }
+ else if (memcmp(E2->xCount_signature, xCount_signatures[xCount_sessionStat1Count_enum], sizeof(E2->xCount_signature)) == 0) {
+ E1 = sessionStat1Count(args);
+ }


// FP: xCreate

@transform_assign_xCreate_arrow@
expression E1, E2;
identifier FP_NAME = xCreate;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xCreate_signature, xCreate_signatures[xCreate_0_enum], sizeof(E2->xCreate_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xCreate_signature, xCreate_signatures[xCreate_dbpageConnect_enum], sizeof(E2->xCreate_signature)) == 0) {
+ E1 = dbpageConnect(args);
+ }
+ else if (memcmp(E2->xCreate_signature, xCreate_signatures[xCreate_fts3CreateMethod_enum], sizeof(E2->xCreate_signature)) == 0) {
+ E1 = fts3CreateMethod(args);
+ }
+ else if (memcmp(E2->xCreate_signature, xCreate_signatures[xCreate_fts3auxConnectMethod_enum], sizeof(E2->xCreate_signature)) == 0) {
+ E1 = fts3auxConnectMethod(args);
+ }
+ else if (memcmp(E2->xCreate_signature, xCreate_signatures[xCreate_fts3tokConnectMethod_enum], sizeof(E2->xCreate_signature)) == 0) {
+ E1 = fts3tokConnectMethod(args);
+ }
+ else if (memcmp(E2->xCreate_signature, xCreate_signatures[xCreate_geopolyCreate_enum], sizeof(E2->xCreate_signature)) == 0) {
+ E1 = geopolyCreate(args);
+ }
+ else if (memcmp(E2->xCreate_signature, xCreate_signatures[xCreate_pcache1Create_enum], sizeof(E2->xCreate_signature)) == 0) {
+ E1 = pcache1Create(args);
+ }
+ else if (memcmp(E2->xCreate_signature, xCreate_signatures[xCreate_pcachetraceCreate_enum], sizeof(E2->xCreate_signature)) == 0) {
+ E1 = pcachetraceCreate(args);
+ }
+ else if (memcmp(E2->xCreate_signature, xCreate_signatures[xCreate_porterCreate_enum], sizeof(E2->xCreate_signature)) == 0) {
+ E1 = porterCreate(args);
+ }
+ else if (memcmp(E2->xCreate_signature, xCreate_signatures[xCreate_rtreeCreate_enum], sizeof(E2->xCreate_signature)) == 0) {
+ E1 = rtreeCreate(args);
+ }
+ else if (memcmp(E2->xCreate_signature, xCreate_signatures[xCreate_simpleCreate_enum], sizeof(E2->xCreate_signature)) == 0) {
+ E1 = simpleCreate(args);
+ }
+ else if (memcmp(E2->xCreate_signature, xCreate_signatures[xCreate_statConnect_enum], sizeof(E2->xCreate_signature)) == 0) {
+ E1 = statConnect(args);
+ }
+ else if (memcmp(E2->xCreate_signature, xCreate_signatures[xCreate_unicodeCreate_enum], sizeof(E2->xCreate_signature)) == 0) {
+ E1 = unicodeCreate(args);
+ }


// FP: xCurrentTime

@transform_assign_xCurrentTime_arrow@
expression E1, E2;
identifier FP_NAME = xCurrentTime;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xCurrentTime_signature, xCurrentTime_signatures[xCurrentTime_0_enum], sizeof(E2->xCurrentTime_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xCurrentTime_signature, xCurrentTime_signatures[xCurrentTime_apndCurrentTime_enum], sizeof(E2->xCurrentTime_signature)) == 0) {
+ E1 = apndCurrentTime(args);
+ }
+ else if (memcmp(E2->xCurrentTime_signature, xCurrentTime_signatures[xCurrentTime_vfstraceCurrentTime_enum], sizeof(E2->xCurrentTime_signature)) == 0) {
+ E1 = vfstraceCurrentTime(args);
+ }
+ else if (memcmp(E2->xCurrentTime_signature, xCurrentTime_signatures[xCurrentTime_unixCurrentTime_enum], sizeof(E2->xCurrentTime_signature)) == 0) {
+ E1 = unixCurrentTime(args);
+ }


// FP: xCurrentTimeInt64

@transform_assign_xCurrentTimeInt64_arrow@
expression E1, E2;
identifier FP_NAME = xCurrentTimeInt64;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xCurrentTimeInt64_signature, xCurrentTimeInt64_signatures[xCurrentTimeInt64_apndCurrentTimeInt64_enum], sizeof(E2->xCurrentTimeInt64_signature)) == 0) {
+ E1 = apndCurrentTimeInt64(args);
+ }
+ else if (memcmp(E2->xCurrentTimeInt64_signature, xCurrentTimeInt64_signatures[xCurrentTimeInt64_memdbCurrentTimeInt64_enum], sizeof(E2->xCurrentTimeInt64_signature)) == 0) {
+ E1 = memdbCurrentTimeInt64(args);
+ }
+ else if (memcmp(E2->xCurrentTimeInt64_signature, xCurrentTimeInt64_signatures[xCurrentTimeInt64_unixCurrentTimeInt64_enum], sizeof(E2->xCurrentTimeInt64_signature)) == 0) {
+ E1 = unixCurrentTimeInt64(args);
+ }


// FP: xDel

@transform_assign_xDel_arrow@
expression E1, E2;
identifier FP_NAME = xDel;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xDel_signature, xDel_signatures[xDel_0_enum], sizeof(E2->xDel_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xDel_signature, xDel_signatures[xDel_SQLITE_DYNAMIC_enum], sizeof(E2->xDel_signature)) == 0) {
+ E1 = SQLITE_DYNAMIC(args);
+ }
+ else if (memcmp(E2->xDel_signature, xDel_signatures[xDel_SQLITE_STATIC_enum], sizeof(E2->xDel_signature)) == 0) {
+ E1 = SQLITE_STATIC(args);
+ }
+ else if (memcmp(E2->xDel_signature, xDel_signatures[xDel_SQLITE_TRANSIENT_enum], sizeof(E2->xDel_signature)) == 0) {
+ E1 = SQLITE_TRANSIENT(args);
+ }
+ else if (memcmp(E2->xDel_signature, xDel_signatures[xDel_rtreeMatchArgFree_enum], sizeof(E2->xDel_signature)) == 0) {
+ E1 = rtreeMatchArgFree(args);
+ }
+ else if (memcmp(E2->xDel_signature, xDel_signatures[xDel_sqlite3RCStrUnref_enum], sizeof(E2->xDel_signature)) == 0) {
+ E1 = sqlite3RCStrUnref(args);
+ }
+ else if (memcmp(E2->xDel_signature, xDel_signatures[xDel_sqlite3RowSetDelete_enum], sizeof(E2->xDel_signature)) == 0) {
+ E1 = sqlite3RowSetDelete(args);
+ }
+ else if (memcmp(E2->xDel_signature, xDel_signatures[xDel_sqlite3SchemaClear_enum], sizeof(E2->xDel_signature)) == 0) {
+ E1 = sqlite3SchemaClear(args);
+ }
+ else if (memcmp(E2->xDel_signature, xDel_signatures[xDel_sqlite3VdbeFrameMemDel_enum], sizeof(E2->xDel_signature)) == 0) {
+ E1 = sqlite3VdbeFrameMemDel(args);
+ }
+ else if (memcmp(E2->xDel_signature, xDel_signatures[xDel_sqlite3VdbeValueListFree_enum], sizeof(E2->xDel_signature)) == 0) {
+ E1 = sqlite3VdbeValueListFree(args);
+ }
+ else if (memcmp(E2->xDel_signature, xDel_signatures[xDel_sqlite3_free_enum], sizeof(E2->xDel_signature)) == 0) {
+ E1 = sqlite3_free(args);
+ }
+ else if (memcmp(E2->xDel_signature, xDel_signatures[xDel_statAccumDestructor_enum], sizeof(E2->xDel_signature)) == 0) {
+ E1 = statAccumDestructor(args);
+ }
+ else if (memcmp(E2->xDel_signature, xDel_signatures[xDel_xDel_enum], sizeof(E2->xDel_signature)) == 0) {
+ E1 = xDel(args);
+ }
+ else if (memcmp(E2->xDel_signature, xDel_signatures[xDel_zipfileFree_enum], sizeof(E2->xDel_signature)) == 0) {
+ E1 = zipfileFree(args);
+ }


// FP: xDelete

@transform_assign_xDelete_arrow@
expression E1, E2;
identifier FP_NAME = xDelete;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xDelete_signature, xDelete_signatures[xDelete_0_enum], sizeof(E2->xDelete_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xDelete_signature, xDelete_signatures[xDelete_apndDelete_enum], sizeof(E2->xDelete_signature)) == 0) {
+ E1 = apndDelete(args);
+ }
+ else if (memcmp(E2->xDelete_signature, xDelete_signatures[xDelete_jsonCacheDeleteGeneric_enum], sizeof(E2->xDelete_signature)) == 0) {
+ E1 = jsonCacheDeleteGeneric(args);
+ }
+ else if (memcmp(E2->xDelete_signature, xDelete_signatures[xDelete_kvstorageDelete_enum], sizeof(E2->xDelete_signature)) == 0) {
+ E1 = kvstorageDelete(args);
+ }
+ else if (memcmp(E2->xDelete_signature, xDelete_signatures[xDelete_sqlite3_free_enum], sizeof(E2->xDelete_signature)) == 0) {
+ E1 = sqlite3_free(args);
+ }
+ else if (memcmp(E2->xDelete_signature, xDelete_signatures[xDelete_vfstraceDelete_enum], sizeof(E2->xDelete_signature)) == 0) {
+ E1 = vfstraceDelete(args);
+ }
+ else if (memcmp(E2->xDelete_signature, xDelete_signatures[xDelete_unixDelete_enum], sizeof(E2->xDelete_signature)) == 0) {
+ E1 = unixDelete(args);
+ }


// FP: xDeleteAux

@transform_assign_xDeleteAux_arrow@
expression E1, E2;
identifier FP_NAME = xDeleteAux;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xDeleteAux_signature, xDeleteAux_signatures[xDeleteAux_jsonCacheDeleteGeneric_enum], sizeof(E2->xDeleteAux_signature)) == 0) {
+ E1 = jsonCacheDeleteGeneric(args);
+ }
+ else if (memcmp(E2->xDeleteAux_signature, xDeleteAux_signatures[xDeleteAux_sqlite3_free_enum], sizeof(E2->xDeleteAux_signature)) == 0) {
+ E1 = sqlite3_free(args);
+ }


// FP: xDepth

@transform_assign_xDepth_arrow@
expression E1, E2;
identifier FP_NAME = xDepth;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xDepth_signature, xDepth_signatures[xDepth_sessionDiffDepth_enum], sizeof(E2->xDepth_signature)) == 0) {
+ E1 = sessionDiffDepth(args);
+ }
+ else if (memcmp(E2->xDepth_signature, xDepth_signatures[xDepth_sessionPreupdateDepth_enum], sizeof(E2->xDepth_signature)) == 0) {
+ E1 = sessionPreupdateDepth(args);
+ }
+ else if (memcmp(E2->xDepth_signature, xDepth_signatures[xDepth_sessionStat1Depth_enum], sizeof(E2->xDepth_signature)) == 0) {
+ E1 = sessionStat1Depth(args);
+ }


// FP: xDestroy

@transform_assign_xDestroy_arrow@
expression E1, E2;
identifier FP_NAME = xDestroy;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xDestroy_signature, xDestroy_signatures[xDestroy_0_enum], sizeof(E2->xDestroy_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xDestroy_signature, xDestroy_signatures[xDestroy_dbpageDisconnect_enum], sizeof(E2->xDestroy_signature)) == 0) {
+ E1 = dbpageDisconnect(args);
+ }
+ else if (memcmp(E2->xDestroy_signature, xDestroy_signatures[xDestroy_expertDisconnect_enum], sizeof(E2->xDestroy_signature)) == 0) {
+ E1 = expertDisconnect(args);
+ }
+ else if (memcmp(E2->xDestroy_signature, xDestroy_signatures[xDestroy_fts3DestroyMethod_enum], sizeof(E2->xDestroy_signature)) == 0) {
+ E1 = fts3DestroyMethod(args);
+ }
+ else if (memcmp(E2->xDestroy_signature, xDestroy_signatures[xDestroy_fts3auxDisconnectMethod_enum], sizeof(E2->xDestroy_signature)) == 0) {
+ E1 = fts3auxDisconnectMethod(args);
+ }
+ else if (memcmp(E2->xDestroy_signature, xDestroy_signatures[xDestroy_fts3tokDisconnectMethod_enum], sizeof(E2->xDestroy_signature)) == 0) {
+ E1 = fts3tokDisconnectMethod(args);
+ }
+ else if (memcmp(E2->xDestroy_signature, xDestroy_signatures[xDestroy_hashDestroy_enum], sizeof(E2->xDestroy_signature)) == 0) {
+ E1 = hashDestroy(args);
+ }
+ else if (memcmp(E2->xDestroy_signature, xDestroy_signatures[xDestroy_pcache1Destroy_enum], sizeof(E2->xDestroy_signature)) == 0) {
+ E1 = pcache1Destroy(args);
+ }
+ else if (memcmp(E2->xDestroy_signature, xDestroy_signatures[xDestroy_pcachetraceDestroy_enum], sizeof(E2->xDestroy_signature)) == 0) {
+ E1 = pcachetraceDestroy(args);
+ }
+ else if (memcmp(E2->xDestroy_signature, xDestroy_signatures[xDestroy_porterDestroy_enum], sizeof(E2->xDestroy_signature)) == 0) {
+ E1 = porterDestroy(args);
+ }
+ else if (memcmp(E2->xDestroy_signature, xDestroy_signatures[xDestroy_rtreeDestroy_enum], sizeof(E2->xDestroy_signature)) == 0) {
+ E1 = rtreeDestroy(args);
+ }
+ else if (memcmp(E2->xDestroy_signature, xDestroy_signatures[xDestroy_rtreeFreeCallback_enum], sizeof(E2->xDestroy_signature)) == 0) {
+ E1 = rtreeFreeCallback(args);
+ }
+ else if (memcmp(E2->xDestroy_signature, xDestroy_signatures[xDestroy_simpleDestroy_enum], sizeof(E2->xDestroy_signature)) == 0) {
+ E1 = simpleDestroy(args);
+ }
+ else if (memcmp(E2->xDestroy_signature, xDestroy_signatures[xDestroy_sqlite3_free_enum], sizeof(E2->xDestroy_signature)) == 0) {
+ E1 = sqlite3_free(args);
+ }
+ else if (memcmp(E2->xDestroy_signature, xDestroy_signatures[xDestroy_statDisconnect_enum], sizeof(E2->xDestroy_signature)) == 0) {
+ E1 = statDisconnect(args);
+ }
+ else if (memcmp(E2->xDestroy_signature, xDestroy_signatures[xDestroy_unicodeDestroy_enum], sizeof(E2->xDestroy_signature)) == 0) {
+ E1 = unicodeDestroy(args);
+ }
+ else if (memcmp(E2->xDestroy_signature, xDestroy_signatures[xDestroy_zipfileDisconnect_enum], sizeof(E2->xDestroy_signature)) == 0) {
+ E1 = zipfileDisconnect(args);
+ }


// FP: xDestructor

@transform_assign_xDestructor_arrow@
expression E1, E2;
identifier FP_NAME = xDestructor;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xDestructor_signature, xDestructor_signatures[xDestructor_0_enum], sizeof(E2->xDestructor_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xDestructor_signature, xDestructor_signatures[xDestructor_rtreeMatchArgFree_enum], sizeof(E2->xDestructor_signature)) == 0) {
+ E1 = rtreeMatchArgFree(args);
+ }
+ else if (memcmp(E2->xDestructor_signature, xDestructor_signatures[xDestructor_sqlite3VdbeValueListFree_enum], sizeof(E2->xDestructor_signature)) == 0) {
+ E1 = sqlite3VdbeValueListFree(args);
+ }


// FP: xDeviceCharacteristics

@transform_assign_xDeviceCharacteristics_arrow@
expression E1, E2;
identifier FP_NAME = xDeviceCharacteristics;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xDeviceCharacteristics_signature, xDeviceCharacteristics_signatures[xDeviceCharacteristics_0_enum], sizeof(E2->xDeviceCharacteristics_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xDeviceCharacteristics_signature, xDeviceCharacteristics_signatures[xDeviceCharacteristics_apndDeviceCharacteristics_enum], sizeof(E2->xDeviceCharacteristics_signature)) == 0) {
+ E1 = apndDeviceCharacteristics(args);
+ }
+ else if (memcmp(E2->xDeviceCharacteristics_signature, xDeviceCharacteristics_signatures[xDeviceCharacteristics_memdbDeviceCharacteristics_enum], sizeof(E2->xDeviceCharacteristics_signature)) == 0) {
+ E1 = memdbDeviceCharacteristics(args);
+ }
+ else if (memcmp(E2->xDeviceCharacteristics_signature, xDeviceCharacteristics_signatures[xDeviceCharacteristics_recoverVfsDeviceCharacteristics_enum], sizeof(E2->xDeviceCharacteristics_signature)) == 0) {
+ E1 = recoverVfsDeviceCharacteristics(args);
+ }
+ else if (memcmp(E2->xDeviceCharacteristics_signature, xDeviceCharacteristics_signatures[xDeviceCharacteristics_vfstraceDeviceCharacteristics_enum], sizeof(E2->xDeviceCharacteristics_signature)) == 0) {
+ E1 = vfstraceDeviceCharacteristics(args);
+ }


// FP: xDisconnect

@transform_assign_xDisconnect_arrow@
expression E1, E2;
identifier FP_NAME = xDisconnect;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xDisconnect_signature, xDisconnect_signatures[xDisconnect_bytecodevtabDisconnect_enum], sizeof(E2->xDisconnect_signature)) == 0) {
+ E1 = bytecodevtabDisconnect(args);
+ }
+ else if (memcmp(E2->xDisconnect_signature, xDisconnect_signatures[xDisconnect_completionDisconnect_enum], sizeof(E2->xDisconnect_signature)) == 0) {
+ E1 = completionDisconnect(args);
+ }
+ else if (memcmp(E2->xDisconnect_signature, xDisconnect_signatures[xDisconnect_dbdataDisconnect_enum], sizeof(E2->xDisconnect_signature)) == 0) {
+ E1 = dbdataDisconnect(args);
+ }
+ else if (memcmp(E2->xDisconnect_signature, xDisconnect_signatures[xDisconnect_dbpageDisconnect_enum], sizeof(E2->xDisconnect_signature)) == 0) {
+ E1 = dbpageDisconnect(args);
+ }
+ else if (memcmp(E2->xDisconnect_signature, xDisconnect_signatures[xDisconnect_expertDisconnect_enum], sizeof(E2->xDisconnect_signature)) == 0) {
+ E1 = expertDisconnect(args);
+ }
+ else if (memcmp(E2->xDisconnect_signature, xDisconnect_signatures[xDisconnect_fsdirDisconnect_enum], sizeof(E2->xDisconnect_signature)) == 0) {
+ E1 = fsdirDisconnect(args);
+ }
+ else if (memcmp(E2->xDisconnect_signature, xDisconnect_signatures[xDisconnect_fts3DisconnectMethod_enum], sizeof(E2->xDisconnect_signature)) == 0) {
+ E1 = fts3DisconnectMethod(args);
+ }
+ else if (memcmp(E2->xDisconnect_signature, xDisconnect_signatures[xDisconnect_fts3auxDisconnectMethod_enum], sizeof(E2->xDisconnect_signature)) == 0) {
+ E1 = fts3auxDisconnectMethod(args);
+ }
+ else if (memcmp(E2->xDisconnect_signature, xDisconnect_signatures[xDisconnect_fts3tokDisconnectMethod_enum], sizeof(E2->xDisconnect_signature)) == 0) {
+ E1 = fts3tokDisconnectMethod(args);
+ }
+ else if (memcmp(E2->xDisconnect_signature, xDisconnect_signatures[xDisconnect_jsonEachDisconnect_enum], sizeof(E2->xDisconnect_signature)) == 0) {
+ E1 = jsonEachDisconnect(args);
+ }
+ else if (memcmp(E2->xDisconnect_signature, xDisconnect_signatures[xDisconnect_pragmaVtabDisconnect_enum], sizeof(E2->xDisconnect_signature)) == 0) {
+ E1 = pragmaVtabDisconnect(args);
+ }
+ else if (memcmp(E2->xDisconnect_signature, xDisconnect_signatures[xDisconnect_rtreeDisconnect_enum], sizeof(E2->xDisconnect_signature)) == 0) {
+ E1 = rtreeDisconnect(args);
+ }
+ else if (memcmp(E2->xDisconnect_signature, xDisconnect_signatures[xDisconnect_seriesDisconnect_enum], sizeof(E2->xDisconnect_signature)) == 0) {
+ E1 = seriesDisconnect(args);
+ }
+ else if (memcmp(E2->xDisconnect_signature, xDisconnect_signatures[xDisconnect_statDisconnect_enum], sizeof(E2->xDisconnect_signature)) == 0) {
+ E1 = statDisconnect(args);
+ }
+ else if (memcmp(E2->xDisconnect_signature, xDisconnect_signatures[xDisconnect_stmtDisconnect_enum], sizeof(E2->xDisconnect_signature)) == 0) {
+ E1 = stmtDisconnect(args);
+ }
+ else if (memcmp(E2->xDisconnect_signature, xDisconnect_signatures[xDisconnect_zipfileDisconnect_enum], sizeof(E2->xDisconnect_signature)) == 0) {
+ E1 = zipfileDisconnect(args);
+ }


// FP: xDlClose

@transform_assign_xDlClose_arrow@
expression E1, E2;
identifier FP_NAME = xDlClose;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xDlClose_signature, xDlClose_signatures[xDlClose_0_enum], sizeof(E2->xDlClose_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xDlClose_signature, xDlClose_signatures[xDlClose_apndDlClose_enum], sizeof(E2->xDlClose_signature)) == 0) {
+ E1 = apndDlClose(args);
+ }
+ else if (memcmp(E2->xDlClose_signature, xDlClose_signatures[xDlClose_memdbDlClose_enum], sizeof(E2->xDlClose_signature)) == 0) {
+ E1 = memdbDlClose(args);
+ }
+ else if (memcmp(E2->xDlClose_signature, xDlClose_signatures[xDlClose_unixDlClose_enum], sizeof(E2->xDlClose_signature)) == 0) {
+ E1 = unixDlClose(args);
+ }


// FP: xDlError

@transform_assign_xDlError_arrow@
expression E1, E2;
identifier FP_NAME = xDlError;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xDlError_signature, xDlError_signatures[xDlError_0_enum], sizeof(E2->xDlError_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xDlError_signature, xDlError_signatures[xDlError_apndDlError_enum], sizeof(E2->xDlError_signature)) == 0) {
+ E1 = apndDlError(args);
+ }
+ else if (memcmp(E2->xDlError_signature, xDlError_signatures[xDlError_memdbDlError_enum], sizeof(E2->xDlError_signature)) == 0) {
+ E1 = memdbDlError(args);
+ }
+ else if (memcmp(E2->xDlError_signature, xDlError_signatures[xDlError_unixDlError_enum], sizeof(E2->xDlError_signature)) == 0) {
+ E1 = unixDlError(args);
+ }


// FP: xDlOpen

@transform_assign_xDlOpen_arrow@
expression E1, E2;
identifier FP_NAME = xDlOpen;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xDlOpen_signature, xDlOpen_signatures[xDlOpen_apndDlOpen_enum], sizeof(E2->xDlOpen_signature)) == 0) {
+ E1 = apndDlOpen(args);
+ }
+ else if (memcmp(E2->xDlOpen_signature, xDlOpen_signatures[xDlOpen_memdbDlOpen_enum], sizeof(E2->xDlOpen_signature)) == 0) {
+ E1 = memdbDlOpen(args);
+ }
+ else if (memcmp(E2->xDlOpen_signature, xDlOpen_signatures[xDlOpen_unixDlOpen_enum], sizeof(E2->xDlOpen_signature)) == 0) {
+ E1 = unixDlOpen(args);
+ }


// FP: xDlSym

@transform_assign_xDlSym_arrow@
expression E1, E2;
identifier FP_NAME = xDlSym;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xDlSym_signature, xDlSym_signatures[xDlSym_0_enum], sizeof(E2->xDlSym_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xDlSym_signature, xDlSym_signatures[xDlSym_apndDlSym_enum], sizeof(E2->xDlSym_signature)) == 0) {
+ E1 = apndDlSym(args);
+ }
+ else if (memcmp(E2->xDlSym_signature, xDlSym_signatures[xDlSym_memdbDlSym_enum], sizeof(E2->xDlSym_signature)) == 0) {
+ E1 = memdbDlSym(args);
+ }
+ else if (memcmp(E2->xDlSym_signature, xDlSym_signatures[xDlSym_rbuVfsDlSym_enum], sizeof(E2->xDlSym_signature)) == 0) {
+ E1 = rbuVfsDlSym(args);
+ }
+ else if (memcmp(E2->xDlSym_signature, xDlSym_signatures[xDlSym_winDlSym_enum], sizeof(E2->xDlSym_signature)) == 0) {
+ E1 = winDlSym(args);
+ }
+ else if (memcmp(E2->xDlSym_signature, xDlSym_signatures[xDlSym_unixDlSym_enum], sizeof(E2->xDlSym_signature)) == 0) {
+ E1 = unixDlSym(args);
+ }


// FP: xEof

@transform_assign_xEof_arrow@
expression E1, E2;
identifier FP_NAME = xEof;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xEof_signature, xEof_signatures[xEof_bytecodevtabEof_enum], sizeof(E2->xEof_signature)) == 0) {
+ E1 = bytecodevtabEof(args);
+ }
+ else if (memcmp(E2->xEof_signature, xEof_signatures[xEof_completionEof_enum], sizeof(E2->xEof_signature)) == 0) {
+ E1 = completionEof(args);
+ }
+ else if (memcmp(E2->xEof_signature, xEof_signatures[xEof_dbdataEof_enum], sizeof(E2->xEof_signature)) == 0) {
+ E1 = dbdataEof(args);
+ }
+ else if (memcmp(E2->xEof_signature, xEof_signatures[xEof_dbpageEof_enum], sizeof(E2->xEof_signature)) == 0) {
+ E1 = dbpageEof(args);
+ }
+ else if (memcmp(E2->xEof_signature, xEof_signatures[xEof_expertEof_enum], sizeof(E2->xEof_signature)) == 0) {
+ E1 = expertEof(args);
+ }
+ else if (memcmp(E2->xEof_signature, xEof_signatures[xEof_fsdirEof_enum], sizeof(E2->xEof_signature)) == 0) {
+ E1 = fsdirEof(args);
+ }
+ else if (memcmp(E2->xEof_signature, xEof_signatures[xEof_fts3EofMethod_enum], sizeof(E2->xEof_signature)) == 0) {
+ E1 = fts3EofMethod(args);
+ }
+ else if (memcmp(E2->xEof_signature, xEof_signatures[xEof_fts3auxEofMethod_enum], sizeof(E2->xEof_signature)) == 0) {
+ E1 = fts3auxEofMethod(args);
+ }
+ else if (memcmp(E2->xEof_signature, xEof_signatures[xEof_fts3tokEofMethod_enum], sizeof(E2->xEof_signature)) == 0) {
+ E1 = fts3tokEofMethod(args);
+ }
+ else if (memcmp(E2->xEof_signature, xEof_signatures[xEof_jsonEachEof_enum], sizeof(E2->xEof_signature)) == 0) {
+ E1 = jsonEachEof(args);
+ }
+ else if (memcmp(E2->xEof_signature, xEof_signatures[xEof_pragmaVtabEof_enum], sizeof(E2->xEof_signature)) == 0) {
+ E1 = pragmaVtabEof(args);
+ }
+ else if (memcmp(E2->xEof_signature, xEof_signatures[xEof_rtreeEof_enum], sizeof(E2->xEof_signature)) == 0) {
+ E1 = rtreeEof(args);
+ }
+ else if (memcmp(E2->xEof_signature, xEof_signatures[xEof_seriesEof_enum], sizeof(E2->xEof_signature)) == 0) {
+ E1 = seriesEof(args);
+ }
+ else if (memcmp(E2->xEof_signature, xEof_signatures[xEof_statEof_enum], sizeof(E2->xEof_signature)) == 0) {
+ E1 = statEof(args);
+ }
+ else if (memcmp(E2->xEof_signature, xEof_signatures[xEof_stmtEof_enum], sizeof(E2->xEof_signature)) == 0) {
+ E1 = stmtEof(args);
+ }
+ else if (memcmp(E2->xEof_signature, xEof_signatures[xEof_zipfileEof_enum], sizeof(E2->xEof_signature)) == 0) {
+ E1 = zipfileEof(args);
+ }


// FP: xExprCallback

@transform_assign_xExprCallback_arrow@
expression E1, E2;
identifier FP_NAME = xExprCallback;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_agginfoPersistExprCb_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = agginfoPersistExprCb(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_aggregateIdxEprRefToColCallback_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = aggregateIdxEprRefToColCallback(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_analyzeAggregate_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = analyzeAggregate(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_checkConstraintExprNode_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = checkConstraintExprNode(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_codeCursorHintCheckExpr_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = codeCursorHintCheckExpr(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_codeCursorHintFixExpr_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = codeCursorHintFixExpr(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_codeCursorHintIsOrFunction_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = codeCursorHintIsOrFunction(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_disallowAggregatesInOrderByCb_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = disallowAggregatesInOrderByCb(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprColumnFlagUnion_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = exprColumnFlagUnion(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprIdxCover_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = exprIdxCover(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprNodeCanReturnSubtype_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = exprNodeCanReturnSubtype(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprNodeIsConstant_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = exprNodeIsConstant(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprNodeIsConstantOrGroupBy_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = exprNodeIsConstantOrGroupBy(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprNodeIsDeterministic_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = exprNodeIsDeterministic(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprRefToSrcList_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = exprRefToSrcList(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_fixExprCb_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = fixExprCb(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_gatherSelectWindowsCallback_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = gatherSelectWindowsCallback(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_havingToWhereExprCb_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = havingToWhereExprCb(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_impliesNotNullRow_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = impliesNotNullRow(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_incrAggDepth_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = incrAggDepth(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_markImmutableExprStep_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = markImmutableExprStep(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_propagateConstantExprRewrite_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = propagateConstantExprRewrite(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_recomputeColumnsUsedExpr_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = recomputeColumnsUsedExpr(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_renameColumnExprCb_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = renameColumnExprCb(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_renameQuotefixExprCb_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = renameQuotefixExprCb(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_renameTableExprCb_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = renameTableExprCb(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_renameUnmapExprCb_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = renameUnmapExprCb(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_renumberCursorsCb_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = renumberCursorsCb(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_resolveExprStep_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = resolveExprStep(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_resolveRemoveWindowsCb_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = resolveRemoveWindowsCb(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_selectCheckOnClausesExpr_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = selectCheckOnClausesExpr(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_selectWindowRewriteExprCb_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = selectWindowRewriteExprCb(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_sqlite3CursorRangeHintExprCheck_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = sqlite3CursorRangeHintExprCheck(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_sqlite3ExprWalkNoop_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = sqlite3ExprWalkNoop(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_sqlite3ReturningSubqueryVarSelect_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = sqlite3ReturningSubqueryVarSelect(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_sqlite3WindowExtraAggFuncDepth_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = sqlite3WindowExtraAggFuncDepth(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_whereIsCoveringIndexWalkCallback_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = whereIsCoveringIndexWalkCallback(args);
+ }


// FP: xFetch

@transform_assign_xFetch_arrow@
expression E1, E2;
identifier FP_NAME = xFetch;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xFetch_signature, xFetch_signatures[xFetch_0_enum], sizeof(E2->xFetch_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xFetch_signature, xFetch_signatures[xFetch_apndFetch_enum], sizeof(E2->xFetch_signature)) == 0) {
+ E1 = apndFetch(args);
+ }
+ else if (memcmp(E2->xFetch_signature, xFetch_signatures[xFetch_memdbFetch_enum], sizeof(E2->xFetch_signature)) == 0) {
+ E1 = memdbFetch(args);
+ }
+ else if (memcmp(E2->xFetch_signature, xFetch_signatures[xFetch_pcache1Fetch_enum], sizeof(E2->xFetch_signature)) == 0) {
+ E1 = pcache1Fetch(args);
+ }
+ else if (memcmp(E2->xFetch_signature, xFetch_signatures[xFetch_pcachetraceFetch_enum], sizeof(E2->xFetch_signature)) == 0) {
+ E1 = pcachetraceFetch(args);
+ }
+ else if (memcmp(E2->xFetch_signature, xFetch_signatures[xFetch_recoverVfsFetch_enum], sizeof(E2->xFetch_signature)) == 0) {
+ E1 = recoverVfsFetch(args);
+ }


// FP: xFileControl

@transform_assign_xFileControl_arrow@
expression E1, E2;
identifier FP_NAME = xFileControl;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xFileControl_signature, xFileControl_signatures[xFileControl_0_enum], sizeof(E2->xFileControl_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xFileControl_signature, xFileControl_signatures[xFileControl_apndFileControl_enum], sizeof(E2->xFileControl_signature)) == 0) {
+ E1 = apndFileControl(args);
+ }
+ else if (memcmp(E2->xFileControl_signature, xFileControl_signatures[xFileControl_memdbFileControl_enum], sizeof(E2->xFileControl_signature)) == 0) {
+ E1 = memdbFileControl(args);
+ }
+ else if (memcmp(E2->xFileControl_signature, xFileControl_signatures[xFileControl_recoverVfsFileControl_enum], sizeof(E2->xFileControl_signature)) == 0) {
+ E1 = recoverVfsFileControl(args);
+ }
+ else if (memcmp(E2->xFileControl_signature, xFileControl_signatures[xFileControl_vfstraceFileControl_enum], sizeof(E2->xFileControl_signature)) == 0) {
+ E1 = vfstraceFileControl(args);
+ }


// FP: xFileSize

@transform_assign_xFileSize_arrow@
expression E1, E2;
identifier FP_NAME = xFileSize;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xFileSize_signature, xFileSize_signatures[xFileSize_apndFileSize_enum], sizeof(E2->xFileSize_signature)) == 0) {
+ E1 = apndFileSize(args);
+ }
+ else if (memcmp(E2->xFileSize_signature, xFileSize_signatures[xFileSize_memdbFileSize_enum], sizeof(E2->xFileSize_signature)) == 0) {
+ E1 = memdbFileSize(args);
+ }
+ else if (memcmp(E2->xFileSize_signature, xFileSize_signatures[xFileSize_memjrnlFileSize_enum], sizeof(E2->xFileSize_signature)) == 0) {
+ E1 = memjrnlFileSize(args);
+ }
+ else if (memcmp(E2->xFileSize_signature, xFileSize_signatures[xFileSize_recoverVfsFileSize_enum], sizeof(E2->xFileSize_signature)) == 0) {
+ E1 = recoverVfsFileSize(args);
+ }
+ else if (memcmp(E2->xFileSize_signature, xFileSize_signatures[xFileSize_vfstraceFileSize_enum], sizeof(E2->xFileSize_signature)) == 0) {
+ E1 = vfstraceFileSize(args);
+ }


// FP: xFilter

@transform_assign_xFilter_arrow@
expression E1, E2;
identifier FP_NAME = xFilter;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xFilter_signature, xFilter_signatures[xFilter_bytecodevtabFilter_enum], sizeof(E2->xFilter_signature)) == 0) {
+ E1 = bytecodevtabFilter(args);
+ }
+ else if (memcmp(E2->xFilter_signature, xFilter_signatures[xFilter_completionFilter_enum], sizeof(E2->xFilter_signature)) == 0) {
+ E1 = completionFilter(args);
+ }
+ else if (memcmp(E2->xFilter_signature, xFilter_signatures[xFilter_dbdataFilter_enum], sizeof(E2->xFilter_signature)) == 0) {
+ E1 = dbdataFilter(args);
+ }
+ else if (memcmp(E2->xFilter_signature, xFilter_signatures[xFilter_dbpageFilter_enum], sizeof(E2->xFilter_signature)) == 0) {
+ E1 = dbpageFilter(args);
+ }
+ else if (memcmp(E2->xFilter_signature, xFilter_signatures[xFilter_expertFilter_enum], sizeof(E2->xFilter_signature)) == 0) {
+ E1 = expertFilter(args);
+ }
+ else if (memcmp(E2->xFilter_signature, xFilter_signatures[xFilter_fsdirFilter_enum], sizeof(E2->xFilter_signature)) == 0) {
+ E1 = fsdirFilter(args);
+ }
+ else if (memcmp(E2->xFilter_signature, xFilter_signatures[xFilter_fts3FilterMethod_enum], sizeof(E2->xFilter_signature)) == 0) {
+ E1 = fts3FilterMethod(args);
+ }
+ else if (memcmp(E2->xFilter_signature, xFilter_signatures[xFilter_fts3auxFilterMethod_enum], sizeof(E2->xFilter_signature)) == 0) {
+ E1 = fts3auxFilterMethod(args);
+ }
+ else if (memcmp(E2->xFilter_signature, xFilter_signatures[xFilter_fts3tokFilterMethod_enum], sizeof(E2->xFilter_signature)) == 0) {
+ E1 = fts3tokFilterMethod(args);
+ }
+ else if (memcmp(E2->xFilter_signature, xFilter_signatures[xFilter_geopolyFilter_enum], sizeof(E2->xFilter_signature)) == 0) {
+ E1 = geopolyFilter(args);
+ }
+ else if (memcmp(E2->xFilter_signature, xFilter_signatures[xFilter_jsonEachFilter_enum], sizeof(E2->xFilter_signature)) == 0) {
+ E1 = jsonEachFilter(args);
+ }
+ else if (memcmp(E2->xFilter_signature, xFilter_signatures[xFilter_pragmaVtabFilter_enum], sizeof(E2->xFilter_signature)) == 0) {
+ E1 = pragmaVtabFilter(args);
+ }
+ else if (memcmp(E2->xFilter_signature, xFilter_signatures[xFilter_rtreeFilter_enum], sizeof(E2->xFilter_signature)) == 0) {
+ E1 = rtreeFilter(args);
+ }
+ else if (memcmp(E2->xFilter_signature, xFilter_signatures[xFilter_seriesFilter_enum], sizeof(E2->xFilter_signature)) == 0) {
+ E1 = seriesFilter(args);
+ }
+ else if (memcmp(E2->xFilter_signature, xFilter_signatures[xFilter_statFilter_enum], sizeof(E2->xFilter_signature)) == 0) {
+ E1 = statFilter(args);
+ }
+ else if (memcmp(E2->xFilter_signature, xFilter_signatures[xFilter_stmtFilter_enum], sizeof(E2->xFilter_signature)) == 0) {
+ E1 = stmtFilter(args);
+ }
+ else if (memcmp(E2->xFilter_signature, xFilter_signatures[xFilter_zipfileFilter_enum], sizeof(E2->xFilter_signature)) == 0) {
+ E1 = zipfileFilter(args);
+ }


// FP: xFinalize

@transform_assign_xFinalize_arrow@
expression E1, E2;
identifier FP_NAME = xFinalize;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xFinalize_signature, xFinalize_signatures[xFinalize_0_enum], sizeof(E2->xFinalize_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xFinalize_signature, xFinalize_signatures[xFinalize_decimalSumFinalize_enum], sizeof(E2->xFinalize_signature)) == 0) {
+ E1 = decimalSumFinalize(args);
+ }
+ else if (memcmp(E2->xFinalize_signature, xFinalize_signatures[xFinalize_dummyUDFvalue_enum], sizeof(E2->xFinalize_signature)) == 0) {
+ E1 = dummyUDFvalue(args);
+ }
+ else if (memcmp(E2->xFinalize_signature, xFinalize_signatures[xFinalize_percentFinal_enum], sizeof(E2->xFinalize_signature)) == 0) {
+ E1 = percentFinal(args);
+ }
+ else if (memcmp(E2->xFinalize_signature, xFinalize_signatures[xFinalize_sha3AggFinal_enum], sizeof(E2->xFinalize_signature)) == 0) {
+ E1 = sha3AggFinal(args);
+ }
+ else if (memcmp(E2->xFinalize_signature, xFinalize_signatures[xFinalize_zipfileFinal_enum], sizeof(E2->xFinalize_signature)) == 0) {
+ E1 = zipfileFinal(args);
+ }


// FP: xFindFunction

@transform_assign_xFindFunction_arrow@
expression E1, E2;
identifier FP_NAME = xFindFunction;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xFindFunction_signature, xFindFunction_signatures[xFindFunction_0_enum], sizeof(E2->xFindFunction_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xFindFunction_signature, xFindFunction_signatures[xFindFunction_fts3FindFunctionMethod_enum], sizeof(E2->xFindFunction_signature)) == 0) {
+ E1 = fts3FindFunctionMethod(args);
+ }
+ else if (memcmp(E2->xFindFunction_signature, xFindFunction_signatures[xFindFunction_zipfileFindFunction_enum], sizeof(E2->xFindFunction_signature)) == 0) {
+ E1 = zipfileFindFunction(args);
+ }


// FP: xFree

@transform_assign_xFree_arrow@
expression E1, E2;
identifier FP_NAME = xFree;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xFree_signature, xFree_signatures[xFree_memtraceFree_enum], sizeof(E2->xFree_signature)) == 0) {
+ E1 = memtraceFree(args);
+ }
+ else if (memcmp(E2->xFree_signature, xFree_signatures[xFree_sqlite3MemFree_enum], sizeof(E2->xFree_signature)) == 0) {
+ E1 = sqlite3MemFree(args);
+ }


// FP: xFreeSchema

@transform_assign_xFreeSchema_arrow@
expression E1, E2;
identifier FP_NAME = xFreeSchema;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xFreeSchema_signature, xFreeSchema_signatures[xFreeSchema_0_enum], sizeof(E2->xFreeSchema_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xFreeSchema_signature, xFreeSchema_signatures[xFreeSchema_sqlite3RCStrUnref_enum], sizeof(E2->xFreeSchema_signature)) == 0) {
+ E1 = sqlite3RCStrUnref(args);
+ }
+ else if (memcmp(E2->xFreeSchema_signature, xFreeSchema_signatures[xFreeSchema_sqlite3SchemaClear_enum], sizeof(E2->xFreeSchema_signature)) == 0) {
+ E1 = sqlite3SchemaClear(args);
+ }


// FP: xFullPathname

@transform_assign_xFullPathname_arrow@
expression E1, E2;
identifier FP_NAME = xFullPathname;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xFullPathname_signature, xFullPathname_signatures[xFullPathname_apndFullPathname_enum], sizeof(E2->xFullPathname_signature)) == 0) {
+ E1 = apndFullPathname(args);
+ }
+ else if (memcmp(E2->xFullPathname_signature, xFullPathname_signatures[xFullPathname_memdbFullPathname_enum], sizeof(E2->xFullPathname_signature)) == 0) {
+ E1 = memdbFullPathname(args);
+ }
+ else if (memcmp(E2->xFullPathname_signature, xFullPathname_signatures[xFullPathname_vfstraceFullPathname_enum], sizeof(E2->xFullPathname_signature)) == 0) {
+ E1 = vfstraceFullPathname(args);
+ }
+ else if (memcmp(E2->xFullPathname_signature, xFullPathname_signatures[xFullPathname_unixFullPathname_enum], sizeof(E2->xFullPathname_signature)) == 0) {
+ E1 = unixFullPathname(args);
+ }


// FP: xFunc

@transform_assign_xFunc_arrow@
expression E1, E2;
identifier FP_NAME = xFunc;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xFunc_signature, xFunc_signatures[xFunc_0_enum], sizeof(E2->xFunc_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xFunc_signature, xFunc_signatures[xFunc_base64_enum], sizeof(E2->xFunc_signature)) == 0) {
+ E1 = base64(args);
+ }
+ else if (memcmp(E2->xFunc_signature, xFunc_signatures[xFunc_base85_enum], sizeof(E2->xFunc_signature)) == 0) {
+ E1 = base85(args);
+ }
+ else if (memcmp(E2->xFunc_signature, xFunc_signatures[xFunc_dummyUDF_enum], sizeof(E2->xFunc_signature)) == 0) {
+ E1 = dummyUDF(args);
+ }
+ else if (memcmp(E2->xFunc_signature, xFunc_signatures[xFunc_editFunc_enum], sizeof(E2->xFunc_signature)) == 0) {
+ E1 = editFunc(args);
+ }
+ else if (memcmp(E2->xFunc_signature, xFunc_signatures[xFunc_fts3AllocateMSI_enum], sizeof(E2->xFunc_signature)) == 0) {
+ E1 = fts3AllocateMSI(args);
+ }
+ else if (memcmp(E2->xFunc_signature, xFunc_signatures[xFunc_fts3ExprGlobalHitsCb_enum], sizeof(E2->xFunc_signature)) == 0) {
+ E1 = fts3ExprGlobalHitsCb(args);
+ }
+ else if (memcmp(E2->xFunc_signature, xFunc_signatures[xFunc_fts3ExprLoadDoclistsCb_enum], sizeof(E2->xFunc_signature)) == 0) {
+ E1 = fts3ExprLoadDoclistsCb(args);
+ }
+ else if (memcmp(E2->xFunc_signature, xFunc_signatures[xFunc_fts3ExprLocalHitsCb_enum], sizeof(E2->xFunc_signature)) == 0) {
+ E1 = fts3ExprLocalHitsCb(args);
+ }
+ else if (memcmp(E2->xFunc_signature, xFunc_signatures[xFunc_fts3ExprPhraseCountCb_enum], sizeof(E2->xFunc_signature)) == 0) {
+ E1 = fts3ExprPhraseCountCb(args);
+ }
+ else if (memcmp(E2->xFunc_signature, xFunc_signatures[xFunc_fts3ExprRestartIfCb_enum], sizeof(E2->xFunc_signature)) == 0) {
+ E1 = fts3ExprRestartIfCb(args);
+ }
+ else if (memcmp(E2->xFunc_signature, xFunc_signatures[xFunc_fts3ExprTermOffsetInit_enum], sizeof(E2->xFunc_signature)) == 0) {
+ E1 = fts3ExprTermOffsetInit(args);
+ }
+ else if (memcmp(E2->xFunc_signature, xFunc_signatures[xFunc_fts3ExprTest_enum], sizeof(E2->xFunc_signature)) == 0) {
+ E1 = fts3ExprTest(args);
+ }
+ else if (memcmp(E2->xFunc_signature, xFunc_signatures[xFunc_fts3ExprTestRebalance_enum], sizeof(E2->xFunc_signature)) == 0) {
+ E1 = fts3ExprTestRebalance(args);
+ }
+ else if (memcmp(E2->xFunc_signature, xFunc_signatures[xFunc_fts3MatchinfoLcsCb_enum], sizeof(E2->xFunc_signature)) == 0) {
+ E1 = fts3MatchinfoLcsCb(args);
+ }
+ else if (memcmp(E2->xFunc_signature, xFunc_signatures[xFunc_fts3SnippetFindPositions_enum], sizeof(E2->xFunc_signature)) == 0) {
+ E1 = fts3SnippetFindPositions(args);
+ }
+ else if (memcmp(E2->xFunc_signature, xFunc_signatures[xFunc_fts3TokenizerFunc_enum], sizeof(E2->xFunc_signature)) == 0) {
+ E1 = fts3TokenizerFunc(args);
+ }
+ else if (memcmp(E2->xFunc_signature, xFunc_signatures[xFunc_geomCallback_enum], sizeof(E2->xFunc_signature)) == 0) {
+ E1 = geomCallback(args);
+ }
+ else if (memcmp(E2->xFunc_signature, xFunc_signatures[xFunc_idxRemFunc_enum], sizeof(E2->xFunc_signature)) == 0) {
+ E1 = idxRemFunc(args);
+ }
+ else if (memcmp(E2->xFunc_signature, xFunc_signatures[xFunc_idxSampleFunc_enum], sizeof(E2->xFunc_signature)) == 0) {
+ E1 = idxSampleFunc(args);
+ }
+ else if (memcmp(E2->xFunc_signature, xFunc_signatures[xFunc_intTestFunc_enum], sizeof(E2->xFunc_signature)) == 0) {
+ E1 = intTestFunc(args);
+ }
+ else if (memcmp(E2->xFunc_signature, xFunc_signatures[xFunc_intckParseCreateIndexFunc_enum], sizeof(E2->xFunc_signature)) == 0) {
+ E1 = intckParseCreateIndexFunc(args);
+ }
+ else if (memcmp(E2->xFunc_signature, xFunc_signatures[xFunc_is_base85_enum], sizeof(E2->xFunc_signature)) == 0) {
+ E1 = is_base85(args);
+ }
+ else if (memcmp(E2->xFunc_signature, xFunc_signatures[xFunc_lsModeFunc_enum], sizeof(E2->xFunc_signature)) == 0) {
+ E1 = lsModeFunc(args);
+ }
+ else if (memcmp(E2->xFunc_signature, xFunc_signatures[xFunc_rbuFossilDeltaFunc_enum], sizeof(E2->xFunc_signature)) == 0) {
+ E1 = rbuFossilDeltaFunc(args);
+ }
+ else if (memcmp(E2->xFunc_signature, xFunc_signatures[xFunc_rbuIndexCntFunc_enum], sizeof(E2->xFunc_signature)) == 0) {
+ E1 = rbuIndexCntFunc(args);
+ }
+ else if (memcmp(E2->xFunc_signature, xFunc_signatures[xFunc_rbuTargetNameFunc_enum], sizeof(E2->xFunc_signature)) == 0) {
+ E1 = rbuTargetNameFunc(args);
+ }
+ else if (memcmp(E2->xFunc_signature, xFunc_signatures[xFunc_rbuTmpInsertFunc_enum], sizeof(E2->xFunc_signature)) == 0) {
+ E1 = rbuTmpInsertFunc(args);
+ }
+ else if (memcmp(E2->xFunc_signature, xFunc_signatures[xFunc_re_bytecode_func_enum], sizeof(E2->xFunc_signature)) == 0) {
+ E1 = re_bytecode_func(args);
+ }
+ else if (memcmp(E2->xFunc_signature, xFunc_signatures[xFunc_re_sql_func_enum], sizeof(E2->xFunc_signature)) == 0) {
+ E1 = re_sql_func(args);
+ }
+ else if (memcmp(E2->xFunc_signature, xFunc_signatures[xFunc_readfileFunc_enum], sizeof(E2->xFunc_signature)) == 0) {
+ E1 = readfileFunc(args);
+ }
+ else if (memcmp(E2->xFunc_signature, xFunc_signatures[xFunc_rtreecheck_enum], sizeof(E2->xFunc_signature)) == 0) {
+ E1 = rtreecheck(args);
+ }
+ else if (memcmp(E2->xFunc_signature, xFunc_signatures[xFunc_rtreedepth_enum], sizeof(E2->xFunc_signature)) == 0) {
+ E1 = rtreedepth(args);
+ }
+ else if (memcmp(E2->xFunc_signature, xFunc_signatures[xFunc_rtreenode_enum], sizeof(E2->xFunc_signature)) == 0) {
+ E1 = rtreenode(args);
+ }
+ else if (memcmp(E2->xFunc_signature, xFunc_signatures[xFunc_sha1Func_enum], sizeof(E2->xFunc_signature)) == 0) {
+ E1 = sha1Func(args);
+ }
+ else if (memcmp(E2->xFunc_signature, xFunc_signatures[xFunc_sha1QueryFunc_enum], sizeof(E2->xFunc_signature)) == 0) {
+ E1 = sha1QueryFunc(args);
+ }
+ else if (memcmp(E2->xFunc_signature, xFunc_signatures[xFunc_sha3Func_enum], sizeof(E2->xFunc_signature)) == 0) {
+ E1 = sha3Func(args);
+ }
+ else if (memcmp(E2->xFunc_signature, xFunc_signatures[xFunc_sha3QueryFunc_enum], sizeof(E2->xFunc_signature)) == 0) {
+ E1 = sha3QueryFunc(args);
+ }
+ else if (memcmp(E2->xFunc_signature, xFunc_signatures[xFunc_shellAddSchemaName_enum], sizeof(E2->xFunc_signature)) == 0) {
+ E1 = shellAddSchemaName(args);
+ }
+ else if (memcmp(E2->xFunc_signature, xFunc_signatures[xFunc_shellDtostr_enum], sizeof(E2->xFunc_signature)) == 0) {
+ E1 = shellDtostr(args);
+ }
+ else if (memcmp(E2->xFunc_signature, xFunc_signatures[xFunc_shellFkeyCollateClause_enum], sizeof(E2->xFunc_signature)) == 0) {
+ E1 = shellFkeyCollateClause(args);
+ }
+ else if (memcmp(E2->xFunc_signature, xFunc_signatures[xFunc_shellModuleSchema_enum], sizeof(E2->xFunc_signature)) == 0) {
+ E1 = shellModuleSchema(args);
+ }
+ else if (memcmp(E2->xFunc_signature, xFunc_signatures[xFunc_shellPutsFunc_enum], sizeof(E2->xFunc_signature)) == 0) {
+ E1 = shellPutsFunc(args);
+ }
+ else if (memcmp(E2->xFunc_signature, xFunc_signatures[xFunc_shellStrtod_enum], sizeof(E2->xFunc_signature)) == 0) {
+ E1 = shellStrtod(args);
+ }
+ else if (memcmp(E2->xFunc_signature, xFunc_signatures[xFunc_shellUSleepFunc_enum], sizeof(E2->xFunc_signature)) == 0) {
+ E1 = shellUSleepFunc(args);
+ }
+ else if (memcmp(E2->xFunc_signature, xFunc_signatures[xFunc_sqlarCompressFunc_enum], sizeof(E2->xFunc_signature)) == 0) {
+ E1 = sqlarCompressFunc(args);
+ }
+ else if (memcmp(E2->xFunc_signature, xFunc_signatures[xFunc_sqlarUncompressFunc_enum], sizeof(E2->xFunc_signature)) == 0) {
+ E1 = sqlarUncompressFunc(args);
+ }
+ else if (memcmp(E2->xFunc_signature, xFunc_signatures[xFunc_sqlite3InvalidFunction_enum], sizeof(E2->xFunc_signature)) == 0) {
+ E1 = sqlite3InvalidFunction(args);
+ }
+ else if (memcmp(E2->xFunc_signature, xFunc_signatures[xFunc_stmtrandFunc_enum], sizeof(E2->xFunc_signature)) == 0) {
+ E1 = stmtrandFunc(args);
+ }
+ else if (memcmp(E2->xFunc_signature, xFunc_signatures[xFunc_testFunc_enum], sizeof(E2->xFunc_signature)) == 0) {
+ E1 = testFunc(args);
+ }
+ else if (memcmp(E2->xFunc_signature, xFunc_signatures[xFunc_writefileFunc_enum], sizeof(E2->xFunc_signature)) == 0) {
+ E1 = writefileFunc(args);
+ }


// FP: xGeom

@transform_assign_xGeom_arrow@
expression E1, E2;
identifier FP_NAME = xGeom;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = 0;


// FP: xGet

@transform_assign_xGet_arrow@
expression E1, E2;
identifier FP_NAME = xGet;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xGet_signature, xGet_signatures[xGet_getPageError_enum], sizeof(E2->xGet_signature)) == 0) {
+ E1 = getPageError(args);
+ }
+ else if (memcmp(E2->xGet_signature, xGet_signatures[xGet_getPageMMap_enum], sizeof(E2->xGet_signature)) == 0) {
+ E1 = getPageMMap(args);
+ }
+ else if (memcmp(E2->xGet_signature, xGet_signatures[xGet_getPageNormal_enum], sizeof(E2->xGet_signature)) == 0) {
+ E1 = getPageNormal(args);
+ }


// FP: xGetLastError

@transform_assign_xGetLastError_arrow@
expression E1, E2;
identifier FP_NAME = xGetLastError;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xGetLastError_signature, xGetLastError_signatures[xGetLastError_0_enum], sizeof(E2->xGetLastError_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xGetLastError_signature, xGetLastError_signatures[xGetLastError_apndGetLastError_enum], sizeof(E2->xGetLastError_signature)) == 0) {
+ E1 = apndGetLastError(args);
+ }
+ else if (memcmp(E2->xGetLastError_signature, xGetLastError_signatures[xGetLastError_memdbGetLastError_enum], sizeof(E2->xGetLastError_signature)) == 0) {
+ E1 = memdbGetLastError(args);
+ }
+ else if (memcmp(E2->xGetLastError_signature, xGetLastError_signatures[xGetLastError_unixGetLastError_enum], sizeof(E2->xGetLastError_signature)) == 0) {
+ E1 = unixGetLastError(args);
+ }


// FP: xGetSystemCall

@transform_assign_xGetSystemCall_arrow@
expression E1, E2;
identifier FP_NAME = xGetSystemCall;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xGetSystemCall_signature, xGetSystemCall_signatures[xGetSystemCall_0_enum], sizeof(E2->xGetSystemCall_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xGetSystemCall_signature, xGetSystemCall_signatures[xGetSystemCall_apndGetSystemCall_enum], sizeof(E2->xGetSystemCall_signature)) == 0) {
+ E1 = apndGetSystemCall(args);
+ }
+ else if (memcmp(E2->xGetSystemCall_signature, xGetSystemCall_signatures[xGetSystemCall_unixGetSystemCall_enum], sizeof(E2->xGetSystemCall_signature)) == 0) {
+ E1 = unixGetSystemCall(args);
+ }


// FP: xInit

@transform_assign_xInit_arrow@
expression E1, E2;
identifier FP_NAME = xInit;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xInit_signature, xInit_signatures[xInit_memtraceInit_enum], sizeof(E2->xInit_signature)) == 0) {
+ E1 = memtraceInit(args);
+ }
+ else if (memcmp(E2->xInit_signature, xInit_signatures[xInit_pcache1Init_enum], sizeof(E2->xInit_signature)) == 0) {
+ E1 = pcache1Init(args);
+ }
+ else if (memcmp(E2->xInit_signature, xInit_signatures[xInit_pcachetraceInit_enum], sizeof(E2->xInit_signature)) == 0) {
+ E1 = pcachetraceInit(args);
+ }
+ else if (memcmp(E2->xInit_signature, xInit_signatures[xInit_sqlite3MemInit_enum], sizeof(E2->xInit_signature)) == 0) {
+ E1 = sqlite3MemInit(args);
+ }


// FP: xInput

@transform_assign_xInput_arrow@
expression E1, E2;
identifier FP_NAME = xInput;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = 0;


// FP: xIntegrity

@transform_assign_xIntegrity_arrow@
expression E1, E2;
identifier FP_NAME = xIntegrity;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xIntegrity_signature, xIntegrity_signatures[xIntegrity_0_enum], sizeof(E2->xIntegrity_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xIntegrity_signature, xIntegrity_signatures[xIntegrity_fts3IntegrityMethod_enum], sizeof(E2->xIntegrity_signature)) == 0) {
+ E1 = fts3IntegrityMethod(args);
+ }
+ else if (memcmp(E2->xIntegrity_signature, xIntegrity_signatures[xIntegrity_rtreeIntegrity_enum], sizeof(E2->xIntegrity_signature)) == 0) {
+ E1 = rtreeIntegrity(args);
+ }


// FP: xInverse

@transform_assign_xInverse_arrow@
expression E1, E2;
identifier FP_NAME = xInverse;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xInverse_signature, xInverse_signatures[xInverse_0_enum], sizeof(E2->xInverse_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xInverse_signature, xInverse_signatures[xInverse_decimalSumInverse_enum], sizeof(E2->xInverse_signature)) == 0) {
+ E1 = decimalSumInverse(args);
+ }
+ else if (memcmp(E2->xInverse_signature, xInverse_signatures[xInverse_percentInverse_enum], sizeof(E2->xInverse_signature)) == 0) {
+ E1 = percentInverse(args);
+ }


// FP: xLanguageid

@transform_assign_xLanguageid_arrow@
expression E1, E2;
identifier FP_NAME = xLanguageid;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = 0;


// FP: xLock

@transform_assign_xLock_arrow@
expression E1, E2;
identifier FP_NAME = xLock;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xLock_signature, xLock_signatures[xLock_0_enum], sizeof(E2->xLock_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xLock_signature, xLock_signatures[xLock_apndLock_enum], sizeof(E2->xLock_signature)) == 0) {
+ E1 = apndLock(args);
+ }
+ else if (memcmp(E2->xLock_signature, xLock_signatures[xLock_memdbLock_enum], sizeof(E2->xLock_signature)) == 0) {
+ E1 = memdbLock(args);
+ }
+ else if (memcmp(E2->xLock_signature, xLock_signatures[xLock_recoverVfsLock_enum], sizeof(E2->xLock_signature)) == 0) {
+ E1 = recoverVfsLock(args);
+ }
+ else if (memcmp(E2->xLock_signature, xLock_signatures[xLock_vfstraceLock_enum], sizeof(E2->xLock_signature)) == 0) {
+ E1 = vfstraceLock(args);
+ }


// FP: xLog

@transform_assign_xLog_arrow@
expression E1, E2;
identifier FP_NAME = xLog;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = 0;


// FP: xMalloc

@transform_assign_xMalloc_arrow@
expression E1, E2;
identifier FP_NAME = xMalloc;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xMalloc_signature, xMalloc_signatures[xMalloc_memtraceMalloc_enum], sizeof(E2->xMalloc_signature)) == 0) {
+ E1 = memtraceMalloc(args);
+ }
+ else if (memcmp(E2->xMalloc_signature, xMalloc_signatures[xMalloc_sqlite3MemMalloc_enum], sizeof(E2->xMalloc_signature)) == 0) {
+ E1 = sqlite3MemMalloc(args);
+ }


// FP: xMutexAlloc

@transform_assign_xMutexAlloc_arrow@
expression E1, E2;
identifier FP_NAME = xMutexAlloc;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_checkMutexAlloc_enum], sizeof(E2->xMutexAlloc_signature)) == 0) {
+ E1 = checkMutexAlloc(args);
+ }
+ else if (memcmp(E2->xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_debugMutexAlloc_enum], sizeof(E2->xMutexAlloc_signature)) == 0) {
+ E1 = debugMutexAlloc(args);
+ }
+ else if (memcmp(E2->xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_noopMutexAlloc_enum], sizeof(E2->xMutexAlloc_signature)) == 0) {
+ E1 = noopMutexAlloc(args);
+ }
+ else if (memcmp(E2->xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_pthreadMutexAlloc_enum], sizeof(E2->xMutexAlloc_signature)) == 0) {
+ E1 = pthreadMutexAlloc(args);
+ }
+ else if (memcmp(E2->xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_winMutexAlloc_enum], sizeof(E2->xMutexAlloc_signature)) == 0) {
+ E1 = winMutexAlloc(args);
+ }


// FP: xMutexEnd

@transform_assign_xMutexEnd_arrow@
expression E1, E2;
identifier FP_NAME = xMutexEnd;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_checkMutexEnd_enum], sizeof(E2->xMutexEnd_signature)) == 0) {
+ E1 = checkMutexEnd(args);
+ }
+ else if (memcmp(E2->xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_debugMutexEnd_enum], sizeof(E2->xMutexEnd_signature)) == 0) {
+ E1 = debugMutexEnd(args);
+ }
+ else if (memcmp(E2->xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_noopMutexEnd_enum], sizeof(E2->xMutexEnd_signature)) == 0) {
+ E1 = noopMutexEnd(args);
+ }
+ else if (memcmp(E2->xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_pthreadMutexEnd_enum], sizeof(E2->xMutexEnd_signature)) == 0) {
+ E1 = pthreadMutexEnd(args);
+ }
+ else if (memcmp(E2->xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_winMutexEnd_enum], sizeof(E2->xMutexEnd_signature)) == 0) {
+ E1 = winMutexEnd(args);
+ }


// FP: xMutexEnter

@transform_assign_xMutexEnter_arrow@
expression E1, E2;
identifier FP_NAME = xMutexEnter;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_checkMutexEnter_enum], sizeof(E2->xMutexEnter_signature)) == 0) {
+ E1 = checkMutexEnter(args);
+ }
+ else if (memcmp(E2->xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_debugMutexEnter_enum], sizeof(E2->xMutexEnter_signature)) == 0) {
+ E1 = debugMutexEnter(args);
+ }
+ else if (memcmp(E2->xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_noopMutexEnter_enum], sizeof(E2->xMutexEnter_signature)) == 0) {
+ E1 = noopMutexEnter(args);
+ }
+ else if (memcmp(E2->xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_pthreadMutexEnter_enum], sizeof(E2->xMutexEnter_signature)) == 0) {
+ E1 = pthreadMutexEnter(args);
+ }
+ else if (memcmp(E2->xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_winMutexEnter_enum], sizeof(E2->xMutexEnter_signature)) == 0) {
+ E1 = winMutexEnter(args);
+ }


// FP: xMutexFree

@transform_assign_xMutexFree_arrow@
expression E1, E2;
identifier FP_NAME = xMutexFree;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xMutexFree_signature, xMutexFree_signatures[xMutexFree_checkMutexFree_enum], sizeof(E2->xMutexFree_signature)) == 0) {
+ E1 = checkMutexFree(args);
+ }
+ else if (memcmp(E2->xMutexFree_signature, xMutexFree_signatures[xMutexFree_debugMutexFree_enum], sizeof(E2->xMutexFree_signature)) == 0) {
+ E1 = debugMutexFree(args);
+ }
+ else if (memcmp(E2->xMutexFree_signature, xMutexFree_signatures[xMutexFree_noopMutexFree_enum], sizeof(E2->xMutexFree_signature)) == 0) {
+ E1 = noopMutexFree(args);
+ }
+ else if (memcmp(E2->xMutexFree_signature, xMutexFree_signatures[xMutexFree_pthreadMutexFree_enum], sizeof(E2->xMutexFree_signature)) == 0) {
+ E1 = pthreadMutexFree(args);
+ }
+ else if (memcmp(E2->xMutexFree_signature, xMutexFree_signatures[xMutexFree_winMutexFree_enum], sizeof(E2->xMutexFree_signature)) == 0) {
+ E1 = winMutexFree(args);
+ }


// FP: xMutexHeld

@transform_assign_xMutexHeld_arrow@
expression E1, E2;
identifier FP_NAME = xMutexHeld;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xMutexHeld_signature, xMutexHeld_signatures[xMutexHeld_0_enum], sizeof(E2->xMutexHeld_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xMutexHeld_signature, xMutexHeld_signatures[xMutexHeld_debugMutexHeld_enum], sizeof(E2->xMutexHeld_signature)) == 0) {
+ E1 = debugMutexHeld(args);
+ }


// FP: xMutexInit

@transform_assign_xMutexInit_arrow@
expression E1, E2;
identifier FP_NAME = xMutexInit;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xMutexInit_signature, xMutexInit_signatures[xMutexInit_checkMutexInit_enum], sizeof(E2->xMutexInit_signature)) == 0) {
+ E1 = checkMutexInit(args);
+ }
+ else if (memcmp(E2->xMutexInit_signature, xMutexInit_signatures[xMutexInit_debugMutexInit_enum], sizeof(E2->xMutexInit_signature)) == 0) {
+ E1 = debugMutexInit(args);
+ }
+ else if (memcmp(E2->xMutexInit_signature, xMutexInit_signatures[xMutexInit_noopMutexInit_enum], sizeof(E2->xMutexInit_signature)) == 0) {
+ E1 = noopMutexInit(args);
+ }
+ else if (memcmp(E2->xMutexInit_signature, xMutexInit_signatures[xMutexInit_pthreadMutexInit_enum], sizeof(E2->xMutexInit_signature)) == 0) {
+ E1 = pthreadMutexInit(args);
+ }
+ else if (memcmp(E2->xMutexInit_signature, xMutexInit_signatures[xMutexInit_winMutexInit_enum], sizeof(E2->xMutexInit_signature)) == 0) {
+ E1 = winMutexInit(args);
+ }


// FP: xMutexLeave

@transform_assign_xMutexLeave_arrow@
expression E1, E2;
identifier FP_NAME = xMutexLeave;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_checkMutexLeave_enum], sizeof(E2->xMutexLeave_signature)) == 0) {
+ E1 = checkMutexLeave(args);
+ }
+ else if (memcmp(E2->xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_debugMutexLeave_enum], sizeof(E2->xMutexLeave_signature)) == 0) {
+ E1 = debugMutexLeave(args);
+ }
+ else if (memcmp(E2->xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_noopMutexLeave_enum], sizeof(E2->xMutexLeave_signature)) == 0) {
+ E1 = noopMutexLeave(args);
+ }
+ else if (memcmp(E2->xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_pthreadMutexLeave_enum], sizeof(E2->xMutexLeave_signature)) == 0) {
+ E1 = pthreadMutexLeave(args);
+ }
+ else if (memcmp(E2->xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_winMutexLeave_enum], sizeof(E2->xMutexLeave_signature)) == 0) {
+ E1 = winMutexLeave(args);
+ }


// FP: xMutexNotheld

@transform_assign_xMutexNotheld_arrow@
expression E1, E2;
identifier FP_NAME = xMutexNotheld;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xMutexNotheld_signature, xMutexNotheld_signatures[xMutexNotheld_0_enum], sizeof(E2->xMutexNotheld_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xMutexNotheld_signature, xMutexNotheld_signatures[xMutexNotheld_debugMutexNotheld_enum], sizeof(E2->xMutexNotheld_signature)) == 0) {
+ E1 = debugMutexNotheld(args);
+ }


// FP: xMutexTry

@transform_assign_xMutexTry_arrow@
expression E1, E2;
identifier FP_NAME = xMutexTry;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xMutexTry_signature, xMutexTry_signatures[xMutexTry_checkMutexTry_enum], sizeof(E2->xMutexTry_signature)) == 0) {
+ E1 = checkMutexTry(args);
+ }
+ else if (memcmp(E2->xMutexTry_signature, xMutexTry_signatures[xMutexTry_debugMutexTry_enum], sizeof(E2->xMutexTry_signature)) == 0) {
+ E1 = debugMutexTry(args);
+ }
+ else if (memcmp(E2->xMutexTry_signature, xMutexTry_signatures[xMutexTry_noopMutexTry_enum], sizeof(E2->xMutexTry_signature)) == 0) {
+ E1 = noopMutexTry(args);
+ }
+ else if (memcmp(E2->xMutexTry_signature, xMutexTry_signatures[xMutexTry_pthreadMutexTry_enum], sizeof(E2->xMutexTry_signature)) == 0) {
+ E1 = pthreadMutexTry(args);
+ }
+ else if (memcmp(E2->xMutexTry_signature, xMutexTry_signatures[xMutexTry_winMutexTry_enum], sizeof(E2->xMutexTry_signature)) == 0) {
+ E1 = winMutexTry(args);
+ }


// FP: xNew

@transform_assign_xNew_arrow@
expression E1, E2;
identifier FP_NAME = xNew;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xNew_signature, xNew_signatures[xNew_sessionDiffNew_enum], sizeof(E2->xNew_signature)) == 0) {
+ E1 = sessionDiffNew(args);
+ }
+ else if (memcmp(E2->xNew_signature, xNew_signatures[xNew_sessionPreupdateNew_enum], sizeof(E2->xNew_signature)) == 0) {
+ E1 = sessionPreupdateNew(args);
+ }
+ else if (memcmp(E2->xNew_signature, xNew_signatures[xNew_sessionStat1New_enum], sizeof(E2->xNew_signature)) == 0) {
+ E1 = sessionStat1New(args);
+ }


// FP: xNext

@transform_assign_xNext_arrow@
expression E1, E2;
identifier FP_NAME = xNext;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xNext_signature, xNext_signatures[xNext_0_enum], sizeof(E2->xNext_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xNext_signature, xNext_signatures[xNext_bytecodevtabNext_enum], sizeof(E2->xNext_signature)) == 0) {
+ E1 = bytecodevtabNext(args);
+ }
+ else if (memcmp(E2->xNext_signature, xNext_signatures[xNext_completionNext_enum], sizeof(E2->xNext_signature)) == 0) {
+ E1 = completionNext(args);
+ }
+ else if (memcmp(E2->xNext_signature, xNext_signatures[xNext_dbdataNext_enum], sizeof(E2->xNext_signature)) == 0) {
+ E1 = dbdataNext(args);
+ }
+ else if (memcmp(E2->xNext_signature, xNext_signatures[xNext_dbpageNext_enum], sizeof(E2->xNext_signature)) == 0) {
+ E1 = dbpageNext(args);
+ }
+ else if (memcmp(E2->xNext_signature, xNext_signatures[xNext_expertNext_enum], sizeof(E2->xNext_signature)) == 0) {
+ E1 = expertNext(args);
+ }
+ else if (memcmp(E2->xNext_signature, xNext_signatures[xNext_fsdirNext_enum], sizeof(E2->xNext_signature)) == 0) {
+ E1 = fsdirNext(args);
+ }
+ else if (memcmp(E2->xNext_signature, xNext_signatures[xNext_fts3NextMethod_enum], sizeof(E2->xNext_signature)) == 0) {
+ E1 = fts3NextMethod(args);
+ }
+ else if (memcmp(E2->xNext_signature, xNext_signatures[xNext_fts3auxNextMethod_enum], sizeof(E2->xNext_signature)) == 0) {
+ E1 = fts3auxNextMethod(args);
+ }
+ else if (memcmp(E2->xNext_signature, xNext_signatures[xNext_fts3tokNextMethod_enum], sizeof(E2->xNext_signature)) == 0) {
+ E1 = fts3tokNextMethod(args);
+ }
+ else if (memcmp(E2->xNext_signature, xNext_signatures[xNext_jsonEachNext_enum], sizeof(E2->xNext_signature)) == 0) {
+ E1 = jsonEachNext(args);
+ }
+ else if (memcmp(E2->xNext_signature, xNext_signatures[xNext_porterNext_enum], sizeof(E2->xNext_signature)) == 0) {
+ E1 = porterNext(args);
+ }
+ else if (memcmp(E2->xNext_signature, xNext_signatures[xNext_pragmaVtabNext_enum], sizeof(E2->xNext_signature)) == 0) {
+ E1 = pragmaVtabNext(args);
+ }
+ else if (memcmp(E2->xNext_signature, xNext_signatures[xNext_rtreeNext_enum], sizeof(E2->xNext_signature)) == 0) {
+ E1 = rtreeNext(args);
+ }
+ else if (memcmp(E2->xNext_signature, xNext_signatures[xNext_seriesNext_enum], sizeof(E2->xNext_signature)) == 0) {
+ E1 = seriesNext(args);
+ }
+ else if (memcmp(E2->xNext_signature, xNext_signatures[xNext_simpleNext_enum], sizeof(E2->xNext_signature)) == 0) {
+ E1 = simpleNext(args);
+ }
+ else if (memcmp(E2->xNext_signature, xNext_signatures[xNext_statNext_enum], sizeof(E2->xNext_signature)) == 0) {
+ E1 = statNext(args);
+ }
+ else if (memcmp(E2->xNext_signature, xNext_signatures[xNext_stmtNext_enum], sizeof(E2->xNext_signature)) == 0) {
+ E1 = stmtNext(args);
+ }
+ else if (memcmp(E2->xNext_signature, xNext_signatures[xNext_unicodeNext_enum], sizeof(E2->xNext_signature)) == 0) {
+ E1 = unicodeNext(args);
+ }
+ else if (memcmp(E2->xNext_signature, xNext_signatures[xNext_zipfileNext_enum], sizeof(E2->xNext_signature)) == 0) {
+ E1 = zipfileNext(args);
+ }


// FP: xNextSystemCall

@transform_assign_xNextSystemCall_arrow@
expression E1, E2;
identifier FP_NAME = xNextSystemCall;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xNextSystemCall_signature, xNextSystemCall_signatures[xNextSystemCall_0_enum], sizeof(E2->xNextSystemCall_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xNextSystemCall_signature, xNextSystemCall_signatures[xNextSystemCall_apndNextSystemCall_enum], sizeof(E2->xNextSystemCall_signature)) == 0) {
+ E1 = apndNextSystemCall(args);
+ }
+ else if (memcmp(E2->xNextSystemCall_signature, xNextSystemCall_signatures[xNextSystemCall_rbuVfsGetLastError_enum], sizeof(E2->xNextSystemCall_signature)) == 0) {
+ E1 = rbuVfsGetLastError(args);
+ }
+ else if (memcmp(E2->xNextSystemCall_signature, xNextSystemCall_signatures[xNextSystemCall_unixNextSystemCall_enum], sizeof(E2->xNextSystemCall_signature)) == 0) {
+ E1 = unixNextSystemCall(args);
+ }


// FP: xOld

@transform_assign_xOld_arrow@
expression E1, E2;
identifier FP_NAME = xOld;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xOld_signature, xOld_signatures[xOld_sessionDiffOld_enum], sizeof(E2->xOld_signature)) == 0) {
+ E1 = sessionDiffOld(args);
+ }
+ else if (memcmp(E2->xOld_signature, xOld_signatures[xOld_sessionPreupdateOld_enum], sizeof(E2->xOld_signature)) == 0) {
+ E1 = sessionPreupdateOld(args);
+ }
+ else if (memcmp(E2->xOld_signature, xOld_signatures[xOld_sessionStat1Old_enum], sizeof(E2->xOld_signature)) == 0) {
+ E1 = sessionStat1Old(args);
+ }


// FP: xOpen

@transform_assign_xOpen_arrow@
expression E1, E2;
identifier FP_NAME = xOpen;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_apndOpen_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = apndOpen(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_bytecodevtabOpen_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = bytecodevtabOpen(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_completionOpen_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = completionOpen(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_dbdataOpen_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = dbdataOpen(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_dbpageOpen_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = dbpageOpen(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_expertOpen_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = expertOpen(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_fsdirOpen_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = fsdirOpen(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_fts3OpenMethod_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = fts3OpenMethod(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_fts3auxOpenMethod_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = fts3auxOpenMethod(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_fts3tokOpenMethod_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = fts3tokOpenMethod(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_jsonEachOpen_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = jsonEachOpen(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_memdbOpen_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = memdbOpen(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_porterOpen_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = porterOpen(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_pragmaVtabOpen_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = pragmaVtabOpen(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_rtreeOpen_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = rtreeOpen(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_seriesOpen_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = seriesOpen(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_simpleOpen_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = simpleOpen(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_statOpen_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = statOpen(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_stmtOpen_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = stmtOpen(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_unicodeOpen_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = unicodeOpen(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_vfstraceOpen_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = vfstraceOpen(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_zipfileOpen_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = zipfileOpen(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_unixOpen_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = unixOpen(args);
+ }


// FP: xOut

@transform_assign_xOut_arrow@
expression E1, E2;
identifier FP_NAME = xOut;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = vfstraceOut(args);


// FP: xPagecount

@transform_assign_xPagecount_arrow@
expression E1, E2;
identifier FP_NAME = xPagecount;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xPagecount_signature, xPagecount_signatures[xPagecount_pcache1Pagecount_enum], sizeof(E2->xPagecount_signature)) == 0) {
+ E1 = pcache1Pagecount(args);
+ }
+ else if (memcmp(E2->xPagecount_signature, xPagecount_signatures[xPagecount_pcachetracePagecount_enum], sizeof(E2->xPagecount_signature)) == 0) {
+ E1 = pcachetracePagecount(args);
+ }


// FP: xParseCell

@transform_assign_xParseCell_arrow@
expression E1, E2;
identifier FP_NAME = xParseCell;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xParseCell_signature, xParseCell_signatures[xParseCell_btreeParseCellPtr_enum], sizeof(E2->xParseCell_signature)) == 0) {
+ E1 = btreeParseCellPtr(args);
+ }
+ else if (memcmp(E2->xParseCell_signature, xParseCell_signatures[xParseCell_btreeParseCellPtrIndex_enum], sizeof(E2->xParseCell_signature)) == 0) {
+ E1 = btreeParseCellPtrIndex(args);
+ }
+ else if (memcmp(E2->xParseCell_signature, xParseCell_signatures[xParseCell_btreeParseCellPtrNoPayload_enum], sizeof(E2->xParseCell_signature)) == 0) {
+ E1 = btreeParseCellPtrNoPayload(args);
+ }


// FP: xPreUpdateCallback

@transform_assign_xPreUpdateCallback_arrow@
expression E1, E2;
identifier FP_NAME = xPreUpdateCallback;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xPreUpdateCallback_signature, xPreUpdateCallback_signatures[xPreUpdateCallback_0_enum], sizeof(E2->xPreUpdateCallback_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xPreUpdateCallback_signature, xPreUpdateCallback_signatures[xPreUpdateCallback_sql_trace_callback_enum], sizeof(E2->xPreUpdateCallback_signature)) == 0) {
+ E1 = sql_trace_callback(args);
+ }
+ else if (memcmp(E2->xPreUpdateCallback_signature, xPreUpdateCallback_signatures[xPreUpdateCallback_sqlite3WalDefaultHook_enum], sizeof(E2->xPreUpdateCallback_signature)) == 0) {
+ E1 = sqlite3WalDefaultHook(args);
+ }


// FP: xQueryFunc

@transform_assign_xQueryFunc_arrow@
expression E1, E2;
identifier FP_NAME = xQueryFunc;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = 0;


// FP: xRandomness

@transform_assign_xRandomness_arrow@
expression E1, E2;
identifier FP_NAME = xRandomness;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xRandomness_signature, xRandomness_signatures[xRandomness_apndRandomness_enum], sizeof(E2->xRandomness_signature)) == 0) {
+ E1 = apndRandomness(args);
+ }
+ else if (memcmp(E2->xRandomness_signature, xRandomness_signatures[xRandomness_memdbRandomness_enum], sizeof(E2->xRandomness_signature)) == 0) {
+ E1 = memdbRandomness(args);
+ }
+ else if (memcmp(E2->xRandomness_signature, xRandomness_signatures[xRandomness_vfstraceRandomness_enum], sizeof(E2->xRandomness_signature)) == 0) {
+ E1 = vfstraceRandomness(args);
+ }
+ else if (memcmp(E2->xRandomness_signature, xRandomness_signatures[xRandomness_unixRandomness_enum], sizeof(E2->xRandomness_signature)) == 0) {
+ E1 = unixRandomness(args);
+ }


// FP: xRead

@transform_assign_xRead_arrow@
expression E1, E2;
identifier FP_NAME = xRead;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xRead_signature, xRead_signatures[xRead_apndRead_enum], sizeof(E2->xRead_signature)) == 0) {
+ E1 = apndRead(args);
+ }
+ else if (memcmp(E2->xRead_signature, xRead_signatures[xRead_memdbRead_enum], sizeof(E2->xRead_signature)) == 0) {
+ E1 = memdbRead(args);
+ }
+ else if (memcmp(E2->xRead_signature, xRead_signatures[xRead_memjrnlRead_enum], sizeof(E2->xRead_signature)) == 0) {
+ E1 = memjrnlRead(args);
+ }
+ else if (memcmp(E2->xRead_signature, xRead_signatures[xRead_recoverVfsRead_enum], sizeof(E2->xRead_signature)) == 0) {
+ E1 = recoverVfsRead(args);
+ }
+ else if (memcmp(E2->xRead_signature, xRead_signatures[xRead_vfstraceRead_enum], sizeof(E2->xRead_signature)) == 0) {
+ E1 = vfstraceRead(args);
+ }


// FP: xRealloc

@transform_assign_xRealloc_arrow@
expression E1, E2;
identifier FP_NAME = xRealloc;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xRealloc_signature, xRealloc_signatures[xRealloc_memtraceRealloc_enum], sizeof(E2->xRealloc_signature)) == 0) {
+ E1 = memtraceRealloc(args);
+ }
+ else if (memcmp(E2->xRealloc_signature, xRealloc_signatures[xRealloc_sqlite3MemRealloc_enum], sizeof(E2->xRealloc_signature)) == 0) {
+ E1 = sqlite3MemRealloc(args);
+ }


// FP: xRekey

@transform_assign_xRekey_arrow@
expression E1, E2;
identifier FP_NAME = xRekey;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xRekey_signature, xRekey_signatures[xRekey_pcache1Rekey_enum], sizeof(E2->xRekey_signature)) == 0) {
+ E1 = pcache1Rekey(args);
+ }
+ else if (memcmp(E2->xRekey_signature, xRekey_signatures[xRekey_pcachetraceRekey_enum], sizeof(E2->xRekey_signature)) == 0) {
+ E1 = pcachetraceRekey(args);
+ }


// FP: xRelease

@transform_assign_xRelease_arrow@
expression E1, E2;
identifier FP_NAME = xRelease;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xRelease_signature, xRelease_signatures[xRelease_0_enum], sizeof(E2->xRelease_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xRelease_signature, xRelease_signatures[xRelease_fts3ReleaseMethod_enum], sizeof(E2->xRelease_signature)) == 0) {
+ E1 = fts3ReleaseMethod(args);
+ }


// FP: xRename

@transform_assign_xRename_arrow@
expression E1, E2;
identifier FP_NAME = xRename;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xRename_signature, xRename_signatures[xRename_0_enum], sizeof(E2->xRename_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xRename_signature, xRename_signatures[xRename_fts3RenameMethod_enum], sizeof(E2->xRename_signature)) == 0) {
+ E1 = fts3RenameMethod(args);
+ }
+ else if (memcmp(E2->xRename_signature, xRename_signatures[xRename_rtreeRename_enum], sizeof(E2->xRename_signature)) == 0) {
+ E1 = rtreeRename(args);
+ }
+ else if (memcmp(E2->xRename_signature, xRename_signatures[xRename_xRename_enum], sizeof(E2->xRename_signature)) == 0) {
+ E1 = xRename(args);
+ }


// FP: xRollback

@transform_assign_xRollback_arrow@
expression E1, E2;
identifier FP_NAME = xRollback;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xRollback_signature, xRollback_signatures[xRollback_0_enum], sizeof(E2->xRollback_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xRollback_signature, xRollback_signatures[xRollback_fts3RollbackMethod_enum], sizeof(E2->xRollback_signature)) == 0) {
+ E1 = fts3RollbackMethod(args);
+ }
+ else if (memcmp(E2->xRollback_signature, xRollback_signatures[xRollback_rtreeEndTransaction_enum], sizeof(E2->xRollback_signature)) == 0) {
+ E1 = rtreeEndTransaction(args);
+ }
+ else if (memcmp(E2->xRollback_signature, xRollback_signatures[xRollback_rtreeRollback_enum], sizeof(E2->xRollback_signature)) == 0) {
+ E1 = rtreeRollback(args);
+ }
+ else if (memcmp(E2->xRollback_signature, xRollback_signatures[xRollback_zipfileRollback_enum], sizeof(E2->xRollback_signature)) == 0) {
+ E1 = zipfileRollback(args);
+ }


// FP: xRollbackCallback

@transform_assign_xRollbackCallback_arrow@
expression E1, E2;
identifier FP_NAME = xRollbackCallback;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xRollbackCallback_signature, xRollbackCallback_signatures[xRollbackCallback_0_enum], sizeof(E2->xRollbackCallback_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xRollbackCallback_signature, xRollbackCallback_signatures[xRollbackCallback_sql_trace_callback_enum], sizeof(E2->xRollbackCallback_signature)) == 0) {
+ E1 = sql_trace_callback(args);
+ }
+ else if (memcmp(E2->xRollbackCallback_signature, xRollbackCallback_signatures[xRollbackCallback_sqlite3WalDefaultHook_enum], sizeof(E2->xRollbackCallback_signature)) == 0) {
+ E1 = sqlite3WalDefaultHook(args);
+ }


// FP: xRollbackTo

@transform_assign_xRollbackTo_arrow@
expression E1, E2;
identifier FP_NAME = xRollbackTo;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xRollbackTo_signature, xRollbackTo_signatures[xRollbackTo_0_enum], sizeof(E2->xRollbackTo_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xRollbackTo_signature, xRollbackTo_signatures[xRollbackTo_dbpageRollbackTo_enum], sizeof(E2->xRollbackTo_signature)) == 0) {
+ E1 = dbpageRollbackTo(args);
+ }
+ else if (memcmp(E2->xRollbackTo_signature, xRollbackTo_signatures[xRollbackTo_fts3RollbackToMethod_enum], sizeof(E2->xRollbackTo_signature)) == 0) {
+ E1 = fts3RollbackToMethod(args);
+ }


// FP: xRoundup

@transform_assign_xRoundup_arrow@
expression E1, E2;
identifier FP_NAME = xRoundup;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xRoundup_signature, xRoundup_signatures[xRoundup_memtraceRoundup_enum], sizeof(E2->xRoundup_signature)) == 0) {
+ E1 = memtraceRoundup(args);
+ }
+ else if (memcmp(E2->xRoundup_signature, xRoundup_signatures[xRoundup_sqlite3MemRoundup_enum], sizeof(E2->xRoundup_signature)) == 0) {
+ E1 = sqlite3MemRoundup(args);
+ }


// FP: xRowid

@transform_assign_xRowid_arrow@
expression E1, E2;
identifier FP_NAME = xRowid;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xRowid_signature, xRowid_signatures[xRowid_0_enum], sizeof(E2->xRowid_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xRowid_signature, xRowid_signatures[xRowid_bytecodevtabRowid_enum], sizeof(E2->xRowid_signature)) == 0) {
+ E1 = bytecodevtabRowid(args);
+ }
+ else if (memcmp(E2->xRowid_signature, xRowid_signatures[xRowid_completionRowid_enum], sizeof(E2->xRowid_signature)) == 0) {
+ E1 = completionRowid(args);
+ }
+ else if (memcmp(E2->xRowid_signature, xRowid_signatures[xRowid_dbdataRowid_enum], sizeof(E2->xRowid_signature)) == 0) {
+ E1 = dbdataRowid(args);
+ }
+ else if (memcmp(E2->xRowid_signature, xRowid_signatures[xRowid_dbpageRowid_enum], sizeof(E2->xRowid_signature)) == 0) {
+ E1 = dbpageRowid(args);
+ }
+ else if (memcmp(E2->xRowid_signature, xRowid_signatures[xRowid_expertRowid_enum], sizeof(E2->xRowid_signature)) == 0) {
+ E1 = expertRowid(args);
+ }
+ else if (memcmp(E2->xRowid_signature, xRowid_signatures[xRowid_fsdirRowid_enum], sizeof(E2->xRowid_signature)) == 0) {
+ E1 = fsdirRowid(args);
+ }
+ else if (memcmp(E2->xRowid_signature, xRowid_signatures[xRowid_fts3RowidMethod_enum], sizeof(E2->xRowid_signature)) == 0) {
+ E1 = fts3RowidMethod(args);
+ }
+ else if (memcmp(E2->xRowid_signature, xRowid_signatures[xRowid_fts3auxRowidMethod_enum], sizeof(E2->xRowid_signature)) == 0) {
+ E1 = fts3auxRowidMethod(args);
+ }
+ else if (memcmp(E2->xRowid_signature, xRowid_signatures[xRowid_fts3tokRowidMethod_enum], sizeof(E2->xRowid_signature)) == 0) {
+ E1 = fts3tokRowidMethod(args);
+ }
+ else if (memcmp(E2->xRowid_signature, xRowid_signatures[xRowid_jsonEachRowid_enum], sizeof(E2->xRowid_signature)) == 0) {
+ E1 = jsonEachRowid(args);
+ }
+ else if (memcmp(E2->xRowid_signature, xRowid_signatures[xRowid_pragmaVtabRowid_enum], sizeof(E2->xRowid_signature)) == 0) {
+ E1 = pragmaVtabRowid(args);
+ }
+ else if (memcmp(E2->xRowid_signature, xRowid_signatures[xRowid_rtreeRowid_enum], sizeof(E2->xRowid_signature)) == 0) {
+ E1 = rtreeRowid(args);
+ }
+ else if (memcmp(E2->xRowid_signature, xRowid_signatures[xRowid_seriesRowid_enum], sizeof(E2->xRowid_signature)) == 0) {
+ E1 = seriesRowid(args);
+ }
+ else if (memcmp(E2->xRowid_signature, xRowid_signatures[xRowid_statRowid_enum], sizeof(E2->xRowid_signature)) == 0) {
+ E1 = statRowid(args);
+ }
+ else if (memcmp(E2->xRowid_signature, xRowid_signatures[xRowid_stmtRowid_enum], sizeof(E2->xRowid_signature)) == 0) {
+ E1 = stmtRowid(args);
+ }


// FP: xSFunc

@transform_assign_xSFunc_arrow@
expression E1, E2;
identifier FP_NAME = xSFunc;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xSFunc_signature, xSFunc_signatures[xSFunc_0_enum], sizeof(E2->xSFunc_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xSFunc_signature, xSFunc_signatures[xSFunc_attachFunc_enum], sizeof(E2->xSFunc_signature)) == 0) {
+ E1 = attachFunc(args);
+ }
+ else if (memcmp(E2->xSFunc_signature, xSFunc_signatures[xSFunc_base64_enum], sizeof(E2->xSFunc_signature)) == 0) {
+ E1 = base64(args);
+ }
+ else if (memcmp(E2->xSFunc_signature, xSFunc_signatures[xSFunc_base85_enum], sizeof(E2->xSFunc_signature)) == 0) {
+ E1 = base85(args);
+ }
+ else if (memcmp(E2->xSFunc_signature, xSFunc_signatures[xSFunc_detachFunc_enum], sizeof(E2->xSFunc_signature)) == 0) {
+ E1 = detachFunc(args);
+ }
+ else if (memcmp(E2->xSFunc_signature, xSFunc_signatures[xSFunc_dummyUDF_enum], sizeof(E2->xSFunc_signature)) == 0) {
+ E1 = dummyUDF(args);
+ }
+ else if (memcmp(E2->xSFunc_signature, xSFunc_signatures[xSFunc_editFunc_enum], sizeof(E2->xSFunc_signature)) == 0) {
+ E1 = editFunc(args);
+ }
+ else if (memcmp(E2->xSFunc_signature, xSFunc_signatures[xSFunc_fts3AllocateMSI_enum], sizeof(E2->xSFunc_signature)) == 0) {
+ E1 = fts3AllocateMSI(args);
+ }
+ else if (memcmp(E2->xSFunc_signature, xSFunc_signatures[xSFunc_fts3ExprGlobalHitsCb_enum], sizeof(E2->xSFunc_signature)) == 0) {
+ E1 = fts3ExprGlobalHitsCb(args);
+ }
+ else if (memcmp(E2->xSFunc_signature, xSFunc_signatures[xSFunc_fts3ExprLoadDoclistsCb_enum], sizeof(E2->xSFunc_signature)) == 0) {
+ E1 = fts3ExprLoadDoclistsCb(args);
+ }
+ else if (memcmp(E2->xSFunc_signature, xSFunc_signatures[xSFunc_fts3ExprLocalHitsCb_enum], sizeof(E2->xSFunc_signature)) == 0) {
+ E1 = fts3ExprLocalHitsCb(args);
+ }
+ else if (memcmp(E2->xSFunc_signature, xSFunc_signatures[xSFunc_fts3ExprPhraseCountCb_enum], sizeof(E2->xSFunc_signature)) == 0) {
+ E1 = fts3ExprPhraseCountCb(args);
+ }
+ else if (memcmp(E2->xSFunc_signature, xSFunc_signatures[xSFunc_fts3ExprRestartIfCb_enum], sizeof(E2->xSFunc_signature)) == 0) {
+ E1 = fts3ExprRestartIfCb(args);
+ }
+ else if (memcmp(E2->xSFunc_signature, xSFunc_signatures[xSFunc_fts3ExprTermOffsetInit_enum], sizeof(E2->xSFunc_signature)) == 0) {
+ E1 = fts3ExprTermOffsetInit(args);
+ }
+ else if (memcmp(E2->xSFunc_signature, xSFunc_signatures[xSFunc_fts3ExprTest_enum], sizeof(E2->xSFunc_signature)) == 0) {
+ E1 = fts3ExprTest(args);
+ }
+ else if (memcmp(E2->xSFunc_signature, xSFunc_signatures[xSFunc_fts3ExprTestRebalance_enum], sizeof(E2->xSFunc_signature)) == 0) {
+ E1 = fts3ExprTestRebalance(args);
+ }
+ else if (memcmp(E2->xSFunc_signature, xSFunc_signatures[xSFunc_fts3MatchinfoLcsCb_enum], sizeof(E2->xSFunc_signature)) == 0) {
+ E1 = fts3MatchinfoLcsCb(args);
+ }
+ else if (memcmp(E2->xSFunc_signature, xSFunc_signatures[xSFunc_fts3SnippetFindPositions_enum], sizeof(E2->xSFunc_signature)) == 0) {
+ E1 = fts3SnippetFindPositions(args);
+ }
+ else if (memcmp(E2->xSFunc_signature, xSFunc_signatures[xSFunc_fts3TokenizerFunc_enum], sizeof(E2->xSFunc_signature)) == 0) {
+ E1 = fts3TokenizerFunc(args);
+ }
+ else if (memcmp(E2->xSFunc_signature, xSFunc_signatures[xSFunc_geomCallback_enum], sizeof(E2->xSFunc_signature)) == 0) {
+ E1 = geomCallback(args);
+ }
+ else if (memcmp(E2->xSFunc_signature, xSFunc_signatures[xSFunc_idxRemFunc_enum], sizeof(E2->xSFunc_signature)) == 0) {
+ E1 = idxRemFunc(args);
+ }
+ else if (memcmp(E2->xSFunc_signature, xSFunc_signatures[xSFunc_idxSampleFunc_enum], sizeof(E2->xSFunc_signature)) == 0) {
+ E1 = idxSampleFunc(args);
+ }
+ else if (memcmp(E2->xSFunc_signature, xSFunc_signatures[xSFunc_intTestFunc_enum], sizeof(E2->xSFunc_signature)) == 0) {
+ E1 = intTestFunc(args);
+ }
+ else if (memcmp(E2->xSFunc_signature, xSFunc_signatures[xSFunc_intckParseCreateIndexFunc_enum], sizeof(E2->xSFunc_signature)) == 0) {
+ E1 = intckParseCreateIndexFunc(args);
+ }
+ else if (memcmp(E2->xSFunc_signature, xSFunc_signatures[xSFunc_is_base85_enum], sizeof(E2->xSFunc_signature)) == 0) {
+ E1 = is_base85(args);
+ }
+ else if (memcmp(E2->xSFunc_signature, xSFunc_signatures[xSFunc_likeFunc_enum], sizeof(E2->xSFunc_signature)) == 0) {
+ E1 = likeFunc(args);
+ }
+ else if (memcmp(E2->xSFunc_signature, xSFunc_signatures[xSFunc_lsModeFunc_enum], sizeof(E2->xSFunc_signature)) == 0) {
+ E1 = lsModeFunc(args);
+ }
+ else if (memcmp(E2->xSFunc_signature, xSFunc_signatures[xSFunc_rbuFossilDeltaFunc_enum], sizeof(E2->xSFunc_signature)) == 0) {
+ E1 = rbuFossilDeltaFunc(args);
+ }
+ else if (memcmp(E2->xSFunc_signature, xSFunc_signatures[xSFunc_rbuIndexCntFunc_enum], sizeof(E2->xSFunc_signature)) == 0) {
+ E1 = rbuIndexCntFunc(args);
+ }
+ else if (memcmp(E2->xSFunc_signature, xSFunc_signatures[xSFunc_rbuTargetNameFunc_enum], sizeof(E2->xSFunc_signature)) == 0) {
+ E1 = rbuTargetNameFunc(args);
+ }
+ else if (memcmp(E2->xSFunc_signature, xSFunc_signatures[xSFunc_rbuTmpInsertFunc_enum], sizeof(E2->xSFunc_signature)) == 0) {
+ E1 = rbuTmpInsertFunc(args);
+ }
+ else if (memcmp(E2->xSFunc_signature, xSFunc_signatures[xSFunc_re_bytecode_func_enum], sizeof(E2->xSFunc_signature)) == 0) {
+ E1 = re_bytecode_func(args);
+ }
+ else if (memcmp(E2->xSFunc_signature, xSFunc_signatures[xSFunc_re_sql_func_enum], sizeof(E2->xSFunc_signature)) == 0) {
+ E1 = re_sql_func(args);
+ }
+ else if (memcmp(E2->xSFunc_signature, xSFunc_signatures[xSFunc_readfileFunc_enum], sizeof(E2->xSFunc_signature)) == 0) {
+ E1 = readfileFunc(args);
+ }
+ else if (memcmp(E2->xSFunc_signature, xSFunc_signatures[xSFunc_rtreecheck_enum], sizeof(E2->xSFunc_signature)) == 0) {
+ E1 = rtreecheck(args);
+ }
+ else if (memcmp(E2->xSFunc_signature, xSFunc_signatures[xSFunc_rtreedepth_enum], sizeof(E2->xSFunc_signature)) == 0) {
+ E1 = rtreedepth(args);
+ }
+ else if (memcmp(E2->xSFunc_signature, xSFunc_signatures[xSFunc_rtreenode_enum], sizeof(E2->xSFunc_signature)) == 0) {
+ E1 = rtreenode(args);
+ }
+ else if (memcmp(E2->xSFunc_signature, xSFunc_signatures[xSFunc_sha1Func_enum], sizeof(E2->xSFunc_signature)) == 0) {
+ E1 = sha1Func(args);
+ }
+ else if (memcmp(E2->xSFunc_signature, xSFunc_signatures[xSFunc_sha1QueryFunc_enum], sizeof(E2->xSFunc_signature)) == 0) {
+ E1 = sha1QueryFunc(args);
+ }
+ else if (memcmp(E2->xSFunc_signature, xSFunc_signatures[xSFunc_sha3Func_enum], sizeof(E2->xSFunc_signature)) == 0) {
+ E1 = sha3Func(args);
+ }
+ else if (memcmp(E2->xSFunc_signature, xSFunc_signatures[xSFunc_sha3QueryFunc_enum], sizeof(E2->xSFunc_signature)) == 0) {
+ E1 = sha3QueryFunc(args);
+ }
+ else if (memcmp(E2->xSFunc_signature, xSFunc_signatures[xSFunc_shellAddSchemaName_enum], sizeof(E2->xSFunc_signature)) == 0) {
+ E1 = shellAddSchemaName(args);
+ }
+ else if (memcmp(E2->xSFunc_signature, xSFunc_signatures[xSFunc_shellDtostr_enum], sizeof(E2->xSFunc_signature)) == 0) {
+ E1 = shellDtostr(args);
+ }
+ else if (memcmp(E2->xSFunc_signature, xSFunc_signatures[xSFunc_shellFkeyCollateClause_enum], sizeof(E2->xSFunc_signature)) == 0) {
+ E1 = shellFkeyCollateClause(args);
+ }
+ else if (memcmp(E2->xSFunc_signature, xSFunc_signatures[xSFunc_shellModuleSchema_enum], sizeof(E2->xSFunc_signature)) == 0) {
+ E1 = shellModuleSchema(args);
+ }
+ else if (memcmp(E2->xSFunc_signature, xSFunc_signatures[xSFunc_shellPutsFunc_enum], sizeof(E2->xSFunc_signature)) == 0) {
+ E1 = shellPutsFunc(args);
+ }
+ else if (memcmp(E2->xSFunc_signature, xSFunc_signatures[xSFunc_shellStrtod_enum], sizeof(E2->xSFunc_signature)) == 0) {
+ E1 = shellStrtod(args);
+ }
+ else if (memcmp(E2->xSFunc_signature, xSFunc_signatures[xSFunc_shellUSleepFunc_enum], sizeof(E2->xSFunc_signature)) == 0) {
+ E1 = shellUSleepFunc(args);
+ }
+ else if (memcmp(E2->xSFunc_signature, xSFunc_signatures[xSFunc_sqlarCompressFunc_enum], sizeof(E2->xSFunc_signature)) == 0) {
+ E1 = sqlarCompressFunc(args);
+ }
+ else if (memcmp(E2->xSFunc_signature, xSFunc_signatures[xSFunc_sqlarUncompressFunc_enum], sizeof(E2->xSFunc_signature)) == 0) {
+ E1 = sqlarUncompressFunc(args);
+ }
+ else if (memcmp(E2->xSFunc_signature, xSFunc_signatures[xSFunc_sqlite3InvalidFunction_enum], sizeof(E2->xSFunc_signature)) == 0) {
+ E1 = sqlite3InvalidFunction(args);
+ }
+ else if (memcmp(E2->xSFunc_signature, xSFunc_signatures[xSFunc_statGet_enum], sizeof(E2->xSFunc_signature)) == 0) {
+ E1 = statGet(args);
+ }
+ else if (memcmp(E2->xSFunc_signature, xSFunc_signatures[xSFunc_statInit_enum], sizeof(E2->xSFunc_signature)) == 0) {
+ E1 = statInit(args);
+ }
+ else if (memcmp(E2->xSFunc_signature, xSFunc_signatures[xSFunc_statPush_enum], sizeof(E2->xSFunc_signature)) == 0) {
+ E1 = statPush(args);
+ }
+ else if (memcmp(E2->xSFunc_signature, xSFunc_signatures[xSFunc_stmtrandFunc_enum], sizeof(E2->xSFunc_signature)) == 0) {
+ E1 = stmtrandFunc(args);
+ }
+ else if (memcmp(E2->xSFunc_signature, xSFunc_signatures[xSFunc_testFunc_enum], sizeof(E2->xSFunc_signature)) == 0) {
+ E1 = testFunc(args);
+ }
+ else if (memcmp(E2->xSFunc_signature, xSFunc_signatures[xSFunc_writefileFunc_enum], sizeof(E2->xSFunc_signature)) == 0) {
+ E1 = writefileFunc(args);
+ }


// FP: xSavepoint

@transform_assign_xSavepoint_arrow@
expression E1, E2;
identifier FP_NAME = xSavepoint;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xSavepoint_signature, xSavepoint_signatures[xSavepoint_0_enum], sizeof(E2->xSavepoint_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xSavepoint_signature, xSavepoint_signatures[xSavepoint_fts3SavepointMethod_enum], sizeof(E2->xSavepoint_signature)) == 0) {
+ E1 = fts3SavepointMethod(args);
+ }
+ else if (memcmp(E2->xSavepoint_signature, xSavepoint_signatures[xSavepoint_rtreeSavepoint_enum], sizeof(E2->xSavepoint_signature)) == 0) {
+ E1 = rtreeSavepoint(args);
+ }


// FP: xSectorSize

@transform_assign_xSectorSize_arrow@
expression E1, E2;
identifier FP_NAME = xSectorSize;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xSectorSize_signature, xSectorSize_signatures[xSectorSize_0_enum], sizeof(E2->xSectorSize_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xSectorSize_signature, xSectorSize_signatures[xSectorSize_apndSectorSize_enum], sizeof(E2->xSectorSize_signature)) == 0) {
+ E1 = apndSectorSize(args);
+ }
+ else if (memcmp(E2->xSectorSize_signature, xSectorSize_signatures[xSectorSize_recoverVfsSectorSize_enum], sizeof(E2->xSectorSize_signature)) == 0) {
+ E1 = recoverVfsSectorSize(args);
+ }
+ else if (memcmp(E2->xSectorSize_signature, xSectorSize_signatures[xSectorSize_vfstraceSectorSize_enum], sizeof(E2->xSectorSize_signature)) == 0) {
+ E1 = vfstraceSectorSize(args);
+ }


// FP: xSelectCallback

@transform_assign_xSelectCallback_arrow@
expression E1, E2;
identifier FP_NAME = xSelectCallback;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_0_enum], sizeof(E2->xSelectCallback_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_convertCompoundSelectToSubquery_enum], sizeof(E2->xSelectCallback_signature)) == 0) {
+ E1 = convertCompoundSelectToSubquery(args);
+ }
+ else if (memcmp(E2->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_exprSelectWalkTableConstant_enum], sizeof(E2->xSelectCallback_signature)) == 0) {
+ E1 = exprSelectWalkTableConstant(args);
+ }
+ else if (memcmp(E2->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_fixSelectCb_enum], sizeof(E2->xSelectCallback_signature)) == 0) {
+ E1 = fixSelectCb(args);
+ }
+ else if (memcmp(E2->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_gatherSelectWindowsSelectCallback_enum], sizeof(E2->xSelectCallback_signature)) == 0) {
+ E1 = gatherSelectWindowsSelectCallback(args);
+ }
+ else if (memcmp(E2->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_renameColumnSelectCb_enum], sizeof(E2->xSelectCallback_signature)) == 0) {
+ E1 = renameColumnSelectCb(args);
+ }
+ else if (memcmp(E2->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_renameTableSelectCb_enum], sizeof(E2->xSelectCallback_signature)) == 0) {
+ E1 = renameTableSelectCb(args);
+ }
+ else if (memcmp(E2->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_renameUnmapSelectCb_enum], sizeof(E2->xSelectCallback_signature)) == 0) {
+ E1 = renameUnmapSelectCb(args);
+ }
+ else if (memcmp(E2->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_resolveSelectStep_enum], sizeof(E2->xSelectCallback_signature)) == 0) {
+ E1 = resolveSelectStep(args);
+ }
+ else if (memcmp(E2->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_selectCheckOnClausesSelect_enum], sizeof(E2->xSelectCallback_signature)) == 0) {
+ E1 = selectCheckOnClausesSelect(args);
+ }
+ else if (memcmp(E2->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_selectExpander_enum], sizeof(E2->xSelectCallback_signature)) == 0) {
+ E1 = selectExpander(args);
+ }
+ else if (memcmp(E2->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_selectRefEnter_enum], sizeof(E2->xSelectCallback_signature)) == 0) {
+ E1 = selectRefEnter(args);
+ }
+ else if (memcmp(E2->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_selectWindowRewriteSelectCb_enum], sizeof(E2->xSelectCallback_signature)) == 0) {
+ E1 = selectWindowRewriteSelectCb(args);
+ }
+ else if (memcmp(E2->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_sqlite3ReturningSubqueryCorrelated_enum], sizeof(E2->xSelectCallback_signature)) == 0) {
+ E1 = sqlite3ReturningSubqueryCorrelated(args);
+ }
+ else if (memcmp(E2->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_sqlite3SelectWalkFail_enum], sizeof(E2->xSelectCallback_signature)) == 0) {
+ E1 = sqlite3SelectWalkFail(args);
+ }
+ else if (memcmp(E2->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_sqlite3SelectWalkNoop_enum], sizeof(E2->xSelectCallback_signature)) == 0) {
+ E1 = sqlite3SelectWalkNoop(args);
+ }
+ else if (memcmp(E2->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_sqlite3WalkerDepthIncrease_enum], sizeof(E2->xSelectCallback_signature)) == 0) {
+ E1 = sqlite3WalkerDepthIncrease(args);
+ }


// FP: xSelectCallback2

@transform_assign_xSelectCallback2_arrow@
expression E1, E2;
identifier FP_NAME = xSelectCallback2;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_0_enum], sizeof(E2->xSelectCallback2_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_selectAddSubqueryTypeInfo_enum], sizeof(E2->xSelectCallback2_signature)) == 0) {
+ E1 = selectAddSubqueryTypeInfo(args);
+ }
+ else if (memcmp(E2->xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_selectRefLeave_enum], sizeof(E2->xSelectCallback2_signature)) == 0) {
+ E1 = selectRefLeave(args);
+ }
+ else if (memcmp(E2->xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_sqlite3SelectPopWith_enum], sizeof(E2->xSelectCallback2_signature)) == 0) {
+ E1 = sqlite3SelectPopWith(args);
+ }
+ else if (memcmp(E2->xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_sqlite3WalkWinDefnDummyCallback_enum], sizeof(E2->xSelectCallback2_signature)) == 0) {
+ E1 = sqlite3WalkWinDefnDummyCallback(args);
+ }
+ else if (memcmp(E2->xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_sqlite3WalkerDepthDecrease_enum], sizeof(E2->xSelectCallback2_signature)) == 0) {
+ E1 = sqlite3WalkerDepthDecrease(args);
+ }


// FP: xSetSystemCall

@transform_assign_xSetSystemCall_arrow@
expression E1, E2;
identifier FP_NAME = xSetSystemCall;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xSetSystemCall_signature, xSetSystemCall_signatures[xSetSystemCall_0_enum], sizeof(E2->xSetSystemCall_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xSetSystemCall_signature, xSetSystemCall_signatures[xSetSystemCall_apndSetSystemCall_enum], sizeof(E2->xSetSystemCall_signature)) == 0) {
+ E1 = apndSetSystemCall(args);
+ }
+ else if (memcmp(E2->xSetSystemCall_signature, xSetSystemCall_signatures[xSetSystemCall_rbuVfsSleep_enum], sizeof(E2->xSetSystemCall_signature)) == 0) {
+ E1 = rbuVfsSleep(args);
+ }
+ else if (memcmp(E2->xSetSystemCall_signature, xSetSystemCall_signatures[xSetSystemCall_unixSetSystemCall_enum], sizeof(E2->xSetSystemCall_signature)) == 0) {
+ E1 = unixSetSystemCall(args);
+ }


// FP: xShadowName

@transform_assign_xShadowName_arrow@
expression E1, E2;
identifier FP_NAME = xShadowName;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xShadowName_signature, xShadowName_signatures[xShadowName_0_enum], sizeof(E2->xShadowName_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xShadowName_signature, xShadowName_signatures[xShadowName_fts3ShadowName_enum], sizeof(E2->xShadowName_signature)) == 0) {
+ E1 = fts3ShadowName(args);
+ }
+ else if (memcmp(E2->xShadowName_signature, xShadowName_signatures[xShadowName_rtreeShadowName_enum], sizeof(E2->xShadowName_signature)) == 0) {
+ E1 = rtreeShadowName(args);
+ }


// FP: xShmBarrier

@transform_assign_xShmBarrier_arrow@
expression E1, E2;
identifier FP_NAME = xShmBarrier;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xShmBarrier_signature, xShmBarrier_signatures[xShmBarrier_0_enum], sizeof(E2->xShmBarrier_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xShmBarrier_signature, xShmBarrier_signatures[xShmBarrier_apndShmBarrier_enum], sizeof(E2->xShmBarrier_signature)) == 0) {
+ E1 = apndShmBarrier(args);
+ }
+ else if (memcmp(E2->xShmBarrier_signature, xShmBarrier_signatures[xShmBarrier_recoverVfsShmBarrier_enum], sizeof(E2->xShmBarrier_signature)) == 0) {
+ E1 = recoverVfsShmBarrier(args);
+ }


// FP: xShmLock

@transform_assign_xShmLock_arrow@
expression E1, E2;
identifier FP_NAME = xShmLock;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xShmLock_signature, xShmLock_signatures[xShmLock_0_enum], sizeof(E2->xShmLock_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xShmLock_signature, xShmLock_signatures[xShmLock_apndShmLock_enum], sizeof(E2->xShmLock_signature)) == 0) {
+ E1 = apndShmLock(args);
+ }
+ else if (memcmp(E2->xShmLock_signature, xShmLock_signatures[xShmLock_recoverVfsShmLock_enum], sizeof(E2->xShmLock_signature)) == 0) {
+ E1 = recoverVfsShmLock(args);
+ }


// FP: xShmMap

@transform_assign_xShmMap_arrow@
expression E1, E2;
identifier FP_NAME = xShmMap;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xShmMap_signature, xShmMap_signatures[xShmMap_0_enum], sizeof(E2->xShmMap_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xShmMap_signature, xShmMap_signatures[xShmMap_apndShmMap_enum], sizeof(E2->xShmMap_signature)) == 0) {
+ E1 = apndShmMap(args);
+ }
+ else if (memcmp(E2->xShmMap_signature, xShmMap_signatures[xShmMap_recoverVfsShmMap_enum], sizeof(E2->xShmMap_signature)) == 0) {
+ E1 = recoverVfsShmMap(args);
+ }


// FP: xShmUnmap

@transform_assign_xShmUnmap_arrow@
expression E1, E2;
identifier FP_NAME = xShmUnmap;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xShmUnmap_signature, xShmUnmap_signatures[xShmUnmap_0_enum], sizeof(E2->xShmUnmap_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xShmUnmap_signature, xShmUnmap_signatures[xShmUnmap_apndShmUnmap_enum], sizeof(E2->xShmUnmap_signature)) == 0) {
+ E1 = apndShmUnmap(args);
+ }
+ else if (memcmp(E2->xShmUnmap_signature, xShmUnmap_signatures[xShmUnmap_recoverVfsShmUnmap_enum], sizeof(E2->xShmUnmap_signature)) == 0) {
+ E1 = recoverVfsShmUnmap(args);
+ }


// FP: xShrink

@transform_assign_xShrink_arrow@
expression E1, E2;
identifier FP_NAME = xShrink;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xShrink_signature, xShrink_signatures[xShrink_pcache1Shrink_enum], sizeof(E2->xShrink_signature)) == 0) {
+ E1 = pcache1Shrink(args);
+ }
+ else if (memcmp(E2->xShrink_signature, xShrink_signatures[xShrink_pcachetraceShrink_enum], sizeof(E2->xShrink_signature)) == 0) {
+ E1 = pcachetraceShrink(args);
+ }


// FP: xShutdown

@transform_assign_xShutdown_arrow@
expression E1, E2;
identifier FP_NAME = xShutdown;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xShutdown_signature, xShutdown_signatures[xShutdown_memtraceShutdown_enum], sizeof(E2->xShutdown_signature)) == 0) {
+ E1 = memtraceShutdown(args);
+ }
+ else if (memcmp(E2->xShutdown_signature, xShutdown_signatures[xShutdown_pcache1Shutdown_enum], sizeof(E2->xShutdown_signature)) == 0) {
+ E1 = pcache1Shutdown(args);
+ }
+ else if (memcmp(E2->xShutdown_signature, xShutdown_signatures[xShutdown_pcachetraceShutdown_enum], sizeof(E2->xShutdown_signature)) == 0) {
+ E1 = pcachetraceShutdown(args);
+ }
+ else if (memcmp(E2->xShutdown_signature, xShutdown_signatures[xShutdown_sqlite3MemShutdown_enum], sizeof(E2->xShutdown_signature)) == 0) {
+ E1 = sqlite3MemShutdown(args);
+ }


// FP: xSize

@transform_assign_xSize_arrow@
expression E1, E2;
identifier FP_NAME = xSize;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xSize_signature, xSize_signatures[xSize_memtraceSize_enum], sizeof(E2->xSize_signature)) == 0) {
+ E1 = memtraceSize(args);
+ }
+ else if (memcmp(E2->xSize_signature, xSize_signatures[xSize_sqlite3MemSize_enum], sizeof(E2->xSize_signature)) == 0) {
+ E1 = sqlite3MemSize(args);
+ }


// FP: xSleep

@transform_assign_xSleep_arrow@
expression E1, E2;
identifier FP_NAME = xSleep;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xSleep_signature, xSleep_signatures[xSleep_0_enum], sizeof(E2->xSleep_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xSleep_signature, xSleep_signatures[xSleep_apndSleep_enum], sizeof(E2->xSleep_signature)) == 0) {
+ E1 = apndSleep(args);
+ }
+ else if (memcmp(E2->xSleep_signature, xSleep_signatures[xSleep_memdbSleep_enum], sizeof(E2->xSleep_signature)) == 0) {
+ E1 = memdbSleep(args);
+ }
+ else if (memcmp(E2->xSleep_signature, xSleep_signatures[xSleep_vfstraceSleep_enum], sizeof(E2->xSleep_signature)) == 0) {
+ E1 = vfstraceSleep(args);
+ }
+ else if (memcmp(E2->xSleep_signature, xSleep_signatures[xSleep_unixSleep_enum], sizeof(E2->xSleep_signature)) == 0) {
+ E1 = unixSleep(args);
+ }


// FP: xSql

@transform_assign_xSql_arrow@
expression E1, E2;
identifier FP_NAME = xSql;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xSql_signature, xSql_signatures[xSql_0_enum], sizeof(E2->xSql_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xSql_signature, xSql_signatures[xSql_recoverSqlCb_enum], sizeof(E2->xSql_signature)) == 0) {
+ E1 = recoverSqlCb(args);
+ }


// FP: xSync

@transform_assign_xSync_arrow@
expression E1, E2;
identifier FP_NAME = xSync;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xSync_signature, xSync_signatures[xSync_0_enum], sizeof(E2->xSync_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xSync_signature, xSync_signatures[xSync_apndSync_enum], sizeof(E2->xSync_signature)) == 0) {
+ E1 = apndSync(args);
+ }
+ else if (memcmp(E2->xSync_signature, xSync_signatures[xSync_dbpageSync_enum], sizeof(E2->xSync_signature)) == 0) {
+ E1 = dbpageSync(args);
+ }
+ else if (memcmp(E2->xSync_signature, xSync_signatures[xSync_fts3SyncMethod_enum], sizeof(E2->xSync_signature)) == 0) {
+ E1 = fts3SyncMethod(args);
+ }
+ else if (memcmp(E2->xSync_signature, xSync_signatures[xSync_memdbSync_enum], sizeof(E2->xSync_signature)) == 0) {
+ E1 = memdbSync(args);
+ }
+ else if (memcmp(E2->xSync_signature, xSync_signatures[xSync_memjrnlSync_enum], sizeof(E2->xSync_signature)) == 0) {
+ E1 = memjrnlSync(args);
+ }
+ else if (memcmp(E2->xSync_signature, xSync_signatures[xSync_recoverVfsSync_enum], sizeof(E2->xSync_signature)) == 0) {
+ E1 = recoverVfsSync(args);
+ }
+ else if (memcmp(E2->xSync_signature, xSync_signatures[xSync_rtreeEndTransaction_enum], sizeof(E2->xSync_signature)) == 0) {
+ E1 = rtreeEndTransaction(args);
+ }
+ else if (memcmp(E2->xSync_signature, xSync_signatures[xSync_vfstraceSync_enum], sizeof(E2->xSync_signature)) == 0) {
+ E1 = vfstraceSync(args);
+ }


// FP: xTableFilter

@transform_assign_xTableFilter_arrow@
expression E1, E2;
identifier FP_NAME = xTableFilter;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xTableFilter_signature, xTableFilter_signatures[xTableFilter_0_enum], sizeof(E2->xTableFilter_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xTableFilter_signature, xTableFilter_signatures[xTableFilter_session_filter_enum], sizeof(E2->xTableFilter_signature)) == 0) {
+ E1 = session_filter(args);
+ }


// FP: xTask

@transform_assign_xTask_arrow@
expression E1, E2;
identifier FP_NAME = xTask;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xTask_signature, xTask_signatures[xTask_0_enum], sizeof(E2->xTask_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xTask_signature, xTask_signatures[xTask_vdbeSorterFlushThread_enum], sizeof(E2->xTask_signature)) == 0) {
+ E1 = vdbeSorterFlushThread(args);
+ }
+ else if (memcmp(E2->xTask_signature, xTask_signatures[xTask_vdbeIncrPopulateThread_enum], sizeof(E2->xTask_signature)) == 0) {
+ E1 = vdbeIncrPopulateThread(args);
+ }
+ else if (memcmp(E2->xTask_signature, xTask_signatures[xTask_vdbePmaReaderBgIncrInit_enum], sizeof(E2->xTask_signature)) == 0) {
+ E1 = vdbePmaReaderBgIncrInit(args);
+ }


// FP: xTruncate

@transform_assign_xTruncate_arrow@
expression E1, E2;
identifier FP_NAME = xTruncate;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xTruncate_signature, xTruncate_signatures[xTruncate_apndTruncate_enum], sizeof(E2->xTruncate_signature)) == 0) {
+ E1 = apndTruncate(args);
+ }
+ else if (memcmp(E2->xTruncate_signature, xTruncate_signatures[xTruncate_memdbTruncate_enum], sizeof(E2->xTruncate_signature)) == 0) {
+ E1 = memdbTruncate(args);
+ }
+ else if (memcmp(E2->xTruncate_signature, xTruncate_signatures[xTruncate_memjrnlTruncate_enum], sizeof(E2->xTruncate_signature)) == 0) {
+ E1 = memjrnlTruncate(args);
+ }
+ else if (memcmp(E2->xTruncate_signature, xTruncate_signatures[xTruncate_pcache1Truncate_enum], sizeof(E2->xTruncate_signature)) == 0) {
+ E1 = pcache1Truncate(args);
+ }
+ else if (memcmp(E2->xTruncate_signature, xTruncate_signatures[xTruncate_pcachetraceTruncate_enum], sizeof(E2->xTruncate_signature)) == 0) {
+ E1 = pcachetraceTruncate(args);
+ }
+ else if (memcmp(E2->xTruncate_signature, xTruncate_signatures[xTruncate_recoverVfsTruncate_enum], sizeof(E2->xTruncate_signature)) == 0) {
+ E1 = recoverVfsTruncate(args);
+ }
+ else if (memcmp(E2->xTruncate_signature, xTruncate_signatures[xTruncate_vfstraceTruncate_enum], sizeof(E2->xTruncate_signature)) == 0) {
+ E1 = vfstraceTruncate(args);
+ }


// FP: xUnfetch

@transform_assign_xUnfetch_arrow@
expression E1, E2;
identifier FP_NAME = xUnfetch;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xUnfetch_signature, xUnfetch_signatures[xUnfetch_0_enum], sizeof(E2->xUnfetch_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xUnfetch_signature, xUnfetch_signatures[xUnfetch_apndUnfetch_enum], sizeof(E2->xUnfetch_signature)) == 0) {
+ E1 = apndUnfetch(args);
+ }
+ else if (memcmp(E2->xUnfetch_signature, xUnfetch_signatures[xUnfetch_memdbUnfetch_enum], sizeof(E2->xUnfetch_signature)) == 0) {
+ E1 = memdbUnfetch(args);
+ }
+ else if (memcmp(E2->xUnfetch_signature, xUnfetch_signatures[xUnfetch_recoverVfsUnfetch_enum], sizeof(E2->xUnfetch_signature)) == 0) {
+ E1 = recoverVfsUnfetch(args);
+ }


// FP: xUnlock

@transform_assign_xUnlock_arrow@
expression E1, E2;
identifier FP_NAME = xUnlock;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xUnlock_signature, xUnlock_signatures[xUnlock_0_enum], sizeof(E2->xUnlock_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xUnlock_signature, xUnlock_signatures[xUnlock_apndUnlock_enum], sizeof(E2->xUnlock_signature)) == 0) {
+ E1 = apndUnlock(args);
+ }
+ else if (memcmp(E2->xUnlock_signature, xUnlock_signatures[xUnlock_memdbUnlock_enum], sizeof(E2->xUnlock_signature)) == 0) {
+ E1 = memdbUnlock(args);
+ }
+ else if (memcmp(E2->xUnlock_signature, xUnlock_signatures[xUnlock_recoverVfsUnlock_enum], sizeof(E2->xUnlock_signature)) == 0) {
+ E1 = recoverVfsUnlock(args);
+ }
+ else if (memcmp(E2->xUnlock_signature, xUnlock_signatures[xUnlock_vfstraceUnlock_enum], sizeof(E2->xUnlock_signature)) == 0) {
+ E1 = vfstraceUnlock(args);
+ }


// FP: xUnlockNotify

@transform_assign_xUnlockNotify_arrow@
expression E1, E2;
identifier FP_NAME = xUnlockNotify;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xUnlockNotify_signature, xUnlockNotify_signatures[xUnlockNotify_0_enum], sizeof(E2->xUnlockNotify_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xUnlockNotify_signature, xUnlockNotify_signatures[xUnlockNotify_xUnlockNotify_enum], sizeof(E2->xUnlockNotify_signature)) == 0) {
+ E1 = xUnlockNotify(args);
+ }


// FP: xUnpin

@transform_assign_xUnpin_arrow@
expression E1, E2;
identifier FP_NAME = xUnpin;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xUnpin_signature, xUnpin_signatures[xUnpin_pcache1Unpin_enum], sizeof(E2->xUnpin_signature)) == 0) {
+ E1 = pcache1Unpin(args);
+ }
+ else if (memcmp(E2->xUnpin_signature, xUnpin_signatures[xUnpin_pcachetraceUnpin_enum], sizeof(E2->xUnpin_signature)) == 0) {
+ E1 = pcachetraceUnpin(args);
+ }


// FP: xUpdate

@transform_assign_xUpdate_arrow@
expression E1, E2;
identifier FP_NAME = xUpdate;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xUpdate_signature, xUpdate_signatures[xUpdate_0_enum], sizeof(E2->xUpdate_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xUpdate_signature, xUpdate_signatures[xUpdate_dbpageUpdate_enum], sizeof(E2->xUpdate_signature)) == 0) {
+ E1 = dbpageUpdate(args);
+ }
+ else if (memcmp(E2->xUpdate_signature, xUpdate_signatures[xUpdate_expertUpdate_enum], sizeof(E2->xUpdate_signature)) == 0) {
+ E1 = expertUpdate(args);
+ }
+ else if (memcmp(E2->xUpdate_signature, xUpdate_signatures[xUpdate_fts3UpdateMethod_enum], sizeof(E2->xUpdate_signature)) == 0) {
+ E1 = fts3UpdateMethod(args);
+ }
+ else if (memcmp(E2->xUpdate_signature, xUpdate_signatures[xUpdate_geopolyUpdate_enum], sizeof(E2->xUpdate_signature)) == 0) {
+ E1 = geopolyUpdate(args);
+ }
+ else if (memcmp(E2->xUpdate_signature, xUpdate_signatures[xUpdate_rtreeUpdate_enum], sizeof(E2->xUpdate_signature)) == 0) {
+ E1 = rtreeUpdate(args);
+ }
+ else if (memcmp(E2->xUpdate_signature, xUpdate_signatures[xUpdate_zipfileUpdate_enum], sizeof(E2->xUpdate_signature)) == 0) {
+ E1 = zipfileUpdate(args);
+ }


// FP: xUpdateCallback

@transform_assign_xUpdateCallback_arrow@
expression E1, E2;
identifier FP_NAME = xUpdateCallback;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xUpdateCallback_signature, xUpdateCallback_signatures[xUpdateCallback_0_enum], sizeof(E2->xUpdateCallback_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xUpdateCallback_signature, xUpdateCallback_signatures[xUpdateCallback_sql_trace_callback_enum], sizeof(E2->xUpdateCallback_signature)) == 0) {
+ E1 = sql_trace_callback(args);
+ }
+ else if (memcmp(E2->xUpdateCallback_signature, xUpdateCallback_signatures[xUpdateCallback_sqlite3WalDefaultHook_enum], sizeof(E2->xUpdateCallback_signature)) == 0) {
+ E1 = sqlite3WalDefaultHook(args);
+ }


// FP: xV2

@transform_assign_xV2_arrow@
expression E1, E2;
identifier FP_NAME = xV2;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xV2_signature, xV2_signatures[xV2_0_enum], sizeof(E2->xV2_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xV2_signature, xV2_signatures[xV2_sql_trace_callback_enum], sizeof(E2->xV2_signature)) == 0) {
+ E1 = sql_trace_callback(args);
+ }


// FP: xValue

@transform_assign_xValue_arrow@
expression E1, E2;
identifier FP_NAME = xValue;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xValue_signature, xValue_signatures[xValue_0_enum], sizeof(E2->xValue_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xValue_signature, xValue_signatures[xValue_decimalSumValue_enum], sizeof(E2->xValue_signature)) == 0) {
+ E1 = decimalSumValue(args);
+ }
+ else if (memcmp(E2->xValue_signature, xValue_signatures[xValue_percentValue_enum], sizeof(E2->xValue_signature)) == 0) {
+ E1 = percentValue(args);
+ }
+ else if (memcmp(E2->xValue_signature, xValue_signatures[xValue_sqlite3changeset_new_enum], sizeof(E2->xValue_signature)) == 0) {
+ E1 = sqlite3changeset_new(args);
+ }
+ else if (memcmp(E2->xValue_signature, xValue_signatures[xValue_sqlite3changeset_old_enum], sizeof(E2->xValue_signature)) == 0) {
+ E1 = sqlite3changeset_old(args);
+ }


// FP: xWrite

@transform_assign_xWrite_arrow@
expression E1, E2;
identifier FP_NAME = xWrite;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xWrite_signature, xWrite_signatures[xWrite_apndWrite_enum], sizeof(E2->xWrite_signature)) == 0) {
+ E1 = apndWrite(args);
+ }
+ else if (memcmp(E2->xWrite_signature, xWrite_signatures[xWrite_kvstorageWrite_enum], sizeof(E2->xWrite_signature)) == 0) {
+ E1 = kvstorageWrite(args);
+ }
+ else if (memcmp(E2->xWrite_signature, xWrite_signatures[xWrite_memdbWrite_enum], sizeof(E2->xWrite_signature)) == 0) {
+ E1 = memdbWrite(args);
+ }
+ else if (memcmp(E2->xWrite_signature, xWrite_signatures[xWrite_memjrnlWrite_enum], sizeof(E2->xWrite_signature)) == 0) {
+ E1 = memjrnlWrite(args);
+ }
+ else if (memcmp(E2->xWrite_signature, xWrite_signatures[xWrite_recoverVfsWrite_enum], sizeof(E2->xWrite_signature)) == 0) {
+ E1 = recoverVfsWrite(args);
+ }
+ else if (memcmp(E2->xWrite_signature, xWrite_signatures[xWrite_vfstraceWrite_enum], sizeof(E2->xWrite_signature)) == 0) {
+ E1 = vfstraceWrite(args);
+ }


// FP: xsnprintf

@transform_assign_xsnprintf_arrow@
expression E1, E2;
identifier FP_NAME = xsnprintf;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = sqlite3_set_authorizer(args);


// FP: xvsnprintf

@transform_assign_xvsnprintf_arrow@
expression E1, E2;
identifier FP_NAME = xvsnprintf;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ // E1 = E2->FP_NAME(args);
+ E1 = 0;

// Total assignment arrow rules: 359

// ===== ASSIGNMENT DOT TRANSFORMATION RULES =====
// Pattern: E1 = E2.fp_name(args);


// FP: aggregate_context

@transform_assign_aggregate_context_dot@
expression E1, E2;
identifier FP_NAME = aggregate_context;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_aggregate_context(args);


// FP: auto_extension

@transform_assign_auto_extension_dot@
expression E1, E2;
identifier FP_NAME = auto_extension;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_vtab_config(args);


// FP: backup_finish

@transform_assign_backup_finish_dot@
expression E1, E2;
identifier FP_NAME = backup_finish;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_result_error_code(args);


// FP: backup_init

@transform_assign_backup_init_dot@
expression E1, E2;
identifier FP_NAME = backup_init;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_test_control(args);


// FP: backup_pagecount

@transform_assign_backup_pagecount_dot@
expression E1, E2;
identifier FP_NAME = backup_pagecount;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_randomness(args);


// FP: backup_remaining

@transform_assign_backup_remaining_dot@
expression E1, E2;
identifier FP_NAME = backup_remaining;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_context_db_handle(args);


// FP: backup_step

@transform_assign_backup_step_dot@
expression E1, E2;
identifier FP_NAME = backup_step;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_extended_result_codes(args);


// FP: bind_blob64

@transform_assign_bind_blob64_dot@
expression E1, E2;
identifier FP_NAME = bind_blob64;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_vtab_on_conflict(args);


// FP: bind_int

@transform_assign_bind_int_dot@
expression E1, E2;
identifier FP_NAME = bind_int;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_bind_double(args);


// FP: bind_int64

@transform_assign_bind_int64_dot@
expression E1, E2;
identifier FP_NAME = bind_int64;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_bind_int(args);


// FP: bind_null

@transform_assign_bind_null_dot@
expression E1, E2;
identifier FP_NAME = bind_null;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_bind_int64(args);


// FP: bind_parameter_count

@transform_assign_bind_parameter_count_dot@
expression E1, E2;
identifier FP_NAME = bind_parameter_count;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_bind_null(args);


// FP: bind_parameter_index

@transform_assign_bind_parameter_index_dot@
expression E1, E2;
identifier FP_NAME = bind_parameter_index;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_bind_parameter_count(args);


// FP: bind_parameter_name

@transform_assign_bind_parameter_name_dot@
expression E1, E2;
identifier FP_NAME = bind_parameter_name;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_bind_parameter_index(args);


// FP: bind_text

@transform_assign_bind_text_dot@
expression E1, E2;
identifier FP_NAME = bind_text;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_bind_parameter_name(args);


// FP: bind_text16

@transform_assign_bind_text16_dot@
expression E1, E2;
identifier FP_NAME = bind_text16;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_bind_text(args);


// FP: bind_text64

@transform_assign_bind_text64_dot@
expression E1, E2;
identifier FP_NAME = bind_text64;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_close_v2(args);


// FP: bind_value

@transform_assign_bind_value_dot@
expression E1, E2;
identifier FP_NAME = bind_value;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_bind_text16(args);


// FP: bind_zeroblob

@transform_assign_bind_zeroblob_dot@
expression E1, E2;
identifier FP_NAME = bind_zeroblob;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_prepare_v2(args);


// FP: bind_zeroblob64

@transform_assign_bind_zeroblob64_dot@
expression E1, E2;
identifier FP_NAME = bind_zeroblob64;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_auto_extension(args);


// FP: blob_bytes

@transform_assign_blob_bytes_dot@
expression E1, E2;
identifier FP_NAME = blob_bytes;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_prepare16_v2(args);


// FP: blob_close

@transform_assign_blob_close_dot@
expression E1, E2;
identifier FP_NAME = blob_close;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_clear_bindings(args);


// FP: blob_open

@transform_assign_blob_open_dot@
expression E1, E2;
identifier FP_NAME = blob_open;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_create_module_v2(args);


// FP: blob_read

@transform_assign_blob_read_dot@
expression E1, E2;
identifier FP_NAME = blob_read;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_bind_zeroblob(args);


// FP: blob_reopen

@transform_assign_blob_reopen_dot@
expression E1, E2;
identifier FP_NAME = blob_reopen;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_db_status(args);


// FP: blob_write

@transform_assign_blob_write_dot@
expression E1, E2;
identifier FP_NAME = blob_write;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_blob_bytes(args);


// FP: busy_handler

@transform_assign_busy_handler_dot@
expression E1, E2;
identifier FP_NAME = busy_handler;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_bind_value(args);


// FP: busy_timeout

@transform_assign_busy_timeout_dot@
expression E1, E2;
identifier FP_NAME = busy_timeout;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_busy_handler(args);


// FP: cancel_auto_extension

@transform_assign_cancel_auto_extension_dot@
expression E1, E2;
identifier FP_NAME = cancel_auto_extension;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_db_filename(args);


// FP: changes

@transform_assign_changes_dot@
expression E1, E2;
identifier FP_NAME = changes;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_busy_timeout(args);


// FP: changes64

@transform_assign_changes64_dot@
expression E1, E2;
identifier FP_NAME = changes64;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_str_value(args);


// FP: clear_bindings

@transform_assign_clear_bindings_dot@
expression E1, E2;
identifier FP_NAME = clear_bindings;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_vmprintf(args);


// FP: close

@transform_assign_close_dot@
expression E1, E2;
identifier FP_NAME = close;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_changes(args);


// FP: close_v2

@transform_assign_close_v2_dot@
expression E1, E2;
identifier FP_NAME = close_v2;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_soft_heap_limit64(args);


// FP: collation_needed

@transform_assign_collation_needed_dot@
expression E1, E2;
identifier FP_NAME = collation_needed;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_close(args);


// FP: collation_needed16

@transform_assign_collation_needed16_dot@
expression E1, E2;
identifier FP_NAME = collation_needed16;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_collation_needed(args);


// FP: column_blob

@transform_assign_column_blob_dot@
expression E1, E2;
identifier FP_NAME = column_blob;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_collation_needed16(args);


// FP: column_bytes

@transform_assign_column_bytes_dot@
expression E1, E2;
identifier FP_NAME = column_bytes;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_column_blob(args);


// FP: column_bytes16

@transform_assign_column_bytes16_dot@
expression E1, E2;
identifier FP_NAME = column_bytes16;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_column_bytes(args);


// FP: column_count

@transform_assign_column_count_dot@
expression E1, E2;
identifier FP_NAME = column_count;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_column_bytes16(args);


// FP: column_database_name

@transform_assign_column_database_name_dot@
expression E1, E2;
identifier FP_NAME = column_database_name;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_column_count(args);


// FP: column_database_name16

@transform_assign_column_database_name16_dot@
expression E1, E2;
identifier FP_NAME = column_database_name16;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_column_database_name(args);


// FP: column_decltype

@transform_assign_column_decltype_dot@
expression E1, E2;
identifier FP_NAME = column_decltype;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_column_database_name16(args);


// FP: column_decltype16

@transform_assign_column_decltype16_dot@
expression E1, E2;
identifier FP_NAME = column_decltype16;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_column_decltype(args);


// FP: column_double

@transform_assign_column_double_dot@
expression E1, E2;
identifier FP_NAME = column_double;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_column_decltype16(args);


// FP: column_int

@transform_assign_column_int_dot@
expression E1, E2;
identifier FP_NAME = column_int;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_column_double(args);


// FP: column_int64

@transform_assign_column_int64_dot@
expression E1, E2;
identifier FP_NAME = column_int64;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_column_int(args);


// FP: column_name

@transform_assign_column_name_dot@
expression E1, E2;
identifier FP_NAME = column_name;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_column_int64(args);


// FP: column_name16

@transform_assign_column_name16_dot@
expression E1, E2;
identifier FP_NAME = column_name16;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_column_name(args);


// FP: column_origin_name

@transform_assign_column_origin_name_dot@
expression E1, E2;
identifier FP_NAME = column_origin_name;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_column_name16(args);


// FP: column_origin_name16

@transform_assign_column_origin_name16_dot@
expression E1, E2;
identifier FP_NAME = column_origin_name16;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_column_origin_name(args);


// FP: column_table_name

@transform_assign_column_table_name_dot@
expression E1, E2;
identifier FP_NAME = column_table_name;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_column_origin_name16(args);


// FP: column_table_name16

@transform_assign_column_table_name16_dot@
expression E1, E2;
identifier FP_NAME = column_table_name16;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_column_table_name(args);


// FP: column_text

@transform_assign_column_text_dot@
expression E1, E2;
identifier FP_NAME = column_text;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_column_table_name16(args);


// FP: column_text16

@transform_assign_column_text16_dot@
expression E1, E2;
identifier FP_NAME = column_text16;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_column_text(args);


// FP: column_type

@transform_assign_column_type_dot@
expression E1, E2;
identifier FP_NAME = column_type;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_column_text16(args);


// FP: column_value

@transform_assign_column_value_dot@
expression E1, E2;
identifier FP_NAME = column_value;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_column_type(args);


// FP: commit_hook

@transform_assign_commit_hook_dot@
expression E1, E2;
identifier FP_NAME = commit_hook;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_column_value(args);


// FP: compileoption_get

@transform_assign_compileoption_get_dot@
expression E1, E2;
identifier FP_NAME = compileoption_get;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_limit(args);


// FP: compileoption_used

@transform_assign_compileoption_used_dot@
expression E1, E2;
identifier FP_NAME = compileoption_used;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_next_stmt(args);


// FP: complete

@transform_assign_complete_dot@
expression E1, E2;
identifier FP_NAME = complete;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_commit_hook(args);


// FP: complete16

@transform_assign_complete16_dot@
expression E1, E2;
identifier FP_NAME = complete16;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_complete(args);


// FP: context_db_handle

@transform_assign_context_db_handle_dot@
expression E1, E2;
identifier FP_NAME = context_db_handle;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_soft_heap_limit(args);


// FP: create_collation

@transform_assign_create_collation_dot@
expression E1, E2;
identifier FP_NAME = create_collation;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_complete16(args);


// FP: create_collation16

@transform_assign_create_collation16_dot@
expression E1, E2;
identifier FP_NAME = create_collation16;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_create_collation(args);


// FP: create_collation_v2

@transform_assign_create_collation_v2_dot@
expression E1, E2;
identifier FP_NAME = create_collation_v2;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_blob_close(args);


// FP: create_filename

@transform_assign_create_filename_dot@
expression E1, E2;
identifier FP_NAME = create_filename;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_str_appendchar(args);


// FP: create_function

@transform_assign_create_function_dot@
expression E1, E2;
identifier FP_NAME = create_function;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_create_collation16(args);


// FP: create_function16

@transform_assign_create_function16_dot@
expression E1, E2;
identifier FP_NAME = create_function16;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_create_function(args);


// FP: create_function_v2

@transform_assign_create_function_v2_dot@
expression E1, E2;
identifier FP_NAME = create_function_v2;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_sql(args);


// FP: create_module

@transform_assign_create_module_dot@
expression E1, E2;
identifier FP_NAME = create_module;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_create_function16(args);


// FP: create_module_v2

@transform_assign_create_module_v2_dot@
expression E1, E2;
identifier FP_NAME = create_module_v2;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_overload_function(args);


// FP: create_window_function

@transform_assign_create_window_function_dot@
expression E1, E2;
identifier FP_NAME = create_window_function;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_vtab_collation(args);


// FP: data_count

@transform_assign_data_count_dot@
expression E1, E2;
identifier FP_NAME = data_count;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_create_module(args);


// FP: database_file_object

@transform_assign_database_file_object_dot@
expression E1, E2;
identifier FP_NAME = database_file_object;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_str_errcode(args);


// FP: db_cacheflush

@transform_assign_db_cacheflush_dot@
expression E1, E2;
identifier FP_NAME = db_cacheflush;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_malloc64(args);


// FP: db_config

@transform_assign_db_config_dot@
expression E1, E2;
identifier FP_NAME = db_config;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_status(args);


// FP: db_filename

@transform_assign_db_filename_dot@
expression E1, E2;
identifier FP_NAME = db_filename;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_sourceid(args);


// FP: db_handle

@transform_assign_db_handle_dot@
expression E1, E2;
identifier FP_NAME = db_handle;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_data_count(args);


// FP: db_mutex

@transform_assign_db_mutex_dot@
expression E1, E2;
identifier FP_NAME = db_mutex;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_backup_finish(args);


// FP: db_name

@transform_assign_db_name_dot@
expression E1, E2;
identifier FP_NAME = db_name;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_filename_journal(args);


// FP: db_readonly

@transform_assign_db_readonly_dot@
expression E1, E2;
identifier FP_NAME = db_readonly;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_stmt_status(args);


// FP: db_release_memory

@transform_assign_db_release_memory_dot@
expression E1, E2;
identifier FP_NAME = db_release_memory;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_strnicmp(args);


// FP: db_status

@transform_assign_db_status_dot@
expression E1, E2;
identifier FP_NAME = db_status;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_backup_init(args);


// FP: declare_vtab

@transform_assign_declare_vtab_dot@
expression E1, E2;
identifier FP_NAME = declare_vtab;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_db_handle(args);


// FP: deserialize

@transform_assign_deserialize_dot@
expression E1, E2;
identifier FP_NAME = deserialize;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_uri_key(args);


// FP: drop_modules

@transform_assign_drop_modules_dot@
expression E1, E2;
identifier FP_NAME = drop_modules;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_str_new(args);


// FP: enable_shared_cache

@transform_assign_enable_shared_cache_dot@
expression E1, E2;
identifier FP_NAME = enable_shared_cache;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_declare_vtab(args);


// FP: errcode

@transform_assign_errcode_dot@
expression E1, E2;
identifier FP_NAME = errcode;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_enable_shared_cache(args);


// FP: errmsg

@transform_assign_errmsg_dot@
expression E1, E2;
identifier FP_NAME = errmsg;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_errcode(args);


// FP: errmsg16

@transform_assign_errmsg16_dot@
expression E1, E2;
identifier FP_NAME = errmsg16;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_errmsg(args);


// FP: exec

@transform_assign_exec_dot@
expression E1, E2;
identifier FP_NAME = exec;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_errmsg16(args);


// FP: expanded_sql

@transform_assign_expanded_sql_dot@
expression E1, E2;
identifier FP_NAME = expanded_sql;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_reset_auto_extension(args);


// FP: expired

@transform_assign_expired_dot@
expression E1, E2;
identifier FP_NAME = expired;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.expired_signature, expired_signatures[expired_0_enum], sizeof(E2.expired_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.expired_signature, expired_signatures[expired_sqlite3_exec_enum], sizeof(E2.expired_signature)) == 0) {
+ E1 = sqlite3_exec(args);
+ }


// FP: extended_errcode

@transform_assign_extended_errcode_dot@
expression E1, E2;
identifier FP_NAME = extended_errcode;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_backup_pagecount(args);


// FP: extended_result_codes

@transform_assign_extended_result_codes_dot@
expression E1, E2;
identifier FP_NAME = extended_result_codes;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_vfs_find(args);


// FP: file_control

@transform_assign_file_control_dot@
expression E1, E2;
identifier FP_NAME = file_control;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_blob_open(args);


// FP: filename_database

@transform_assign_filename_database_dot@
expression E1, E2;
identifier FP_NAME = filename_database;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_str_vappendf(args);


// FP: filename_journal

@transform_assign_filename_journal_dot@
expression E1, E2;
identifier FP_NAME = filename_journal;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_str_append(args);


// FP: filename_wal

@transform_assign_filename_wal_dot@
expression E1, E2;
identifier FP_NAME = filename_wal;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_str_appendall(args);


// FP: free_filename

@transform_assign_free_filename_dot@
expression E1, E2;
identifier FP_NAME = free_filename;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_str_reset(args);


// FP: get_autocommit

@transform_assign_get_autocommit_dot@
expression E1, E2;
identifier FP_NAME = get_autocommit;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_free(args);


// FP: get_auxdata

@transform_assign_get_auxdata_dot@
expression E1, E2;
identifier FP_NAME = get_auxdata;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_free_table(args);


// FP: get_clientdata

@transform_assign_get_clientdata_dot@
expression E1, E2;
identifier FP_NAME = get_clientdata;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_database_file_object(args);


// FP: get_table

@transform_assign_get_table_dot@
expression E1, E2;
identifier FP_NAME = get_table;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_get_autocommit(args);


// FP: global_recover

@transform_assign_global_recover_dot@
expression E1, E2;
identifier FP_NAME = global_recover;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_get_auxdata(args);


// FP: hard_heap_limit64

@transform_assign_hard_heap_limit64_dot@
expression E1, E2;
identifier FP_NAME = hard_heap_limit64;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_str_finish(args);


// FP: interruptx

@transform_assign_interruptx_dot@
expression E1, E2;
identifier FP_NAME = interruptx;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_get_table(args);


// FP: is_interrupted

@transform_assign_is_interrupted_dot@
expression E1, E2;
identifier FP_NAME = is_interrupted;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_create_filename(args);


// FP: keyword_check

@transform_assign_keyword_check_dot@
expression E1, E2;
identifier FP_NAME = keyword_check;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_db_cacheflush(args);


// FP: keyword_count

@transform_assign_keyword_count_dot@
expression E1, E2;
identifier FP_NAME = keyword_count;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_status64(args);


// FP: keyword_name

@transform_assign_keyword_name_dot@
expression E1, E2;
identifier FP_NAME = keyword_name;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_strlike(args);


// FP: last_insert_rowid

@transform_assign_last_insert_rowid_dot@
expression E1, E2;
identifier FP_NAME = last_insert_rowid;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = 0;


// FP: libversion

@transform_assign_libversion_dot@
expression E1, E2;
identifier FP_NAME = libversion;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_interrupt(args);


// FP: libversion_number

@transform_assign_libversion_number_dot@
expression E1, E2;
identifier FP_NAME = libversion_number;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_last_insert_rowid(args);


// FP: limit

@transform_assign_limit_dot@
expression E1, E2;
identifier FP_NAME = limit;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_vfs_register(args);


// FP: load_extension

@transform_assign_load_extension_dot@
expression E1, E2;
identifier FP_NAME = load_extension;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_db_readonly(args);


// FP: log

@transform_assign_log_dot@
expression E1, E2;
identifier FP_NAME = log;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_backup_remaining(args);


// FP: malloc

@transform_assign_malloc_dot@
expression E1, E2;
identifier FP_NAME = malloc;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_libversion(args);


// FP: malloc64

@transform_assign_malloc64_dot@
expression E1, E2;
identifier FP_NAME = malloc64;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_db_release_memory(args);


// FP: memory_highwater

@transform_assign_memory_highwater_dot@
expression E1, E2;
identifier FP_NAME = memory_highwater;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_blob_read(args);


// FP: memory_used

@transform_assign_memory_used_dot@
expression E1, E2;
identifier FP_NAME = memory_used;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_blob_write(args);


// FP: mprintf

@transform_assign_mprintf_dot@
expression E1, E2;
identifier FP_NAME = mprintf;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_libversion_number(args);


// FP: msize

@transform_assign_msize_dot@
expression E1, E2;
identifier FP_NAME = msize;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_errstr(args);


// FP: mutex_alloc

@transform_assign_mutex_alloc_dot@
expression E1, E2;
identifier FP_NAME = mutex_alloc;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_create_collation_v2(args);


// FP: mutex_enter

@transform_assign_mutex_enter_dot@
expression E1, E2;
identifier FP_NAME = mutex_enter;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_file_control(args);


// FP: mutex_free

@transform_assign_mutex_free_dot@
expression E1, E2;
identifier FP_NAME = mutex_free;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_memory_highwater(args);


// FP: mutex_leave

@transform_assign_mutex_leave_dot@
expression E1, E2;
identifier FP_NAME = mutex_leave;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_memory_used(args);


// FP: next_stmt

@transform_assign_next_stmt_dot@
expression E1, E2;
identifier FP_NAME = next_stmt;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_vfs_unregister(args);


// FP: normalized_sql

@transform_assign_normalized_sql_dot@
expression E1, E2;
identifier FP_NAME = normalized_sql;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_keyword_count(args);


// FP: open

@transform_assign_open_dot@
expression E1, E2;
identifier FP_NAME = open;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_malloc(args);


// FP: open16

@transform_assign_open16_dot@
expression E1, E2;
identifier FP_NAME = open16;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_mprintf(args);


// FP: open_v2

@transform_assign_open_v2_dot@
expression E1, E2;
identifier FP_NAME = open_v2;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = 0;


// FP: overload_function

@transform_assign_overload_function_dot@
expression E1, E2;
identifier FP_NAME = overload_function;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_value_text16be(args);


// FP: prepare

@transform_assign_prepare_dot@
expression E1, E2;
identifier FP_NAME = prepare;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_open(args);


// FP: prepare16

@transform_assign_prepare16_dot@
expression E1, E2;
identifier FP_NAME = prepare16;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_open16(args);


// FP: prepare16_v2

@transform_assign_prepare16_v2_dot@
expression E1, E2;
identifier FP_NAME = prepare16_v2;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_value_type(args);


// FP: prepare16_v3

@transform_assign_prepare16_v3_dot@
expression E1, E2;
identifier FP_NAME = prepare16_v3;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_strglob(args);


// FP: prepare_v2

@transform_assign_prepare_v2_dot@
expression E1, E2;
identifier FP_NAME = prepare_v2;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_value_text16le(args);


// FP: prepare_v3

@transform_assign_prepare_v3_dot@
expression E1, E2;
identifier FP_NAME = prepare_v3;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_result_text64(args);


// FP: profile

@transform_assign_profile_dot@
expression E1, E2;
identifier FP_NAME = profile;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_prepare(args);


// FP: progress_handler

@transform_assign_progress_handler_dot@
expression E1, E2;
identifier FP_NAME = progress_handler;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_prepare16(args);


// FP: randomness

@transform_assign_randomness_dot@
expression E1, E2;
identifier FP_NAME = randomness;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_sleep(args);


// FP: realloc

@transform_assign_realloc_dot@
expression E1, E2;
identifier FP_NAME = realloc;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_profile(args);


// FP: realloc64

@transform_assign_realloc64_dot@
expression E1, E2;
identifier FP_NAME = realloc64;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_stmt_busy(args);


// FP: release_memory

@transform_assign_release_memory_dot@
expression E1, E2;
identifier FP_NAME = release_memory;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = 0;


// FP: reset

@transform_assign_reset_dot@
expression E1, E2;
identifier FP_NAME = reset;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_progress_handler(args);


// FP: reset_auto_extension

@transform_assign_reset_auto_extension_dot@
expression E1, E2;
identifier FP_NAME = reset_auto_extension;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_stmt_readonly(args);


// FP: result_blob

@transform_assign_result_blob_dot@
expression E1, E2;
identifier FP_NAME = result_blob;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_realloc(args);


// FP: result_blob64

@transform_assign_result_blob64_dot@
expression E1, E2;
identifier FP_NAME = result_blob64;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_stricmp(args);


// FP: result_double

@transform_assign_result_double_dot@
expression E1, E2;
identifier FP_NAME = result_double;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_reset(args);


// FP: result_error

@transform_assign_result_error_dot@
expression E1, E2;
identifier FP_NAME = result_error;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_result_blob(args);


// FP: result_error16

@transform_assign_result_error16_dot@
expression E1, E2;
identifier FP_NAME = result_error16;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_result_double(args);


// FP: result_error_code

@transform_assign_result_error_code_dot@
expression E1, E2;
identifier FP_NAME = result_error_code;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_result_error_nomem(args);


// FP: result_error_nomem

@transform_assign_result_error_nomem_dot@
expression E1, E2;
identifier FP_NAME = result_error_nomem;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = 0;


// FP: result_error_toobig

@transform_assign_result_error_toobig_dot@
expression E1, E2;
identifier FP_NAME = result_error_toobig;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = 0;


// FP: result_int

@transform_assign_result_int_dot@
expression E1, E2;
identifier FP_NAME = result_int;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_result_error(args);


// FP: result_int64

@transform_assign_result_int64_dot@
expression E1, E2;
identifier FP_NAME = result_int64;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_result_error16(args);


// FP: result_null

@transform_assign_result_null_dot@
expression E1, E2;
identifier FP_NAME = result_null;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_result_int(args);


// FP: result_pointer

@transform_assign_result_pointer_dot@
expression E1, E2;
identifier FP_NAME = result_pointer;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_value_free(args);


// FP: result_subtype

@transform_assign_result_subtype_dot@
expression E1, E2;
identifier FP_NAME = result_subtype;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_bind_text64(args);


// FP: result_text

@transform_assign_result_text_dot@
expression E1, E2;
identifier FP_NAME = result_text;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_result_int64(args);


// FP: result_text16

@transform_assign_result_text16_dot@
expression E1, E2;
identifier FP_NAME = result_text16;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_result_null(args);


// FP: result_text16be

@transform_assign_result_text16be_dot@
expression E1, E2;
identifier FP_NAME = result_text16be;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_result_text(args);


// FP: result_text16le

@transform_assign_result_text16le_dot@
expression E1, E2;
identifier FP_NAME = result_text16le;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_result_text16(args);


// FP: result_text64

@transform_assign_result_text64_dot@
expression E1, E2;
identifier FP_NAME = result_text64;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_uri_boolean(args);


// FP: result_value

@transform_assign_result_value_dot@
expression E1, E2;
identifier FP_NAME = result_value;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_result_text16be(args);


// FP: result_zeroblob

@transform_assign_result_zeroblob_dot@
expression E1, E2;
identifier FP_NAME = result_zeroblob;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_release_memory(args);


// FP: result_zeroblob64

@transform_assign_result_zeroblob64_dot@
expression E1, E2;
identifier FP_NAME = result_zeroblob64;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_wal_checkpoint_v2(args);


// FP: rollback_hook

@transform_assign_rollback_hook_dot@
expression E1, E2;
identifier FP_NAME = rollback_hook;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_result_text16le(args);


// FP: serialize

@transform_assign_serialize_dot@
expression E1, E2;
identifier FP_NAME = serialize;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_filename_database(args);


// FP: set_authorizer

@transform_assign_set_authorizer_dot@
expression E1, E2;
identifier FP_NAME = set_authorizer;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_result_value(args);


// FP: set_auxdata

@transform_assign_set_auxdata_dot@
expression E1, E2;
identifier FP_NAME = set_auxdata;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_rollback_hook(args);


// FP: set_clientdata

@transform_assign_set_clientdata_dot@
expression E1, E2;
identifier FP_NAME = set_clientdata;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_txn_state(args);


// FP: set_errmsg

@transform_assign_set_errmsg_dot@
expression E1, E2;
identifier FP_NAME = set_errmsg;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_total_changes64(args);


// FP: set_last_insert_rowid

@transform_assign_set_last_insert_rowid_dot@
expression E1, E2;
identifier FP_NAME = set_last_insert_rowid;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_result_blob64(args);


// FP: setlk_timeout

@transform_assign_setlk_timeout_dot@
expression E1, E2;
identifier FP_NAME = setlk_timeout;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_changes64(args);


// FP: soft_heap_limit

@transform_assign_soft_heap_limit_dot@
expression E1, E2;
identifier FP_NAME = soft_heap_limit;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_mutex_enter(args);


// FP: soft_heap_limit64

@transform_assign_soft_heap_limit64_dot@
expression E1, E2;
identifier FP_NAME = soft_heap_limit64;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_backup_step(args);


// FP: sql

@transform_assign_sql_dot@
expression E1, E2;
identifier FP_NAME = sql;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_threadsafe(args);


// FP: status

@transform_assign_status_dot@
expression E1, E2;
identifier FP_NAME = status;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_result_zeroblob(args);


// FP: status64

@transform_assign_status64_dot@
expression E1, E2;
identifier FP_NAME = status64;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_cancel_auto_extension(args);


// FP: step

@transform_assign_step_dot@
expression E1, E2;
identifier FP_NAME = step;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_set_auxdata(args);


// FP: stmt_explain

@transform_assign_stmt_explain_dot@
expression E1, E2;
identifier FP_NAME = stmt_explain;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_free_filename(args);


// FP: stmt_isexplain

@transform_assign_stmt_isexplain_dot@
expression E1, E2;
identifier FP_NAME = stmt_isexplain;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_keyword_name(args);


// FP: stmt_status

@transform_assign_stmt_status_dot@
expression E1, E2;
identifier FP_NAME = stmt_status;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_compileoption_used(args);


// FP: str_append

@transform_assign_str_append_dot@
expression E1, E2;
identifier FP_NAME = str_append;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_prepare_v3(args);


// FP: str_appendall

@transform_assign_str_appendall_dot@
expression E1, E2;
identifier FP_NAME = str_appendall;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_prepare16_v3(args);


// FP: str_appendchar

@transform_assign_str_appendchar_dot@
expression E1, E2;
identifier FP_NAME = str_appendchar;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_bind_pointer(args);


// FP: str_appendf

@transform_assign_str_appendf_dot@
expression E1, E2;
identifier FP_NAME = str_appendf;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_expanded_sql(args);


// FP: str_errcode

@transform_assign_str_errcode_dot@
expression E1, E2;
identifier FP_NAME = str_errcode;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_value_pointer(args);


// FP: str_finish

@transform_assign_str_finish_dot@
expression E1, E2;
identifier FP_NAME = str_finish;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_trace_v2(args);


// FP: str_length

@transform_assign_str_length_dot@
expression E1, E2;
identifier FP_NAME = str_length;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_vtab_nochange(args);


// FP: str_new

@transform_assign_str_new_dot@
expression E1, E2;
identifier FP_NAME = str_new;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_system_errno(args);


// FP: str_reset

@transform_assign_str_reset_dot@
expression E1, E2;
identifier FP_NAME = str_reset;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_result_pointer(args);


// FP: str_value

@transform_assign_str_value_dot@
expression E1, E2;
identifier FP_NAME = str_value;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_value_nochange(args);


// FP: str_vappendf

@transform_assign_str_vappendf_dot@
expression E1, E2;
identifier FP_NAME = str_vappendf;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_set_last_insert_rowid(args);


// FP: strglob

@transform_assign_strglob_dot@
expression E1, E2;
identifier FP_NAME = strglob;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_uri_int64(args);


// FP: stricmp

@transform_assign_stricmp_dot@
expression E1, E2;
identifier FP_NAME = stricmp;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_wal_checkpoint(args);


// FP: strlike

@transform_assign_strlike_dot@
expression E1, E2;
identifier FP_NAME = strlike;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_load_extension(args);


// FP: system_errno

@transform_assign_system_errno_dot@
expression E1, E2;
identifier FP_NAME = system_errno;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_msize(args);


// FP: table_column_metadata

@transform_assign_table_column_metadata_dot@
expression E1, E2;
identifier FP_NAME = table_column_metadata;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_snprintf(args);


// FP: test_control

@transform_assign_test_control_dot@
expression E1, E2;
identifier FP_NAME = test_control;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_result_error_toobig(args);


// FP: thread_cleanup

@transform_assign_thread_cleanup_dot@
expression E1, E2;
identifier FP_NAME = thread_cleanup;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_step(args);


// FP: total_changes

@transform_assign_total_changes_dot@
expression E1, E2;
identifier FP_NAME = total_changes;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_table_column_metadata(args);


// FP: total_changes64

@transform_assign_total_changes64_dot@
expression E1, E2;
identifier FP_NAME = total_changes64;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_create_window_function(args);


// FP: trace_v2

@transform_assign_trace_v2_dot@
expression E1, E2;
identifier FP_NAME = trace_v2;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_realloc64(args);


// FP: txn_state

@transform_assign_txn_state_dot@
expression E1, E2;
identifier FP_NAME = txn_state;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_str_length(args);


// FP: unlock_notify

@transform_assign_unlock_notify_dot@
expression E1, E2;
identifier FP_NAME = unlock_notify;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = 0;


// FP: uri_boolean

@transform_assign_uri_boolean_dot@
expression E1, E2;
identifier FP_NAME = uri_boolean;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_wal_hook(args);


// FP: uri_key

@transform_assign_uri_key_dot@
expression E1, E2;
identifier FP_NAME = uri_key;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_str_appendf(args);


// FP: uri_parameter

@transform_assign_uri_parameter_dot@
expression E1, E2;
identifier FP_NAME = uri_parameter;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = 0;


// FP: user_data

@transform_assign_user_data_dot@
expression E1, E2;
identifier FP_NAME = user_data;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_trace(args);


// FP: value_double

@transform_assign_value_double_dot@
expression E1, E2;
identifier FP_NAME = value_double;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_user_data(args);


// FP: value_dup

@transform_assign_value_dup_dot@
expression E1, E2;
identifier FP_NAME = value_dup;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_uri_parameter(args);


// FP: value_encoding

@transform_assign_value_encoding_dot@
expression E1, E2;
identifier FP_NAME = value_encoding;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_filename_wal(args);


// FP: value_free

@transform_assign_value_free_dot@
expression E1, E2;
identifier FP_NAME = value_free;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_vsnprintf(args);


// FP: value_frombind

@transform_assign_value_frombind_dot@
expression E1, E2;
identifier FP_NAME = value_frombind;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_keyword_check(args);


// FP: value_int

@transform_assign_value_int_dot@
expression E1, E2;
identifier FP_NAME = value_int;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_value_blob(args);


// FP: value_int64

@transform_assign_value_int64_dot@
expression E1, E2;
identifier FP_NAME = value_int64;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_value_bytes(args);


// FP: value_nochange

@transform_assign_value_nochange_dot@
expression E1, E2;
identifier FP_NAME = value_nochange;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_value_subtype(args);


// FP: value_numeric_type

@transform_assign_value_numeric_type_dot@
expression E1, E2;
identifier FP_NAME = value_numeric_type;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_value_bytes16(args);


// FP: value_pointer

@transform_assign_value_pointer_dot@
expression E1, E2;
identifier FP_NAME = value_pointer;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_result_zeroblob64(args);


// FP: value_subtype

@transform_assign_value_subtype_dot@
expression E1, E2;
identifier FP_NAME = value_subtype;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_bind_blob64(args);


// FP: value_text

@transform_assign_value_text_dot@
expression E1, E2;
identifier FP_NAME = value_text;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_value_double(args);


// FP: value_text16

@transform_assign_value_text16_dot@
expression E1, E2;
identifier FP_NAME = value_text16;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_value_int(args);


// FP: value_text16be

@transform_assign_value_text16be_dot@
expression E1, E2;
identifier FP_NAME = value_text16be;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_value_int64(args);


// FP: value_text16le

@transform_assign_value_text16le_dot@
expression E1, E2;
identifier FP_NAME = value_text16le;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_value_numeric_type(args);


// FP: value_type

@transform_assign_value_type_dot@
expression E1, E2;
identifier FP_NAME = value_type;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_value_text(args);


// FP: vfs_find

@transform_assign_vfs_find_dot@
expression E1, E2;
identifier FP_NAME = vfs_find;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_mutex_free(args);


// FP: vfs_register

@transform_assign_vfs_register_dot@
expression E1, E2;
identifier FP_NAME = vfs_register;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_mutex_leave(args);


// FP: vfs_unregister

@transform_assign_vfs_unregister_dot@
expression E1, E2;
identifier FP_NAME = vfs_unregister;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_mutex_try(args);


// FP: vmprintf

@transform_assign_vmprintf_dot@
expression E1, E2;
identifier FP_NAME = vmprintf;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_value_text16(args);


// FP: vtab_collation

@transform_assign_vtab_collation_dot@
expression E1, E2;
identifier FP_NAME = vtab_collation;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_result_subtype(args);


// FP: vtab_config

@transform_assign_vtab_config_dot@
expression E1, E2;
identifier FP_NAME = vtab_config;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_extended_errcode(args);


// FP: vtab_distinct

@transform_assign_vtab_distinct_dot@
expression E1, E2;
identifier FP_NAME = vtab_distinct;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_value_frombind(args);


// FP: vtab_nochange

@transform_assign_vtab_nochange_dot@
expression E1, E2;
identifier FP_NAME = vtab_nochange;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_bind_zeroblob64(args);


// FP: vtab_on_conflict

@transform_assign_vtab_on_conflict_dot@
expression E1, E2;
identifier FP_NAME = vtab_on_conflict;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_log(args);


// FP: wal_checkpoint

@transform_assign_wal_checkpoint_dot@
expression E1, E2;
identifier FP_NAME = wal_checkpoint;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_db_config(args);


// FP: wal_hook

@transform_assign_wal_hook_dot@
expression E1, E2;
identifier FP_NAME = wal_hook;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_db_mutex(args);


// FP: xAccess

@transform_assign_xAccess_dot@
expression E1, E2;
identifier FP_NAME = xAccess;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xAccess_signature, xAccess_signatures[xAccess_apndAccess_enum], sizeof(E2.xAccess_signature)) == 0) {
+ E1 = apndAccess(args);
+ }
+ else if (memcmp(E2.xAccess_signature, xAccess_signatures[xAccess_memdbAccess_enum], sizeof(E2.xAccess_signature)) == 0) {
+ E1 = memdbAccess(args);
+ }
+ else if (memcmp(E2.xAccess_signature, xAccess_signatures[xAccess_vfstraceAccess_enum], sizeof(E2.xAccess_signature)) == 0) {
+ E1 = vfstraceAccess(args);
+ }
+ else if (memcmp(E2.xAccess_signature, xAccess_signatures[xAccess_unixAccess_enum], sizeof(E2.xAccess_signature)) == 0) {
+ E1 = unixAccess(args);
+ }


// FP: xAltLocaltime

@transform_assign_xAltLocaltime_dot@
expression E1, E2;
identifier FP_NAME = xAltLocaltime;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = 0;


// FP: xAutovacDestr

@transform_assign_xAutovacDestr_dot@
expression E1, E2;
identifier FP_NAME = xAutovacDestr;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xAutovacDestr_signature, xAutovacDestr_signatures[xAutovacDestr_0_enum], sizeof(E2.xAutovacDestr_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xAutovacDestr_signature, xAutovacDestr_signatures[xAutovacDestr_rtreeMatchArgFree_enum], sizeof(E2.xAutovacDestr_signature)) == 0) {
+ E1 = rtreeMatchArgFree(args);
+ }
+ else if (memcmp(E2.xAutovacDestr_signature, xAutovacDestr_signatures[xAutovacDestr_sqlite3VdbeValueListFree_enum], sizeof(E2.xAutovacDestr_signature)) == 0) {
+ E1 = sqlite3VdbeValueListFree(args);
+ }


// FP: xAutovacPages

@transform_assign_xAutovacPages_dot@
expression E1, E2;
identifier FP_NAME = xAutovacPages;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xAutovacPages_signature, xAutovacPages_signatures[xAutovacPages_0_enum], sizeof(E2.xAutovacPages_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xAutovacPages_signature, xAutovacPages_signatures[xAutovacPages_sql_trace_callback_enum], sizeof(E2.xAutovacPages_signature)) == 0) {
+ E1 = sql_trace_callback(args);
+ }
+ else if (memcmp(E2.xAutovacPages_signature, xAutovacPages_signatures[xAutovacPages_sqlite3WalDefaultHook_enum], sizeof(E2.xAutovacPages_signature)) == 0) {
+ E1 = sqlite3WalDefaultHook(args);
+ }


// FP: xBegin

@transform_assign_xBegin_dot@
expression E1, E2;
identifier FP_NAME = xBegin;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xBegin_signature, xBegin_signatures[xBegin_0_enum], sizeof(E2.xBegin_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xBegin_signature, xBegin_signatures[xBegin_dbpageBegin_enum], sizeof(E2.xBegin_signature)) == 0) {
+ E1 = dbpageBegin(args);
+ }
+ else if (memcmp(E2.xBegin_signature, xBegin_signatures[xBegin_fts3BeginMethod_enum], sizeof(E2.xBegin_signature)) == 0) {
+ E1 = fts3BeginMethod(args);
+ }
+ else if (memcmp(E2.xBegin_signature, xBegin_signatures[xBegin_rtreeBeginTransaction_enum], sizeof(E2.xBegin_signature)) == 0) {
+ E1 = rtreeBeginTransaction(args);
+ }
+ else if (memcmp(E2.xBegin_signature, xBegin_signatures[xBegin_zipfileBegin_enum], sizeof(E2.xBegin_signature)) == 0) {
+ E1 = zipfileBegin(args);
+ }


// FP: xBestIndex

@transform_assign_xBestIndex_dot@
expression E1, E2;
identifier FP_NAME = xBestIndex;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xBestIndex_signature, xBestIndex_signatures[xBestIndex_bytecodevtabBestIndex_enum], sizeof(E2.xBestIndex_signature)) == 0) {
+ E1 = bytecodevtabBestIndex(args);
+ }
+ else if (memcmp(E2.xBestIndex_signature, xBestIndex_signatures[xBestIndex_completionBestIndex_enum], sizeof(E2.xBestIndex_signature)) == 0) {
+ E1 = completionBestIndex(args);
+ }
+ else if (memcmp(E2.xBestIndex_signature, xBestIndex_signatures[xBestIndex_dbdataBestIndex_enum], sizeof(E2.xBestIndex_signature)) == 0) {
+ E1 = dbdataBestIndex(args);
+ }
+ else if (memcmp(E2.xBestIndex_signature, xBestIndex_signatures[xBestIndex_dbpageBestIndex_enum], sizeof(E2.xBestIndex_signature)) == 0) {
+ E1 = dbpageBestIndex(args);
+ }
+ else if (memcmp(E2.xBestIndex_signature, xBestIndex_signatures[xBestIndex_expertBestIndex_enum], sizeof(E2.xBestIndex_signature)) == 0) {
+ E1 = expertBestIndex(args);
+ }
+ else if (memcmp(E2.xBestIndex_signature, xBestIndex_signatures[xBestIndex_fsdirBestIndex_enum], sizeof(E2.xBestIndex_signature)) == 0) {
+ E1 = fsdirBestIndex(args);
+ }
+ else if (memcmp(E2.xBestIndex_signature, xBestIndex_signatures[xBestIndex_fts3BestIndexMethod_enum], sizeof(E2.xBestIndex_signature)) == 0) {
+ E1 = fts3BestIndexMethod(args);
+ }
+ else if (memcmp(E2.xBestIndex_signature, xBestIndex_signatures[xBestIndex_fts3auxBestIndexMethod_enum], sizeof(E2.xBestIndex_signature)) == 0) {
+ E1 = fts3auxBestIndexMethod(args);
+ }
+ else if (memcmp(E2.xBestIndex_signature, xBestIndex_signatures[xBestIndex_fts3tokBestIndexMethod_enum], sizeof(E2.xBestIndex_signature)) == 0) {
+ E1 = fts3tokBestIndexMethod(args);
+ }
+ else if (memcmp(E2.xBestIndex_signature, xBestIndex_signatures[xBestIndex_jsonEachBestIndex_enum], sizeof(E2.xBestIndex_signature)) == 0) {
+ E1 = jsonEachBestIndex(args);
+ }
+ else if (memcmp(E2.xBestIndex_signature, xBestIndex_signatures[xBestIndex_pragmaVtabBestIndex_enum], sizeof(E2.xBestIndex_signature)) == 0) {
+ E1 = pragmaVtabBestIndex(args);
+ }
+ else if (memcmp(E2.xBestIndex_signature, xBestIndex_signatures[xBestIndex_rtreeBestIndex_enum], sizeof(E2.xBestIndex_signature)) == 0) {
+ E1 = rtreeBestIndex(args);
+ }
+ else if (memcmp(E2.xBestIndex_signature, xBestIndex_signatures[xBestIndex_seriesBestIndex_enum], sizeof(E2.xBestIndex_signature)) == 0) {
+ E1 = seriesBestIndex(args);
+ }
+ else if (memcmp(E2.xBestIndex_signature, xBestIndex_signatures[xBestIndex_statBestIndex_enum], sizeof(E2.xBestIndex_signature)) == 0) {
+ E1 = statBestIndex(args);
+ }
+ else if (memcmp(E2.xBestIndex_signature, xBestIndex_signatures[xBestIndex_stmtBestIndex_enum], sizeof(E2.xBestIndex_signature)) == 0) {
+ E1 = stmtBestIndex(args);
+ }
+ else if (memcmp(E2.xBestIndex_signature, xBestIndex_signatures[xBestIndex_zipfileBestIndex_enum], sizeof(E2.xBestIndex_signature)) == 0) {
+ E1 = zipfileBestIndex(args);
+ }


// FP: xBusyHandler

@transform_assign_xBusyHandler_dot@
expression E1, E2;
identifier FP_NAME = xBusyHandler;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xBusyHandler_signature, xBusyHandler_signatures[xBusyHandler_0_enum], sizeof(E2.xBusyHandler_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xBusyHandler_signature, xBusyHandler_signatures[xBusyHandler_btreeInvokeBusyHandler_enum], sizeof(E2.xBusyHandler_signature)) == 0) {
+ E1 = btreeInvokeBusyHandler(args);
+ }
+ else if (memcmp(E2.xBusyHandler_signature, xBusyHandler_signatures[xBusyHandler_sqliteDefaultBusyCallback_enum], sizeof(E2.xBusyHandler_signature)) == 0) {
+ E1 = sqliteDefaultBusyCallback(args);
+ }
+ else if (memcmp(E2.xBusyHandler_signature, xBusyHandler_signatures[xBusyHandler_xBusyHandler_enum], sizeof(E2.xBusyHandler_signature)) == 0) {
+ E1 = xBusyHandler(args);
+ }


// FP: xCachesize

@transform_assign_xCachesize_dot@
expression E1, E2;
identifier FP_NAME = xCachesize;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xCachesize_signature, xCachesize_signatures[xCachesize_pcache1Cachesize_enum], sizeof(E2.xCachesize_signature)) == 0) {
+ E1 = pcache1Cachesize(args);
+ }
+ else if (memcmp(E2.xCachesize_signature, xCachesize_signatures[xCachesize_pcachetraceCachesize_enum], sizeof(E2.xCachesize_signature)) == 0) {
+ E1 = pcachetraceCachesize(args);
+ }


// FP: xCellSize

@transform_assign_xCellSize_dot@
expression E1, E2;
identifier FP_NAME = xCellSize;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xCellSize_signature, xCellSize_signatures[xCellSize_cellSizePtr_enum], sizeof(E2.xCellSize_signature)) == 0) {
+ E1 = cellSizePtr(args);
+ }
+ else if (memcmp(E2.xCellSize_signature, xCellSize_signatures[xCellSize_cellSizePtrIdxLeaf_enum], sizeof(E2.xCellSize_signature)) == 0) {
+ E1 = cellSizePtrIdxLeaf(args);
+ }
+ else if (memcmp(E2.xCellSize_signature, xCellSize_signatures[xCellSize_cellSizePtrNoPayload_enum], sizeof(E2.xCellSize_signature)) == 0) {
+ E1 = cellSizePtrNoPayload(args);
+ }
+ else if (memcmp(E2.xCellSize_signature, xCellSize_signatures[xCellSize_cellSizePtrTableLeaf_enum], sizeof(E2.xCellSize_signature)) == 0) {
+ E1 = cellSizePtrTableLeaf(args);
+ }


// FP: xCheckReservedLock

@transform_assign_xCheckReservedLock_dot@
expression E1, E2;
identifier FP_NAME = xCheckReservedLock;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xCheckReservedLock_signature, xCheckReservedLock_signatures[xCheckReservedLock_0_enum], sizeof(E2.xCheckReservedLock_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xCheckReservedLock_signature, xCheckReservedLock_signatures[xCheckReservedLock_apndCheckReservedLock_enum], sizeof(E2.xCheckReservedLock_signature)) == 0) {
+ E1 = apndCheckReservedLock(args);
+ }
+ else if (memcmp(E2.xCheckReservedLock_signature, xCheckReservedLock_signatures[xCheckReservedLock_recoverVfsCheckReservedLock_enum], sizeof(E2.xCheckReservedLock_signature)) == 0) {
+ E1 = recoverVfsCheckReservedLock(args);
+ }
+ else if (memcmp(E2.xCheckReservedLock_signature, xCheckReservedLock_signatures[xCheckReservedLock_vfstraceCheckReservedLock_enum], sizeof(E2.xCheckReservedLock_signature)) == 0) {
+ E1 = vfstraceCheckReservedLock(args);
+ }


// FP: xCleanup

@transform_assign_xCleanup_dot@
expression E1, E2;
identifier FP_NAME = xCleanup;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xCleanup_signature, xCleanup_signatures[xCleanup_agginfoFree_enum], sizeof(E2.xCleanup_signature)) == 0) {
+ E1 = agginfoFree(args);
+ }
+ else if (memcmp(E2.xCleanup_signature, xCleanup_signatures[xCleanup_sqlite3DbFree_enum], sizeof(E2.xCleanup_signature)) == 0) {
+ E1 = sqlite3DbFree(args);
+ }
+ else if (memcmp(E2.xCleanup_signature, xCleanup_signatures[xCleanup_sqlite3DeleteReturning_enum], sizeof(E2.xCleanup_signature)) == 0) {
+ E1 = sqlite3DeleteReturning(args);
+ }
+ else if (memcmp(E2.xCleanup_signature, xCleanup_signatures[xCleanup_sqlite3DeleteTableGeneric_enum], sizeof(E2.xCleanup_signature)) == 0) {
+ E1 = sqlite3DeleteTableGeneric(args);
+ }
+ else if (memcmp(E2.xCleanup_signature, xCleanup_signatures[xCleanup_sqlite3ExprDeleteGeneric_enum], sizeof(E2.xCleanup_signature)) == 0) {
+ E1 = sqlite3ExprDeleteGeneric(args);
+ }
+ else if (memcmp(E2.xCleanup_signature, xCleanup_signatures[xCleanup_sqlite3ExprListDeleteGeneric_enum], sizeof(E2.xCleanup_signature)) == 0) {
+ E1 = sqlite3ExprListDeleteGeneric(args);
+ }
+ else if (memcmp(E2.xCleanup_signature, xCleanup_signatures[xCleanup_sqlite3SelectDeleteGeneric_enum], sizeof(E2.xCleanup_signature)) == 0) {
+ E1 = sqlite3SelectDeleteGeneric(args);
+ }
+ else if (memcmp(E2.xCleanup_signature, xCleanup_signatures[xCleanup_sqlite3WithDeleteGeneric_enum], sizeof(E2.xCleanup_signature)) == 0) {
+ E1 = sqlite3WithDeleteGeneric(args);
+ }
+ else if (memcmp(E2.xCleanup_signature, xCleanup_signatures[xCleanup_whereIndexedExprCleanup_enum], sizeof(E2.xCleanup_signature)) == 0) {
+ E1 = whereIndexedExprCleanup(args);
+ }


// FP: xClose

@transform_assign_xClose_dot@
expression E1, E2;
identifier FP_NAME = xClose;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xClose_signature, xClose_signatures[xClose_apndClose_enum], sizeof(E2.xClose_signature)) == 0) {
+ E1 = apndClose(args);
+ }
+ else if (memcmp(E2.xClose_signature, xClose_signatures[xClose_bytecodevtabClose_enum], sizeof(E2.xClose_signature)) == 0) {
+ E1 = bytecodevtabClose(args);
+ }
+ else if (memcmp(E2.xClose_signature, xClose_signatures[xClose_completionClose_enum], sizeof(E2.xClose_signature)) == 0) {
+ E1 = completionClose(args);
+ }
+ else if (memcmp(E2.xClose_signature, xClose_signatures[xClose_dbdataClose_enum], sizeof(E2.xClose_signature)) == 0) {
+ E1 = dbdataClose(args);
+ }
+ else if (memcmp(E2.xClose_signature, xClose_signatures[xClose_dbpageClose_enum], sizeof(E2.xClose_signature)) == 0) {
+ E1 = dbpageClose(args);
+ }
+ else if (memcmp(E2.xClose_signature, xClose_signatures[xClose_expertClose_enum], sizeof(E2.xClose_signature)) == 0) {
+ E1 = expertClose(args);
+ }
+ else if (memcmp(E2.xClose_signature, xClose_signatures[xClose_fsdirClose_enum], sizeof(E2.xClose_signature)) == 0) {
+ E1 = fsdirClose(args);
+ }
+ else if (memcmp(E2.xClose_signature, xClose_signatures[xClose_fts3CloseMethod_enum], sizeof(E2.xClose_signature)) == 0) {
+ E1 = fts3CloseMethod(args);
+ }
+ else if (memcmp(E2.xClose_signature, xClose_signatures[xClose_fts3auxCloseMethod_enum], sizeof(E2.xClose_signature)) == 0) {
+ E1 = fts3auxCloseMethod(args);
+ }
+ else if (memcmp(E2.xClose_signature, xClose_signatures[xClose_fts3tokCloseMethod_enum], sizeof(E2.xClose_signature)) == 0) {
+ E1 = fts3tokCloseMethod(args);
+ }
+ else if (memcmp(E2.xClose_signature, xClose_signatures[xClose_jsonEachClose_enum], sizeof(E2.xClose_signature)) == 0) {
+ E1 = jsonEachClose(args);
+ }
+ else if (memcmp(E2.xClose_signature, xClose_signatures[xClose_memdbClose_enum], sizeof(E2.xClose_signature)) == 0) {
+ E1 = memdbClose(args);
+ }
+ else if (memcmp(E2.xClose_signature, xClose_signatures[xClose_memjrnlClose_enum], sizeof(E2.xClose_signature)) == 0) {
+ E1 = memjrnlClose(args);
+ }
+ else if (memcmp(E2.xClose_signature, xClose_signatures[xClose_porterClose_enum], sizeof(E2.xClose_signature)) == 0) {
+ E1 = porterClose(args);
+ }
+ else if (memcmp(E2.xClose_signature, xClose_signatures[xClose_pragmaVtabClose_enum], sizeof(E2.xClose_signature)) == 0) {
+ E1 = pragmaVtabClose(args);
+ }
+ else if (memcmp(E2.xClose_signature, xClose_signatures[xClose_recoverVfsClose_enum], sizeof(E2.xClose_signature)) == 0) {
+ E1 = recoverVfsClose(args);
+ }
+ else if (memcmp(E2.xClose_signature, xClose_signatures[xClose_rtreeClose_enum], sizeof(E2.xClose_signature)) == 0) {
+ E1 = rtreeClose(args);
+ }
+ else if (memcmp(E2.xClose_signature, xClose_signatures[xClose_seriesClose_enum], sizeof(E2.xClose_signature)) == 0) {
+ E1 = seriesClose(args);
+ }
+ else if (memcmp(E2.xClose_signature, xClose_signatures[xClose_simpleClose_enum], sizeof(E2.xClose_signature)) == 0) {
+ E1 = simpleClose(args);
+ }
+ else if (memcmp(E2.xClose_signature, xClose_signatures[xClose_statClose_enum], sizeof(E2.xClose_signature)) == 0) {
+ E1 = statClose(args);
+ }
+ else if (memcmp(E2.xClose_signature, xClose_signatures[xClose_stmtClose_enum], sizeof(E2.xClose_signature)) == 0) {
+ E1 = stmtClose(args);
+ }
+ else if (memcmp(E2.xClose_signature, xClose_signatures[xClose_unicodeClose_enum], sizeof(E2.xClose_signature)) == 0) {
+ E1 = unicodeClose(args);
+ }
+ else if (memcmp(E2.xClose_signature, xClose_signatures[xClose_vfstraceClose_enum], sizeof(E2.xClose_signature)) == 0) {
+ E1 = vfstraceClose(args);
+ }
+ else if (memcmp(E2.xClose_signature, xClose_signatures[xClose_zipfileClose_enum], sizeof(E2.xClose_signature)) == 0) {
+ E1 = zipfileClose(args);
+ }


// FP: xCmp

@transform_assign_xCmp_dot@
expression E1, E2;
identifier FP_NAME = xCmp;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xCmp_signature, xCmp_signatures[xCmp_0_enum], sizeof(E2.xCmp_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xCmp_signature, xCmp_signatures[xCmp_binCollFunc_enum], sizeof(E2.xCmp_signature)) == 0) {
+ E1 = binCollFunc(args);
+ }
+ else if (memcmp(E2.xCmp_signature, xCmp_signatures[xCmp_decimalCollFunc_enum], sizeof(E2.xCmp_signature)) == 0) {
+ E1 = decimalCollFunc(args);
+ }
+ else if (memcmp(E2.xCmp_signature, xCmp_signatures[xCmp_dummyCompare_enum], sizeof(E2.xCmp_signature)) == 0) {
+ E1 = dummyCompare(args);
+ }
+ else if (memcmp(E2.xCmp_signature, xCmp_signatures[xCmp_icuCollationColl_enum], sizeof(E2.xCmp_signature)) == 0) {
+ E1 = icuCollationColl(args);
+ }
+ else if (memcmp(E2.xCmp_signature, xCmp_signatures[xCmp_nocaseCollatingFunc_enum], sizeof(E2.xCmp_signature)) == 0) {
+ E1 = nocaseCollatingFunc(args);
+ }
+ else if (memcmp(E2.xCmp_signature, xCmp_signatures[xCmp_rtrimCollFunc_enum], sizeof(E2.xCmp_signature)) == 0) {
+ E1 = rtrimCollFunc(args);
+ }
+ else if (memcmp(E2.xCmp_signature, xCmp_signatures[xCmp_uintCollFunc_enum], sizeof(E2.xCmp_signature)) == 0) {
+ E1 = uintCollFunc(args);
+ }


// FP: xCollNeeded16

@transform_assign_xCollNeeded16_dot@
expression E1, E2;
identifier FP_NAME = xCollNeeded16;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = 0;


// FP: xColumn

@transform_assign_xColumn_dot@
expression E1, E2;
identifier FP_NAME = xColumn;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xColumn_signature, xColumn_signatures[xColumn_bytecodevtabColumn_enum], sizeof(E2.xColumn_signature)) == 0) {
+ E1 = bytecodevtabColumn(args);
+ }
+ else if (memcmp(E2.xColumn_signature, xColumn_signatures[xColumn_completionColumn_enum], sizeof(E2.xColumn_signature)) == 0) {
+ E1 = completionColumn(args);
+ }
+ else if (memcmp(E2.xColumn_signature, xColumn_signatures[xColumn_dbdataColumn_enum], sizeof(E2.xColumn_signature)) == 0) {
+ E1 = dbdataColumn(args);
+ }
+ else if (memcmp(E2.xColumn_signature, xColumn_signatures[xColumn_dbpageColumn_enum], sizeof(E2.xColumn_signature)) == 0) {
+ E1 = dbpageColumn(args);
+ }
+ else if (memcmp(E2.xColumn_signature, xColumn_signatures[xColumn_expertColumn_enum], sizeof(E2.xColumn_signature)) == 0) {
+ E1 = expertColumn(args);
+ }
+ else if (memcmp(E2.xColumn_signature, xColumn_signatures[xColumn_fsdirColumn_enum], sizeof(E2.xColumn_signature)) == 0) {
+ E1 = fsdirColumn(args);
+ }
+ else if (memcmp(E2.xColumn_signature, xColumn_signatures[xColumn_fts3ColumnMethod_enum], sizeof(E2.xColumn_signature)) == 0) {
+ E1 = fts3ColumnMethod(args);
+ }
+ else if (memcmp(E2.xColumn_signature, xColumn_signatures[xColumn_fts3auxColumnMethod_enum], sizeof(E2.xColumn_signature)) == 0) {
+ E1 = fts3auxColumnMethod(args);
+ }
+ else if (memcmp(E2.xColumn_signature, xColumn_signatures[xColumn_fts3tokColumnMethod_enum], sizeof(E2.xColumn_signature)) == 0) {
+ E1 = fts3tokColumnMethod(args);
+ }
+ else if (memcmp(E2.xColumn_signature, xColumn_signatures[xColumn_geopolyColumn_enum], sizeof(E2.xColumn_signature)) == 0) {
+ E1 = geopolyColumn(args);
+ }
+ else if (memcmp(E2.xColumn_signature, xColumn_signatures[xColumn_jsonEachColumn_enum], sizeof(E2.xColumn_signature)) == 0) {
+ E1 = jsonEachColumn(args);
+ }
+ else if (memcmp(E2.xColumn_signature, xColumn_signatures[xColumn_pragmaVtabColumn_enum], sizeof(E2.xColumn_signature)) == 0) {
+ E1 = pragmaVtabColumn(args);
+ }
+ else if (memcmp(E2.xColumn_signature, xColumn_signatures[xColumn_rtreeColumn_enum], sizeof(E2.xColumn_signature)) == 0) {
+ E1 = rtreeColumn(args);
+ }
+ else if (memcmp(E2.xColumn_signature, xColumn_signatures[xColumn_seriesColumn_enum], sizeof(E2.xColumn_signature)) == 0) {
+ E1 = seriesColumn(args);
+ }
+ else if (memcmp(E2.xColumn_signature, xColumn_signatures[xColumn_statColumn_enum], sizeof(E2.xColumn_signature)) == 0) {
+ E1 = statColumn(args);
+ }
+ else if (memcmp(E2.xColumn_signature, xColumn_signatures[xColumn_stmtColumn_enum], sizeof(E2.xColumn_signature)) == 0) {
+ E1 = stmtColumn(args);
+ }
+ else if (memcmp(E2.xColumn_signature, xColumn_signatures[xColumn_zipfileColumn_enum], sizeof(E2.xColumn_signature)) == 0) {
+ E1 = zipfileColumn(args);
+ }


// FP: xCommit

@transform_assign_xCommit_dot@
expression E1, E2;
identifier FP_NAME = xCommit;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xCommit_signature, xCommit_signatures[xCommit_0_enum], sizeof(E2.xCommit_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xCommit_signature, xCommit_signatures[xCommit_fts3CommitMethod_enum], sizeof(E2.xCommit_signature)) == 0) {
+ E1 = fts3CommitMethod(args);
+ }
+ else if (memcmp(E2.xCommit_signature, xCommit_signatures[xCommit_rtreeEndTransaction_enum], sizeof(E2.xCommit_signature)) == 0) {
+ E1 = rtreeEndTransaction(args);
+ }
+ else if (memcmp(E2.xCommit_signature, xCommit_signatures[xCommit_zipfileCommit_enum], sizeof(E2.xCommit_signature)) == 0) {
+ E1 = zipfileCommit(args);
+ }


// FP: xCommitCallback

@transform_assign_xCommitCallback_dot@
expression E1, E2;
identifier FP_NAME = xCommitCallback;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xCommitCallback_signature, xCommitCallback_signatures[xCommitCallback_0_enum], sizeof(E2.xCommitCallback_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xCommitCallback_signature, xCommitCallback_signatures[xCommitCallback_sql_trace_callback_enum], sizeof(E2.xCommitCallback_signature)) == 0) {
+ E1 = sql_trace_callback(args);
+ }
+ else if (memcmp(E2.xCommitCallback_signature, xCommitCallback_signatures[xCommitCallback_sqlite3WalDefaultHook_enum], sizeof(E2.xCommitCallback_signature)) == 0) {
+ E1 = sqlite3WalDefaultHook(args);
+ }


// FP: xConnect

@transform_assign_xConnect_dot@
expression E1, E2;
identifier FP_NAME = xConnect;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xConnect_signature, xConnect_signatures[xConnect_bytecodevtabConnect_enum], sizeof(E2.xConnect_signature)) == 0) {
+ E1 = bytecodevtabConnect(args);
+ }
+ else if (memcmp(E2.xConnect_signature, xConnect_signatures[xConnect_dbpageConnect_enum], sizeof(E2.xConnect_signature)) == 0) {
+ E1 = dbpageConnect(args);
+ }
+ else if (memcmp(E2.xConnect_signature, xConnect_signatures[xConnect_fts3ConnectMethod_enum], sizeof(E2.xConnect_signature)) == 0) {
+ E1 = fts3ConnectMethod(args);
+ }
+ else if (memcmp(E2.xConnect_signature, xConnect_signatures[xConnect_fts3auxConnectMethod_enum], sizeof(E2.xConnect_signature)) == 0) {
+ E1 = fts3auxConnectMethod(args);
+ }
+ else if (memcmp(E2.xConnect_signature, xConnect_signatures[xConnect_fts3tokConnectMethod_enum], sizeof(E2.xConnect_signature)) == 0) {
+ E1 = fts3tokConnectMethod(args);
+ }
+ else if (memcmp(E2.xConnect_signature, xConnect_signatures[xConnect_jsonEachConnect_enum], sizeof(E2.xConnect_signature)) == 0) {
+ E1 = jsonEachConnect(args);
+ }
+ else if (memcmp(E2.xConnect_signature, xConnect_signatures[xConnect_pragmaVtabConnect_enum], sizeof(E2.xConnect_signature)) == 0) {
+ E1 = pragmaVtabConnect(args);
+ }
+ else if (memcmp(E2.xConnect_signature, xConnect_signatures[xConnect_rtreeConnect_enum], sizeof(E2.xConnect_signature)) == 0) {
+ E1 = rtreeConnect(args);
+ }
+ else if (memcmp(E2.xConnect_signature, xConnect_signatures[xConnect_statConnect_enum], sizeof(E2.xConnect_signature)) == 0) {
+ E1 = statConnect(args);
+ }
+ else if (memcmp(E2.xConnect_signature, xConnect_signatures[xConnect_stmtConnect_enum], sizeof(E2.xConnect_signature)) == 0) {
+ E1 = stmtConnect(args);
+ }


// FP: xCount

@transform_assign_xCount_dot@
expression E1, E2;
identifier FP_NAME = xCount;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xCount_signature, xCount_signatures[xCount_sessionDiffCount_enum], sizeof(E2.xCount_signature)) == 0) {
+ E1 = sessionDiffCount(args);
+ }
+ else if (memcmp(E2.xCount_signature, xCount_signatures[xCount_sessionPreupdateCount_enum], sizeof(E2.xCount_signature)) == 0) {
+ E1 = sessionPreupdateCount(args);
+ }
+ else if (memcmp(E2.xCount_signature, xCount_signatures[xCount_sessionStat1Count_enum], sizeof(E2.xCount_signature)) == 0) {
+ E1 = sessionStat1Count(args);
+ }


// FP: xCreate

@transform_assign_xCreate_dot@
expression E1, E2;
identifier FP_NAME = xCreate;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xCreate_signature, xCreate_signatures[xCreate_0_enum], sizeof(E2.xCreate_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xCreate_signature, xCreate_signatures[xCreate_dbpageConnect_enum], sizeof(E2.xCreate_signature)) == 0) {
+ E1 = dbpageConnect(args);
+ }
+ else if (memcmp(E2.xCreate_signature, xCreate_signatures[xCreate_fts3CreateMethod_enum], sizeof(E2.xCreate_signature)) == 0) {
+ E1 = fts3CreateMethod(args);
+ }
+ else if (memcmp(E2.xCreate_signature, xCreate_signatures[xCreate_fts3auxConnectMethod_enum], sizeof(E2.xCreate_signature)) == 0) {
+ E1 = fts3auxConnectMethod(args);
+ }
+ else if (memcmp(E2.xCreate_signature, xCreate_signatures[xCreate_fts3tokConnectMethod_enum], sizeof(E2.xCreate_signature)) == 0) {
+ E1 = fts3tokConnectMethod(args);
+ }
+ else if (memcmp(E2.xCreate_signature, xCreate_signatures[xCreate_geopolyCreate_enum], sizeof(E2.xCreate_signature)) == 0) {
+ E1 = geopolyCreate(args);
+ }
+ else if (memcmp(E2.xCreate_signature, xCreate_signatures[xCreate_pcache1Create_enum], sizeof(E2.xCreate_signature)) == 0) {
+ E1 = pcache1Create(args);
+ }
+ else if (memcmp(E2.xCreate_signature, xCreate_signatures[xCreate_pcachetraceCreate_enum], sizeof(E2.xCreate_signature)) == 0) {
+ E1 = pcachetraceCreate(args);
+ }
+ else if (memcmp(E2.xCreate_signature, xCreate_signatures[xCreate_porterCreate_enum], sizeof(E2.xCreate_signature)) == 0) {
+ E1 = porterCreate(args);
+ }
+ else if (memcmp(E2.xCreate_signature, xCreate_signatures[xCreate_rtreeCreate_enum], sizeof(E2.xCreate_signature)) == 0) {
+ E1 = rtreeCreate(args);
+ }
+ else if (memcmp(E2.xCreate_signature, xCreate_signatures[xCreate_simpleCreate_enum], sizeof(E2.xCreate_signature)) == 0) {
+ E1 = simpleCreate(args);
+ }
+ else if (memcmp(E2.xCreate_signature, xCreate_signatures[xCreate_statConnect_enum], sizeof(E2.xCreate_signature)) == 0) {
+ E1 = statConnect(args);
+ }
+ else if (memcmp(E2.xCreate_signature, xCreate_signatures[xCreate_unicodeCreate_enum], sizeof(E2.xCreate_signature)) == 0) {
+ E1 = unicodeCreate(args);
+ }


// FP: xCurrentTime

@transform_assign_xCurrentTime_dot@
expression E1, E2;
identifier FP_NAME = xCurrentTime;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xCurrentTime_signature, xCurrentTime_signatures[xCurrentTime_0_enum], sizeof(E2.xCurrentTime_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xCurrentTime_signature, xCurrentTime_signatures[xCurrentTime_apndCurrentTime_enum], sizeof(E2.xCurrentTime_signature)) == 0) {
+ E1 = apndCurrentTime(args);
+ }
+ else if (memcmp(E2.xCurrentTime_signature, xCurrentTime_signatures[xCurrentTime_vfstraceCurrentTime_enum], sizeof(E2.xCurrentTime_signature)) == 0) {
+ E1 = vfstraceCurrentTime(args);
+ }
+ else if (memcmp(E2.xCurrentTime_signature, xCurrentTime_signatures[xCurrentTime_unixCurrentTime_enum], sizeof(E2.xCurrentTime_signature)) == 0) {
+ E1 = unixCurrentTime(args);
+ }


// FP: xCurrentTimeInt64

@transform_assign_xCurrentTimeInt64_dot@
expression E1, E2;
identifier FP_NAME = xCurrentTimeInt64;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xCurrentTimeInt64_signature, xCurrentTimeInt64_signatures[xCurrentTimeInt64_apndCurrentTimeInt64_enum], sizeof(E2.xCurrentTimeInt64_signature)) == 0) {
+ E1 = apndCurrentTimeInt64(args);
+ }
+ else if (memcmp(E2.xCurrentTimeInt64_signature, xCurrentTimeInt64_signatures[xCurrentTimeInt64_memdbCurrentTimeInt64_enum], sizeof(E2.xCurrentTimeInt64_signature)) == 0) {
+ E1 = memdbCurrentTimeInt64(args);
+ }
+ else if (memcmp(E2.xCurrentTimeInt64_signature, xCurrentTimeInt64_signatures[xCurrentTimeInt64_unixCurrentTimeInt64_enum], sizeof(E2.xCurrentTimeInt64_signature)) == 0) {
+ E1 = unixCurrentTimeInt64(args);
+ }


// FP: xDel

@transform_assign_xDel_dot@
expression E1, E2;
identifier FP_NAME = xDel;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xDel_signature, xDel_signatures[xDel_0_enum], sizeof(E2.xDel_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xDel_signature, xDel_signatures[xDel_SQLITE_DYNAMIC_enum], sizeof(E2.xDel_signature)) == 0) {
+ E1 = SQLITE_DYNAMIC(args);
+ }
+ else if (memcmp(E2.xDel_signature, xDel_signatures[xDel_SQLITE_STATIC_enum], sizeof(E2.xDel_signature)) == 0) {
+ E1 = SQLITE_STATIC(args);
+ }
+ else if (memcmp(E2.xDel_signature, xDel_signatures[xDel_SQLITE_TRANSIENT_enum], sizeof(E2.xDel_signature)) == 0) {
+ E1 = SQLITE_TRANSIENT(args);
+ }
+ else if (memcmp(E2.xDel_signature, xDel_signatures[xDel_rtreeMatchArgFree_enum], sizeof(E2.xDel_signature)) == 0) {
+ E1 = rtreeMatchArgFree(args);
+ }
+ else if (memcmp(E2.xDel_signature, xDel_signatures[xDel_sqlite3RCStrUnref_enum], sizeof(E2.xDel_signature)) == 0) {
+ E1 = sqlite3RCStrUnref(args);
+ }
+ else if (memcmp(E2.xDel_signature, xDel_signatures[xDel_sqlite3RowSetDelete_enum], sizeof(E2.xDel_signature)) == 0) {
+ E1 = sqlite3RowSetDelete(args);
+ }
+ else if (memcmp(E2.xDel_signature, xDel_signatures[xDel_sqlite3SchemaClear_enum], sizeof(E2.xDel_signature)) == 0) {
+ E1 = sqlite3SchemaClear(args);
+ }
+ else if (memcmp(E2.xDel_signature, xDel_signatures[xDel_sqlite3VdbeFrameMemDel_enum], sizeof(E2.xDel_signature)) == 0) {
+ E1 = sqlite3VdbeFrameMemDel(args);
+ }
+ else if (memcmp(E2.xDel_signature, xDel_signatures[xDel_sqlite3VdbeValueListFree_enum], sizeof(E2.xDel_signature)) == 0) {
+ E1 = sqlite3VdbeValueListFree(args);
+ }
+ else if (memcmp(E2.xDel_signature, xDel_signatures[xDel_sqlite3_free_enum], sizeof(E2.xDel_signature)) == 0) {
+ E1 = sqlite3_free(args);
+ }
+ else if (memcmp(E2.xDel_signature, xDel_signatures[xDel_statAccumDestructor_enum], sizeof(E2.xDel_signature)) == 0) {
+ E1 = statAccumDestructor(args);
+ }
+ else if (memcmp(E2.xDel_signature, xDel_signatures[xDel_xDel_enum], sizeof(E2.xDel_signature)) == 0) {
+ E1 = xDel(args);
+ }
+ else if (memcmp(E2.xDel_signature, xDel_signatures[xDel_zipfileFree_enum], sizeof(E2.xDel_signature)) == 0) {
+ E1 = zipfileFree(args);
+ }


// FP: xDelete

@transform_assign_xDelete_dot@
expression E1, E2;
identifier FP_NAME = xDelete;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xDelete_signature, xDelete_signatures[xDelete_0_enum], sizeof(E2.xDelete_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xDelete_signature, xDelete_signatures[xDelete_apndDelete_enum], sizeof(E2.xDelete_signature)) == 0) {
+ E1 = apndDelete(args);
+ }
+ else if (memcmp(E2.xDelete_signature, xDelete_signatures[xDelete_jsonCacheDeleteGeneric_enum], sizeof(E2.xDelete_signature)) == 0) {
+ E1 = jsonCacheDeleteGeneric(args);
+ }
+ else if (memcmp(E2.xDelete_signature, xDelete_signatures[xDelete_kvstorageDelete_enum], sizeof(E2.xDelete_signature)) == 0) {
+ E1 = kvstorageDelete(args);
+ }
+ else if (memcmp(E2.xDelete_signature, xDelete_signatures[xDelete_sqlite3_free_enum], sizeof(E2.xDelete_signature)) == 0) {
+ E1 = sqlite3_free(args);
+ }
+ else if (memcmp(E2.xDelete_signature, xDelete_signatures[xDelete_vfstraceDelete_enum], sizeof(E2.xDelete_signature)) == 0) {
+ E1 = vfstraceDelete(args);
+ }
+ else if (memcmp(E2.xDelete_signature, xDelete_signatures[xDelete_unixDelete_enum], sizeof(E2.xDelete_signature)) == 0) {
+ E1 = unixDelete(args);
+ }


// FP: xDeleteAux

@transform_assign_xDeleteAux_dot@
expression E1, E2;
identifier FP_NAME = xDeleteAux;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xDeleteAux_signature, xDeleteAux_signatures[xDeleteAux_jsonCacheDeleteGeneric_enum], sizeof(E2.xDeleteAux_signature)) == 0) {
+ E1 = jsonCacheDeleteGeneric(args);
+ }
+ else if (memcmp(E2.xDeleteAux_signature, xDeleteAux_signatures[xDeleteAux_sqlite3_free_enum], sizeof(E2.xDeleteAux_signature)) == 0) {
+ E1 = sqlite3_free(args);
+ }


// FP: xDepth

@transform_assign_xDepth_dot@
expression E1, E2;
identifier FP_NAME = xDepth;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xDepth_signature, xDepth_signatures[xDepth_sessionDiffDepth_enum], sizeof(E2.xDepth_signature)) == 0) {
+ E1 = sessionDiffDepth(args);
+ }
+ else if (memcmp(E2.xDepth_signature, xDepth_signatures[xDepth_sessionPreupdateDepth_enum], sizeof(E2.xDepth_signature)) == 0) {
+ E1 = sessionPreupdateDepth(args);
+ }
+ else if (memcmp(E2.xDepth_signature, xDepth_signatures[xDepth_sessionStat1Depth_enum], sizeof(E2.xDepth_signature)) == 0) {
+ E1 = sessionStat1Depth(args);
+ }


// FP: xDestroy

@transform_assign_xDestroy_dot@
expression E1, E2;
identifier FP_NAME = xDestroy;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xDestroy_signature, xDestroy_signatures[xDestroy_0_enum], sizeof(E2.xDestroy_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xDestroy_signature, xDestroy_signatures[xDestroy_dbpageDisconnect_enum], sizeof(E2.xDestroy_signature)) == 0) {
+ E1 = dbpageDisconnect(args);
+ }
+ else if (memcmp(E2.xDestroy_signature, xDestroy_signatures[xDestroy_expertDisconnect_enum], sizeof(E2.xDestroy_signature)) == 0) {
+ E1 = expertDisconnect(args);
+ }
+ else if (memcmp(E2.xDestroy_signature, xDestroy_signatures[xDestroy_fts3DestroyMethod_enum], sizeof(E2.xDestroy_signature)) == 0) {
+ E1 = fts3DestroyMethod(args);
+ }
+ else if (memcmp(E2.xDestroy_signature, xDestroy_signatures[xDestroy_fts3auxDisconnectMethod_enum], sizeof(E2.xDestroy_signature)) == 0) {
+ E1 = fts3auxDisconnectMethod(args);
+ }
+ else if (memcmp(E2.xDestroy_signature, xDestroy_signatures[xDestroy_fts3tokDisconnectMethod_enum], sizeof(E2.xDestroy_signature)) == 0) {
+ E1 = fts3tokDisconnectMethod(args);
+ }
+ else if (memcmp(E2.xDestroy_signature, xDestroy_signatures[xDestroy_hashDestroy_enum], sizeof(E2.xDestroy_signature)) == 0) {
+ E1 = hashDestroy(args);
+ }
+ else if (memcmp(E2.xDestroy_signature, xDestroy_signatures[xDestroy_pcache1Destroy_enum], sizeof(E2.xDestroy_signature)) == 0) {
+ E1 = pcache1Destroy(args);
+ }
+ else if (memcmp(E2.xDestroy_signature, xDestroy_signatures[xDestroy_pcachetraceDestroy_enum], sizeof(E2.xDestroy_signature)) == 0) {
+ E1 = pcachetraceDestroy(args);
+ }
+ else if (memcmp(E2.xDestroy_signature, xDestroy_signatures[xDestroy_porterDestroy_enum], sizeof(E2.xDestroy_signature)) == 0) {
+ E1 = porterDestroy(args);
+ }
+ else if (memcmp(E2.xDestroy_signature, xDestroy_signatures[xDestroy_rtreeDestroy_enum], sizeof(E2.xDestroy_signature)) == 0) {
+ E1 = rtreeDestroy(args);
+ }
+ else if (memcmp(E2.xDestroy_signature, xDestroy_signatures[xDestroy_rtreeFreeCallback_enum], sizeof(E2.xDestroy_signature)) == 0) {
+ E1 = rtreeFreeCallback(args);
+ }
+ else if (memcmp(E2.xDestroy_signature, xDestroy_signatures[xDestroy_simpleDestroy_enum], sizeof(E2.xDestroy_signature)) == 0) {
+ E1 = simpleDestroy(args);
+ }
+ else if (memcmp(E2.xDestroy_signature, xDestroy_signatures[xDestroy_sqlite3_free_enum], sizeof(E2.xDestroy_signature)) == 0) {
+ E1 = sqlite3_free(args);
+ }
+ else if (memcmp(E2.xDestroy_signature, xDestroy_signatures[xDestroy_statDisconnect_enum], sizeof(E2.xDestroy_signature)) == 0) {
+ E1 = statDisconnect(args);
+ }
+ else if (memcmp(E2.xDestroy_signature, xDestroy_signatures[xDestroy_unicodeDestroy_enum], sizeof(E2.xDestroy_signature)) == 0) {
+ E1 = unicodeDestroy(args);
+ }
+ else if (memcmp(E2.xDestroy_signature, xDestroy_signatures[xDestroy_zipfileDisconnect_enum], sizeof(E2.xDestroy_signature)) == 0) {
+ E1 = zipfileDisconnect(args);
+ }


// FP: xDestructor

@transform_assign_xDestructor_dot@
expression E1, E2;
identifier FP_NAME = xDestructor;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xDestructor_signature, xDestructor_signatures[xDestructor_0_enum], sizeof(E2.xDestructor_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xDestructor_signature, xDestructor_signatures[xDestructor_rtreeMatchArgFree_enum], sizeof(E2.xDestructor_signature)) == 0) {
+ E1 = rtreeMatchArgFree(args);
+ }
+ else if (memcmp(E2.xDestructor_signature, xDestructor_signatures[xDestructor_sqlite3VdbeValueListFree_enum], sizeof(E2.xDestructor_signature)) == 0) {
+ E1 = sqlite3VdbeValueListFree(args);
+ }


// FP: xDeviceCharacteristics

@transform_assign_xDeviceCharacteristics_dot@
expression E1, E2;
identifier FP_NAME = xDeviceCharacteristics;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xDeviceCharacteristics_signature, xDeviceCharacteristics_signatures[xDeviceCharacteristics_0_enum], sizeof(E2.xDeviceCharacteristics_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xDeviceCharacteristics_signature, xDeviceCharacteristics_signatures[xDeviceCharacteristics_apndDeviceCharacteristics_enum], sizeof(E2.xDeviceCharacteristics_signature)) == 0) {
+ E1 = apndDeviceCharacteristics(args);
+ }
+ else if (memcmp(E2.xDeviceCharacteristics_signature, xDeviceCharacteristics_signatures[xDeviceCharacteristics_memdbDeviceCharacteristics_enum], sizeof(E2.xDeviceCharacteristics_signature)) == 0) {
+ E1 = memdbDeviceCharacteristics(args);
+ }
+ else if (memcmp(E2.xDeviceCharacteristics_signature, xDeviceCharacteristics_signatures[xDeviceCharacteristics_recoverVfsDeviceCharacteristics_enum], sizeof(E2.xDeviceCharacteristics_signature)) == 0) {
+ E1 = recoverVfsDeviceCharacteristics(args);
+ }
+ else if (memcmp(E2.xDeviceCharacteristics_signature, xDeviceCharacteristics_signatures[xDeviceCharacteristics_vfstraceDeviceCharacteristics_enum], sizeof(E2.xDeviceCharacteristics_signature)) == 0) {
+ E1 = vfstraceDeviceCharacteristics(args);
+ }


// FP: xDisconnect

@transform_assign_xDisconnect_dot@
expression E1, E2;
identifier FP_NAME = xDisconnect;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xDisconnect_signature, xDisconnect_signatures[xDisconnect_bytecodevtabDisconnect_enum], sizeof(E2.xDisconnect_signature)) == 0) {
+ E1 = bytecodevtabDisconnect(args);
+ }
+ else if (memcmp(E2.xDisconnect_signature, xDisconnect_signatures[xDisconnect_completionDisconnect_enum], sizeof(E2.xDisconnect_signature)) == 0) {
+ E1 = completionDisconnect(args);
+ }
+ else if (memcmp(E2.xDisconnect_signature, xDisconnect_signatures[xDisconnect_dbdataDisconnect_enum], sizeof(E2.xDisconnect_signature)) == 0) {
+ E1 = dbdataDisconnect(args);
+ }
+ else if (memcmp(E2.xDisconnect_signature, xDisconnect_signatures[xDisconnect_dbpageDisconnect_enum], sizeof(E2.xDisconnect_signature)) == 0) {
+ E1 = dbpageDisconnect(args);
+ }
+ else if (memcmp(E2.xDisconnect_signature, xDisconnect_signatures[xDisconnect_expertDisconnect_enum], sizeof(E2.xDisconnect_signature)) == 0) {
+ E1 = expertDisconnect(args);
+ }
+ else if (memcmp(E2.xDisconnect_signature, xDisconnect_signatures[xDisconnect_fsdirDisconnect_enum], sizeof(E2.xDisconnect_signature)) == 0) {
+ E1 = fsdirDisconnect(args);
+ }
+ else if (memcmp(E2.xDisconnect_signature, xDisconnect_signatures[xDisconnect_fts3DisconnectMethod_enum], sizeof(E2.xDisconnect_signature)) == 0) {
+ E1 = fts3DisconnectMethod(args);
+ }
+ else if (memcmp(E2.xDisconnect_signature, xDisconnect_signatures[xDisconnect_fts3auxDisconnectMethod_enum], sizeof(E2.xDisconnect_signature)) == 0) {
+ E1 = fts3auxDisconnectMethod(args);
+ }
+ else if (memcmp(E2.xDisconnect_signature, xDisconnect_signatures[xDisconnect_fts3tokDisconnectMethod_enum], sizeof(E2.xDisconnect_signature)) == 0) {
+ E1 = fts3tokDisconnectMethod(args);
+ }
+ else if (memcmp(E2.xDisconnect_signature, xDisconnect_signatures[xDisconnect_jsonEachDisconnect_enum], sizeof(E2.xDisconnect_signature)) == 0) {
+ E1 = jsonEachDisconnect(args);
+ }
+ else if (memcmp(E2.xDisconnect_signature, xDisconnect_signatures[xDisconnect_pragmaVtabDisconnect_enum], sizeof(E2.xDisconnect_signature)) == 0) {
+ E1 = pragmaVtabDisconnect(args);
+ }
+ else if (memcmp(E2.xDisconnect_signature, xDisconnect_signatures[xDisconnect_rtreeDisconnect_enum], sizeof(E2.xDisconnect_signature)) == 0) {
+ E1 = rtreeDisconnect(args);
+ }
+ else if (memcmp(E2.xDisconnect_signature, xDisconnect_signatures[xDisconnect_seriesDisconnect_enum], sizeof(E2.xDisconnect_signature)) == 0) {
+ E1 = seriesDisconnect(args);
+ }
+ else if (memcmp(E2.xDisconnect_signature, xDisconnect_signatures[xDisconnect_statDisconnect_enum], sizeof(E2.xDisconnect_signature)) == 0) {
+ E1 = statDisconnect(args);
+ }
+ else if (memcmp(E2.xDisconnect_signature, xDisconnect_signatures[xDisconnect_stmtDisconnect_enum], sizeof(E2.xDisconnect_signature)) == 0) {
+ E1 = stmtDisconnect(args);
+ }
+ else if (memcmp(E2.xDisconnect_signature, xDisconnect_signatures[xDisconnect_zipfileDisconnect_enum], sizeof(E2.xDisconnect_signature)) == 0) {
+ E1 = zipfileDisconnect(args);
+ }


// FP: xDlClose

@transform_assign_xDlClose_dot@
expression E1, E2;
identifier FP_NAME = xDlClose;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xDlClose_signature, xDlClose_signatures[xDlClose_0_enum], sizeof(E2.xDlClose_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xDlClose_signature, xDlClose_signatures[xDlClose_apndDlClose_enum], sizeof(E2.xDlClose_signature)) == 0) {
+ E1 = apndDlClose(args);
+ }
+ else if (memcmp(E2.xDlClose_signature, xDlClose_signatures[xDlClose_memdbDlClose_enum], sizeof(E2.xDlClose_signature)) == 0) {
+ E1 = memdbDlClose(args);
+ }
+ else if (memcmp(E2.xDlClose_signature, xDlClose_signatures[xDlClose_unixDlClose_enum], sizeof(E2.xDlClose_signature)) == 0) {
+ E1 = unixDlClose(args);
+ }


// FP: xDlError

@transform_assign_xDlError_dot@
expression E1, E2;
identifier FP_NAME = xDlError;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xDlError_signature, xDlError_signatures[xDlError_0_enum], sizeof(E2.xDlError_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xDlError_signature, xDlError_signatures[xDlError_apndDlError_enum], sizeof(E2.xDlError_signature)) == 0) {
+ E1 = apndDlError(args);
+ }
+ else if (memcmp(E2.xDlError_signature, xDlError_signatures[xDlError_memdbDlError_enum], sizeof(E2.xDlError_signature)) == 0) {
+ E1 = memdbDlError(args);
+ }
+ else if (memcmp(E2.xDlError_signature, xDlError_signatures[xDlError_unixDlError_enum], sizeof(E2.xDlError_signature)) == 0) {
+ E1 = unixDlError(args);
+ }


// FP: xDlOpen

@transform_assign_xDlOpen_dot@
expression E1, E2;
identifier FP_NAME = xDlOpen;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xDlOpen_signature, xDlOpen_signatures[xDlOpen_apndDlOpen_enum], sizeof(E2.xDlOpen_signature)) == 0) {
+ E1 = apndDlOpen(args);
+ }
+ else if (memcmp(E2.xDlOpen_signature, xDlOpen_signatures[xDlOpen_memdbDlOpen_enum], sizeof(E2.xDlOpen_signature)) == 0) {
+ E1 = memdbDlOpen(args);
+ }
+ else if (memcmp(E2.xDlOpen_signature, xDlOpen_signatures[xDlOpen_unixDlOpen_enum], sizeof(E2.xDlOpen_signature)) == 0) {
+ E1 = unixDlOpen(args);
+ }


// FP: xDlSym

@transform_assign_xDlSym_dot@
expression E1, E2;
identifier FP_NAME = xDlSym;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xDlSym_signature, xDlSym_signatures[xDlSym_0_enum], sizeof(E2.xDlSym_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xDlSym_signature, xDlSym_signatures[xDlSym_apndDlSym_enum], sizeof(E2.xDlSym_signature)) == 0) {
+ E1 = apndDlSym(args);
+ }
+ else if (memcmp(E2.xDlSym_signature, xDlSym_signatures[xDlSym_memdbDlSym_enum], sizeof(E2.xDlSym_signature)) == 0) {
+ E1 = memdbDlSym(args);
+ }
+ else if (memcmp(E2.xDlSym_signature, xDlSym_signatures[xDlSym_rbuVfsDlSym_enum], sizeof(E2.xDlSym_signature)) == 0) {
+ E1 = rbuVfsDlSym(args);
+ }
+ else if (memcmp(E2.xDlSym_signature, xDlSym_signatures[xDlSym_winDlSym_enum], sizeof(E2.xDlSym_signature)) == 0) {
+ E1 = winDlSym(args);
+ }
+ else if (memcmp(E2.xDlSym_signature, xDlSym_signatures[xDlSym_unixDlSym_enum], sizeof(E2.xDlSym_signature)) == 0) {
+ E1 = unixDlSym(args);
+ }


// FP: xEof

@transform_assign_xEof_dot@
expression E1, E2;
identifier FP_NAME = xEof;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xEof_signature, xEof_signatures[xEof_bytecodevtabEof_enum], sizeof(E2.xEof_signature)) == 0) {
+ E1 = bytecodevtabEof(args);
+ }
+ else if (memcmp(E2.xEof_signature, xEof_signatures[xEof_completionEof_enum], sizeof(E2.xEof_signature)) == 0) {
+ E1 = completionEof(args);
+ }
+ else if (memcmp(E2.xEof_signature, xEof_signatures[xEof_dbdataEof_enum], sizeof(E2.xEof_signature)) == 0) {
+ E1 = dbdataEof(args);
+ }
+ else if (memcmp(E2.xEof_signature, xEof_signatures[xEof_dbpageEof_enum], sizeof(E2.xEof_signature)) == 0) {
+ E1 = dbpageEof(args);
+ }
+ else if (memcmp(E2.xEof_signature, xEof_signatures[xEof_expertEof_enum], sizeof(E2.xEof_signature)) == 0) {
+ E1 = expertEof(args);
+ }
+ else if (memcmp(E2.xEof_signature, xEof_signatures[xEof_fsdirEof_enum], sizeof(E2.xEof_signature)) == 0) {
+ E1 = fsdirEof(args);
+ }
+ else if (memcmp(E2.xEof_signature, xEof_signatures[xEof_fts3EofMethod_enum], sizeof(E2.xEof_signature)) == 0) {
+ E1 = fts3EofMethod(args);
+ }
+ else if (memcmp(E2.xEof_signature, xEof_signatures[xEof_fts3auxEofMethod_enum], sizeof(E2.xEof_signature)) == 0) {
+ E1 = fts3auxEofMethod(args);
+ }
+ else if (memcmp(E2.xEof_signature, xEof_signatures[xEof_fts3tokEofMethod_enum], sizeof(E2.xEof_signature)) == 0) {
+ E1 = fts3tokEofMethod(args);
+ }
+ else if (memcmp(E2.xEof_signature, xEof_signatures[xEof_jsonEachEof_enum], sizeof(E2.xEof_signature)) == 0) {
+ E1 = jsonEachEof(args);
+ }
+ else if (memcmp(E2.xEof_signature, xEof_signatures[xEof_pragmaVtabEof_enum], sizeof(E2.xEof_signature)) == 0) {
+ E1 = pragmaVtabEof(args);
+ }
+ else if (memcmp(E2.xEof_signature, xEof_signatures[xEof_rtreeEof_enum], sizeof(E2.xEof_signature)) == 0) {
+ E1 = rtreeEof(args);
+ }
+ else if (memcmp(E2.xEof_signature, xEof_signatures[xEof_seriesEof_enum], sizeof(E2.xEof_signature)) == 0) {
+ E1 = seriesEof(args);
+ }
+ else if (memcmp(E2.xEof_signature, xEof_signatures[xEof_statEof_enum], sizeof(E2.xEof_signature)) == 0) {
+ E1 = statEof(args);
+ }
+ else if (memcmp(E2.xEof_signature, xEof_signatures[xEof_stmtEof_enum], sizeof(E2.xEof_signature)) == 0) {
+ E1 = stmtEof(args);
+ }
+ else if (memcmp(E2.xEof_signature, xEof_signatures[xEof_zipfileEof_enum], sizeof(E2.xEof_signature)) == 0) {
+ E1 = zipfileEof(args);
+ }


// FP: xExprCallback

@transform_assign_xExprCallback_dot@
expression E1, E2;
identifier FP_NAME = xExprCallback;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_agginfoPersistExprCb_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = agginfoPersistExprCb(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_aggregateIdxEprRefToColCallback_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = aggregateIdxEprRefToColCallback(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_analyzeAggregate_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = analyzeAggregate(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_checkConstraintExprNode_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = checkConstraintExprNode(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_codeCursorHintCheckExpr_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = codeCursorHintCheckExpr(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_codeCursorHintFixExpr_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = codeCursorHintFixExpr(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_codeCursorHintIsOrFunction_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = codeCursorHintIsOrFunction(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_disallowAggregatesInOrderByCb_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = disallowAggregatesInOrderByCb(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprColumnFlagUnion_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = exprColumnFlagUnion(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprIdxCover_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = exprIdxCover(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprNodeCanReturnSubtype_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = exprNodeCanReturnSubtype(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprNodeIsConstant_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = exprNodeIsConstant(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprNodeIsConstantOrGroupBy_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = exprNodeIsConstantOrGroupBy(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprNodeIsDeterministic_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = exprNodeIsDeterministic(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprRefToSrcList_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = exprRefToSrcList(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_fixExprCb_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = fixExprCb(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_gatherSelectWindowsCallback_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = gatherSelectWindowsCallback(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_havingToWhereExprCb_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = havingToWhereExprCb(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_impliesNotNullRow_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = impliesNotNullRow(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_incrAggDepth_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = incrAggDepth(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_markImmutableExprStep_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = markImmutableExprStep(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_propagateConstantExprRewrite_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = propagateConstantExprRewrite(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_recomputeColumnsUsedExpr_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = recomputeColumnsUsedExpr(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_renameColumnExprCb_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = renameColumnExprCb(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_renameQuotefixExprCb_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = renameQuotefixExprCb(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_renameTableExprCb_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = renameTableExprCb(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_renameUnmapExprCb_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = renameUnmapExprCb(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_renumberCursorsCb_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = renumberCursorsCb(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_resolveExprStep_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = resolveExprStep(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_resolveRemoveWindowsCb_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = resolveRemoveWindowsCb(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_selectCheckOnClausesExpr_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = selectCheckOnClausesExpr(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_selectWindowRewriteExprCb_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = selectWindowRewriteExprCb(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_sqlite3CursorRangeHintExprCheck_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = sqlite3CursorRangeHintExprCheck(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_sqlite3ExprWalkNoop_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = sqlite3ExprWalkNoop(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_sqlite3ReturningSubqueryVarSelect_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = sqlite3ReturningSubqueryVarSelect(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_sqlite3WindowExtraAggFuncDepth_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = sqlite3WindowExtraAggFuncDepth(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_whereIsCoveringIndexWalkCallback_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = whereIsCoveringIndexWalkCallback(args);
+ }


// FP: xFetch

@transform_assign_xFetch_dot@
expression E1, E2;
identifier FP_NAME = xFetch;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xFetch_signature, xFetch_signatures[xFetch_0_enum], sizeof(E2.xFetch_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xFetch_signature, xFetch_signatures[xFetch_apndFetch_enum], sizeof(E2.xFetch_signature)) == 0) {
+ E1 = apndFetch(args);
+ }
+ else if (memcmp(E2.xFetch_signature, xFetch_signatures[xFetch_memdbFetch_enum], sizeof(E2.xFetch_signature)) == 0) {
+ E1 = memdbFetch(args);
+ }
+ else if (memcmp(E2.xFetch_signature, xFetch_signatures[xFetch_pcache1Fetch_enum], sizeof(E2.xFetch_signature)) == 0) {
+ E1 = pcache1Fetch(args);
+ }
+ else if (memcmp(E2.xFetch_signature, xFetch_signatures[xFetch_pcachetraceFetch_enum], sizeof(E2.xFetch_signature)) == 0) {
+ E1 = pcachetraceFetch(args);
+ }
+ else if (memcmp(E2.xFetch_signature, xFetch_signatures[xFetch_recoverVfsFetch_enum], sizeof(E2.xFetch_signature)) == 0) {
+ E1 = recoverVfsFetch(args);
+ }


// FP: xFileControl

@transform_assign_xFileControl_dot@
expression E1, E2;
identifier FP_NAME = xFileControl;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xFileControl_signature, xFileControl_signatures[xFileControl_0_enum], sizeof(E2.xFileControl_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xFileControl_signature, xFileControl_signatures[xFileControl_apndFileControl_enum], sizeof(E2.xFileControl_signature)) == 0) {
+ E1 = apndFileControl(args);
+ }
+ else if (memcmp(E2.xFileControl_signature, xFileControl_signatures[xFileControl_memdbFileControl_enum], sizeof(E2.xFileControl_signature)) == 0) {
+ E1 = memdbFileControl(args);
+ }
+ else if (memcmp(E2.xFileControl_signature, xFileControl_signatures[xFileControl_recoverVfsFileControl_enum], sizeof(E2.xFileControl_signature)) == 0) {
+ E1 = recoverVfsFileControl(args);
+ }
+ else if (memcmp(E2.xFileControl_signature, xFileControl_signatures[xFileControl_vfstraceFileControl_enum], sizeof(E2.xFileControl_signature)) == 0) {
+ E1 = vfstraceFileControl(args);
+ }


// FP: xFileSize

@transform_assign_xFileSize_dot@
expression E1, E2;
identifier FP_NAME = xFileSize;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xFileSize_signature, xFileSize_signatures[xFileSize_apndFileSize_enum], sizeof(E2.xFileSize_signature)) == 0) {
+ E1 = apndFileSize(args);
+ }
+ else if (memcmp(E2.xFileSize_signature, xFileSize_signatures[xFileSize_memdbFileSize_enum], sizeof(E2.xFileSize_signature)) == 0) {
+ E1 = memdbFileSize(args);
+ }
+ else if (memcmp(E2.xFileSize_signature, xFileSize_signatures[xFileSize_memjrnlFileSize_enum], sizeof(E2.xFileSize_signature)) == 0) {
+ E1 = memjrnlFileSize(args);
+ }
+ else if (memcmp(E2.xFileSize_signature, xFileSize_signatures[xFileSize_recoverVfsFileSize_enum], sizeof(E2.xFileSize_signature)) == 0) {
+ E1 = recoverVfsFileSize(args);
+ }
+ else if (memcmp(E2.xFileSize_signature, xFileSize_signatures[xFileSize_vfstraceFileSize_enum], sizeof(E2.xFileSize_signature)) == 0) {
+ E1 = vfstraceFileSize(args);
+ }


// FP: xFilter

@transform_assign_xFilter_dot@
expression E1, E2;
identifier FP_NAME = xFilter;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xFilter_signature, xFilter_signatures[xFilter_bytecodevtabFilter_enum], sizeof(E2.xFilter_signature)) == 0) {
+ E1 = bytecodevtabFilter(args);
+ }
+ else if (memcmp(E2.xFilter_signature, xFilter_signatures[xFilter_completionFilter_enum], sizeof(E2.xFilter_signature)) == 0) {
+ E1 = completionFilter(args);
+ }
+ else if (memcmp(E2.xFilter_signature, xFilter_signatures[xFilter_dbdataFilter_enum], sizeof(E2.xFilter_signature)) == 0) {
+ E1 = dbdataFilter(args);
+ }
+ else if (memcmp(E2.xFilter_signature, xFilter_signatures[xFilter_dbpageFilter_enum], sizeof(E2.xFilter_signature)) == 0) {
+ E1 = dbpageFilter(args);
+ }
+ else if (memcmp(E2.xFilter_signature, xFilter_signatures[xFilter_expertFilter_enum], sizeof(E2.xFilter_signature)) == 0) {
+ E1 = expertFilter(args);
+ }
+ else if (memcmp(E2.xFilter_signature, xFilter_signatures[xFilter_fsdirFilter_enum], sizeof(E2.xFilter_signature)) == 0) {
+ E1 = fsdirFilter(args);
+ }
+ else if (memcmp(E2.xFilter_signature, xFilter_signatures[xFilter_fts3FilterMethod_enum], sizeof(E2.xFilter_signature)) == 0) {
+ E1 = fts3FilterMethod(args);
+ }
+ else if (memcmp(E2.xFilter_signature, xFilter_signatures[xFilter_fts3auxFilterMethod_enum], sizeof(E2.xFilter_signature)) == 0) {
+ E1 = fts3auxFilterMethod(args);
+ }
+ else if (memcmp(E2.xFilter_signature, xFilter_signatures[xFilter_fts3tokFilterMethod_enum], sizeof(E2.xFilter_signature)) == 0) {
+ E1 = fts3tokFilterMethod(args);
+ }
+ else if (memcmp(E2.xFilter_signature, xFilter_signatures[xFilter_geopolyFilter_enum], sizeof(E2.xFilter_signature)) == 0) {
+ E1 = geopolyFilter(args);
+ }
+ else if (memcmp(E2.xFilter_signature, xFilter_signatures[xFilter_jsonEachFilter_enum], sizeof(E2.xFilter_signature)) == 0) {
+ E1 = jsonEachFilter(args);
+ }
+ else if (memcmp(E2.xFilter_signature, xFilter_signatures[xFilter_pragmaVtabFilter_enum], sizeof(E2.xFilter_signature)) == 0) {
+ E1 = pragmaVtabFilter(args);
+ }
+ else if (memcmp(E2.xFilter_signature, xFilter_signatures[xFilter_rtreeFilter_enum], sizeof(E2.xFilter_signature)) == 0) {
+ E1 = rtreeFilter(args);
+ }
+ else if (memcmp(E2.xFilter_signature, xFilter_signatures[xFilter_seriesFilter_enum], sizeof(E2.xFilter_signature)) == 0) {
+ E1 = seriesFilter(args);
+ }
+ else if (memcmp(E2.xFilter_signature, xFilter_signatures[xFilter_statFilter_enum], sizeof(E2.xFilter_signature)) == 0) {
+ E1 = statFilter(args);
+ }
+ else if (memcmp(E2.xFilter_signature, xFilter_signatures[xFilter_stmtFilter_enum], sizeof(E2.xFilter_signature)) == 0) {
+ E1 = stmtFilter(args);
+ }
+ else if (memcmp(E2.xFilter_signature, xFilter_signatures[xFilter_zipfileFilter_enum], sizeof(E2.xFilter_signature)) == 0) {
+ E1 = zipfileFilter(args);
+ }


// FP: xFinalize

@transform_assign_xFinalize_dot@
expression E1, E2;
identifier FP_NAME = xFinalize;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xFinalize_signature, xFinalize_signatures[xFinalize_0_enum], sizeof(E2.xFinalize_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xFinalize_signature, xFinalize_signatures[xFinalize_decimalSumFinalize_enum], sizeof(E2.xFinalize_signature)) == 0) {
+ E1 = decimalSumFinalize(args);
+ }
+ else if (memcmp(E2.xFinalize_signature, xFinalize_signatures[xFinalize_dummyUDFvalue_enum], sizeof(E2.xFinalize_signature)) == 0) {
+ E1 = dummyUDFvalue(args);
+ }
+ else if (memcmp(E2.xFinalize_signature, xFinalize_signatures[xFinalize_percentFinal_enum], sizeof(E2.xFinalize_signature)) == 0) {
+ E1 = percentFinal(args);
+ }
+ else if (memcmp(E2.xFinalize_signature, xFinalize_signatures[xFinalize_sha3AggFinal_enum], sizeof(E2.xFinalize_signature)) == 0) {
+ E1 = sha3AggFinal(args);
+ }
+ else if (memcmp(E2.xFinalize_signature, xFinalize_signatures[xFinalize_zipfileFinal_enum], sizeof(E2.xFinalize_signature)) == 0) {
+ E1 = zipfileFinal(args);
+ }


// FP: xFindFunction

@transform_assign_xFindFunction_dot@
expression E1, E2;
identifier FP_NAME = xFindFunction;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xFindFunction_signature, xFindFunction_signatures[xFindFunction_0_enum], sizeof(E2.xFindFunction_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xFindFunction_signature, xFindFunction_signatures[xFindFunction_fts3FindFunctionMethod_enum], sizeof(E2.xFindFunction_signature)) == 0) {
+ E1 = fts3FindFunctionMethod(args);
+ }
+ else if (memcmp(E2.xFindFunction_signature, xFindFunction_signatures[xFindFunction_zipfileFindFunction_enum], sizeof(E2.xFindFunction_signature)) == 0) {
+ E1 = zipfileFindFunction(args);
+ }


// FP: xFree

@transform_assign_xFree_dot@
expression E1, E2;
identifier FP_NAME = xFree;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xFree_signature, xFree_signatures[xFree_memtraceFree_enum], sizeof(E2.xFree_signature)) == 0) {
+ E1 = memtraceFree(args);
+ }
+ else if (memcmp(E2.xFree_signature, xFree_signatures[xFree_sqlite3MemFree_enum], sizeof(E2.xFree_signature)) == 0) {
+ E1 = sqlite3MemFree(args);
+ }


// FP: xFreeSchema

@transform_assign_xFreeSchema_dot@
expression E1, E2;
identifier FP_NAME = xFreeSchema;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xFreeSchema_signature, xFreeSchema_signatures[xFreeSchema_0_enum], sizeof(E2.xFreeSchema_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xFreeSchema_signature, xFreeSchema_signatures[xFreeSchema_sqlite3RCStrUnref_enum], sizeof(E2.xFreeSchema_signature)) == 0) {
+ E1 = sqlite3RCStrUnref(args);
+ }
+ else if (memcmp(E2.xFreeSchema_signature, xFreeSchema_signatures[xFreeSchema_sqlite3SchemaClear_enum], sizeof(E2.xFreeSchema_signature)) == 0) {
+ E1 = sqlite3SchemaClear(args);
+ }


// FP: xFullPathname

@transform_assign_xFullPathname_dot@
expression E1, E2;
identifier FP_NAME = xFullPathname;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xFullPathname_signature, xFullPathname_signatures[xFullPathname_apndFullPathname_enum], sizeof(E2.xFullPathname_signature)) == 0) {
+ E1 = apndFullPathname(args);
+ }
+ else if (memcmp(E2.xFullPathname_signature, xFullPathname_signatures[xFullPathname_memdbFullPathname_enum], sizeof(E2.xFullPathname_signature)) == 0) {
+ E1 = memdbFullPathname(args);
+ }
+ else if (memcmp(E2.xFullPathname_signature, xFullPathname_signatures[xFullPathname_vfstraceFullPathname_enum], sizeof(E2.xFullPathname_signature)) == 0) {
+ E1 = vfstraceFullPathname(args);
+ }
+ else if (memcmp(E2.xFullPathname_signature, xFullPathname_signatures[xFullPathname_unixFullPathname_enum], sizeof(E2.xFullPathname_signature)) == 0) {
+ E1 = unixFullPathname(args);
+ }


// FP: xFunc

@transform_assign_xFunc_dot@
expression E1, E2;
identifier FP_NAME = xFunc;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xFunc_signature, xFunc_signatures[xFunc_0_enum], sizeof(E2.xFunc_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xFunc_signature, xFunc_signatures[xFunc_base64_enum], sizeof(E2.xFunc_signature)) == 0) {
+ E1 = base64(args);
+ }
+ else if (memcmp(E2.xFunc_signature, xFunc_signatures[xFunc_base85_enum], sizeof(E2.xFunc_signature)) == 0) {
+ E1 = base85(args);
+ }
+ else if (memcmp(E2.xFunc_signature, xFunc_signatures[xFunc_dummyUDF_enum], sizeof(E2.xFunc_signature)) == 0) {
+ E1 = dummyUDF(args);
+ }
+ else if (memcmp(E2.xFunc_signature, xFunc_signatures[xFunc_editFunc_enum], sizeof(E2.xFunc_signature)) == 0) {
+ E1 = editFunc(args);
+ }
+ else if (memcmp(E2.xFunc_signature, xFunc_signatures[xFunc_fts3AllocateMSI_enum], sizeof(E2.xFunc_signature)) == 0) {
+ E1 = fts3AllocateMSI(args);
+ }
+ else if (memcmp(E2.xFunc_signature, xFunc_signatures[xFunc_fts3ExprGlobalHitsCb_enum], sizeof(E2.xFunc_signature)) == 0) {
+ E1 = fts3ExprGlobalHitsCb(args);
+ }
+ else if (memcmp(E2.xFunc_signature, xFunc_signatures[xFunc_fts3ExprLoadDoclistsCb_enum], sizeof(E2.xFunc_signature)) == 0) {
+ E1 = fts3ExprLoadDoclistsCb(args);
+ }
+ else if (memcmp(E2.xFunc_signature, xFunc_signatures[xFunc_fts3ExprLocalHitsCb_enum], sizeof(E2.xFunc_signature)) == 0) {
+ E1 = fts3ExprLocalHitsCb(args);
+ }
+ else if (memcmp(E2.xFunc_signature, xFunc_signatures[xFunc_fts3ExprPhraseCountCb_enum], sizeof(E2.xFunc_signature)) == 0) {
+ E1 = fts3ExprPhraseCountCb(args);
+ }
+ else if (memcmp(E2.xFunc_signature, xFunc_signatures[xFunc_fts3ExprRestartIfCb_enum], sizeof(E2.xFunc_signature)) == 0) {
+ E1 = fts3ExprRestartIfCb(args);
+ }
+ else if (memcmp(E2.xFunc_signature, xFunc_signatures[xFunc_fts3ExprTermOffsetInit_enum], sizeof(E2.xFunc_signature)) == 0) {
+ E1 = fts3ExprTermOffsetInit(args);
+ }
+ else if (memcmp(E2.xFunc_signature, xFunc_signatures[xFunc_fts3ExprTest_enum], sizeof(E2.xFunc_signature)) == 0) {
+ E1 = fts3ExprTest(args);
+ }
+ else if (memcmp(E2.xFunc_signature, xFunc_signatures[xFunc_fts3ExprTestRebalance_enum], sizeof(E2.xFunc_signature)) == 0) {
+ E1 = fts3ExprTestRebalance(args);
+ }
+ else if (memcmp(E2.xFunc_signature, xFunc_signatures[xFunc_fts3MatchinfoLcsCb_enum], sizeof(E2.xFunc_signature)) == 0) {
+ E1 = fts3MatchinfoLcsCb(args);
+ }
+ else if (memcmp(E2.xFunc_signature, xFunc_signatures[xFunc_fts3SnippetFindPositions_enum], sizeof(E2.xFunc_signature)) == 0) {
+ E1 = fts3SnippetFindPositions(args);
+ }
+ else if (memcmp(E2.xFunc_signature, xFunc_signatures[xFunc_fts3TokenizerFunc_enum], sizeof(E2.xFunc_signature)) == 0) {
+ E1 = fts3TokenizerFunc(args);
+ }
+ else if (memcmp(E2.xFunc_signature, xFunc_signatures[xFunc_geomCallback_enum], sizeof(E2.xFunc_signature)) == 0) {
+ E1 = geomCallback(args);
+ }
+ else if (memcmp(E2.xFunc_signature, xFunc_signatures[xFunc_idxRemFunc_enum], sizeof(E2.xFunc_signature)) == 0) {
+ E1 = idxRemFunc(args);
+ }
+ else if (memcmp(E2.xFunc_signature, xFunc_signatures[xFunc_idxSampleFunc_enum], sizeof(E2.xFunc_signature)) == 0) {
+ E1 = idxSampleFunc(args);
+ }
+ else if (memcmp(E2.xFunc_signature, xFunc_signatures[xFunc_intTestFunc_enum], sizeof(E2.xFunc_signature)) == 0) {
+ E1 = intTestFunc(args);
+ }
+ else if (memcmp(E2.xFunc_signature, xFunc_signatures[xFunc_intckParseCreateIndexFunc_enum], sizeof(E2.xFunc_signature)) == 0) {
+ E1 = intckParseCreateIndexFunc(args);
+ }
+ else if (memcmp(E2.xFunc_signature, xFunc_signatures[xFunc_is_base85_enum], sizeof(E2.xFunc_signature)) == 0) {
+ E1 = is_base85(args);
+ }
+ else if (memcmp(E2.xFunc_signature, xFunc_signatures[xFunc_lsModeFunc_enum], sizeof(E2.xFunc_signature)) == 0) {
+ E1 = lsModeFunc(args);
+ }
+ else if (memcmp(E2.xFunc_signature, xFunc_signatures[xFunc_rbuFossilDeltaFunc_enum], sizeof(E2.xFunc_signature)) == 0) {
+ E1 = rbuFossilDeltaFunc(args);
+ }
+ else if (memcmp(E2.xFunc_signature, xFunc_signatures[xFunc_rbuIndexCntFunc_enum], sizeof(E2.xFunc_signature)) == 0) {
+ E1 = rbuIndexCntFunc(args);
+ }
+ else if (memcmp(E2.xFunc_signature, xFunc_signatures[xFunc_rbuTargetNameFunc_enum], sizeof(E2.xFunc_signature)) == 0) {
+ E1 = rbuTargetNameFunc(args);
+ }
+ else if (memcmp(E2.xFunc_signature, xFunc_signatures[xFunc_rbuTmpInsertFunc_enum], sizeof(E2.xFunc_signature)) == 0) {
+ E1 = rbuTmpInsertFunc(args);
+ }
+ else if (memcmp(E2.xFunc_signature, xFunc_signatures[xFunc_re_bytecode_func_enum], sizeof(E2.xFunc_signature)) == 0) {
+ E1 = re_bytecode_func(args);
+ }
+ else if (memcmp(E2.xFunc_signature, xFunc_signatures[xFunc_re_sql_func_enum], sizeof(E2.xFunc_signature)) == 0) {
+ E1 = re_sql_func(args);
+ }
+ else if (memcmp(E2.xFunc_signature, xFunc_signatures[xFunc_readfileFunc_enum], sizeof(E2.xFunc_signature)) == 0) {
+ E1 = readfileFunc(args);
+ }
+ else if (memcmp(E2.xFunc_signature, xFunc_signatures[xFunc_rtreecheck_enum], sizeof(E2.xFunc_signature)) == 0) {
+ E1 = rtreecheck(args);
+ }
+ else if (memcmp(E2.xFunc_signature, xFunc_signatures[xFunc_rtreedepth_enum], sizeof(E2.xFunc_signature)) == 0) {
+ E1 = rtreedepth(args);
+ }
+ else if (memcmp(E2.xFunc_signature, xFunc_signatures[xFunc_rtreenode_enum], sizeof(E2.xFunc_signature)) == 0) {
+ E1 = rtreenode(args);
+ }
+ else if (memcmp(E2.xFunc_signature, xFunc_signatures[xFunc_sha1Func_enum], sizeof(E2.xFunc_signature)) == 0) {
+ E1 = sha1Func(args);
+ }
+ else if (memcmp(E2.xFunc_signature, xFunc_signatures[xFunc_sha1QueryFunc_enum], sizeof(E2.xFunc_signature)) == 0) {
+ E1 = sha1QueryFunc(args);
+ }
+ else if (memcmp(E2.xFunc_signature, xFunc_signatures[xFunc_sha3Func_enum], sizeof(E2.xFunc_signature)) == 0) {
+ E1 = sha3Func(args);
+ }
+ else if (memcmp(E2.xFunc_signature, xFunc_signatures[xFunc_sha3QueryFunc_enum], sizeof(E2.xFunc_signature)) == 0) {
+ E1 = sha3QueryFunc(args);
+ }
+ else if (memcmp(E2.xFunc_signature, xFunc_signatures[xFunc_shellAddSchemaName_enum], sizeof(E2.xFunc_signature)) == 0) {
+ E1 = shellAddSchemaName(args);
+ }
+ else if (memcmp(E2.xFunc_signature, xFunc_signatures[xFunc_shellDtostr_enum], sizeof(E2.xFunc_signature)) == 0) {
+ E1 = shellDtostr(args);
+ }
+ else if (memcmp(E2.xFunc_signature, xFunc_signatures[xFunc_shellFkeyCollateClause_enum], sizeof(E2.xFunc_signature)) == 0) {
+ E1 = shellFkeyCollateClause(args);
+ }
+ else if (memcmp(E2.xFunc_signature, xFunc_signatures[xFunc_shellModuleSchema_enum], sizeof(E2.xFunc_signature)) == 0) {
+ E1 = shellModuleSchema(args);
+ }
+ else if (memcmp(E2.xFunc_signature, xFunc_signatures[xFunc_shellPutsFunc_enum], sizeof(E2.xFunc_signature)) == 0) {
+ E1 = shellPutsFunc(args);
+ }
+ else if (memcmp(E2.xFunc_signature, xFunc_signatures[xFunc_shellStrtod_enum], sizeof(E2.xFunc_signature)) == 0) {
+ E1 = shellStrtod(args);
+ }
+ else if (memcmp(E2.xFunc_signature, xFunc_signatures[xFunc_shellUSleepFunc_enum], sizeof(E2.xFunc_signature)) == 0) {
+ E1 = shellUSleepFunc(args);
+ }
+ else if (memcmp(E2.xFunc_signature, xFunc_signatures[xFunc_sqlarCompressFunc_enum], sizeof(E2.xFunc_signature)) == 0) {
+ E1 = sqlarCompressFunc(args);
+ }
+ else if (memcmp(E2.xFunc_signature, xFunc_signatures[xFunc_sqlarUncompressFunc_enum], sizeof(E2.xFunc_signature)) == 0) {
+ E1 = sqlarUncompressFunc(args);
+ }
+ else if (memcmp(E2.xFunc_signature, xFunc_signatures[xFunc_sqlite3InvalidFunction_enum], sizeof(E2.xFunc_signature)) == 0) {
+ E1 = sqlite3InvalidFunction(args);
+ }
+ else if (memcmp(E2.xFunc_signature, xFunc_signatures[xFunc_stmtrandFunc_enum], sizeof(E2.xFunc_signature)) == 0) {
+ E1 = stmtrandFunc(args);
+ }
+ else if (memcmp(E2.xFunc_signature, xFunc_signatures[xFunc_testFunc_enum], sizeof(E2.xFunc_signature)) == 0) {
+ E1 = testFunc(args);
+ }
+ else if (memcmp(E2.xFunc_signature, xFunc_signatures[xFunc_writefileFunc_enum], sizeof(E2.xFunc_signature)) == 0) {
+ E1 = writefileFunc(args);
+ }


// FP: xGeom

@transform_assign_xGeom_dot@
expression E1, E2;
identifier FP_NAME = xGeom;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = 0;


// FP: xGet

@transform_assign_xGet_dot@
expression E1, E2;
identifier FP_NAME = xGet;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xGet_signature, xGet_signatures[xGet_getPageError_enum], sizeof(E2.xGet_signature)) == 0) {
+ E1 = getPageError(args);
+ }
+ else if (memcmp(E2.xGet_signature, xGet_signatures[xGet_getPageMMap_enum], sizeof(E2.xGet_signature)) == 0) {
+ E1 = getPageMMap(args);
+ }
+ else if (memcmp(E2.xGet_signature, xGet_signatures[xGet_getPageNormal_enum], sizeof(E2.xGet_signature)) == 0) {
+ E1 = getPageNormal(args);
+ }


// FP: xGetLastError

@transform_assign_xGetLastError_dot@
expression E1, E2;
identifier FP_NAME = xGetLastError;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xGetLastError_signature, xGetLastError_signatures[xGetLastError_0_enum], sizeof(E2.xGetLastError_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xGetLastError_signature, xGetLastError_signatures[xGetLastError_apndGetLastError_enum], sizeof(E2.xGetLastError_signature)) == 0) {
+ E1 = apndGetLastError(args);
+ }
+ else if (memcmp(E2.xGetLastError_signature, xGetLastError_signatures[xGetLastError_memdbGetLastError_enum], sizeof(E2.xGetLastError_signature)) == 0) {
+ E1 = memdbGetLastError(args);
+ }
+ else if (memcmp(E2.xGetLastError_signature, xGetLastError_signatures[xGetLastError_unixGetLastError_enum], sizeof(E2.xGetLastError_signature)) == 0) {
+ E1 = unixGetLastError(args);
+ }


// FP: xGetSystemCall

@transform_assign_xGetSystemCall_dot@
expression E1, E2;
identifier FP_NAME = xGetSystemCall;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xGetSystemCall_signature, xGetSystemCall_signatures[xGetSystemCall_0_enum], sizeof(E2.xGetSystemCall_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xGetSystemCall_signature, xGetSystemCall_signatures[xGetSystemCall_apndGetSystemCall_enum], sizeof(E2.xGetSystemCall_signature)) == 0) {
+ E1 = apndGetSystemCall(args);
+ }
+ else if (memcmp(E2.xGetSystemCall_signature, xGetSystemCall_signatures[xGetSystemCall_unixGetSystemCall_enum], sizeof(E2.xGetSystemCall_signature)) == 0) {
+ E1 = unixGetSystemCall(args);
+ }


// FP: xInit

@transform_assign_xInit_dot@
expression E1, E2;
identifier FP_NAME = xInit;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xInit_signature, xInit_signatures[xInit_memtraceInit_enum], sizeof(E2.xInit_signature)) == 0) {
+ E1 = memtraceInit(args);
+ }
+ else if (memcmp(E2.xInit_signature, xInit_signatures[xInit_pcache1Init_enum], sizeof(E2.xInit_signature)) == 0) {
+ E1 = pcache1Init(args);
+ }
+ else if (memcmp(E2.xInit_signature, xInit_signatures[xInit_pcachetraceInit_enum], sizeof(E2.xInit_signature)) == 0) {
+ E1 = pcachetraceInit(args);
+ }
+ else if (memcmp(E2.xInit_signature, xInit_signatures[xInit_sqlite3MemInit_enum], sizeof(E2.xInit_signature)) == 0) {
+ E1 = sqlite3MemInit(args);
+ }


// FP: xInput

@transform_assign_xInput_dot@
expression E1, E2;
identifier FP_NAME = xInput;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = 0;


// FP: xIntegrity

@transform_assign_xIntegrity_dot@
expression E1, E2;
identifier FP_NAME = xIntegrity;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xIntegrity_signature, xIntegrity_signatures[xIntegrity_0_enum], sizeof(E2.xIntegrity_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xIntegrity_signature, xIntegrity_signatures[xIntegrity_fts3IntegrityMethod_enum], sizeof(E2.xIntegrity_signature)) == 0) {
+ E1 = fts3IntegrityMethod(args);
+ }
+ else if (memcmp(E2.xIntegrity_signature, xIntegrity_signatures[xIntegrity_rtreeIntegrity_enum], sizeof(E2.xIntegrity_signature)) == 0) {
+ E1 = rtreeIntegrity(args);
+ }


// FP: xInverse

@transform_assign_xInverse_dot@
expression E1, E2;
identifier FP_NAME = xInverse;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xInverse_signature, xInverse_signatures[xInverse_0_enum], sizeof(E2.xInverse_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xInverse_signature, xInverse_signatures[xInverse_decimalSumInverse_enum], sizeof(E2.xInverse_signature)) == 0) {
+ E1 = decimalSumInverse(args);
+ }
+ else if (memcmp(E2.xInverse_signature, xInverse_signatures[xInverse_percentInverse_enum], sizeof(E2.xInverse_signature)) == 0) {
+ E1 = percentInverse(args);
+ }


// FP: xLanguageid

@transform_assign_xLanguageid_dot@
expression E1, E2;
identifier FP_NAME = xLanguageid;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = 0;


// FP: xLock

@transform_assign_xLock_dot@
expression E1, E2;
identifier FP_NAME = xLock;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xLock_signature, xLock_signatures[xLock_0_enum], sizeof(E2.xLock_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xLock_signature, xLock_signatures[xLock_apndLock_enum], sizeof(E2.xLock_signature)) == 0) {
+ E1 = apndLock(args);
+ }
+ else if (memcmp(E2.xLock_signature, xLock_signatures[xLock_memdbLock_enum], sizeof(E2.xLock_signature)) == 0) {
+ E1 = memdbLock(args);
+ }
+ else if (memcmp(E2.xLock_signature, xLock_signatures[xLock_recoverVfsLock_enum], sizeof(E2.xLock_signature)) == 0) {
+ E1 = recoverVfsLock(args);
+ }
+ else if (memcmp(E2.xLock_signature, xLock_signatures[xLock_vfstraceLock_enum], sizeof(E2.xLock_signature)) == 0) {
+ E1 = vfstraceLock(args);
+ }


// FP: xLog

@transform_assign_xLog_dot@
expression E1, E2;
identifier FP_NAME = xLog;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = 0;


// FP: xMalloc

@transform_assign_xMalloc_dot@
expression E1, E2;
identifier FP_NAME = xMalloc;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xMalloc_signature, xMalloc_signatures[xMalloc_memtraceMalloc_enum], sizeof(E2.xMalloc_signature)) == 0) {
+ E1 = memtraceMalloc(args);
+ }
+ else if (memcmp(E2.xMalloc_signature, xMalloc_signatures[xMalloc_sqlite3MemMalloc_enum], sizeof(E2.xMalloc_signature)) == 0) {
+ E1 = sqlite3MemMalloc(args);
+ }


// FP: xMutexAlloc

@transform_assign_xMutexAlloc_dot@
expression E1, E2;
identifier FP_NAME = xMutexAlloc;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_checkMutexAlloc_enum], sizeof(E2.xMutexAlloc_signature)) == 0) {
+ E1 = checkMutexAlloc(args);
+ }
+ else if (memcmp(E2.xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_debugMutexAlloc_enum], sizeof(E2.xMutexAlloc_signature)) == 0) {
+ E1 = debugMutexAlloc(args);
+ }
+ else if (memcmp(E2.xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_noopMutexAlloc_enum], sizeof(E2.xMutexAlloc_signature)) == 0) {
+ E1 = noopMutexAlloc(args);
+ }
+ else if (memcmp(E2.xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_pthreadMutexAlloc_enum], sizeof(E2.xMutexAlloc_signature)) == 0) {
+ E1 = pthreadMutexAlloc(args);
+ }
+ else if (memcmp(E2.xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_winMutexAlloc_enum], sizeof(E2.xMutexAlloc_signature)) == 0) {
+ E1 = winMutexAlloc(args);
+ }


// FP: xMutexEnd

@transform_assign_xMutexEnd_dot@
expression E1, E2;
identifier FP_NAME = xMutexEnd;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_checkMutexEnd_enum], sizeof(E2.xMutexEnd_signature)) == 0) {
+ E1 = checkMutexEnd(args);
+ }
+ else if (memcmp(E2.xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_debugMutexEnd_enum], sizeof(E2.xMutexEnd_signature)) == 0) {
+ E1 = debugMutexEnd(args);
+ }
+ else if (memcmp(E2.xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_noopMutexEnd_enum], sizeof(E2.xMutexEnd_signature)) == 0) {
+ E1 = noopMutexEnd(args);
+ }
+ else if (memcmp(E2.xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_pthreadMutexEnd_enum], sizeof(E2.xMutexEnd_signature)) == 0) {
+ E1 = pthreadMutexEnd(args);
+ }
+ else if (memcmp(E2.xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_winMutexEnd_enum], sizeof(E2.xMutexEnd_signature)) == 0) {
+ E1 = winMutexEnd(args);
+ }


// FP: xMutexEnter

@transform_assign_xMutexEnter_dot@
expression E1, E2;
identifier FP_NAME = xMutexEnter;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_checkMutexEnter_enum], sizeof(E2.xMutexEnter_signature)) == 0) {
+ E1 = checkMutexEnter(args);
+ }
+ else if (memcmp(E2.xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_debugMutexEnter_enum], sizeof(E2.xMutexEnter_signature)) == 0) {
+ E1 = debugMutexEnter(args);
+ }
+ else if (memcmp(E2.xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_noopMutexEnter_enum], sizeof(E2.xMutexEnter_signature)) == 0) {
+ E1 = noopMutexEnter(args);
+ }
+ else if (memcmp(E2.xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_pthreadMutexEnter_enum], sizeof(E2.xMutexEnter_signature)) == 0) {
+ E1 = pthreadMutexEnter(args);
+ }
+ else if (memcmp(E2.xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_winMutexEnter_enum], sizeof(E2.xMutexEnter_signature)) == 0) {
+ E1 = winMutexEnter(args);
+ }


// FP: xMutexFree

@transform_assign_xMutexFree_dot@
expression E1, E2;
identifier FP_NAME = xMutexFree;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xMutexFree_signature, xMutexFree_signatures[xMutexFree_checkMutexFree_enum], sizeof(E2.xMutexFree_signature)) == 0) {
+ E1 = checkMutexFree(args);
+ }
+ else if (memcmp(E2.xMutexFree_signature, xMutexFree_signatures[xMutexFree_debugMutexFree_enum], sizeof(E2.xMutexFree_signature)) == 0) {
+ E1 = debugMutexFree(args);
+ }
+ else if (memcmp(E2.xMutexFree_signature, xMutexFree_signatures[xMutexFree_noopMutexFree_enum], sizeof(E2.xMutexFree_signature)) == 0) {
+ E1 = noopMutexFree(args);
+ }
+ else if (memcmp(E2.xMutexFree_signature, xMutexFree_signatures[xMutexFree_pthreadMutexFree_enum], sizeof(E2.xMutexFree_signature)) == 0) {
+ E1 = pthreadMutexFree(args);
+ }
+ else if (memcmp(E2.xMutexFree_signature, xMutexFree_signatures[xMutexFree_winMutexFree_enum], sizeof(E2.xMutexFree_signature)) == 0) {
+ E1 = winMutexFree(args);
+ }


// FP: xMutexHeld

@transform_assign_xMutexHeld_dot@
expression E1, E2;
identifier FP_NAME = xMutexHeld;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xMutexHeld_signature, xMutexHeld_signatures[xMutexHeld_0_enum], sizeof(E2.xMutexHeld_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xMutexHeld_signature, xMutexHeld_signatures[xMutexHeld_debugMutexHeld_enum], sizeof(E2.xMutexHeld_signature)) == 0) {
+ E1 = debugMutexHeld(args);
+ }


// FP: xMutexInit

@transform_assign_xMutexInit_dot@
expression E1, E2;
identifier FP_NAME = xMutexInit;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xMutexInit_signature, xMutexInit_signatures[xMutexInit_checkMutexInit_enum], sizeof(E2.xMutexInit_signature)) == 0) {
+ E1 = checkMutexInit(args);
+ }
+ else if (memcmp(E2.xMutexInit_signature, xMutexInit_signatures[xMutexInit_debugMutexInit_enum], sizeof(E2.xMutexInit_signature)) == 0) {
+ E1 = debugMutexInit(args);
+ }
+ else if (memcmp(E2.xMutexInit_signature, xMutexInit_signatures[xMutexInit_noopMutexInit_enum], sizeof(E2.xMutexInit_signature)) == 0) {
+ E1 = noopMutexInit(args);
+ }
+ else if (memcmp(E2.xMutexInit_signature, xMutexInit_signatures[xMutexInit_pthreadMutexInit_enum], sizeof(E2.xMutexInit_signature)) == 0) {
+ E1 = pthreadMutexInit(args);
+ }
+ else if (memcmp(E2.xMutexInit_signature, xMutexInit_signatures[xMutexInit_winMutexInit_enum], sizeof(E2.xMutexInit_signature)) == 0) {
+ E1 = winMutexInit(args);
+ }


// FP: xMutexLeave

@transform_assign_xMutexLeave_dot@
expression E1, E2;
identifier FP_NAME = xMutexLeave;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_checkMutexLeave_enum], sizeof(E2.xMutexLeave_signature)) == 0) {
+ E1 = checkMutexLeave(args);
+ }
+ else if (memcmp(E2.xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_debugMutexLeave_enum], sizeof(E2.xMutexLeave_signature)) == 0) {
+ E1 = debugMutexLeave(args);
+ }
+ else if (memcmp(E2.xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_noopMutexLeave_enum], sizeof(E2.xMutexLeave_signature)) == 0) {
+ E1 = noopMutexLeave(args);
+ }
+ else if (memcmp(E2.xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_pthreadMutexLeave_enum], sizeof(E2.xMutexLeave_signature)) == 0) {
+ E1 = pthreadMutexLeave(args);
+ }
+ else if (memcmp(E2.xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_winMutexLeave_enum], sizeof(E2.xMutexLeave_signature)) == 0) {
+ E1 = winMutexLeave(args);
+ }


// FP: xMutexNotheld

@transform_assign_xMutexNotheld_dot@
expression E1, E2;
identifier FP_NAME = xMutexNotheld;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xMutexNotheld_signature, xMutexNotheld_signatures[xMutexNotheld_0_enum], sizeof(E2.xMutexNotheld_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xMutexNotheld_signature, xMutexNotheld_signatures[xMutexNotheld_debugMutexNotheld_enum], sizeof(E2.xMutexNotheld_signature)) == 0) {
+ E1 = debugMutexNotheld(args);
+ }


// FP: xMutexTry

@transform_assign_xMutexTry_dot@
expression E1, E2;
identifier FP_NAME = xMutexTry;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xMutexTry_signature, xMutexTry_signatures[xMutexTry_checkMutexTry_enum], sizeof(E2.xMutexTry_signature)) == 0) {
+ E1 = checkMutexTry(args);
+ }
+ else if (memcmp(E2.xMutexTry_signature, xMutexTry_signatures[xMutexTry_debugMutexTry_enum], sizeof(E2.xMutexTry_signature)) == 0) {
+ E1 = debugMutexTry(args);
+ }
+ else if (memcmp(E2.xMutexTry_signature, xMutexTry_signatures[xMutexTry_noopMutexTry_enum], sizeof(E2.xMutexTry_signature)) == 0) {
+ E1 = noopMutexTry(args);
+ }
+ else if (memcmp(E2.xMutexTry_signature, xMutexTry_signatures[xMutexTry_pthreadMutexTry_enum], sizeof(E2.xMutexTry_signature)) == 0) {
+ E1 = pthreadMutexTry(args);
+ }
+ else if (memcmp(E2.xMutexTry_signature, xMutexTry_signatures[xMutexTry_winMutexTry_enum], sizeof(E2.xMutexTry_signature)) == 0) {
+ E1 = winMutexTry(args);
+ }


// FP: xNew

@transform_assign_xNew_dot@
expression E1, E2;
identifier FP_NAME = xNew;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xNew_signature, xNew_signatures[xNew_sessionDiffNew_enum], sizeof(E2.xNew_signature)) == 0) {
+ E1 = sessionDiffNew(args);
+ }
+ else if (memcmp(E2.xNew_signature, xNew_signatures[xNew_sessionPreupdateNew_enum], sizeof(E2.xNew_signature)) == 0) {
+ E1 = sessionPreupdateNew(args);
+ }
+ else if (memcmp(E2.xNew_signature, xNew_signatures[xNew_sessionStat1New_enum], sizeof(E2.xNew_signature)) == 0) {
+ E1 = sessionStat1New(args);
+ }


// FP: xNext

@transform_assign_xNext_dot@
expression E1, E2;
identifier FP_NAME = xNext;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xNext_signature, xNext_signatures[xNext_0_enum], sizeof(E2.xNext_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xNext_signature, xNext_signatures[xNext_bytecodevtabNext_enum], sizeof(E2.xNext_signature)) == 0) {
+ E1 = bytecodevtabNext(args);
+ }
+ else if (memcmp(E2.xNext_signature, xNext_signatures[xNext_completionNext_enum], sizeof(E2.xNext_signature)) == 0) {
+ E1 = completionNext(args);
+ }
+ else if (memcmp(E2.xNext_signature, xNext_signatures[xNext_dbdataNext_enum], sizeof(E2.xNext_signature)) == 0) {
+ E1 = dbdataNext(args);
+ }
+ else if (memcmp(E2.xNext_signature, xNext_signatures[xNext_dbpageNext_enum], sizeof(E2.xNext_signature)) == 0) {
+ E1 = dbpageNext(args);
+ }
+ else if (memcmp(E2.xNext_signature, xNext_signatures[xNext_expertNext_enum], sizeof(E2.xNext_signature)) == 0) {
+ E1 = expertNext(args);
+ }
+ else if (memcmp(E2.xNext_signature, xNext_signatures[xNext_fsdirNext_enum], sizeof(E2.xNext_signature)) == 0) {
+ E1 = fsdirNext(args);
+ }
+ else if (memcmp(E2.xNext_signature, xNext_signatures[xNext_fts3NextMethod_enum], sizeof(E2.xNext_signature)) == 0) {
+ E1 = fts3NextMethod(args);
+ }
+ else if (memcmp(E2.xNext_signature, xNext_signatures[xNext_fts3auxNextMethod_enum], sizeof(E2.xNext_signature)) == 0) {
+ E1 = fts3auxNextMethod(args);
+ }
+ else if (memcmp(E2.xNext_signature, xNext_signatures[xNext_fts3tokNextMethod_enum], sizeof(E2.xNext_signature)) == 0) {
+ E1 = fts3tokNextMethod(args);
+ }
+ else if (memcmp(E2.xNext_signature, xNext_signatures[xNext_jsonEachNext_enum], sizeof(E2.xNext_signature)) == 0) {
+ E1 = jsonEachNext(args);
+ }
+ else if (memcmp(E2.xNext_signature, xNext_signatures[xNext_porterNext_enum], sizeof(E2.xNext_signature)) == 0) {
+ E1 = porterNext(args);
+ }
+ else if (memcmp(E2.xNext_signature, xNext_signatures[xNext_pragmaVtabNext_enum], sizeof(E2.xNext_signature)) == 0) {
+ E1 = pragmaVtabNext(args);
+ }
+ else if (memcmp(E2.xNext_signature, xNext_signatures[xNext_rtreeNext_enum], sizeof(E2.xNext_signature)) == 0) {
+ E1 = rtreeNext(args);
+ }
+ else if (memcmp(E2.xNext_signature, xNext_signatures[xNext_seriesNext_enum], sizeof(E2.xNext_signature)) == 0) {
+ E1 = seriesNext(args);
+ }
+ else if (memcmp(E2.xNext_signature, xNext_signatures[xNext_simpleNext_enum], sizeof(E2.xNext_signature)) == 0) {
+ E1 = simpleNext(args);
+ }
+ else if (memcmp(E2.xNext_signature, xNext_signatures[xNext_statNext_enum], sizeof(E2.xNext_signature)) == 0) {
+ E1 = statNext(args);
+ }
+ else if (memcmp(E2.xNext_signature, xNext_signatures[xNext_stmtNext_enum], sizeof(E2.xNext_signature)) == 0) {
+ E1 = stmtNext(args);
+ }
+ else if (memcmp(E2.xNext_signature, xNext_signatures[xNext_unicodeNext_enum], sizeof(E2.xNext_signature)) == 0) {
+ E1 = unicodeNext(args);
+ }
+ else if (memcmp(E2.xNext_signature, xNext_signatures[xNext_zipfileNext_enum], sizeof(E2.xNext_signature)) == 0) {
+ E1 = zipfileNext(args);
+ }


// FP: xNextSystemCall

@transform_assign_xNextSystemCall_dot@
expression E1, E2;
identifier FP_NAME = xNextSystemCall;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xNextSystemCall_signature, xNextSystemCall_signatures[xNextSystemCall_0_enum], sizeof(E2.xNextSystemCall_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xNextSystemCall_signature, xNextSystemCall_signatures[xNextSystemCall_apndNextSystemCall_enum], sizeof(E2.xNextSystemCall_signature)) == 0) {
+ E1 = apndNextSystemCall(args);
+ }
+ else if (memcmp(E2.xNextSystemCall_signature, xNextSystemCall_signatures[xNextSystemCall_rbuVfsGetLastError_enum], sizeof(E2.xNextSystemCall_signature)) == 0) {
+ E1 = rbuVfsGetLastError(args);
+ }
+ else if (memcmp(E2.xNextSystemCall_signature, xNextSystemCall_signatures[xNextSystemCall_unixNextSystemCall_enum], sizeof(E2.xNextSystemCall_signature)) == 0) {
+ E1 = unixNextSystemCall(args);
+ }


// FP: xOld

@transform_assign_xOld_dot@
expression E1, E2;
identifier FP_NAME = xOld;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xOld_signature, xOld_signatures[xOld_sessionDiffOld_enum], sizeof(E2.xOld_signature)) == 0) {
+ E1 = sessionDiffOld(args);
+ }
+ else if (memcmp(E2.xOld_signature, xOld_signatures[xOld_sessionPreupdateOld_enum], sizeof(E2.xOld_signature)) == 0) {
+ E1 = sessionPreupdateOld(args);
+ }
+ else if (memcmp(E2.xOld_signature, xOld_signatures[xOld_sessionStat1Old_enum], sizeof(E2.xOld_signature)) == 0) {
+ E1 = sessionStat1Old(args);
+ }


// FP: xOpen

@transform_assign_xOpen_dot@
expression E1, E2;
identifier FP_NAME = xOpen;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_apndOpen_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = apndOpen(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_bytecodevtabOpen_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = bytecodevtabOpen(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_completionOpen_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = completionOpen(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_dbdataOpen_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = dbdataOpen(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_dbpageOpen_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = dbpageOpen(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_expertOpen_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = expertOpen(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_fsdirOpen_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = fsdirOpen(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_fts3OpenMethod_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = fts3OpenMethod(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_fts3auxOpenMethod_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = fts3auxOpenMethod(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_fts3tokOpenMethod_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = fts3tokOpenMethod(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_jsonEachOpen_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = jsonEachOpen(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_memdbOpen_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = memdbOpen(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_porterOpen_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = porterOpen(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_pragmaVtabOpen_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = pragmaVtabOpen(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_rtreeOpen_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = rtreeOpen(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_seriesOpen_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = seriesOpen(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_simpleOpen_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = simpleOpen(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_statOpen_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = statOpen(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_stmtOpen_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = stmtOpen(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_unicodeOpen_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = unicodeOpen(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_vfstraceOpen_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = vfstraceOpen(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_zipfileOpen_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = zipfileOpen(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_unixOpen_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = unixOpen(args);
+ }


// FP: xOut

@transform_assign_xOut_dot@
expression E1, E2;
identifier FP_NAME = xOut;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = vfstraceOut(args);


// FP: xPagecount

@transform_assign_xPagecount_dot@
expression E1, E2;
identifier FP_NAME = xPagecount;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xPagecount_signature, xPagecount_signatures[xPagecount_pcache1Pagecount_enum], sizeof(E2.xPagecount_signature)) == 0) {
+ E1 = pcache1Pagecount(args);
+ }
+ else if (memcmp(E2.xPagecount_signature, xPagecount_signatures[xPagecount_pcachetracePagecount_enum], sizeof(E2.xPagecount_signature)) == 0) {
+ E1 = pcachetracePagecount(args);
+ }


// FP: xParseCell

@transform_assign_xParseCell_dot@
expression E1, E2;
identifier FP_NAME = xParseCell;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xParseCell_signature, xParseCell_signatures[xParseCell_btreeParseCellPtr_enum], sizeof(E2.xParseCell_signature)) == 0) {
+ E1 = btreeParseCellPtr(args);
+ }
+ else if (memcmp(E2.xParseCell_signature, xParseCell_signatures[xParseCell_btreeParseCellPtrIndex_enum], sizeof(E2.xParseCell_signature)) == 0) {
+ E1 = btreeParseCellPtrIndex(args);
+ }
+ else if (memcmp(E2.xParseCell_signature, xParseCell_signatures[xParseCell_btreeParseCellPtrNoPayload_enum], sizeof(E2.xParseCell_signature)) == 0) {
+ E1 = btreeParseCellPtrNoPayload(args);
+ }


// FP: xPreUpdateCallback

@transform_assign_xPreUpdateCallback_dot@
expression E1, E2;
identifier FP_NAME = xPreUpdateCallback;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xPreUpdateCallback_signature, xPreUpdateCallback_signatures[xPreUpdateCallback_0_enum], sizeof(E2.xPreUpdateCallback_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xPreUpdateCallback_signature, xPreUpdateCallback_signatures[xPreUpdateCallback_sql_trace_callback_enum], sizeof(E2.xPreUpdateCallback_signature)) == 0) {
+ E1 = sql_trace_callback(args);
+ }
+ else if (memcmp(E2.xPreUpdateCallback_signature, xPreUpdateCallback_signatures[xPreUpdateCallback_sqlite3WalDefaultHook_enum], sizeof(E2.xPreUpdateCallback_signature)) == 0) {
+ E1 = sqlite3WalDefaultHook(args);
+ }


// FP: xQueryFunc

@transform_assign_xQueryFunc_dot@
expression E1, E2;
identifier FP_NAME = xQueryFunc;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = 0;


// FP: xRandomness

@transform_assign_xRandomness_dot@
expression E1, E2;
identifier FP_NAME = xRandomness;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xRandomness_signature, xRandomness_signatures[xRandomness_apndRandomness_enum], sizeof(E2.xRandomness_signature)) == 0) {
+ E1 = apndRandomness(args);
+ }
+ else if (memcmp(E2.xRandomness_signature, xRandomness_signatures[xRandomness_memdbRandomness_enum], sizeof(E2.xRandomness_signature)) == 0) {
+ E1 = memdbRandomness(args);
+ }
+ else if (memcmp(E2.xRandomness_signature, xRandomness_signatures[xRandomness_vfstraceRandomness_enum], sizeof(E2.xRandomness_signature)) == 0) {
+ E1 = vfstraceRandomness(args);
+ }
+ else if (memcmp(E2.xRandomness_signature, xRandomness_signatures[xRandomness_unixRandomness_enum], sizeof(E2.xRandomness_signature)) == 0) {
+ E1 = unixRandomness(args);
+ }


// FP: xRead

@transform_assign_xRead_dot@
expression E1, E2;
identifier FP_NAME = xRead;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xRead_signature, xRead_signatures[xRead_apndRead_enum], sizeof(E2.xRead_signature)) == 0) {
+ E1 = apndRead(args);
+ }
+ else if (memcmp(E2.xRead_signature, xRead_signatures[xRead_memdbRead_enum], sizeof(E2.xRead_signature)) == 0) {
+ E1 = memdbRead(args);
+ }
+ else if (memcmp(E2.xRead_signature, xRead_signatures[xRead_memjrnlRead_enum], sizeof(E2.xRead_signature)) == 0) {
+ E1 = memjrnlRead(args);
+ }
+ else if (memcmp(E2.xRead_signature, xRead_signatures[xRead_recoverVfsRead_enum], sizeof(E2.xRead_signature)) == 0) {
+ E1 = recoverVfsRead(args);
+ }
+ else if (memcmp(E2.xRead_signature, xRead_signatures[xRead_vfstraceRead_enum], sizeof(E2.xRead_signature)) == 0) {
+ E1 = vfstraceRead(args);
+ }


// FP: xRealloc

@transform_assign_xRealloc_dot@
expression E1, E2;
identifier FP_NAME = xRealloc;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xRealloc_signature, xRealloc_signatures[xRealloc_memtraceRealloc_enum], sizeof(E2.xRealloc_signature)) == 0) {
+ E1 = memtraceRealloc(args);
+ }
+ else if (memcmp(E2.xRealloc_signature, xRealloc_signatures[xRealloc_sqlite3MemRealloc_enum], sizeof(E2.xRealloc_signature)) == 0) {
+ E1 = sqlite3MemRealloc(args);
+ }


// FP: xRekey

@transform_assign_xRekey_dot@
expression E1, E2;
identifier FP_NAME = xRekey;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xRekey_signature, xRekey_signatures[xRekey_pcache1Rekey_enum], sizeof(E2.xRekey_signature)) == 0) {
+ E1 = pcache1Rekey(args);
+ }
+ else if (memcmp(E2.xRekey_signature, xRekey_signatures[xRekey_pcachetraceRekey_enum], sizeof(E2.xRekey_signature)) == 0) {
+ E1 = pcachetraceRekey(args);
+ }


// FP: xRelease

@transform_assign_xRelease_dot@
expression E1, E2;
identifier FP_NAME = xRelease;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xRelease_signature, xRelease_signatures[xRelease_0_enum], sizeof(E2.xRelease_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xRelease_signature, xRelease_signatures[xRelease_fts3ReleaseMethod_enum], sizeof(E2.xRelease_signature)) == 0) {
+ E1 = fts3ReleaseMethod(args);
+ }


// FP: xRename

@transform_assign_xRename_dot@
expression E1, E2;
identifier FP_NAME = xRename;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xRename_signature, xRename_signatures[xRename_0_enum], sizeof(E2.xRename_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xRename_signature, xRename_signatures[xRename_fts3RenameMethod_enum], sizeof(E2.xRename_signature)) == 0) {
+ E1 = fts3RenameMethod(args);
+ }
+ else if (memcmp(E2.xRename_signature, xRename_signatures[xRename_rtreeRename_enum], sizeof(E2.xRename_signature)) == 0) {
+ E1 = rtreeRename(args);
+ }
+ else if (memcmp(E2.xRename_signature, xRename_signatures[xRename_xRename_enum], sizeof(E2.xRename_signature)) == 0) {
+ E1 = xRename(args);
+ }


// FP: xRollback

@transform_assign_xRollback_dot@
expression E1, E2;
identifier FP_NAME = xRollback;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xRollback_signature, xRollback_signatures[xRollback_0_enum], sizeof(E2.xRollback_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xRollback_signature, xRollback_signatures[xRollback_fts3RollbackMethod_enum], sizeof(E2.xRollback_signature)) == 0) {
+ E1 = fts3RollbackMethod(args);
+ }
+ else if (memcmp(E2.xRollback_signature, xRollback_signatures[xRollback_rtreeEndTransaction_enum], sizeof(E2.xRollback_signature)) == 0) {
+ E1 = rtreeEndTransaction(args);
+ }
+ else if (memcmp(E2.xRollback_signature, xRollback_signatures[xRollback_rtreeRollback_enum], sizeof(E2.xRollback_signature)) == 0) {
+ E1 = rtreeRollback(args);
+ }
+ else if (memcmp(E2.xRollback_signature, xRollback_signatures[xRollback_zipfileRollback_enum], sizeof(E2.xRollback_signature)) == 0) {
+ E1 = zipfileRollback(args);
+ }


// FP: xRollbackCallback

@transform_assign_xRollbackCallback_dot@
expression E1, E2;
identifier FP_NAME = xRollbackCallback;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xRollbackCallback_signature, xRollbackCallback_signatures[xRollbackCallback_0_enum], sizeof(E2.xRollbackCallback_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xRollbackCallback_signature, xRollbackCallback_signatures[xRollbackCallback_sql_trace_callback_enum], sizeof(E2.xRollbackCallback_signature)) == 0) {
+ E1 = sql_trace_callback(args);
+ }
+ else if (memcmp(E2.xRollbackCallback_signature, xRollbackCallback_signatures[xRollbackCallback_sqlite3WalDefaultHook_enum], sizeof(E2.xRollbackCallback_signature)) == 0) {
+ E1 = sqlite3WalDefaultHook(args);
+ }


// FP: xRollbackTo

@transform_assign_xRollbackTo_dot@
expression E1, E2;
identifier FP_NAME = xRollbackTo;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xRollbackTo_signature, xRollbackTo_signatures[xRollbackTo_0_enum], sizeof(E2.xRollbackTo_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xRollbackTo_signature, xRollbackTo_signatures[xRollbackTo_dbpageRollbackTo_enum], sizeof(E2.xRollbackTo_signature)) == 0) {
+ E1 = dbpageRollbackTo(args);
+ }
+ else if (memcmp(E2.xRollbackTo_signature, xRollbackTo_signatures[xRollbackTo_fts3RollbackToMethod_enum], sizeof(E2.xRollbackTo_signature)) == 0) {
+ E1 = fts3RollbackToMethod(args);
+ }


// FP: xRoundup

@transform_assign_xRoundup_dot@
expression E1, E2;
identifier FP_NAME = xRoundup;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xRoundup_signature, xRoundup_signatures[xRoundup_memtraceRoundup_enum], sizeof(E2.xRoundup_signature)) == 0) {
+ E1 = memtraceRoundup(args);
+ }
+ else if (memcmp(E2.xRoundup_signature, xRoundup_signatures[xRoundup_sqlite3MemRoundup_enum], sizeof(E2.xRoundup_signature)) == 0) {
+ E1 = sqlite3MemRoundup(args);
+ }


// FP: xRowid

@transform_assign_xRowid_dot@
expression E1, E2;
identifier FP_NAME = xRowid;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xRowid_signature, xRowid_signatures[xRowid_0_enum], sizeof(E2.xRowid_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xRowid_signature, xRowid_signatures[xRowid_bytecodevtabRowid_enum], sizeof(E2.xRowid_signature)) == 0) {
+ E1 = bytecodevtabRowid(args);
+ }
+ else if (memcmp(E2.xRowid_signature, xRowid_signatures[xRowid_completionRowid_enum], sizeof(E2.xRowid_signature)) == 0) {
+ E1 = completionRowid(args);
+ }
+ else if (memcmp(E2.xRowid_signature, xRowid_signatures[xRowid_dbdataRowid_enum], sizeof(E2.xRowid_signature)) == 0) {
+ E1 = dbdataRowid(args);
+ }
+ else if (memcmp(E2.xRowid_signature, xRowid_signatures[xRowid_dbpageRowid_enum], sizeof(E2.xRowid_signature)) == 0) {
+ E1 = dbpageRowid(args);
+ }
+ else if (memcmp(E2.xRowid_signature, xRowid_signatures[xRowid_expertRowid_enum], sizeof(E2.xRowid_signature)) == 0) {
+ E1 = expertRowid(args);
+ }
+ else if (memcmp(E2.xRowid_signature, xRowid_signatures[xRowid_fsdirRowid_enum], sizeof(E2.xRowid_signature)) == 0) {
+ E1 = fsdirRowid(args);
+ }
+ else if (memcmp(E2.xRowid_signature, xRowid_signatures[xRowid_fts3RowidMethod_enum], sizeof(E2.xRowid_signature)) == 0) {
+ E1 = fts3RowidMethod(args);
+ }
+ else if (memcmp(E2.xRowid_signature, xRowid_signatures[xRowid_fts3auxRowidMethod_enum], sizeof(E2.xRowid_signature)) == 0) {
+ E1 = fts3auxRowidMethod(args);
+ }
+ else if (memcmp(E2.xRowid_signature, xRowid_signatures[xRowid_fts3tokRowidMethod_enum], sizeof(E2.xRowid_signature)) == 0) {
+ E1 = fts3tokRowidMethod(args);
+ }
+ else if (memcmp(E2.xRowid_signature, xRowid_signatures[xRowid_jsonEachRowid_enum], sizeof(E2.xRowid_signature)) == 0) {
+ E1 = jsonEachRowid(args);
+ }
+ else if (memcmp(E2.xRowid_signature, xRowid_signatures[xRowid_pragmaVtabRowid_enum], sizeof(E2.xRowid_signature)) == 0) {
+ E1 = pragmaVtabRowid(args);
+ }
+ else if (memcmp(E2.xRowid_signature, xRowid_signatures[xRowid_rtreeRowid_enum], sizeof(E2.xRowid_signature)) == 0) {
+ E1 = rtreeRowid(args);
+ }
+ else if (memcmp(E2.xRowid_signature, xRowid_signatures[xRowid_seriesRowid_enum], sizeof(E2.xRowid_signature)) == 0) {
+ E1 = seriesRowid(args);
+ }
+ else if (memcmp(E2.xRowid_signature, xRowid_signatures[xRowid_statRowid_enum], sizeof(E2.xRowid_signature)) == 0) {
+ E1 = statRowid(args);
+ }
+ else if (memcmp(E2.xRowid_signature, xRowid_signatures[xRowid_stmtRowid_enum], sizeof(E2.xRowid_signature)) == 0) {
+ E1 = stmtRowid(args);
+ }


// FP: xSFunc

@transform_assign_xSFunc_dot@
expression E1, E2;
identifier FP_NAME = xSFunc;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xSFunc_signature, xSFunc_signatures[xSFunc_0_enum], sizeof(E2.xSFunc_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xSFunc_signature, xSFunc_signatures[xSFunc_attachFunc_enum], sizeof(E2.xSFunc_signature)) == 0) {
+ E1 = attachFunc(args);
+ }
+ else if (memcmp(E2.xSFunc_signature, xSFunc_signatures[xSFunc_base64_enum], sizeof(E2.xSFunc_signature)) == 0) {
+ E1 = base64(args);
+ }
+ else if (memcmp(E2.xSFunc_signature, xSFunc_signatures[xSFunc_base85_enum], sizeof(E2.xSFunc_signature)) == 0) {
+ E1 = base85(args);
+ }
+ else if (memcmp(E2.xSFunc_signature, xSFunc_signatures[xSFunc_detachFunc_enum], sizeof(E2.xSFunc_signature)) == 0) {
+ E1 = detachFunc(args);
+ }
+ else if (memcmp(E2.xSFunc_signature, xSFunc_signatures[xSFunc_dummyUDF_enum], sizeof(E2.xSFunc_signature)) == 0) {
+ E1 = dummyUDF(args);
+ }
+ else if (memcmp(E2.xSFunc_signature, xSFunc_signatures[xSFunc_editFunc_enum], sizeof(E2.xSFunc_signature)) == 0) {
+ E1 = editFunc(args);
+ }
+ else if (memcmp(E2.xSFunc_signature, xSFunc_signatures[xSFunc_fts3AllocateMSI_enum], sizeof(E2.xSFunc_signature)) == 0) {
+ E1 = fts3AllocateMSI(args);
+ }
+ else if (memcmp(E2.xSFunc_signature, xSFunc_signatures[xSFunc_fts3ExprGlobalHitsCb_enum], sizeof(E2.xSFunc_signature)) == 0) {
+ E1 = fts3ExprGlobalHitsCb(args);
+ }
+ else if (memcmp(E2.xSFunc_signature, xSFunc_signatures[xSFunc_fts3ExprLoadDoclistsCb_enum], sizeof(E2.xSFunc_signature)) == 0) {
+ E1 = fts3ExprLoadDoclistsCb(args);
+ }
+ else if (memcmp(E2.xSFunc_signature, xSFunc_signatures[xSFunc_fts3ExprLocalHitsCb_enum], sizeof(E2.xSFunc_signature)) == 0) {
+ E1 = fts3ExprLocalHitsCb(args);
+ }
+ else if (memcmp(E2.xSFunc_signature, xSFunc_signatures[xSFunc_fts3ExprPhraseCountCb_enum], sizeof(E2.xSFunc_signature)) == 0) {
+ E1 = fts3ExprPhraseCountCb(args);
+ }
+ else if (memcmp(E2.xSFunc_signature, xSFunc_signatures[xSFunc_fts3ExprRestartIfCb_enum], sizeof(E2.xSFunc_signature)) == 0) {
+ E1 = fts3ExprRestartIfCb(args);
+ }
+ else if (memcmp(E2.xSFunc_signature, xSFunc_signatures[xSFunc_fts3ExprTermOffsetInit_enum], sizeof(E2.xSFunc_signature)) == 0) {
+ E1 = fts3ExprTermOffsetInit(args);
+ }
+ else if (memcmp(E2.xSFunc_signature, xSFunc_signatures[xSFunc_fts3ExprTest_enum], sizeof(E2.xSFunc_signature)) == 0) {
+ E1 = fts3ExprTest(args);
+ }
+ else if (memcmp(E2.xSFunc_signature, xSFunc_signatures[xSFunc_fts3ExprTestRebalance_enum], sizeof(E2.xSFunc_signature)) == 0) {
+ E1 = fts3ExprTestRebalance(args);
+ }
+ else if (memcmp(E2.xSFunc_signature, xSFunc_signatures[xSFunc_fts3MatchinfoLcsCb_enum], sizeof(E2.xSFunc_signature)) == 0) {
+ E1 = fts3MatchinfoLcsCb(args);
+ }
+ else if (memcmp(E2.xSFunc_signature, xSFunc_signatures[xSFunc_fts3SnippetFindPositions_enum], sizeof(E2.xSFunc_signature)) == 0) {
+ E1 = fts3SnippetFindPositions(args);
+ }
+ else if (memcmp(E2.xSFunc_signature, xSFunc_signatures[xSFunc_fts3TokenizerFunc_enum], sizeof(E2.xSFunc_signature)) == 0) {
+ E1 = fts3TokenizerFunc(args);
+ }
+ else if (memcmp(E2.xSFunc_signature, xSFunc_signatures[xSFunc_geomCallback_enum], sizeof(E2.xSFunc_signature)) == 0) {
+ E1 = geomCallback(args);
+ }
+ else if (memcmp(E2.xSFunc_signature, xSFunc_signatures[xSFunc_idxRemFunc_enum], sizeof(E2.xSFunc_signature)) == 0) {
+ E1 = idxRemFunc(args);
+ }
+ else if (memcmp(E2.xSFunc_signature, xSFunc_signatures[xSFunc_idxSampleFunc_enum], sizeof(E2.xSFunc_signature)) == 0) {
+ E1 = idxSampleFunc(args);
+ }
+ else if (memcmp(E2.xSFunc_signature, xSFunc_signatures[xSFunc_intTestFunc_enum], sizeof(E2.xSFunc_signature)) == 0) {
+ E1 = intTestFunc(args);
+ }
+ else if (memcmp(E2.xSFunc_signature, xSFunc_signatures[xSFunc_intckParseCreateIndexFunc_enum], sizeof(E2.xSFunc_signature)) == 0) {
+ E1 = intckParseCreateIndexFunc(args);
+ }
+ else if (memcmp(E2.xSFunc_signature, xSFunc_signatures[xSFunc_is_base85_enum], sizeof(E2.xSFunc_signature)) == 0) {
+ E1 = is_base85(args);
+ }
+ else if (memcmp(E2.xSFunc_signature, xSFunc_signatures[xSFunc_likeFunc_enum], sizeof(E2.xSFunc_signature)) == 0) {
+ E1 = likeFunc(args);
+ }
+ else if (memcmp(E2.xSFunc_signature, xSFunc_signatures[xSFunc_lsModeFunc_enum], sizeof(E2.xSFunc_signature)) == 0) {
+ E1 = lsModeFunc(args);
+ }
+ else if (memcmp(E2.xSFunc_signature, xSFunc_signatures[xSFunc_rbuFossilDeltaFunc_enum], sizeof(E2.xSFunc_signature)) == 0) {
+ E1 = rbuFossilDeltaFunc(args);
+ }
+ else if (memcmp(E2.xSFunc_signature, xSFunc_signatures[xSFunc_rbuIndexCntFunc_enum], sizeof(E2.xSFunc_signature)) == 0) {
+ E1 = rbuIndexCntFunc(args);
+ }
+ else if (memcmp(E2.xSFunc_signature, xSFunc_signatures[xSFunc_rbuTargetNameFunc_enum], sizeof(E2.xSFunc_signature)) == 0) {
+ E1 = rbuTargetNameFunc(args);
+ }
+ else if (memcmp(E2.xSFunc_signature, xSFunc_signatures[xSFunc_rbuTmpInsertFunc_enum], sizeof(E2.xSFunc_signature)) == 0) {
+ E1 = rbuTmpInsertFunc(args);
+ }
+ else if (memcmp(E2.xSFunc_signature, xSFunc_signatures[xSFunc_re_bytecode_func_enum], sizeof(E2.xSFunc_signature)) == 0) {
+ E1 = re_bytecode_func(args);
+ }
+ else if (memcmp(E2.xSFunc_signature, xSFunc_signatures[xSFunc_re_sql_func_enum], sizeof(E2.xSFunc_signature)) == 0) {
+ E1 = re_sql_func(args);
+ }
+ else if (memcmp(E2.xSFunc_signature, xSFunc_signatures[xSFunc_readfileFunc_enum], sizeof(E2.xSFunc_signature)) == 0) {
+ E1 = readfileFunc(args);
+ }
+ else if (memcmp(E2.xSFunc_signature, xSFunc_signatures[xSFunc_rtreecheck_enum], sizeof(E2.xSFunc_signature)) == 0) {
+ E1 = rtreecheck(args);
+ }
+ else if (memcmp(E2.xSFunc_signature, xSFunc_signatures[xSFunc_rtreedepth_enum], sizeof(E2.xSFunc_signature)) == 0) {
+ E1 = rtreedepth(args);
+ }
+ else if (memcmp(E2.xSFunc_signature, xSFunc_signatures[xSFunc_rtreenode_enum], sizeof(E2.xSFunc_signature)) == 0) {
+ E1 = rtreenode(args);
+ }
+ else if (memcmp(E2.xSFunc_signature, xSFunc_signatures[xSFunc_sha1Func_enum], sizeof(E2.xSFunc_signature)) == 0) {
+ E1 = sha1Func(args);
+ }
+ else if (memcmp(E2.xSFunc_signature, xSFunc_signatures[xSFunc_sha1QueryFunc_enum], sizeof(E2.xSFunc_signature)) == 0) {
+ E1 = sha1QueryFunc(args);
+ }
+ else if (memcmp(E2.xSFunc_signature, xSFunc_signatures[xSFunc_sha3Func_enum], sizeof(E2.xSFunc_signature)) == 0) {
+ E1 = sha3Func(args);
+ }
+ else if (memcmp(E2.xSFunc_signature, xSFunc_signatures[xSFunc_sha3QueryFunc_enum], sizeof(E2.xSFunc_signature)) == 0) {
+ E1 = sha3QueryFunc(args);
+ }
+ else if (memcmp(E2.xSFunc_signature, xSFunc_signatures[xSFunc_shellAddSchemaName_enum], sizeof(E2.xSFunc_signature)) == 0) {
+ E1 = shellAddSchemaName(args);
+ }
+ else if (memcmp(E2.xSFunc_signature, xSFunc_signatures[xSFunc_shellDtostr_enum], sizeof(E2.xSFunc_signature)) == 0) {
+ E1 = shellDtostr(args);
+ }
+ else if (memcmp(E2.xSFunc_signature, xSFunc_signatures[xSFunc_shellFkeyCollateClause_enum], sizeof(E2.xSFunc_signature)) == 0) {
+ E1 = shellFkeyCollateClause(args);
+ }
+ else if (memcmp(E2.xSFunc_signature, xSFunc_signatures[xSFunc_shellModuleSchema_enum], sizeof(E2.xSFunc_signature)) == 0) {
+ E1 = shellModuleSchema(args);
+ }
+ else if (memcmp(E2.xSFunc_signature, xSFunc_signatures[xSFunc_shellPutsFunc_enum], sizeof(E2.xSFunc_signature)) == 0) {
+ E1 = shellPutsFunc(args);
+ }
+ else if (memcmp(E2.xSFunc_signature, xSFunc_signatures[xSFunc_shellStrtod_enum], sizeof(E2.xSFunc_signature)) == 0) {
+ E1 = shellStrtod(args);
+ }
+ else if (memcmp(E2.xSFunc_signature, xSFunc_signatures[xSFunc_shellUSleepFunc_enum], sizeof(E2.xSFunc_signature)) == 0) {
+ E1 = shellUSleepFunc(args);
+ }
+ else if (memcmp(E2.xSFunc_signature, xSFunc_signatures[xSFunc_sqlarCompressFunc_enum], sizeof(E2.xSFunc_signature)) == 0) {
+ E1 = sqlarCompressFunc(args);
+ }
+ else if (memcmp(E2.xSFunc_signature, xSFunc_signatures[xSFunc_sqlarUncompressFunc_enum], sizeof(E2.xSFunc_signature)) == 0) {
+ E1 = sqlarUncompressFunc(args);
+ }
+ else if (memcmp(E2.xSFunc_signature, xSFunc_signatures[xSFunc_sqlite3InvalidFunction_enum], sizeof(E2.xSFunc_signature)) == 0) {
+ E1 = sqlite3InvalidFunction(args);
+ }
+ else if (memcmp(E2.xSFunc_signature, xSFunc_signatures[xSFunc_statGet_enum], sizeof(E2.xSFunc_signature)) == 0) {
+ E1 = statGet(args);
+ }
+ else if (memcmp(E2.xSFunc_signature, xSFunc_signatures[xSFunc_statInit_enum], sizeof(E2.xSFunc_signature)) == 0) {
+ E1 = statInit(args);
+ }
+ else if (memcmp(E2.xSFunc_signature, xSFunc_signatures[xSFunc_statPush_enum], sizeof(E2.xSFunc_signature)) == 0) {
+ E1 = statPush(args);
+ }
+ else if (memcmp(E2.xSFunc_signature, xSFunc_signatures[xSFunc_stmtrandFunc_enum], sizeof(E2.xSFunc_signature)) == 0) {
+ E1 = stmtrandFunc(args);
+ }
+ else if (memcmp(E2.xSFunc_signature, xSFunc_signatures[xSFunc_testFunc_enum], sizeof(E2.xSFunc_signature)) == 0) {
+ E1 = testFunc(args);
+ }
+ else if (memcmp(E2.xSFunc_signature, xSFunc_signatures[xSFunc_writefileFunc_enum], sizeof(E2.xSFunc_signature)) == 0) {
+ E1 = writefileFunc(args);
+ }


// FP: xSavepoint

@transform_assign_xSavepoint_dot@
expression E1, E2;
identifier FP_NAME = xSavepoint;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xSavepoint_signature, xSavepoint_signatures[xSavepoint_0_enum], sizeof(E2.xSavepoint_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xSavepoint_signature, xSavepoint_signatures[xSavepoint_fts3SavepointMethod_enum], sizeof(E2.xSavepoint_signature)) == 0) {
+ E1 = fts3SavepointMethod(args);
+ }
+ else if (memcmp(E2.xSavepoint_signature, xSavepoint_signatures[xSavepoint_rtreeSavepoint_enum], sizeof(E2.xSavepoint_signature)) == 0) {
+ E1 = rtreeSavepoint(args);
+ }


// FP: xSectorSize

@transform_assign_xSectorSize_dot@
expression E1, E2;
identifier FP_NAME = xSectorSize;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xSectorSize_signature, xSectorSize_signatures[xSectorSize_0_enum], sizeof(E2.xSectorSize_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xSectorSize_signature, xSectorSize_signatures[xSectorSize_apndSectorSize_enum], sizeof(E2.xSectorSize_signature)) == 0) {
+ E1 = apndSectorSize(args);
+ }
+ else if (memcmp(E2.xSectorSize_signature, xSectorSize_signatures[xSectorSize_recoverVfsSectorSize_enum], sizeof(E2.xSectorSize_signature)) == 0) {
+ E1 = recoverVfsSectorSize(args);
+ }
+ else if (memcmp(E2.xSectorSize_signature, xSectorSize_signatures[xSectorSize_vfstraceSectorSize_enum], sizeof(E2.xSectorSize_signature)) == 0) {
+ E1 = vfstraceSectorSize(args);
+ }


// FP: xSelectCallback

@transform_assign_xSelectCallback_dot@
expression E1, E2;
identifier FP_NAME = xSelectCallback;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_0_enum], sizeof(E2.xSelectCallback_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_convertCompoundSelectToSubquery_enum], sizeof(E2.xSelectCallback_signature)) == 0) {
+ E1 = convertCompoundSelectToSubquery(args);
+ }
+ else if (memcmp(E2.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_exprSelectWalkTableConstant_enum], sizeof(E2.xSelectCallback_signature)) == 0) {
+ E1 = exprSelectWalkTableConstant(args);
+ }
+ else if (memcmp(E2.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_fixSelectCb_enum], sizeof(E2.xSelectCallback_signature)) == 0) {
+ E1 = fixSelectCb(args);
+ }
+ else if (memcmp(E2.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_gatherSelectWindowsSelectCallback_enum], sizeof(E2.xSelectCallback_signature)) == 0) {
+ E1 = gatherSelectWindowsSelectCallback(args);
+ }
+ else if (memcmp(E2.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_renameColumnSelectCb_enum], sizeof(E2.xSelectCallback_signature)) == 0) {
+ E1 = renameColumnSelectCb(args);
+ }
+ else if (memcmp(E2.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_renameTableSelectCb_enum], sizeof(E2.xSelectCallback_signature)) == 0) {
+ E1 = renameTableSelectCb(args);
+ }
+ else if (memcmp(E2.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_renameUnmapSelectCb_enum], sizeof(E2.xSelectCallback_signature)) == 0) {
+ E1 = renameUnmapSelectCb(args);
+ }
+ else if (memcmp(E2.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_resolveSelectStep_enum], sizeof(E2.xSelectCallback_signature)) == 0) {
+ E1 = resolveSelectStep(args);
+ }
+ else if (memcmp(E2.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_selectCheckOnClausesSelect_enum], sizeof(E2.xSelectCallback_signature)) == 0) {
+ E1 = selectCheckOnClausesSelect(args);
+ }
+ else if (memcmp(E2.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_selectExpander_enum], sizeof(E2.xSelectCallback_signature)) == 0) {
+ E1 = selectExpander(args);
+ }
+ else if (memcmp(E2.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_selectRefEnter_enum], sizeof(E2.xSelectCallback_signature)) == 0) {
+ E1 = selectRefEnter(args);
+ }
+ else if (memcmp(E2.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_selectWindowRewriteSelectCb_enum], sizeof(E2.xSelectCallback_signature)) == 0) {
+ E1 = selectWindowRewriteSelectCb(args);
+ }
+ else if (memcmp(E2.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_sqlite3ReturningSubqueryCorrelated_enum], sizeof(E2.xSelectCallback_signature)) == 0) {
+ E1 = sqlite3ReturningSubqueryCorrelated(args);
+ }
+ else if (memcmp(E2.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_sqlite3SelectWalkFail_enum], sizeof(E2.xSelectCallback_signature)) == 0) {
+ E1 = sqlite3SelectWalkFail(args);
+ }
+ else if (memcmp(E2.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_sqlite3SelectWalkNoop_enum], sizeof(E2.xSelectCallback_signature)) == 0) {
+ E1 = sqlite3SelectWalkNoop(args);
+ }
+ else if (memcmp(E2.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_sqlite3WalkerDepthIncrease_enum], sizeof(E2.xSelectCallback_signature)) == 0) {
+ E1 = sqlite3WalkerDepthIncrease(args);
+ }


// FP: xSelectCallback2

@transform_assign_xSelectCallback2_dot@
expression E1, E2;
identifier FP_NAME = xSelectCallback2;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_0_enum], sizeof(E2.xSelectCallback2_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_selectAddSubqueryTypeInfo_enum], sizeof(E2.xSelectCallback2_signature)) == 0) {
+ E1 = selectAddSubqueryTypeInfo(args);
+ }
+ else if (memcmp(E2.xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_selectRefLeave_enum], sizeof(E2.xSelectCallback2_signature)) == 0) {
+ E1 = selectRefLeave(args);
+ }
+ else if (memcmp(E2.xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_sqlite3SelectPopWith_enum], sizeof(E2.xSelectCallback2_signature)) == 0) {
+ E1 = sqlite3SelectPopWith(args);
+ }
+ else if (memcmp(E2.xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_sqlite3WalkWinDefnDummyCallback_enum], sizeof(E2.xSelectCallback2_signature)) == 0) {
+ E1 = sqlite3WalkWinDefnDummyCallback(args);
+ }
+ else if (memcmp(E2.xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_sqlite3WalkerDepthDecrease_enum], sizeof(E2.xSelectCallback2_signature)) == 0) {
+ E1 = sqlite3WalkerDepthDecrease(args);
+ }


// FP: xSetSystemCall

@transform_assign_xSetSystemCall_dot@
expression E1, E2;
identifier FP_NAME = xSetSystemCall;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xSetSystemCall_signature, xSetSystemCall_signatures[xSetSystemCall_0_enum], sizeof(E2.xSetSystemCall_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xSetSystemCall_signature, xSetSystemCall_signatures[xSetSystemCall_apndSetSystemCall_enum], sizeof(E2.xSetSystemCall_signature)) == 0) {
+ E1 = apndSetSystemCall(args);
+ }
+ else if (memcmp(E2.xSetSystemCall_signature, xSetSystemCall_signatures[xSetSystemCall_rbuVfsSleep_enum], sizeof(E2.xSetSystemCall_signature)) == 0) {
+ E1 = rbuVfsSleep(args);
+ }
+ else if (memcmp(E2.xSetSystemCall_signature, xSetSystemCall_signatures[xSetSystemCall_unixSetSystemCall_enum], sizeof(E2.xSetSystemCall_signature)) == 0) {
+ E1 = unixSetSystemCall(args);
+ }


// FP: xShadowName

@transform_assign_xShadowName_dot@
expression E1, E2;
identifier FP_NAME = xShadowName;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xShadowName_signature, xShadowName_signatures[xShadowName_0_enum], sizeof(E2.xShadowName_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xShadowName_signature, xShadowName_signatures[xShadowName_fts3ShadowName_enum], sizeof(E2.xShadowName_signature)) == 0) {
+ E1 = fts3ShadowName(args);
+ }
+ else if (memcmp(E2.xShadowName_signature, xShadowName_signatures[xShadowName_rtreeShadowName_enum], sizeof(E2.xShadowName_signature)) == 0) {
+ E1 = rtreeShadowName(args);
+ }


// FP: xShmBarrier

@transform_assign_xShmBarrier_dot@
expression E1, E2;
identifier FP_NAME = xShmBarrier;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xShmBarrier_signature, xShmBarrier_signatures[xShmBarrier_0_enum], sizeof(E2.xShmBarrier_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xShmBarrier_signature, xShmBarrier_signatures[xShmBarrier_apndShmBarrier_enum], sizeof(E2.xShmBarrier_signature)) == 0) {
+ E1 = apndShmBarrier(args);
+ }
+ else if (memcmp(E2.xShmBarrier_signature, xShmBarrier_signatures[xShmBarrier_recoverVfsShmBarrier_enum], sizeof(E2.xShmBarrier_signature)) == 0) {
+ E1 = recoverVfsShmBarrier(args);
+ }


// FP: xShmLock

@transform_assign_xShmLock_dot@
expression E1, E2;
identifier FP_NAME = xShmLock;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xShmLock_signature, xShmLock_signatures[xShmLock_0_enum], sizeof(E2.xShmLock_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xShmLock_signature, xShmLock_signatures[xShmLock_apndShmLock_enum], sizeof(E2.xShmLock_signature)) == 0) {
+ E1 = apndShmLock(args);
+ }
+ else if (memcmp(E2.xShmLock_signature, xShmLock_signatures[xShmLock_recoverVfsShmLock_enum], sizeof(E2.xShmLock_signature)) == 0) {
+ E1 = recoverVfsShmLock(args);
+ }


// FP: xShmMap

@transform_assign_xShmMap_dot@
expression E1, E2;
identifier FP_NAME = xShmMap;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xShmMap_signature, xShmMap_signatures[xShmMap_0_enum], sizeof(E2.xShmMap_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xShmMap_signature, xShmMap_signatures[xShmMap_apndShmMap_enum], sizeof(E2.xShmMap_signature)) == 0) {
+ E1 = apndShmMap(args);
+ }
+ else if (memcmp(E2.xShmMap_signature, xShmMap_signatures[xShmMap_recoverVfsShmMap_enum], sizeof(E2.xShmMap_signature)) == 0) {
+ E1 = recoverVfsShmMap(args);
+ }


// FP: xShmUnmap

@transform_assign_xShmUnmap_dot@
expression E1, E2;
identifier FP_NAME = xShmUnmap;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xShmUnmap_signature, xShmUnmap_signatures[xShmUnmap_0_enum], sizeof(E2.xShmUnmap_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xShmUnmap_signature, xShmUnmap_signatures[xShmUnmap_apndShmUnmap_enum], sizeof(E2.xShmUnmap_signature)) == 0) {
+ E1 = apndShmUnmap(args);
+ }
+ else if (memcmp(E2.xShmUnmap_signature, xShmUnmap_signatures[xShmUnmap_recoverVfsShmUnmap_enum], sizeof(E2.xShmUnmap_signature)) == 0) {
+ E1 = recoverVfsShmUnmap(args);
+ }


// FP: xShrink

@transform_assign_xShrink_dot@
expression E1, E2;
identifier FP_NAME = xShrink;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xShrink_signature, xShrink_signatures[xShrink_pcache1Shrink_enum], sizeof(E2.xShrink_signature)) == 0) {
+ E1 = pcache1Shrink(args);
+ }
+ else if (memcmp(E2.xShrink_signature, xShrink_signatures[xShrink_pcachetraceShrink_enum], sizeof(E2.xShrink_signature)) == 0) {
+ E1 = pcachetraceShrink(args);
+ }


// FP: xShutdown

@transform_assign_xShutdown_dot@
expression E1, E2;
identifier FP_NAME = xShutdown;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xShutdown_signature, xShutdown_signatures[xShutdown_memtraceShutdown_enum], sizeof(E2.xShutdown_signature)) == 0) {
+ E1 = memtraceShutdown(args);
+ }
+ else if (memcmp(E2.xShutdown_signature, xShutdown_signatures[xShutdown_pcache1Shutdown_enum], sizeof(E2.xShutdown_signature)) == 0) {
+ E1 = pcache1Shutdown(args);
+ }
+ else if (memcmp(E2.xShutdown_signature, xShutdown_signatures[xShutdown_pcachetraceShutdown_enum], sizeof(E2.xShutdown_signature)) == 0) {
+ E1 = pcachetraceShutdown(args);
+ }
+ else if (memcmp(E2.xShutdown_signature, xShutdown_signatures[xShutdown_sqlite3MemShutdown_enum], sizeof(E2.xShutdown_signature)) == 0) {
+ E1 = sqlite3MemShutdown(args);
+ }


// FP: xSize

@transform_assign_xSize_dot@
expression E1, E2;
identifier FP_NAME = xSize;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xSize_signature, xSize_signatures[xSize_memtraceSize_enum], sizeof(E2.xSize_signature)) == 0) {
+ E1 = memtraceSize(args);
+ }
+ else if (memcmp(E2.xSize_signature, xSize_signatures[xSize_sqlite3MemSize_enum], sizeof(E2.xSize_signature)) == 0) {
+ E1 = sqlite3MemSize(args);
+ }


// FP: xSleep

@transform_assign_xSleep_dot@
expression E1, E2;
identifier FP_NAME = xSleep;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xSleep_signature, xSleep_signatures[xSleep_0_enum], sizeof(E2.xSleep_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xSleep_signature, xSleep_signatures[xSleep_apndSleep_enum], sizeof(E2.xSleep_signature)) == 0) {
+ E1 = apndSleep(args);
+ }
+ else if (memcmp(E2.xSleep_signature, xSleep_signatures[xSleep_memdbSleep_enum], sizeof(E2.xSleep_signature)) == 0) {
+ E1 = memdbSleep(args);
+ }
+ else if (memcmp(E2.xSleep_signature, xSleep_signatures[xSleep_vfstraceSleep_enum], sizeof(E2.xSleep_signature)) == 0) {
+ E1 = vfstraceSleep(args);
+ }
+ else if (memcmp(E2.xSleep_signature, xSleep_signatures[xSleep_unixSleep_enum], sizeof(E2.xSleep_signature)) == 0) {
+ E1 = unixSleep(args);
+ }


// FP: xSql

@transform_assign_xSql_dot@
expression E1, E2;
identifier FP_NAME = xSql;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xSql_signature, xSql_signatures[xSql_0_enum], sizeof(E2.xSql_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xSql_signature, xSql_signatures[xSql_recoverSqlCb_enum], sizeof(E2.xSql_signature)) == 0) {
+ E1 = recoverSqlCb(args);
+ }


// FP: xSync

@transform_assign_xSync_dot@
expression E1, E2;
identifier FP_NAME = xSync;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xSync_signature, xSync_signatures[xSync_0_enum], sizeof(E2.xSync_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xSync_signature, xSync_signatures[xSync_apndSync_enum], sizeof(E2.xSync_signature)) == 0) {
+ E1 = apndSync(args);
+ }
+ else if (memcmp(E2.xSync_signature, xSync_signatures[xSync_dbpageSync_enum], sizeof(E2.xSync_signature)) == 0) {
+ E1 = dbpageSync(args);
+ }
+ else if (memcmp(E2.xSync_signature, xSync_signatures[xSync_fts3SyncMethod_enum], sizeof(E2.xSync_signature)) == 0) {
+ E1 = fts3SyncMethod(args);
+ }
+ else if (memcmp(E2.xSync_signature, xSync_signatures[xSync_memdbSync_enum], sizeof(E2.xSync_signature)) == 0) {
+ E1 = memdbSync(args);
+ }
+ else if (memcmp(E2.xSync_signature, xSync_signatures[xSync_memjrnlSync_enum], sizeof(E2.xSync_signature)) == 0) {
+ E1 = memjrnlSync(args);
+ }
+ else if (memcmp(E2.xSync_signature, xSync_signatures[xSync_recoverVfsSync_enum], sizeof(E2.xSync_signature)) == 0) {
+ E1 = recoverVfsSync(args);
+ }
+ else if (memcmp(E2.xSync_signature, xSync_signatures[xSync_rtreeEndTransaction_enum], sizeof(E2.xSync_signature)) == 0) {
+ E1 = rtreeEndTransaction(args);
+ }
+ else if (memcmp(E2.xSync_signature, xSync_signatures[xSync_vfstraceSync_enum], sizeof(E2.xSync_signature)) == 0) {
+ E1 = vfstraceSync(args);
+ }


// FP: xTableFilter

@transform_assign_xTableFilter_dot@
expression E1, E2;
identifier FP_NAME = xTableFilter;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xTableFilter_signature, xTableFilter_signatures[xTableFilter_0_enum], sizeof(E2.xTableFilter_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xTableFilter_signature, xTableFilter_signatures[xTableFilter_session_filter_enum], sizeof(E2.xTableFilter_signature)) == 0) {
+ E1 = session_filter(args);
+ }


// FP: xTask

@transform_assign_xTask_dot@
expression E1, E2;
identifier FP_NAME = xTask;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xTask_signature, xTask_signatures[xTask_0_enum], sizeof(E2.xTask_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xTask_signature, xTask_signatures[xTask_vdbeSorterFlushThread_enum], sizeof(E2.xTask_signature)) == 0) {
+ E1 = vdbeSorterFlushThread(args);
+ }
+ else if (memcmp(E2.xTask_signature, xTask_signatures[xTask_vdbeIncrPopulateThread_enum], sizeof(E2.xTask_signature)) == 0) {
+ E1 = vdbeIncrPopulateThread(args);
+ }
+ else if (memcmp(E2.xTask_signature, xTask_signatures[xTask_vdbePmaReaderBgIncrInit_enum], sizeof(E2.xTask_signature)) == 0) {
+ E1 = vdbePmaReaderBgIncrInit(args);
+ }


// FP: xTruncate

@transform_assign_xTruncate_dot@
expression E1, E2;
identifier FP_NAME = xTruncate;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xTruncate_signature, xTruncate_signatures[xTruncate_apndTruncate_enum], sizeof(E2.xTruncate_signature)) == 0) {
+ E1 = apndTruncate(args);
+ }
+ else if (memcmp(E2.xTruncate_signature, xTruncate_signatures[xTruncate_memdbTruncate_enum], sizeof(E2.xTruncate_signature)) == 0) {
+ E1 = memdbTruncate(args);
+ }
+ else if (memcmp(E2.xTruncate_signature, xTruncate_signatures[xTruncate_memjrnlTruncate_enum], sizeof(E2.xTruncate_signature)) == 0) {
+ E1 = memjrnlTruncate(args);
+ }
+ else if (memcmp(E2.xTruncate_signature, xTruncate_signatures[xTruncate_pcache1Truncate_enum], sizeof(E2.xTruncate_signature)) == 0) {
+ E1 = pcache1Truncate(args);
+ }
+ else if (memcmp(E2.xTruncate_signature, xTruncate_signatures[xTruncate_pcachetraceTruncate_enum], sizeof(E2.xTruncate_signature)) == 0) {
+ E1 = pcachetraceTruncate(args);
+ }
+ else if (memcmp(E2.xTruncate_signature, xTruncate_signatures[xTruncate_recoverVfsTruncate_enum], sizeof(E2.xTruncate_signature)) == 0) {
+ E1 = recoverVfsTruncate(args);
+ }
+ else if (memcmp(E2.xTruncate_signature, xTruncate_signatures[xTruncate_vfstraceTruncate_enum], sizeof(E2.xTruncate_signature)) == 0) {
+ E1 = vfstraceTruncate(args);
+ }


// FP: xUnfetch

@transform_assign_xUnfetch_dot@
expression E1, E2;
identifier FP_NAME = xUnfetch;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xUnfetch_signature, xUnfetch_signatures[xUnfetch_0_enum], sizeof(E2.xUnfetch_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xUnfetch_signature, xUnfetch_signatures[xUnfetch_apndUnfetch_enum], sizeof(E2.xUnfetch_signature)) == 0) {
+ E1 = apndUnfetch(args);
+ }
+ else if (memcmp(E2.xUnfetch_signature, xUnfetch_signatures[xUnfetch_memdbUnfetch_enum], sizeof(E2.xUnfetch_signature)) == 0) {
+ E1 = memdbUnfetch(args);
+ }
+ else if (memcmp(E2.xUnfetch_signature, xUnfetch_signatures[xUnfetch_recoverVfsUnfetch_enum], sizeof(E2.xUnfetch_signature)) == 0) {
+ E1 = recoverVfsUnfetch(args);
+ }


// FP: xUnlock

@transform_assign_xUnlock_dot@
expression E1, E2;
identifier FP_NAME = xUnlock;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xUnlock_signature, xUnlock_signatures[xUnlock_0_enum], sizeof(E2.xUnlock_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xUnlock_signature, xUnlock_signatures[xUnlock_apndUnlock_enum], sizeof(E2.xUnlock_signature)) == 0) {
+ E1 = apndUnlock(args);
+ }
+ else if (memcmp(E2.xUnlock_signature, xUnlock_signatures[xUnlock_memdbUnlock_enum], sizeof(E2.xUnlock_signature)) == 0) {
+ E1 = memdbUnlock(args);
+ }
+ else if (memcmp(E2.xUnlock_signature, xUnlock_signatures[xUnlock_recoverVfsUnlock_enum], sizeof(E2.xUnlock_signature)) == 0) {
+ E1 = recoverVfsUnlock(args);
+ }
+ else if (memcmp(E2.xUnlock_signature, xUnlock_signatures[xUnlock_vfstraceUnlock_enum], sizeof(E2.xUnlock_signature)) == 0) {
+ E1 = vfstraceUnlock(args);
+ }


// FP: xUnlockNotify

@transform_assign_xUnlockNotify_dot@
expression E1, E2;
identifier FP_NAME = xUnlockNotify;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xUnlockNotify_signature, xUnlockNotify_signatures[xUnlockNotify_0_enum], sizeof(E2.xUnlockNotify_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xUnlockNotify_signature, xUnlockNotify_signatures[xUnlockNotify_xUnlockNotify_enum], sizeof(E2.xUnlockNotify_signature)) == 0) {
+ E1 = xUnlockNotify(args);
+ }


// FP: xUnpin

@transform_assign_xUnpin_dot@
expression E1, E2;
identifier FP_NAME = xUnpin;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xUnpin_signature, xUnpin_signatures[xUnpin_pcache1Unpin_enum], sizeof(E2.xUnpin_signature)) == 0) {
+ E1 = pcache1Unpin(args);
+ }
+ else if (memcmp(E2.xUnpin_signature, xUnpin_signatures[xUnpin_pcachetraceUnpin_enum], sizeof(E2.xUnpin_signature)) == 0) {
+ E1 = pcachetraceUnpin(args);
+ }


// FP: xUpdate

@transform_assign_xUpdate_dot@
expression E1, E2;
identifier FP_NAME = xUpdate;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xUpdate_signature, xUpdate_signatures[xUpdate_0_enum], sizeof(E2.xUpdate_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xUpdate_signature, xUpdate_signatures[xUpdate_dbpageUpdate_enum], sizeof(E2.xUpdate_signature)) == 0) {
+ E1 = dbpageUpdate(args);
+ }
+ else if (memcmp(E2.xUpdate_signature, xUpdate_signatures[xUpdate_expertUpdate_enum], sizeof(E2.xUpdate_signature)) == 0) {
+ E1 = expertUpdate(args);
+ }
+ else if (memcmp(E2.xUpdate_signature, xUpdate_signatures[xUpdate_fts3UpdateMethod_enum], sizeof(E2.xUpdate_signature)) == 0) {
+ E1 = fts3UpdateMethod(args);
+ }
+ else if (memcmp(E2.xUpdate_signature, xUpdate_signatures[xUpdate_geopolyUpdate_enum], sizeof(E2.xUpdate_signature)) == 0) {
+ E1 = geopolyUpdate(args);
+ }
+ else if (memcmp(E2.xUpdate_signature, xUpdate_signatures[xUpdate_rtreeUpdate_enum], sizeof(E2.xUpdate_signature)) == 0) {
+ E1 = rtreeUpdate(args);
+ }
+ else if (memcmp(E2.xUpdate_signature, xUpdate_signatures[xUpdate_zipfileUpdate_enum], sizeof(E2.xUpdate_signature)) == 0) {
+ E1 = zipfileUpdate(args);
+ }


// FP: xUpdateCallback

@transform_assign_xUpdateCallback_dot@
expression E1, E2;
identifier FP_NAME = xUpdateCallback;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xUpdateCallback_signature, xUpdateCallback_signatures[xUpdateCallback_0_enum], sizeof(E2.xUpdateCallback_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xUpdateCallback_signature, xUpdateCallback_signatures[xUpdateCallback_sql_trace_callback_enum], sizeof(E2.xUpdateCallback_signature)) == 0) {
+ E1 = sql_trace_callback(args);
+ }
+ else if (memcmp(E2.xUpdateCallback_signature, xUpdateCallback_signatures[xUpdateCallback_sqlite3WalDefaultHook_enum], sizeof(E2.xUpdateCallback_signature)) == 0) {
+ E1 = sqlite3WalDefaultHook(args);
+ }


// FP: xV2

@transform_assign_xV2_dot@
expression E1, E2;
identifier FP_NAME = xV2;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xV2_signature, xV2_signatures[xV2_0_enum], sizeof(E2.xV2_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xV2_signature, xV2_signatures[xV2_sql_trace_callback_enum], sizeof(E2.xV2_signature)) == 0) {
+ E1 = sql_trace_callback(args);
+ }


// FP: xValue

@transform_assign_xValue_dot@
expression E1, E2;
identifier FP_NAME = xValue;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xValue_signature, xValue_signatures[xValue_0_enum], sizeof(E2.xValue_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xValue_signature, xValue_signatures[xValue_decimalSumValue_enum], sizeof(E2.xValue_signature)) == 0) {
+ E1 = decimalSumValue(args);
+ }
+ else if (memcmp(E2.xValue_signature, xValue_signatures[xValue_percentValue_enum], sizeof(E2.xValue_signature)) == 0) {
+ E1 = percentValue(args);
+ }
+ else if (memcmp(E2.xValue_signature, xValue_signatures[xValue_sqlite3changeset_new_enum], sizeof(E2.xValue_signature)) == 0) {
+ E1 = sqlite3changeset_new(args);
+ }
+ else if (memcmp(E2.xValue_signature, xValue_signatures[xValue_sqlite3changeset_old_enum], sizeof(E2.xValue_signature)) == 0) {
+ E1 = sqlite3changeset_old(args);
+ }


// FP: xWrite

@transform_assign_xWrite_dot@
expression E1, E2;
identifier FP_NAME = xWrite;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xWrite_signature, xWrite_signatures[xWrite_apndWrite_enum], sizeof(E2.xWrite_signature)) == 0) {
+ E1 = apndWrite(args);
+ }
+ else if (memcmp(E2.xWrite_signature, xWrite_signatures[xWrite_kvstorageWrite_enum], sizeof(E2.xWrite_signature)) == 0) {
+ E1 = kvstorageWrite(args);
+ }
+ else if (memcmp(E2.xWrite_signature, xWrite_signatures[xWrite_memdbWrite_enum], sizeof(E2.xWrite_signature)) == 0) {
+ E1 = memdbWrite(args);
+ }
+ else if (memcmp(E2.xWrite_signature, xWrite_signatures[xWrite_memjrnlWrite_enum], sizeof(E2.xWrite_signature)) == 0) {
+ E1 = memjrnlWrite(args);
+ }
+ else if (memcmp(E2.xWrite_signature, xWrite_signatures[xWrite_recoverVfsWrite_enum], sizeof(E2.xWrite_signature)) == 0) {
+ E1 = recoverVfsWrite(args);
+ }
+ else if (memcmp(E2.xWrite_signature, xWrite_signatures[xWrite_vfstraceWrite_enum], sizeof(E2.xWrite_signature)) == 0) {
+ E1 = vfstraceWrite(args);
+ }


// FP: xsnprintf

@transform_assign_xsnprintf_dot@
expression E1, E2;
identifier FP_NAME = xsnprintf;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = sqlite3_set_authorizer(args);


// FP: xvsnprintf

@transform_assign_xvsnprintf_dot@
expression E1, E2;
identifier FP_NAME = xvsnprintf;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ // E1 = E2.FP_NAME(args);
+ E1 = 0;

// Total assignment dot rules: 359

// ===== STANDALONE ARROW CALL TRANSFORMATION RULES =====
// Pattern: E->fp_name(args);


// FP: aggregate_context

@transform_standalone_aggregate_context_arrow@
expression E;
identifier FP_NAME = aggregate_context;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_aggregate_context(args);


// FP: auto_extension

@transform_standalone_auto_extension_arrow@
expression E;
identifier FP_NAME = auto_extension;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_vtab_config(args);


// FP: backup_finish

@transform_standalone_backup_finish_arrow@
expression E;
identifier FP_NAME = backup_finish;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_result_error_code(args);


// FP: backup_init

@transform_standalone_backup_init_arrow@
expression E;
identifier FP_NAME = backup_init;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_test_control(args);


// FP: backup_pagecount

@transform_standalone_backup_pagecount_arrow@
expression E;
identifier FP_NAME = backup_pagecount;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_randomness(args);


// FP: backup_remaining

@transform_standalone_backup_remaining_arrow@
expression E;
identifier FP_NAME = backup_remaining;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_context_db_handle(args);


// FP: backup_step

@transform_standalone_backup_step_arrow@
expression E;
identifier FP_NAME = backup_step;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_extended_result_codes(args);


// FP: bind_blob64

@transform_standalone_bind_blob64_arrow@
expression E;
identifier FP_NAME = bind_blob64;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_vtab_on_conflict(args);


// FP: bind_int

@transform_standalone_bind_int_arrow@
expression E;
identifier FP_NAME = bind_int;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_bind_double(args);


// FP: bind_int64

@transform_standalone_bind_int64_arrow@
expression E;
identifier FP_NAME = bind_int64;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_bind_int(args);


// FP: bind_null

@transform_standalone_bind_null_arrow@
expression E;
identifier FP_NAME = bind_null;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_bind_int64(args);


// FP: bind_parameter_count

@transform_standalone_bind_parameter_count_arrow@
expression E;
identifier FP_NAME = bind_parameter_count;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_bind_null(args);


// FP: bind_parameter_index

@transform_standalone_bind_parameter_index_arrow@
expression E;
identifier FP_NAME = bind_parameter_index;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_bind_parameter_count(args);


// FP: bind_parameter_name

@transform_standalone_bind_parameter_name_arrow@
expression E;
identifier FP_NAME = bind_parameter_name;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_bind_parameter_index(args);


// FP: bind_text

@transform_standalone_bind_text_arrow@
expression E;
identifier FP_NAME = bind_text;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_bind_parameter_name(args);


// FP: bind_text16

@transform_standalone_bind_text16_arrow@
expression E;
identifier FP_NAME = bind_text16;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_bind_text(args);


// FP: bind_text64

@transform_standalone_bind_text64_arrow@
expression E;
identifier FP_NAME = bind_text64;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_close_v2(args);


// FP: bind_value

@transform_standalone_bind_value_arrow@
expression E;
identifier FP_NAME = bind_value;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_bind_text16(args);


// FP: bind_zeroblob

@transform_standalone_bind_zeroblob_arrow@
expression E;
identifier FP_NAME = bind_zeroblob;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_prepare_v2(args);


// FP: bind_zeroblob64

@transform_standalone_bind_zeroblob64_arrow@
expression E;
identifier FP_NAME = bind_zeroblob64;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_auto_extension(args);


// FP: blob_bytes

@transform_standalone_blob_bytes_arrow@
expression E;
identifier FP_NAME = blob_bytes;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_prepare16_v2(args);


// FP: blob_close

@transform_standalone_blob_close_arrow@
expression E;
identifier FP_NAME = blob_close;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_clear_bindings(args);


// FP: blob_open

@transform_standalone_blob_open_arrow@
expression E;
identifier FP_NAME = blob_open;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_create_module_v2(args);


// FP: blob_read

@transform_standalone_blob_read_arrow@
expression E;
identifier FP_NAME = blob_read;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_bind_zeroblob(args);


// FP: blob_reopen

@transform_standalone_blob_reopen_arrow@
expression E;
identifier FP_NAME = blob_reopen;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_db_status(args);


// FP: blob_write

@transform_standalone_blob_write_arrow@
expression E;
identifier FP_NAME = blob_write;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_blob_bytes(args);


// FP: busy_handler

@transform_standalone_busy_handler_arrow@
expression E;
identifier FP_NAME = busy_handler;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_bind_value(args);


// FP: busy_timeout

@transform_standalone_busy_timeout_arrow@
expression E;
identifier FP_NAME = busy_timeout;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_busy_handler(args);


// FP: cancel_auto_extension

@transform_standalone_cancel_auto_extension_arrow@
expression E;
identifier FP_NAME = cancel_auto_extension;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_db_filename(args);


// FP: changes

@transform_standalone_changes_arrow@
expression E;
identifier FP_NAME = changes;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_busy_timeout(args);


// FP: changes64

@transform_standalone_changes64_arrow@
expression E;
identifier FP_NAME = changes64;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_str_value(args);


// FP: clear_bindings

@transform_standalone_clear_bindings_arrow@
expression E;
identifier FP_NAME = clear_bindings;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_vmprintf(args);


// FP: close

@transform_standalone_close_arrow@
expression E;
identifier FP_NAME = close;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_changes(args);


// FP: close_v2

@transform_standalone_close_v2_arrow@
expression E;
identifier FP_NAME = close_v2;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_soft_heap_limit64(args);


// FP: collation_needed

@transform_standalone_collation_needed_arrow@
expression E;
identifier FP_NAME = collation_needed;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_close(args);


// FP: collation_needed16

@transform_standalone_collation_needed16_arrow@
expression E;
identifier FP_NAME = collation_needed16;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_collation_needed(args);


// FP: column_blob

@transform_standalone_column_blob_arrow@
expression E;
identifier FP_NAME = column_blob;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_collation_needed16(args);


// FP: column_bytes

@transform_standalone_column_bytes_arrow@
expression E;
identifier FP_NAME = column_bytes;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_column_blob(args);


// FP: column_bytes16

@transform_standalone_column_bytes16_arrow@
expression E;
identifier FP_NAME = column_bytes16;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_column_bytes(args);


// FP: column_count

@transform_standalone_column_count_arrow@
expression E;
identifier FP_NAME = column_count;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_column_bytes16(args);


// FP: column_database_name

@transform_standalone_column_database_name_arrow@
expression E;
identifier FP_NAME = column_database_name;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_column_count(args);


// FP: column_database_name16

@transform_standalone_column_database_name16_arrow@
expression E;
identifier FP_NAME = column_database_name16;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_column_database_name(args);


// FP: column_decltype

@transform_standalone_column_decltype_arrow@
expression E;
identifier FP_NAME = column_decltype;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_column_database_name16(args);


// FP: column_decltype16

@transform_standalone_column_decltype16_arrow@
expression E;
identifier FP_NAME = column_decltype16;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_column_decltype(args);


// FP: column_double

@transform_standalone_column_double_arrow@
expression E;
identifier FP_NAME = column_double;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_column_decltype16(args);


// FP: column_int

@transform_standalone_column_int_arrow@
expression E;
identifier FP_NAME = column_int;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_column_double(args);


// FP: column_int64

@transform_standalone_column_int64_arrow@
expression E;
identifier FP_NAME = column_int64;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_column_int(args);


// FP: column_name

@transform_standalone_column_name_arrow@
expression E;
identifier FP_NAME = column_name;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_column_int64(args);


// FP: column_name16

@transform_standalone_column_name16_arrow@
expression E;
identifier FP_NAME = column_name16;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_column_name(args);


// FP: column_origin_name

@transform_standalone_column_origin_name_arrow@
expression E;
identifier FP_NAME = column_origin_name;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_column_name16(args);


// FP: column_origin_name16

@transform_standalone_column_origin_name16_arrow@
expression E;
identifier FP_NAME = column_origin_name16;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_column_origin_name(args);


// FP: column_table_name

@transform_standalone_column_table_name_arrow@
expression E;
identifier FP_NAME = column_table_name;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_column_origin_name16(args);


// FP: column_table_name16

@transform_standalone_column_table_name16_arrow@
expression E;
identifier FP_NAME = column_table_name16;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_column_table_name(args);


// FP: column_text

@transform_standalone_column_text_arrow@
expression E;
identifier FP_NAME = column_text;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_column_table_name16(args);


// FP: column_text16

@transform_standalone_column_text16_arrow@
expression E;
identifier FP_NAME = column_text16;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_column_text(args);


// FP: column_type

@transform_standalone_column_type_arrow@
expression E;
identifier FP_NAME = column_type;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_column_text16(args);


// FP: column_value

@transform_standalone_column_value_arrow@
expression E;
identifier FP_NAME = column_value;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_column_type(args);


// FP: commit_hook

@transform_standalone_commit_hook_arrow@
expression E;
identifier FP_NAME = commit_hook;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_column_value(args);


// FP: compileoption_get

@transform_standalone_compileoption_get_arrow@
expression E;
identifier FP_NAME = compileoption_get;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_limit(args);


// FP: compileoption_used

@transform_standalone_compileoption_used_arrow@
expression E;
identifier FP_NAME = compileoption_used;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_next_stmt(args);


// FP: complete

@transform_standalone_complete_arrow@
expression E;
identifier FP_NAME = complete;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_commit_hook(args);


// FP: complete16

@transform_standalone_complete16_arrow@
expression E;
identifier FP_NAME = complete16;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_complete(args);


// FP: context_db_handle

@transform_standalone_context_db_handle_arrow@
expression E;
identifier FP_NAME = context_db_handle;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_soft_heap_limit(args);


// FP: create_collation

@transform_standalone_create_collation_arrow@
expression E;
identifier FP_NAME = create_collation;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_complete16(args);


// FP: create_collation16

@transform_standalone_create_collation16_arrow@
expression E;
identifier FP_NAME = create_collation16;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_create_collation(args);


// FP: create_collation_v2

@transform_standalone_create_collation_v2_arrow@
expression E;
identifier FP_NAME = create_collation_v2;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_blob_close(args);


// FP: create_filename

@transform_standalone_create_filename_arrow@
expression E;
identifier FP_NAME = create_filename;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_str_appendchar(args);


// FP: create_function

@transform_standalone_create_function_arrow@
expression E;
identifier FP_NAME = create_function;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_create_collation16(args);


// FP: create_function16

@transform_standalone_create_function16_arrow@
expression E;
identifier FP_NAME = create_function16;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_create_function(args);


// FP: create_function_v2

@transform_standalone_create_function_v2_arrow@
expression E;
identifier FP_NAME = create_function_v2;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_sql(args);


// FP: create_module

@transform_standalone_create_module_arrow@
expression E;
identifier FP_NAME = create_module;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_create_function16(args);


// FP: create_module_v2

@transform_standalone_create_module_v2_arrow@
expression E;
identifier FP_NAME = create_module_v2;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_overload_function(args);


// FP: create_window_function

@transform_standalone_create_window_function_arrow@
expression E;
identifier FP_NAME = create_window_function;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_vtab_collation(args);


// FP: data_count

@transform_standalone_data_count_arrow@
expression E;
identifier FP_NAME = data_count;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_create_module(args);


// FP: database_file_object

@transform_standalone_database_file_object_arrow@
expression E;
identifier FP_NAME = database_file_object;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_str_errcode(args);


// FP: db_cacheflush

@transform_standalone_db_cacheflush_arrow@
expression E;
identifier FP_NAME = db_cacheflush;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_malloc64(args);


// FP: db_config

@transform_standalone_db_config_arrow@
expression E;
identifier FP_NAME = db_config;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_status(args);


// FP: db_filename

@transform_standalone_db_filename_arrow@
expression E;
identifier FP_NAME = db_filename;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_sourceid(args);


// FP: db_handle

@transform_standalone_db_handle_arrow@
expression E;
identifier FP_NAME = db_handle;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_data_count(args);


// FP: db_mutex

@transform_standalone_db_mutex_arrow@
expression E;
identifier FP_NAME = db_mutex;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_backup_finish(args);


// FP: db_name

@transform_standalone_db_name_arrow@
expression E;
identifier FP_NAME = db_name;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_filename_journal(args);


// FP: db_readonly

@transform_standalone_db_readonly_arrow@
expression E;
identifier FP_NAME = db_readonly;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_stmt_status(args);


// FP: db_release_memory

@transform_standalone_db_release_memory_arrow@
expression E;
identifier FP_NAME = db_release_memory;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_strnicmp(args);


// FP: db_status

@transform_standalone_db_status_arrow@
expression E;
identifier FP_NAME = db_status;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_backup_init(args);


// FP: declare_vtab

@transform_standalone_declare_vtab_arrow@
expression E;
identifier FP_NAME = declare_vtab;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_db_handle(args);


// FP: deserialize

@transform_standalone_deserialize_arrow@
expression E;
identifier FP_NAME = deserialize;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_uri_key(args);


// FP: drop_modules

@transform_standalone_drop_modules_arrow@
expression E;
identifier FP_NAME = drop_modules;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_str_new(args);


// FP: enable_shared_cache

@transform_standalone_enable_shared_cache_arrow@
expression E;
identifier FP_NAME = enable_shared_cache;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_declare_vtab(args);


// FP: errcode

@transform_standalone_errcode_arrow@
expression E;
identifier FP_NAME = errcode;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_enable_shared_cache(args);


// FP: errmsg

@transform_standalone_errmsg_arrow@
expression E;
identifier FP_NAME = errmsg;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_errcode(args);


// FP: errmsg16

@transform_standalone_errmsg16_arrow@
expression E;
identifier FP_NAME = errmsg16;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_errmsg(args);


// FP: exec

@transform_standalone_exec_arrow@
expression E;
identifier FP_NAME = exec;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_errmsg16(args);


// FP: expanded_sql

@transform_standalone_expanded_sql_arrow@
expression E;
identifier FP_NAME = expanded_sql;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_reset_auto_extension(args);


// FP: expired

@transform_standalone_expired_arrow@
expression E;
identifier FP_NAME = expired;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->expired_signature, expired_signatures[expired_0_enum], sizeof(E->expired_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->expired_signature, expired_signatures[expired_sqlite3_exec_enum], sizeof(E->expired_signature)) == 0) {
+ sqlite3_exec(args);
+ }


// FP: extended_errcode

@transform_standalone_extended_errcode_arrow@
expression E;
identifier FP_NAME = extended_errcode;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_backup_pagecount(args);


// FP: extended_result_codes

@transform_standalone_extended_result_codes_arrow@
expression E;
identifier FP_NAME = extended_result_codes;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_vfs_find(args);


// FP: file_control

@transform_standalone_file_control_arrow@
expression E;
identifier FP_NAME = file_control;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_blob_open(args);


// FP: filename_database

@transform_standalone_filename_database_arrow@
expression E;
identifier FP_NAME = filename_database;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_str_vappendf(args);


// FP: filename_journal

@transform_standalone_filename_journal_arrow@
expression E;
identifier FP_NAME = filename_journal;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_str_append(args);


// FP: filename_wal

@transform_standalone_filename_wal_arrow@
expression E;
identifier FP_NAME = filename_wal;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_str_appendall(args);


// FP: free_filename

@transform_standalone_free_filename_arrow@
expression E;
identifier FP_NAME = free_filename;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_str_reset(args);


// FP: get_autocommit

@transform_standalone_get_autocommit_arrow@
expression E;
identifier FP_NAME = get_autocommit;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_free(args);


// FP: get_auxdata

@transform_standalone_get_auxdata_arrow@
expression E;
identifier FP_NAME = get_auxdata;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_free_table(args);


// FP: get_clientdata

@transform_standalone_get_clientdata_arrow@
expression E;
identifier FP_NAME = get_clientdata;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_database_file_object(args);


// FP: get_table

@transform_standalone_get_table_arrow@
expression E;
identifier FP_NAME = get_table;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_get_autocommit(args);


// FP: global_recover

@transform_standalone_global_recover_arrow@
expression E;
identifier FP_NAME = global_recover;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_get_auxdata(args);


// FP: hard_heap_limit64

@transform_standalone_hard_heap_limit64_arrow@
expression E;
identifier FP_NAME = hard_heap_limit64;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_str_finish(args);


// FP: interruptx

@transform_standalone_interruptx_arrow@
expression E;
identifier FP_NAME = interruptx;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_get_table(args);


// FP: is_interrupted

@transform_standalone_is_interrupted_arrow@
expression E;
identifier FP_NAME = is_interrupted;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_create_filename(args);


// FP: keyword_check

@transform_standalone_keyword_check_arrow@
expression E;
identifier FP_NAME = keyword_check;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_db_cacheflush(args);


// FP: keyword_count

@transform_standalone_keyword_count_arrow@
expression E;
identifier FP_NAME = keyword_count;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_status64(args);


// FP: keyword_name

@transform_standalone_keyword_name_arrow@
expression E;
identifier FP_NAME = keyword_name;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_strlike(args);


// FP: last_insert_rowid

@transform_standalone_last_insert_rowid_arrow@
expression E;
identifier FP_NAME = last_insert_rowid;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ 0;


// FP: libversion

@transform_standalone_libversion_arrow@
expression E;
identifier FP_NAME = libversion;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_interrupt(args);


// FP: libversion_number

@transform_standalone_libversion_number_arrow@
expression E;
identifier FP_NAME = libversion_number;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_last_insert_rowid(args);


// FP: limit

@transform_standalone_limit_arrow@
expression E;
identifier FP_NAME = limit;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_vfs_register(args);


// FP: load_extension

@transform_standalone_load_extension_arrow@
expression E;
identifier FP_NAME = load_extension;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_db_readonly(args);


// FP: log

@transform_standalone_log_arrow@
expression E;
identifier FP_NAME = log;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_backup_remaining(args);


// FP: malloc

@transform_standalone_malloc_arrow@
expression E;
identifier FP_NAME = malloc;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_libversion(args);


// FP: malloc64

@transform_standalone_malloc64_arrow@
expression E;
identifier FP_NAME = malloc64;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_db_release_memory(args);


// FP: memory_highwater

@transform_standalone_memory_highwater_arrow@
expression E;
identifier FP_NAME = memory_highwater;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_blob_read(args);


// FP: memory_used

@transform_standalone_memory_used_arrow@
expression E;
identifier FP_NAME = memory_used;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_blob_write(args);


// FP: mprintf

@transform_standalone_mprintf_arrow@
expression E;
identifier FP_NAME = mprintf;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_libversion_number(args);


// FP: msize

@transform_standalone_msize_arrow@
expression E;
identifier FP_NAME = msize;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_errstr(args);


// FP: mutex_alloc

@transform_standalone_mutex_alloc_arrow@
expression E;
identifier FP_NAME = mutex_alloc;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_create_collation_v2(args);


// FP: mutex_enter

@transform_standalone_mutex_enter_arrow@
expression E;
identifier FP_NAME = mutex_enter;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_file_control(args);


// FP: mutex_free

@transform_standalone_mutex_free_arrow@
expression E;
identifier FP_NAME = mutex_free;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_memory_highwater(args);


// FP: mutex_leave

@transform_standalone_mutex_leave_arrow@
expression E;
identifier FP_NAME = mutex_leave;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_memory_used(args);


// FP: next_stmt

@transform_standalone_next_stmt_arrow@
expression E;
identifier FP_NAME = next_stmt;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_vfs_unregister(args);


// FP: normalized_sql

@transform_standalone_normalized_sql_arrow@
expression E;
identifier FP_NAME = normalized_sql;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_keyword_count(args);


// FP: open

@transform_standalone_open_arrow@
expression E;
identifier FP_NAME = open;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_malloc(args);


// FP: open16

@transform_standalone_open16_arrow@
expression E;
identifier FP_NAME = open16;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_mprintf(args);


// FP: open_v2

@transform_standalone_open_v2_arrow@
expression E;
identifier FP_NAME = open_v2;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ 0;


// FP: overload_function

@transform_standalone_overload_function_arrow@
expression E;
identifier FP_NAME = overload_function;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_value_text16be(args);


// FP: prepare

@transform_standalone_prepare_arrow@
expression E;
identifier FP_NAME = prepare;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_open(args);


// FP: prepare16

@transform_standalone_prepare16_arrow@
expression E;
identifier FP_NAME = prepare16;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_open16(args);


// FP: prepare16_v2

@transform_standalone_prepare16_v2_arrow@
expression E;
identifier FP_NAME = prepare16_v2;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_value_type(args);


// FP: prepare16_v3

@transform_standalone_prepare16_v3_arrow@
expression E;
identifier FP_NAME = prepare16_v3;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_strglob(args);


// FP: prepare_v2

@transform_standalone_prepare_v2_arrow@
expression E;
identifier FP_NAME = prepare_v2;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_value_text16le(args);


// FP: prepare_v3

@transform_standalone_prepare_v3_arrow@
expression E;
identifier FP_NAME = prepare_v3;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_result_text64(args);


// FP: profile

@transform_standalone_profile_arrow@
expression E;
identifier FP_NAME = profile;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_prepare(args);


// FP: progress_handler

@transform_standalone_progress_handler_arrow@
expression E;
identifier FP_NAME = progress_handler;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_prepare16(args);


// FP: randomness

@transform_standalone_randomness_arrow@
expression E;
identifier FP_NAME = randomness;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_sleep(args);


// FP: realloc

@transform_standalone_realloc_arrow@
expression E;
identifier FP_NAME = realloc;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_profile(args);


// FP: realloc64

@transform_standalone_realloc64_arrow@
expression E;
identifier FP_NAME = realloc64;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_stmt_busy(args);


// FP: release_memory

@transform_standalone_release_memory_arrow@
expression E;
identifier FP_NAME = release_memory;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ 0;


// FP: reset

@transform_standalone_reset_arrow@
expression E;
identifier FP_NAME = reset;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_progress_handler(args);


// FP: reset_auto_extension

@transform_standalone_reset_auto_extension_arrow@
expression E;
identifier FP_NAME = reset_auto_extension;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_stmt_readonly(args);


// FP: result_blob

@transform_standalone_result_blob_arrow@
expression E;
identifier FP_NAME = result_blob;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_realloc(args);


// FP: result_blob64

@transform_standalone_result_blob64_arrow@
expression E;
identifier FP_NAME = result_blob64;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_stricmp(args);


// FP: result_double

@transform_standalone_result_double_arrow@
expression E;
identifier FP_NAME = result_double;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_reset(args);


// FP: result_error

@transform_standalone_result_error_arrow@
expression E;
identifier FP_NAME = result_error;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_result_blob(args);


// FP: result_error16

@transform_standalone_result_error16_arrow@
expression E;
identifier FP_NAME = result_error16;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_result_double(args);


// FP: result_error_code

@transform_standalone_result_error_code_arrow@
expression E;
identifier FP_NAME = result_error_code;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_result_error_nomem(args);


// FP: result_error_nomem

@transform_standalone_result_error_nomem_arrow@
expression E;
identifier FP_NAME = result_error_nomem;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ 0;


// FP: result_error_toobig

@transform_standalone_result_error_toobig_arrow@
expression E;
identifier FP_NAME = result_error_toobig;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ 0;


// FP: result_int

@transform_standalone_result_int_arrow@
expression E;
identifier FP_NAME = result_int;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_result_error(args);


// FP: result_int64

@transform_standalone_result_int64_arrow@
expression E;
identifier FP_NAME = result_int64;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_result_error16(args);


// FP: result_null

@transform_standalone_result_null_arrow@
expression E;
identifier FP_NAME = result_null;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_result_int(args);


// FP: result_pointer

@transform_standalone_result_pointer_arrow@
expression E;
identifier FP_NAME = result_pointer;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_value_free(args);


// FP: result_subtype

@transform_standalone_result_subtype_arrow@
expression E;
identifier FP_NAME = result_subtype;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_bind_text64(args);


// FP: result_text

@transform_standalone_result_text_arrow@
expression E;
identifier FP_NAME = result_text;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_result_int64(args);


// FP: result_text16

@transform_standalone_result_text16_arrow@
expression E;
identifier FP_NAME = result_text16;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_result_null(args);


// FP: result_text16be

@transform_standalone_result_text16be_arrow@
expression E;
identifier FP_NAME = result_text16be;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_result_text(args);


// FP: result_text16le

@transform_standalone_result_text16le_arrow@
expression E;
identifier FP_NAME = result_text16le;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_result_text16(args);


// FP: result_text64

@transform_standalone_result_text64_arrow@
expression E;
identifier FP_NAME = result_text64;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_uri_boolean(args);


// FP: result_value

@transform_standalone_result_value_arrow@
expression E;
identifier FP_NAME = result_value;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_result_text16be(args);


// FP: result_zeroblob

@transform_standalone_result_zeroblob_arrow@
expression E;
identifier FP_NAME = result_zeroblob;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_release_memory(args);


// FP: result_zeroblob64

@transform_standalone_result_zeroblob64_arrow@
expression E;
identifier FP_NAME = result_zeroblob64;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_wal_checkpoint_v2(args);


// FP: rollback_hook

@transform_standalone_rollback_hook_arrow@
expression E;
identifier FP_NAME = rollback_hook;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_result_text16le(args);


// FP: serialize

@transform_standalone_serialize_arrow@
expression E;
identifier FP_NAME = serialize;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_filename_database(args);


// FP: set_authorizer

@transform_standalone_set_authorizer_arrow@
expression E;
identifier FP_NAME = set_authorizer;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_result_value(args);


// FP: set_auxdata

@transform_standalone_set_auxdata_arrow@
expression E;
identifier FP_NAME = set_auxdata;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_rollback_hook(args);


// FP: set_clientdata

@transform_standalone_set_clientdata_arrow@
expression E;
identifier FP_NAME = set_clientdata;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_txn_state(args);


// FP: set_errmsg

@transform_standalone_set_errmsg_arrow@
expression E;
identifier FP_NAME = set_errmsg;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_total_changes64(args);


// FP: set_last_insert_rowid

@transform_standalone_set_last_insert_rowid_arrow@
expression E;
identifier FP_NAME = set_last_insert_rowid;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_result_blob64(args);


// FP: setlk_timeout

@transform_standalone_setlk_timeout_arrow@
expression E;
identifier FP_NAME = setlk_timeout;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_changes64(args);


// FP: soft_heap_limit

@transform_standalone_soft_heap_limit_arrow@
expression E;
identifier FP_NAME = soft_heap_limit;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_mutex_enter(args);


// FP: soft_heap_limit64

@transform_standalone_soft_heap_limit64_arrow@
expression E;
identifier FP_NAME = soft_heap_limit64;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_backup_step(args);


// FP: sql

@transform_standalone_sql_arrow@
expression E;
identifier FP_NAME = sql;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_threadsafe(args);


// FP: status

@transform_standalone_status_arrow@
expression E;
identifier FP_NAME = status;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_result_zeroblob(args);


// FP: status64

@transform_standalone_status64_arrow@
expression E;
identifier FP_NAME = status64;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_cancel_auto_extension(args);


// FP: step

@transform_standalone_step_arrow@
expression E;
identifier FP_NAME = step;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_set_auxdata(args);


// FP: stmt_explain

@transform_standalone_stmt_explain_arrow@
expression E;
identifier FP_NAME = stmt_explain;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_free_filename(args);


// FP: stmt_isexplain

@transform_standalone_stmt_isexplain_arrow@
expression E;
identifier FP_NAME = stmt_isexplain;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_keyword_name(args);


// FP: stmt_status

@transform_standalone_stmt_status_arrow@
expression E;
identifier FP_NAME = stmt_status;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_compileoption_used(args);


// FP: str_append

@transform_standalone_str_append_arrow@
expression E;
identifier FP_NAME = str_append;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_prepare_v3(args);


// FP: str_appendall

@transform_standalone_str_appendall_arrow@
expression E;
identifier FP_NAME = str_appendall;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_prepare16_v3(args);


// FP: str_appendchar

@transform_standalone_str_appendchar_arrow@
expression E;
identifier FP_NAME = str_appendchar;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_bind_pointer(args);


// FP: str_appendf

@transform_standalone_str_appendf_arrow@
expression E;
identifier FP_NAME = str_appendf;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_expanded_sql(args);


// FP: str_errcode

@transform_standalone_str_errcode_arrow@
expression E;
identifier FP_NAME = str_errcode;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_value_pointer(args);


// FP: str_finish

@transform_standalone_str_finish_arrow@
expression E;
identifier FP_NAME = str_finish;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_trace_v2(args);


// FP: str_length

@transform_standalone_str_length_arrow@
expression E;
identifier FP_NAME = str_length;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_vtab_nochange(args);


// FP: str_new

@transform_standalone_str_new_arrow@
expression E;
identifier FP_NAME = str_new;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_system_errno(args);


// FP: str_reset

@transform_standalone_str_reset_arrow@
expression E;
identifier FP_NAME = str_reset;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_result_pointer(args);


// FP: str_value

@transform_standalone_str_value_arrow@
expression E;
identifier FP_NAME = str_value;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_value_nochange(args);


// FP: str_vappendf

@transform_standalone_str_vappendf_arrow@
expression E;
identifier FP_NAME = str_vappendf;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_set_last_insert_rowid(args);


// FP: strglob

@transform_standalone_strglob_arrow@
expression E;
identifier FP_NAME = strglob;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_uri_int64(args);


// FP: stricmp

@transform_standalone_stricmp_arrow@
expression E;
identifier FP_NAME = stricmp;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_wal_checkpoint(args);


// FP: strlike

@transform_standalone_strlike_arrow@
expression E;
identifier FP_NAME = strlike;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_load_extension(args);


// FP: system_errno

@transform_standalone_system_errno_arrow@
expression E;
identifier FP_NAME = system_errno;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_msize(args);


// FP: table_column_metadata

@transform_standalone_table_column_metadata_arrow@
expression E;
identifier FP_NAME = table_column_metadata;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_snprintf(args);


// FP: test_control

@transform_standalone_test_control_arrow@
expression E;
identifier FP_NAME = test_control;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_result_error_toobig(args);


// FP: thread_cleanup

@transform_standalone_thread_cleanup_arrow@
expression E;
identifier FP_NAME = thread_cleanup;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_step(args);


// FP: total_changes

@transform_standalone_total_changes_arrow@
expression E;
identifier FP_NAME = total_changes;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_table_column_metadata(args);


// FP: total_changes64

@transform_standalone_total_changes64_arrow@
expression E;
identifier FP_NAME = total_changes64;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_create_window_function(args);


// FP: trace_v2

@transform_standalone_trace_v2_arrow@
expression E;
identifier FP_NAME = trace_v2;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_realloc64(args);


// FP: txn_state

@transform_standalone_txn_state_arrow@
expression E;
identifier FP_NAME = txn_state;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_str_length(args);


// FP: unlock_notify

@transform_standalone_unlock_notify_arrow@
expression E;
identifier FP_NAME = unlock_notify;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ 0;


// FP: uri_boolean

@transform_standalone_uri_boolean_arrow@
expression E;
identifier FP_NAME = uri_boolean;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_wal_hook(args);


// FP: uri_key

@transform_standalone_uri_key_arrow@
expression E;
identifier FP_NAME = uri_key;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_str_appendf(args);


// FP: uri_parameter

@transform_standalone_uri_parameter_arrow@
expression E;
identifier FP_NAME = uri_parameter;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ 0;


// FP: user_data

@transform_standalone_user_data_arrow@
expression E;
identifier FP_NAME = user_data;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_trace(args);


// FP: value_double

@transform_standalone_value_double_arrow@
expression E;
identifier FP_NAME = value_double;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_user_data(args);


// FP: value_dup

@transform_standalone_value_dup_arrow@
expression E;
identifier FP_NAME = value_dup;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_uri_parameter(args);


// FP: value_encoding

@transform_standalone_value_encoding_arrow@
expression E;
identifier FP_NAME = value_encoding;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_filename_wal(args);


// FP: value_free

@transform_standalone_value_free_arrow@
expression E;
identifier FP_NAME = value_free;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_vsnprintf(args);


// FP: value_frombind

@transform_standalone_value_frombind_arrow@
expression E;
identifier FP_NAME = value_frombind;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_keyword_check(args);


// FP: value_int

@transform_standalone_value_int_arrow@
expression E;
identifier FP_NAME = value_int;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_value_blob(args);


// FP: value_int64

@transform_standalone_value_int64_arrow@
expression E;
identifier FP_NAME = value_int64;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_value_bytes(args);


// FP: value_nochange

@transform_standalone_value_nochange_arrow@
expression E;
identifier FP_NAME = value_nochange;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_value_subtype(args);


// FP: value_numeric_type

@transform_standalone_value_numeric_type_arrow@
expression E;
identifier FP_NAME = value_numeric_type;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_value_bytes16(args);


// FP: value_pointer

@transform_standalone_value_pointer_arrow@
expression E;
identifier FP_NAME = value_pointer;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_result_zeroblob64(args);


// FP: value_subtype

@transform_standalone_value_subtype_arrow@
expression E;
identifier FP_NAME = value_subtype;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_bind_blob64(args);


// FP: value_text

@transform_standalone_value_text_arrow@
expression E;
identifier FP_NAME = value_text;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_value_double(args);


// FP: value_text16

@transform_standalone_value_text16_arrow@
expression E;
identifier FP_NAME = value_text16;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_value_int(args);


// FP: value_text16be

@transform_standalone_value_text16be_arrow@
expression E;
identifier FP_NAME = value_text16be;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_value_int64(args);


// FP: value_text16le

@transform_standalone_value_text16le_arrow@
expression E;
identifier FP_NAME = value_text16le;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_value_numeric_type(args);


// FP: value_type

@transform_standalone_value_type_arrow@
expression E;
identifier FP_NAME = value_type;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_value_text(args);


// FP: vfs_find

@transform_standalone_vfs_find_arrow@
expression E;
identifier FP_NAME = vfs_find;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_mutex_free(args);


// FP: vfs_register

@transform_standalone_vfs_register_arrow@
expression E;
identifier FP_NAME = vfs_register;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_mutex_leave(args);


// FP: vfs_unregister

@transform_standalone_vfs_unregister_arrow@
expression E;
identifier FP_NAME = vfs_unregister;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_mutex_try(args);


// FP: vmprintf

@transform_standalone_vmprintf_arrow@
expression E;
identifier FP_NAME = vmprintf;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_value_text16(args);


// FP: vtab_collation

@transform_standalone_vtab_collation_arrow@
expression E;
identifier FP_NAME = vtab_collation;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_result_subtype(args);


// FP: vtab_config

@transform_standalone_vtab_config_arrow@
expression E;
identifier FP_NAME = vtab_config;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_extended_errcode(args);


// FP: vtab_distinct

@transform_standalone_vtab_distinct_arrow@
expression E;
identifier FP_NAME = vtab_distinct;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_value_frombind(args);


// FP: vtab_nochange

@transform_standalone_vtab_nochange_arrow@
expression E;
identifier FP_NAME = vtab_nochange;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_bind_zeroblob64(args);


// FP: vtab_on_conflict

@transform_standalone_vtab_on_conflict_arrow@
expression E;
identifier FP_NAME = vtab_on_conflict;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_log(args);


// FP: wal_checkpoint

@transform_standalone_wal_checkpoint_arrow@
expression E;
identifier FP_NAME = wal_checkpoint;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_db_config(args);


// FP: wal_hook

@transform_standalone_wal_hook_arrow@
expression E;
identifier FP_NAME = wal_hook;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_db_mutex(args);


// FP: xAccess

@transform_standalone_xAccess_arrow@
expression E;
identifier FP_NAME = xAccess;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xAccess_signature, xAccess_signatures[xAccess_apndAccess_enum], sizeof(E->xAccess_signature)) == 0) {
+ apndAccess(args);
+ }
+ else if (memcmp(E->xAccess_signature, xAccess_signatures[xAccess_memdbAccess_enum], sizeof(E->xAccess_signature)) == 0) {
+ memdbAccess(args);
+ }
+ else if (memcmp(E->xAccess_signature, xAccess_signatures[xAccess_vfstraceAccess_enum], sizeof(E->xAccess_signature)) == 0) {
+ vfstraceAccess(args);
+ }
+ else if (memcmp(E->xAccess_signature, xAccess_signatures[xAccess_unixAccess_enum], sizeof(E->xAccess_signature)) == 0) {
+ unixAccess(args);
+ }


// FP: xAltLocaltime

@transform_standalone_xAltLocaltime_arrow@
expression E;
identifier FP_NAME = xAltLocaltime;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ 0;


// FP: xAutovacDestr

@transform_standalone_xAutovacDestr_arrow@
expression E;
identifier FP_NAME = xAutovacDestr;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xAutovacDestr_signature, xAutovacDestr_signatures[xAutovacDestr_0_enum], sizeof(E->xAutovacDestr_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xAutovacDestr_signature, xAutovacDestr_signatures[xAutovacDestr_rtreeMatchArgFree_enum], sizeof(E->xAutovacDestr_signature)) == 0) {
+ rtreeMatchArgFree(args);
+ }
+ else if (memcmp(E->xAutovacDestr_signature, xAutovacDestr_signatures[xAutovacDestr_sqlite3VdbeValueListFree_enum], sizeof(E->xAutovacDestr_signature)) == 0) {
+ sqlite3VdbeValueListFree(args);
+ }


// FP: xAutovacPages

@transform_standalone_xAutovacPages_arrow@
expression E;
identifier FP_NAME = xAutovacPages;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xAutovacPages_signature, xAutovacPages_signatures[xAutovacPages_0_enum], sizeof(E->xAutovacPages_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xAutovacPages_signature, xAutovacPages_signatures[xAutovacPages_sql_trace_callback_enum], sizeof(E->xAutovacPages_signature)) == 0) {
+ sql_trace_callback(args);
+ }
+ else if (memcmp(E->xAutovacPages_signature, xAutovacPages_signatures[xAutovacPages_sqlite3WalDefaultHook_enum], sizeof(E->xAutovacPages_signature)) == 0) {
+ sqlite3WalDefaultHook(args);
+ }


// FP: xBegin

@transform_standalone_xBegin_arrow@
expression E;
identifier FP_NAME = xBegin;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xBegin_signature, xBegin_signatures[xBegin_0_enum], sizeof(E->xBegin_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xBegin_signature, xBegin_signatures[xBegin_dbpageBegin_enum], sizeof(E->xBegin_signature)) == 0) {
+ dbpageBegin(args);
+ }
+ else if (memcmp(E->xBegin_signature, xBegin_signatures[xBegin_fts3BeginMethod_enum], sizeof(E->xBegin_signature)) == 0) {
+ fts3BeginMethod(args);
+ }
+ else if (memcmp(E->xBegin_signature, xBegin_signatures[xBegin_rtreeBeginTransaction_enum], sizeof(E->xBegin_signature)) == 0) {
+ rtreeBeginTransaction(args);
+ }
+ else if (memcmp(E->xBegin_signature, xBegin_signatures[xBegin_zipfileBegin_enum], sizeof(E->xBegin_signature)) == 0) {
+ zipfileBegin(args);
+ }


// FP: xBestIndex

@transform_standalone_xBestIndex_arrow@
expression E;
identifier FP_NAME = xBestIndex;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xBestIndex_signature, xBestIndex_signatures[xBestIndex_bytecodevtabBestIndex_enum], sizeof(E->xBestIndex_signature)) == 0) {
+ bytecodevtabBestIndex(args);
+ }
+ else if (memcmp(E->xBestIndex_signature, xBestIndex_signatures[xBestIndex_completionBestIndex_enum], sizeof(E->xBestIndex_signature)) == 0) {
+ completionBestIndex(args);
+ }
+ else if (memcmp(E->xBestIndex_signature, xBestIndex_signatures[xBestIndex_dbdataBestIndex_enum], sizeof(E->xBestIndex_signature)) == 0) {
+ dbdataBestIndex(args);
+ }
+ else if (memcmp(E->xBestIndex_signature, xBestIndex_signatures[xBestIndex_dbpageBestIndex_enum], sizeof(E->xBestIndex_signature)) == 0) {
+ dbpageBestIndex(args);
+ }
+ else if (memcmp(E->xBestIndex_signature, xBestIndex_signatures[xBestIndex_expertBestIndex_enum], sizeof(E->xBestIndex_signature)) == 0) {
+ expertBestIndex(args);
+ }
+ else if (memcmp(E->xBestIndex_signature, xBestIndex_signatures[xBestIndex_fsdirBestIndex_enum], sizeof(E->xBestIndex_signature)) == 0) {
+ fsdirBestIndex(args);
+ }
+ else if (memcmp(E->xBestIndex_signature, xBestIndex_signatures[xBestIndex_fts3BestIndexMethod_enum], sizeof(E->xBestIndex_signature)) == 0) {
+ fts3BestIndexMethod(args);
+ }
+ else if (memcmp(E->xBestIndex_signature, xBestIndex_signatures[xBestIndex_fts3auxBestIndexMethod_enum], sizeof(E->xBestIndex_signature)) == 0) {
+ fts3auxBestIndexMethod(args);
+ }
+ else if (memcmp(E->xBestIndex_signature, xBestIndex_signatures[xBestIndex_fts3tokBestIndexMethod_enum], sizeof(E->xBestIndex_signature)) == 0) {
+ fts3tokBestIndexMethod(args);
+ }
+ else if (memcmp(E->xBestIndex_signature, xBestIndex_signatures[xBestIndex_jsonEachBestIndex_enum], sizeof(E->xBestIndex_signature)) == 0) {
+ jsonEachBestIndex(args);
+ }
+ else if (memcmp(E->xBestIndex_signature, xBestIndex_signatures[xBestIndex_pragmaVtabBestIndex_enum], sizeof(E->xBestIndex_signature)) == 0) {
+ pragmaVtabBestIndex(args);
+ }
+ else if (memcmp(E->xBestIndex_signature, xBestIndex_signatures[xBestIndex_rtreeBestIndex_enum], sizeof(E->xBestIndex_signature)) == 0) {
+ rtreeBestIndex(args);
+ }
+ else if (memcmp(E->xBestIndex_signature, xBestIndex_signatures[xBestIndex_seriesBestIndex_enum], sizeof(E->xBestIndex_signature)) == 0) {
+ seriesBestIndex(args);
+ }
+ else if (memcmp(E->xBestIndex_signature, xBestIndex_signatures[xBestIndex_statBestIndex_enum], sizeof(E->xBestIndex_signature)) == 0) {
+ statBestIndex(args);
+ }
+ else if (memcmp(E->xBestIndex_signature, xBestIndex_signatures[xBestIndex_stmtBestIndex_enum], sizeof(E->xBestIndex_signature)) == 0) {
+ stmtBestIndex(args);
+ }
+ else if (memcmp(E->xBestIndex_signature, xBestIndex_signatures[xBestIndex_zipfileBestIndex_enum], sizeof(E->xBestIndex_signature)) == 0) {
+ zipfileBestIndex(args);
+ }


// FP: xBusyHandler

@transform_standalone_xBusyHandler_arrow@
expression E;
identifier FP_NAME = xBusyHandler;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xBusyHandler_signature, xBusyHandler_signatures[xBusyHandler_0_enum], sizeof(E->xBusyHandler_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xBusyHandler_signature, xBusyHandler_signatures[xBusyHandler_btreeInvokeBusyHandler_enum], sizeof(E->xBusyHandler_signature)) == 0) {
+ btreeInvokeBusyHandler(args);
+ }
+ else if (memcmp(E->xBusyHandler_signature, xBusyHandler_signatures[xBusyHandler_sqliteDefaultBusyCallback_enum], sizeof(E->xBusyHandler_signature)) == 0) {
+ sqliteDefaultBusyCallback(args);
+ }
+ else if (memcmp(E->xBusyHandler_signature, xBusyHandler_signatures[xBusyHandler_xBusyHandler_enum], sizeof(E->xBusyHandler_signature)) == 0) {
+ xBusyHandler(args);
+ }


// FP: xCachesize

@transform_standalone_xCachesize_arrow@
expression E;
identifier FP_NAME = xCachesize;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xCachesize_signature, xCachesize_signatures[xCachesize_pcache1Cachesize_enum], sizeof(E->xCachesize_signature)) == 0) {
+ pcache1Cachesize(args);
+ }
+ else if (memcmp(E->xCachesize_signature, xCachesize_signatures[xCachesize_pcachetraceCachesize_enum], sizeof(E->xCachesize_signature)) == 0) {
+ pcachetraceCachesize(args);
+ }


// FP: xCellSize

@transform_standalone_xCellSize_arrow@
expression E;
identifier FP_NAME = xCellSize;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xCellSize_signature, xCellSize_signatures[xCellSize_cellSizePtr_enum], sizeof(E->xCellSize_signature)) == 0) {
+ cellSizePtr(args);
+ }
+ else if (memcmp(E->xCellSize_signature, xCellSize_signatures[xCellSize_cellSizePtrIdxLeaf_enum], sizeof(E->xCellSize_signature)) == 0) {
+ cellSizePtrIdxLeaf(args);
+ }
+ else if (memcmp(E->xCellSize_signature, xCellSize_signatures[xCellSize_cellSizePtrNoPayload_enum], sizeof(E->xCellSize_signature)) == 0) {
+ cellSizePtrNoPayload(args);
+ }
+ else if (memcmp(E->xCellSize_signature, xCellSize_signatures[xCellSize_cellSizePtrTableLeaf_enum], sizeof(E->xCellSize_signature)) == 0) {
+ cellSizePtrTableLeaf(args);
+ }


// FP: xCheckReservedLock

@transform_standalone_xCheckReservedLock_arrow@
expression E;
identifier FP_NAME = xCheckReservedLock;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xCheckReservedLock_signature, xCheckReservedLock_signatures[xCheckReservedLock_0_enum], sizeof(E->xCheckReservedLock_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xCheckReservedLock_signature, xCheckReservedLock_signatures[xCheckReservedLock_apndCheckReservedLock_enum], sizeof(E->xCheckReservedLock_signature)) == 0) {
+ apndCheckReservedLock(args);
+ }
+ else if (memcmp(E->xCheckReservedLock_signature, xCheckReservedLock_signatures[xCheckReservedLock_recoverVfsCheckReservedLock_enum], sizeof(E->xCheckReservedLock_signature)) == 0) {
+ recoverVfsCheckReservedLock(args);
+ }
+ else if (memcmp(E->xCheckReservedLock_signature, xCheckReservedLock_signatures[xCheckReservedLock_vfstraceCheckReservedLock_enum], sizeof(E->xCheckReservedLock_signature)) == 0) {
+ vfstraceCheckReservedLock(args);
+ }


// FP: xCleanup

@transform_standalone_xCleanup_arrow@
expression E;
identifier FP_NAME = xCleanup;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xCleanup_signature, xCleanup_signatures[xCleanup_agginfoFree_enum], sizeof(E->xCleanup_signature)) == 0) {
+ agginfoFree(args);
+ }
+ else if (memcmp(E->xCleanup_signature, xCleanup_signatures[xCleanup_sqlite3DbFree_enum], sizeof(E->xCleanup_signature)) == 0) {
+ sqlite3DbFree(args);
+ }
+ else if (memcmp(E->xCleanup_signature, xCleanup_signatures[xCleanup_sqlite3DeleteReturning_enum], sizeof(E->xCleanup_signature)) == 0) {
+ sqlite3DeleteReturning(args);
+ }
+ else if (memcmp(E->xCleanup_signature, xCleanup_signatures[xCleanup_sqlite3DeleteTableGeneric_enum], sizeof(E->xCleanup_signature)) == 0) {
+ sqlite3DeleteTableGeneric(args);
+ }
+ else if (memcmp(E->xCleanup_signature, xCleanup_signatures[xCleanup_sqlite3ExprDeleteGeneric_enum], sizeof(E->xCleanup_signature)) == 0) {
+ sqlite3ExprDeleteGeneric(args);
+ }
+ else if (memcmp(E->xCleanup_signature, xCleanup_signatures[xCleanup_sqlite3ExprListDeleteGeneric_enum], sizeof(E->xCleanup_signature)) == 0) {
+ sqlite3ExprListDeleteGeneric(args);
+ }
+ else if (memcmp(E->xCleanup_signature, xCleanup_signatures[xCleanup_sqlite3SelectDeleteGeneric_enum], sizeof(E->xCleanup_signature)) == 0) {
+ sqlite3SelectDeleteGeneric(args);
+ }
+ else if (memcmp(E->xCleanup_signature, xCleanup_signatures[xCleanup_sqlite3WithDeleteGeneric_enum], sizeof(E->xCleanup_signature)) == 0) {
+ sqlite3WithDeleteGeneric(args);
+ }
+ else if (memcmp(E->xCleanup_signature, xCleanup_signatures[xCleanup_whereIndexedExprCleanup_enum], sizeof(E->xCleanup_signature)) == 0) {
+ whereIndexedExprCleanup(args);
+ }


// FP: xClose

@transform_standalone_xClose_arrow@
expression E;
identifier FP_NAME = xClose;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xClose_signature, xClose_signatures[xClose_apndClose_enum], sizeof(E->xClose_signature)) == 0) {
+ apndClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_bytecodevtabClose_enum], sizeof(E->xClose_signature)) == 0) {
+ bytecodevtabClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_completionClose_enum], sizeof(E->xClose_signature)) == 0) {
+ completionClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_dbdataClose_enum], sizeof(E->xClose_signature)) == 0) {
+ dbdataClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_dbpageClose_enum], sizeof(E->xClose_signature)) == 0) {
+ dbpageClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_expertClose_enum], sizeof(E->xClose_signature)) == 0) {
+ expertClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_fsdirClose_enum], sizeof(E->xClose_signature)) == 0) {
+ fsdirClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_fts3CloseMethod_enum], sizeof(E->xClose_signature)) == 0) {
+ fts3CloseMethod(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_fts3auxCloseMethod_enum], sizeof(E->xClose_signature)) == 0) {
+ fts3auxCloseMethod(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_fts3tokCloseMethod_enum], sizeof(E->xClose_signature)) == 0) {
+ fts3tokCloseMethod(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_jsonEachClose_enum], sizeof(E->xClose_signature)) == 0) {
+ jsonEachClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_memdbClose_enum], sizeof(E->xClose_signature)) == 0) {
+ memdbClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_memjrnlClose_enum], sizeof(E->xClose_signature)) == 0) {
+ memjrnlClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_porterClose_enum], sizeof(E->xClose_signature)) == 0) {
+ porterClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_pragmaVtabClose_enum], sizeof(E->xClose_signature)) == 0) {
+ pragmaVtabClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_recoverVfsClose_enum], sizeof(E->xClose_signature)) == 0) {
+ recoverVfsClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_rtreeClose_enum], sizeof(E->xClose_signature)) == 0) {
+ rtreeClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_seriesClose_enum], sizeof(E->xClose_signature)) == 0) {
+ seriesClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_simpleClose_enum], sizeof(E->xClose_signature)) == 0) {
+ simpleClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_statClose_enum], sizeof(E->xClose_signature)) == 0) {
+ statClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_stmtClose_enum], sizeof(E->xClose_signature)) == 0) {
+ stmtClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_unicodeClose_enum], sizeof(E->xClose_signature)) == 0) {
+ unicodeClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_vfstraceClose_enum], sizeof(E->xClose_signature)) == 0) {
+ vfstraceClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_zipfileClose_enum], sizeof(E->xClose_signature)) == 0) {
+ zipfileClose(args);
+ }


// FP: xCmp

@transform_standalone_xCmp_arrow@
expression E;
identifier FP_NAME = xCmp;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xCmp_signature, xCmp_signatures[xCmp_0_enum], sizeof(E->xCmp_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xCmp_signature, xCmp_signatures[xCmp_binCollFunc_enum], sizeof(E->xCmp_signature)) == 0) {
+ binCollFunc(args);
+ }
+ else if (memcmp(E->xCmp_signature, xCmp_signatures[xCmp_decimalCollFunc_enum], sizeof(E->xCmp_signature)) == 0) {
+ decimalCollFunc(args);
+ }
+ else if (memcmp(E->xCmp_signature, xCmp_signatures[xCmp_dummyCompare_enum], sizeof(E->xCmp_signature)) == 0) {
+ dummyCompare(args);
+ }
+ else if (memcmp(E->xCmp_signature, xCmp_signatures[xCmp_icuCollationColl_enum], sizeof(E->xCmp_signature)) == 0) {
+ icuCollationColl(args);
+ }
+ else if (memcmp(E->xCmp_signature, xCmp_signatures[xCmp_nocaseCollatingFunc_enum], sizeof(E->xCmp_signature)) == 0) {
+ nocaseCollatingFunc(args);
+ }
+ else if (memcmp(E->xCmp_signature, xCmp_signatures[xCmp_rtrimCollFunc_enum], sizeof(E->xCmp_signature)) == 0) {
+ rtrimCollFunc(args);
+ }
+ else if (memcmp(E->xCmp_signature, xCmp_signatures[xCmp_uintCollFunc_enum], sizeof(E->xCmp_signature)) == 0) {
+ uintCollFunc(args);
+ }


// FP: xCollNeeded16

@transform_standalone_xCollNeeded16_arrow@
expression E;
identifier FP_NAME = xCollNeeded16;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ 0;


// FP: xColumn

@transform_standalone_xColumn_arrow@
expression E;
identifier FP_NAME = xColumn;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_bytecodevtabColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ bytecodevtabColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_completionColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ completionColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_dbdataColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ dbdataColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_dbpageColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ dbpageColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_expertColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ expertColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_fsdirColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ fsdirColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_fts3ColumnMethod_enum], sizeof(E->xColumn_signature)) == 0) {
+ fts3ColumnMethod(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_fts3auxColumnMethod_enum], sizeof(E->xColumn_signature)) == 0) {
+ fts3auxColumnMethod(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_fts3tokColumnMethod_enum], sizeof(E->xColumn_signature)) == 0) {
+ fts3tokColumnMethod(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_geopolyColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ geopolyColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_jsonEachColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ jsonEachColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_pragmaVtabColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ pragmaVtabColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_rtreeColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ rtreeColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_seriesColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ seriesColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_statColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ statColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_stmtColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ stmtColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_zipfileColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ zipfileColumn(args);
+ }


// FP: xCommit

@transform_standalone_xCommit_arrow@
expression E;
identifier FP_NAME = xCommit;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xCommit_signature, xCommit_signatures[xCommit_0_enum], sizeof(E->xCommit_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xCommit_signature, xCommit_signatures[xCommit_fts3CommitMethod_enum], sizeof(E->xCommit_signature)) == 0) {
+ fts3CommitMethod(args);
+ }
+ else if (memcmp(E->xCommit_signature, xCommit_signatures[xCommit_rtreeEndTransaction_enum], sizeof(E->xCommit_signature)) == 0) {
+ rtreeEndTransaction(args);
+ }
+ else if (memcmp(E->xCommit_signature, xCommit_signatures[xCommit_zipfileCommit_enum], sizeof(E->xCommit_signature)) == 0) {
+ zipfileCommit(args);
+ }


// FP: xCommitCallback

@transform_standalone_xCommitCallback_arrow@
expression E;
identifier FP_NAME = xCommitCallback;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xCommitCallback_signature, xCommitCallback_signatures[xCommitCallback_0_enum], sizeof(E->xCommitCallback_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xCommitCallback_signature, xCommitCallback_signatures[xCommitCallback_sql_trace_callback_enum], sizeof(E->xCommitCallback_signature)) == 0) {
+ sql_trace_callback(args);
+ }
+ else if (memcmp(E->xCommitCallback_signature, xCommitCallback_signatures[xCommitCallback_sqlite3WalDefaultHook_enum], sizeof(E->xCommitCallback_signature)) == 0) {
+ sqlite3WalDefaultHook(args);
+ }


// FP: xConnect

@transform_standalone_xConnect_arrow@
expression E;
identifier FP_NAME = xConnect;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_bytecodevtabConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ bytecodevtabConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_dbpageConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ dbpageConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_fts3ConnectMethod_enum], sizeof(E->xConnect_signature)) == 0) {
+ fts3ConnectMethod(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_fts3auxConnectMethod_enum], sizeof(E->xConnect_signature)) == 0) {
+ fts3auxConnectMethod(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_fts3tokConnectMethod_enum], sizeof(E->xConnect_signature)) == 0) {
+ fts3tokConnectMethod(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_jsonEachConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ jsonEachConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_pragmaVtabConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ pragmaVtabConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_rtreeConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ rtreeConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_statConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ statConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_stmtConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ stmtConnect(args);
+ }


// FP: xCount

@transform_standalone_xCount_arrow@
expression E;
identifier FP_NAME = xCount;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xCount_signature, xCount_signatures[xCount_sessionDiffCount_enum], sizeof(E->xCount_signature)) == 0) {
+ sessionDiffCount(args);
+ }
+ else if (memcmp(E->xCount_signature, xCount_signatures[xCount_sessionPreupdateCount_enum], sizeof(E->xCount_signature)) == 0) {
+ sessionPreupdateCount(args);
+ }
+ else if (memcmp(E->xCount_signature, xCount_signatures[xCount_sessionStat1Count_enum], sizeof(E->xCount_signature)) == 0) {
+ sessionStat1Count(args);
+ }


// FP: xCreate

@transform_standalone_xCreate_arrow@
expression E;
identifier FP_NAME = xCreate;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_0_enum], sizeof(E->xCreate_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_dbpageConnect_enum], sizeof(E->xCreate_signature)) == 0) {
+ dbpageConnect(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_fts3CreateMethod_enum], sizeof(E->xCreate_signature)) == 0) {
+ fts3CreateMethod(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_fts3auxConnectMethod_enum], sizeof(E->xCreate_signature)) == 0) {
+ fts3auxConnectMethod(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_fts3tokConnectMethod_enum], sizeof(E->xCreate_signature)) == 0) {
+ fts3tokConnectMethod(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_geopolyCreate_enum], sizeof(E->xCreate_signature)) == 0) {
+ geopolyCreate(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_pcache1Create_enum], sizeof(E->xCreate_signature)) == 0) {
+ pcache1Create(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_pcachetraceCreate_enum], sizeof(E->xCreate_signature)) == 0) {
+ pcachetraceCreate(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_porterCreate_enum], sizeof(E->xCreate_signature)) == 0) {
+ porterCreate(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_rtreeCreate_enum], sizeof(E->xCreate_signature)) == 0) {
+ rtreeCreate(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_simpleCreate_enum], sizeof(E->xCreate_signature)) == 0) {
+ simpleCreate(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_statConnect_enum], sizeof(E->xCreate_signature)) == 0) {
+ statConnect(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_unicodeCreate_enum], sizeof(E->xCreate_signature)) == 0) {
+ unicodeCreate(args);
+ }


// FP: xCurrentTime

@transform_standalone_xCurrentTime_arrow@
expression E;
identifier FP_NAME = xCurrentTime;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xCurrentTime_signature, xCurrentTime_signatures[xCurrentTime_0_enum], sizeof(E->xCurrentTime_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xCurrentTime_signature, xCurrentTime_signatures[xCurrentTime_apndCurrentTime_enum], sizeof(E->xCurrentTime_signature)) == 0) {
+ apndCurrentTime(args);
+ }
+ else if (memcmp(E->xCurrentTime_signature, xCurrentTime_signatures[xCurrentTime_vfstraceCurrentTime_enum], sizeof(E->xCurrentTime_signature)) == 0) {
+ vfstraceCurrentTime(args);
+ }
+ else if (memcmp(E->xCurrentTime_signature, xCurrentTime_signatures[xCurrentTime_unixCurrentTime_enum], sizeof(E->xCurrentTime_signature)) == 0) {
+ unixCurrentTime(args);
+ }


// FP: xCurrentTimeInt64

@transform_standalone_xCurrentTimeInt64_arrow@
expression E;
identifier FP_NAME = xCurrentTimeInt64;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xCurrentTimeInt64_signature, xCurrentTimeInt64_signatures[xCurrentTimeInt64_apndCurrentTimeInt64_enum], sizeof(E->xCurrentTimeInt64_signature)) == 0) {
+ apndCurrentTimeInt64(args);
+ }
+ else if (memcmp(E->xCurrentTimeInt64_signature, xCurrentTimeInt64_signatures[xCurrentTimeInt64_memdbCurrentTimeInt64_enum], sizeof(E->xCurrentTimeInt64_signature)) == 0) {
+ memdbCurrentTimeInt64(args);
+ }
+ else if (memcmp(E->xCurrentTimeInt64_signature, xCurrentTimeInt64_signatures[xCurrentTimeInt64_unixCurrentTimeInt64_enum], sizeof(E->xCurrentTimeInt64_signature)) == 0) {
+ unixCurrentTimeInt64(args);
+ }


// FP: xDel

@transform_standalone_xDel_arrow@
expression E;
identifier FP_NAME = xDel;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xDel_signature, xDel_signatures[xDel_0_enum], sizeof(E->xDel_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xDel_signature, xDel_signatures[xDel_SQLITE_DYNAMIC_enum], sizeof(E->xDel_signature)) == 0) {
+ SQLITE_DYNAMIC(args);
+ }
+ else if (memcmp(E->xDel_signature, xDel_signatures[xDel_SQLITE_STATIC_enum], sizeof(E->xDel_signature)) == 0) {
+ SQLITE_STATIC(args);
+ }
+ else if (memcmp(E->xDel_signature, xDel_signatures[xDel_SQLITE_TRANSIENT_enum], sizeof(E->xDel_signature)) == 0) {
+ SQLITE_TRANSIENT(args);
+ }
+ else if (memcmp(E->xDel_signature, xDel_signatures[xDel_rtreeMatchArgFree_enum], sizeof(E->xDel_signature)) == 0) {
+ rtreeMatchArgFree(args);
+ }
+ else if (memcmp(E->xDel_signature, xDel_signatures[xDel_sqlite3RCStrUnref_enum], sizeof(E->xDel_signature)) == 0) {
+ sqlite3RCStrUnref(args);
+ }
+ else if (memcmp(E->xDel_signature, xDel_signatures[xDel_sqlite3RowSetDelete_enum], sizeof(E->xDel_signature)) == 0) {
+ sqlite3RowSetDelete(args);
+ }
+ else if (memcmp(E->xDel_signature, xDel_signatures[xDel_sqlite3SchemaClear_enum], sizeof(E->xDel_signature)) == 0) {
+ sqlite3SchemaClear(args);
+ }
+ else if (memcmp(E->xDel_signature, xDel_signatures[xDel_sqlite3VdbeFrameMemDel_enum], sizeof(E->xDel_signature)) == 0) {
+ sqlite3VdbeFrameMemDel(args);
+ }
+ else if (memcmp(E->xDel_signature, xDel_signatures[xDel_sqlite3VdbeValueListFree_enum], sizeof(E->xDel_signature)) == 0) {
+ sqlite3VdbeValueListFree(args);
+ }
+ else if (memcmp(E->xDel_signature, xDel_signatures[xDel_sqlite3_free_enum], sizeof(E->xDel_signature)) == 0) {
+ sqlite3_free(args);
+ }
+ else if (memcmp(E->xDel_signature, xDel_signatures[xDel_statAccumDestructor_enum], sizeof(E->xDel_signature)) == 0) {
+ statAccumDestructor(args);
+ }
+ else if (memcmp(E->xDel_signature, xDel_signatures[xDel_xDel_enum], sizeof(E->xDel_signature)) == 0) {
+ xDel(args);
+ }
+ else if (memcmp(E->xDel_signature, xDel_signatures[xDel_zipfileFree_enum], sizeof(E->xDel_signature)) == 0) {
+ zipfileFree(args);
+ }


// FP: xDelete

@transform_standalone_xDelete_arrow@
expression E;
identifier FP_NAME = xDelete;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xDelete_signature, xDelete_signatures[xDelete_0_enum], sizeof(E->xDelete_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xDelete_signature, xDelete_signatures[xDelete_apndDelete_enum], sizeof(E->xDelete_signature)) == 0) {
+ apndDelete(args);
+ }
+ else if (memcmp(E->xDelete_signature, xDelete_signatures[xDelete_jsonCacheDeleteGeneric_enum], sizeof(E->xDelete_signature)) == 0) {
+ jsonCacheDeleteGeneric(args);
+ }
+ else if (memcmp(E->xDelete_signature, xDelete_signatures[xDelete_kvstorageDelete_enum], sizeof(E->xDelete_signature)) == 0) {
+ kvstorageDelete(args);
+ }
+ else if (memcmp(E->xDelete_signature, xDelete_signatures[xDelete_sqlite3_free_enum], sizeof(E->xDelete_signature)) == 0) {
+ sqlite3_free(args);
+ }
+ else if (memcmp(E->xDelete_signature, xDelete_signatures[xDelete_vfstraceDelete_enum], sizeof(E->xDelete_signature)) == 0) {
+ vfstraceDelete(args);
+ }
+ else if (memcmp(E->xDelete_signature, xDelete_signatures[xDelete_unixDelete_enum], sizeof(E->xDelete_signature)) == 0) {
+ unixDelete(args);
+ }


// FP: xDeleteAux

@transform_standalone_xDeleteAux_arrow@
expression E;
identifier FP_NAME = xDeleteAux;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xDeleteAux_signature, xDeleteAux_signatures[xDeleteAux_jsonCacheDeleteGeneric_enum], sizeof(E->xDeleteAux_signature)) == 0) {
+ jsonCacheDeleteGeneric(args);
+ }
+ else if (memcmp(E->xDeleteAux_signature, xDeleteAux_signatures[xDeleteAux_sqlite3_free_enum], sizeof(E->xDeleteAux_signature)) == 0) {
+ sqlite3_free(args);
+ }


// FP: xDepth

@transform_standalone_xDepth_arrow@
expression E;
identifier FP_NAME = xDepth;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xDepth_signature, xDepth_signatures[xDepth_sessionDiffDepth_enum], sizeof(E->xDepth_signature)) == 0) {
+ sessionDiffDepth(args);
+ }
+ else if (memcmp(E->xDepth_signature, xDepth_signatures[xDepth_sessionPreupdateDepth_enum], sizeof(E->xDepth_signature)) == 0) {
+ sessionPreupdateDepth(args);
+ }
+ else if (memcmp(E->xDepth_signature, xDepth_signatures[xDepth_sessionStat1Depth_enum], sizeof(E->xDepth_signature)) == 0) {
+ sessionStat1Depth(args);
+ }


// FP: xDestroy

@transform_standalone_xDestroy_arrow@
expression E;
identifier FP_NAME = xDestroy;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xDestroy_signature, xDestroy_signatures[xDestroy_0_enum], sizeof(E->xDestroy_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xDestroy_signature, xDestroy_signatures[xDestroy_dbpageDisconnect_enum], sizeof(E->xDestroy_signature)) == 0) {
+ dbpageDisconnect(args);
+ }
+ else if (memcmp(E->xDestroy_signature, xDestroy_signatures[xDestroy_expertDisconnect_enum], sizeof(E->xDestroy_signature)) == 0) {
+ expertDisconnect(args);
+ }
+ else if (memcmp(E->xDestroy_signature, xDestroy_signatures[xDestroy_fts3DestroyMethod_enum], sizeof(E->xDestroy_signature)) == 0) {
+ fts3DestroyMethod(args);
+ }
+ else if (memcmp(E->xDestroy_signature, xDestroy_signatures[xDestroy_fts3auxDisconnectMethod_enum], sizeof(E->xDestroy_signature)) == 0) {
+ fts3auxDisconnectMethod(args);
+ }
+ else if (memcmp(E->xDestroy_signature, xDestroy_signatures[xDestroy_fts3tokDisconnectMethod_enum], sizeof(E->xDestroy_signature)) == 0) {
+ fts3tokDisconnectMethod(args);
+ }
+ else if (memcmp(E->xDestroy_signature, xDestroy_signatures[xDestroy_hashDestroy_enum], sizeof(E->xDestroy_signature)) == 0) {
+ hashDestroy(args);
+ }
+ else if (memcmp(E->xDestroy_signature, xDestroy_signatures[xDestroy_pcache1Destroy_enum], sizeof(E->xDestroy_signature)) == 0) {
+ pcache1Destroy(args);
+ }
+ else if (memcmp(E->xDestroy_signature, xDestroy_signatures[xDestroy_pcachetraceDestroy_enum], sizeof(E->xDestroy_signature)) == 0) {
+ pcachetraceDestroy(args);
+ }
+ else if (memcmp(E->xDestroy_signature, xDestroy_signatures[xDestroy_porterDestroy_enum], sizeof(E->xDestroy_signature)) == 0) {
+ porterDestroy(args);
+ }
+ else if (memcmp(E->xDestroy_signature, xDestroy_signatures[xDestroy_rtreeDestroy_enum], sizeof(E->xDestroy_signature)) == 0) {
+ rtreeDestroy(args);
+ }
+ else if (memcmp(E->xDestroy_signature, xDestroy_signatures[xDestroy_rtreeFreeCallback_enum], sizeof(E->xDestroy_signature)) == 0) {
+ rtreeFreeCallback(args);
+ }
+ else if (memcmp(E->xDestroy_signature, xDestroy_signatures[xDestroy_simpleDestroy_enum], sizeof(E->xDestroy_signature)) == 0) {
+ simpleDestroy(args);
+ }
+ else if (memcmp(E->xDestroy_signature, xDestroy_signatures[xDestroy_sqlite3_free_enum], sizeof(E->xDestroy_signature)) == 0) {
+ sqlite3_free(args);
+ }
+ else if (memcmp(E->xDestroy_signature, xDestroy_signatures[xDestroy_statDisconnect_enum], sizeof(E->xDestroy_signature)) == 0) {
+ statDisconnect(args);
+ }
+ else if (memcmp(E->xDestroy_signature, xDestroy_signatures[xDestroy_unicodeDestroy_enum], sizeof(E->xDestroy_signature)) == 0) {
+ unicodeDestroy(args);
+ }
+ else if (memcmp(E->xDestroy_signature, xDestroy_signatures[xDestroy_zipfileDisconnect_enum], sizeof(E->xDestroy_signature)) == 0) {
+ zipfileDisconnect(args);
+ }


// FP: xDestructor

@transform_standalone_xDestructor_arrow@
expression E;
identifier FP_NAME = xDestructor;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xDestructor_signature, xDestructor_signatures[xDestructor_0_enum], sizeof(E->xDestructor_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xDestructor_signature, xDestructor_signatures[xDestructor_rtreeMatchArgFree_enum], sizeof(E->xDestructor_signature)) == 0) {
+ rtreeMatchArgFree(args);
+ }
+ else if (memcmp(E->xDestructor_signature, xDestructor_signatures[xDestructor_sqlite3VdbeValueListFree_enum], sizeof(E->xDestructor_signature)) == 0) {
+ sqlite3VdbeValueListFree(args);
+ }


// FP: xDeviceCharacteristics

@transform_standalone_xDeviceCharacteristics_arrow@
expression E;
identifier FP_NAME = xDeviceCharacteristics;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xDeviceCharacteristics_signature, xDeviceCharacteristics_signatures[xDeviceCharacteristics_0_enum], sizeof(E->xDeviceCharacteristics_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xDeviceCharacteristics_signature, xDeviceCharacteristics_signatures[xDeviceCharacteristics_apndDeviceCharacteristics_enum], sizeof(E->xDeviceCharacteristics_signature)) == 0) {
+ apndDeviceCharacteristics(args);
+ }
+ else if (memcmp(E->xDeviceCharacteristics_signature, xDeviceCharacteristics_signatures[xDeviceCharacteristics_memdbDeviceCharacteristics_enum], sizeof(E->xDeviceCharacteristics_signature)) == 0) {
+ memdbDeviceCharacteristics(args);
+ }
+ else if (memcmp(E->xDeviceCharacteristics_signature, xDeviceCharacteristics_signatures[xDeviceCharacteristics_recoverVfsDeviceCharacteristics_enum], sizeof(E->xDeviceCharacteristics_signature)) == 0) {
+ recoverVfsDeviceCharacteristics(args);
+ }
+ else if (memcmp(E->xDeviceCharacteristics_signature, xDeviceCharacteristics_signatures[xDeviceCharacteristics_vfstraceDeviceCharacteristics_enum], sizeof(E->xDeviceCharacteristics_signature)) == 0) {
+ vfstraceDeviceCharacteristics(args);
+ }


// FP: xDisconnect

@transform_standalone_xDisconnect_arrow@
expression E;
identifier FP_NAME = xDisconnect;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xDisconnect_signature, xDisconnect_signatures[xDisconnect_bytecodevtabDisconnect_enum], sizeof(E->xDisconnect_signature)) == 0) {
+ bytecodevtabDisconnect(args);
+ }
+ else if (memcmp(E->xDisconnect_signature, xDisconnect_signatures[xDisconnect_completionDisconnect_enum], sizeof(E->xDisconnect_signature)) == 0) {
+ completionDisconnect(args);
+ }
+ else if (memcmp(E->xDisconnect_signature, xDisconnect_signatures[xDisconnect_dbdataDisconnect_enum], sizeof(E->xDisconnect_signature)) == 0) {
+ dbdataDisconnect(args);
+ }
+ else if (memcmp(E->xDisconnect_signature, xDisconnect_signatures[xDisconnect_dbpageDisconnect_enum], sizeof(E->xDisconnect_signature)) == 0) {
+ dbpageDisconnect(args);
+ }
+ else if (memcmp(E->xDisconnect_signature, xDisconnect_signatures[xDisconnect_expertDisconnect_enum], sizeof(E->xDisconnect_signature)) == 0) {
+ expertDisconnect(args);
+ }
+ else if (memcmp(E->xDisconnect_signature, xDisconnect_signatures[xDisconnect_fsdirDisconnect_enum], sizeof(E->xDisconnect_signature)) == 0) {
+ fsdirDisconnect(args);
+ }
+ else if (memcmp(E->xDisconnect_signature, xDisconnect_signatures[xDisconnect_fts3DisconnectMethod_enum], sizeof(E->xDisconnect_signature)) == 0) {
+ fts3DisconnectMethod(args);
+ }
+ else if (memcmp(E->xDisconnect_signature, xDisconnect_signatures[xDisconnect_fts3auxDisconnectMethod_enum], sizeof(E->xDisconnect_signature)) == 0) {
+ fts3auxDisconnectMethod(args);
+ }
+ else if (memcmp(E->xDisconnect_signature, xDisconnect_signatures[xDisconnect_fts3tokDisconnectMethod_enum], sizeof(E->xDisconnect_signature)) == 0) {
+ fts3tokDisconnectMethod(args);
+ }
+ else if (memcmp(E->xDisconnect_signature, xDisconnect_signatures[xDisconnect_jsonEachDisconnect_enum], sizeof(E->xDisconnect_signature)) == 0) {
+ jsonEachDisconnect(args);
+ }
+ else if (memcmp(E->xDisconnect_signature, xDisconnect_signatures[xDisconnect_pragmaVtabDisconnect_enum], sizeof(E->xDisconnect_signature)) == 0) {
+ pragmaVtabDisconnect(args);
+ }
+ else if (memcmp(E->xDisconnect_signature, xDisconnect_signatures[xDisconnect_rtreeDisconnect_enum], sizeof(E->xDisconnect_signature)) == 0) {
+ rtreeDisconnect(args);
+ }
+ else if (memcmp(E->xDisconnect_signature, xDisconnect_signatures[xDisconnect_seriesDisconnect_enum], sizeof(E->xDisconnect_signature)) == 0) {
+ seriesDisconnect(args);
+ }
+ else if (memcmp(E->xDisconnect_signature, xDisconnect_signatures[xDisconnect_statDisconnect_enum], sizeof(E->xDisconnect_signature)) == 0) {
+ statDisconnect(args);
+ }
+ else if (memcmp(E->xDisconnect_signature, xDisconnect_signatures[xDisconnect_stmtDisconnect_enum], sizeof(E->xDisconnect_signature)) == 0) {
+ stmtDisconnect(args);
+ }
+ else if (memcmp(E->xDisconnect_signature, xDisconnect_signatures[xDisconnect_zipfileDisconnect_enum], sizeof(E->xDisconnect_signature)) == 0) {
+ zipfileDisconnect(args);
+ }


// FP: xDlClose

@transform_standalone_xDlClose_arrow@
expression E;
identifier FP_NAME = xDlClose;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xDlClose_signature, xDlClose_signatures[xDlClose_0_enum], sizeof(E->xDlClose_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xDlClose_signature, xDlClose_signatures[xDlClose_apndDlClose_enum], sizeof(E->xDlClose_signature)) == 0) {
+ apndDlClose(args);
+ }
+ else if (memcmp(E->xDlClose_signature, xDlClose_signatures[xDlClose_memdbDlClose_enum], sizeof(E->xDlClose_signature)) == 0) {
+ memdbDlClose(args);
+ }
+ else if (memcmp(E->xDlClose_signature, xDlClose_signatures[xDlClose_unixDlClose_enum], sizeof(E->xDlClose_signature)) == 0) {
+ unixDlClose(args);
+ }


// FP: xDlError

@transform_standalone_xDlError_arrow@
expression E;
identifier FP_NAME = xDlError;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xDlError_signature, xDlError_signatures[xDlError_0_enum], sizeof(E->xDlError_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xDlError_signature, xDlError_signatures[xDlError_apndDlError_enum], sizeof(E->xDlError_signature)) == 0) {
+ apndDlError(args);
+ }
+ else if (memcmp(E->xDlError_signature, xDlError_signatures[xDlError_memdbDlError_enum], sizeof(E->xDlError_signature)) == 0) {
+ memdbDlError(args);
+ }
+ else if (memcmp(E->xDlError_signature, xDlError_signatures[xDlError_unixDlError_enum], sizeof(E->xDlError_signature)) == 0) {
+ unixDlError(args);
+ }


// FP: xDlOpen

@transform_standalone_xDlOpen_arrow@
expression E;
identifier FP_NAME = xDlOpen;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xDlOpen_signature, xDlOpen_signatures[xDlOpen_apndDlOpen_enum], sizeof(E->xDlOpen_signature)) == 0) {
+ apndDlOpen(args);
+ }
+ else if (memcmp(E->xDlOpen_signature, xDlOpen_signatures[xDlOpen_memdbDlOpen_enum], sizeof(E->xDlOpen_signature)) == 0) {
+ memdbDlOpen(args);
+ }
+ else if (memcmp(E->xDlOpen_signature, xDlOpen_signatures[xDlOpen_unixDlOpen_enum], sizeof(E->xDlOpen_signature)) == 0) {
+ unixDlOpen(args);
+ }


// FP: xDlSym

@transform_standalone_xDlSym_arrow@
expression E;
identifier FP_NAME = xDlSym;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xDlSym_signature, xDlSym_signatures[xDlSym_0_enum], sizeof(E->xDlSym_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xDlSym_signature, xDlSym_signatures[xDlSym_apndDlSym_enum], sizeof(E->xDlSym_signature)) == 0) {
+ apndDlSym(args);
+ }
+ else if (memcmp(E->xDlSym_signature, xDlSym_signatures[xDlSym_memdbDlSym_enum], sizeof(E->xDlSym_signature)) == 0) {
+ memdbDlSym(args);
+ }
+ else if (memcmp(E->xDlSym_signature, xDlSym_signatures[xDlSym_rbuVfsDlSym_enum], sizeof(E->xDlSym_signature)) == 0) {
+ rbuVfsDlSym(args);
+ }
+ else if (memcmp(E->xDlSym_signature, xDlSym_signatures[xDlSym_winDlSym_enum], sizeof(E->xDlSym_signature)) == 0) {
+ winDlSym(args);
+ }
+ else if (memcmp(E->xDlSym_signature, xDlSym_signatures[xDlSym_unixDlSym_enum], sizeof(E->xDlSym_signature)) == 0) {
+ unixDlSym(args);
+ }


// FP: xEof

@transform_standalone_xEof_arrow@
expression E;
identifier FP_NAME = xEof;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xEof_signature, xEof_signatures[xEof_bytecodevtabEof_enum], sizeof(E->xEof_signature)) == 0) {
+ bytecodevtabEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_completionEof_enum], sizeof(E->xEof_signature)) == 0) {
+ completionEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_dbdataEof_enum], sizeof(E->xEof_signature)) == 0) {
+ dbdataEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_dbpageEof_enum], sizeof(E->xEof_signature)) == 0) {
+ dbpageEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_expertEof_enum], sizeof(E->xEof_signature)) == 0) {
+ expertEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_fsdirEof_enum], sizeof(E->xEof_signature)) == 0) {
+ fsdirEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_fts3EofMethod_enum], sizeof(E->xEof_signature)) == 0) {
+ fts3EofMethod(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_fts3auxEofMethod_enum], sizeof(E->xEof_signature)) == 0) {
+ fts3auxEofMethod(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_fts3tokEofMethod_enum], sizeof(E->xEof_signature)) == 0) {
+ fts3tokEofMethod(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_jsonEachEof_enum], sizeof(E->xEof_signature)) == 0) {
+ jsonEachEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_pragmaVtabEof_enum], sizeof(E->xEof_signature)) == 0) {
+ pragmaVtabEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_rtreeEof_enum], sizeof(E->xEof_signature)) == 0) {
+ rtreeEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_seriesEof_enum], sizeof(E->xEof_signature)) == 0) {
+ seriesEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_statEof_enum], sizeof(E->xEof_signature)) == 0) {
+ statEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_stmtEof_enum], sizeof(E->xEof_signature)) == 0) {
+ stmtEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_zipfileEof_enum], sizeof(E->xEof_signature)) == 0) {
+ zipfileEof(args);
+ }


// FP: xExprCallback

@transform_standalone_xExprCallback_arrow@
expression E;
identifier FP_NAME = xExprCallback;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_agginfoPersistExprCb_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ agginfoPersistExprCb(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_aggregateIdxEprRefToColCallback_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ aggregateIdxEprRefToColCallback(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_analyzeAggregate_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ analyzeAggregate(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_checkConstraintExprNode_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ checkConstraintExprNode(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_codeCursorHintCheckExpr_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ codeCursorHintCheckExpr(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_codeCursorHintFixExpr_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ codeCursorHintFixExpr(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_codeCursorHintIsOrFunction_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ codeCursorHintIsOrFunction(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_disallowAggregatesInOrderByCb_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ disallowAggregatesInOrderByCb(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprColumnFlagUnion_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ exprColumnFlagUnion(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprIdxCover_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ exprIdxCover(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprNodeCanReturnSubtype_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ exprNodeCanReturnSubtype(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprNodeIsConstant_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ exprNodeIsConstant(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprNodeIsConstantOrGroupBy_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ exprNodeIsConstantOrGroupBy(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprNodeIsDeterministic_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ exprNodeIsDeterministic(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprRefToSrcList_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ exprRefToSrcList(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_fixExprCb_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ fixExprCb(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_gatherSelectWindowsCallback_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ gatherSelectWindowsCallback(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_havingToWhereExprCb_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ havingToWhereExprCb(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_impliesNotNullRow_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ impliesNotNullRow(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_incrAggDepth_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ incrAggDepth(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_markImmutableExprStep_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ markImmutableExprStep(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_propagateConstantExprRewrite_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ propagateConstantExprRewrite(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_recomputeColumnsUsedExpr_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ recomputeColumnsUsedExpr(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_renameColumnExprCb_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ renameColumnExprCb(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_renameQuotefixExprCb_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ renameQuotefixExprCb(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_renameTableExprCb_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ renameTableExprCb(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_renameUnmapExprCb_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ renameUnmapExprCb(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_renumberCursorsCb_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ renumberCursorsCb(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_resolveExprStep_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ resolveExprStep(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_resolveRemoveWindowsCb_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ resolveRemoveWindowsCb(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_selectCheckOnClausesExpr_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ selectCheckOnClausesExpr(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_selectWindowRewriteExprCb_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ selectWindowRewriteExprCb(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_sqlite3CursorRangeHintExprCheck_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ sqlite3CursorRangeHintExprCheck(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_sqlite3ExprWalkNoop_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ sqlite3ExprWalkNoop(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_sqlite3ReturningSubqueryVarSelect_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ sqlite3ReturningSubqueryVarSelect(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_sqlite3WindowExtraAggFuncDepth_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ sqlite3WindowExtraAggFuncDepth(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_whereIsCoveringIndexWalkCallback_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ whereIsCoveringIndexWalkCallback(args);
+ }


// FP: xFetch

@transform_standalone_xFetch_arrow@
expression E;
identifier FP_NAME = xFetch;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xFetch_signature, xFetch_signatures[xFetch_0_enum], sizeof(E->xFetch_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xFetch_signature, xFetch_signatures[xFetch_apndFetch_enum], sizeof(E->xFetch_signature)) == 0) {
+ apndFetch(args);
+ }
+ else if (memcmp(E->xFetch_signature, xFetch_signatures[xFetch_memdbFetch_enum], sizeof(E->xFetch_signature)) == 0) {
+ memdbFetch(args);
+ }
+ else if (memcmp(E->xFetch_signature, xFetch_signatures[xFetch_pcache1Fetch_enum], sizeof(E->xFetch_signature)) == 0) {
+ pcache1Fetch(args);
+ }
+ else if (memcmp(E->xFetch_signature, xFetch_signatures[xFetch_pcachetraceFetch_enum], sizeof(E->xFetch_signature)) == 0) {
+ pcachetraceFetch(args);
+ }
+ else if (memcmp(E->xFetch_signature, xFetch_signatures[xFetch_recoverVfsFetch_enum], sizeof(E->xFetch_signature)) == 0) {
+ recoverVfsFetch(args);
+ }


// FP: xFileControl

@transform_standalone_xFileControl_arrow@
expression E;
identifier FP_NAME = xFileControl;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xFileControl_signature, xFileControl_signatures[xFileControl_0_enum], sizeof(E->xFileControl_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xFileControl_signature, xFileControl_signatures[xFileControl_apndFileControl_enum], sizeof(E->xFileControl_signature)) == 0) {
+ apndFileControl(args);
+ }
+ else if (memcmp(E->xFileControl_signature, xFileControl_signatures[xFileControl_memdbFileControl_enum], sizeof(E->xFileControl_signature)) == 0) {
+ memdbFileControl(args);
+ }
+ else if (memcmp(E->xFileControl_signature, xFileControl_signatures[xFileControl_recoverVfsFileControl_enum], sizeof(E->xFileControl_signature)) == 0) {
+ recoverVfsFileControl(args);
+ }
+ else if (memcmp(E->xFileControl_signature, xFileControl_signatures[xFileControl_vfstraceFileControl_enum], sizeof(E->xFileControl_signature)) == 0) {
+ vfstraceFileControl(args);
+ }


// FP: xFileSize

@transform_standalone_xFileSize_arrow@
expression E;
identifier FP_NAME = xFileSize;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xFileSize_signature, xFileSize_signatures[xFileSize_apndFileSize_enum], sizeof(E->xFileSize_signature)) == 0) {
+ apndFileSize(args);
+ }
+ else if (memcmp(E->xFileSize_signature, xFileSize_signatures[xFileSize_memdbFileSize_enum], sizeof(E->xFileSize_signature)) == 0) {
+ memdbFileSize(args);
+ }
+ else if (memcmp(E->xFileSize_signature, xFileSize_signatures[xFileSize_memjrnlFileSize_enum], sizeof(E->xFileSize_signature)) == 0) {
+ memjrnlFileSize(args);
+ }
+ else if (memcmp(E->xFileSize_signature, xFileSize_signatures[xFileSize_recoverVfsFileSize_enum], sizeof(E->xFileSize_signature)) == 0) {
+ recoverVfsFileSize(args);
+ }
+ else if (memcmp(E->xFileSize_signature, xFileSize_signatures[xFileSize_vfstraceFileSize_enum], sizeof(E->xFileSize_signature)) == 0) {
+ vfstraceFileSize(args);
+ }


// FP: xFilter

@transform_standalone_xFilter_arrow@
expression E;
identifier FP_NAME = xFilter;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_bytecodevtabFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ bytecodevtabFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_completionFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ completionFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_dbdataFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ dbdataFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_dbpageFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ dbpageFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_expertFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ expertFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_fsdirFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ fsdirFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_fts3FilterMethod_enum], sizeof(E->xFilter_signature)) == 0) {
+ fts3FilterMethod(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_fts3auxFilterMethod_enum], sizeof(E->xFilter_signature)) == 0) {
+ fts3auxFilterMethod(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_fts3tokFilterMethod_enum], sizeof(E->xFilter_signature)) == 0) {
+ fts3tokFilterMethod(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_geopolyFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ geopolyFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_jsonEachFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ jsonEachFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_pragmaVtabFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ pragmaVtabFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_rtreeFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ rtreeFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_seriesFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ seriesFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_statFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ statFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_stmtFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ stmtFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_zipfileFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ zipfileFilter(args);
+ }


// FP: xFinalize

@transform_standalone_xFinalize_arrow@
expression E;
identifier FP_NAME = xFinalize;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xFinalize_signature, xFinalize_signatures[xFinalize_0_enum], sizeof(E->xFinalize_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xFinalize_signature, xFinalize_signatures[xFinalize_decimalSumFinalize_enum], sizeof(E->xFinalize_signature)) == 0) {
+ decimalSumFinalize(args);
+ }
+ else if (memcmp(E->xFinalize_signature, xFinalize_signatures[xFinalize_dummyUDFvalue_enum], sizeof(E->xFinalize_signature)) == 0) {
+ dummyUDFvalue(args);
+ }
+ else if (memcmp(E->xFinalize_signature, xFinalize_signatures[xFinalize_percentFinal_enum], sizeof(E->xFinalize_signature)) == 0) {
+ percentFinal(args);
+ }
+ else if (memcmp(E->xFinalize_signature, xFinalize_signatures[xFinalize_sha3AggFinal_enum], sizeof(E->xFinalize_signature)) == 0) {
+ sha3AggFinal(args);
+ }
+ else if (memcmp(E->xFinalize_signature, xFinalize_signatures[xFinalize_zipfileFinal_enum], sizeof(E->xFinalize_signature)) == 0) {
+ zipfileFinal(args);
+ }


// FP: xFindFunction

@transform_standalone_xFindFunction_arrow@
expression E;
identifier FP_NAME = xFindFunction;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xFindFunction_signature, xFindFunction_signatures[xFindFunction_0_enum], sizeof(E->xFindFunction_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xFindFunction_signature, xFindFunction_signatures[xFindFunction_fts3FindFunctionMethod_enum], sizeof(E->xFindFunction_signature)) == 0) {
+ fts3FindFunctionMethod(args);
+ }
+ else if (memcmp(E->xFindFunction_signature, xFindFunction_signatures[xFindFunction_zipfileFindFunction_enum], sizeof(E->xFindFunction_signature)) == 0) {
+ zipfileFindFunction(args);
+ }


// FP: xFree

@transform_standalone_xFree_arrow@
expression E;
identifier FP_NAME = xFree;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xFree_signature, xFree_signatures[xFree_memtraceFree_enum], sizeof(E->xFree_signature)) == 0) {
+ memtraceFree(args);
+ }
+ else if (memcmp(E->xFree_signature, xFree_signatures[xFree_sqlite3MemFree_enum], sizeof(E->xFree_signature)) == 0) {
+ sqlite3MemFree(args);
+ }


// FP: xFreeSchema

@transform_standalone_xFreeSchema_arrow@
expression E;
identifier FP_NAME = xFreeSchema;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xFreeSchema_signature, xFreeSchema_signatures[xFreeSchema_0_enum], sizeof(E->xFreeSchema_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xFreeSchema_signature, xFreeSchema_signatures[xFreeSchema_sqlite3RCStrUnref_enum], sizeof(E->xFreeSchema_signature)) == 0) {
+ sqlite3RCStrUnref(args);
+ }
+ else if (memcmp(E->xFreeSchema_signature, xFreeSchema_signatures[xFreeSchema_sqlite3SchemaClear_enum], sizeof(E->xFreeSchema_signature)) == 0) {
+ sqlite3SchemaClear(args);
+ }


// FP: xFullPathname

@transform_standalone_xFullPathname_arrow@
expression E;
identifier FP_NAME = xFullPathname;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xFullPathname_signature, xFullPathname_signatures[xFullPathname_apndFullPathname_enum], sizeof(E->xFullPathname_signature)) == 0) {
+ apndFullPathname(args);
+ }
+ else if (memcmp(E->xFullPathname_signature, xFullPathname_signatures[xFullPathname_memdbFullPathname_enum], sizeof(E->xFullPathname_signature)) == 0) {
+ memdbFullPathname(args);
+ }
+ else if (memcmp(E->xFullPathname_signature, xFullPathname_signatures[xFullPathname_vfstraceFullPathname_enum], sizeof(E->xFullPathname_signature)) == 0) {
+ vfstraceFullPathname(args);
+ }
+ else if (memcmp(E->xFullPathname_signature, xFullPathname_signatures[xFullPathname_unixFullPathname_enum], sizeof(E->xFullPathname_signature)) == 0) {
+ unixFullPathname(args);
+ }


// FP: xFunc

@transform_standalone_xFunc_arrow@
expression E;
identifier FP_NAME = xFunc;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_0_enum], sizeof(E->xFunc_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_base64_enum], sizeof(E->xFunc_signature)) == 0) {
+ base64(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_base85_enum], sizeof(E->xFunc_signature)) == 0) {
+ base85(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_dummyUDF_enum], sizeof(E->xFunc_signature)) == 0) {
+ dummyUDF(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_editFunc_enum], sizeof(E->xFunc_signature)) == 0) {
+ editFunc(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_fts3AllocateMSI_enum], sizeof(E->xFunc_signature)) == 0) {
+ fts3AllocateMSI(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_fts3ExprGlobalHitsCb_enum], sizeof(E->xFunc_signature)) == 0) {
+ fts3ExprGlobalHitsCb(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_fts3ExprLoadDoclistsCb_enum], sizeof(E->xFunc_signature)) == 0) {
+ fts3ExprLoadDoclistsCb(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_fts3ExprLocalHitsCb_enum], sizeof(E->xFunc_signature)) == 0) {
+ fts3ExprLocalHitsCb(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_fts3ExprPhraseCountCb_enum], sizeof(E->xFunc_signature)) == 0) {
+ fts3ExprPhraseCountCb(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_fts3ExprRestartIfCb_enum], sizeof(E->xFunc_signature)) == 0) {
+ fts3ExprRestartIfCb(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_fts3ExprTermOffsetInit_enum], sizeof(E->xFunc_signature)) == 0) {
+ fts3ExprTermOffsetInit(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_fts3ExprTest_enum], sizeof(E->xFunc_signature)) == 0) {
+ fts3ExprTest(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_fts3ExprTestRebalance_enum], sizeof(E->xFunc_signature)) == 0) {
+ fts3ExprTestRebalance(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_fts3MatchinfoLcsCb_enum], sizeof(E->xFunc_signature)) == 0) {
+ fts3MatchinfoLcsCb(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_fts3SnippetFindPositions_enum], sizeof(E->xFunc_signature)) == 0) {
+ fts3SnippetFindPositions(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_fts3TokenizerFunc_enum], sizeof(E->xFunc_signature)) == 0) {
+ fts3TokenizerFunc(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_geomCallback_enum], sizeof(E->xFunc_signature)) == 0) {
+ geomCallback(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_idxRemFunc_enum], sizeof(E->xFunc_signature)) == 0) {
+ idxRemFunc(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_idxSampleFunc_enum], sizeof(E->xFunc_signature)) == 0) {
+ idxSampleFunc(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_intTestFunc_enum], sizeof(E->xFunc_signature)) == 0) {
+ intTestFunc(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_intckParseCreateIndexFunc_enum], sizeof(E->xFunc_signature)) == 0) {
+ intckParseCreateIndexFunc(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_is_base85_enum], sizeof(E->xFunc_signature)) == 0) {
+ is_base85(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_lsModeFunc_enum], sizeof(E->xFunc_signature)) == 0) {
+ lsModeFunc(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_rbuFossilDeltaFunc_enum], sizeof(E->xFunc_signature)) == 0) {
+ rbuFossilDeltaFunc(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_rbuIndexCntFunc_enum], sizeof(E->xFunc_signature)) == 0) {
+ rbuIndexCntFunc(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_rbuTargetNameFunc_enum], sizeof(E->xFunc_signature)) == 0) {
+ rbuTargetNameFunc(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_rbuTmpInsertFunc_enum], sizeof(E->xFunc_signature)) == 0) {
+ rbuTmpInsertFunc(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_re_bytecode_func_enum], sizeof(E->xFunc_signature)) == 0) {
+ re_bytecode_func(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_re_sql_func_enum], sizeof(E->xFunc_signature)) == 0) {
+ re_sql_func(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_readfileFunc_enum], sizeof(E->xFunc_signature)) == 0) {
+ readfileFunc(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_rtreecheck_enum], sizeof(E->xFunc_signature)) == 0) {
+ rtreecheck(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_rtreedepth_enum], sizeof(E->xFunc_signature)) == 0) {
+ rtreedepth(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_rtreenode_enum], sizeof(E->xFunc_signature)) == 0) {
+ rtreenode(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_sha1Func_enum], sizeof(E->xFunc_signature)) == 0) {
+ sha1Func(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_sha1QueryFunc_enum], sizeof(E->xFunc_signature)) == 0) {
+ sha1QueryFunc(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_sha3Func_enum], sizeof(E->xFunc_signature)) == 0) {
+ sha3Func(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_sha3QueryFunc_enum], sizeof(E->xFunc_signature)) == 0) {
+ sha3QueryFunc(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_shellAddSchemaName_enum], sizeof(E->xFunc_signature)) == 0) {
+ shellAddSchemaName(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_shellDtostr_enum], sizeof(E->xFunc_signature)) == 0) {
+ shellDtostr(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_shellFkeyCollateClause_enum], sizeof(E->xFunc_signature)) == 0) {
+ shellFkeyCollateClause(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_shellModuleSchema_enum], sizeof(E->xFunc_signature)) == 0) {
+ shellModuleSchema(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_shellPutsFunc_enum], sizeof(E->xFunc_signature)) == 0) {
+ shellPutsFunc(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_shellStrtod_enum], sizeof(E->xFunc_signature)) == 0) {
+ shellStrtod(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_shellUSleepFunc_enum], sizeof(E->xFunc_signature)) == 0) {
+ shellUSleepFunc(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_sqlarCompressFunc_enum], sizeof(E->xFunc_signature)) == 0) {
+ sqlarCompressFunc(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_sqlarUncompressFunc_enum], sizeof(E->xFunc_signature)) == 0) {
+ sqlarUncompressFunc(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_sqlite3InvalidFunction_enum], sizeof(E->xFunc_signature)) == 0) {
+ sqlite3InvalidFunction(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_stmtrandFunc_enum], sizeof(E->xFunc_signature)) == 0) {
+ stmtrandFunc(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_testFunc_enum], sizeof(E->xFunc_signature)) == 0) {
+ testFunc(args);
+ }
+ else if (memcmp(E->xFunc_signature, xFunc_signatures[xFunc_writefileFunc_enum], sizeof(E->xFunc_signature)) == 0) {
+ writefileFunc(args);
+ }


// FP: xGeom

@transform_standalone_xGeom_arrow@
expression E;
identifier FP_NAME = xGeom;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ 0;


// FP: xGet

@transform_standalone_xGet_arrow@
expression E;
identifier FP_NAME = xGet;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xGet_signature, xGet_signatures[xGet_getPageError_enum], sizeof(E->xGet_signature)) == 0) {
+ getPageError(args);
+ }
+ else if (memcmp(E->xGet_signature, xGet_signatures[xGet_getPageMMap_enum], sizeof(E->xGet_signature)) == 0) {
+ getPageMMap(args);
+ }
+ else if (memcmp(E->xGet_signature, xGet_signatures[xGet_getPageNormal_enum], sizeof(E->xGet_signature)) == 0) {
+ getPageNormal(args);
+ }


// FP: xGetLastError

@transform_standalone_xGetLastError_arrow@
expression E;
identifier FP_NAME = xGetLastError;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xGetLastError_signature, xGetLastError_signatures[xGetLastError_0_enum], sizeof(E->xGetLastError_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xGetLastError_signature, xGetLastError_signatures[xGetLastError_apndGetLastError_enum], sizeof(E->xGetLastError_signature)) == 0) {
+ apndGetLastError(args);
+ }
+ else if (memcmp(E->xGetLastError_signature, xGetLastError_signatures[xGetLastError_memdbGetLastError_enum], sizeof(E->xGetLastError_signature)) == 0) {
+ memdbGetLastError(args);
+ }
+ else if (memcmp(E->xGetLastError_signature, xGetLastError_signatures[xGetLastError_unixGetLastError_enum], sizeof(E->xGetLastError_signature)) == 0) {
+ unixGetLastError(args);
+ }


// FP: xGetSystemCall

@transform_standalone_xGetSystemCall_arrow@
expression E;
identifier FP_NAME = xGetSystemCall;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xGetSystemCall_signature, xGetSystemCall_signatures[xGetSystemCall_0_enum], sizeof(E->xGetSystemCall_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xGetSystemCall_signature, xGetSystemCall_signatures[xGetSystemCall_apndGetSystemCall_enum], sizeof(E->xGetSystemCall_signature)) == 0) {
+ apndGetSystemCall(args);
+ }
+ else if (memcmp(E->xGetSystemCall_signature, xGetSystemCall_signatures[xGetSystemCall_unixGetSystemCall_enum], sizeof(E->xGetSystemCall_signature)) == 0) {
+ unixGetSystemCall(args);
+ }


// FP: xInit

@transform_standalone_xInit_arrow@
expression E;
identifier FP_NAME = xInit;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xInit_signature, xInit_signatures[xInit_memtraceInit_enum], sizeof(E->xInit_signature)) == 0) {
+ memtraceInit(args);
+ }
+ else if (memcmp(E->xInit_signature, xInit_signatures[xInit_pcache1Init_enum], sizeof(E->xInit_signature)) == 0) {
+ pcache1Init(args);
+ }
+ else if (memcmp(E->xInit_signature, xInit_signatures[xInit_pcachetraceInit_enum], sizeof(E->xInit_signature)) == 0) {
+ pcachetraceInit(args);
+ }
+ else if (memcmp(E->xInit_signature, xInit_signatures[xInit_sqlite3MemInit_enum], sizeof(E->xInit_signature)) == 0) {
+ sqlite3MemInit(args);
+ }


// FP: xInput

@transform_standalone_xInput_arrow@
expression E;
identifier FP_NAME = xInput;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ 0;


// FP: xIntegrity

@transform_standalone_xIntegrity_arrow@
expression E;
identifier FP_NAME = xIntegrity;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xIntegrity_signature, xIntegrity_signatures[xIntegrity_0_enum], sizeof(E->xIntegrity_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xIntegrity_signature, xIntegrity_signatures[xIntegrity_fts3IntegrityMethod_enum], sizeof(E->xIntegrity_signature)) == 0) {
+ fts3IntegrityMethod(args);
+ }
+ else if (memcmp(E->xIntegrity_signature, xIntegrity_signatures[xIntegrity_rtreeIntegrity_enum], sizeof(E->xIntegrity_signature)) == 0) {
+ rtreeIntegrity(args);
+ }


// FP: xInverse

@transform_standalone_xInverse_arrow@
expression E;
identifier FP_NAME = xInverse;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xInverse_signature, xInverse_signatures[xInverse_0_enum], sizeof(E->xInverse_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xInverse_signature, xInverse_signatures[xInverse_decimalSumInverse_enum], sizeof(E->xInverse_signature)) == 0) {
+ decimalSumInverse(args);
+ }
+ else if (memcmp(E->xInverse_signature, xInverse_signatures[xInverse_percentInverse_enum], sizeof(E->xInverse_signature)) == 0) {
+ percentInverse(args);
+ }


// FP: xLanguageid

@transform_standalone_xLanguageid_arrow@
expression E;
identifier FP_NAME = xLanguageid;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ 0;


// FP: xLock

@transform_standalone_xLock_arrow@
expression E;
identifier FP_NAME = xLock;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xLock_signature, xLock_signatures[xLock_0_enum], sizeof(E->xLock_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xLock_signature, xLock_signatures[xLock_apndLock_enum], sizeof(E->xLock_signature)) == 0) {
+ apndLock(args);
+ }
+ else if (memcmp(E->xLock_signature, xLock_signatures[xLock_memdbLock_enum], sizeof(E->xLock_signature)) == 0) {
+ memdbLock(args);
+ }
+ else if (memcmp(E->xLock_signature, xLock_signatures[xLock_recoverVfsLock_enum], sizeof(E->xLock_signature)) == 0) {
+ recoverVfsLock(args);
+ }
+ else if (memcmp(E->xLock_signature, xLock_signatures[xLock_vfstraceLock_enum], sizeof(E->xLock_signature)) == 0) {
+ vfstraceLock(args);
+ }


// FP: xLog

@transform_standalone_xLog_arrow@
expression E;
identifier FP_NAME = xLog;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ 0;


// FP: xMalloc

@transform_standalone_xMalloc_arrow@
expression E;
identifier FP_NAME = xMalloc;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xMalloc_signature, xMalloc_signatures[xMalloc_memtraceMalloc_enum], sizeof(E->xMalloc_signature)) == 0) {
+ memtraceMalloc(args);
+ }
+ else if (memcmp(E->xMalloc_signature, xMalloc_signatures[xMalloc_sqlite3MemMalloc_enum], sizeof(E->xMalloc_signature)) == 0) {
+ sqlite3MemMalloc(args);
+ }


// FP: xMutexAlloc

@transform_standalone_xMutexAlloc_arrow@
expression E;
identifier FP_NAME = xMutexAlloc;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_checkMutexAlloc_enum], sizeof(E->xMutexAlloc_signature)) == 0) {
+ checkMutexAlloc(args);
+ }
+ else if (memcmp(E->xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_debugMutexAlloc_enum], sizeof(E->xMutexAlloc_signature)) == 0) {
+ debugMutexAlloc(args);
+ }
+ else if (memcmp(E->xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_noopMutexAlloc_enum], sizeof(E->xMutexAlloc_signature)) == 0) {
+ noopMutexAlloc(args);
+ }
+ else if (memcmp(E->xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_pthreadMutexAlloc_enum], sizeof(E->xMutexAlloc_signature)) == 0) {
+ pthreadMutexAlloc(args);
+ }
+ else if (memcmp(E->xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_winMutexAlloc_enum], sizeof(E->xMutexAlloc_signature)) == 0) {
+ winMutexAlloc(args);
+ }


// FP: xMutexEnd

@transform_standalone_xMutexEnd_arrow@
expression E;
identifier FP_NAME = xMutexEnd;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_checkMutexEnd_enum], sizeof(E->xMutexEnd_signature)) == 0) {
+ checkMutexEnd(args);
+ }
+ else if (memcmp(E->xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_debugMutexEnd_enum], sizeof(E->xMutexEnd_signature)) == 0) {
+ debugMutexEnd(args);
+ }
+ else if (memcmp(E->xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_noopMutexEnd_enum], sizeof(E->xMutexEnd_signature)) == 0) {
+ noopMutexEnd(args);
+ }
+ else if (memcmp(E->xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_pthreadMutexEnd_enum], sizeof(E->xMutexEnd_signature)) == 0) {
+ pthreadMutexEnd(args);
+ }
+ else if (memcmp(E->xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_winMutexEnd_enum], sizeof(E->xMutexEnd_signature)) == 0) {
+ winMutexEnd(args);
+ }


// FP: xMutexEnter

@transform_standalone_xMutexEnter_arrow@
expression E;
identifier FP_NAME = xMutexEnter;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_checkMutexEnter_enum], sizeof(E->xMutexEnter_signature)) == 0) {
+ checkMutexEnter(args);
+ }
+ else if (memcmp(E->xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_debugMutexEnter_enum], sizeof(E->xMutexEnter_signature)) == 0) {
+ debugMutexEnter(args);
+ }
+ else if (memcmp(E->xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_noopMutexEnter_enum], sizeof(E->xMutexEnter_signature)) == 0) {
+ noopMutexEnter(args);
+ }
+ else if (memcmp(E->xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_pthreadMutexEnter_enum], sizeof(E->xMutexEnter_signature)) == 0) {
+ pthreadMutexEnter(args);
+ }
+ else if (memcmp(E->xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_winMutexEnter_enum], sizeof(E->xMutexEnter_signature)) == 0) {
+ winMutexEnter(args);
+ }


// FP: xMutexFree

@transform_standalone_xMutexFree_arrow@
expression E;
identifier FP_NAME = xMutexFree;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xMutexFree_signature, xMutexFree_signatures[xMutexFree_checkMutexFree_enum], sizeof(E->xMutexFree_signature)) == 0) {
+ checkMutexFree(args);
+ }
+ else if (memcmp(E->xMutexFree_signature, xMutexFree_signatures[xMutexFree_debugMutexFree_enum], sizeof(E->xMutexFree_signature)) == 0) {
+ debugMutexFree(args);
+ }
+ else if (memcmp(E->xMutexFree_signature, xMutexFree_signatures[xMutexFree_noopMutexFree_enum], sizeof(E->xMutexFree_signature)) == 0) {
+ noopMutexFree(args);
+ }
+ else if (memcmp(E->xMutexFree_signature, xMutexFree_signatures[xMutexFree_pthreadMutexFree_enum], sizeof(E->xMutexFree_signature)) == 0) {
+ pthreadMutexFree(args);
+ }
+ else if (memcmp(E->xMutexFree_signature, xMutexFree_signatures[xMutexFree_winMutexFree_enum], sizeof(E->xMutexFree_signature)) == 0) {
+ winMutexFree(args);
+ }


// FP: xMutexHeld

@transform_standalone_xMutexHeld_arrow@
expression E;
identifier FP_NAME = xMutexHeld;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xMutexHeld_signature, xMutexHeld_signatures[xMutexHeld_0_enum], sizeof(E->xMutexHeld_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xMutexHeld_signature, xMutexHeld_signatures[xMutexHeld_debugMutexHeld_enum], sizeof(E->xMutexHeld_signature)) == 0) {
+ debugMutexHeld(args);
+ }


// FP: xMutexInit

@transform_standalone_xMutexInit_arrow@
expression E;
identifier FP_NAME = xMutexInit;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xMutexInit_signature, xMutexInit_signatures[xMutexInit_checkMutexInit_enum], sizeof(E->xMutexInit_signature)) == 0) {
+ checkMutexInit(args);
+ }
+ else if (memcmp(E->xMutexInit_signature, xMutexInit_signatures[xMutexInit_debugMutexInit_enum], sizeof(E->xMutexInit_signature)) == 0) {
+ debugMutexInit(args);
+ }
+ else if (memcmp(E->xMutexInit_signature, xMutexInit_signatures[xMutexInit_noopMutexInit_enum], sizeof(E->xMutexInit_signature)) == 0) {
+ noopMutexInit(args);
+ }
+ else if (memcmp(E->xMutexInit_signature, xMutexInit_signatures[xMutexInit_pthreadMutexInit_enum], sizeof(E->xMutexInit_signature)) == 0) {
+ pthreadMutexInit(args);
+ }
+ else if (memcmp(E->xMutexInit_signature, xMutexInit_signatures[xMutexInit_winMutexInit_enum], sizeof(E->xMutexInit_signature)) == 0) {
+ winMutexInit(args);
+ }


// FP: xMutexLeave

@transform_standalone_xMutexLeave_arrow@
expression E;
identifier FP_NAME = xMutexLeave;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_checkMutexLeave_enum], sizeof(E->xMutexLeave_signature)) == 0) {
+ checkMutexLeave(args);
+ }
+ else if (memcmp(E->xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_debugMutexLeave_enum], sizeof(E->xMutexLeave_signature)) == 0) {
+ debugMutexLeave(args);
+ }
+ else if (memcmp(E->xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_noopMutexLeave_enum], sizeof(E->xMutexLeave_signature)) == 0) {
+ noopMutexLeave(args);
+ }
+ else if (memcmp(E->xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_pthreadMutexLeave_enum], sizeof(E->xMutexLeave_signature)) == 0) {
+ pthreadMutexLeave(args);
+ }
+ else if (memcmp(E->xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_winMutexLeave_enum], sizeof(E->xMutexLeave_signature)) == 0) {
+ winMutexLeave(args);
+ }


// FP: xMutexNotheld

@transform_standalone_xMutexNotheld_arrow@
expression E;
identifier FP_NAME = xMutexNotheld;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xMutexNotheld_signature, xMutexNotheld_signatures[xMutexNotheld_0_enum], sizeof(E->xMutexNotheld_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xMutexNotheld_signature, xMutexNotheld_signatures[xMutexNotheld_debugMutexNotheld_enum], sizeof(E->xMutexNotheld_signature)) == 0) {
+ debugMutexNotheld(args);
+ }


// FP: xMutexTry

@transform_standalone_xMutexTry_arrow@
expression E;
identifier FP_NAME = xMutexTry;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xMutexTry_signature, xMutexTry_signatures[xMutexTry_checkMutexTry_enum], sizeof(E->xMutexTry_signature)) == 0) {
+ checkMutexTry(args);
+ }
+ else if (memcmp(E->xMutexTry_signature, xMutexTry_signatures[xMutexTry_debugMutexTry_enum], sizeof(E->xMutexTry_signature)) == 0) {
+ debugMutexTry(args);
+ }
+ else if (memcmp(E->xMutexTry_signature, xMutexTry_signatures[xMutexTry_noopMutexTry_enum], sizeof(E->xMutexTry_signature)) == 0) {
+ noopMutexTry(args);
+ }
+ else if (memcmp(E->xMutexTry_signature, xMutexTry_signatures[xMutexTry_pthreadMutexTry_enum], sizeof(E->xMutexTry_signature)) == 0) {
+ pthreadMutexTry(args);
+ }
+ else if (memcmp(E->xMutexTry_signature, xMutexTry_signatures[xMutexTry_winMutexTry_enum], sizeof(E->xMutexTry_signature)) == 0) {
+ winMutexTry(args);
+ }


// FP: xNew

@transform_standalone_xNew_arrow@
expression E;
identifier FP_NAME = xNew;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xNew_signature, xNew_signatures[xNew_sessionDiffNew_enum], sizeof(E->xNew_signature)) == 0) {
+ sessionDiffNew(args);
+ }
+ else if (memcmp(E->xNew_signature, xNew_signatures[xNew_sessionPreupdateNew_enum], sizeof(E->xNew_signature)) == 0) {
+ sessionPreupdateNew(args);
+ }
+ else if (memcmp(E->xNew_signature, xNew_signatures[xNew_sessionStat1New_enum], sizeof(E->xNew_signature)) == 0) {
+ sessionStat1New(args);
+ }


// FP: xNext

@transform_standalone_xNext_arrow@
expression E;
identifier FP_NAME = xNext;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xNext_signature, xNext_signatures[xNext_0_enum], sizeof(E->xNext_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_bytecodevtabNext_enum], sizeof(E->xNext_signature)) == 0) {
+ bytecodevtabNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_completionNext_enum], sizeof(E->xNext_signature)) == 0) {
+ completionNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_dbdataNext_enum], sizeof(E->xNext_signature)) == 0) {
+ dbdataNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_dbpageNext_enum], sizeof(E->xNext_signature)) == 0) {
+ dbpageNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_expertNext_enum], sizeof(E->xNext_signature)) == 0) {
+ expertNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_fsdirNext_enum], sizeof(E->xNext_signature)) == 0) {
+ fsdirNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_fts3NextMethod_enum], sizeof(E->xNext_signature)) == 0) {
+ fts3NextMethod(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_fts3auxNextMethod_enum], sizeof(E->xNext_signature)) == 0) {
+ fts3auxNextMethod(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_fts3tokNextMethod_enum], sizeof(E->xNext_signature)) == 0) {
+ fts3tokNextMethod(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_jsonEachNext_enum], sizeof(E->xNext_signature)) == 0) {
+ jsonEachNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_porterNext_enum], sizeof(E->xNext_signature)) == 0) {
+ porterNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_pragmaVtabNext_enum], sizeof(E->xNext_signature)) == 0) {
+ pragmaVtabNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_rtreeNext_enum], sizeof(E->xNext_signature)) == 0) {
+ rtreeNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_seriesNext_enum], sizeof(E->xNext_signature)) == 0) {
+ seriesNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_simpleNext_enum], sizeof(E->xNext_signature)) == 0) {
+ simpleNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_statNext_enum], sizeof(E->xNext_signature)) == 0) {
+ statNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_stmtNext_enum], sizeof(E->xNext_signature)) == 0) {
+ stmtNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_unicodeNext_enum], sizeof(E->xNext_signature)) == 0) {
+ unicodeNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_zipfileNext_enum], sizeof(E->xNext_signature)) == 0) {
+ zipfileNext(args);
+ }


// FP: xNextSystemCall

@transform_standalone_xNextSystemCall_arrow@
expression E;
identifier FP_NAME = xNextSystemCall;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xNextSystemCall_signature, xNextSystemCall_signatures[xNextSystemCall_0_enum], sizeof(E->xNextSystemCall_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xNextSystemCall_signature, xNextSystemCall_signatures[xNextSystemCall_apndNextSystemCall_enum], sizeof(E->xNextSystemCall_signature)) == 0) {
+ apndNextSystemCall(args);
+ }
+ else if (memcmp(E->xNextSystemCall_signature, xNextSystemCall_signatures[xNextSystemCall_rbuVfsGetLastError_enum], sizeof(E->xNextSystemCall_signature)) == 0) {
+ rbuVfsGetLastError(args);
+ }
+ else if (memcmp(E->xNextSystemCall_signature, xNextSystemCall_signatures[xNextSystemCall_unixNextSystemCall_enum], sizeof(E->xNextSystemCall_signature)) == 0) {
+ unixNextSystemCall(args);
+ }


// FP: xOld

@transform_standalone_xOld_arrow@
expression E;
identifier FP_NAME = xOld;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xOld_signature, xOld_signatures[xOld_sessionDiffOld_enum], sizeof(E->xOld_signature)) == 0) {
+ sessionDiffOld(args);
+ }
+ else if (memcmp(E->xOld_signature, xOld_signatures[xOld_sessionPreupdateOld_enum], sizeof(E->xOld_signature)) == 0) {
+ sessionPreupdateOld(args);
+ }
+ else if (memcmp(E->xOld_signature, xOld_signatures[xOld_sessionStat1Old_enum], sizeof(E->xOld_signature)) == 0) {
+ sessionStat1Old(args);
+ }


// FP: xOpen

@transform_standalone_xOpen_arrow@
expression E;
identifier FP_NAME = xOpen;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_apndOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ apndOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_bytecodevtabOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ bytecodevtabOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_completionOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ completionOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_dbdataOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ dbdataOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_dbpageOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ dbpageOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_expertOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ expertOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_fsdirOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ fsdirOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_fts3OpenMethod_enum], sizeof(E->xOpen_signature)) == 0) {
+ fts3OpenMethod(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_fts3auxOpenMethod_enum], sizeof(E->xOpen_signature)) == 0) {
+ fts3auxOpenMethod(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_fts3tokOpenMethod_enum], sizeof(E->xOpen_signature)) == 0) {
+ fts3tokOpenMethod(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_jsonEachOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ jsonEachOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_memdbOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ memdbOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_porterOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ porterOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_pragmaVtabOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ pragmaVtabOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_rtreeOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ rtreeOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_seriesOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ seriesOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_simpleOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ simpleOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_statOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ statOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_stmtOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ stmtOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_unicodeOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ unicodeOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_vfstraceOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ vfstraceOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_zipfileOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ zipfileOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_unixOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ unixOpen(args);
+ }


// FP: xOut

@transform_standalone_xOut_arrow@
expression E;
identifier FP_NAME = xOut;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ vfstraceOut(args);


// FP: xPagecount

@transform_standalone_xPagecount_arrow@
expression E;
identifier FP_NAME = xPagecount;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xPagecount_signature, xPagecount_signatures[xPagecount_pcache1Pagecount_enum], sizeof(E->xPagecount_signature)) == 0) {
+ pcache1Pagecount(args);
+ }
+ else if (memcmp(E->xPagecount_signature, xPagecount_signatures[xPagecount_pcachetracePagecount_enum], sizeof(E->xPagecount_signature)) == 0) {
+ pcachetracePagecount(args);
+ }


// FP: xParseCell

@transform_standalone_xParseCell_arrow@
expression E;
identifier FP_NAME = xParseCell;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xParseCell_signature, xParseCell_signatures[xParseCell_btreeParseCellPtr_enum], sizeof(E->xParseCell_signature)) == 0) {
+ btreeParseCellPtr(args);
+ }
+ else if (memcmp(E->xParseCell_signature, xParseCell_signatures[xParseCell_btreeParseCellPtrIndex_enum], sizeof(E->xParseCell_signature)) == 0) {
+ btreeParseCellPtrIndex(args);
+ }
+ else if (memcmp(E->xParseCell_signature, xParseCell_signatures[xParseCell_btreeParseCellPtrNoPayload_enum], sizeof(E->xParseCell_signature)) == 0) {
+ btreeParseCellPtrNoPayload(args);
+ }


// FP: xPreUpdateCallback

@transform_standalone_xPreUpdateCallback_arrow@
expression E;
identifier FP_NAME = xPreUpdateCallback;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xPreUpdateCallback_signature, xPreUpdateCallback_signatures[xPreUpdateCallback_0_enum], sizeof(E->xPreUpdateCallback_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xPreUpdateCallback_signature, xPreUpdateCallback_signatures[xPreUpdateCallback_sql_trace_callback_enum], sizeof(E->xPreUpdateCallback_signature)) == 0) {
+ sql_trace_callback(args);
+ }
+ else if (memcmp(E->xPreUpdateCallback_signature, xPreUpdateCallback_signatures[xPreUpdateCallback_sqlite3WalDefaultHook_enum], sizeof(E->xPreUpdateCallback_signature)) == 0) {
+ sqlite3WalDefaultHook(args);
+ }


// FP: xQueryFunc

@transform_standalone_xQueryFunc_arrow@
expression E;
identifier FP_NAME = xQueryFunc;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ 0;


// FP: xRandomness

@transform_standalone_xRandomness_arrow@
expression E;
identifier FP_NAME = xRandomness;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xRandomness_signature, xRandomness_signatures[xRandomness_apndRandomness_enum], sizeof(E->xRandomness_signature)) == 0) {
+ apndRandomness(args);
+ }
+ else if (memcmp(E->xRandomness_signature, xRandomness_signatures[xRandomness_memdbRandomness_enum], sizeof(E->xRandomness_signature)) == 0) {
+ memdbRandomness(args);
+ }
+ else if (memcmp(E->xRandomness_signature, xRandomness_signatures[xRandomness_vfstraceRandomness_enum], sizeof(E->xRandomness_signature)) == 0) {
+ vfstraceRandomness(args);
+ }
+ else if (memcmp(E->xRandomness_signature, xRandomness_signatures[xRandomness_unixRandomness_enum], sizeof(E->xRandomness_signature)) == 0) {
+ unixRandomness(args);
+ }


// FP: xRead

@transform_standalone_xRead_arrow@
expression E;
identifier FP_NAME = xRead;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xRead_signature, xRead_signatures[xRead_apndRead_enum], sizeof(E->xRead_signature)) == 0) {
+ apndRead(args);
+ }
+ else if (memcmp(E->xRead_signature, xRead_signatures[xRead_memdbRead_enum], sizeof(E->xRead_signature)) == 0) {
+ memdbRead(args);
+ }
+ else if (memcmp(E->xRead_signature, xRead_signatures[xRead_memjrnlRead_enum], sizeof(E->xRead_signature)) == 0) {
+ memjrnlRead(args);
+ }
+ else if (memcmp(E->xRead_signature, xRead_signatures[xRead_recoverVfsRead_enum], sizeof(E->xRead_signature)) == 0) {
+ recoverVfsRead(args);
+ }
+ else if (memcmp(E->xRead_signature, xRead_signatures[xRead_vfstraceRead_enum], sizeof(E->xRead_signature)) == 0) {
+ vfstraceRead(args);
+ }


// FP: xRealloc

@transform_standalone_xRealloc_arrow@
expression E;
identifier FP_NAME = xRealloc;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xRealloc_signature, xRealloc_signatures[xRealloc_memtraceRealloc_enum], sizeof(E->xRealloc_signature)) == 0) {
+ memtraceRealloc(args);
+ }
+ else if (memcmp(E->xRealloc_signature, xRealloc_signatures[xRealloc_sqlite3MemRealloc_enum], sizeof(E->xRealloc_signature)) == 0) {
+ sqlite3MemRealloc(args);
+ }


// FP: xRekey

@transform_standalone_xRekey_arrow@
expression E;
identifier FP_NAME = xRekey;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xRekey_signature, xRekey_signatures[xRekey_pcache1Rekey_enum], sizeof(E->xRekey_signature)) == 0) {
+ pcache1Rekey(args);
+ }
+ else if (memcmp(E->xRekey_signature, xRekey_signatures[xRekey_pcachetraceRekey_enum], sizeof(E->xRekey_signature)) == 0) {
+ pcachetraceRekey(args);
+ }


// FP: xRelease

@transform_standalone_xRelease_arrow@
expression E;
identifier FP_NAME = xRelease;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xRelease_signature, xRelease_signatures[xRelease_0_enum], sizeof(E->xRelease_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xRelease_signature, xRelease_signatures[xRelease_fts3ReleaseMethod_enum], sizeof(E->xRelease_signature)) == 0) {
+ fts3ReleaseMethod(args);
+ }


// FP: xRename

@transform_standalone_xRename_arrow@
expression E;
identifier FP_NAME = xRename;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xRename_signature, xRename_signatures[xRename_0_enum], sizeof(E->xRename_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xRename_signature, xRename_signatures[xRename_fts3RenameMethod_enum], sizeof(E->xRename_signature)) == 0) {
+ fts3RenameMethod(args);
+ }
+ else if (memcmp(E->xRename_signature, xRename_signatures[xRename_rtreeRename_enum], sizeof(E->xRename_signature)) == 0) {
+ rtreeRename(args);
+ }
+ else if (memcmp(E->xRename_signature, xRename_signatures[xRename_xRename_enum], sizeof(E->xRename_signature)) == 0) {
+ xRename(args);
+ }


// FP: xRollback

@transform_standalone_xRollback_arrow@
expression E;
identifier FP_NAME = xRollback;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xRollback_signature, xRollback_signatures[xRollback_0_enum], sizeof(E->xRollback_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xRollback_signature, xRollback_signatures[xRollback_fts3RollbackMethod_enum], sizeof(E->xRollback_signature)) == 0) {
+ fts3RollbackMethod(args);
+ }
+ else if (memcmp(E->xRollback_signature, xRollback_signatures[xRollback_rtreeEndTransaction_enum], sizeof(E->xRollback_signature)) == 0) {
+ rtreeEndTransaction(args);
+ }
+ else if (memcmp(E->xRollback_signature, xRollback_signatures[xRollback_rtreeRollback_enum], sizeof(E->xRollback_signature)) == 0) {
+ rtreeRollback(args);
+ }
+ else if (memcmp(E->xRollback_signature, xRollback_signatures[xRollback_zipfileRollback_enum], sizeof(E->xRollback_signature)) == 0) {
+ zipfileRollback(args);
+ }


// FP: xRollbackCallback

@transform_standalone_xRollbackCallback_arrow@
expression E;
identifier FP_NAME = xRollbackCallback;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xRollbackCallback_signature, xRollbackCallback_signatures[xRollbackCallback_0_enum], sizeof(E->xRollbackCallback_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xRollbackCallback_signature, xRollbackCallback_signatures[xRollbackCallback_sql_trace_callback_enum], sizeof(E->xRollbackCallback_signature)) == 0) {
+ sql_trace_callback(args);
+ }
+ else if (memcmp(E->xRollbackCallback_signature, xRollbackCallback_signatures[xRollbackCallback_sqlite3WalDefaultHook_enum], sizeof(E->xRollbackCallback_signature)) == 0) {
+ sqlite3WalDefaultHook(args);
+ }


// FP: xRollbackTo

@transform_standalone_xRollbackTo_arrow@
expression E;
identifier FP_NAME = xRollbackTo;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xRollbackTo_signature, xRollbackTo_signatures[xRollbackTo_0_enum], sizeof(E->xRollbackTo_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xRollbackTo_signature, xRollbackTo_signatures[xRollbackTo_dbpageRollbackTo_enum], sizeof(E->xRollbackTo_signature)) == 0) {
+ dbpageRollbackTo(args);
+ }
+ else if (memcmp(E->xRollbackTo_signature, xRollbackTo_signatures[xRollbackTo_fts3RollbackToMethod_enum], sizeof(E->xRollbackTo_signature)) == 0) {
+ fts3RollbackToMethod(args);
+ }


// FP: xRoundup

@transform_standalone_xRoundup_arrow@
expression E;
identifier FP_NAME = xRoundup;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xRoundup_signature, xRoundup_signatures[xRoundup_memtraceRoundup_enum], sizeof(E->xRoundup_signature)) == 0) {
+ memtraceRoundup(args);
+ }
+ else if (memcmp(E->xRoundup_signature, xRoundup_signatures[xRoundup_sqlite3MemRoundup_enum], sizeof(E->xRoundup_signature)) == 0) {
+ sqlite3MemRoundup(args);
+ }


// FP: xRowid

@transform_standalone_xRowid_arrow@
expression E;
identifier FP_NAME = xRowid;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_0_enum], sizeof(E->xRowid_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_bytecodevtabRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ bytecodevtabRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_completionRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ completionRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_dbdataRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ dbdataRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_dbpageRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ dbpageRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_expertRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ expertRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_fsdirRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ fsdirRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_fts3RowidMethod_enum], sizeof(E->xRowid_signature)) == 0) {
+ fts3RowidMethod(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_fts3auxRowidMethod_enum], sizeof(E->xRowid_signature)) == 0) {
+ fts3auxRowidMethod(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_fts3tokRowidMethod_enum], sizeof(E->xRowid_signature)) == 0) {
+ fts3tokRowidMethod(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_jsonEachRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ jsonEachRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_pragmaVtabRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ pragmaVtabRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_rtreeRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ rtreeRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_seriesRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ seriesRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_statRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ statRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_stmtRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ stmtRowid(args);
+ }


// FP: xSFunc

@transform_standalone_xSFunc_arrow@
expression E;
identifier FP_NAME = xSFunc;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_0_enum], sizeof(E->xSFunc_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_attachFunc_enum], sizeof(E->xSFunc_signature)) == 0) {
+ attachFunc(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_base64_enum], sizeof(E->xSFunc_signature)) == 0) {
+ base64(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_base85_enum], sizeof(E->xSFunc_signature)) == 0) {
+ base85(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_detachFunc_enum], sizeof(E->xSFunc_signature)) == 0) {
+ detachFunc(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_dummyUDF_enum], sizeof(E->xSFunc_signature)) == 0) {
+ dummyUDF(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_editFunc_enum], sizeof(E->xSFunc_signature)) == 0) {
+ editFunc(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_fts3AllocateMSI_enum], sizeof(E->xSFunc_signature)) == 0) {
+ fts3AllocateMSI(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_fts3ExprGlobalHitsCb_enum], sizeof(E->xSFunc_signature)) == 0) {
+ fts3ExprGlobalHitsCb(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_fts3ExprLoadDoclistsCb_enum], sizeof(E->xSFunc_signature)) == 0) {
+ fts3ExprLoadDoclistsCb(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_fts3ExprLocalHitsCb_enum], sizeof(E->xSFunc_signature)) == 0) {
+ fts3ExprLocalHitsCb(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_fts3ExprPhraseCountCb_enum], sizeof(E->xSFunc_signature)) == 0) {
+ fts3ExprPhraseCountCb(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_fts3ExprRestartIfCb_enum], sizeof(E->xSFunc_signature)) == 0) {
+ fts3ExprRestartIfCb(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_fts3ExprTermOffsetInit_enum], sizeof(E->xSFunc_signature)) == 0) {
+ fts3ExprTermOffsetInit(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_fts3ExprTest_enum], sizeof(E->xSFunc_signature)) == 0) {
+ fts3ExprTest(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_fts3ExprTestRebalance_enum], sizeof(E->xSFunc_signature)) == 0) {
+ fts3ExprTestRebalance(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_fts3MatchinfoLcsCb_enum], sizeof(E->xSFunc_signature)) == 0) {
+ fts3MatchinfoLcsCb(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_fts3SnippetFindPositions_enum], sizeof(E->xSFunc_signature)) == 0) {
+ fts3SnippetFindPositions(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_fts3TokenizerFunc_enum], sizeof(E->xSFunc_signature)) == 0) {
+ fts3TokenizerFunc(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_geomCallback_enum], sizeof(E->xSFunc_signature)) == 0) {
+ geomCallback(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_idxRemFunc_enum], sizeof(E->xSFunc_signature)) == 0) {
+ idxRemFunc(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_idxSampleFunc_enum], sizeof(E->xSFunc_signature)) == 0) {
+ idxSampleFunc(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_intTestFunc_enum], sizeof(E->xSFunc_signature)) == 0) {
+ intTestFunc(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_intckParseCreateIndexFunc_enum], sizeof(E->xSFunc_signature)) == 0) {
+ intckParseCreateIndexFunc(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_is_base85_enum], sizeof(E->xSFunc_signature)) == 0) {
+ is_base85(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_likeFunc_enum], sizeof(E->xSFunc_signature)) == 0) {
+ likeFunc(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_lsModeFunc_enum], sizeof(E->xSFunc_signature)) == 0) {
+ lsModeFunc(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_rbuFossilDeltaFunc_enum], sizeof(E->xSFunc_signature)) == 0) {
+ rbuFossilDeltaFunc(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_rbuIndexCntFunc_enum], sizeof(E->xSFunc_signature)) == 0) {
+ rbuIndexCntFunc(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_rbuTargetNameFunc_enum], sizeof(E->xSFunc_signature)) == 0) {
+ rbuTargetNameFunc(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_rbuTmpInsertFunc_enum], sizeof(E->xSFunc_signature)) == 0) {
+ rbuTmpInsertFunc(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_re_bytecode_func_enum], sizeof(E->xSFunc_signature)) == 0) {
+ re_bytecode_func(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_re_sql_func_enum], sizeof(E->xSFunc_signature)) == 0) {
+ re_sql_func(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_readfileFunc_enum], sizeof(E->xSFunc_signature)) == 0) {
+ readfileFunc(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_rtreecheck_enum], sizeof(E->xSFunc_signature)) == 0) {
+ rtreecheck(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_rtreedepth_enum], sizeof(E->xSFunc_signature)) == 0) {
+ rtreedepth(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_rtreenode_enum], sizeof(E->xSFunc_signature)) == 0) {
+ rtreenode(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_sha1Func_enum], sizeof(E->xSFunc_signature)) == 0) {
+ sha1Func(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_sha1QueryFunc_enum], sizeof(E->xSFunc_signature)) == 0) {
+ sha1QueryFunc(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_sha3Func_enum], sizeof(E->xSFunc_signature)) == 0) {
+ sha3Func(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_sha3QueryFunc_enum], sizeof(E->xSFunc_signature)) == 0) {
+ sha3QueryFunc(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_shellAddSchemaName_enum], sizeof(E->xSFunc_signature)) == 0) {
+ shellAddSchemaName(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_shellDtostr_enum], sizeof(E->xSFunc_signature)) == 0) {
+ shellDtostr(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_shellFkeyCollateClause_enum], sizeof(E->xSFunc_signature)) == 0) {
+ shellFkeyCollateClause(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_shellModuleSchema_enum], sizeof(E->xSFunc_signature)) == 0) {
+ shellModuleSchema(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_shellPutsFunc_enum], sizeof(E->xSFunc_signature)) == 0) {
+ shellPutsFunc(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_shellStrtod_enum], sizeof(E->xSFunc_signature)) == 0) {
+ shellStrtod(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_shellUSleepFunc_enum], sizeof(E->xSFunc_signature)) == 0) {
+ shellUSleepFunc(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_sqlarCompressFunc_enum], sizeof(E->xSFunc_signature)) == 0) {
+ sqlarCompressFunc(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_sqlarUncompressFunc_enum], sizeof(E->xSFunc_signature)) == 0) {
+ sqlarUncompressFunc(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_sqlite3InvalidFunction_enum], sizeof(E->xSFunc_signature)) == 0) {
+ sqlite3InvalidFunction(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_statGet_enum], sizeof(E->xSFunc_signature)) == 0) {
+ statGet(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_statInit_enum], sizeof(E->xSFunc_signature)) == 0) {
+ statInit(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_statPush_enum], sizeof(E->xSFunc_signature)) == 0) {
+ statPush(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_stmtrandFunc_enum], sizeof(E->xSFunc_signature)) == 0) {
+ stmtrandFunc(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_testFunc_enum], sizeof(E->xSFunc_signature)) == 0) {
+ testFunc(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_writefileFunc_enum], sizeof(E->xSFunc_signature)) == 0) {
+ writefileFunc(args);
+ }


// FP: xSavepoint

@transform_standalone_xSavepoint_arrow@
expression E;
identifier FP_NAME = xSavepoint;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xSavepoint_signature, xSavepoint_signatures[xSavepoint_0_enum], sizeof(E->xSavepoint_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xSavepoint_signature, xSavepoint_signatures[xSavepoint_fts3SavepointMethod_enum], sizeof(E->xSavepoint_signature)) == 0) {
+ fts3SavepointMethod(args);
+ }
+ else if (memcmp(E->xSavepoint_signature, xSavepoint_signatures[xSavepoint_rtreeSavepoint_enum], sizeof(E->xSavepoint_signature)) == 0) {
+ rtreeSavepoint(args);
+ }


// FP: xSectorSize

@transform_standalone_xSectorSize_arrow@
expression E;
identifier FP_NAME = xSectorSize;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xSectorSize_signature, xSectorSize_signatures[xSectorSize_0_enum], sizeof(E->xSectorSize_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xSectorSize_signature, xSectorSize_signatures[xSectorSize_apndSectorSize_enum], sizeof(E->xSectorSize_signature)) == 0) {
+ apndSectorSize(args);
+ }
+ else if (memcmp(E->xSectorSize_signature, xSectorSize_signatures[xSectorSize_recoverVfsSectorSize_enum], sizeof(E->xSectorSize_signature)) == 0) {
+ recoverVfsSectorSize(args);
+ }
+ else if (memcmp(E->xSectorSize_signature, xSectorSize_signatures[xSectorSize_vfstraceSectorSize_enum], sizeof(E->xSectorSize_signature)) == 0) {
+ vfstraceSectorSize(args);
+ }


// FP: xSelectCallback

@transform_standalone_xSelectCallback_arrow@
expression E;
identifier FP_NAME = xSelectCallback;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_0_enum], sizeof(E->xSelectCallback_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_convertCompoundSelectToSubquery_enum], sizeof(E->xSelectCallback_signature)) == 0) {
+ convertCompoundSelectToSubquery(args);
+ }
+ else if (memcmp(E->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_exprSelectWalkTableConstant_enum], sizeof(E->xSelectCallback_signature)) == 0) {
+ exprSelectWalkTableConstant(args);
+ }
+ else if (memcmp(E->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_fixSelectCb_enum], sizeof(E->xSelectCallback_signature)) == 0) {
+ fixSelectCb(args);
+ }
+ else if (memcmp(E->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_gatherSelectWindowsSelectCallback_enum], sizeof(E->xSelectCallback_signature)) == 0) {
+ gatherSelectWindowsSelectCallback(args);
+ }
+ else if (memcmp(E->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_renameColumnSelectCb_enum], sizeof(E->xSelectCallback_signature)) == 0) {
+ renameColumnSelectCb(args);
+ }
+ else if (memcmp(E->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_renameTableSelectCb_enum], sizeof(E->xSelectCallback_signature)) == 0) {
+ renameTableSelectCb(args);
+ }
+ else if (memcmp(E->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_renameUnmapSelectCb_enum], sizeof(E->xSelectCallback_signature)) == 0) {
+ renameUnmapSelectCb(args);
+ }
+ else if (memcmp(E->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_resolveSelectStep_enum], sizeof(E->xSelectCallback_signature)) == 0) {
+ resolveSelectStep(args);
+ }
+ else if (memcmp(E->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_selectCheckOnClausesSelect_enum], sizeof(E->xSelectCallback_signature)) == 0) {
+ selectCheckOnClausesSelect(args);
+ }
+ else if (memcmp(E->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_selectExpander_enum], sizeof(E->xSelectCallback_signature)) == 0) {
+ selectExpander(args);
+ }
+ else if (memcmp(E->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_selectRefEnter_enum], sizeof(E->xSelectCallback_signature)) == 0) {
+ selectRefEnter(args);
+ }
+ else if (memcmp(E->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_selectWindowRewriteSelectCb_enum], sizeof(E->xSelectCallback_signature)) == 0) {
+ selectWindowRewriteSelectCb(args);
+ }
+ else if (memcmp(E->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_sqlite3ReturningSubqueryCorrelated_enum], sizeof(E->xSelectCallback_signature)) == 0) {
+ sqlite3ReturningSubqueryCorrelated(args);
+ }
+ else if (memcmp(E->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_sqlite3SelectWalkFail_enum], sizeof(E->xSelectCallback_signature)) == 0) {
+ sqlite3SelectWalkFail(args);
+ }
+ else if (memcmp(E->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_sqlite3SelectWalkNoop_enum], sizeof(E->xSelectCallback_signature)) == 0) {
+ sqlite3SelectWalkNoop(args);
+ }
+ else if (memcmp(E->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_sqlite3WalkerDepthIncrease_enum], sizeof(E->xSelectCallback_signature)) == 0) {
+ sqlite3WalkerDepthIncrease(args);
+ }


// FP: xSelectCallback2

@transform_standalone_xSelectCallback2_arrow@
expression E;
identifier FP_NAME = xSelectCallback2;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_0_enum], sizeof(E->xSelectCallback2_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_selectAddSubqueryTypeInfo_enum], sizeof(E->xSelectCallback2_signature)) == 0) {
+ selectAddSubqueryTypeInfo(args);
+ }
+ else if (memcmp(E->xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_selectRefLeave_enum], sizeof(E->xSelectCallback2_signature)) == 0) {
+ selectRefLeave(args);
+ }
+ else if (memcmp(E->xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_sqlite3SelectPopWith_enum], sizeof(E->xSelectCallback2_signature)) == 0) {
+ sqlite3SelectPopWith(args);
+ }
+ else if (memcmp(E->xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_sqlite3WalkWinDefnDummyCallback_enum], sizeof(E->xSelectCallback2_signature)) == 0) {
+ sqlite3WalkWinDefnDummyCallback(args);
+ }
+ else if (memcmp(E->xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_sqlite3WalkerDepthDecrease_enum], sizeof(E->xSelectCallback2_signature)) == 0) {
+ sqlite3WalkerDepthDecrease(args);
+ }


// FP: xSetSystemCall

@transform_standalone_xSetSystemCall_arrow@
expression E;
identifier FP_NAME = xSetSystemCall;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xSetSystemCall_signature, xSetSystemCall_signatures[xSetSystemCall_0_enum], sizeof(E->xSetSystemCall_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xSetSystemCall_signature, xSetSystemCall_signatures[xSetSystemCall_apndSetSystemCall_enum], sizeof(E->xSetSystemCall_signature)) == 0) {
+ apndSetSystemCall(args);
+ }
+ else if (memcmp(E->xSetSystemCall_signature, xSetSystemCall_signatures[xSetSystemCall_rbuVfsSleep_enum], sizeof(E->xSetSystemCall_signature)) == 0) {
+ rbuVfsSleep(args);
+ }
+ else if (memcmp(E->xSetSystemCall_signature, xSetSystemCall_signatures[xSetSystemCall_unixSetSystemCall_enum], sizeof(E->xSetSystemCall_signature)) == 0) {
+ unixSetSystemCall(args);
+ }


// FP: xShadowName

@transform_standalone_xShadowName_arrow@
expression E;
identifier FP_NAME = xShadowName;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xShadowName_signature, xShadowName_signatures[xShadowName_0_enum], sizeof(E->xShadowName_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xShadowName_signature, xShadowName_signatures[xShadowName_fts3ShadowName_enum], sizeof(E->xShadowName_signature)) == 0) {
+ fts3ShadowName(args);
+ }
+ else if (memcmp(E->xShadowName_signature, xShadowName_signatures[xShadowName_rtreeShadowName_enum], sizeof(E->xShadowName_signature)) == 0) {
+ rtreeShadowName(args);
+ }


// FP: xShmBarrier

@transform_standalone_xShmBarrier_arrow@
expression E;
identifier FP_NAME = xShmBarrier;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xShmBarrier_signature, xShmBarrier_signatures[xShmBarrier_0_enum], sizeof(E->xShmBarrier_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xShmBarrier_signature, xShmBarrier_signatures[xShmBarrier_apndShmBarrier_enum], sizeof(E->xShmBarrier_signature)) == 0) {
+ apndShmBarrier(args);
+ }
+ else if (memcmp(E->xShmBarrier_signature, xShmBarrier_signatures[xShmBarrier_recoverVfsShmBarrier_enum], sizeof(E->xShmBarrier_signature)) == 0) {
+ recoverVfsShmBarrier(args);
+ }


// FP: xShmLock

@transform_standalone_xShmLock_arrow@
expression E;
identifier FP_NAME = xShmLock;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xShmLock_signature, xShmLock_signatures[xShmLock_0_enum], sizeof(E->xShmLock_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xShmLock_signature, xShmLock_signatures[xShmLock_apndShmLock_enum], sizeof(E->xShmLock_signature)) == 0) {
+ apndShmLock(args);
+ }
+ else if (memcmp(E->xShmLock_signature, xShmLock_signatures[xShmLock_recoverVfsShmLock_enum], sizeof(E->xShmLock_signature)) == 0) {
+ recoverVfsShmLock(args);
+ }


// FP: xShmMap

@transform_standalone_xShmMap_arrow@
expression E;
identifier FP_NAME = xShmMap;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xShmMap_signature, xShmMap_signatures[xShmMap_0_enum], sizeof(E->xShmMap_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xShmMap_signature, xShmMap_signatures[xShmMap_apndShmMap_enum], sizeof(E->xShmMap_signature)) == 0) {
+ apndShmMap(args);
+ }
+ else if (memcmp(E->xShmMap_signature, xShmMap_signatures[xShmMap_recoverVfsShmMap_enum], sizeof(E->xShmMap_signature)) == 0) {
+ recoverVfsShmMap(args);
+ }


// FP: xShmUnmap

@transform_standalone_xShmUnmap_arrow@
expression E;
identifier FP_NAME = xShmUnmap;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xShmUnmap_signature, xShmUnmap_signatures[xShmUnmap_0_enum], sizeof(E->xShmUnmap_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xShmUnmap_signature, xShmUnmap_signatures[xShmUnmap_apndShmUnmap_enum], sizeof(E->xShmUnmap_signature)) == 0) {
+ apndShmUnmap(args);
+ }
+ else if (memcmp(E->xShmUnmap_signature, xShmUnmap_signatures[xShmUnmap_recoverVfsShmUnmap_enum], sizeof(E->xShmUnmap_signature)) == 0) {
+ recoverVfsShmUnmap(args);
+ }


// FP: xShrink

@transform_standalone_xShrink_arrow@
expression E;
identifier FP_NAME = xShrink;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xShrink_signature, xShrink_signatures[xShrink_pcache1Shrink_enum], sizeof(E->xShrink_signature)) == 0) {
+ pcache1Shrink(args);
+ }
+ else if (memcmp(E->xShrink_signature, xShrink_signatures[xShrink_pcachetraceShrink_enum], sizeof(E->xShrink_signature)) == 0) {
+ pcachetraceShrink(args);
+ }


// FP: xShutdown

@transform_standalone_xShutdown_arrow@
expression E;
identifier FP_NAME = xShutdown;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xShutdown_signature, xShutdown_signatures[xShutdown_memtraceShutdown_enum], sizeof(E->xShutdown_signature)) == 0) {
+ memtraceShutdown(args);
+ }
+ else if (memcmp(E->xShutdown_signature, xShutdown_signatures[xShutdown_pcache1Shutdown_enum], sizeof(E->xShutdown_signature)) == 0) {
+ pcache1Shutdown(args);
+ }
+ else if (memcmp(E->xShutdown_signature, xShutdown_signatures[xShutdown_pcachetraceShutdown_enum], sizeof(E->xShutdown_signature)) == 0) {
+ pcachetraceShutdown(args);
+ }
+ else if (memcmp(E->xShutdown_signature, xShutdown_signatures[xShutdown_sqlite3MemShutdown_enum], sizeof(E->xShutdown_signature)) == 0) {
+ sqlite3MemShutdown(args);
+ }


// FP: xSize

@transform_standalone_xSize_arrow@
expression E;
identifier FP_NAME = xSize;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xSize_signature, xSize_signatures[xSize_memtraceSize_enum], sizeof(E->xSize_signature)) == 0) {
+ memtraceSize(args);
+ }
+ else if (memcmp(E->xSize_signature, xSize_signatures[xSize_sqlite3MemSize_enum], sizeof(E->xSize_signature)) == 0) {
+ sqlite3MemSize(args);
+ }


// FP: xSleep

@transform_standalone_xSleep_arrow@
expression E;
identifier FP_NAME = xSleep;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xSleep_signature, xSleep_signatures[xSleep_0_enum], sizeof(E->xSleep_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xSleep_signature, xSleep_signatures[xSleep_apndSleep_enum], sizeof(E->xSleep_signature)) == 0) {
+ apndSleep(args);
+ }
+ else if (memcmp(E->xSleep_signature, xSleep_signatures[xSleep_memdbSleep_enum], sizeof(E->xSleep_signature)) == 0) {
+ memdbSleep(args);
+ }
+ else if (memcmp(E->xSleep_signature, xSleep_signatures[xSleep_vfstraceSleep_enum], sizeof(E->xSleep_signature)) == 0) {
+ vfstraceSleep(args);
+ }
+ else if (memcmp(E->xSleep_signature, xSleep_signatures[xSleep_unixSleep_enum], sizeof(E->xSleep_signature)) == 0) {
+ unixSleep(args);
+ }


// FP: xSql

@transform_standalone_xSql_arrow@
expression E;
identifier FP_NAME = xSql;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xSql_signature, xSql_signatures[xSql_0_enum], sizeof(E->xSql_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xSql_signature, xSql_signatures[xSql_recoverSqlCb_enum], sizeof(E->xSql_signature)) == 0) {
+ recoverSqlCb(args);
+ }


// FP: xSync

@transform_standalone_xSync_arrow@
expression E;
identifier FP_NAME = xSync;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xSync_signature, xSync_signatures[xSync_0_enum], sizeof(E->xSync_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xSync_signature, xSync_signatures[xSync_apndSync_enum], sizeof(E->xSync_signature)) == 0) {
+ apndSync(args);
+ }
+ else if (memcmp(E->xSync_signature, xSync_signatures[xSync_dbpageSync_enum], sizeof(E->xSync_signature)) == 0) {
+ dbpageSync(args);
+ }
+ else if (memcmp(E->xSync_signature, xSync_signatures[xSync_fts3SyncMethod_enum], sizeof(E->xSync_signature)) == 0) {
+ fts3SyncMethod(args);
+ }
+ else if (memcmp(E->xSync_signature, xSync_signatures[xSync_memdbSync_enum], sizeof(E->xSync_signature)) == 0) {
+ memdbSync(args);
+ }
+ else if (memcmp(E->xSync_signature, xSync_signatures[xSync_memjrnlSync_enum], sizeof(E->xSync_signature)) == 0) {
+ memjrnlSync(args);
+ }
+ else if (memcmp(E->xSync_signature, xSync_signatures[xSync_recoverVfsSync_enum], sizeof(E->xSync_signature)) == 0) {
+ recoverVfsSync(args);
+ }
+ else if (memcmp(E->xSync_signature, xSync_signatures[xSync_rtreeEndTransaction_enum], sizeof(E->xSync_signature)) == 0) {
+ rtreeEndTransaction(args);
+ }
+ else if (memcmp(E->xSync_signature, xSync_signatures[xSync_vfstraceSync_enum], sizeof(E->xSync_signature)) == 0) {
+ vfstraceSync(args);
+ }


// FP: xTableFilter

@transform_standalone_xTableFilter_arrow@
expression E;
identifier FP_NAME = xTableFilter;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xTableFilter_signature, xTableFilter_signatures[xTableFilter_0_enum], sizeof(E->xTableFilter_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xTableFilter_signature, xTableFilter_signatures[xTableFilter_session_filter_enum], sizeof(E->xTableFilter_signature)) == 0) {
+ session_filter(args);
+ }


// FP: xTask

@transform_standalone_xTask_arrow@
expression E;
identifier FP_NAME = xTask;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xTask_signature, xTask_signatures[xTask_0_enum], sizeof(E->xTask_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xTask_signature, xTask_signatures[xTask_vdbeSorterFlushThread_enum], sizeof(E->xTask_signature)) == 0) {
+ vdbeSorterFlushThread(args);
+ }
+ else if (memcmp(E->xTask_signature, xTask_signatures[xTask_vdbeIncrPopulateThread_enum], sizeof(E->xTask_signature)) == 0) {
+ vdbeIncrPopulateThread(args);
+ }
+ else if (memcmp(E->xTask_signature, xTask_signatures[xTask_vdbePmaReaderBgIncrInit_enum], sizeof(E->xTask_signature)) == 0) {
+ vdbePmaReaderBgIncrInit(args);
+ }


// FP: xTruncate

@transform_standalone_xTruncate_arrow@
expression E;
identifier FP_NAME = xTruncate;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xTruncate_signature, xTruncate_signatures[xTruncate_apndTruncate_enum], sizeof(E->xTruncate_signature)) == 0) {
+ apndTruncate(args);
+ }
+ else if (memcmp(E->xTruncate_signature, xTruncate_signatures[xTruncate_memdbTruncate_enum], sizeof(E->xTruncate_signature)) == 0) {
+ memdbTruncate(args);
+ }
+ else if (memcmp(E->xTruncate_signature, xTruncate_signatures[xTruncate_memjrnlTruncate_enum], sizeof(E->xTruncate_signature)) == 0) {
+ memjrnlTruncate(args);
+ }
+ else if (memcmp(E->xTruncate_signature, xTruncate_signatures[xTruncate_pcache1Truncate_enum], sizeof(E->xTruncate_signature)) == 0) {
+ pcache1Truncate(args);
+ }
+ else if (memcmp(E->xTruncate_signature, xTruncate_signatures[xTruncate_pcachetraceTruncate_enum], sizeof(E->xTruncate_signature)) == 0) {
+ pcachetraceTruncate(args);
+ }
+ else if (memcmp(E->xTruncate_signature, xTruncate_signatures[xTruncate_recoverVfsTruncate_enum], sizeof(E->xTruncate_signature)) == 0) {
+ recoverVfsTruncate(args);
+ }
+ else if (memcmp(E->xTruncate_signature, xTruncate_signatures[xTruncate_vfstraceTruncate_enum], sizeof(E->xTruncate_signature)) == 0) {
+ vfstraceTruncate(args);
+ }


// FP: xUnfetch

@transform_standalone_xUnfetch_arrow@
expression E;
identifier FP_NAME = xUnfetch;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xUnfetch_signature, xUnfetch_signatures[xUnfetch_0_enum], sizeof(E->xUnfetch_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xUnfetch_signature, xUnfetch_signatures[xUnfetch_apndUnfetch_enum], sizeof(E->xUnfetch_signature)) == 0) {
+ apndUnfetch(args);
+ }
+ else if (memcmp(E->xUnfetch_signature, xUnfetch_signatures[xUnfetch_memdbUnfetch_enum], sizeof(E->xUnfetch_signature)) == 0) {
+ memdbUnfetch(args);
+ }
+ else if (memcmp(E->xUnfetch_signature, xUnfetch_signatures[xUnfetch_recoverVfsUnfetch_enum], sizeof(E->xUnfetch_signature)) == 0) {
+ recoverVfsUnfetch(args);
+ }


// FP: xUnlock

@transform_standalone_xUnlock_arrow@
expression E;
identifier FP_NAME = xUnlock;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xUnlock_signature, xUnlock_signatures[xUnlock_0_enum], sizeof(E->xUnlock_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xUnlock_signature, xUnlock_signatures[xUnlock_apndUnlock_enum], sizeof(E->xUnlock_signature)) == 0) {
+ apndUnlock(args);
+ }
+ else if (memcmp(E->xUnlock_signature, xUnlock_signatures[xUnlock_memdbUnlock_enum], sizeof(E->xUnlock_signature)) == 0) {
+ memdbUnlock(args);
+ }
+ else if (memcmp(E->xUnlock_signature, xUnlock_signatures[xUnlock_recoverVfsUnlock_enum], sizeof(E->xUnlock_signature)) == 0) {
+ recoverVfsUnlock(args);
+ }
+ else if (memcmp(E->xUnlock_signature, xUnlock_signatures[xUnlock_vfstraceUnlock_enum], sizeof(E->xUnlock_signature)) == 0) {
+ vfstraceUnlock(args);
+ }


// FP: xUnlockNotify

@transform_standalone_xUnlockNotify_arrow@
expression E;
identifier FP_NAME = xUnlockNotify;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xUnlockNotify_signature, xUnlockNotify_signatures[xUnlockNotify_0_enum], sizeof(E->xUnlockNotify_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xUnlockNotify_signature, xUnlockNotify_signatures[xUnlockNotify_xUnlockNotify_enum], sizeof(E->xUnlockNotify_signature)) == 0) {
+ xUnlockNotify(args);
+ }


// FP: xUnpin

@transform_standalone_xUnpin_arrow@
expression E;
identifier FP_NAME = xUnpin;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xUnpin_signature, xUnpin_signatures[xUnpin_pcache1Unpin_enum], sizeof(E->xUnpin_signature)) == 0) {
+ pcache1Unpin(args);
+ }
+ else if (memcmp(E->xUnpin_signature, xUnpin_signatures[xUnpin_pcachetraceUnpin_enum], sizeof(E->xUnpin_signature)) == 0) {
+ pcachetraceUnpin(args);
+ }


// FP: xUpdate

@transform_standalone_xUpdate_arrow@
expression E;
identifier FP_NAME = xUpdate;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xUpdate_signature, xUpdate_signatures[xUpdate_0_enum], sizeof(E->xUpdate_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xUpdate_signature, xUpdate_signatures[xUpdate_dbpageUpdate_enum], sizeof(E->xUpdate_signature)) == 0) {
+ dbpageUpdate(args);
+ }
+ else if (memcmp(E->xUpdate_signature, xUpdate_signatures[xUpdate_expertUpdate_enum], sizeof(E->xUpdate_signature)) == 0) {
+ expertUpdate(args);
+ }
+ else if (memcmp(E->xUpdate_signature, xUpdate_signatures[xUpdate_fts3UpdateMethod_enum], sizeof(E->xUpdate_signature)) == 0) {
+ fts3UpdateMethod(args);
+ }
+ else if (memcmp(E->xUpdate_signature, xUpdate_signatures[xUpdate_geopolyUpdate_enum], sizeof(E->xUpdate_signature)) == 0) {
+ geopolyUpdate(args);
+ }
+ else if (memcmp(E->xUpdate_signature, xUpdate_signatures[xUpdate_rtreeUpdate_enum], sizeof(E->xUpdate_signature)) == 0) {
+ rtreeUpdate(args);
+ }
+ else if (memcmp(E->xUpdate_signature, xUpdate_signatures[xUpdate_zipfileUpdate_enum], sizeof(E->xUpdate_signature)) == 0) {
+ zipfileUpdate(args);
+ }


// FP: xUpdateCallback

@transform_standalone_xUpdateCallback_arrow@
expression E;
identifier FP_NAME = xUpdateCallback;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xUpdateCallback_signature, xUpdateCallback_signatures[xUpdateCallback_0_enum], sizeof(E->xUpdateCallback_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xUpdateCallback_signature, xUpdateCallback_signatures[xUpdateCallback_sql_trace_callback_enum], sizeof(E->xUpdateCallback_signature)) == 0) {
+ sql_trace_callback(args);
+ }
+ else if (memcmp(E->xUpdateCallback_signature, xUpdateCallback_signatures[xUpdateCallback_sqlite3WalDefaultHook_enum], sizeof(E->xUpdateCallback_signature)) == 0) {
+ sqlite3WalDefaultHook(args);
+ }


// FP: xV2

@transform_standalone_xV2_arrow@
expression E;
identifier FP_NAME = xV2;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xV2_signature, xV2_signatures[xV2_0_enum], sizeof(E->xV2_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xV2_signature, xV2_signatures[xV2_sql_trace_callback_enum], sizeof(E->xV2_signature)) == 0) {
+ sql_trace_callback(args);
+ }


// FP: xValue

@transform_standalone_xValue_arrow@
expression E;
identifier FP_NAME = xValue;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xValue_signature, xValue_signatures[xValue_0_enum], sizeof(E->xValue_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xValue_signature, xValue_signatures[xValue_decimalSumValue_enum], sizeof(E->xValue_signature)) == 0) {
+ decimalSumValue(args);
+ }
+ else if (memcmp(E->xValue_signature, xValue_signatures[xValue_percentValue_enum], sizeof(E->xValue_signature)) == 0) {
+ percentValue(args);
+ }
+ else if (memcmp(E->xValue_signature, xValue_signatures[xValue_sqlite3changeset_new_enum], sizeof(E->xValue_signature)) == 0) {
+ sqlite3changeset_new(args);
+ }
+ else if (memcmp(E->xValue_signature, xValue_signatures[xValue_sqlite3changeset_old_enum], sizeof(E->xValue_signature)) == 0) {
+ sqlite3changeset_old(args);
+ }


// FP: xWrite

@transform_standalone_xWrite_arrow@
expression E;
identifier FP_NAME = xWrite;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ if (memcmp(E->xWrite_signature, xWrite_signatures[xWrite_apndWrite_enum], sizeof(E->xWrite_signature)) == 0) {
+ apndWrite(args);
+ }
+ else if (memcmp(E->xWrite_signature, xWrite_signatures[xWrite_kvstorageWrite_enum], sizeof(E->xWrite_signature)) == 0) {
+ kvstorageWrite(args);
+ }
+ else if (memcmp(E->xWrite_signature, xWrite_signatures[xWrite_memdbWrite_enum], sizeof(E->xWrite_signature)) == 0) {
+ memdbWrite(args);
+ }
+ else if (memcmp(E->xWrite_signature, xWrite_signatures[xWrite_memjrnlWrite_enum], sizeof(E->xWrite_signature)) == 0) {
+ memjrnlWrite(args);
+ }
+ else if (memcmp(E->xWrite_signature, xWrite_signatures[xWrite_recoverVfsWrite_enum], sizeof(E->xWrite_signature)) == 0) {
+ recoverVfsWrite(args);
+ }
+ else if (memcmp(E->xWrite_signature, xWrite_signatures[xWrite_vfstraceWrite_enum], sizeof(E->xWrite_signature)) == 0) {
+ vfstraceWrite(args);
+ }


// FP: xsnprintf

@transform_standalone_xsnprintf_arrow@
expression E;
identifier FP_NAME = xsnprintf;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ sqlite3_set_authorizer(args);


// FP: xvsnprintf

@transform_standalone_xvsnprintf_arrow@
expression E;
identifier FP_NAME = xvsnprintf;
expression list args;
@@
- E->FP_NAME(args);
+ // E->FP_NAME(args);
+ 0;

// Total standalone arrow rules: 359

// ===== STANDALONE DOT CALL TRANSFORMATION RULES =====
// Pattern: E.fp_name(args);


// FP: aggregate_context

@transform_standalone_aggregate_context_dot@
expression E;
identifier FP_NAME = aggregate_context;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_aggregate_context(args);


// FP: auto_extension

@transform_standalone_auto_extension_dot@
expression E;
identifier FP_NAME = auto_extension;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_vtab_config(args);


// FP: backup_finish

@transform_standalone_backup_finish_dot@
expression E;
identifier FP_NAME = backup_finish;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_result_error_code(args);


// FP: backup_init

@transform_standalone_backup_init_dot@
expression E;
identifier FP_NAME = backup_init;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_test_control(args);


// FP: backup_pagecount

@transform_standalone_backup_pagecount_dot@
expression E;
identifier FP_NAME = backup_pagecount;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_randomness(args);


// FP: backup_remaining

@transform_standalone_backup_remaining_dot@
expression E;
identifier FP_NAME = backup_remaining;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_context_db_handle(args);


// FP: backup_step

@transform_standalone_backup_step_dot@
expression E;
identifier FP_NAME = backup_step;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_extended_result_codes(args);


// FP: bind_blob64

@transform_standalone_bind_blob64_dot@
expression E;
identifier FP_NAME = bind_blob64;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_vtab_on_conflict(args);


// FP: bind_int

@transform_standalone_bind_int_dot@
expression E;
identifier FP_NAME = bind_int;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_bind_double(args);


// FP: bind_int64

@transform_standalone_bind_int64_dot@
expression E;
identifier FP_NAME = bind_int64;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_bind_int(args);


// FP: bind_null

@transform_standalone_bind_null_dot@
expression E;
identifier FP_NAME = bind_null;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_bind_int64(args);


// FP: bind_parameter_count

@transform_standalone_bind_parameter_count_dot@
expression E;
identifier FP_NAME = bind_parameter_count;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_bind_null(args);


// FP: bind_parameter_index

@transform_standalone_bind_parameter_index_dot@
expression E;
identifier FP_NAME = bind_parameter_index;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_bind_parameter_count(args);


// FP: bind_parameter_name

@transform_standalone_bind_parameter_name_dot@
expression E;
identifier FP_NAME = bind_parameter_name;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_bind_parameter_index(args);


// FP: bind_text

@transform_standalone_bind_text_dot@
expression E;
identifier FP_NAME = bind_text;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_bind_parameter_name(args);


// FP: bind_text16

@transform_standalone_bind_text16_dot@
expression E;
identifier FP_NAME = bind_text16;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_bind_text(args);


// FP: bind_text64

@transform_standalone_bind_text64_dot@
expression E;
identifier FP_NAME = bind_text64;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_close_v2(args);


// FP: bind_value

@transform_standalone_bind_value_dot@
expression E;
identifier FP_NAME = bind_value;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_bind_text16(args);


// FP: bind_zeroblob

@transform_standalone_bind_zeroblob_dot@
expression E;
identifier FP_NAME = bind_zeroblob;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_prepare_v2(args);


// FP: bind_zeroblob64

@transform_standalone_bind_zeroblob64_dot@
expression E;
identifier FP_NAME = bind_zeroblob64;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_auto_extension(args);


// FP: blob_bytes

@transform_standalone_blob_bytes_dot@
expression E;
identifier FP_NAME = blob_bytes;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_prepare16_v2(args);


// FP: blob_close

@transform_standalone_blob_close_dot@
expression E;
identifier FP_NAME = blob_close;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_clear_bindings(args);


// FP: blob_open

@transform_standalone_blob_open_dot@
expression E;
identifier FP_NAME = blob_open;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_create_module_v2(args);


// FP: blob_read

@transform_standalone_blob_read_dot@
expression E;
identifier FP_NAME = blob_read;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_bind_zeroblob(args);


// FP: blob_reopen

@transform_standalone_blob_reopen_dot@
expression E;
identifier FP_NAME = blob_reopen;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_db_status(args);


// FP: blob_write

@transform_standalone_blob_write_dot@
expression E;
identifier FP_NAME = blob_write;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_blob_bytes(args);


// FP: busy_handler

@transform_standalone_busy_handler_dot@
expression E;
identifier FP_NAME = busy_handler;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_bind_value(args);


// FP: busy_timeout

@transform_standalone_busy_timeout_dot@
expression E;
identifier FP_NAME = busy_timeout;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_busy_handler(args);


// FP: cancel_auto_extension

@transform_standalone_cancel_auto_extension_dot@
expression E;
identifier FP_NAME = cancel_auto_extension;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_db_filename(args);


// FP: changes

@transform_standalone_changes_dot@
expression E;
identifier FP_NAME = changes;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_busy_timeout(args);


// FP: changes64

@transform_standalone_changes64_dot@
expression E;
identifier FP_NAME = changes64;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_str_value(args);


// FP: clear_bindings

@transform_standalone_clear_bindings_dot@
expression E;
identifier FP_NAME = clear_bindings;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_vmprintf(args);


// FP: close

@transform_standalone_close_dot@
expression E;
identifier FP_NAME = close;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_changes(args);


// FP: close_v2

@transform_standalone_close_v2_dot@
expression E;
identifier FP_NAME = close_v2;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_soft_heap_limit64(args);


// FP: collation_needed

@transform_standalone_collation_needed_dot@
expression E;
identifier FP_NAME = collation_needed;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_close(args);


// FP: collation_needed16

@transform_standalone_collation_needed16_dot@
expression E;
identifier FP_NAME = collation_needed16;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_collation_needed(args);


// FP: column_blob

@transform_standalone_column_blob_dot@
expression E;
identifier FP_NAME = column_blob;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_collation_needed16(args);


// FP: column_bytes

@transform_standalone_column_bytes_dot@
expression E;
identifier FP_NAME = column_bytes;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_column_blob(args);


// FP: column_bytes16

@transform_standalone_column_bytes16_dot@
expression E;
identifier FP_NAME = column_bytes16;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_column_bytes(args);


// FP: column_count

@transform_standalone_column_count_dot@
expression E;
identifier FP_NAME = column_count;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_column_bytes16(args);


// FP: column_database_name

@transform_standalone_column_database_name_dot@
expression E;
identifier FP_NAME = column_database_name;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_column_count(args);


// FP: column_database_name16

@transform_standalone_column_database_name16_dot@
expression E;
identifier FP_NAME = column_database_name16;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_column_database_name(args);


// FP: column_decltype

@transform_standalone_column_decltype_dot@
expression E;
identifier FP_NAME = column_decltype;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_column_database_name16(args);


// FP: column_decltype16

@transform_standalone_column_decltype16_dot@
expression E;
identifier FP_NAME = column_decltype16;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_column_decltype(args);


// FP: column_double

@transform_standalone_column_double_dot@
expression E;
identifier FP_NAME = column_double;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_column_decltype16(args);


// FP: column_int

@transform_standalone_column_int_dot@
expression E;
identifier FP_NAME = column_int;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_column_double(args);


// FP: column_int64

@transform_standalone_column_int64_dot@
expression E;
identifier FP_NAME = column_int64;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_column_int(args);


// FP: column_name

@transform_standalone_column_name_dot@
expression E;
identifier FP_NAME = column_name;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_column_int64(args);


// FP: column_name16

@transform_standalone_column_name16_dot@
expression E;
identifier FP_NAME = column_name16;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_column_name(args);


// FP: column_origin_name

@transform_standalone_column_origin_name_dot@
expression E;
identifier FP_NAME = column_origin_name;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_column_name16(args);


// FP: column_origin_name16

@transform_standalone_column_origin_name16_dot@
expression E;
identifier FP_NAME = column_origin_name16;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_column_origin_name(args);


// FP: column_table_name

@transform_standalone_column_table_name_dot@
expression E;
identifier FP_NAME = column_table_name;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_column_origin_name16(args);


// FP: column_table_name16

@transform_standalone_column_table_name16_dot@
expression E;
identifier FP_NAME = column_table_name16;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_column_table_name(args);


// FP: column_text

@transform_standalone_column_text_dot@
expression E;
identifier FP_NAME = column_text;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_column_table_name16(args);


// FP: column_text16

@transform_standalone_column_text16_dot@
expression E;
identifier FP_NAME = column_text16;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_column_text(args);


// FP: column_type

@transform_standalone_column_type_dot@
expression E;
identifier FP_NAME = column_type;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_column_text16(args);


// FP: column_value

@transform_standalone_column_value_dot@
expression E;
identifier FP_NAME = column_value;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_column_type(args);


// FP: commit_hook

@transform_standalone_commit_hook_dot@
expression E;
identifier FP_NAME = commit_hook;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_column_value(args);


// FP: compileoption_get

@transform_standalone_compileoption_get_dot@
expression E;
identifier FP_NAME = compileoption_get;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_limit(args);


// FP: compileoption_used

@transform_standalone_compileoption_used_dot@
expression E;
identifier FP_NAME = compileoption_used;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_next_stmt(args);


// FP: complete

@transform_standalone_complete_dot@
expression E;
identifier FP_NAME = complete;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_commit_hook(args);


// FP: complete16

@transform_standalone_complete16_dot@
expression E;
identifier FP_NAME = complete16;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_complete(args);


// FP: context_db_handle

@transform_standalone_context_db_handle_dot@
expression E;
identifier FP_NAME = context_db_handle;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_soft_heap_limit(args);


// FP: create_collation

@transform_standalone_create_collation_dot@
expression E;
identifier FP_NAME = create_collation;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_complete16(args);


// FP: create_collation16

@transform_standalone_create_collation16_dot@
expression E;
identifier FP_NAME = create_collation16;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_create_collation(args);


// FP: create_collation_v2

@transform_standalone_create_collation_v2_dot@
expression E;
identifier FP_NAME = create_collation_v2;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_blob_close(args);


// FP: create_filename

@transform_standalone_create_filename_dot@
expression E;
identifier FP_NAME = create_filename;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_str_appendchar(args);


// FP: create_function

@transform_standalone_create_function_dot@
expression E;
identifier FP_NAME = create_function;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_create_collation16(args);


// FP: create_function16

@transform_standalone_create_function16_dot@
expression E;
identifier FP_NAME = create_function16;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_create_function(args);


// FP: create_function_v2

@transform_standalone_create_function_v2_dot@
expression E;
identifier FP_NAME = create_function_v2;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_sql(args);


// FP: create_module

@transform_standalone_create_module_dot@
expression E;
identifier FP_NAME = create_module;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_create_function16(args);


// FP: create_module_v2

@transform_standalone_create_module_v2_dot@
expression E;
identifier FP_NAME = create_module_v2;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_overload_function(args);


// FP: create_window_function

@transform_standalone_create_window_function_dot@
expression E;
identifier FP_NAME = create_window_function;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_vtab_collation(args);


// FP: data_count

@transform_standalone_data_count_dot@
expression E;
identifier FP_NAME = data_count;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_create_module(args);


// FP: database_file_object

@transform_standalone_database_file_object_dot@
expression E;
identifier FP_NAME = database_file_object;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_str_errcode(args);


// FP: db_cacheflush

@transform_standalone_db_cacheflush_dot@
expression E;
identifier FP_NAME = db_cacheflush;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_malloc64(args);


// FP: db_config

@transform_standalone_db_config_dot@
expression E;
identifier FP_NAME = db_config;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_status(args);


// FP: db_filename

@transform_standalone_db_filename_dot@
expression E;
identifier FP_NAME = db_filename;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_sourceid(args);


// FP: db_handle

@transform_standalone_db_handle_dot@
expression E;
identifier FP_NAME = db_handle;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_data_count(args);


// FP: db_mutex

@transform_standalone_db_mutex_dot@
expression E;
identifier FP_NAME = db_mutex;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_backup_finish(args);


// FP: db_name

@transform_standalone_db_name_dot@
expression E;
identifier FP_NAME = db_name;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_filename_journal(args);


// FP: db_readonly

@transform_standalone_db_readonly_dot@
expression E;
identifier FP_NAME = db_readonly;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_stmt_status(args);


// FP: db_release_memory

@transform_standalone_db_release_memory_dot@
expression E;
identifier FP_NAME = db_release_memory;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_strnicmp(args);


// FP: db_status

@transform_standalone_db_status_dot@
expression E;
identifier FP_NAME = db_status;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_backup_init(args);


// FP: declare_vtab

@transform_standalone_declare_vtab_dot@
expression E;
identifier FP_NAME = declare_vtab;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_db_handle(args);


// FP: deserialize

@transform_standalone_deserialize_dot@
expression E;
identifier FP_NAME = deserialize;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_uri_key(args);


// FP: drop_modules

@transform_standalone_drop_modules_dot@
expression E;
identifier FP_NAME = drop_modules;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_str_new(args);


// FP: enable_shared_cache

@transform_standalone_enable_shared_cache_dot@
expression E;
identifier FP_NAME = enable_shared_cache;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_declare_vtab(args);


// FP: errcode

@transform_standalone_errcode_dot@
expression E;
identifier FP_NAME = errcode;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_enable_shared_cache(args);


// FP: errmsg

@transform_standalone_errmsg_dot@
expression E;
identifier FP_NAME = errmsg;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_errcode(args);


// FP: errmsg16

@transform_standalone_errmsg16_dot@
expression E;
identifier FP_NAME = errmsg16;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_errmsg(args);


// FP: exec

@transform_standalone_exec_dot@
expression E;
identifier FP_NAME = exec;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_errmsg16(args);


// FP: expanded_sql

@transform_standalone_expanded_sql_dot@
expression E;
identifier FP_NAME = expanded_sql;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_reset_auto_extension(args);


// FP: expired

@transform_standalone_expired_dot@
expression E;
identifier FP_NAME = expired;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.expired_signature, expired_signatures[expired_0_enum], sizeof(E.expired_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.expired_signature, expired_signatures[expired_sqlite3_exec_enum], sizeof(E.expired_signature)) == 0) {
+ sqlite3_exec(args);
+ }


// FP: extended_errcode

@transform_standalone_extended_errcode_dot@
expression E;
identifier FP_NAME = extended_errcode;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_backup_pagecount(args);


// FP: extended_result_codes

@transform_standalone_extended_result_codes_dot@
expression E;
identifier FP_NAME = extended_result_codes;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_vfs_find(args);


// FP: file_control

@transform_standalone_file_control_dot@
expression E;
identifier FP_NAME = file_control;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_blob_open(args);


// FP: filename_database

@transform_standalone_filename_database_dot@
expression E;
identifier FP_NAME = filename_database;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_str_vappendf(args);


// FP: filename_journal

@transform_standalone_filename_journal_dot@
expression E;
identifier FP_NAME = filename_journal;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_str_append(args);


// FP: filename_wal

@transform_standalone_filename_wal_dot@
expression E;
identifier FP_NAME = filename_wal;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_str_appendall(args);


// FP: free_filename

@transform_standalone_free_filename_dot@
expression E;
identifier FP_NAME = free_filename;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_str_reset(args);


// FP: get_autocommit

@transform_standalone_get_autocommit_dot@
expression E;
identifier FP_NAME = get_autocommit;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_free(args);


// FP: get_auxdata

@transform_standalone_get_auxdata_dot@
expression E;
identifier FP_NAME = get_auxdata;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_free_table(args);


// FP: get_clientdata

@transform_standalone_get_clientdata_dot@
expression E;
identifier FP_NAME = get_clientdata;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_database_file_object(args);


// FP: get_table

@transform_standalone_get_table_dot@
expression E;
identifier FP_NAME = get_table;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_get_autocommit(args);


// FP: global_recover

@transform_standalone_global_recover_dot@
expression E;
identifier FP_NAME = global_recover;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_get_auxdata(args);


// FP: hard_heap_limit64

@transform_standalone_hard_heap_limit64_dot@
expression E;
identifier FP_NAME = hard_heap_limit64;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_str_finish(args);


// FP: interruptx

@transform_standalone_interruptx_dot@
expression E;
identifier FP_NAME = interruptx;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_get_table(args);


// FP: is_interrupted

@transform_standalone_is_interrupted_dot@
expression E;
identifier FP_NAME = is_interrupted;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_create_filename(args);


// FP: keyword_check

@transform_standalone_keyword_check_dot@
expression E;
identifier FP_NAME = keyword_check;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_db_cacheflush(args);


// FP: keyword_count

@transform_standalone_keyword_count_dot@
expression E;
identifier FP_NAME = keyword_count;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_status64(args);


// FP: keyword_name

@transform_standalone_keyword_name_dot@
expression E;
identifier FP_NAME = keyword_name;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_strlike(args);


// FP: last_insert_rowid

@transform_standalone_last_insert_rowid_dot@
expression E;
identifier FP_NAME = last_insert_rowid;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ 0;


// FP: libversion

@transform_standalone_libversion_dot@
expression E;
identifier FP_NAME = libversion;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_interrupt(args);


// FP: libversion_number

@transform_standalone_libversion_number_dot@
expression E;
identifier FP_NAME = libversion_number;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_last_insert_rowid(args);


// FP: limit

@transform_standalone_limit_dot@
expression E;
identifier FP_NAME = limit;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_vfs_register(args);


// FP: load_extension

@transform_standalone_load_extension_dot@
expression E;
identifier FP_NAME = load_extension;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_db_readonly(args);


// FP: log

@transform_standalone_log_dot@
expression E;
identifier FP_NAME = log;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_backup_remaining(args);


// FP: malloc

@transform_standalone_malloc_dot@
expression E;
identifier FP_NAME = malloc;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_libversion(args);


// FP: malloc64

@transform_standalone_malloc64_dot@
expression E;
identifier FP_NAME = malloc64;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_db_release_memory(args);


// FP: memory_highwater

@transform_standalone_memory_highwater_dot@
expression E;
identifier FP_NAME = memory_highwater;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_blob_read(args);


// FP: memory_used

@transform_standalone_memory_used_dot@
expression E;
identifier FP_NAME = memory_used;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_blob_write(args);


// FP: mprintf

@transform_standalone_mprintf_dot@
expression E;
identifier FP_NAME = mprintf;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_libversion_number(args);


// FP: msize

@transform_standalone_msize_dot@
expression E;
identifier FP_NAME = msize;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_errstr(args);


// FP: mutex_alloc

@transform_standalone_mutex_alloc_dot@
expression E;
identifier FP_NAME = mutex_alloc;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_create_collation_v2(args);


// FP: mutex_enter

@transform_standalone_mutex_enter_dot@
expression E;
identifier FP_NAME = mutex_enter;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_file_control(args);


// FP: mutex_free

@transform_standalone_mutex_free_dot@
expression E;
identifier FP_NAME = mutex_free;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_memory_highwater(args);


// FP: mutex_leave

@transform_standalone_mutex_leave_dot@
expression E;
identifier FP_NAME = mutex_leave;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_memory_used(args);


// FP: next_stmt

@transform_standalone_next_stmt_dot@
expression E;
identifier FP_NAME = next_stmt;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_vfs_unregister(args);


// FP: normalized_sql

@transform_standalone_normalized_sql_dot@
expression E;
identifier FP_NAME = normalized_sql;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_keyword_count(args);


// FP: open

@transform_standalone_open_dot@
expression E;
identifier FP_NAME = open;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_malloc(args);


// FP: open16

@transform_standalone_open16_dot@
expression E;
identifier FP_NAME = open16;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_mprintf(args);


// FP: open_v2

@transform_standalone_open_v2_dot@
expression E;
identifier FP_NAME = open_v2;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ 0;


// FP: overload_function

@transform_standalone_overload_function_dot@
expression E;
identifier FP_NAME = overload_function;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_value_text16be(args);


// FP: prepare

@transform_standalone_prepare_dot@
expression E;
identifier FP_NAME = prepare;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_open(args);


// FP: prepare16

@transform_standalone_prepare16_dot@
expression E;
identifier FP_NAME = prepare16;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_open16(args);


// FP: prepare16_v2

@transform_standalone_prepare16_v2_dot@
expression E;
identifier FP_NAME = prepare16_v2;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_value_type(args);


// FP: prepare16_v3

@transform_standalone_prepare16_v3_dot@
expression E;
identifier FP_NAME = prepare16_v3;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_strglob(args);


// FP: prepare_v2

@transform_standalone_prepare_v2_dot@
expression E;
identifier FP_NAME = prepare_v2;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_value_text16le(args);


// FP: prepare_v3

@transform_standalone_prepare_v3_dot@
expression E;
identifier FP_NAME = prepare_v3;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_result_text64(args);


// FP: profile

@transform_standalone_profile_dot@
expression E;
identifier FP_NAME = profile;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_prepare(args);


// FP: progress_handler

@transform_standalone_progress_handler_dot@
expression E;
identifier FP_NAME = progress_handler;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_prepare16(args);


// FP: randomness

@transform_standalone_randomness_dot@
expression E;
identifier FP_NAME = randomness;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_sleep(args);


// FP: realloc

@transform_standalone_realloc_dot@
expression E;
identifier FP_NAME = realloc;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_profile(args);


// FP: realloc64

@transform_standalone_realloc64_dot@
expression E;
identifier FP_NAME = realloc64;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_stmt_busy(args);


// FP: release_memory

@transform_standalone_release_memory_dot@
expression E;
identifier FP_NAME = release_memory;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ 0;


// FP: reset

@transform_standalone_reset_dot@
expression E;
identifier FP_NAME = reset;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_progress_handler(args);


// FP: reset_auto_extension

@transform_standalone_reset_auto_extension_dot@
expression E;
identifier FP_NAME = reset_auto_extension;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_stmt_readonly(args);


// FP: result_blob

@transform_standalone_result_blob_dot@
expression E;
identifier FP_NAME = result_blob;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_realloc(args);


// FP: result_blob64

@transform_standalone_result_blob64_dot@
expression E;
identifier FP_NAME = result_blob64;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_stricmp(args);


// FP: result_double

@transform_standalone_result_double_dot@
expression E;
identifier FP_NAME = result_double;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_reset(args);


// FP: result_error

@transform_standalone_result_error_dot@
expression E;
identifier FP_NAME = result_error;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_result_blob(args);


// FP: result_error16

@transform_standalone_result_error16_dot@
expression E;
identifier FP_NAME = result_error16;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_result_double(args);


// FP: result_error_code

@transform_standalone_result_error_code_dot@
expression E;
identifier FP_NAME = result_error_code;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_result_error_nomem(args);


// FP: result_error_nomem

@transform_standalone_result_error_nomem_dot@
expression E;
identifier FP_NAME = result_error_nomem;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ 0;


// FP: result_error_toobig

@transform_standalone_result_error_toobig_dot@
expression E;
identifier FP_NAME = result_error_toobig;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ 0;


// FP: result_int

@transform_standalone_result_int_dot@
expression E;
identifier FP_NAME = result_int;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_result_error(args);


// FP: result_int64

@transform_standalone_result_int64_dot@
expression E;
identifier FP_NAME = result_int64;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_result_error16(args);


// FP: result_null

@transform_standalone_result_null_dot@
expression E;
identifier FP_NAME = result_null;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_result_int(args);


// FP: result_pointer

@transform_standalone_result_pointer_dot@
expression E;
identifier FP_NAME = result_pointer;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_value_free(args);


// FP: result_subtype

@transform_standalone_result_subtype_dot@
expression E;
identifier FP_NAME = result_subtype;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_bind_text64(args);


// FP: result_text

@transform_standalone_result_text_dot@
expression E;
identifier FP_NAME = result_text;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_result_int64(args);


// FP: result_text16

@transform_standalone_result_text16_dot@
expression E;
identifier FP_NAME = result_text16;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_result_null(args);


// FP: result_text16be

@transform_standalone_result_text16be_dot@
expression E;
identifier FP_NAME = result_text16be;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_result_text(args);


// FP: result_text16le

@transform_standalone_result_text16le_dot@
expression E;
identifier FP_NAME = result_text16le;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_result_text16(args);


// FP: result_text64

@transform_standalone_result_text64_dot@
expression E;
identifier FP_NAME = result_text64;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_uri_boolean(args);


// FP: result_value

@transform_standalone_result_value_dot@
expression E;
identifier FP_NAME = result_value;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_result_text16be(args);


// FP: result_zeroblob

@transform_standalone_result_zeroblob_dot@
expression E;
identifier FP_NAME = result_zeroblob;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_release_memory(args);


// FP: result_zeroblob64

@transform_standalone_result_zeroblob64_dot@
expression E;
identifier FP_NAME = result_zeroblob64;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_wal_checkpoint_v2(args);


// FP: rollback_hook

@transform_standalone_rollback_hook_dot@
expression E;
identifier FP_NAME = rollback_hook;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_result_text16le(args);


// FP: serialize

@transform_standalone_serialize_dot@
expression E;
identifier FP_NAME = serialize;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_filename_database(args);


// FP: set_authorizer

@transform_standalone_set_authorizer_dot@
expression E;
identifier FP_NAME = set_authorizer;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_result_value(args);


// FP: set_auxdata

@transform_standalone_set_auxdata_dot@
expression E;
identifier FP_NAME = set_auxdata;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_rollback_hook(args);


// FP: set_clientdata

@transform_standalone_set_clientdata_dot@
expression E;
identifier FP_NAME = set_clientdata;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_txn_state(args);


// FP: set_errmsg

@transform_standalone_set_errmsg_dot@
expression E;
identifier FP_NAME = set_errmsg;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_total_changes64(args);


// FP: set_last_insert_rowid

@transform_standalone_set_last_insert_rowid_dot@
expression E;
identifier FP_NAME = set_last_insert_rowid;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_result_blob64(args);


// FP: setlk_timeout

@transform_standalone_setlk_timeout_dot@
expression E;
identifier FP_NAME = setlk_timeout;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_changes64(args);


// FP: soft_heap_limit

@transform_standalone_soft_heap_limit_dot@
expression E;
identifier FP_NAME = soft_heap_limit;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_mutex_enter(args);


// FP: soft_heap_limit64

@transform_standalone_soft_heap_limit64_dot@
expression E;
identifier FP_NAME = soft_heap_limit64;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_backup_step(args);


// FP: sql

@transform_standalone_sql_dot@
expression E;
identifier FP_NAME = sql;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_threadsafe(args);


// FP: status

@transform_standalone_status_dot@
expression E;
identifier FP_NAME = status;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_result_zeroblob(args);


// FP: status64

@transform_standalone_status64_dot@
expression E;
identifier FP_NAME = status64;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_cancel_auto_extension(args);


// FP: step

@transform_standalone_step_dot@
expression E;
identifier FP_NAME = step;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_set_auxdata(args);


// FP: stmt_explain

@transform_standalone_stmt_explain_dot@
expression E;
identifier FP_NAME = stmt_explain;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_free_filename(args);


// FP: stmt_isexplain

@transform_standalone_stmt_isexplain_dot@
expression E;
identifier FP_NAME = stmt_isexplain;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_keyword_name(args);


// FP: stmt_status

@transform_standalone_stmt_status_dot@
expression E;
identifier FP_NAME = stmt_status;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_compileoption_used(args);


// FP: str_append

@transform_standalone_str_append_dot@
expression E;
identifier FP_NAME = str_append;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_prepare_v3(args);


// FP: str_appendall

@transform_standalone_str_appendall_dot@
expression E;
identifier FP_NAME = str_appendall;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_prepare16_v3(args);


// FP: str_appendchar

@transform_standalone_str_appendchar_dot@
expression E;
identifier FP_NAME = str_appendchar;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_bind_pointer(args);


// FP: str_appendf

@transform_standalone_str_appendf_dot@
expression E;
identifier FP_NAME = str_appendf;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_expanded_sql(args);


// FP: str_errcode

@transform_standalone_str_errcode_dot@
expression E;
identifier FP_NAME = str_errcode;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_value_pointer(args);


// FP: str_finish

@transform_standalone_str_finish_dot@
expression E;
identifier FP_NAME = str_finish;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_trace_v2(args);


// FP: str_length

@transform_standalone_str_length_dot@
expression E;
identifier FP_NAME = str_length;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_vtab_nochange(args);


// FP: str_new

@transform_standalone_str_new_dot@
expression E;
identifier FP_NAME = str_new;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_system_errno(args);


// FP: str_reset

@transform_standalone_str_reset_dot@
expression E;
identifier FP_NAME = str_reset;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_result_pointer(args);


// FP: str_value

@transform_standalone_str_value_dot@
expression E;
identifier FP_NAME = str_value;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_value_nochange(args);


// FP: str_vappendf

@transform_standalone_str_vappendf_dot@
expression E;
identifier FP_NAME = str_vappendf;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_set_last_insert_rowid(args);


// FP: strglob

@transform_standalone_strglob_dot@
expression E;
identifier FP_NAME = strglob;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_uri_int64(args);


// FP: stricmp

@transform_standalone_stricmp_dot@
expression E;
identifier FP_NAME = stricmp;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_wal_checkpoint(args);


// FP: strlike

@transform_standalone_strlike_dot@
expression E;
identifier FP_NAME = strlike;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_load_extension(args);


// FP: system_errno

@transform_standalone_system_errno_dot@
expression E;
identifier FP_NAME = system_errno;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_msize(args);


// FP: table_column_metadata

@transform_standalone_table_column_metadata_dot@
expression E;
identifier FP_NAME = table_column_metadata;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_snprintf(args);


// FP: test_control

@transform_standalone_test_control_dot@
expression E;
identifier FP_NAME = test_control;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_result_error_toobig(args);


// FP: thread_cleanup

@transform_standalone_thread_cleanup_dot@
expression E;
identifier FP_NAME = thread_cleanup;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_step(args);


// FP: total_changes

@transform_standalone_total_changes_dot@
expression E;
identifier FP_NAME = total_changes;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_table_column_metadata(args);


// FP: total_changes64

@transform_standalone_total_changes64_dot@
expression E;
identifier FP_NAME = total_changes64;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_create_window_function(args);


// FP: trace_v2

@transform_standalone_trace_v2_dot@
expression E;
identifier FP_NAME = trace_v2;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_realloc64(args);


// FP: txn_state

@transform_standalone_txn_state_dot@
expression E;
identifier FP_NAME = txn_state;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_str_length(args);


// FP: unlock_notify

@transform_standalone_unlock_notify_dot@
expression E;
identifier FP_NAME = unlock_notify;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ 0;


// FP: uri_boolean

@transform_standalone_uri_boolean_dot@
expression E;
identifier FP_NAME = uri_boolean;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_wal_hook(args);


// FP: uri_key

@transform_standalone_uri_key_dot@
expression E;
identifier FP_NAME = uri_key;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_str_appendf(args);


// FP: uri_parameter

@transform_standalone_uri_parameter_dot@
expression E;
identifier FP_NAME = uri_parameter;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ 0;


// FP: user_data

@transform_standalone_user_data_dot@
expression E;
identifier FP_NAME = user_data;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_trace(args);


// FP: value_double

@transform_standalone_value_double_dot@
expression E;
identifier FP_NAME = value_double;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_user_data(args);


// FP: value_dup

@transform_standalone_value_dup_dot@
expression E;
identifier FP_NAME = value_dup;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_uri_parameter(args);


// FP: value_encoding

@transform_standalone_value_encoding_dot@
expression E;
identifier FP_NAME = value_encoding;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_filename_wal(args);


// FP: value_free

@transform_standalone_value_free_dot@
expression E;
identifier FP_NAME = value_free;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_vsnprintf(args);


// FP: value_frombind

@transform_standalone_value_frombind_dot@
expression E;
identifier FP_NAME = value_frombind;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_keyword_check(args);


// FP: value_int

@transform_standalone_value_int_dot@
expression E;
identifier FP_NAME = value_int;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_value_blob(args);


// FP: value_int64

@transform_standalone_value_int64_dot@
expression E;
identifier FP_NAME = value_int64;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_value_bytes(args);


// FP: value_nochange

@transform_standalone_value_nochange_dot@
expression E;
identifier FP_NAME = value_nochange;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_value_subtype(args);


// FP: value_numeric_type

@transform_standalone_value_numeric_type_dot@
expression E;
identifier FP_NAME = value_numeric_type;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_value_bytes16(args);


// FP: value_pointer

@transform_standalone_value_pointer_dot@
expression E;
identifier FP_NAME = value_pointer;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_result_zeroblob64(args);


// FP: value_subtype

@transform_standalone_value_subtype_dot@
expression E;
identifier FP_NAME = value_subtype;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_bind_blob64(args);


// FP: value_text

@transform_standalone_value_text_dot@
expression E;
identifier FP_NAME = value_text;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_value_double(args);


// FP: value_text16

@transform_standalone_value_text16_dot@
expression E;
identifier FP_NAME = value_text16;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_value_int(args);


// FP: value_text16be

@transform_standalone_value_text16be_dot@
expression E;
identifier FP_NAME = value_text16be;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_value_int64(args);


// FP: value_text16le

@transform_standalone_value_text16le_dot@
expression E;
identifier FP_NAME = value_text16le;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_value_numeric_type(args);


// FP: value_type

@transform_standalone_value_type_dot@
expression E;
identifier FP_NAME = value_type;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_value_text(args);


// FP: vfs_find

@transform_standalone_vfs_find_dot@
expression E;
identifier FP_NAME = vfs_find;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_mutex_free(args);


// FP: vfs_register

@transform_standalone_vfs_register_dot@
expression E;
identifier FP_NAME = vfs_register;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_mutex_leave(args);


// FP: vfs_unregister

@transform_standalone_vfs_unregister_dot@
expression E;
identifier FP_NAME = vfs_unregister;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_mutex_try(args);


// FP: vmprintf

@transform_standalone_vmprintf_dot@
expression E;
identifier FP_NAME = vmprintf;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_value_text16(args);


// FP: vtab_collation

@transform_standalone_vtab_collation_dot@
expression E;
identifier FP_NAME = vtab_collation;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_result_subtype(args);


// FP: vtab_config

@transform_standalone_vtab_config_dot@
expression E;
identifier FP_NAME = vtab_config;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_extended_errcode(args);


// FP: vtab_distinct

@transform_standalone_vtab_distinct_dot@
expression E;
identifier FP_NAME = vtab_distinct;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_value_frombind(args);


// FP: vtab_nochange

@transform_standalone_vtab_nochange_dot@
expression E;
identifier FP_NAME = vtab_nochange;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_bind_zeroblob64(args);


// FP: vtab_on_conflict

@transform_standalone_vtab_on_conflict_dot@
expression E;
identifier FP_NAME = vtab_on_conflict;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_log(args);


// FP: wal_checkpoint

@transform_standalone_wal_checkpoint_dot@
expression E;
identifier FP_NAME = wal_checkpoint;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_db_config(args);


// FP: wal_hook

@transform_standalone_wal_hook_dot@
expression E;
identifier FP_NAME = wal_hook;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_db_mutex(args);


// FP: xAccess

@transform_standalone_xAccess_dot@
expression E;
identifier FP_NAME = xAccess;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xAccess_signature, xAccess_signatures[xAccess_apndAccess_enum], sizeof(E.xAccess_signature)) == 0) {
+ apndAccess(args);
+ }
+ else if (memcmp(E.xAccess_signature, xAccess_signatures[xAccess_memdbAccess_enum], sizeof(E.xAccess_signature)) == 0) {
+ memdbAccess(args);
+ }
+ else if (memcmp(E.xAccess_signature, xAccess_signatures[xAccess_vfstraceAccess_enum], sizeof(E.xAccess_signature)) == 0) {
+ vfstraceAccess(args);
+ }
+ else if (memcmp(E.xAccess_signature, xAccess_signatures[xAccess_unixAccess_enum], sizeof(E.xAccess_signature)) == 0) {
+ unixAccess(args);
+ }


// FP: xAltLocaltime

@transform_standalone_xAltLocaltime_dot@
expression E;
identifier FP_NAME = xAltLocaltime;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ 0;


// FP: xAutovacDestr

@transform_standalone_xAutovacDestr_dot@
expression E;
identifier FP_NAME = xAutovacDestr;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xAutovacDestr_signature, xAutovacDestr_signatures[xAutovacDestr_0_enum], sizeof(E.xAutovacDestr_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xAutovacDestr_signature, xAutovacDestr_signatures[xAutovacDestr_rtreeMatchArgFree_enum], sizeof(E.xAutovacDestr_signature)) == 0) {
+ rtreeMatchArgFree(args);
+ }
+ else if (memcmp(E.xAutovacDestr_signature, xAutovacDestr_signatures[xAutovacDestr_sqlite3VdbeValueListFree_enum], sizeof(E.xAutovacDestr_signature)) == 0) {
+ sqlite3VdbeValueListFree(args);
+ }


// FP: xAutovacPages

@transform_standalone_xAutovacPages_dot@
expression E;
identifier FP_NAME = xAutovacPages;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xAutovacPages_signature, xAutovacPages_signatures[xAutovacPages_0_enum], sizeof(E.xAutovacPages_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xAutovacPages_signature, xAutovacPages_signatures[xAutovacPages_sql_trace_callback_enum], sizeof(E.xAutovacPages_signature)) == 0) {
+ sql_trace_callback(args);
+ }
+ else if (memcmp(E.xAutovacPages_signature, xAutovacPages_signatures[xAutovacPages_sqlite3WalDefaultHook_enum], sizeof(E.xAutovacPages_signature)) == 0) {
+ sqlite3WalDefaultHook(args);
+ }


// FP: xBegin

@transform_standalone_xBegin_dot@
expression E;
identifier FP_NAME = xBegin;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xBegin_signature, xBegin_signatures[xBegin_0_enum], sizeof(E.xBegin_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xBegin_signature, xBegin_signatures[xBegin_dbpageBegin_enum], sizeof(E.xBegin_signature)) == 0) {
+ dbpageBegin(args);
+ }
+ else if (memcmp(E.xBegin_signature, xBegin_signatures[xBegin_fts3BeginMethod_enum], sizeof(E.xBegin_signature)) == 0) {
+ fts3BeginMethod(args);
+ }
+ else if (memcmp(E.xBegin_signature, xBegin_signatures[xBegin_rtreeBeginTransaction_enum], sizeof(E.xBegin_signature)) == 0) {
+ rtreeBeginTransaction(args);
+ }
+ else if (memcmp(E.xBegin_signature, xBegin_signatures[xBegin_zipfileBegin_enum], sizeof(E.xBegin_signature)) == 0) {
+ zipfileBegin(args);
+ }


// FP: xBestIndex

@transform_standalone_xBestIndex_dot@
expression E;
identifier FP_NAME = xBestIndex;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xBestIndex_signature, xBestIndex_signatures[xBestIndex_bytecodevtabBestIndex_enum], sizeof(E.xBestIndex_signature)) == 0) {
+ bytecodevtabBestIndex(args);
+ }
+ else if (memcmp(E.xBestIndex_signature, xBestIndex_signatures[xBestIndex_completionBestIndex_enum], sizeof(E.xBestIndex_signature)) == 0) {
+ completionBestIndex(args);
+ }
+ else if (memcmp(E.xBestIndex_signature, xBestIndex_signatures[xBestIndex_dbdataBestIndex_enum], sizeof(E.xBestIndex_signature)) == 0) {
+ dbdataBestIndex(args);
+ }
+ else if (memcmp(E.xBestIndex_signature, xBestIndex_signatures[xBestIndex_dbpageBestIndex_enum], sizeof(E.xBestIndex_signature)) == 0) {
+ dbpageBestIndex(args);
+ }
+ else if (memcmp(E.xBestIndex_signature, xBestIndex_signatures[xBestIndex_expertBestIndex_enum], sizeof(E.xBestIndex_signature)) == 0) {
+ expertBestIndex(args);
+ }
+ else if (memcmp(E.xBestIndex_signature, xBestIndex_signatures[xBestIndex_fsdirBestIndex_enum], sizeof(E.xBestIndex_signature)) == 0) {
+ fsdirBestIndex(args);
+ }
+ else if (memcmp(E.xBestIndex_signature, xBestIndex_signatures[xBestIndex_fts3BestIndexMethod_enum], sizeof(E.xBestIndex_signature)) == 0) {
+ fts3BestIndexMethod(args);
+ }
+ else if (memcmp(E.xBestIndex_signature, xBestIndex_signatures[xBestIndex_fts3auxBestIndexMethod_enum], sizeof(E.xBestIndex_signature)) == 0) {
+ fts3auxBestIndexMethod(args);
+ }
+ else if (memcmp(E.xBestIndex_signature, xBestIndex_signatures[xBestIndex_fts3tokBestIndexMethod_enum], sizeof(E.xBestIndex_signature)) == 0) {
+ fts3tokBestIndexMethod(args);
+ }
+ else if (memcmp(E.xBestIndex_signature, xBestIndex_signatures[xBestIndex_jsonEachBestIndex_enum], sizeof(E.xBestIndex_signature)) == 0) {
+ jsonEachBestIndex(args);
+ }
+ else if (memcmp(E.xBestIndex_signature, xBestIndex_signatures[xBestIndex_pragmaVtabBestIndex_enum], sizeof(E.xBestIndex_signature)) == 0) {
+ pragmaVtabBestIndex(args);
+ }
+ else if (memcmp(E.xBestIndex_signature, xBestIndex_signatures[xBestIndex_rtreeBestIndex_enum], sizeof(E.xBestIndex_signature)) == 0) {
+ rtreeBestIndex(args);
+ }
+ else if (memcmp(E.xBestIndex_signature, xBestIndex_signatures[xBestIndex_seriesBestIndex_enum], sizeof(E.xBestIndex_signature)) == 0) {
+ seriesBestIndex(args);
+ }
+ else if (memcmp(E.xBestIndex_signature, xBestIndex_signatures[xBestIndex_statBestIndex_enum], sizeof(E.xBestIndex_signature)) == 0) {
+ statBestIndex(args);
+ }
+ else if (memcmp(E.xBestIndex_signature, xBestIndex_signatures[xBestIndex_stmtBestIndex_enum], sizeof(E.xBestIndex_signature)) == 0) {
+ stmtBestIndex(args);
+ }
+ else if (memcmp(E.xBestIndex_signature, xBestIndex_signatures[xBestIndex_zipfileBestIndex_enum], sizeof(E.xBestIndex_signature)) == 0) {
+ zipfileBestIndex(args);
+ }


// FP: xBusyHandler

@transform_standalone_xBusyHandler_dot@
expression E;
identifier FP_NAME = xBusyHandler;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xBusyHandler_signature, xBusyHandler_signatures[xBusyHandler_0_enum], sizeof(E.xBusyHandler_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xBusyHandler_signature, xBusyHandler_signatures[xBusyHandler_btreeInvokeBusyHandler_enum], sizeof(E.xBusyHandler_signature)) == 0) {
+ btreeInvokeBusyHandler(args);
+ }
+ else if (memcmp(E.xBusyHandler_signature, xBusyHandler_signatures[xBusyHandler_sqliteDefaultBusyCallback_enum], sizeof(E.xBusyHandler_signature)) == 0) {
+ sqliteDefaultBusyCallback(args);
+ }
+ else if (memcmp(E.xBusyHandler_signature, xBusyHandler_signatures[xBusyHandler_xBusyHandler_enum], sizeof(E.xBusyHandler_signature)) == 0) {
+ xBusyHandler(args);
+ }


// FP: xCachesize

@transform_standalone_xCachesize_dot@
expression E;
identifier FP_NAME = xCachesize;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xCachesize_signature, xCachesize_signatures[xCachesize_pcache1Cachesize_enum], sizeof(E.xCachesize_signature)) == 0) {
+ pcache1Cachesize(args);
+ }
+ else if (memcmp(E.xCachesize_signature, xCachesize_signatures[xCachesize_pcachetraceCachesize_enum], sizeof(E.xCachesize_signature)) == 0) {
+ pcachetraceCachesize(args);
+ }


// FP: xCellSize

@transform_standalone_xCellSize_dot@
expression E;
identifier FP_NAME = xCellSize;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xCellSize_signature, xCellSize_signatures[xCellSize_cellSizePtr_enum], sizeof(E.xCellSize_signature)) == 0) {
+ cellSizePtr(args);
+ }
+ else if (memcmp(E.xCellSize_signature, xCellSize_signatures[xCellSize_cellSizePtrIdxLeaf_enum], sizeof(E.xCellSize_signature)) == 0) {
+ cellSizePtrIdxLeaf(args);
+ }
+ else if (memcmp(E.xCellSize_signature, xCellSize_signatures[xCellSize_cellSizePtrNoPayload_enum], sizeof(E.xCellSize_signature)) == 0) {
+ cellSizePtrNoPayload(args);
+ }
+ else if (memcmp(E.xCellSize_signature, xCellSize_signatures[xCellSize_cellSizePtrTableLeaf_enum], sizeof(E.xCellSize_signature)) == 0) {
+ cellSizePtrTableLeaf(args);
+ }


// FP: xCheckReservedLock

@transform_standalone_xCheckReservedLock_dot@
expression E;
identifier FP_NAME = xCheckReservedLock;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xCheckReservedLock_signature, xCheckReservedLock_signatures[xCheckReservedLock_0_enum], sizeof(E.xCheckReservedLock_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xCheckReservedLock_signature, xCheckReservedLock_signatures[xCheckReservedLock_apndCheckReservedLock_enum], sizeof(E.xCheckReservedLock_signature)) == 0) {
+ apndCheckReservedLock(args);
+ }
+ else if (memcmp(E.xCheckReservedLock_signature, xCheckReservedLock_signatures[xCheckReservedLock_recoverVfsCheckReservedLock_enum], sizeof(E.xCheckReservedLock_signature)) == 0) {
+ recoverVfsCheckReservedLock(args);
+ }
+ else if (memcmp(E.xCheckReservedLock_signature, xCheckReservedLock_signatures[xCheckReservedLock_vfstraceCheckReservedLock_enum], sizeof(E.xCheckReservedLock_signature)) == 0) {
+ vfstraceCheckReservedLock(args);
+ }


// FP: xCleanup

@transform_standalone_xCleanup_dot@
expression E;
identifier FP_NAME = xCleanup;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xCleanup_signature, xCleanup_signatures[xCleanup_agginfoFree_enum], sizeof(E.xCleanup_signature)) == 0) {
+ agginfoFree(args);
+ }
+ else if (memcmp(E.xCleanup_signature, xCleanup_signatures[xCleanup_sqlite3DbFree_enum], sizeof(E.xCleanup_signature)) == 0) {
+ sqlite3DbFree(args);
+ }
+ else if (memcmp(E.xCleanup_signature, xCleanup_signatures[xCleanup_sqlite3DeleteReturning_enum], sizeof(E.xCleanup_signature)) == 0) {
+ sqlite3DeleteReturning(args);
+ }
+ else if (memcmp(E.xCleanup_signature, xCleanup_signatures[xCleanup_sqlite3DeleteTableGeneric_enum], sizeof(E.xCleanup_signature)) == 0) {
+ sqlite3DeleteTableGeneric(args);
+ }
+ else if (memcmp(E.xCleanup_signature, xCleanup_signatures[xCleanup_sqlite3ExprDeleteGeneric_enum], sizeof(E.xCleanup_signature)) == 0) {
+ sqlite3ExprDeleteGeneric(args);
+ }
+ else if (memcmp(E.xCleanup_signature, xCleanup_signatures[xCleanup_sqlite3ExprListDeleteGeneric_enum], sizeof(E.xCleanup_signature)) == 0) {
+ sqlite3ExprListDeleteGeneric(args);
+ }
+ else if (memcmp(E.xCleanup_signature, xCleanup_signatures[xCleanup_sqlite3SelectDeleteGeneric_enum], sizeof(E.xCleanup_signature)) == 0) {
+ sqlite3SelectDeleteGeneric(args);
+ }
+ else if (memcmp(E.xCleanup_signature, xCleanup_signatures[xCleanup_sqlite3WithDeleteGeneric_enum], sizeof(E.xCleanup_signature)) == 0) {
+ sqlite3WithDeleteGeneric(args);
+ }
+ else if (memcmp(E.xCleanup_signature, xCleanup_signatures[xCleanup_whereIndexedExprCleanup_enum], sizeof(E.xCleanup_signature)) == 0) {
+ whereIndexedExprCleanup(args);
+ }


// FP: xClose

@transform_standalone_xClose_dot@
expression E;
identifier FP_NAME = xClose;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xClose_signature, xClose_signatures[xClose_apndClose_enum], sizeof(E.xClose_signature)) == 0) {
+ apndClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_bytecodevtabClose_enum], sizeof(E.xClose_signature)) == 0) {
+ bytecodevtabClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_completionClose_enum], sizeof(E.xClose_signature)) == 0) {
+ completionClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_dbdataClose_enum], sizeof(E.xClose_signature)) == 0) {
+ dbdataClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_dbpageClose_enum], sizeof(E.xClose_signature)) == 0) {
+ dbpageClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_expertClose_enum], sizeof(E.xClose_signature)) == 0) {
+ expertClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_fsdirClose_enum], sizeof(E.xClose_signature)) == 0) {
+ fsdirClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_fts3CloseMethod_enum], sizeof(E.xClose_signature)) == 0) {
+ fts3CloseMethod(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_fts3auxCloseMethod_enum], sizeof(E.xClose_signature)) == 0) {
+ fts3auxCloseMethod(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_fts3tokCloseMethod_enum], sizeof(E.xClose_signature)) == 0) {
+ fts3tokCloseMethod(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_jsonEachClose_enum], sizeof(E.xClose_signature)) == 0) {
+ jsonEachClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_memdbClose_enum], sizeof(E.xClose_signature)) == 0) {
+ memdbClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_memjrnlClose_enum], sizeof(E.xClose_signature)) == 0) {
+ memjrnlClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_porterClose_enum], sizeof(E.xClose_signature)) == 0) {
+ porterClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_pragmaVtabClose_enum], sizeof(E.xClose_signature)) == 0) {
+ pragmaVtabClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_recoverVfsClose_enum], sizeof(E.xClose_signature)) == 0) {
+ recoverVfsClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_rtreeClose_enum], sizeof(E.xClose_signature)) == 0) {
+ rtreeClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_seriesClose_enum], sizeof(E.xClose_signature)) == 0) {
+ seriesClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_simpleClose_enum], sizeof(E.xClose_signature)) == 0) {
+ simpleClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_statClose_enum], sizeof(E.xClose_signature)) == 0) {
+ statClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_stmtClose_enum], sizeof(E.xClose_signature)) == 0) {
+ stmtClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_unicodeClose_enum], sizeof(E.xClose_signature)) == 0) {
+ unicodeClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_vfstraceClose_enum], sizeof(E.xClose_signature)) == 0) {
+ vfstraceClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_zipfileClose_enum], sizeof(E.xClose_signature)) == 0) {
+ zipfileClose(args);
+ }


// FP: xCmp

@transform_standalone_xCmp_dot@
expression E;
identifier FP_NAME = xCmp;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xCmp_signature, xCmp_signatures[xCmp_0_enum], sizeof(E.xCmp_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xCmp_signature, xCmp_signatures[xCmp_binCollFunc_enum], sizeof(E.xCmp_signature)) == 0) {
+ binCollFunc(args);
+ }
+ else if (memcmp(E.xCmp_signature, xCmp_signatures[xCmp_decimalCollFunc_enum], sizeof(E.xCmp_signature)) == 0) {
+ decimalCollFunc(args);
+ }
+ else if (memcmp(E.xCmp_signature, xCmp_signatures[xCmp_dummyCompare_enum], sizeof(E.xCmp_signature)) == 0) {
+ dummyCompare(args);
+ }
+ else if (memcmp(E.xCmp_signature, xCmp_signatures[xCmp_icuCollationColl_enum], sizeof(E.xCmp_signature)) == 0) {
+ icuCollationColl(args);
+ }
+ else if (memcmp(E.xCmp_signature, xCmp_signatures[xCmp_nocaseCollatingFunc_enum], sizeof(E.xCmp_signature)) == 0) {
+ nocaseCollatingFunc(args);
+ }
+ else if (memcmp(E.xCmp_signature, xCmp_signatures[xCmp_rtrimCollFunc_enum], sizeof(E.xCmp_signature)) == 0) {
+ rtrimCollFunc(args);
+ }
+ else if (memcmp(E.xCmp_signature, xCmp_signatures[xCmp_uintCollFunc_enum], sizeof(E.xCmp_signature)) == 0) {
+ uintCollFunc(args);
+ }


// FP: xCollNeeded16

@transform_standalone_xCollNeeded16_dot@
expression E;
identifier FP_NAME = xCollNeeded16;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ 0;


// FP: xColumn

@transform_standalone_xColumn_dot@
expression E;
identifier FP_NAME = xColumn;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_bytecodevtabColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ bytecodevtabColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_completionColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ completionColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_dbdataColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ dbdataColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_dbpageColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ dbpageColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_expertColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ expertColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_fsdirColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ fsdirColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_fts3ColumnMethod_enum], sizeof(E.xColumn_signature)) == 0) {
+ fts3ColumnMethod(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_fts3auxColumnMethod_enum], sizeof(E.xColumn_signature)) == 0) {
+ fts3auxColumnMethod(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_fts3tokColumnMethod_enum], sizeof(E.xColumn_signature)) == 0) {
+ fts3tokColumnMethod(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_geopolyColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ geopolyColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_jsonEachColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ jsonEachColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_pragmaVtabColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ pragmaVtabColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_rtreeColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ rtreeColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_seriesColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ seriesColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_statColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ statColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_stmtColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ stmtColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_zipfileColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ zipfileColumn(args);
+ }


// FP: xCommit

@transform_standalone_xCommit_dot@
expression E;
identifier FP_NAME = xCommit;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xCommit_signature, xCommit_signatures[xCommit_0_enum], sizeof(E.xCommit_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xCommit_signature, xCommit_signatures[xCommit_fts3CommitMethod_enum], sizeof(E.xCommit_signature)) == 0) {
+ fts3CommitMethod(args);
+ }
+ else if (memcmp(E.xCommit_signature, xCommit_signatures[xCommit_rtreeEndTransaction_enum], sizeof(E.xCommit_signature)) == 0) {
+ rtreeEndTransaction(args);
+ }
+ else if (memcmp(E.xCommit_signature, xCommit_signatures[xCommit_zipfileCommit_enum], sizeof(E.xCommit_signature)) == 0) {
+ zipfileCommit(args);
+ }


// FP: xCommitCallback

@transform_standalone_xCommitCallback_dot@
expression E;
identifier FP_NAME = xCommitCallback;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xCommitCallback_signature, xCommitCallback_signatures[xCommitCallback_0_enum], sizeof(E.xCommitCallback_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xCommitCallback_signature, xCommitCallback_signatures[xCommitCallback_sql_trace_callback_enum], sizeof(E.xCommitCallback_signature)) == 0) {
+ sql_trace_callback(args);
+ }
+ else if (memcmp(E.xCommitCallback_signature, xCommitCallback_signatures[xCommitCallback_sqlite3WalDefaultHook_enum], sizeof(E.xCommitCallback_signature)) == 0) {
+ sqlite3WalDefaultHook(args);
+ }


// FP: xConnect

@transform_standalone_xConnect_dot@
expression E;
identifier FP_NAME = xConnect;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_bytecodevtabConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ bytecodevtabConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_dbpageConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ dbpageConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_fts3ConnectMethod_enum], sizeof(E.xConnect_signature)) == 0) {
+ fts3ConnectMethod(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_fts3auxConnectMethod_enum], sizeof(E.xConnect_signature)) == 0) {
+ fts3auxConnectMethod(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_fts3tokConnectMethod_enum], sizeof(E.xConnect_signature)) == 0) {
+ fts3tokConnectMethod(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_jsonEachConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ jsonEachConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_pragmaVtabConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ pragmaVtabConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_rtreeConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ rtreeConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_statConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ statConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_stmtConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ stmtConnect(args);
+ }


// FP: xCount

@transform_standalone_xCount_dot@
expression E;
identifier FP_NAME = xCount;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xCount_signature, xCount_signatures[xCount_sessionDiffCount_enum], sizeof(E.xCount_signature)) == 0) {
+ sessionDiffCount(args);
+ }
+ else if (memcmp(E.xCount_signature, xCount_signatures[xCount_sessionPreupdateCount_enum], sizeof(E.xCount_signature)) == 0) {
+ sessionPreupdateCount(args);
+ }
+ else if (memcmp(E.xCount_signature, xCount_signatures[xCount_sessionStat1Count_enum], sizeof(E.xCount_signature)) == 0) {
+ sessionStat1Count(args);
+ }


// FP: xCreate

@transform_standalone_xCreate_dot@
expression E;
identifier FP_NAME = xCreate;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_0_enum], sizeof(E.xCreate_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_dbpageConnect_enum], sizeof(E.xCreate_signature)) == 0) {
+ dbpageConnect(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_fts3CreateMethod_enum], sizeof(E.xCreate_signature)) == 0) {
+ fts3CreateMethod(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_fts3auxConnectMethod_enum], sizeof(E.xCreate_signature)) == 0) {
+ fts3auxConnectMethod(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_fts3tokConnectMethod_enum], sizeof(E.xCreate_signature)) == 0) {
+ fts3tokConnectMethod(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_geopolyCreate_enum], sizeof(E.xCreate_signature)) == 0) {
+ geopolyCreate(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_pcache1Create_enum], sizeof(E.xCreate_signature)) == 0) {
+ pcache1Create(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_pcachetraceCreate_enum], sizeof(E.xCreate_signature)) == 0) {
+ pcachetraceCreate(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_porterCreate_enum], sizeof(E.xCreate_signature)) == 0) {
+ porterCreate(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_rtreeCreate_enum], sizeof(E.xCreate_signature)) == 0) {
+ rtreeCreate(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_simpleCreate_enum], sizeof(E.xCreate_signature)) == 0) {
+ simpleCreate(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_statConnect_enum], sizeof(E.xCreate_signature)) == 0) {
+ statConnect(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_unicodeCreate_enum], sizeof(E.xCreate_signature)) == 0) {
+ unicodeCreate(args);
+ }


// FP: xCurrentTime

@transform_standalone_xCurrentTime_dot@
expression E;
identifier FP_NAME = xCurrentTime;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xCurrentTime_signature, xCurrentTime_signatures[xCurrentTime_0_enum], sizeof(E.xCurrentTime_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xCurrentTime_signature, xCurrentTime_signatures[xCurrentTime_apndCurrentTime_enum], sizeof(E.xCurrentTime_signature)) == 0) {
+ apndCurrentTime(args);
+ }
+ else if (memcmp(E.xCurrentTime_signature, xCurrentTime_signatures[xCurrentTime_vfstraceCurrentTime_enum], sizeof(E.xCurrentTime_signature)) == 0) {
+ vfstraceCurrentTime(args);
+ }
+ else if (memcmp(E.xCurrentTime_signature, xCurrentTime_signatures[xCurrentTime_unixCurrentTime_enum], sizeof(E.xCurrentTime_signature)) == 0) {
+ unixCurrentTime(args);
+ }


// FP: xCurrentTimeInt64

@transform_standalone_xCurrentTimeInt64_dot@
expression E;
identifier FP_NAME = xCurrentTimeInt64;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xCurrentTimeInt64_signature, xCurrentTimeInt64_signatures[xCurrentTimeInt64_apndCurrentTimeInt64_enum], sizeof(E.xCurrentTimeInt64_signature)) == 0) {
+ apndCurrentTimeInt64(args);
+ }
+ else if (memcmp(E.xCurrentTimeInt64_signature, xCurrentTimeInt64_signatures[xCurrentTimeInt64_memdbCurrentTimeInt64_enum], sizeof(E.xCurrentTimeInt64_signature)) == 0) {
+ memdbCurrentTimeInt64(args);
+ }
+ else if (memcmp(E.xCurrentTimeInt64_signature, xCurrentTimeInt64_signatures[xCurrentTimeInt64_unixCurrentTimeInt64_enum], sizeof(E.xCurrentTimeInt64_signature)) == 0) {
+ unixCurrentTimeInt64(args);
+ }


// FP: xDel

@transform_standalone_xDel_dot@
expression E;
identifier FP_NAME = xDel;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xDel_signature, xDel_signatures[xDel_0_enum], sizeof(E.xDel_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xDel_signature, xDel_signatures[xDel_SQLITE_DYNAMIC_enum], sizeof(E.xDel_signature)) == 0) {
+ SQLITE_DYNAMIC(args);
+ }
+ else if (memcmp(E.xDel_signature, xDel_signatures[xDel_SQLITE_STATIC_enum], sizeof(E.xDel_signature)) == 0) {
+ SQLITE_STATIC(args);
+ }
+ else if (memcmp(E.xDel_signature, xDel_signatures[xDel_SQLITE_TRANSIENT_enum], sizeof(E.xDel_signature)) == 0) {
+ SQLITE_TRANSIENT(args);
+ }
+ else if (memcmp(E.xDel_signature, xDel_signatures[xDel_rtreeMatchArgFree_enum], sizeof(E.xDel_signature)) == 0) {
+ rtreeMatchArgFree(args);
+ }
+ else if (memcmp(E.xDel_signature, xDel_signatures[xDel_sqlite3RCStrUnref_enum], sizeof(E.xDel_signature)) == 0) {
+ sqlite3RCStrUnref(args);
+ }
+ else if (memcmp(E.xDel_signature, xDel_signatures[xDel_sqlite3RowSetDelete_enum], sizeof(E.xDel_signature)) == 0) {
+ sqlite3RowSetDelete(args);
+ }
+ else if (memcmp(E.xDel_signature, xDel_signatures[xDel_sqlite3SchemaClear_enum], sizeof(E.xDel_signature)) == 0) {
+ sqlite3SchemaClear(args);
+ }
+ else if (memcmp(E.xDel_signature, xDel_signatures[xDel_sqlite3VdbeFrameMemDel_enum], sizeof(E.xDel_signature)) == 0) {
+ sqlite3VdbeFrameMemDel(args);
+ }
+ else if (memcmp(E.xDel_signature, xDel_signatures[xDel_sqlite3VdbeValueListFree_enum], sizeof(E.xDel_signature)) == 0) {
+ sqlite3VdbeValueListFree(args);
+ }
+ else if (memcmp(E.xDel_signature, xDel_signatures[xDel_sqlite3_free_enum], sizeof(E.xDel_signature)) == 0) {
+ sqlite3_free(args);
+ }
+ else if (memcmp(E.xDel_signature, xDel_signatures[xDel_statAccumDestructor_enum], sizeof(E.xDel_signature)) == 0) {
+ statAccumDestructor(args);
+ }
+ else if (memcmp(E.xDel_signature, xDel_signatures[xDel_xDel_enum], sizeof(E.xDel_signature)) == 0) {
+ xDel(args);
+ }
+ else if (memcmp(E.xDel_signature, xDel_signatures[xDel_zipfileFree_enum], sizeof(E.xDel_signature)) == 0) {
+ zipfileFree(args);
+ }


// FP: xDelete

@transform_standalone_xDelete_dot@
expression E;
identifier FP_NAME = xDelete;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xDelete_signature, xDelete_signatures[xDelete_0_enum], sizeof(E.xDelete_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xDelete_signature, xDelete_signatures[xDelete_apndDelete_enum], sizeof(E.xDelete_signature)) == 0) {
+ apndDelete(args);
+ }
+ else if (memcmp(E.xDelete_signature, xDelete_signatures[xDelete_jsonCacheDeleteGeneric_enum], sizeof(E.xDelete_signature)) == 0) {
+ jsonCacheDeleteGeneric(args);
+ }
+ else if (memcmp(E.xDelete_signature, xDelete_signatures[xDelete_kvstorageDelete_enum], sizeof(E.xDelete_signature)) == 0) {
+ kvstorageDelete(args);
+ }
+ else if (memcmp(E.xDelete_signature, xDelete_signatures[xDelete_sqlite3_free_enum], sizeof(E.xDelete_signature)) == 0) {
+ sqlite3_free(args);
+ }
+ else if (memcmp(E.xDelete_signature, xDelete_signatures[xDelete_vfstraceDelete_enum], sizeof(E.xDelete_signature)) == 0) {
+ vfstraceDelete(args);
+ }
+ else if (memcmp(E.xDelete_signature, xDelete_signatures[xDelete_unixDelete_enum], sizeof(E.xDelete_signature)) == 0) {
+ unixDelete(args);
+ }


// FP: xDeleteAux

@transform_standalone_xDeleteAux_dot@
expression E;
identifier FP_NAME = xDeleteAux;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xDeleteAux_signature, xDeleteAux_signatures[xDeleteAux_jsonCacheDeleteGeneric_enum], sizeof(E.xDeleteAux_signature)) == 0) {
+ jsonCacheDeleteGeneric(args);
+ }
+ else if (memcmp(E.xDeleteAux_signature, xDeleteAux_signatures[xDeleteAux_sqlite3_free_enum], sizeof(E.xDeleteAux_signature)) == 0) {
+ sqlite3_free(args);
+ }


// FP: xDepth

@transform_standalone_xDepth_dot@
expression E;
identifier FP_NAME = xDepth;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xDepth_signature, xDepth_signatures[xDepth_sessionDiffDepth_enum], sizeof(E.xDepth_signature)) == 0) {
+ sessionDiffDepth(args);
+ }
+ else if (memcmp(E.xDepth_signature, xDepth_signatures[xDepth_sessionPreupdateDepth_enum], sizeof(E.xDepth_signature)) == 0) {
+ sessionPreupdateDepth(args);
+ }
+ else if (memcmp(E.xDepth_signature, xDepth_signatures[xDepth_sessionStat1Depth_enum], sizeof(E.xDepth_signature)) == 0) {
+ sessionStat1Depth(args);
+ }


// FP: xDestroy

@transform_standalone_xDestroy_dot@
expression E;
identifier FP_NAME = xDestroy;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xDestroy_signature, xDestroy_signatures[xDestroy_0_enum], sizeof(E.xDestroy_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xDestroy_signature, xDestroy_signatures[xDestroy_dbpageDisconnect_enum], sizeof(E.xDestroy_signature)) == 0) {
+ dbpageDisconnect(args);
+ }
+ else if (memcmp(E.xDestroy_signature, xDestroy_signatures[xDestroy_expertDisconnect_enum], sizeof(E.xDestroy_signature)) == 0) {
+ expertDisconnect(args);
+ }
+ else if (memcmp(E.xDestroy_signature, xDestroy_signatures[xDestroy_fts3DestroyMethod_enum], sizeof(E.xDestroy_signature)) == 0) {
+ fts3DestroyMethod(args);
+ }
+ else if (memcmp(E.xDestroy_signature, xDestroy_signatures[xDestroy_fts3auxDisconnectMethod_enum], sizeof(E.xDestroy_signature)) == 0) {
+ fts3auxDisconnectMethod(args);
+ }
+ else if (memcmp(E.xDestroy_signature, xDestroy_signatures[xDestroy_fts3tokDisconnectMethod_enum], sizeof(E.xDestroy_signature)) == 0) {
+ fts3tokDisconnectMethod(args);
+ }
+ else if (memcmp(E.xDestroy_signature, xDestroy_signatures[xDestroy_hashDestroy_enum], sizeof(E.xDestroy_signature)) == 0) {
+ hashDestroy(args);
+ }
+ else if (memcmp(E.xDestroy_signature, xDestroy_signatures[xDestroy_pcache1Destroy_enum], sizeof(E.xDestroy_signature)) == 0) {
+ pcache1Destroy(args);
+ }
+ else if (memcmp(E.xDestroy_signature, xDestroy_signatures[xDestroy_pcachetraceDestroy_enum], sizeof(E.xDestroy_signature)) == 0) {
+ pcachetraceDestroy(args);
+ }
+ else if (memcmp(E.xDestroy_signature, xDestroy_signatures[xDestroy_porterDestroy_enum], sizeof(E.xDestroy_signature)) == 0) {
+ porterDestroy(args);
+ }
+ else if (memcmp(E.xDestroy_signature, xDestroy_signatures[xDestroy_rtreeDestroy_enum], sizeof(E.xDestroy_signature)) == 0) {
+ rtreeDestroy(args);
+ }
+ else if (memcmp(E.xDestroy_signature, xDestroy_signatures[xDestroy_rtreeFreeCallback_enum], sizeof(E.xDestroy_signature)) == 0) {
+ rtreeFreeCallback(args);
+ }
+ else if (memcmp(E.xDestroy_signature, xDestroy_signatures[xDestroy_simpleDestroy_enum], sizeof(E.xDestroy_signature)) == 0) {
+ simpleDestroy(args);
+ }
+ else if (memcmp(E.xDestroy_signature, xDestroy_signatures[xDestroy_sqlite3_free_enum], sizeof(E.xDestroy_signature)) == 0) {
+ sqlite3_free(args);
+ }
+ else if (memcmp(E.xDestroy_signature, xDestroy_signatures[xDestroy_statDisconnect_enum], sizeof(E.xDestroy_signature)) == 0) {
+ statDisconnect(args);
+ }
+ else if (memcmp(E.xDestroy_signature, xDestroy_signatures[xDestroy_unicodeDestroy_enum], sizeof(E.xDestroy_signature)) == 0) {
+ unicodeDestroy(args);
+ }
+ else if (memcmp(E.xDestroy_signature, xDestroy_signatures[xDestroy_zipfileDisconnect_enum], sizeof(E.xDestroy_signature)) == 0) {
+ zipfileDisconnect(args);
+ }


// FP: xDestructor

@transform_standalone_xDestructor_dot@
expression E;
identifier FP_NAME = xDestructor;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xDestructor_signature, xDestructor_signatures[xDestructor_0_enum], sizeof(E.xDestructor_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xDestructor_signature, xDestructor_signatures[xDestructor_rtreeMatchArgFree_enum], sizeof(E.xDestructor_signature)) == 0) {
+ rtreeMatchArgFree(args);
+ }
+ else if (memcmp(E.xDestructor_signature, xDestructor_signatures[xDestructor_sqlite3VdbeValueListFree_enum], sizeof(E.xDestructor_signature)) == 0) {
+ sqlite3VdbeValueListFree(args);
+ }


// FP: xDeviceCharacteristics

@transform_standalone_xDeviceCharacteristics_dot@
expression E;
identifier FP_NAME = xDeviceCharacteristics;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xDeviceCharacteristics_signature, xDeviceCharacteristics_signatures[xDeviceCharacteristics_0_enum], sizeof(E.xDeviceCharacteristics_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xDeviceCharacteristics_signature, xDeviceCharacteristics_signatures[xDeviceCharacteristics_apndDeviceCharacteristics_enum], sizeof(E.xDeviceCharacteristics_signature)) == 0) {
+ apndDeviceCharacteristics(args);
+ }
+ else if (memcmp(E.xDeviceCharacteristics_signature, xDeviceCharacteristics_signatures[xDeviceCharacteristics_memdbDeviceCharacteristics_enum], sizeof(E.xDeviceCharacteristics_signature)) == 0) {
+ memdbDeviceCharacteristics(args);
+ }
+ else if (memcmp(E.xDeviceCharacteristics_signature, xDeviceCharacteristics_signatures[xDeviceCharacteristics_recoverVfsDeviceCharacteristics_enum], sizeof(E.xDeviceCharacteristics_signature)) == 0) {
+ recoverVfsDeviceCharacteristics(args);
+ }
+ else if (memcmp(E.xDeviceCharacteristics_signature, xDeviceCharacteristics_signatures[xDeviceCharacteristics_vfstraceDeviceCharacteristics_enum], sizeof(E.xDeviceCharacteristics_signature)) == 0) {
+ vfstraceDeviceCharacteristics(args);
+ }


// FP: xDisconnect

@transform_standalone_xDisconnect_dot@
expression E;
identifier FP_NAME = xDisconnect;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xDisconnect_signature, xDisconnect_signatures[xDisconnect_bytecodevtabDisconnect_enum], sizeof(E.xDisconnect_signature)) == 0) {
+ bytecodevtabDisconnect(args);
+ }
+ else if (memcmp(E.xDisconnect_signature, xDisconnect_signatures[xDisconnect_completionDisconnect_enum], sizeof(E.xDisconnect_signature)) == 0) {
+ completionDisconnect(args);
+ }
+ else if (memcmp(E.xDisconnect_signature, xDisconnect_signatures[xDisconnect_dbdataDisconnect_enum], sizeof(E.xDisconnect_signature)) == 0) {
+ dbdataDisconnect(args);
+ }
+ else if (memcmp(E.xDisconnect_signature, xDisconnect_signatures[xDisconnect_dbpageDisconnect_enum], sizeof(E.xDisconnect_signature)) == 0) {
+ dbpageDisconnect(args);
+ }
+ else if (memcmp(E.xDisconnect_signature, xDisconnect_signatures[xDisconnect_expertDisconnect_enum], sizeof(E.xDisconnect_signature)) == 0) {
+ expertDisconnect(args);
+ }
+ else if (memcmp(E.xDisconnect_signature, xDisconnect_signatures[xDisconnect_fsdirDisconnect_enum], sizeof(E.xDisconnect_signature)) == 0) {
+ fsdirDisconnect(args);
+ }
+ else if (memcmp(E.xDisconnect_signature, xDisconnect_signatures[xDisconnect_fts3DisconnectMethod_enum], sizeof(E.xDisconnect_signature)) == 0) {
+ fts3DisconnectMethod(args);
+ }
+ else if (memcmp(E.xDisconnect_signature, xDisconnect_signatures[xDisconnect_fts3auxDisconnectMethod_enum], sizeof(E.xDisconnect_signature)) == 0) {
+ fts3auxDisconnectMethod(args);
+ }
+ else if (memcmp(E.xDisconnect_signature, xDisconnect_signatures[xDisconnect_fts3tokDisconnectMethod_enum], sizeof(E.xDisconnect_signature)) == 0) {
+ fts3tokDisconnectMethod(args);
+ }
+ else if (memcmp(E.xDisconnect_signature, xDisconnect_signatures[xDisconnect_jsonEachDisconnect_enum], sizeof(E.xDisconnect_signature)) == 0) {
+ jsonEachDisconnect(args);
+ }
+ else if (memcmp(E.xDisconnect_signature, xDisconnect_signatures[xDisconnect_pragmaVtabDisconnect_enum], sizeof(E.xDisconnect_signature)) == 0) {
+ pragmaVtabDisconnect(args);
+ }
+ else if (memcmp(E.xDisconnect_signature, xDisconnect_signatures[xDisconnect_rtreeDisconnect_enum], sizeof(E.xDisconnect_signature)) == 0) {
+ rtreeDisconnect(args);
+ }
+ else if (memcmp(E.xDisconnect_signature, xDisconnect_signatures[xDisconnect_seriesDisconnect_enum], sizeof(E.xDisconnect_signature)) == 0) {
+ seriesDisconnect(args);
+ }
+ else if (memcmp(E.xDisconnect_signature, xDisconnect_signatures[xDisconnect_statDisconnect_enum], sizeof(E.xDisconnect_signature)) == 0) {
+ statDisconnect(args);
+ }
+ else if (memcmp(E.xDisconnect_signature, xDisconnect_signatures[xDisconnect_stmtDisconnect_enum], sizeof(E.xDisconnect_signature)) == 0) {
+ stmtDisconnect(args);
+ }
+ else if (memcmp(E.xDisconnect_signature, xDisconnect_signatures[xDisconnect_zipfileDisconnect_enum], sizeof(E.xDisconnect_signature)) == 0) {
+ zipfileDisconnect(args);
+ }


// FP: xDlClose

@transform_standalone_xDlClose_dot@
expression E;
identifier FP_NAME = xDlClose;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xDlClose_signature, xDlClose_signatures[xDlClose_0_enum], sizeof(E.xDlClose_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xDlClose_signature, xDlClose_signatures[xDlClose_apndDlClose_enum], sizeof(E.xDlClose_signature)) == 0) {
+ apndDlClose(args);
+ }
+ else if (memcmp(E.xDlClose_signature, xDlClose_signatures[xDlClose_memdbDlClose_enum], sizeof(E.xDlClose_signature)) == 0) {
+ memdbDlClose(args);
+ }
+ else if (memcmp(E.xDlClose_signature, xDlClose_signatures[xDlClose_unixDlClose_enum], sizeof(E.xDlClose_signature)) == 0) {
+ unixDlClose(args);
+ }


// FP: xDlError

@transform_standalone_xDlError_dot@
expression E;
identifier FP_NAME = xDlError;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xDlError_signature, xDlError_signatures[xDlError_0_enum], sizeof(E.xDlError_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xDlError_signature, xDlError_signatures[xDlError_apndDlError_enum], sizeof(E.xDlError_signature)) == 0) {
+ apndDlError(args);
+ }
+ else if (memcmp(E.xDlError_signature, xDlError_signatures[xDlError_memdbDlError_enum], sizeof(E.xDlError_signature)) == 0) {
+ memdbDlError(args);
+ }
+ else if (memcmp(E.xDlError_signature, xDlError_signatures[xDlError_unixDlError_enum], sizeof(E.xDlError_signature)) == 0) {
+ unixDlError(args);
+ }


// FP: xDlOpen

@transform_standalone_xDlOpen_dot@
expression E;
identifier FP_NAME = xDlOpen;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xDlOpen_signature, xDlOpen_signatures[xDlOpen_apndDlOpen_enum], sizeof(E.xDlOpen_signature)) == 0) {
+ apndDlOpen(args);
+ }
+ else if (memcmp(E.xDlOpen_signature, xDlOpen_signatures[xDlOpen_memdbDlOpen_enum], sizeof(E.xDlOpen_signature)) == 0) {
+ memdbDlOpen(args);
+ }
+ else if (memcmp(E.xDlOpen_signature, xDlOpen_signatures[xDlOpen_unixDlOpen_enum], sizeof(E.xDlOpen_signature)) == 0) {
+ unixDlOpen(args);
+ }


// FP: xDlSym

@transform_standalone_xDlSym_dot@
expression E;
identifier FP_NAME = xDlSym;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xDlSym_signature, xDlSym_signatures[xDlSym_0_enum], sizeof(E.xDlSym_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xDlSym_signature, xDlSym_signatures[xDlSym_apndDlSym_enum], sizeof(E.xDlSym_signature)) == 0) {
+ apndDlSym(args);
+ }
+ else if (memcmp(E.xDlSym_signature, xDlSym_signatures[xDlSym_memdbDlSym_enum], sizeof(E.xDlSym_signature)) == 0) {
+ memdbDlSym(args);
+ }
+ else if (memcmp(E.xDlSym_signature, xDlSym_signatures[xDlSym_rbuVfsDlSym_enum], sizeof(E.xDlSym_signature)) == 0) {
+ rbuVfsDlSym(args);
+ }
+ else if (memcmp(E.xDlSym_signature, xDlSym_signatures[xDlSym_winDlSym_enum], sizeof(E.xDlSym_signature)) == 0) {
+ winDlSym(args);
+ }
+ else if (memcmp(E.xDlSym_signature, xDlSym_signatures[xDlSym_unixDlSym_enum], sizeof(E.xDlSym_signature)) == 0) {
+ unixDlSym(args);
+ }


// FP: xEof

@transform_standalone_xEof_dot@
expression E;
identifier FP_NAME = xEof;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xEof_signature, xEof_signatures[xEof_bytecodevtabEof_enum], sizeof(E.xEof_signature)) == 0) {
+ bytecodevtabEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_completionEof_enum], sizeof(E.xEof_signature)) == 0) {
+ completionEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_dbdataEof_enum], sizeof(E.xEof_signature)) == 0) {
+ dbdataEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_dbpageEof_enum], sizeof(E.xEof_signature)) == 0) {
+ dbpageEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_expertEof_enum], sizeof(E.xEof_signature)) == 0) {
+ expertEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_fsdirEof_enum], sizeof(E.xEof_signature)) == 0) {
+ fsdirEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_fts3EofMethod_enum], sizeof(E.xEof_signature)) == 0) {
+ fts3EofMethod(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_fts3auxEofMethod_enum], sizeof(E.xEof_signature)) == 0) {
+ fts3auxEofMethod(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_fts3tokEofMethod_enum], sizeof(E.xEof_signature)) == 0) {
+ fts3tokEofMethod(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_jsonEachEof_enum], sizeof(E.xEof_signature)) == 0) {
+ jsonEachEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_pragmaVtabEof_enum], sizeof(E.xEof_signature)) == 0) {
+ pragmaVtabEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_rtreeEof_enum], sizeof(E.xEof_signature)) == 0) {
+ rtreeEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_seriesEof_enum], sizeof(E.xEof_signature)) == 0) {
+ seriesEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_statEof_enum], sizeof(E.xEof_signature)) == 0) {
+ statEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_stmtEof_enum], sizeof(E.xEof_signature)) == 0) {
+ stmtEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_zipfileEof_enum], sizeof(E.xEof_signature)) == 0) {
+ zipfileEof(args);
+ }


// FP: xExprCallback

@transform_standalone_xExprCallback_dot@
expression E;
identifier FP_NAME = xExprCallback;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_agginfoPersistExprCb_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ agginfoPersistExprCb(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_aggregateIdxEprRefToColCallback_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ aggregateIdxEprRefToColCallback(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_analyzeAggregate_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ analyzeAggregate(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_checkConstraintExprNode_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ checkConstraintExprNode(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_codeCursorHintCheckExpr_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ codeCursorHintCheckExpr(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_codeCursorHintFixExpr_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ codeCursorHintFixExpr(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_codeCursorHintIsOrFunction_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ codeCursorHintIsOrFunction(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_disallowAggregatesInOrderByCb_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ disallowAggregatesInOrderByCb(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprColumnFlagUnion_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ exprColumnFlagUnion(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprIdxCover_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ exprIdxCover(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprNodeCanReturnSubtype_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ exprNodeCanReturnSubtype(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprNodeIsConstant_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ exprNodeIsConstant(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprNodeIsConstantOrGroupBy_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ exprNodeIsConstantOrGroupBy(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprNodeIsDeterministic_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ exprNodeIsDeterministic(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprRefToSrcList_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ exprRefToSrcList(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_fixExprCb_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ fixExprCb(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_gatherSelectWindowsCallback_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ gatherSelectWindowsCallback(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_havingToWhereExprCb_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ havingToWhereExprCb(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_impliesNotNullRow_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ impliesNotNullRow(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_incrAggDepth_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ incrAggDepth(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_markImmutableExprStep_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ markImmutableExprStep(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_propagateConstantExprRewrite_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ propagateConstantExprRewrite(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_recomputeColumnsUsedExpr_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ recomputeColumnsUsedExpr(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_renameColumnExprCb_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ renameColumnExprCb(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_renameQuotefixExprCb_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ renameQuotefixExprCb(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_renameTableExprCb_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ renameTableExprCb(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_renameUnmapExprCb_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ renameUnmapExprCb(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_renumberCursorsCb_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ renumberCursorsCb(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_resolveExprStep_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ resolveExprStep(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_resolveRemoveWindowsCb_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ resolveRemoveWindowsCb(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_selectCheckOnClausesExpr_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ selectCheckOnClausesExpr(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_selectWindowRewriteExprCb_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ selectWindowRewriteExprCb(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_sqlite3CursorRangeHintExprCheck_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ sqlite3CursorRangeHintExprCheck(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_sqlite3ExprWalkNoop_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ sqlite3ExprWalkNoop(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_sqlite3ReturningSubqueryVarSelect_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ sqlite3ReturningSubqueryVarSelect(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_sqlite3WindowExtraAggFuncDepth_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ sqlite3WindowExtraAggFuncDepth(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_whereIsCoveringIndexWalkCallback_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ whereIsCoveringIndexWalkCallback(args);
+ }


// FP: xFetch

@transform_standalone_xFetch_dot@
expression E;
identifier FP_NAME = xFetch;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xFetch_signature, xFetch_signatures[xFetch_0_enum], sizeof(E.xFetch_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xFetch_signature, xFetch_signatures[xFetch_apndFetch_enum], sizeof(E.xFetch_signature)) == 0) {
+ apndFetch(args);
+ }
+ else if (memcmp(E.xFetch_signature, xFetch_signatures[xFetch_memdbFetch_enum], sizeof(E.xFetch_signature)) == 0) {
+ memdbFetch(args);
+ }
+ else if (memcmp(E.xFetch_signature, xFetch_signatures[xFetch_pcache1Fetch_enum], sizeof(E.xFetch_signature)) == 0) {
+ pcache1Fetch(args);
+ }
+ else if (memcmp(E.xFetch_signature, xFetch_signatures[xFetch_pcachetraceFetch_enum], sizeof(E.xFetch_signature)) == 0) {
+ pcachetraceFetch(args);
+ }
+ else if (memcmp(E.xFetch_signature, xFetch_signatures[xFetch_recoverVfsFetch_enum], sizeof(E.xFetch_signature)) == 0) {
+ recoverVfsFetch(args);
+ }


// FP: xFileControl

@transform_standalone_xFileControl_dot@
expression E;
identifier FP_NAME = xFileControl;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xFileControl_signature, xFileControl_signatures[xFileControl_0_enum], sizeof(E.xFileControl_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xFileControl_signature, xFileControl_signatures[xFileControl_apndFileControl_enum], sizeof(E.xFileControl_signature)) == 0) {
+ apndFileControl(args);
+ }
+ else if (memcmp(E.xFileControl_signature, xFileControl_signatures[xFileControl_memdbFileControl_enum], sizeof(E.xFileControl_signature)) == 0) {
+ memdbFileControl(args);
+ }
+ else if (memcmp(E.xFileControl_signature, xFileControl_signatures[xFileControl_recoverVfsFileControl_enum], sizeof(E.xFileControl_signature)) == 0) {
+ recoverVfsFileControl(args);
+ }
+ else if (memcmp(E.xFileControl_signature, xFileControl_signatures[xFileControl_vfstraceFileControl_enum], sizeof(E.xFileControl_signature)) == 0) {
+ vfstraceFileControl(args);
+ }


// FP: xFileSize

@transform_standalone_xFileSize_dot@
expression E;
identifier FP_NAME = xFileSize;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xFileSize_signature, xFileSize_signatures[xFileSize_apndFileSize_enum], sizeof(E.xFileSize_signature)) == 0) {
+ apndFileSize(args);
+ }
+ else if (memcmp(E.xFileSize_signature, xFileSize_signatures[xFileSize_memdbFileSize_enum], sizeof(E.xFileSize_signature)) == 0) {
+ memdbFileSize(args);
+ }
+ else if (memcmp(E.xFileSize_signature, xFileSize_signatures[xFileSize_memjrnlFileSize_enum], sizeof(E.xFileSize_signature)) == 0) {
+ memjrnlFileSize(args);
+ }
+ else if (memcmp(E.xFileSize_signature, xFileSize_signatures[xFileSize_recoverVfsFileSize_enum], sizeof(E.xFileSize_signature)) == 0) {
+ recoverVfsFileSize(args);
+ }
+ else if (memcmp(E.xFileSize_signature, xFileSize_signatures[xFileSize_vfstraceFileSize_enum], sizeof(E.xFileSize_signature)) == 0) {
+ vfstraceFileSize(args);
+ }


// FP: xFilter

@transform_standalone_xFilter_dot@
expression E;
identifier FP_NAME = xFilter;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_bytecodevtabFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ bytecodevtabFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_completionFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ completionFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_dbdataFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ dbdataFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_dbpageFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ dbpageFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_expertFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ expertFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_fsdirFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ fsdirFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_fts3FilterMethod_enum], sizeof(E.xFilter_signature)) == 0) {
+ fts3FilterMethod(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_fts3auxFilterMethod_enum], sizeof(E.xFilter_signature)) == 0) {
+ fts3auxFilterMethod(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_fts3tokFilterMethod_enum], sizeof(E.xFilter_signature)) == 0) {
+ fts3tokFilterMethod(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_geopolyFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ geopolyFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_jsonEachFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ jsonEachFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_pragmaVtabFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ pragmaVtabFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_rtreeFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ rtreeFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_seriesFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ seriesFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_statFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ statFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_stmtFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ stmtFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_zipfileFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ zipfileFilter(args);
+ }


// FP: xFinalize

@transform_standalone_xFinalize_dot@
expression E;
identifier FP_NAME = xFinalize;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xFinalize_signature, xFinalize_signatures[xFinalize_0_enum], sizeof(E.xFinalize_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xFinalize_signature, xFinalize_signatures[xFinalize_decimalSumFinalize_enum], sizeof(E.xFinalize_signature)) == 0) {
+ decimalSumFinalize(args);
+ }
+ else if (memcmp(E.xFinalize_signature, xFinalize_signatures[xFinalize_dummyUDFvalue_enum], sizeof(E.xFinalize_signature)) == 0) {
+ dummyUDFvalue(args);
+ }
+ else if (memcmp(E.xFinalize_signature, xFinalize_signatures[xFinalize_percentFinal_enum], sizeof(E.xFinalize_signature)) == 0) {
+ percentFinal(args);
+ }
+ else if (memcmp(E.xFinalize_signature, xFinalize_signatures[xFinalize_sha3AggFinal_enum], sizeof(E.xFinalize_signature)) == 0) {
+ sha3AggFinal(args);
+ }
+ else if (memcmp(E.xFinalize_signature, xFinalize_signatures[xFinalize_zipfileFinal_enum], sizeof(E.xFinalize_signature)) == 0) {
+ zipfileFinal(args);
+ }


// FP: xFindFunction

@transform_standalone_xFindFunction_dot@
expression E;
identifier FP_NAME = xFindFunction;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xFindFunction_signature, xFindFunction_signatures[xFindFunction_0_enum], sizeof(E.xFindFunction_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xFindFunction_signature, xFindFunction_signatures[xFindFunction_fts3FindFunctionMethod_enum], sizeof(E.xFindFunction_signature)) == 0) {
+ fts3FindFunctionMethod(args);
+ }
+ else if (memcmp(E.xFindFunction_signature, xFindFunction_signatures[xFindFunction_zipfileFindFunction_enum], sizeof(E.xFindFunction_signature)) == 0) {
+ zipfileFindFunction(args);
+ }


// FP: xFree

@transform_standalone_xFree_dot@
expression E;
identifier FP_NAME = xFree;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xFree_signature, xFree_signatures[xFree_memtraceFree_enum], sizeof(E.xFree_signature)) == 0) {
+ memtraceFree(args);
+ }
+ else if (memcmp(E.xFree_signature, xFree_signatures[xFree_sqlite3MemFree_enum], sizeof(E.xFree_signature)) == 0) {
+ sqlite3MemFree(args);
+ }


// FP: xFreeSchema

@transform_standalone_xFreeSchema_dot@
expression E;
identifier FP_NAME = xFreeSchema;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xFreeSchema_signature, xFreeSchema_signatures[xFreeSchema_0_enum], sizeof(E.xFreeSchema_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xFreeSchema_signature, xFreeSchema_signatures[xFreeSchema_sqlite3RCStrUnref_enum], sizeof(E.xFreeSchema_signature)) == 0) {
+ sqlite3RCStrUnref(args);
+ }
+ else if (memcmp(E.xFreeSchema_signature, xFreeSchema_signatures[xFreeSchema_sqlite3SchemaClear_enum], sizeof(E.xFreeSchema_signature)) == 0) {
+ sqlite3SchemaClear(args);
+ }


// FP: xFullPathname

@transform_standalone_xFullPathname_dot@
expression E;
identifier FP_NAME = xFullPathname;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xFullPathname_signature, xFullPathname_signatures[xFullPathname_apndFullPathname_enum], sizeof(E.xFullPathname_signature)) == 0) {
+ apndFullPathname(args);
+ }
+ else if (memcmp(E.xFullPathname_signature, xFullPathname_signatures[xFullPathname_memdbFullPathname_enum], sizeof(E.xFullPathname_signature)) == 0) {
+ memdbFullPathname(args);
+ }
+ else if (memcmp(E.xFullPathname_signature, xFullPathname_signatures[xFullPathname_vfstraceFullPathname_enum], sizeof(E.xFullPathname_signature)) == 0) {
+ vfstraceFullPathname(args);
+ }
+ else if (memcmp(E.xFullPathname_signature, xFullPathname_signatures[xFullPathname_unixFullPathname_enum], sizeof(E.xFullPathname_signature)) == 0) {
+ unixFullPathname(args);
+ }


// FP: xFunc

@transform_standalone_xFunc_dot@
expression E;
identifier FP_NAME = xFunc;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_0_enum], sizeof(E.xFunc_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_base64_enum], sizeof(E.xFunc_signature)) == 0) {
+ base64(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_base85_enum], sizeof(E.xFunc_signature)) == 0) {
+ base85(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_dummyUDF_enum], sizeof(E.xFunc_signature)) == 0) {
+ dummyUDF(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_editFunc_enum], sizeof(E.xFunc_signature)) == 0) {
+ editFunc(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_fts3AllocateMSI_enum], sizeof(E.xFunc_signature)) == 0) {
+ fts3AllocateMSI(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_fts3ExprGlobalHitsCb_enum], sizeof(E.xFunc_signature)) == 0) {
+ fts3ExprGlobalHitsCb(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_fts3ExprLoadDoclistsCb_enum], sizeof(E.xFunc_signature)) == 0) {
+ fts3ExprLoadDoclistsCb(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_fts3ExprLocalHitsCb_enum], sizeof(E.xFunc_signature)) == 0) {
+ fts3ExprLocalHitsCb(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_fts3ExprPhraseCountCb_enum], sizeof(E.xFunc_signature)) == 0) {
+ fts3ExprPhraseCountCb(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_fts3ExprRestartIfCb_enum], sizeof(E.xFunc_signature)) == 0) {
+ fts3ExprRestartIfCb(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_fts3ExprTermOffsetInit_enum], sizeof(E.xFunc_signature)) == 0) {
+ fts3ExprTermOffsetInit(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_fts3ExprTest_enum], sizeof(E.xFunc_signature)) == 0) {
+ fts3ExprTest(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_fts3ExprTestRebalance_enum], sizeof(E.xFunc_signature)) == 0) {
+ fts3ExprTestRebalance(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_fts3MatchinfoLcsCb_enum], sizeof(E.xFunc_signature)) == 0) {
+ fts3MatchinfoLcsCb(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_fts3SnippetFindPositions_enum], sizeof(E.xFunc_signature)) == 0) {
+ fts3SnippetFindPositions(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_fts3TokenizerFunc_enum], sizeof(E.xFunc_signature)) == 0) {
+ fts3TokenizerFunc(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_geomCallback_enum], sizeof(E.xFunc_signature)) == 0) {
+ geomCallback(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_idxRemFunc_enum], sizeof(E.xFunc_signature)) == 0) {
+ idxRemFunc(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_idxSampleFunc_enum], sizeof(E.xFunc_signature)) == 0) {
+ idxSampleFunc(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_intTestFunc_enum], sizeof(E.xFunc_signature)) == 0) {
+ intTestFunc(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_intckParseCreateIndexFunc_enum], sizeof(E.xFunc_signature)) == 0) {
+ intckParseCreateIndexFunc(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_is_base85_enum], sizeof(E.xFunc_signature)) == 0) {
+ is_base85(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_lsModeFunc_enum], sizeof(E.xFunc_signature)) == 0) {
+ lsModeFunc(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_rbuFossilDeltaFunc_enum], sizeof(E.xFunc_signature)) == 0) {
+ rbuFossilDeltaFunc(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_rbuIndexCntFunc_enum], sizeof(E.xFunc_signature)) == 0) {
+ rbuIndexCntFunc(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_rbuTargetNameFunc_enum], sizeof(E.xFunc_signature)) == 0) {
+ rbuTargetNameFunc(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_rbuTmpInsertFunc_enum], sizeof(E.xFunc_signature)) == 0) {
+ rbuTmpInsertFunc(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_re_bytecode_func_enum], sizeof(E.xFunc_signature)) == 0) {
+ re_bytecode_func(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_re_sql_func_enum], sizeof(E.xFunc_signature)) == 0) {
+ re_sql_func(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_readfileFunc_enum], sizeof(E.xFunc_signature)) == 0) {
+ readfileFunc(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_rtreecheck_enum], sizeof(E.xFunc_signature)) == 0) {
+ rtreecheck(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_rtreedepth_enum], sizeof(E.xFunc_signature)) == 0) {
+ rtreedepth(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_rtreenode_enum], sizeof(E.xFunc_signature)) == 0) {
+ rtreenode(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_sha1Func_enum], sizeof(E.xFunc_signature)) == 0) {
+ sha1Func(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_sha1QueryFunc_enum], sizeof(E.xFunc_signature)) == 0) {
+ sha1QueryFunc(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_sha3Func_enum], sizeof(E.xFunc_signature)) == 0) {
+ sha3Func(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_sha3QueryFunc_enum], sizeof(E.xFunc_signature)) == 0) {
+ sha3QueryFunc(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_shellAddSchemaName_enum], sizeof(E.xFunc_signature)) == 0) {
+ shellAddSchemaName(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_shellDtostr_enum], sizeof(E.xFunc_signature)) == 0) {
+ shellDtostr(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_shellFkeyCollateClause_enum], sizeof(E.xFunc_signature)) == 0) {
+ shellFkeyCollateClause(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_shellModuleSchema_enum], sizeof(E.xFunc_signature)) == 0) {
+ shellModuleSchema(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_shellPutsFunc_enum], sizeof(E.xFunc_signature)) == 0) {
+ shellPutsFunc(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_shellStrtod_enum], sizeof(E.xFunc_signature)) == 0) {
+ shellStrtod(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_shellUSleepFunc_enum], sizeof(E.xFunc_signature)) == 0) {
+ shellUSleepFunc(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_sqlarCompressFunc_enum], sizeof(E.xFunc_signature)) == 0) {
+ sqlarCompressFunc(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_sqlarUncompressFunc_enum], sizeof(E.xFunc_signature)) == 0) {
+ sqlarUncompressFunc(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_sqlite3InvalidFunction_enum], sizeof(E.xFunc_signature)) == 0) {
+ sqlite3InvalidFunction(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_stmtrandFunc_enum], sizeof(E.xFunc_signature)) == 0) {
+ stmtrandFunc(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_testFunc_enum], sizeof(E.xFunc_signature)) == 0) {
+ testFunc(args);
+ }
+ else if (memcmp(E.xFunc_signature, xFunc_signatures[xFunc_writefileFunc_enum], sizeof(E.xFunc_signature)) == 0) {
+ writefileFunc(args);
+ }


// FP: xGeom

@transform_standalone_xGeom_dot@
expression E;
identifier FP_NAME = xGeom;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ 0;


// FP: xGet

@transform_standalone_xGet_dot@
expression E;
identifier FP_NAME = xGet;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xGet_signature, xGet_signatures[xGet_getPageError_enum], sizeof(E.xGet_signature)) == 0) {
+ getPageError(args);
+ }
+ else if (memcmp(E.xGet_signature, xGet_signatures[xGet_getPageMMap_enum], sizeof(E.xGet_signature)) == 0) {
+ getPageMMap(args);
+ }
+ else if (memcmp(E.xGet_signature, xGet_signatures[xGet_getPageNormal_enum], sizeof(E.xGet_signature)) == 0) {
+ getPageNormal(args);
+ }


// FP: xGetLastError

@transform_standalone_xGetLastError_dot@
expression E;
identifier FP_NAME = xGetLastError;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xGetLastError_signature, xGetLastError_signatures[xGetLastError_0_enum], sizeof(E.xGetLastError_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xGetLastError_signature, xGetLastError_signatures[xGetLastError_apndGetLastError_enum], sizeof(E.xGetLastError_signature)) == 0) {
+ apndGetLastError(args);
+ }
+ else if (memcmp(E.xGetLastError_signature, xGetLastError_signatures[xGetLastError_memdbGetLastError_enum], sizeof(E.xGetLastError_signature)) == 0) {
+ memdbGetLastError(args);
+ }
+ else if (memcmp(E.xGetLastError_signature, xGetLastError_signatures[xGetLastError_unixGetLastError_enum], sizeof(E.xGetLastError_signature)) == 0) {
+ unixGetLastError(args);
+ }


// FP: xGetSystemCall

@transform_standalone_xGetSystemCall_dot@
expression E;
identifier FP_NAME = xGetSystemCall;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xGetSystemCall_signature, xGetSystemCall_signatures[xGetSystemCall_0_enum], sizeof(E.xGetSystemCall_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xGetSystemCall_signature, xGetSystemCall_signatures[xGetSystemCall_apndGetSystemCall_enum], sizeof(E.xGetSystemCall_signature)) == 0) {
+ apndGetSystemCall(args);
+ }
+ else if (memcmp(E.xGetSystemCall_signature, xGetSystemCall_signatures[xGetSystemCall_unixGetSystemCall_enum], sizeof(E.xGetSystemCall_signature)) == 0) {
+ unixGetSystemCall(args);
+ }


// FP: xInit

@transform_standalone_xInit_dot@
expression E;
identifier FP_NAME = xInit;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xInit_signature, xInit_signatures[xInit_memtraceInit_enum], sizeof(E.xInit_signature)) == 0) {
+ memtraceInit(args);
+ }
+ else if (memcmp(E.xInit_signature, xInit_signatures[xInit_pcache1Init_enum], sizeof(E.xInit_signature)) == 0) {
+ pcache1Init(args);
+ }
+ else if (memcmp(E.xInit_signature, xInit_signatures[xInit_pcachetraceInit_enum], sizeof(E.xInit_signature)) == 0) {
+ pcachetraceInit(args);
+ }
+ else if (memcmp(E.xInit_signature, xInit_signatures[xInit_sqlite3MemInit_enum], sizeof(E.xInit_signature)) == 0) {
+ sqlite3MemInit(args);
+ }


// FP: xInput

@transform_standalone_xInput_dot@
expression E;
identifier FP_NAME = xInput;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ 0;


// FP: xIntegrity

@transform_standalone_xIntegrity_dot@
expression E;
identifier FP_NAME = xIntegrity;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xIntegrity_signature, xIntegrity_signatures[xIntegrity_0_enum], sizeof(E.xIntegrity_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xIntegrity_signature, xIntegrity_signatures[xIntegrity_fts3IntegrityMethod_enum], sizeof(E.xIntegrity_signature)) == 0) {
+ fts3IntegrityMethod(args);
+ }
+ else if (memcmp(E.xIntegrity_signature, xIntegrity_signatures[xIntegrity_rtreeIntegrity_enum], sizeof(E.xIntegrity_signature)) == 0) {
+ rtreeIntegrity(args);
+ }


// FP: xInverse

@transform_standalone_xInverse_dot@
expression E;
identifier FP_NAME = xInverse;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xInverse_signature, xInverse_signatures[xInverse_0_enum], sizeof(E.xInverse_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xInverse_signature, xInverse_signatures[xInverse_decimalSumInverse_enum], sizeof(E.xInverse_signature)) == 0) {
+ decimalSumInverse(args);
+ }
+ else if (memcmp(E.xInverse_signature, xInverse_signatures[xInverse_percentInverse_enum], sizeof(E.xInverse_signature)) == 0) {
+ percentInverse(args);
+ }


// FP: xLanguageid

@transform_standalone_xLanguageid_dot@
expression E;
identifier FP_NAME = xLanguageid;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ 0;


// FP: xLock

@transform_standalone_xLock_dot@
expression E;
identifier FP_NAME = xLock;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xLock_signature, xLock_signatures[xLock_0_enum], sizeof(E.xLock_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xLock_signature, xLock_signatures[xLock_apndLock_enum], sizeof(E.xLock_signature)) == 0) {
+ apndLock(args);
+ }
+ else if (memcmp(E.xLock_signature, xLock_signatures[xLock_memdbLock_enum], sizeof(E.xLock_signature)) == 0) {
+ memdbLock(args);
+ }
+ else if (memcmp(E.xLock_signature, xLock_signatures[xLock_recoverVfsLock_enum], sizeof(E.xLock_signature)) == 0) {
+ recoverVfsLock(args);
+ }
+ else if (memcmp(E.xLock_signature, xLock_signatures[xLock_vfstraceLock_enum], sizeof(E.xLock_signature)) == 0) {
+ vfstraceLock(args);
+ }


// FP: xLog

@transform_standalone_xLog_dot@
expression E;
identifier FP_NAME = xLog;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ 0;


// FP: xMalloc

@transform_standalone_xMalloc_dot@
expression E;
identifier FP_NAME = xMalloc;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xMalloc_signature, xMalloc_signatures[xMalloc_memtraceMalloc_enum], sizeof(E.xMalloc_signature)) == 0) {
+ memtraceMalloc(args);
+ }
+ else if (memcmp(E.xMalloc_signature, xMalloc_signatures[xMalloc_sqlite3MemMalloc_enum], sizeof(E.xMalloc_signature)) == 0) {
+ sqlite3MemMalloc(args);
+ }


// FP: xMutexAlloc

@transform_standalone_xMutexAlloc_dot@
expression E;
identifier FP_NAME = xMutexAlloc;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_checkMutexAlloc_enum], sizeof(E.xMutexAlloc_signature)) == 0) {
+ checkMutexAlloc(args);
+ }
+ else if (memcmp(E.xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_debugMutexAlloc_enum], sizeof(E.xMutexAlloc_signature)) == 0) {
+ debugMutexAlloc(args);
+ }
+ else if (memcmp(E.xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_noopMutexAlloc_enum], sizeof(E.xMutexAlloc_signature)) == 0) {
+ noopMutexAlloc(args);
+ }
+ else if (memcmp(E.xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_pthreadMutexAlloc_enum], sizeof(E.xMutexAlloc_signature)) == 0) {
+ pthreadMutexAlloc(args);
+ }
+ else if (memcmp(E.xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_winMutexAlloc_enum], sizeof(E.xMutexAlloc_signature)) == 0) {
+ winMutexAlloc(args);
+ }


// FP: xMutexEnd

@transform_standalone_xMutexEnd_dot@
expression E;
identifier FP_NAME = xMutexEnd;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_checkMutexEnd_enum], sizeof(E.xMutexEnd_signature)) == 0) {
+ checkMutexEnd(args);
+ }
+ else if (memcmp(E.xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_debugMutexEnd_enum], sizeof(E.xMutexEnd_signature)) == 0) {
+ debugMutexEnd(args);
+ }
+ else if (memcmp(E.xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_noopMutexEnd_enum], sizeof(E.xMutexEnd_signature)) == 0) {
+ noopMutexEnd(args);
+ }
+ else if (memcmp(E.xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_pthreadMutexEnd_enum], sizeof(E.xMutexEnd_signature)) == 0) {
+ pthreadMutexEnd(args);
+ }
+ else if (memcmp(E.xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_winMutexEnd_enum], sizeof(E.xMutexEnd_signature)) == 0) {
+ winMutexEnd(args);
+ }


// FP: xMutexEnter

@transform_standalone_xMutexEnter_dot@
expression E;
identifier FP_NAME = xMutexEnter;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_checkMutexEnter_enum], sizeof(E.xMutexEnter_signature)) == 0) {
+ checkMutexEnter(args);
+ }
+ else if (memcmp(E.xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_debugMutexEnter_enum], sizeof(E.xMutexEnter_signature)) == 0) {
+ debugMutexEnter(args);
+ }
+ else if (memcmp(E.xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_noopMutexEnter_enum], sizeof(E.xMutexEnter_signature)) == 0) {
+ noopMutexEnter(args);
+ }
+ else if (memcmp(E.xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_pthreadMutexEnter_enum], sizeof(E.xMutexEnter_signature)) == 0) {
+ pthreadMutexEnter(args);
+ }
+ else if (memcmp(E.xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_winMutexEnter_enum], sizeof(E.xMutexEnter_signature)) == 0) {
+ winMutexEnter(args);
+ }


// FP: xMutexFree

@transform_standalone_xMutexFree_dot@
expression E;
identifier FP_NAME = xMutexFree;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xMutexFree_signature, xMutexFree_signatures[xMutexFree_checkMutexFree_enum], sizeof(E.xMutexFree_signature)) == 0) {
+ checkMutexFree(args);
+ }
+ else if (memcmp(E.xMutexFree_signature, xMutexFree_signatures[xMutexFree_debugMutexFree_enum], sizeof(E.xMutexFree_signature)) == 0) {
+ debugMutexFree(args);
+ }
+ else if (memcmp(E.xMutexFree_signature, xMutexFree_signatures[xMutexFree_noopMutexFree_enum], sizeof(E.xMutexFree_signature)) == 0) {
+ noopMutexFree(args);
+ }
+ else if (memcmp(E.xMutexFree_signature, xMutexFree_signatures[xMutexFree_pthreadMutexFree_enum], sizeof(E.xMutexFree_signature)) == 0) {
+ pthreadMutexFree(args);
+ }
+ else if (memcmp(E.xMutexFree_signature, xMutexFree_signatures[xMutexFree_winMutexFree_enum], sizeof(E.xMutexFree_signature)) == 0) {
+ winMutexFree(args);
+ }


// FP: xMutexHeld

@transform_standalone_xMutexHeld_dot@
expression E;
identifier FP_NAME = xMutexHeld;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xMutexHeld_signature, xMutexHeld_signatures[xMutexHeld_0_enum], sizeof(E.xMutexHeld_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xMutexHeld_signature, xMutexHeld_signatures[xMutexHeld_debugMutexHeld_enum], sizeof(E.xMutexHeld_signature)) == 0) {
+ debugMutexHeld(args);
+ }


// FP: xMutexInit

@transform_standalone_xMutexInit_dot@
expression E;
identifier FP_NAME = xMutexInit;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xMutexInit_signature, xMutexInit_signatures[xMutexInit_checkMutexInit_enum], sizeof(E.xMutexInit_signature)) == 0) {
+ checkMutexInit(args);
+ }
+ else if (memcmp(E.xMutexInit_signature, xMutexInit_signatures[xMutexInit_debugMutexInit_enum], sizeof(E.xMutexInit_signature)) == 0) {
+ debugMutexInit(args);
+ }
+ else if (memcmp(E.xMutexInit_signature, xMutexInit_signatures[xMutexInit_noopMutexInit_enum], sizeof(E.xMutexInit_signature)) == 0) {
+ noopMutexInit(args);
+ }
+ else if (memcmp(E.xMutexInit_signature, xMutexInit_signatures[xMutexInit_pthreadMutexInit_enum], sizeof(E.xMutexInit_signature)) == 0) {
+ pthreadMutexInit(args);
+ }
+ else if (memcmp(E.xMutexInit_signature, xMutexInit_signatures[xMutexInit_winMutexInit_enum], sizeof(E.xMutexInit_signature)) == 0) {
+ winMutexInit(args);
+ }


// FP: xMutexLeave

@transform_standalone_xMutexLeave_dot@
expression E;
identifier FP_NAME = xMutexLeave;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_checkMutexLeave_enum], sizeof(E.xMutexLeave_signature)) == 0) {
+ checkMutexLeave(args);
+ }
+ else if (memcmp(E.xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_debugMutexLeave_enum], sizeof(E.xMutexLeave_signature)) == 0) {
+ debugMutexLeave(args);
+ }
+ else if (memcmp(E.xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_noopMutexLeave_enum], sizeof(E.xMutexLeave_signature)) == 0) {
+ noopMutexLeave(args);
+ }
+ else if (memcmp(E.xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_pthreadMutexLeave_enum], sizeof(E.xMutexLeave_signature)) == 0) {
+ pthreadMutexLeave(args);
+ }
+ else if (memcmp(E.xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_winMutexLeave_enum], sizeof(E.xMutexLeave_signature)) == 0) {
+ winMutexLeave(args);
+ }


// FP: xMutexNotheld

@transform_standalone_xMutexNotheld_dot@
expression E;
identifier FP_NAME = xMutexNotheld;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xMutexNotheld_signature, xMutexNotheld_signatures[xMutexNotheld_0_enum], sizeof(E.xMutexNotheld_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xMutexNotheld_signature, xMutexNotheld_signatures[xMutexNotheld_debugMutexNotheld_enum], sizeof(E.xMutexNotheld_signature)) == 0) {
+ debugMutexNotheld(args);
+ }


// FP: xMutexTry

@transform_standalone_xMutexTry_dot@
expression E;
identifier FP_NAME = xMutexTry;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xMutexTry_signature, xMutexTry_signatures[xMutexTry_checkMutexTry_enum], sizeof(E.xMutexTry_signature)) == 0) {
+ checkMutexTry(args);
+ }
+ else if (memcmp(E.xMutexTry_signature, xMutexTry_signatures[xMutexTry_debugMutexTry_enum], sizeof(E.xMutexTry_signature)) == 0) {
+ debugMutexTry(args);
+ }
+ else if (memcmp(E.xMutexTry_signature, xMutexTry_signatures[xMutexTry_noopMutexTry_enum], sizeof(E.xMutexTry_signature)) == 0) {
+ noopMutexTry(args);
+ }
+ else if (memcmp(E.xMutexTry_signature, xMutexTry_signatures[xMutexTry_pthreadMutexTry_enum], sizeof(E.xMutexTry_signature)) == 0) {
+ pthreadMutexTry(args);
+ }
+ else if (memcmp(E.xMutexTry_signature, xMutexTry_signatures[xMutexTry_winMutexTry_enum], sizeof(E.xMutexTry_signature)) == 0) {
+ winMutexTry(args);
+ }


// FP: xNew

@transform_standalone_xNew_dot@
expression E;
identifier FP_NAME = xNew;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xNew_signature, xNew_signatures[xNew_sessionDiffNew_enum], sizeof(E.xNew_signature)) == 0) {
+ sessionDiffNew(args);
+ }
+ else if (memcmp(E.xNew_signature, xNew_signatures[xNew_sessionPreupdateNew_enum], sizeof(E.xNew_signature)) == 0) {
+ sessionPreupdateNew(args);
+ }
+ else if (memcmp(E.xNew_signature, xNew_signatures[xNew_sessionStat1New_enum], sizeof(E.xNew_signature)) == 0) {
+ sessionStat1New(args);
+ }


// FP: xNext

@transform_standalone_xNext_dot@
expression E;
identifier FP_NAME = xNext;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xNext_signature, xNext_signatures[xNext_0_enum], sizeof(E.xNext_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_bytecodevtabNext_enum], sizeof(E.xNext_signature)) == 0) {
+ bytecodevtabNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_completionNext_enum], sizeof(E.xNext_signature)) == 0) {
+ completionNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_dbdataNext_enum], sizeof(E.xNext_signature)) == 0) {
+ dbdataNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_dbpageNext_enum], sizeof(E.xNext_signature)) == 0) {
+ dbpageNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_expertNext_enum], sizeof(E.xNext_signature)) == 0) {
+ expertNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_fsdirNext_enum], sizeof(E.xNext_signature)) == 0) {
+ fsdirNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_fts3NextMethod_enum], sizeof(E.xNext_signature)) == 0) {
+ fts3NextMethod(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_fts3auxNextMethod_enum], sizeof(E.xNext_signature)) == 0) {
+ fts3auxNextMethod(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_fts3tokNextMethod_enum], sizeof(E.xNext_signature)) == 0) {
+ fts3tokNextMethod(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_jsonEachNext_enum], sizeof(E.xNext_signature)) == 0) {
+ jsonEachNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_porterNext_enum], sizeof(E.xNext_signature)) == 0) {
+ porterNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_pragmaVtabNext_enum], sizeof(E.xNext_signature)) == 0) {
+ pragmaVtabNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_rtreeNext_enum], sizeof(E.xNext_signature)) == 0) {
+ rtreeNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_seriesNext_enum], sizeof(E.xNext_signature)) == 0) {
+ seriesNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_simpleNext_enum], sizeof(E.xNext_signature)) == 0) {
+ simpleNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_statNext_enum], sizeof(E.xNext_signature)) == 0) {
+ statNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_stmtNext_enum], sizeof(E.xNext_signature)) == 0) {
+ stmtNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_unicodeNext_enum], sizeof(E.xNext_signature)) == 0) {
+ unicodeNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_zipfileNext_enum], sizeof(E.xNext_signature)) == 0) {
+ zipfileNext(args);
+ }


// FP: xNextSystemCall

@transform_standalone_xNextSystemCall_dot@
expression E;
identifier FP_NAME = xNextSystemCall;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xNextSystemCall_signature, xNextSystemCall_signatures[xNextSystemCall_0_enum], sizeof(E.xNextSystemCall_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xNextSystemCall_signature, xNextSystemCall_signatures[xNextSystemCall_apndNextSystemCall_enum], sizeof(E.xNextSystemCall_signature)) == 0) {
+ apndNextSystemCall(args);
+ }
+ else if (memcmp(E.xNextSystemCall_signature, xNextSystemCall_signatures[xNextSystemCall_rbuVfsGetLastError_enum], sizeof(E.xNextSystemCall_signature)) == 0) {
+ rbuVfsGetLastError(args);
+ }
+ else if (memcmp(E.xNextSystemCall_signature, xNextSystemCall_signatures[xNextSystemCall_unixNextSystemCall_enum], sizeof(E.xNextSystemCall_signature)) == 0) {
+ unixNextSystemCall(args);
+ }


// FP: xOld

@transform_standalone_xOld_dot@
expression E;
identifier FP_NAME = xOld;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xOld_signature, xOld_signatures[xOld_sessionDiffOld_enum], sizeof(E.xOld_signature)) == 0) {
+ sessionDiffOld(args);
+ }
+ else if (memcmp(E.xOld_signature, xOld_signatures[xOld_sessionPreupdateOld_enum], sizeof(E.xOld_signature)) == 0) {
+ sessionPreupdateOld(args);
+ }
+ else if (memcmp(E.xOld_signature, xOld_signatures[xOld_sessionStat1Old_enum], sizeof(E.xOld_signature)) == 0) {
+ sessionStat1Old(args);
+ }


// FP: xOpen

@transform_standalone_xOpen_dot@
expression E;
identifier FP_NAME = xOpen;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_apndOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ apndOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_bytecodevtabOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ bytecodevtabOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_completionOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ completionOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_dbdataOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ dbdataOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_dbpageOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ dbpageOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_expertOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ expertOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_fsdirOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ fsdirOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_fts3OpenMethod_enum], sizeof(E.xOpen_signature)) == 0) {
+ fts3OpenMethod(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_fts3auxOpenMethod_enum], sizeof(E.xOpen_signature)) == 0) {
+ fts3auxOpenMethod(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_fts3tokOpenMethod_enum], sizeof(E.xOpen_signature)) == 0) {
+ fts3tokOpenMethod(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_jsonEachOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ jsonEachOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_memdbOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ memdbOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_porterOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ porterOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_pragmaVtabOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ pragmaVtabOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_rtreeOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ rtreeOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_seriesOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ seriesOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_simpleOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ simpleOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_statOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ statOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_stmtOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ stmtOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_unicodeOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ unicodeOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_vfstraceOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ vfstraceOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_zipfileOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ zipfileOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_unixOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ unixOpen(args);
+ }


// FP: xOut

@transform_standalone_xOut_dot@
expression E;
identifier FP_NAME = xOut;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ vfstraceOut(args);


// FP: xPagecount

@transform_standalone_xPagecount_dot@
expression E;
identifier FP_NAME = xPagecount;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xPagecount_signature, xPagecount_signatures[xPagecount_pcache1Pagecount_enum], sizeof(E.xPagecount_signature)) == 0) {
+ pcache1Pagecount(args);
+ }
+ else if (memcmp(E.xPagecount_signature, xPagecount_signatures[xPagecount_pcachetracePagecount_enum], sizeof(E.xPagecount_signature)) == 0) {
+ pcachetracePagecount(args);
+ }


// FP: xParseCell

@transform_standalone_xParseCell_dot@
expression E;
identifier FP_NAME = xParseCell;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xParseCell_signature, xParseCell_signatures[xParseCell_btreeParseCellPtr_enum], sizeof(E.xParseCell_signature)) == 0) {
+ btreeParseCellPtr(args);
+ }
+ else if (memcmp(E.xParseCell_signature, xParseCell_signatures[xParseCell_btreeParseCellPtrIndex_enum], sizeof(E.xParseCell_signature)) == 0) {
+ btreeParseCellPtrIndex(args);
+ }
+ else if (memcmp(E.xParseCell_signature, xParseCell_signatures[xParseCell_btreeParseCellPtrNoPayload_enum], sizeof(E.xParseCell_signature)) == 0) {
+ btreeParseCellPtrNoPayload(args);
+ }


// FP: xPreUpdateCallback

@transform_standalone_xPreUpdateCallback_dot@
expression E;
identifier FP_NAME = xPreUpdateCallback;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xPreUpdateCallback_signature, xPreUpdateCallback_signatures[xPreUpdateCallback_0_enum], sizeof(E.xPreUpdateCallback_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xPreUpdateCallback_signature, xPreUpdateCallback_signatures[xPreUpdateCallback_sql_trace_callback_enum], sizeof(E.xPreUpdateCallback_signature)) == 0) {
+ sql_trace_callback(args);
+ }
+ else if (memcmp(E.xPreUpdateCallback_signature, xPreUpdateCallback_signatures[xPreUpdateCallback_sqlite3WalDefaultHook_enum], sizeof(E.xPreUpdateCallback_signature)) == 0) {
+ sqlite3WalDefaultHook(args);
+ }


// FP: xQueryFunc

@transform_standalone_xQueryFunc_dot@
expression E;
identifier FP_NAME = xQueryFunc;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ 0;


// FP: xRandomness

@transform_standalone_xRandomness_dot@
expression E;
identifier FP_NAME = xRandomness;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xRandomness_signature, xRandomness_signatures[xRandomness_apndRandomness_enum], sizeof(E.xRandomness_signature)) == 0) {
+ apndRandomness(args);
+ }
+ else if (memcmp(E.xRandomness_signature, xRandomness_signatures[xRandomness_memdbRandomness_enum], sizeof(E.xRandomness_signature)) == 0) {
+ memdbRandomness(args);
+ }
+ else if (memcmp(E.xRandomness_signature, xRandomness_signatures[xRandomness_vfstraceRandomness_enum], sizeof(E.xRandomness_signature)) == 0) {
+ vfstraceRandomness(args);
+ }
+ else if (memcmp(E.xRandomness_signature, xRandomness_signatures[xRandomness_unixRandomness_enum], sizeof(E.xRandomness_signature)) == 0) {
+ unixRandomness(args);
+ }


// FP: xRead

@transform_standalone_xRead_dot@
expression E;
identifier FP_NAME = xRead;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xRead_signature, xRead_signatures[xRead_apndRead_enum], sizeof(E.xRead_signature)) == 0) {
+ apndRead(args);
+ }
+ else if (memcmp(E.xRead_signature, xRead_signatures[xRead_memdbRead_enum], sizeof(E.xRead_signature)) == 0) {
+ memdbRead(args);
+ }
+ else if (memcmp(E.xRead_signature, xRead_signatures[xRead_memjrnlRead_enum], sizeof(E.xRead_signature)) == 0) {
+ memjrnlRead(args);
+ }
+ else if (memcmp(E.xRead_signature, xRead_signatures[xRead_recoverVfsRead_enum], sizeof(E.xRead_signature)) == 0) {
+ recoverVfsRead(args);
+ }
+ else if (memcmp(E.xRead_signature, xRead_signatures[xRead_vfstraceRead_enum], sizeof(E.xRead_signature)) == 0) {
+ vfstraceRead(args);
+ }


// FP: xRealloc

@transform_standalone_xRealloc_dot@
expression E;
identifier FP_NAME = xRealloc;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xRealloc_signature, xRealloc_signatures[xRealloc_memtraceRealloc_enum], sizeof(E.xRealloc_signature)) == 0) {
+ memtraceRealloc(args);
+ }
+ else if (memcmp(E.xRealloc_signature, xRealloc_signatures[xRealloc_sqlite3MemRealloc_enum], sizeof(E.xRealloc_signature)) == 0) {
+ sqlite3MemRealloc(args);
+ }


// FP: xRekey

@transform_standalone_xRekey_dot@
expression E;
identifier FP_NAME = xRekey;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xRekey_signature, xRekey_signatures[xRekey_pcache1Rekey_enum], sizeof(E.xRekey_signature)) == 0) {
+ pcache1Rekey(args);
+ }
+ else if (memcmp(E.xRekey_signature, xRekey_signatures[xRekey_pcachetraceRekey_enum], sizeof(E.xRekey_signature)) == 0) {
+ pcachetraceRekey(args);
+ }


// FP: xRelease

@transform_standalone_xRelease_dot@
expression E;
identifier FP_NAME = xRelease;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xRelease_signature, xRelease_signatures[xRelease_0_enum], sizeof(E.xRelease_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xRelease_signature, xRelease_signatures[xRelease_fts3ReleaseMethod_enum], sizeof(E.xRelease_signature)) == 0) {
+ fts3ReleaseMethod(args);
+ }


// FP: xRename

@transform_standalone_xRename_dot@
expression E;
identifier FP_NAME = xRename;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xRename_signature, xRename_signatures[xRename_0_enum], sizeof(E.xRename_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xRename_signature, xRename_signatures[xRename_fts3RenameMethod_enum], sizeof(E.xRename_signature)) == 0) {
+ fts3RenameMethod(args);
+ }
+ else if (memcmp(E.xRename_signature, xRename_signatures[xRename_rtreeRename_enum], sizeof(E.xRename_signature)) == 0) {
+ rtreeRename(args);
+ }
+ else if (memcmp(E.xRename_signature, xRename_signatures[xRename_xRename_enum], sizeof(E.xRename_signature)) == 0) {
+ xRename(args);
+ }


// FP: xRollback

@transform_standalone_xRollback_dot@
expression E;
identifier FP_NAME = xRollback;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xRollback_signature, xRollback_signatures[xRollback_0_enum], sizeof(E.xRollback_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xRollback_signature, xRollback_signatures[xRollback_fts3RollbackMethod_enum], sizeof(E.xRollback_signature)) == 0) {
+ fts3RollbackMethod(args);
+ }
+ else if (memcmp(E.xRollback_signature, xRollback_signatures[xRollback_rtreeEndTransaction_enum], sizeof(E.xRollback_signature)) == 0) {
+ rtreeEndTransaction(args);
+ }
+ else if (memcmp(E.xRollback_signature, xRollback_signatures[xRollback_rtreeRollback_enum], sizeof(E.xRollback_signature)) == 0) {
+ rtreeRollback(args);
+ }
+ else if (memcmp(E.xRollback_signature, xRollback_signatures[xRollback_zipfileRollback_enum], sizeof(E.xRollback_signature)) == 0) {
+ zipfileRollback(args);
+ }


// FP: xRollbackCallback

@transform_standalone_xRollbackCallback_dot@
expression E;
identifier FP_NAME = xRollbackCallback;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xRollbackCallback_signature, xRollbackCallback_signatures[xRollbackCallback_0_enum], sizeof(E.xRollbackCallback_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xRollbackCallback_signature, xRollbackCallback_signatures[xRollbackCallback_sql_trace_callback_enum], sizeof(E.xRollbackCallback_signature)) == 0) {
+ sql_trace_callback(args);
+ }
+ else if (memcmp(E.xRollbackCallback_signature, xRollbackCallback_signatures[xRollbackCallback_sqlite3WalDefaultHook_enum], sizeof(E.xRollbackCallback_signature)) == 0) {
+ sqlite3WalDefaultHook(args);
+ }


// FP: xRollbackTo

@transform_standalone_xRollbackTo_dot@
expression E;
identifier FP_NAME = xRollbackTo;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xRollbackTo_signature, xRollbackTo_signatures[xRollbackTo_0_enum], sizeof(E.xRollbackTo_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xRollbackTo_signature, xRollbackTo_signatures[xRollbackTo_dbpageRollbackTo_enum], sizeof(E.xRollbackTo_signature)) == 0) {
+ dbpageRollbackTo(args);
+ }
+ else if (memcmp(E.xRollbackTo_signature, xRollbackTo_signatures[xRollbackTo_fts3RollbackToMethod_enum], sizeof(E.xRollbackTo_signature)) == 0) {
+ fts3RollbackToMethod(args);
+ }


// FP: xRoundup

@transform_standalone_xRoundup_dot@
expression E;
identifier FP_NAME = xRoundup;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xRoundup_signature, xRoundup_signatures[xRoundup_memtraceRoundup_enum], sizeof(E.xRoundup_signature)) == 0) {
+ memtraceRoundup(args);
+ }
+ else if (memcmp(E.xRoundup_signature, xRoundup_signatures[xRoundup_sqlite3MemRoundup_enum], sizeof(E.xRoundup_signature)) == 0) {
+ sqlite3MemRoundup(args);
+ }


// FP: xRowid

@transform_standalone_xRowid_dot@
expression E;
identifier FP_NAME = xRowid;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_0_enum], sizeof(E.xRowid_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_bytecodevtabRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ bytecodevtabRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_completionRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ completionRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_dbdataRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ dbdataRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_dbpageRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ dbpageRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_expertRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ expertRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_fsdirRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ fsdirRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_fts3RowidMethod_enum], sizeof(E.xRowid_signature)) == 0) {
+ fts3RowidMethod(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_fts3auxRowidMethod_enum], sizeof(E.xRowid_signature)) == 0) {
+ fts3auxRowidMethod(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_fts3tokRowidMethod_enum], sizeof(E.xRowid_signature)) == 0) {
+ fts3tokRowidMethod(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_jsonEachRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ jsonEachRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_pragmaVtabRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ pragmaVtabRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_rtreeRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ rtreeRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_seriesRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ seriesRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_statRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ statRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_stmtRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ stmtRowid(args);
+ }


// FP: xSFunc

@transform_standalone_xSFunc_dot@
expression E;
identifier FP_NAME = xSFunc;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_0_enum], sizeof(E.xSFunc_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_attachFunc_enum], sizeof(E.xSFunc_signature)) == 0) {
+ attachFunc(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_base64_enum], sizeof(E.xSFunc_signature)) == 0) {
+ base64(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_base85_enum], sizeof(E.xSFunc_signature)) == 0) {
+ base85(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_detachFunc_enum], sizeof(E.xSFunc_signature)) == 0) {
+ detachFunc(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_dummyUDF_enum], sizeof(E.xSFunc_signature)) == 0) {
+ dummyUDF(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_editFunc_enum], sizeof(E.xSFunc_signature)) == 0) {
+ editFunc(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_fts3AllocateMSI_enum], sizeof(E.xSFunc_signature)) == 0) {
+ fts3AllocateMSI(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_fts3ExprGlobalHitsCb_enum], sizeof(E.xSFunc_signature)) == 0) {
+ fts3ExprGlobalHitsCb(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_fts3ExprLoadDoclistsCb_enum], sizeof(E.xSFunc_signature)) == 0) {
+ fts3ExprLoadDoclistsCb(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_fts3ExprLocalHitsCb_enum], sizeof(E.xSFunc_signature)) == 0) {
+ fts3ExprLocalHitsCb(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_fts3ExprPhraseCountCb_enum], sizeof(E.xSFunc_signature)) == 0) {
+ fts3ExprPhraseCountCb(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_fts3ExprRestartIfCb_enum], sizeof(E.xSFunc_signature)) == 0) {
+ fts3ExprRestartIfCb(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_fts3ExprTermOffsetInit_enum], sizeof(E.xSFunc_signature)) == 0) {
+ fts3ExprTermOffsetInit(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_fts3ExprTest_enum], sizeof(E.xSFunc_signature)) == 0) {
+ fts3ExprTest(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_fts3ExprTestRebalance_enum], sizeof(E.xSFunc_signature)) == 0) {
+ fts3ExprTestRebalance(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_fts3MatchinfoLcsCb_enum], sizeof(E.xSFunc_signature)) == 0) {
+ fts3MatchinfoLcsCb(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_fts3SnippetFindPositions_enum], sizeof(E.xSFunc_signature)) == 0) {
+ fts3SnippetFindPositions(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_fts3TokenizerFunc_enum], sizeof(E.xSFunc_signature)) == 0) {
+ fts3TokenizerFunc(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_geomCallback_enum], sizeof(E.xSFunc_signature)) == 0) {
+ geomCallback(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_idxRemFunc_enum], sizeof(E.xSFunc_signature)) == 0) {
+ idxRemFunc(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_idxSampleFunc_enum], sizeof(E.xSFunc_signature)) == 0) {
+ idxSampleFunc(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_intTestFunc_enum], sizeof(E.xSFunc_signature)) == 0) {
+ intTestFunc(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_intckParseCreateIndexFunc_enum], sizeof(E.xSFunc_signature)) == 0) {
+ intckParseCreateIndexFunc(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_is_base85_enum], sizeof(E.xSFunc_signature)) == 0) {
+ is_base85(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_likeFunc_enum], sizeof(E.xSFunc_signature)) == 0) {
+ likeFunc(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_lsModeFunc_enum], sizeof(E.xSFunc_signature)) == 0) {
+ lsModeFunc(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_rbuFossilDeltaFunc_enum], sizeof(E.xSFunc_signature)) == 0) {
+ rbuFossilDeltaFunc(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_rbuIndexCntFunc_enum], sizeof(E.xSFunc_signature)) == 0) {
+ rbuIndexCntFunc(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_rbuTargetNameFunc_enum], sizeof(E.xSFunc_signature)) == 0) {
+ rbuTargetNameFunc(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_rbuTmpInsertFunc_enum], sizeof(E.xSFunc_signature)) == 0) {
+ rbuTmpInsertFunc(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_re_bytecode_func_enum], sizeof(E.xSFunc_signature)) == 0) {
+ re_bytecode_func(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_re_sql_func_enum], sizeof(E.xSFunc_signature)) == 0) {
+ re_sql_func(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_readfileFunc_enum], sizeof(E.xSFunc_signature)) == 0) {
+ readfileFunc(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_rtreecheck_enum], sizeof(E.xSFunc_signature)) == 0) {
+ rtreecheck(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_rtreedepth_enum], sizeof(E.xSFunc_signature)) == 0) {
+ rtreedepth(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_rtreenode_enum], sizeof(E.xSFunc_signature)) == 0) {
+ rtreenode(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_sha1Func_enum], sizeof(E.xSFunc_signature)) == 0) {
+ sha1Func(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_sha1QueryFunc_enum], sizeof(E.xSFunc_signature)) == 0) {
+ sha1QueryFunc(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_sha3Func_enum], sizeof(E.xSFunc_signature)) == 0) {
+ sha3Func(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_sha3QueryFunc_enum], sizeof(E.xSFunc_signature)) == 0) {
+ sha3QueryFunc(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_shellAddSchemaName_enum], sizeof(E.xSFunc_signature)) == 0) {
+ shellAddSchemaName(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_shellDtostr_enum], sizeof(E.xSFunc_signature)) == 0) {
+ shellDtostr(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_shellFkeyCollateClause_enum], sizeof(E.xSFunc_signature)) == 0) {
+ shellFkeyCollateClause(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_shellModuleSchema_enum], sizeof(E.xSFunc_signature)) == 0) {
+ shellModuleSchema(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_shellPutsFunc_enum], sizeof(E.xSFunc_signature)) == 0) {
+ shellPutsFunc(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_shellStrtod_enum], sizeof(E.xSFunc_signature)) == 0) {
+ shellStrtod(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_shellUSleepFunc_enum], sizeof(E.xSFunc_signature)) == 0) {
+ shellUSleepFunc(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_sqlarCompressFunc_enum], sizeof(E.xSFunc_signature)) == 0) {
+ sqlarCompressFunc(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_sqlarUncompressFunc_enum], sizeof(E.xSFunc_signature)) == 0) {
+ sqlarUncompressFunc(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_sqlite3InvalidFunction_enum], sizeof(E.xSFunc_signature)) == 0) {
+ sqlite3InvalidFunction(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_statGet_enum], sizeof(E.xSFunc_signature)) == 0) {
+ statGet(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_statInit_enum], sizeof(E.xSFunc_signature)) == 0) {
+ statInit(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_statPush_enum], sizeof(E.xSFunc_signature)) == 0) {
+ statPush(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_stmtrandFunc_enum], sizeof(E.xSFunc_signature)) == 0) {
+ stmtrandFunc(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_testFunc_enum], sizeof(E.xSFunc_signature)) == 0) {
+ testFunc(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_writefileFunc_enum], sizeof(E.xSFunc_signature)) == 0) {
+ writefileFunc(args);
+ }


// FP: xSavepoint

@transform_standalone_xSavepoint_dot@
expression E;
identifier FP_NAME = xSavepoint;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xSavepoint_signature, xSavepoint_signatures[xSavepoint_0_enum], sizeof(E.xSavepoint_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xSavepoint_signature, xSavepoint_signatures[xSavepoint_fts3SavepointMethod_enum], sizeof(E.xSavepoint_signature)) == 0) {
+ fts3SavepointMethod(args);
+ }
+ else if (memcmp(E.xSavepoint_signature, xSavepoint_signatures[xSavepoint_rtreeSavepoint_enum], sizeof(E.xSavepoint_signature)) == 0) {
+ rtreeSavepoint(args);
+ }


// FP: xSectorSize

@transform_standalone_xSectorSize_dot@
expression E;
identifier FP_NAME = xSectorSize;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xSectorSize_signature, xSectorSize_signatures[xSectorSize_0_enum], sizeof(E.xSectorSize_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xSectorSize_signature, xSectorSize_signatures[xSectorSize_apndSectorSize_enum], sizeof(E.xSectorSize_signature)) == 0) {
+ apndSectorSize(args);
+ }
+ else if (memcmp(E.xSectorSize_signature, xSectorSize_signatures[xSectorSize_recoverVfsSectorSize_enum], sizeof(E.xSectorSize_signature)) == 0) {
+ recoverVfsSectorSize(args);
+ }
+ else if (memcmp(E.xSectorSize_signature, xSectorSize_signatures[xSectorSize_vfstraceSectorSize_enum], sizeof(E.xSectorSize_signature)) == 0) {
+ vfstraceSectorSize(args);
+ }


// FP: xSelectCallback

@transform_standalone_xSelectCallback_dot@
expression E;
identifier FP_NAME = xSelectCallback;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_0_enum], sizeof(E.xSelectCallback_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_convertCompoundSelectToSubquery_enum], sizeof(E.xSelectCallback_signature)) == 0) {
+ convertCompoundSelectToSubquery(args);
+ }
+ else if (memcmp(E.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_exprSelectWalkTableConstant_enum], sizeof(E.xSelectCallback_signature)) == 0) {
+ exprSelectWalkTableConstant(args);
+ }
+ else if (memcmp(E.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_fixSelectCb_enum], sizeof(E.xSelectCallback_signature)) == 0) {
+ fixSelectCb(args);
+ }
+ else if (memcmp(E.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_gatherSelectWindowsSelectCallback_enum], sizeof(E.xSelectCallback_signature)) == 0) {
+ gatherSelectWindowsSelectCallback(args);
+ }
+ else if (memcmp(E.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_renameColumnSelectCb_enum], sizeof(E.xSelectCallback_signature)) == 0) {
+ renameColumnSelectCb(args);
+ }
+ else if (memcmp(E.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_renameTableSelectCb_enum], sizeof(E.xSelectCallback_signature)) == 0) {
+ renameTableSelectCb(args);
+ }
+ else if (memcmp(E.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_renameUnmapSelectCb_enum], sizeof(E.xSelectCallback_signature)) == 0) {
+ renameUnmapSelectCb(args);
+ }
+ else if (memcmp(E.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_resolveSelectStep_enum], sizeof(E.xSelectCallback_signature)) == 0) {
+ resolveSelectStep(args);
+ }
+ else if (memcmp(E.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_selectCheckOnClausesSelect_enum], sizeof(E.xSelectCallback_signature)) == 0) {
+ selectCheckOnClausesSelect(args);
+ }
+ else if (memcmp(E.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_selectExpander_enum], sizeof(E.xSelectCallback_signature)) == 0) {
+ selectExpander(args);
+ }
+ else if (memcmp(E.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_selectRefEnter_enum], sizeof(E.xSelectCallback_signature)) == 0) {
+ selectRefEnter(args);
+ }
+ else if (memcmp(E.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_selectWindowRewriteSelectCb_enum], sizeof(E.xSelectCallback_signature)) == 0) {
+ selectWindowRewriteSelectCb(args);
+ }
+ else if (memcmp(E.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_sqlite3ReturningSubqueryCorrelated_enum], sizeof(E.xSelectCallback_signature)) == 0) {
+ sqlite3ReturningSubqueryCorrelated(args);
+ }
+ else if (memcmp(E.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_sqlite3SelectWalkFail_enum], sizeof(E.xSelectCallback_signature)) == 0) {
+ sqlite3SelectWalkFail(args);
+ }
+ else if (memcmp(E.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_sqlite3SelectWalkNoop_enum], sizeof(E.xSelectCallback_signature)) == 0) {
+ sqlite3SelectWalkNoop(args);
+ }
+ else if (memcmp(E.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_sqlite3WalkerDepthIncrease_enum], sizeof(E.xSelectCallback_signature)) == 0) {
+ sqlite3WalkerDepthIncrease(args);
+ }


// FP: xSelectCallback2

@transform_standalone_xSelectCallback2_dot@
expression E;
identifier FP_NAME = xSelectCallback2;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_0_enum], sizeof(E.xSelectCallback2_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_selectAddSubqueryTypeInfo_enum], sizeof(E.xSelectCallback2_signature)) == 0) {
+ selectAddSubqueryTypeInfo(args);
+ }
+ else if (memcmp(E.xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_selectRefLeave_enum], sizeof(E.xSelectCallback2_signature)) == 0) {
+ selectRefLeave(args);
+ }
+ else if (memcmp(E.xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_sqlite3SelectPopWith_enum], sizeof(E.xSelectCallback2_signature)) == 0) {
+ sqlite3SelectPopWith(args);
+ }
+ else if (memcmp(E.xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_sqlite3WalkWinDefnDummyCallback_enum], sizeof(E.xSelectCallback2_signature)) == 0) {
+ sqlite3WalkWinDefnDummyCallback(args);
+ }
+ else if (memcmp(E.xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_sqlite3WalkerDepthDecrease_enum], sizeof(E.xSelectCallback2_signature)) == 0) {
+ sqlite3WalkerDepthDecrease(args);
+ }


// FP: xSetSystemCall

@transform_standalone_xSetSystemCall_dot@
expression E;
identifier FP_NAME = xSetSystemCall;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xSetSystemCall_signature, xSetSystemCall_signatures[xSetSystemCall_0_enum], sizeof(E.xSetSystemCall_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xSetSystemCall_signature, xSetSystemCall_signatures[xSetSystemCall_apndSetSystemCall_enum], sizeof(E.xSetSystemCall_signature)) == 0) {
+ apndSetSystemCall(args);
+ }
+ else if (memcmp(E.xSetSystemCall_signature, xSetSystemCall_signatures[xSetSystemCall_rbuVfsSleep_enum], sizeof(E.xSetSystemCall_signature)) == 0) {
+ rbuVfsSleep(args);
+ }
+ else if (memcmp(E.xSetSystemCall_signature, xSetSystemCall_signatures[xSetSystemCall_unixSetSystemCall_enum], sizeof(E.xSetSystemCall_signature)) == 0) {
+ unixSetSystemCall(args);
+ }


// FP: xShadowName

@transform_standalone_xShadowName_dot@
expression E;
identifier FP_NAME = xShadowName;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xShadowName_signature, xShadowName_signatures[xShadowName_0_enum], sizeof(E.xShadowName_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xShadowName_signature, xShadowName_signatures[xShadowName_fts3ShadowName_enum], sizeof(E.xShadowName_signature)) == 0) {
+ fts3ShadowName(args);
+ }
+ else if (memcmp(E.xShadowName_signature, xShadowName_signatures[xShadowName_rtreeShadowName_enum], sizeof(E.xShadowName_signature)) == 0) {
+ rtreeShadowName(args);
+ }


// FP: xShmBarrier

@transform_standalone_xShmBarrier_dot@
expression E;
identifier FP_NAME = xShmBarrier;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xShmBarrier_signature, xShmBarrier_signatures[xShmBarrier_0_enum], sizeof(E.xShmBarrier_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xShmBarrier_signature, xShmBarrier_signatures[xShmBarrier_apndShmBarrier_enum], sizeof(E.xShmBarrier_signature)) == 0) {
+ apndShmBarrier(args);
+ }
+ else if (memcmp(E.xShmBarrier_signature, xShmBarrier_signatures[xShmBarrier_recoverVfsShmBarrier_enum], sizeof(E.xShmBarrier_signature)) == 0) {
+ recoverVfsShmBarrier(args);
+ }


// FP: xShmLock

@transform_standalone_xShmLock_dot@
expression E;
identifier FP_NAME = xShmLock;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xShmLock_signature, xShmLock_signatures[xShmLock_0_enum], sizeof(E.xShmLock_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xShmLock_signature, xShmLock_signatures[xShmLock_apndShmLock_enum], sizeof(E.xShmLock_signature)) == 0) {
+ apndShmLock(args);
+ }
+ else if (memcmp(E.xShmLock_signature, xShmLock_signatures[xShmLock_recoverVfsShmLock_enum], sizeof(E.xShmLock_signature)) == 0) {
+ recoverVfsShmLock(args);
+ }


// FP: xShmMap

@transform_standalone_xShmMap_dot@
expression E;
identifier FP_NAME = xShmMap;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xShmMap_signature, xShmMap_signatures[xShmMap_0_enum], sizeof(E.xShmMap_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xShmMap_signature, xShmMap_signatures[xShmMap_apndShmMap_enum], sizeof(E.xShmMap_signature)) == 0) {
+ apndShmMap(args);
+ }
+ else if (memcmp(E.xShmMap_signature, xShmMap_signatures[xShmMap_recoverVfsShmMap_enum], sizeof(E.xShmMap_signature)) == 0) {
+ recoverVfsShmMap(args);
+ }


// FP: xShmUnmap

@transform_standalone_xShmUnmap_dot@
expression E;
identifier FP_NAME = xShmUnmap;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xShmUnmap_signature, xShmUnmap_signatures[xShmUnmap_0_enum], sizeof(E.xShmUnmap_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xShmUnmap_signature, xShmUnmap_signatures[xShmUnmap_apndShmUnmap_enum], sizeof(E.xShmUnmap_signature)) == 0) {
+ apndShmUnmap(args);
+ }
+ else if (memcmp(E.xShmUnmap_signature, xShmUnmap_signatures[xShmUnmap_recoverVfsShmUnmap_enum], sizeof(E.xShmUnmap_signature)) == 0) {
+ recoverVfsShmUnmap(args);
+ }


// FP: xShrink

@transform_standalone_xShrink_dot@
expression E;
identifier FP_NAME = xShrink;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xShrink_signature, xShrink_signatures[xShrink_pcache1Shrink_enum], sizeof(E.xShrink_signature)) == 0) {
+ pcache1Shrink(args);
+ }
+ else if (memcmp(E.xShrink_signature, xShrink_signatures[xShrink_pcachetraceShrink_enum], sizeof(E.xShrink_signature)) == 0) {
+ pcachetraceShrink(args);
+ }


// FP: xShutdown

@transform_standalone_xShutdown_dot@
expression E;
identifier FP_NAME = xShutdown;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xShutdown_signature, xShutdown_signatures[xShutdown_memtraceShutdown_enum], sizeof(E.xShutdown_signature)) == 0) {
+ memtraceShutdown(args);
+ }
+ else if (memcmp(E.xShutdown_signature, xShutdown_signatures[xShutdown_pcache1Shutdown_enum], sizeof(E.xShutdown_signature)) == 0) {
+ pcache1Shutdown(args);
+ }
+ else if (memcmp(E.xShutdown_signature, xShutdown_signatures[xShutdown_pcachetraceShutdown_enum], sizeof(E.xShutdown_signature)) == 0) {
+ pcachetraceShutdown(args);
+ }
+ else if (memcmp(E.xShutdown_signature, xShutdown_signatures[xShutdown_sqlite3MemShutdown_enum], sizeof(E.xShutdown_signature)) == 0) {
+ sqlite3MemShutdown(args);
+ }


// FP: xSize

@transform_standalone_xSize_dot@
expression E;
identifier FP_NAME = xSize;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xSize_signature, xSize_signatures[xSize_memtraceSize_enum], sizeof(E.xSize_signature)) == 0) {
+ memtraceSize(args);
+ }
+ else if (memcmp(E.xSize_signature, xSize_signatures[xSize_sqlite3MemSize_enum], sizeof(E.xSize_signature)) == 0) {
+ sqlite3MemSize(args);
+ }


// FP: xSleep

@transform_standalone_xSleep_dot@
expression E;
identifier FP_NAME = xSleep;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xSleep_signature, xSleep_signatures[xSleep_0_enum], sizeof(E.xSleep_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xSleep_signature, xSleep_signatures[xSleep_apndSleep_enum], sizeof(E.xSleep_signature)) == 0) {
+ apndSleep(args);
+ }
+ else if (memcmp(E.xSleep_signature, xSleep_signatures[xSleep_memdbSleep_enum], sizeof(E.xSleep_signature)) == 0) {
+ memdbSleep(args);
+ }
+ else if (memcmp(E.xSleep_signature, xSleep_signatures[xSleep_vfstraceSleep_enum], sizeof(E.xSleep_signature)) == 0) {
+ vfstraceSleep(args);
+ }
+ else if (memcmp(E.xSleep_signature, xSleep_signatures[xSleep_unixSleep_enum], sizeof(E.xSleep_signature)) == 0) {
+ unixSleep(args);
+ }


// FP: xSql

@transform_standalone_xSql_dot@
expression E;
identifier FP_NAME = xSql;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xSql_signature, xSql_signatures[xSql_0_enum], sizeof(E.xSql_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xSql_signature, xSql_signatures[xSql_recoverSqlCb_enum], sizeof(E.xSql_signature)) == 0) {
+ recoverSqlCb(args);
+ }


// FP: xSync

@transform_standalone_xSync_dot@
expression E;
identifier FP_NAME = xSync;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xSync_signature, xSync_signatures[xSync_0_enum], sizeof(E.xSync_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xSync_signature, xSync_signatures[xSync_apndSync_enum], sizeof(E.xSync_signature)) == 0) {
+ apndSync(args);
+ }
+ else if (memcmp(E.xSync_signature, xSync_signatures[xSync_dbpageSync_enum], sizeof(E.xSync_signature)) == 0) {
+ dbpageSync(args);
+ }
+ else if (memcmp(E.xSync_signature, xSync_signatures[xSync_fts3SyncMethod_enum], sizeof(E.xSync_signature)) == 0) {
+ fts3SyncMethod(args);
+ }
+ else if (memcmp(E.xSync_signature, xSync_signatures[xSync_memdbSync_enum], sizeof(E.xSync_signature)) == 0) {
+ memdbSync(args);
+ }
+ else if (memcmp(E.xSync_signature, xSync_signatures[xSync_memjrnlSync_enum], sizeof(E.xSync_signature)) == 0) {
+ memjrnlSync(args);
+ }
+ else if (memcmp(E.xSync_signature, xSync_signatures[xSync_recoverVfsSync_enum], sizeof(E.xSync_signature)) == 0) {
+ recoverVfsSync(args);
+ }
+ else if (memcmp(E.xSync_signature, xSync_signatures[xSync_rtreeEndTransaction_enum], sizeof(E.xSync_signature)) == 0) {
+ rtreeEndTransaction(args);
+ }
+ else if (memcmp(E.xSync_signature, xSync_signatures[xSync_vfstraceSync_enum], sizeof(E.xSync_signature)) == 0) {
+ vfstraceSync(args);
+ }


// FP: xTableFilter

@transform_standalone_xTableFilter_dot@
expression E;
identifier FP_NAME = xTableFilter;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xTableFilter_signature, xTableFilter_signatures[xTableFilter_0_enum], sizeof(E.xTableFilter_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xTableFilter_signature, xTableFilter_signatures[xTableFilter_session_filter_enum], sizeof(E.xTableFilter_signature)) == 0) {
+ session_filter(args);
+ }


// FP: xTask

@transform_standalone_xTask_dot@
expression E;
identifier FP_NAME = xTask;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xTask_signature, xTask_signatures[xTask_0_enum], sizeof(E.xTask_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xTask_signature, xTask_signatures[xTask_vdbeSorterFlushThread_enum], sizeof(E.xTask_signature)) == 0) {
+ vdbeSorterFlushThread(args);
+ }
+ else if (memcmp(E.xTask_signature, xTask_signatures[xTask_vdbeIncrPopulateThread_enum], sizeof(E.xTask_signature)) == 0) {
+ vdbeIncrPopulateThread(args);
+ }
+ else if (memcmp(E.xTask_signature, xTask_signatures[xTask_vdbePmaReaderBgIncrInit_enum], sizeof(E.xTask_signature)) == 0) {
+ vdbePmaReaderBgIncrInit(args);
+ }


// FP: xTruncate

@transform_standalone_xTruncate_dot@
expression E;
identifier FP_NAME = xTruncate;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xTruncate_signature, xTruncate_signatures[xTruncate_apndTruncate_enum], sizeof(E.xTruncate_signature)) == 0) {
+ apndTruncate(args);
+ }
+ else if (memcmp(E.xTruncate_signature, xTruncate_signatures[xTruncate_memdbTruncate_enum], sizeof(E.xTruncate_signature)) == 0) {
+ memdbTruncate(args);
+ }
+ else if (memcmp(E.xTruncate_signature, xTruncate_signatures[xTruncate_memjrnlTruncate_enum], sizeof(E.xTruncate_signature)) == 0) {
+ memjrnlTruncate(args);
+ }
+ else if (memcmp(E.xTruncate_signature, xTruncate_signatures[xTruncate_pcache1Truncate_enum], sizeof(E.xTruncate_signature)) == 0) {
+ pcache1Truncate(args);
+ }
+ else if (memcmp(E.xTruncate_signature, xTruncate_signatures[xTruncate_pcachetraceTruncate_enum], sizeof(E.xTruncate_signature)) == 0) {
+ pcachetraceTruncate(args);
+ }
+ else if (memcmp(E.xTruncate_signature, xTruncate_signatures[xTruncate_recoverVfsTruncate_enum], sizeof(E.xTruncate_signature)) == 0) {
+ recoverVfsTruncate(args);
+ }
+ else if (memcmp(E.xTruncate_signature, xTruncate_signatures[xTruncate_vfstraceTruncate_enum], sizeof(E.xTruncate_signature)) == 0) {
+ vfstraceTruncate(args);
+ }


// FP: xUnfetch

@transform_standalone_xUnfetch_dot@
expression E;
identifier FP_NAME = xUnfetch;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xUnfetch_signature, xUnfetch_signatures[xUnfetch_0_enum], sizeof(E.xUnfetch_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xUnfetch_signature, xUnfetch_signatures[xUnfetch_apndUnfetch_enum], sizeof(E.xUnfetch_signature)) == 0) {
+ apndUnfetch(args);
+ }
+ else if (memcmp(E.xUnfetch_signature, xUnfetch_signatures[xUnfetch_memdbUnfetch_enum], sizeof(E.xUnfetch_signature)) == 0) {
+ memdbUnfetch(args);
+ }
+ else if (memcmp(E.xUnfetch_signature, xUnfetch_signatures[xUnfetch_recoverVfsUnfetch_enum], sizeof(E.xUnfetch_signature)) == 0) {
+ recoverVfsUnfetch(args);
+ }


// FP: xUnlock

@transform_standalone_xUnlock_dot@
expression E;
identifier FP_NAME = xUnlock;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xUnlock_signature, xUnlock_signatures[xUnlock_0_enum], sizeof(E.xUnlock_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xUnlock_signature, xUnlock_signatures[xUnlock_apndUnlock_enum], sizeof(E.xUnlock_signature)) == 0) {
+ apndUnlock(args);
+ }
+ else if (memcmp(E.xUnlock_signature, xUnlock_signatures[xUnlock_memdbUnlock_enum], sizeof(E.xUnlock_signature)) == 0) {
+ memdbUnlock(args);
+ }
+ else if (memcmp(E.xUnlock_signature, xUnlock_signatures[xUnlock_recoverVfsUnlock_enum], sizeof(E.xUnlock_signature)) == 0) {
+ recoverVfsUnlock(args);
+ }
+ else if (memcmp(E.xUnlock_signature, xUnlock_signatures[xUnlock_vfstraceUnlock_enum], sizeof(E.xUnlock_signature)) == 0) {
+ vfstraceUnlock(args);
+ }


// FP: xUnlockNotify

@transform_standalone_xUnlockNotify_dot@
expression E;
identifier FP_NAME = xUnlockNotify;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xUnlockNotify_signature, xUnlockNotify_signatures[xUnlockNotify_0_enum], sizeof(E.xUnlockNotify_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xUnlockNotify_signature, xUnlockNotify_signatures[xUnlockNotify_xUnlockNotify_enum], sizeof(E.xUnlockNotify_signature)) == 0) {
+ xUnlockNotify(args);
+ }


// FP: xUnpin

@transform_standalone_xUnpin_dot@
expression E;
identifier FP_NAME = xUnpin;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xUnpin_signature, xUnpin_signatures[xUnpin_pcache1Unpin_enum], sizeof(E.xUnpin_signature)) == 0) {
+ pcache1Unpin(args);
+ }
+ else if (memcmp(E.xUnpin_signature, xUnpin_signatures[xUnpin_pcachetraceUnpin_enum], sizeof(E.xUnpin_signature)) == 0) {
+ pcachetraceUnpin(args);
+ }


// FP: xUpdate

@transform_standalone_xUpdate_dot@
expression E;
identifier FP_NAME = xUpdate;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xUpdate_signature, xUpdate_signatures[xUpdate_0_enum], sizeof(E.xUpdate_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xUpdate_signature, xUpdate_signatures[xUpdate_dbpageUpdate_enum], sizeof(E.xUpdate_signature)) == 0) {
+ dbpageUpdate(args);
+ }
+ else if (memcmp(E.xUpdate_signature, xUpdate_signatures[xUpdate_expertUpdate_enum], sizeof(E.xUpdate_signature)) == 0) {
+ expertUpdate(args);
+ }
+ else if (memcmp(E.xUpdate_signature, xUpdate_signatures[xUpdate_fts3UpdateMethod_enum], sizeof(E.xUpdate_signature)) == 0) {
+ fts3UpdateMethod(args);
+ }
+ else if (memcmp(E.xUpdate_signature, xUpdate_signatures[xUpdate_geopolyUpdate_enum], sizeof(E.xUpdate_signature)) == 0) {
+ geopolyUpdate(args);
+ }
+ else if (memcmp(E.xUpdate_signature, xUpdate_signatures[xUpdate_rtreeUpdate_enum], sizeof(E.xUpdate_signature)) == 0) {
+ rtreeUpdate(args);
+ }
+ else if (memcmp(E.xUpdate_signature, xUpdate_signatures[xUpdate_zipfileUpdate_enum], sizeof(E.xUpdate_signature)) == 0) {
+ zipfileUpdate(args);
+ }


// FP: xUpdateCallback

@transform_standalone_xUpdateCallback_dot@
expression E;
identifier FP_NAME = xUpdateCallback;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xUpdateCallback_signature, xUpdateCallback_signatures[xUpdateCallback_0_enum], sizeof(E.xUpdateCallback_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xUpdateCallback_signature, xUpdateCallback_signatures[xUpdateCallback_sql_trace_callback_enum], sizeof(E.xUpdateCallback_signature)) == 0) {
+ sql_trace_callback(args);
+ }
+ else if (memcmp(E.xUpdateCallback_signature, xUpdateCallback_signatures[xUpdateCallback_sqlite3WalDefaultHook_enum], sizeof(E.xUpdateCallback_signature)) == 0) {
+ sqlite3WalDefaultHook(args);
+ }


// FP: xV2

@transform_standalone_xV2_dot@
expression E;
identifier FP_NAME = xV2;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xV2_signature, xV2_signatures[xV2_0_enum], sizeof(E.xV2_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xV2_signature, xV2_signatures[xV2_sql_trace_callback_enum], sizeof(E.xV2_signature)) == 0) {
+ sql_trace_callback(args);
+ }


// FP: xValue

@transform_standalone_xValue_dot@
expression E;
identifier FP_NAME = xValue;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xValue_signature, xValue_signatures[xValue_0_enum], sizeof(E.xValue_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xValue_signature, xValue_signatures[xValue_decimalSumValue_enum], sizeof(E.xValue_signature)) == 0) {
+ decimalSumValue(args);
+ }
+ else if (memcmp(E.xValue_signature, xValue_signatures[xValue_percentValue_enum], sizeof(E.xValue_signature)) == 0) {
+ percentValue(args);
+ }
+ else if (memcmp(E.xValue_signature, xValue_signatures[xValue_sqlite3changeset_new_enum], sizeof(E.xValue_signature)) == 0) {
+ sqlite3changeset_new(args);
+ }
+ else if (memcmp(E.xValue_signature, xValue_signatures[xValue_sqlite3changeset_old_enum], sizeof(E.xValue_signature)) == 0) {
+ sqlite3changeset_old(args);
+ }


// FP: xWrite

@transform_standalone_xWrite_dot@
expression E;
identifier FP_NAME = xWrite;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ if (memcmp(E.xWrite_signature, xWrite_signatures[xWrite_apndWrite_enum], sizeof(E.xWrite_signature)) == 0) {
+ apndWrite(args);
+ }
+ else if (memcmp(E.xWrite_signature, xWrite_signatures[xWrite_kvstorageWrite_enum], sizeof(E.xWrite_signature)) == 0) {
+ kvstorageWrite(args);
+ }
+ else if (memcmp(E.xWrite_signature, xWrite_signatures[xWrite_memdbWrite_enum], sizeof(E.xWrite_signature)) == 0) {
+ memdbWrite(args);
+ }
+ else if (memcmp(E.xWrite_signature, xWrite_signatures[xWrite_memjrnlWrite_enum], sizeof(E.xWrite_signature)) == 0) {
+ memjrnlWrite(args);
+ }
+ else if (memcmp(E.xWrite_signature, xWrite_signatures[xWrite_recoverVfsWrite_enum], sizeof(E.xWrite_signature)) == 0) {
+ recoverVfsWrite(args);
+ }
+ else if (memcmp(E.xWrite_signature, xWrite_signatures[xWrite_vfstraceWrite_enum], sizeof(E.xWrite_signature)) == 0) {
+ vfstraceWrite(args);
+ }


// FP: xsnprintf

@transform_standalone_xsnprintf_dot@
expression E;
identifier FP_NAME = xsnprintf;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ sqlite3_set_authorizer(args);


// FP: xvsnprintf

@transform_standalone_xvsnprintf_dot@
expression E;
identifier FP_NAME = xvsnprintf;
expression list args;
@@
- E.FP_NAME(args);
+ // E.FP_NAME(args);
+ 0;

// Total standalone dot rules: 359

