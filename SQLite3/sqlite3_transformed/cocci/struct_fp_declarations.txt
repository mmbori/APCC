int agginfoPersistExprCb(Walker *pWalker, Expr *pExpr){
int aggregateIdxEprRefToColCallback(Walker *pWalker, Expr *pExpr){
int analyzeAggregate(Walker *pWalker, Expr *pExpr){
static int apndAccess(sqlite3_vfs*, const char *zName, int flags, int *);
static int apndCheckReservedLock(sqlite3_file*, int *pResOut);
static int apndClose(sqlite3_file*);
static int apndCurrentTime(sqlite3_vfs*, double*);
static int apndCurrentTimeInt64(sqlite3_vfs*, sqlite3_int64*);
static int apndDelete(sqlite3_vfs*, const char *zName, int syncDir);
static int apndDeviceCharacteristics(sqlite3_file*);
static void apndDlClose(sqlite3_vfs*, void*);
static void apndDlError(sqlite3_vfs*, int nByte, char *zErrMsg);
static void *apndDlOpen(sqlite3_vfs*, const char *zFilename);
static int apndFetch(sqlite3_file*, sqlite3_int64 iOfst, int iAmt, void **pp);
static int apndFileControl(sqlite3_file*, int op, void *pArg);
static int apndFileSize(sqlite3_file*, sqlite3_int64 *pSize);
static int apndFullPathname(sqlite3_vfs*, const char *zName, int, char *zOut);
static int apndGetLastError(sqlite3_vfs*, int, char *);
static sqlite3_syscall_ptr apndGetSystemCall(sqlite3_vfs*, const char *z);
static int apndLock(sqlite3_file*, int);
static const char *apndNextSystemCall(sqlite3_vfs*, const char *zName);
static int apndOpen(sqlite3_vfs*, const char *, sqlite3_file*, int , int *);
static int apndRandomness(sqlite3_vfs*, int nByte, char *zOut);
static int apndRead(sqlite3_file*, void*, int iAmt, sqlite3_int64 iOfst);
static int apndSectorSize(sqlite3_file*);
static int apndSetSystemCall(sqlite3_vfs*, const char*,sqlite3_syscall_ptr);
static void apndShmBarrier(sqlite3_file*);
static int apndShmLock(sqlite3_file*, int offset, int n, int flags);
static int apndShmMap(sqlite3_file*, int iPg, int pgsz, int, void volatile**);
static int apndShmUnmap(sqlite3_file*, int deleteFlag);
static int apndSleep(sqlite3_vfs*, int microseconds);
static int apndSync(sqlite3_file*, int flags);
static int apndTruncate(sqlite3_file*, sqlite3_int64 size);
static int apndUnfetch(sqlite3_file*, sqlite3_int64 iOfst, void *p);
static int apndUnlock(sqlite3_file*, int);
static int apndWrite(sqlite3_file*,const void*,int iAmt, sqlite3_int64 iOfst);
sqlite3ParserCTX_FETCH sqlite3ParserARG_STORE assert( yypParser->yytos!=0 );
void attachFunc( sqlite3_context *context, int NotUsed, sqlite3_value **argv ){
int binCollFunc( void *NotUsed, int nKey1, const void *pKey1, int nKey2, const void *pKey2 ){
void btreeParseCellPtr( MemPage *pPage, u8 *pCell, CellInfo *pInfo ){
void btreeParseCellPtrIndex( MemPage *pPage, u8 *pCell, CellInfo *pInfo ){
static void btreeParseCellPtrNoPayload( MemPage *pPage, u8 *pCell, CellInfo *pInfo ){
static int bytecodevtabBestIndex( sqlite3_vtab *tab, sqlite3_index_info *pIdxInfo ){
static int bytecodevtabClose(sqlite3_vtab_cursor *cur){
static int bytecodevtabColumn( sqlite3_vtab_cursor *cur, sqlite3_context *ctx, int i ){
static int bytecodevtabConnect( sqlite3 *db, void *pAux, int argc, const char *const*argv, sqlite3_vtab **ppVtab, char **pzErr ){
static int bytecodevtabDisconnect(sqlite3_vtab *pVtab){
static int bytecodevtabEof(sqlite3_vtab_cursor *cur){
static int bytecodevtabFilter( sqlite3_vtab_cursor *pVtabCursor, int idxNum, const char *idxStr, int argc, sqlite3_value **argv ){
static int bytecodevtabNext(sqlite3_vtab_cursor *cur){
static int bytecodevtabOpen(sqlite3_vtab *p, sqlite3_vtab_cursor **ppCursor){
static int bytecodevtabRowid(sqlite3_vtab_cursor *cur, sqlite_int64 *pRowid){
static u16 cellSizePtr(MemPage *pPage, u8 *pCell){
static u16 cellSizePtrIdxLeaf(MemPage *pPage, u8 *pCell){
static u16 cellSizePtrNoPayload(MemPage *pPage, u8 *pCell){
u16 cellSizePtrTableLeaf(MemPage *pPage, u8 *pCell){
static sqlite3_mutex *checkMutexAlloc(int iType){
static int checkMutexEnd(void){
static void checkMutexEnter(sqlite3_mutex *p){
static void checkMutexFree(sqlite3_mutex *p){
static void checkMutexLeave(sqlite3_mutex *p){
static int checkMutexNotheld(sqlite3_mutex *p){
static int checkMutexTry(sqlite3_mutex *p){
int codeCursorHintCheckExpr(Walker *pWalker, Expr *pExpr){
int codeCursorHintFixExpr(Walker *pWalker, Expr *pExpr){
int codeCursorHintIsOrFunction(Walker *pWalker, Expr *pExpr){
static int completionBestIndex( sqlite3_vtab *tab, sqlite3_index_info *pIdxInfo ){
static int completionClose(sqlite3_vtab_cursor *cur){
static int completionColumn( sqlite3_vtab_cursor *cur, sqlite3_context *ctx, int i ){
static int completionDisconnect(sqlite3_vtab *pVtab){
static int completionEof(sqlite3_vtab_cursor *cur){
static int completionFilter( sqlite3_vtab_cursor *pVtabCursor, int idxNum, const char *idxStr, int argc, sqlite3_value **argv ){
static int completionNext(sqlite3_vtab_cursor *cur){
static int completionOpen(sqlite3_vtab *p, sqlite3_vtab_cursor **ppCursor){
static int completionRowid(sqlite3_vtab_cursor *cur, sqlite_int64 *pRowid){
int convertCompoundSelectToSubquery(Walker *pWalker, Select *p){
static int dbdataBestIndex(sqlite3_vtab *tab, sqlite3_index_info *pIdx){
static int dbdataClose(sqlite3_vtab_cursor *pCursor){
static int dbdataColumn( sqlite3_vtab_cursor *pCursor, sqlite3_context *ctx, int i ){
static int dbdataConnect( sqlite3 *db, void *pAux, int argc, const char *const*argv, sqlite3_vtab **ppVtab, char **pzErr ){
static int dbdataDisconnect(sqlite3_vtab *pVtab){
static int dbdataEof(sqlite3_vtab_cursor *pCursor){
static int dbdataFilter( sqlite3_vtab_cursor *pCursor, int idxNum, const char *idxStr, int argc, sqlite3_value **argv ){
static int dbdataOpen(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor){
static int dbdataRowid(sqlite3_vtab_cursor *pCursor, sqlite_int64 *pRowid){
static int dbpageBegin(sqlite3_vtab *pVtab){
static int dbpageBestIndex(sqlite3_vtab *tab, sqlite3_index_info *pIdxInfo){
static int dbpageClose(sqlite3_vtab_cursor *pCursor){
static int dbpageColumn( sqlite3_vtab_cursor *pCursor, sqlite3_context *ctx, int i ){
static int dbpageDisconnect(sqlite3_vtab *pVtab){
static int dbpageEof(sqlite3_vtab_cursor *pCursor){
static int dbpageFilter( sqlite3_vtab_cursor *pCursor, int idxNum, const char *idxStr, int argc, sqlite3_value **argv ){
static int dbpageNext(sqlite3_vtab_cursor *pCursor){
static int dbpageOpen(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor){
static int dbpageRollbackTo(sqlite3_vtab *pVtab, int notUsed1){
static int dbpageRowid(sqlite3_vtab_cursor *pCursor, sqlite_int64 *pRowid){
static int dbpageSync(sqlite3_vtab *pVtab){
static int dbpageUpdate( sqlite3_vtab *pVtab, int argc, sqlite3_value **argv, sqlite_int64 *pRowid ){
static sqlite3_mutex *debugMutexAlloc(int id){
static int debugMutexEnd(void){
static void debugMutexEnter(sqlite3_mutex *pX){
static void debugMutexFree(sqlite3_mutex *pX){
static int debugMutexHeld(sqlite3_mutex *pX){
static int debugMutexInit(void){
static void debugMutexLeave(sqlite3_mutex *pX){
static int debugMutexNotheld(sqlite3_mutex *pX){
static int debugMutexTry(sqlite3_mutex *pX){
static void decimalAddFunc( sqlite3_context *context, int argc, sqlite3_value **argv ){
static void decimalCmpFunc( sqlite3_context *context, int argc, sqlite3_value **argv ){
static void decimalFunc( sqlite3_context *context, int argc, sqlite3_value **argv ){
static void decimalMulFunc( sqlite3_context *context, int argc, sqlite3_value **argv ){
static void decimalPow2Func( sqlite3_context *context, int argc, sqlite3_value **argv ){
static void decimalSubFunc( sqlite3_context *context, int argc, sqlite3_value **argv ){
static void detachFunc( sqlite3_context *context, int NotUsed, sqlite3_value **argv ){
int disallowAggregatesInOrderByCb(Walker *pWalker, Expr *pExpr){
static int expertBestIndex(sqlite3_vtab *pVtab, sqlite3_index_info *pIdxInfo){
static int expertClose(sqlite3_vtab_cursor *cur){
static int expertColumn(sqlite3_vtab_cursor *cur, sqlite3_context *ctx, int i){
static int expertConnect( sqlite3 *db, void *pAux, int argc, const char *const*argv, sqlite3_vtab **ppVtab, char **pzErr ){
static int expertDisconnect(sqlite3_vtab *pVtab){
static int expertEof(sqlite3_vtab_cursor *cur){
static int expertFilter( sqlite3_vtab_cursor *cur, int idxNum, const char *idxStr, int argc, sqlite3_value **argv ){
static int expertNext(sqlite3_vtab_cursor *cur){
static int expertOpen(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor){
static int expertRowid(sqlite3_vtab_cursor *cur, sqlite_int64 *pRowid){
static int expertUpdate( sqlite3_vtab *pVtab, int nData, sqlite3_value **azData, sqlite_int64 *pRowid ){
int exprColumnFlagUnion(Walker *pWalker, Expr *pExpr){
int exprIdxCover(Walker *pWalker, Expr *pExpr){
int exprNodeCanReturnSubtype(Walker *pWalker, Expr *pExpr){
static int exprNodeIsConstant(Walker *pWalker, Expr *pExpr){
int exprNodeIsConstantOrGroupBy(Walker *pWalker, Expr *pExpr){
int exprNodeIsDeterministic(Walker *pWalker, Expr *pExpr){
int exprRefToSrcList(Walker *pWalker, Expr *pExpr){
int exprSelectWalkTableConstant(Walker *pWalker, Select *pSelect){
int fixSelectCb(Walker *p, Select *pSelect){
static int fsdirBestIndex( sqlite3_vtab *tab, sqlite3_index_info *pIdxInfo ){
static int fsdirClose(sqlite3_vtab_cursor *cur){
static int fsdirColumn( sqlite3_vtab_cursor *cur, sqlite3_context *ctx, int i ){
static int fsdirConnect( sqlite3 *db, void *pAux, int argc, const char *const*argv, sqlite3_vtab **ppVtab, char **pzErr ){
static int fsdirDisconnect(sqlite3_vtab *pVtab){
static int fsdirEof(sqlite3_vtab_cursor *cur){
static int fsdirFilter( sqlite3_vtab_cursor *cur, int idxNum, const char *idxStr, int argc, sqlite3_value **argv ){
static int fsdirNext(sqlite3_vtab_cursor *cur){
static int fsdirOpen(sqlite3_vtab *p, sqlite3_vtab_cursor **ppCursor){
static int fsdirRowid(sqlite3_vtab_cursor *cur, sqlite_int64 *pRowid){
static int fts3BeginMethod(sqlite3_vtab *pVtab){
static int fts3BestIndexMethod(sqlite3_vtab *pVTab, sqlite3_index_info *pInfo){
static int fts3CloseMethod(sqlite3_vtab_cursor *pCursor){
static int fts3ColumnMethod( sqlite3_vtab_cursor *pCursor, sqlite3_context *pCtx, int iCol ){
static int fts3CommitMethod(sqlite3_vtab *pVtab){
static int fts3ConnectMethod( sqlite3 *db, void *pAux, int argc, const char * const *argv, sqlite3_vtab **ppVtab, char **pzErr ){
static int fts3CreateMethod( sqlite3 *db, void *pAux, int argc, const char * const *argv, sqlite3_vtab **ppVtab, char **pzErr ){
static int fts3DestroyMethod(sqlite3_vtab *pVtab){
static int fts3DisconnectMethod(sqlite3_vtab *pVtab){
static int fts3EofMethod(sqlite3_vtab_cursor *pCursor){
static int fts3FilterMethod( sqlite3_vtab_cursor *pCursor, int idxNum, const char *idxStr, int nVal, sqlite3_value **apVal ){
static int fts3FindFunctionMethod( sqlite3_vtab *pVtab, int nArg, const char *zName, void (**pxFunc)(sqlite3_context*,int,sqlite3_value**), void **ppArg ){
static int fts3IntegrityMethod( sqlite3_vtab *pVtab, const char *zSchema, const char *zTabname, int isQuick, char **pzErr ){
static int fts3NextMethod(sqlite3_vtab_cursor *pCursor){
static int fts3OpenMethod(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCsr){
static int fts3ReleaseMethod(sqlite3_vtab *pVtab, int iSavepoint){
static int fts3RenameMethod( sqlite3_vtab *pVtab, const char *zName ){
static int fts3RollbackMethod(sqlite3_vtab *pVtab){
static int fts3RollbackToMethod(sqlite3_vtab *pVtab, int iSavepoint){
static int fts3RowidMethod(sqlite3_vtab_cursor *pCursor, sqlite_int64 *pRowid){
static int fts3SavepointMethod(sqlite3_vtab *pVtab, int iSavepoint){
static int fts3ShadowName(const char *zName){
static int fts3SyncMethod(sqlite3_vtab *pVtab){
static int fts3UpdateMethod( sqlite3_vtab *pVtab, int nArg, sqlite3_value **apVal, sqlite_int64 *pRowid ){
static int fts3auxCloseMethod(sqlite3_vtab_cursor *pCursor){
static int fts3auxColumnMethod( sqlite3_vtab_cursor *pCursor, sqlite3_context *pCtx, int iCol ){
static int fts3auxDisconnectMethod(sqlite3_vtab *pVtab){
static int fts3auxEofMethod(sqlite3_vtab_cursor *pCursor){
static int fts3auxFilterMethod( sqlite3_vtab_cursor *pCursor, int idxNum, const char *idxStr, int nVal, sqlite3_value **apVal ){
static int fts3auxNextMethod(sqlite3_vtab_cursor *pCursor){
static int fts3auxOpenMethod(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCsr){
static int fts3auxRowidMethod( sqlite3_vtab_cursor *pCursor, sqlite_int64 *pRowid ){
static int fts3tokBestIndexMethod( sqlite3_vtab *pVTab, sqlite3_index_info *pInfo ){
static int fts3tokCloseMethod(sqlite3_vtab_cursor *pCursor){
static int fts3tokColumnMethod( sqlite3_vtab_cursor *pCursor, sqlite3_context *pCtx, int iCol ){
static int fts3tokDisconnectMethod(sqlite3_vtab *pVtab){
static int fts3tokEofMethod(sqlite3_vtab_cursor *pCursor){
static int fts3tokFilterMethod( sqlite3_vtab_cursor *pCursor, int idxNum, const char *idxStr, int nVal, sqlite3_value **apVal ){
static int fts3tokNextMethod(sqlite3_vtab_cursor *pCursor){
static int fts3tokOpenMethod(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCsr){
static int fts3tokRowidMethod( sqlite3_vtab_cursor *pCursor, sqlite_int64 *pRowid ){
static int fts5ApiColumnCount(Fts5Context *pCtx){
static int fts5ApiColumnLocale( Fts5Context *pCtx, int iCol, const char **pzLocale, int *pnLocale ){
static int fts5ApiColumnSize(Fts5Context *pCtx, int iCol, int *pnToken){
static int fts5ApiColumnText( Fts5Context *pCtx, int iCol, const char **pz, int *pn ){
static int fts5ApiColumnTotalSize( Fts5Context *pCtx, int iCol, sqlite3_int64 *pnToken ){
static void *fts5ApiGetAuxdata(Fts5Context *pCtx, int bClear){
static int fts5ApiInst( Fts5Context *pCtx, int iIdx, int *piPhrase, int *piCol, int *piOff ){
static int fts5ApiInstCount(Fts5Context *pCtx, int *pnInst){
static int fts5ApiInstToken( Fts5Context *pCtx, int iIdx, int iToken, const char **ppOut, int *pnOut ){
static int fts5ApiPhraseCount(Fts5Context *pCtx){
static int fts5ApiPhraseFirst( Fts5Context *pCtx, int iPhrase, Fts5PhraseIter *pIter, int *piCol, int *piOff ){
static int fts5ApiPhraseFirstColumn( Fts5Context *pCtx, int iPhrase, Fts5PhraseIter *pIter, int *piCol ){
static void fts5ApiPhraseNext( Fts5Context *pCtx, Fts5PhraseIter *pIter, int *piCol, int *piOff ){
static void fts5ApiPhraseNextColumn( Fts5Context *pCtx, Fts5PhraseIter *pIter, int *piCol ){
static int fts5ApiPhraseSize(Fts5Context *pCtx, int iPhrase){
static int fts5ApiQueryPhrase(Fts5Context*, int, void*, int(*)(const Fts5ExtensionApi*, Fts5Context*, void*) );
static int fts5ApiQueryToken( Fts5Context* pCtx, int iPhrase, int iToken, const char **ppOut, int *pnOut ){
static int fts5ApiRowCount(Fts5Context *pCtx, i64 *pnRow){
static sqlite3_int64 fts5ApiRowid(Fts5Context *pCtx){
static int fts5ApiSetAuxdata( Fts5Context *pCtx, void *pPtr, void(*xDelete)(void*), int *xDelete_signature, ){
static int fts5ApiTokenize( Fts5Context *pCtx, const char *pText, int nText, void *pUserData, int (*xToken)(void*, int, const char*, int, int, int), int *xToken_signature ){
static int fts5ApiTokenize_v2( Fts5Context *pCtx, const char *pText, int nText, const char *pLoc, int nLoc, void *pUserData, int (*xToken)(void*, int, const char*, int, int, int), int *xToken_signature ){
static void *fts5ApiUserData(Fts5Context *pCtx){
void fts5AppendPoslist(Fts5Index *p, u64 iDelta, Fts5Iter *pMulti, Fts5Buffer *pBuf){
void fts5AppendRowid(Fts5Index *p, u64 iDelta, Fts5Iter *pUnused, Fts5Buffer *pBuf){
static int fts5BeginMethod(sqlite3_vtab *pVtab){
static int fts5BestIndexMethod(sqlite3_vtab *pVTab, sqlite3_index_info *pInfo){
static int fts5CloseMethod(sqlite3_vtab_cursor *pCursor){
static int fts5ColumnMethod( sqlite3_vtab_cursor *pCursor, sqlite3_context *pCtx, int iCol ){
static int fts5CommitMethod(sqlite3_vtab *pVtab){
static int fts5ConnectMethod( sqlite3 *db, void *pAux, int argc, const char * const *argv, sqlite3_vtab **ppVtab, char **pzErr ){
static int fts5CreateMethod( sqlite3 *db, void *pAux, int argc, const char * const *argv, sqlite3_vtab **ppVtab, char **pzErr ){
int fts5CreateTokenizer(fts5_api *pApi, const char *zName, void *pUserData, fts5_tokenizer *pTokenizer, void (*xDestroy)(void *), int *xDestroy_signature){
int fts5CreateTokenizer_v2(fts5_api *pApi, const char *zName, void *pUserData, fts5_tokenizer_v2 *pTokenizer, void (*xDestroy)(void *), int *xDestroy_signature){
static int fts5DestroyMethod(sqlite3_vtab *pVtab){
static int fts5DisconnectMethod(sqlite3_vtab *pVtab){
static int fts5EofMethod(sqlite3_vtab_cursor *pCursor){
static int fts5ExprNodeNext_AND( Fts5Expr *pExpr, Fts5ExprNode *pNode, int bFromValid, i64 iFrom ){
static int fts5ExprNodeNext_NOT( Fts5Expr *pExpr, Fts5ExprNode *pNode, int bFromValid, i64 iFrom ){
static int fts5ExprNodeNext_OR( Fts5Expr *pExpr, Fts5ExprNode *pNode, int bFromValid, i64 iFrom ){
static int fts5ExprNodeNext_STRING( Fts5Expr *pExpr, Fts5ExprNode *pNode, int bFromValid, i64 iFrom ){
static int fts5ExprNodeNext_TERM( Fts5Expr *pExpr, Fts5ExprNode *pNode, int bFromValid, i64 iFrom ){
static int fts5FilterMethod( sqlite3_vtab_cursor *pCursor, int idxNum, const char *idxStr, int nVal, sqlite3_value **apVal ){
static int fts5FindFunctionMethod( sqlite3_vtab *pVtab, int nUnused, const char *zName, void (**pxFunc)(sqlite3_context*,int,sqlite3_value**), void **ppArg ){
int fts5FindTokenizer(fts5_api *pApi, const char *zName, void **ppUserData, fts5_tokenizer *pTokenizer){
int fts5FindTokenizer_v2(fts5_api *pApi, const char *zName, void **ppUserData, fts5_tokenizer_v2 **ppTokenizer){
static int fts5IntegrityMethod( sqlite3_vtab *pVtab, const char *zSchema, const char *zTabname, int isQuick, char **pzErr ){
static void fts5IterSetOutputs_Col(Fts5Iter *pIter, Fts5SegIter *pSeg){
static void fts5IterSetOutputs_Col100(Fts5Iter *pIter, Fts5SegIter *pSeg){
static void fts5IterSetOutputs_Full(Fts5Iter *pIter, Fts5SegIter *pSeg){
static void fts5IterSetOutputs_Nocolset(Fts5Iter *pIter, Fts5SegIter *pSeg){
static void fts5IterSetOutputs_None(Fts5Iter *pIter, Fts5SegIter *pSeg){
static void fts5IterSetOutputs_Noop(Fts5Iter *pUnused1, Fts5SegIter *pUnused2){
static void fts5IterSetOutputs_ZeroColset(Fts5Iter *pIter, Fts5SegIter *pSeg){
void fts5MergePrefixLists(Fts5Index *p, Fts5Buffer *p1, int nBuf, Fts5Buffer *aBuf){
void fts5MergeRowidLists(Fts5Index *p, Fts5Buffer *p1, int nBuf, Fts5Buffer *aBuf){
static int fts5NextMethod(sqlite3_vtab_cursor *pCursor){
static int fts5OpenMethod(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCsr){
static int fts5PorterCreate( void *pCtx, const char **azArg, int nArg, Fts5Tokenizer **ppOut ){
static void fts5PorterDelete(Fts5Tokenizer *pTok){
static int fts5PorterTokenize( Fts5Tokenizer *pTokenizer, void *pCtx, int flags, const char *pText, int nText, const char *pLoc, int nLoc, int (*xToken)(void*, int, const char*, int nToken, int iStart, int iEnd), int *xToken_signature ){
static int fts5ReleaseMethod(sqlite3_vtab *pVtab, int iSavepoint){
static int fts5RenameMethod( sqlite3_vtab *pVtab, const char *zName ){
static int fts5RollbackMethod(sqlite3_vtab *pVtab){
static int fts5RollbackToMethod(sqlite3_vtab *pVtab, int iSavepoint){
static int fts5RowidMethod(sqlite3_vtab_cursor *pCursor, sqlite_int64 *pRowid){
static int fts5SavepointMethod(sqlite3_vtab *pVtab, int iSavepoint){
static void fts5SegIterNext(Fts5Index*, Fts5SegIter*, int*);
static void fts5SegIterNext_None(Fts5Index*, Fts5SegIter*, int*);
static void fts5SegIterNext_Reverse(Fts5Index*, Fts5SegIter*, int*);
static int fts5ShadowName(const char *zName){
static int fts5SyncMethod(sqlite3_vtab *pVtab){
static int fts5UpdateMethod( sqlite3_vtab *pVtab, int nArg, sqlite3_value **apVal, sqlite_int64 *pRowid ){
int fts5V1toV2Tokenize(Fts5Tokenizer *pTok, void *pCtx, int flags, const char *pText, int nText, int (*xToken)(void *, int, const char *, int, int, int), int *xToken_signature){
int fts5V2toV1Tokenize(Fts5Tokenizer *pTok, void *pCtx, int flags, const char *pText, int nText, const char *pLocale, int nLocale, int (*xToken)(void *, int, const char *, int, int, int), int *xToken_signature){
static int fts5VocabBestIndexMethod( sqlite3_vtab *pUnused, sqlite3_index_info *pInfo ){
static int fts5VocabCloseMethod(sqlite3_vtab_cursor *pCursor){
static int fts5VocabColumnMethod( sqlite3_vtab_cursor *pCursor, sqlite3_context *pCtx, int iCol ){
static int fts5VocabConnectMethod( sqlite3 *db, void *pAux, int argc, const char * const *argv, sqlite3_vtab **ppVtab, char **pzErr ){
static int fts5VocabCreateMethod( sqlite3 *db, void *pAux, int argc, const char * const *argv, sqlite3_vtab **ppVtab, char **pzErr ){
static int fts5VocabDestroyMethod(sqlite3_vtab *pVtab){
static int fts5VocabDisconnectMethod(sqlite3_vtab *pVtab){
static int fts5VocabEofMethod(sqlite3_vtab_cursor *pCursor){
static int fts5VocabFilterMethod( sqlite3_vtab_cursor *pCursor, int idxNum, const char *zUnused, int nUnused, sqlite3_value **apVal ){
static int fts5VocabNextMethod(sqlite3_vtab_cursor *pCursor){
static int fts5VocabOpenMethod( sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCsr ){
static int fts5VocabRowidMethod( sqlite3_vtab_cursor *pCursor, sqlite_int64 *pRowid ){
int fts5VtoVCreate(void *pCtx, const char **azArg, int nArg, Fts5Tokenizer **ppOut){
void fts5VtoVDelete(Fts5Tokenizer *pTok){
static int fts5structBestIndexMethod( sqlite3_vtab *tab, sqlite3_index_info *pIdxInfo ){
static int fts5structCloseMethod(sqlite3_vtab_cursor *cur){
static int fts5structColumnMethod( sqlite3_vtab_cursor *cur, sqlite3_context *ctx, int i ){
static int fts5structConnectMethod( sqlite3 *db, void *pAux, int argc, const char *const*argv, sqlite3_vtab **ppVtab, char **pzErr ){
static int fts5structDisconnectMethod(sqlite3_vtab *pVtab){
static int fts5structEofMethod(sqlite3_vtab_cursor *cur){
static int fts5structFilterMethod( sqlite3_vtab_cursor *pVtabCursor, int idxNum, const char *idxStr, int argc, sqlite3_value **argv ){
static int fts5structNextMethod(sqlite3_vtab_cursor *cur){
static int fts5structOpenMethod(sqlite3_vtab *p, sqlite3_vtab_cursor **ppCsr){
static int fts5structRowidMethod( sqlite3_vtab_cursor *cur, sqlite_int64 *piRowid ){
int gatherSelectWindowsSelectCallback(Walker *pWalker, Select *p){
static void geopolyAreaFunc( sqlite3_context *context, int argc, sqlite3_value **argv ){
static void geopolyBBoxFunc( sqlite3_context *context, int argc, sqlite3_value **argv ){
static int geopolyBestIndex(sqlite3_vtab *tab, sqlite3_index_info *pIdxInfo){
static void geopolyBlobFunc( sqlite3_context *context, int argc, sqlite3_value **argv ){
static void geopolyCcwFunc( sqlite3_context *context, int argc, sqlite3_value **argv ){
static int geopolyColumn(sqlite3_vtab_cursor *cur, sqlite3_context *ctx, int i){
static int geopolyConnect( sqlite3 *db, void *pAux, int argc, const char *const*argv, sqlite3_vtab **ppVtab, char **pzErr ){
static void geopolyContainsPointFunc( sqlite3_context *context, int argc, sqlite3_value **argv ){
static int geopolyCreate( sqlite3 *db, void *pAux, int argc, const char *const*argv, sqlite3_vtab **ppVtab, char **pzErr ){
static void geopolyDebugFunc( sqlite3_context *context, int argc, sqlite3_value **argv ){
static int geopolyFilter( sqlite3_vtab_cursor *pVtabCursor, int idxNum, const char *idxStr, int argc, sqlite3_value **argv ){
static int geopolyFindFunction( sqlite3_vtab *pVtab, int nArg, const char *zName, void (**pxFunc)(sqlite3_context*,int,sqlite3_value**), void **ppArg ){
static void geopolyJsonFunc( sqlite3_context *context, int argc, sqlite3_value **argv ){
static void geopolyOverlapFunc( sqlite3_context *context, int argc, sqlite3_value **argv ){
static void geopolyRegularFunc( sqlite3_context *context, int argc, sqlite3_value **argv ){
static void geopolySvgFunc( sqlite3_context *context, int argc, sqlite3_value **argv ){
static int geopolyUpdate( sqlite3_vtab *pVtab, int nData, sqlite3_value **aData, sqlite_int64 *pRowid ){
static void geopolyWithinFunc( sqlite3_context *context, int argc, sqlite3_value **argv ){
static void geopolyXformFunc( sqlite3_context *context, int argc, sqlite3_value **argv ){
int getPageError(Pager*,Pgno,DbPage**,int);
int getPageNormal( Pager *pPager, Pgno pgno, DbPage **ppPage, int flags ){
static void icuCaseFunc16(sqlite3_context *p, int nArg, sqlite3_value **apArg){
static int icuClose(sqlite3_tokenizer_cursor *pCursor){
static int icuCreate( int argc, const char * const *argv, sqlite3_tokenizer **ppTokenizer ){
static int icuDestroy(sqlite3_tokenizer *pTokenizer){
static void icuLikeFunc( sqlite3_context *context, int argc, sqlite3_value **argv ){
static void icuLoadCollation( sqlite3_context *p, int nArg, sqlite3_value **apArg ){
static int icuNext( sqlite3_tokenizer_cursor *pCursor, const char **ppToken, int *pnBytes, int *piStartOffset, int *piEndOffset, int *piPosition ){
static int icuOpen( sqlite3_tokenizer *pTokenizer, const char *zInput, int nInput, sqlite3_tokenizer_cursor **ppCursor ){
static void icuRegexpFunc(sqlite3_context *p, int nArg, sqlite3_value **apArg){
static void ieee754func_to_blob( sqlite3_context *context, int argc, sqlite3_value **argv ){
static void ieee754inc( sqlite3_context *context, int argc, sqlite3_value **argv ){
int impliesNotNullRow(Walker *pWalker, Expr *pExpr){
typedef int (*sqlite3_callback)(void*,int,char**, char**);
static int jsonEachBestIndex( sqlite3_vtab *tab, sqlite3_index_info *pIdxInfo ){
static int jsonEachClose(sqlite3_vtab_cursor *cur){
static int jsonEachColumn( sqlite3_vtab_cursor *cur, sqlite3_context *ctx, int iColumn ){
static int jsonEachConnect( sqlite3 *db, void *pAux, int argc, const char *const*argv, sqlite3_vtab **ppVtab, char **pzErr ){
static int jsonEachDisconnect(sqlite3_vtab *pVtab){
static int jsonEachEof(sqlite3_vtab_cursor *cur){
static int jsonEachFilter( sqlite3_vtab_cursor *cur, int idxNum, const char *idxStr, int argc, sqlite3_value **argv ){
static int jsonEachNext(sqlite3_vtab_cursor *cur){
static int jsonEachOpen(sqlite3_vtab *p, sqlite3_vtab_cursor **ppCursor){
static int jsonEachRowid(sqlite3_vtab_cursor *cur, sqlite_int64 *pRowid){
static int kvstorageDelete(const char*, const char *zKey);
static int kvstorageRead(const char*, const char *zKey, char *zBuf, int nBuf);
static int kvstorageWrite( const char *zClass, const char *zKey, const char *zData ){
static int kvvfsAccess(sqlite3_vfs*, const char *zName, int flags, int *);
static int kvvfsCheckReservedLock(sqlite3_file*, int *pResOut);
static int kvvfsClose(sqlite3_file *pProtoFile){
static int kvvfsCurrentTime(sqlite3_vfs*, double*);
static int kvvfsCurrentTimeInt64(sqlite3_vfs*, sqlite3_int64*);
static int kvvfsDelete(sqlite3_vfs*, const char *zName, int syncDir);
static int kvvfsDeviceCharacteristics(sqlite3_file*);
static void *kvvfsDlOpen(sqlite3_vfs*, const char *zFilename);
static int kvvfsFileControlDb(sqlite3_file*, int op, void *pArg);
static int kvvfsFileControlJrnl(sqlite3_file*, int op, void *pArg);
static int kvvfsFileSizeDb(sqlite3_file*, sqlite3_int64 *pSize);
static int kvvfsFileSizeJrnl(sqlite3_file*, sqlite3_int64 *pSize);
static int kvvfsFullPathname(sqlite3_vfs*, const char *zName, int, char *zOut);
static int kvvfsLock(sqlite3_file*, int);
static int kvvfsOpen(sqlite3_vfs*, const char *, sqlite3_file*, int , int *);
static int kvvfsRandomness(sqlite3_vfs*, int nByte, char *zOut);
static int kvvfsReadDb(sqlite3_file*, void*, int iAmt, sqlite3_int64 iOfst);
static int kvvfsReadJrnl(sqlite3_file*, void*, int iAmt, sqlite3_int64 iOfst);
static int kvvfsSectorSize(sqlite3_file*);
static int kvvfsSleep(sqlite3_vfs*, int microseconds);
static int kvvfsSyncDb(sqlite3_file*, int flags);
static int kvvfsSyncJrnl(sqlite3_file*, int flags);
static int kvvfsTruncateDb(sqlite3_file*, sqlite3_int64 size);
static int kvvfsTruncateJrnl(sqlite3_file*, sqlite3_int64 size);
static int kvvfsUnlock(sqlite3_file*, int);
static int kvvfsWriteDb(sqlite3_file*,const void*,int iAmt, sqlite3_int64);
static int kvvfsWriteJrnl(sqlite3_file*,const void*,int iAmt, sqlite3_int64);
179 #define TK_ASTERISK 180 #define TK_SPAN 181 #define TK_ERROR 182 #define TK_QNUMBER 183 #define TK_SPACE 184 #define TK_COMMENT 185 #define TK_ILLEGAL 186 #include <stdio.h> #include <stdlib.h> #include <string.h> #include <assert.h> #include <stddef.h> #include <ctype.h> #ifdef SQLITE_INLINE_MEMCPY # define memcpy(D,S,N) {
static int memdbAccess(sqlite3_vfs*, const char *zName, int flags, int *);
static int memdbClose(sqlite3_file*);
static int memdbCurrentTimeInt64(sqlite3_vfs*, sqlite3_int64*);
static void memdbDlClose(sqlite3_vfs*, void*);
static void memdbDlError(sqlite3_vfs*, int nByte, char *zErrMsg);
static void *memdbDlOpen(sqlite3_vfs*, const char *zFilename);
static int memdbFetch( sqlite3_file *pFile, sqlite3_int64 iOfst, int iAmt, void **pp ){
static int memdbFileSize(sqlite3_file*, sqlite3_int64 *pSize);
static int memdbFullPathname(sqlite3_vfs*, const char *zName, int, char *zOut);
static int memdbGetLastError(sqlite3_vfs*, int, char *);
static int memdbLock(sqlite3_file*, int);
static int memdbOpen(sqlite3_vfs*, const char *, sqlite3_file*, int , int *);
static int memdbRandomness(sqlite3_vfs*, int nByte, char *zOut);
static int memdbRead(sqlite3_file*, void*, int iAmt, sqlite3_int64 iOfst);
static int memdbSleep(sqlite3_vfs*, int microseconds);
static int memdbSync(sqlite3_file*, int flags);
static int memdbTruncate(sqlite3_file*, sqlite3_int64 size);
static int memdbUnfetch(sqlite3_file *pFile, sqlite3_int64 iOfst, void *pPage){
static int memdbUnlock(sqlite3_file*, int);
static int memdbWrite(sqlite3_file*,const void*,int iAmt, sqlite3_int64 iOfst);
int memjrnlClose(sqlite3_file *pJfd){
int memjrnlFileSize(sqlite3_file *pJfd, sqlite_int64 *pSize){
int memjrnlRead(sqlite3_file *pJfd, void *zBuf, int iAmt, sqlite_int64 iOfst){
int memjrnlSync(sqlite3_file *pJfd, int flags){
int memjrnlTruncate(sqlite3_file *pJfd, sqlite_int64 size);
int memjrnlWrite( sqlite3_file *pJfd, const void *zBuf, int iAmt, sqlite_int64 iOfst ){
static void memsys3Free(void *pPrior){
static int memsys3Init(void *NotUsed){
static void *memsys3Malloc(int nBytes){
static void *memsys3Realloc(void *pPrior, int nBytes){
static int memsys3Roundup(int n){
static void memsys3Shutdown(void *NotUsed){
static int memsys3Size(void *p){
static void memsys5Free(void *pPrior){
static int memsys5Init(void *NotUsed){
static void *memsys5Malloc(int nBytes){
static void *memsys5Realloc(void *pPrior, int nBytes){
static int memsys5Roundup(int n){
static void memsys5Shutdown(void *NotUsed){
static int memsys5Size(void *p){
static void memtraceFree(void *p){
static int memtraceInit(void *p){
static void *memtraceMalloc(int n){
static void *memtraceRealloc(void *p, int n){
static int memtraceRoundup(int n){
static void memtraceShutdown(void *p){
static int memtraceSize(void *p){
static int nolockLock(sqlite3_file *NotUsed, int NotUsed2){
sqlite3_mutex *noopMutexAlloc(int id){
int noopMutexEnd(void);
void noopMutexEnter(sqlite3_mutex *p);
void noopMutexFree(sqlite3_mutex *p);
int noopMutexInit(void);
void noopMutexLeave(sqlite3_mutex *p);
int noopMutexTry(sqlite3_mutex *p);
pLaf->pFindRoot = recoverPrepare(p, p->dbOut, "WITH RECURSIVE p(pgno) AS (" " SELECT ?" " UNION" " SELECT parent FROM recovery.map AS m, p WHERE m.pgno=p.pgno" ") " "SELECT p.pgno FROM p, recovery.map m WHERE m.pgno=p.pgno " " AND m.parent IS NULL" );
void pcache1Cachesize(sqlite3_pcache *p , int nMax);
sqlite3_pcache *pcache1Create(int szPage , int szExtra , int bPurgeable);
void pcache1Destroy(sqlite3_pcache *p);
sqlite3_pcache_page *pcache1Fetch(sqlite3_pcache *p , unsigned int iKey , int createFlag);
int pcache1Init(void *NotUsed);
int pcache1Pagecount(sqlite3_pcache *p);
void pcache1Rekey(sqlite3_pcache *p , sqlite3_pcache_page *pPg , unsigned int iOld , unsigned int iNew);
void pcache1Shrink(sqlite3_pcache *p);
void pcache1Shutdown(void *NotUsed);
void pcache1Truncate(sqlite3_pcache *p , unsigned int iLimit);
void pcache1Unpin(sqlite3_pcache *p , sqlite3_pcache_page *pPg , int reuseUnlikely);
static void pcachetraceCachesize(sqlite3_pcache *p, int nCachesize){
static sqlite3_pcache *pcachetraceCreate(int szPage, int szExtra, int bPurge){
static void pcachetraceDestroy(sqlite3_pcache *p){
static sqlite3_pcache_page *pcachetraceFetch( sqlite3_pcache *p, unsigned key, int crFg ){
static int pcachetraceInit(void *pArg){
static int pcachetracePagecount(sqlite3_pcache *p){
static void pcachetraceRekey( sqlite3_pcache *p, sqlite3_pcache_page *pPg, unsigned oldKey, unsigned newKey ){
static void pcachetraceShrink(sqlite3_pcache *p){
static void pcachetraceShutdown(void *pArg){
static void pcachetraceTruncate(sqlite3_pcache *p, unsigned n){
static void pcachetraceUnpin( sqlite3_pcache *p, sqlite3_pcache_page *pPg, int bDiscard ){
static int porterClose(sqlite3_tokenizer_cursor *pCursor){
static int porterCreate( int argc, const char * const *argv, sqlite3_tokenizer **ppTokenizer ){
static int porterDestroy(sqlite3_tokenizer *pTokenizer){
static int porterOpen( sqlite3_tokenizer *pTokenizer, const char *zInput, int nInput, sqlite3_tokenizer_cursor **ppCursor ){
static int pragmaVtabBestIndex(sqlite3_vtab *tab, sqlite3_index_info *pIdxInfo){
static int pragmaVtabClose(sqlite3_vtab_cursor *cur){
static int pragmaVtabColumn( sqlite3_vtab_cursor *pVtabCursor, sqlite3_context *ctx, int i ){
static int pragmaVtabConnect( sqlite3 *db, void *pAux, int argc, const char *const*argv, sqlite3_vtab **ppVtab, char **pzErr ){
static int pragmaVtabDisconnect(sqlite3_vtab *pVtab){
static int pragmaVtabEof(sqlite3_vtab_cursor *pVtabCursor){
static int pragmaVtabFilter( sqlite3_vtab_cursor *pVtabCursor, int idxNum, const char *idxStr, int argc, sqlite3_value **argv ){
static int pragmaVtabNext(sqlite3_vtab_cursor *pVtabCursor){
static int pragmaVtabOpen(sqlite3_vtab *pVtab, sqlite3_vtab_cursor **ppCursor){
static int pragmaVtabRowid(sqlite3_vtab_cursor *pVtabCursor, sqlite_int64 *p){
int propagateConstantExprRewrite(Walker *pWalker, Expr *pExpr){
sqlite3_mutex *pthreadMutexAlloc(int iType){
static int pthreadMutexEnd(void){
void pthreadMutexEnter(sqlite3_mutex *p){
void pthreadMutexFree(sqlite3_mutex *p){
int pthreadMutexInit(void){
void pthreadMutexLeave(sqlite3_mutex *p){
static int pthreadMutexNotheld(sqlite3_mutex *p){
static int pthreadMutexTry(sqlite3_mutex *p){
static int rbuVfsAccess( sqlite3_vfs *pVfs, const char *zPath, int flags, int *pResOut ){
static int rbuVfsCheckReservedLock(sqlite3_file *pFile, int *pResOut){
static int rbuVfsClose(sqlite3_file *pFile){
static int rbuVfsCurrentTime(sqlite3_vfs *pVfs, double *pTimeOut){
static int rbuVfsDelete(sqlite3_vfs *pVfs, const char *zPath, int dirSync){
static int rbuVfsDeviceCharacteristics(sqlite3_file *pFile){
static void rbuVfsDlClose(sqlite3_vfs *pVfs, void *pHandle){
static void rbuVfsDlError(sqlite3_vfs *pVfs, int nByte, char *zErrMsg){
static int rbuVfsFileControl(sqlite3_file *pFile, int op, void *pArg){
static int rbuVfsFileSize(sqlite3_file *pFile, sqlite_int64 *pSize){
static int rbuVfsFullPathname( sqlite3_vfs *pVfs, const char *zPath, int nOut, char *zOut ){
static int rbuVfsGetLastError(sqlite3_vfs *pVfs, int a, char *b){
static int rbuVfsLock(sqlite3_file *pFile, int eLock){
static int rbuVfsOpen( sqlite3_vfs *pVfs, const char *zName, sqlite3_file *pFile, int flags, int *pOutFlags ){
static int rbuVfsRead( sqlite3_file *pFile, void *zBuf, int iAmt, sqlite_int64 iOfst ){
static int rbuVfsSectorSize(sqlite3_file *pFile){
static void rbuVfsShmBarrier(sqlite3_file *pFile){
static int rbuVfsShmLock(sqlite3_file *pFile, int ofst, int n, int flags){
static int rbuVfsShmMap( sqlite3_file *pFile, int iRegion, int szRegion, int isWrite, void volatile **pp ){
static int rbuVfsShmUnmap(sqlite3_file *pFile, int delFlag){
static int rbuVfsSleep(sqlite3_vfs *pVfs, int nMicro){
static int rbuVfsSync(sqlite3_file *pFile, int flags){
static int rbuVfsTruncate(sqlite3_file *pFile, sqlite_int64 size){
static int rbuVfsUnlock(sqlite3_file *pFile, int eLock){
static int rbuVfsWrite( sqlite3_file *pFile, const void *zBuf, int iAmt, sqlite_int64 iOfst ){
static unsigned re_next_char(ReInput *p){
static unsigned re_next_char_nocase(ReInput *p){
static void recoverEscapeCrlf( sqlite3_context *context, int argc, sqlite3_value **argv ){
static void recoverGetPage( sqlite3_context *pCtx, int nArg, sqlite3_value **apArg ){
static void recoverPageIsUsed( sqlite3_context *pCtx, int nArg, sqlite3_value **apArg ){
static void recoverReadI32( sqlite3_context *context, int argc, sqlite3_value **argv ){
static int recoverVfsCheckReservedLock(sqlite3_file*, int *pResOut);
static int recoverVfsClose(sqlite3_file*);
static int recoverVfsDeviceCharacteristics(sqlite3_file*);
static int recoverVfsFetch(sqlite3_file*, sqlite3_int64, int, void**);
static int recoverVfsFileControl(sqlite3_file*, int op, void *pArg);
static int recoverVfsFileSize(sqlite3_file*, sqlite3_int64 *pSize);
static int recoverVfsLock(sqlite3_file*, int);
static int recoverVfsRead(sqlite3_file*, void*, int iAmt, sqlite3_int64 iOfst);
static int recoverVfsSectorSize(sqlite3_file*);
static void recoverVfsShmBarrier(sqlite3_file*);
static int recoverVfsShmLock(sqlite3_file*, int offset, int n, int flags);
static int recoverVfsShmMap(sqlite3_file*, int, int, int, void volatile**);
static int recoverVfsShmUnmap(sqlite3_file*, int deleteFlag);
static int recoverVfsSync(sqlite3_file*, int flags);
static int recoverVfsTruncate(sqlite3_file*, sqlite3_int64 size);
static int recoverVfsUnfetch(sqlite3_file *pFd, sqlite3_int64 iOff, void *p);
static int recoverVfsUnlock(sqlite3_file*, int);
static int recoverVfsWrite(sqlite3_file*, const void*, int, sqlite3_int64);
int renameColumnExprCb(Walker *pWalker, Expr *pExpr){
int renameColumnSelectCb(Walker *pWalker, Select *p){
int renameQuotefixExprCb(Walker *pWalker, Expr *pExpr){
int renameTableExprCb(Walker *pWalker, Expr *pExpr){
int renameTableSelectCb(Walker *pWalker, Select *pSelect){
int renameUnmapExprCb(Walker *pWalker, Expr *pExpr){
int renameUnmapSelectCb(Walker *pWalker, Select *p){
int renumberCursorsCb(Walker *pWalker, Expr *pExpr){
int resolveExprStep(Walker *pWalker, Expr *pExpr){
int resolveSelectStep(Walker *pWalker, Select *p){
static int rtreeBeginTransaction(sqlite3_vtab *pVtab){
static int rtreeBestIndex(sqlite3_vtab *tab, sqlite3_index_info *pIdxInfo){
static int rtreeClose(sqlite3_vtab_cursor *cur){
static int rtreeColumn(sqlite3_vtab_cursor *cur, sqlite3_context *ctx, int i){
static int rtreeConnect( sqlite3 *db, void *pAux, int argc, const char *const*argv, sqlite3_vtab **ppVtab, char **pzErr ){
static int rtreeCreate( sqlite3 *db, void *pAux, int argc, const char *const*argv, sqlite3_vtab **ppVtab, char **pzErr ){
static int rtreeDestroy(sqlite3_vtab *pVtab){
static int rtreeDisconnect(sqlite3_vtab *pVtab){
static int rtreeEndTransaction(sqlite3_vtab *pVtab){
static int rtreeEof(sqlite3_vtab_cursor *cur){
static int rtreeFilter( sqlite3_vtab_cursor *pVtabCursor, int idxNum, const char *idxStr, int argc, sqlite3_value **argv ){
static int rtreeIntegrity(sqlite3_vtab*, const char*, const char*, int, char**);
static int rtreeNext(sqlite3_vtab_cursor *pVtabCursor){
static int rtreeOpen(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor){
static int rtreeRename(sqlite3_vtab *pVtab, const char *zNewName){
static int rtreeRollback(sqlite3_vtab *pVtab){
static int rtreeRowid(sqlite3_vtab_cursor *pVtabCursor, sqlite_int64 *pRowid){
static int rtreeSavepoint(sqlite3_vtab *pVtab, int iSavepoint){
static int rtreeShadowName(const char *zName){
static int rtreeUpdate( sqlite3_vtab *pVtab, int nData, sqlite3_value **aData, sqlite_int64 *pRowid ){
int selectCheckOnClausesSelect(Walker *pWalker, Select *pSelect){
int selectExpander(Walker *pWalker, Select *p){
int selectRefEnter(Walker *pWalker, Select *pSelect){
void selectRefLeave(Walker *pWalker, Select *pSelect){
static int selectWindowRewriteExprCb(Walker *pWalker, Expr *pExpr){
int selectWindowRewriteSelectCb(Walker *pWalker, Select *pSelect){
static int seriesBestIndex( sqlite3_vtab *pVTab, sqlite3_index_info *pIdxInfo ){
static int seriesClose(sqlite3_vtab_cursor *cur){
static int seriesColumn( sqlite3_vtab_cursor *cur, sqlite3_context *ctx, int i ){
static int seriesConnect( sqlite3 *db, void *pUnused, int argcUnused, const char *const*argvUnused, sqlite3_vtab **ppVtab, char **pzErrUnused ){
static int seriesDisconnect(sqlite3_vtab *pVtab){
static int seriesEof(sqlite3_vtab_cursor *cur){
static int seriesFilter( sqlite3_vtab_cursor *pVtabCursor, int idxNum, const char *idxStrUnused, int argc, sqlite3_value **argv ){
static int seriesNext(sqlite3_vtab_cursor *cur){
static int seriesOpen(sqlite3_vtab *pUnused, sqlite3_vtab_cursor **ppCursor){
int sessionDiffCount(void *pCtx){
int sessionDiffDepth(void *pCtx){
int sessionDiffNew(void *pCtx, int iVal, sqlite3_value **ppVal){
int sessionDiffOld(void *pCtx, int iVal, sqlite3_value **ppVal){
int sessionPreupdateCount(void *pCtx){
int sessionPreupdateDepth(void *pCtx){
int sessionPreupdateNew(void *pCtx, int iVal, sqlite3_value **ppVal){
int sessionPreupdateOld(void *pCtx, int iVal, sqlite3_value **ppVal){
int sessionStat1Count(void *pCtx){
int sessionStat1Depth(void *pCtx){
int sessionStat1New(void *pCtx, int iCol, sqlite3_value **ppVal){
int sessionStat1Old(void *pCtx, int iCol, sqlite3_value **ppVal){
static int simpleClose(sqlite3_tokenizer_cursor *pCursor){
static int simpleCreate( int argc, const char * const *argv, sqlite3_tokenizer **ppTokenizer ){
static int simpleDestroy(sqlite3_tokenizer *pTokenizer){
static int simpleNext( sqlite3_tokenizer_cursor *pCursor, const char **ppToken, int *pnBytes, int *piStartOffset, int *piEndOffset, int *piPosition ){
static int simpleOpen( sqlite3_tokenizer *pTokenizer, const char *pInput, int nBytes, sqlite3_tokenizer_cursor **ppCursor ){
void sqlite3ErrorMsg(Parse*, const char*, ...);
int sqlite3ExprWalkNoop(Walker*, Expr*);
char *sqlite3MPrintf(sqlite3*,const char*, ...);
void sqlite3MemFree(void *pPrior);
int sqlite3MemInit(void *NotUsed);
void *sqlite3MemMalloc(int nByte);
void *sqlite3MemRealloc(void *pPrior , int nByte);
int sqlite3MemRoundup(int n);
void sqlite3MemSetDefault(void);
void sqlite3MemShutdown(void *NotUsed);
int sqlite3MemSize(void *p);
void sqlite3NoopDestructor(void*);
void sqlite3PCacheSetDefault(void){
void sqlite3RCStrUnref(void*);
int sqlite3ReturningSubqueryCorrelated(Walker *pWalker, Select *pSelect){
int sqlite3ReturningSubqueryVarSelect(Walker *NotUsed, Expr *pExpr){
void sqlite3RowSetDelete(void*);
int sqlite3SelectWalkFail(Walker*, Select*);
int sqlite3SelectWalkNoop(Walker*, Select*);
void sqlite3WalkWinDefnDummyCallback(Walker*,Select*);
void sqlite3WalkerDepthDecrease(Walker*,Select*);
int sqlite3WalkerDepthIncrease(Walker*,Select*);
int sqlite3WindowExtraAggFuncDepth(Walker *pWalker, Expr *pExpr){
SQLITE_API void *sqlite3_aggregate_context(sqlite3_context*, int nBytes);
TE_UTF16LE 2 #define SQLITE_UTF16BE 3 #define SQLITE_UTF16 4 #define SQLITE_ANY 5 #define SQLITE_UTF16_ALIGNED 8 #define SQLITE_DETERMINISTIC 0x000000800 #define SQLITE_DIRECTONLY 0x000080000 #define SQLITE_SUBTYPE 0x000100000 #define SQLITE_INNOCUOUS 0x000200000 #define SQLITE_RESULT_SUBTYPE 0x001000000 #define SQLITE_SELFORDER1 0x002000000 #ifndef SQLITE_OMIT_DEPRECATED SQLITE_API SQLITE_DEPRECATED int sqlite3_aggregate_count(sqlite3_context*);
SQLITE_API int sqlite3_auto_extension(void(*xEntryPoint)(void), int *xEntryPoint_signature);
SQLITE_API int sqlite3_backup_finish(sqlite3_backup *p);
SQLITE_API sqlite3_backup *sqlite3_backup_init( sqlite3 *pDest, const char *zDestName, sqlite3 *pSource, const char *zSourceName );
SQLITE_API int sqlite3_backup_pagecount(sqlite3_backup *p);
SQLITE_API int sqlite3_backup_remaining(sqlite3_backup *p);
SQLITE_API int sqlite3_backup_step(sqlite3_backup *p, int nPage);
SQLITE_API int sqlite3_bind_blob(sqlite3_stmt*, int, const void*, int n, void(*)(void*), int*);
SQLITE_API int sqlite3_bind_blob64(sqlite3_stmt*, int, const void*, sqlite3_uint64, void(*)(void*), int*);
SQLITE_API int sqlite3_bind_double(sqlite3_stmt*, int, double);
SQLITE_API int sqlite3_bind_int(sqlite3_stmt*, int, int);
SQLITE_API int sqlite3_bind_int64(sqlite3_stmt*, int, sqlite3_int64);
SQLITE_API int sqlite3_bind_null(sqlite3_stmt*, int);
SQLITE_API int sqlite3_bind_parameter_count(sqlite3_stmt*);
SQLITE_API int sqlite3_bind_parameter_index(sqlite3_stmt*, const char *zName);
SQLITE_API const char *sqlite3_bind_parameter_name(sqlite3_stmt*, int);
SQLITE_API int sqlite3_bind_pointer(sqlite3_stmt*, int, void*, const char*,void(*)(void*), int*);
SQLITE_API int sqlite3_bind_text(sqlite3_stmt*,int,const char*,int,void(*)(void*), int*);
SQLITE_API int sqlite3_bind_text16(sqlite3_stmt*, int, const void*, int, void(*)(void*), int*);
SQLITE_API int sqlite3_bind_text64(sqlite3_stmt*, int, const char*, sqlite3_uint64, void(*)(void*), int*, unsigned char encoding);
SQLITE_API int sqlite3_bind_value(sqlite3_stmt*, int, const sqlite3_value*);
SQLITE_API int sqlite3_bind_zeroblob(sqlite3_stmt*, int, int n);
SQLITE_API int sqlite3_bind_zeroblob64(sqlite3_stmt*, int, sqlite3_uint64);
SQLITE_API int sqlite3_blob_bytes(sqlite3_blob *);
SQLITE_API int sqlite3_blob_close(sqlite3_blob *);
SQLITE_API int sqlite3_blob_open( sqlite3*, const char *zDb, const char *zTable, const char *zColumn, sqlite3_int64 iRow, int flags, sqlite3_blob **ppBlob );
SQLITE_API int sqlite3_blob_read(sqlite3_blob *, void *Z, int N, int iOffset);
SQLITE_API int sqlite3_blob_reopen(sqlite3_blob *, sqlite3_int64);
SQLITE_API int sqlite3_blob_write(sqlite3_blob *, const void *z, int n, int iOffset);
SQLITE_API int sqlite3_busy_handler(sqlite3*,int(*)(void*,int), int*, void*);
SQLITE_API int sqlite3_busy_timeout(sqlite3*, int ms);
SQLITE_API int sqlite3_cancel_auto_extension(void(*xEntryPoint)(void), int *xEntryPoint_signature);
SQLITE_API int sqlite3_changes(sqlite3*);
SQLITE_API sqlite3_int64 sqlite3_changes64(sqlite3*);
SQLITE_API int sqlite3_clear_bindings(sqlite3_stmt*);
SQLITE_API int sqlite3_close(sqlite3 *db){
SQLITE_API int sqlite3_close_v2(sqlite3*);
SQLITE_API int sqlite3_collation_needed( sqlite3*, void*, void(*)(void*,sqlite3*,int eTextRep,const char*), int* );
SQLITE_API int sqlite3_collation_needed16( sqlite3*, void*, void(*)(void*,sqlite3*,int eTextRep,const void*), int* );
SQLITE_API const void *sqlite3_column_blob(sqlite3_stmt *pStmt, int i){
SQLITE_API int sqlite3_column_bytes(sqlite3_stmt*, int iCol);
SQLITE_API int sqlite3_column_bytes16(sqlite3_stmt*, int iCol);
SQLITE_API int sqlite3_column_count(sqlite3_stmt *pStmt);
SQLITE_API const char *sqlite3_column_database_name(sqlite3_stmt*,int);
SQLITE_API const void *sqlite3_column_database_name16(sqlite3_stmt*,int);
SQLITE_API const char *sqlite3_column_decltype(sqlite3_stmt*,int);
SQLITE_API const void *sqlite3_column_decltype16(sqlite3_stmt*,int);
SQLITE_API double sqlite3_column_double(sqlite3_stmt*, int iCol);
SQLITE_API int sqlite3_column_int(sqlite3_stmt*, int iCol);
SQLITE_API sqlite3_int64 sqlite3_column_int64(sqlite3_stmt*, int iCol);
SQLITE_API const char *sqlite3_column_name(sqlite3_stmt*, int N);
SQLITE_API const void *sqlite3_column_name16(sqlite3_stmt*, int N);
SQLITE_API const char *sqlite3_column_origin_name(sqlite3_stmt*,int);
SQLITE_API const void *sqlite3_column_origin_name16(sqlite3_stmt*,int);
SQLITE_API const char *sqlite3_column_table_name(sqlite3_stmt*,int);
SQLITE_API const void *sqlite3_column_table_name16(sqlite3_stmt*,int);
SQLITE_API const unsigned char *sqlite3_column_text(sqlite3_stmt*, int iCol);
SQLITE_API const void *sqlite3_column_text16(sqlite3_stmt*, int iCol);
SQLITE_API int sqlite3_column_type(sqlite3_stmt*, int iCol);
SQLITE_API sqlite3_value *sqlite3_column_value(sqlite3_stmt*, int iCol);
SQLITE_API void *sqlite3_commit_hook(sqlite3*, int(*)(void*), void*);
SQLITE_API const char *sqlite3_compileoption_get(int N);
SQLITE_API int sqlite3_complete(const char *sql);
SQLITE_API int sqlite3_complete16(const void *sql);
endif " -memtrace trace all memory allocations and deallocations\n" " -mmap N default mmap size set to N\n" #ifdef SQLITE_ENABLE_MULTIPLEX " -multiplex enable the multiplexor VFS\n" #endif " -newline SEP set output row separator. Default: '\\n'\n" " -nofollow refuse to open symbolic links to database files\n" " -nonce STRING set the safe-mode escape nonce\n" " -no-rowid-in-view Disable rowid-in-view using sqlite3_config()\n" " -nullvalue TEXT set text string for NULL values. Default ''\n" " -pagecache SIZE N use N slots of SZ bytes each for page cache memory\n" " -pcachetrace trace all page cache operations\n" " -quote set output mode to 'quote'\n" " -readonly open the database read-only\n" " -safe enable safe-mode\n" " -separator SEP set output column separator. Default: '|'\n" #ifdef SQLITE_ENABLE_SORTER_REFERENCES " -sorterref SIZE sorter references threshold size\n" #endif " -stats print memory stats before each finalize\n" " -table set output mode to 'table'\n" " -tabs set output mode to 'tabs'\n" " -unsafe-testing allow unsafe commands and modes for testing\n" " -version show SQLite version\n" " -vfs NAME use NAME as the default VFS\n" " -vfstrace enable tracing of all VFS calls\n" #ifdef SQLITE_HAVE_ZLIB " -zip open the file as a ZIP Archive\n" #endif ;
SQLITE_API sqlite3 *sqlite3_context_db_handle(sqlite3_context*);
SQLITE_API int sqlite3_create_collation( sqlite3*, const char *zName, int eTextRep, void *pArg, int(*xCompare)(void*,int,const void*,int,const void*), int *xCompare_signature );
SQLITE_API int sqlite3_create_collation16( sqlite3*, const void *zName, int eTextRep, void *pArg, int(*xCompare)(void*,int,const void*,int,const void*), int *xCompare_signature );
SQLITE_API int sqlite3_create_collation_v2( sqlite3*, const char *zName, int eTextRep, void *pArg, int(*xCompare)(void*,int,const void*,int,const void*), int *xCompare_signature, void(*xDestroy)(void*), int *xDestroy_signature );
SQLITE_API sqlite3_filename sqlite3_create_filename( const char *zDatabase, const char *zJournal, const char *zWal, int nParam, const char **azParam );
SQLITE_API int sqlite3_create_function( sqlite3 *db, const char *zFunctionName, int nArg, int eTextRep, void *pApp, void (*xFunc)(sqlite3_context*,int,sqlite3_value**), int *xFunc_signature, void (*xStep)(sqlite3_context*,int,sqlite3_value**), int *xStep_signature, void (*xFinal)(sqlite3_context*), int *xFinal_signature );
SQLITE_API int sqlite3_create_function16( sqlite3 *db, const void *zFunctionName, int nArg, int eTextRep, void *pApp, void (*xFunc)(sqlite3_context*,int,sqlite3_value**), int *xFunc_signature, void (*xStep)(sqlite3_context*,int,sqlite3_value**), int *xStep_signature, void (*xFinal)(sqlite3_context*), int *xFinal_signature );
SQLITE_API int sqlite3_create_function_v2( sqlite3 *db, const char *zFunctionName, int nArg, int eTextRep, void *pApp, void (*xFunc)(sqlite3_context*,int,sqlite3_value**), int *xFunc_signature, void (*xStep)(sqlite3_context*,int,sqlite3_value**), int *xStep_signature, void (*xFinal)(sqlite3_context*), int *xFinal_signature, void(*xDestroy)(void*), int *xDestroy_signature );
NSTRAINT_LIKE 65 #define SQLITE_INDEX_CONSTRAINT_GLOB 66 #define SQLITE_INDEX_CONSTRAINT_REGEXP 67 #define SQLITE_INDEX_CONSTRAINT_NE 68 #define SQLITE_INDEX_CONSTRAINT_ISNOT 69 #define SQLITE_INDEX_CONSTRAINT_ISNOTNULL 70 #define SQLITE_INDEX_CONSTRAINT_ISNULL 71 #define SQLITE_INDEX_CONSTRAINT_IS 72 #define SQLITE_INDEX_CONSTRAINT_LIMIT 73 #define SQLITE_INDEX_CONSTRAINT_OFFSET 74 #define SQLITE_INDEX_CONSTRAINT_FUNCTION 150 SQLITE_API int sqlite3_create_module( sqlite3 *db, const char *zName, const sqlite3_module *p, void *pClientData );
SQLITE_API int sqlite3_create_module_v2( sqlite3 *db, const char *zName, const sqlite3_module *p, void *pClientData, void(*xDestroy)(void*), int *xDestroy_signature );
SQLITE_API int sqlite3_create_window_function( sqlite3 *db, const char *zFunctionName, int nArg, int eTextRep, void *pApp, void (*xStep)(sqlite3_context*,int,sqlite3_value**), int *xStep_signature, void (*xFinal)(sqlite3_context*), int *xFinal_signature, void (*xValue)(sqlite3_context*), int *xValue_signature, void (*xInverse)(sqlite3_context*,int,sqlite3_value**), int *xInverse_signature, void(*xDestroy)(void*), int *xDestroy_signature );
SQLITE_API int sqlite3_data_count(sqlite3_stmt *pStmt);
SQLITE_API sqlite3_file *sqlite3_database_file_object(const char*);
SQLITE_API int sqlite3_db_cacheflush(sqlite3*);
Show number of rows changed by SQL", #ifndef SQLITE_SHELL_FIDDLE ".check GLOB Fail if output since .testcase does not match", ".clone NEWDB Clone data into NEWDB from the existing database", #endif ".connection [close] [#] Open or close an auxiliary database connection", ".crlf ?on|off? Whether or not to use \\r\\n line endings", ".databases List names and files of attached databases", ".dbconfig ?op? ?val? List or change sqlite3_db_config() options", #if SQLITE_SHELL_HAVE_RECOVER ".dbinfo ?DB? Show status information about the database", #endif ".dbtotxt Hex dump of the database file", ".dump ?OBJECTS? Render database content as SQL", " Options:", " --data-only Output only INSERT statements", " --newlines Allow unescaped newline characters in output", " --nosys Omit system tables (ex: \"sqlite_stat1\")", " --preserve-rowids Include ROWID values in the output", " OBJECTS is a LIKE pattern for tables, indexes, triggers or views to dump", " Additional LIKE patterns can be given in subsequent arguments", ".echo on|off Turn command echo on or off", ".eqp on|off|full|... Enable or disable automatic EXPLAIN QUERY PLAN", " Other Modes:", #ifdef SQLITE_DEBUG " test Show raw EXPLAIN QUERY PLAN output", " trace Like \"full\" but enable \"PRAGMA vdbe_trace\"", #endif " trigger Like \"full\" but also show trigger bytecode", #ifndef SQLITE_SHELL_FIDDLE ".excel Display the output of next command in spreadsheet", " --bom Put a UTF8 byte-order mark on intermediate file", #endif #ifndef SQLITE_SHELL_FIDDLE ".exit ?CODE? Exit this program with return-code CODE", #endif ".expert EXPERIMENTAL. Suggest indexes for queries", ".explain ?on|off|auto? Change the EXPLAIN formatting mode. Default: auto", ".filectrl CMD ... Run various sqlite3_file_control() operations", " --schema SCHEMA Use SCHEMA instead of \"main\"", " --help Show CMD details", ".fullschema ?--indent? Show schema and the content of sqlite_stat tables", ".headers on|off Turn display of headers on or off", ".help ?-all? ?PATTERN? Show help text for PATTERN", #ifndef SQLITE_SHELL_FIDDLE ".import FILE TABLE Import data from FILE into TABLE", " Options:", " --ascii Use \\037 and \\036 as column and row separators", " --csv Use , and \\n as column and row separators", " --skip N Skip the first N rows of input", " --schema S Target table to be S.TABLE", " -v \"Verbose\" - increase auxiliary output", " Notes:", " * If TABLE does not exist, it is created. The first row of input", " determines the column names.", " * If neither --csv or --ascii are used, the input mode is derived", " from the \".mode\" output mode", " * If FILE begins with \"|\" then it is a command that generates the", " input text.", #endif #ifndef SQLITE_OMIT_TEST_CONTROL ",imposter INDEX TABLE Create imposter table TABLE on index INDEX", #endif ".indexes ?TABLE? Show names of indexes", " If TABLE is specified, only show indexes for", " tables matching TABLE using the LIKE operator.", ".intck ?STEPS_PER_UNLOCK? Run an incremental integrity check on the db", #ifdef SQLITE_ENABLE_IOTRACE ",iotrace FILE Enable I/O diagnostic logging to FILE", #endif ".limit ?LIMIT? ?VAL? Display or change the value of an SQLITE_LIMIT", ".lint OPTIONS Report potential schema issues.", " Options:", " fkey-indexes Find missing foreign key indexes", #if !defined(SQLITE_OMIT_LOAD_EXTENSION) && !defined(SQLITE_SHELL_FIDDLE) ".load FILE ?ENTRY? Load an extension library", #endif #if !defined(SQLITE_SHELL_FIDDLE) ".log FILE|on|off Turn logging on or off. FILE can be stderr/stdout", #else ".log on|off Turn logging on or off.", #endif ".mode ?MODE? ?OPTIONS? Set output mode", " MODE is one of:", " ascii Columns/rows delimited by 0x1F and 0x1E", " box Tables using unicode box-drawing characters", " csv Comma-separated values", " column Output in columns. (See .width)", " html HTML <table> code", " insert SQL insert statements for TABLE", " json Results in a JSON array", " line One value per line", " list Values delimited by \"|\"", " markdown Markdown table format", " qbox Shorthand for \"box --wrap 60 --quote\"", " quote Escape answers as for SQL", " table ASCII-art table", " tabs Tab-separated values", " tcl TCL list elements", " OPTIONS: (for columnar modes or insert mode):", " --escape T ctrl-char escape;
SQLITE_API sqlite3_filename sqlite3_db_filename(sqlite3 *db, const char *zDbName);
SQLITE_API sqlite3 *sqlite3_db_handle(sqlite3_stmt*);
4 #define SQLITE_MUTEX_STATIC_PRNG 5 #define SQLITE_MUTEX_STATIC_LRU 6 #define SQLITE_MUTEX_STATIC_LRU2 7 #define SQLITE_MUTEX_STATIC_PMEM 7 #define SQLITE_MUTEX_STATIC_APP1 8 #define SQLITE_MUTEX_STATIC_APP2 9 #define SQLITE_MUTEX_STATIC_APP3 10 #define SQLITE_MUTEX_STATIC_VFS1 11 #define SQLITE_MUTEX_STATIC_VFS2 12 #define SQLITE_MUTEX_STATIC_VFS3 13 #define SQLITE_MUTEX_STATIC_MASTER 2 SQLITE_API sqlite3_mutex *sqlite3_db_mutex(sqlite3*);
SQLITE_API int sqlite3_db_readonly(sqlite3 *db, const char *zDbName);
SQLITE_API int sqlite3_db_release_memory(sqlite3*);
SQLITE_API int sqlite3_db_status( sqlite3 *db, int op, int *pCurrent, int *pHighwater, int resetFlag ){
SQLITE_API int sqlite3_declare_vtab(sqlite3*, const char *zSQL);
SQLITE_API int sqlite3_drop_modules( sqlite3 *db, const char **azKeep );
SQLITE_API int sqlite3_enable_shared_cache(int);
SQLITE_API int sqlite3_errcode(sqlite3 *db);
SQLITE_API const char *sqlite3_errmsg(sqlite3*);
SQLITE_API const void *sqlite3_errmsg16(sqlite3*);
SQLITE_API const char *sqlite3_errstr(int);
SQLITE_API int sqlite3_exec( sqlite3*, const char *sql, int (*callback)(void*,int,char**,char**), int *callback_signature, void *, char **errmsg );
SQLITE_API char *sqlite3_expanded_sql(sqlite3_stmt *pStmt);
SQLITE_API SQLITE_DEPRECATED int sqlite3_expired(sqlite3_stmt*);
SQLITE_API int sqlite3_extended_errcode(sqlite3 *db);
1014 #define SQLITE_DBCONFIG_ENABLE_VIEW 1015 #define SQLITE_DBCONFIG_LEGACY_FILE_FORMAT 1016 #define SQLITE_DBCONFIG_TRUSTED_SCHEMA 1017 #define SQLITE_DBCONFIG_STMT_SCANSTATUS 1018 #define SQLITE_DBCONFIG_REVERSE_SCANORDER 1019 #define SQLITE_DBCONFIG_ENABLE_ATTACH_CREATE 1020 #define SQLITE_DBCONFIG_ENABLE_ATTACH_WRITE 1021 #define SQLITE_DBCONFIG_ENABLE_COMMENTS 1022 #define SQLITE_DBCONFIG_MAX 1022 SQLITE_API int sqlite3_extended_result_codes(sqlite3*, int onoff);
code", #ifndef SQLITE_SHELL_FIDDLE ".excel Display the output of next command in spreadsheet", " --bom Put a UTF8 byte-order mark on intermediate file", #endif #ifndef SQLITE_SHELL_FIDDLE ".exit ?CODE? Exit this program with return-code CODE", #endif ".expert EXPERIMENTAL. Suggest indexes for queries", ".explain ?on|off|auto? Change the EXPLAIN formatting mode. Default: auto", ".filectrl CMD ... Run various sqlite3_file_control() operations", " --schema SCHEMA Use SCHEMA instead of \"main\"", " --help Show CMD details", ".fullschema ?--indent? Show schema and the content of sqlite_stat tables", ".headers on|off Turn display of headers on or off", ".help ?-all? ?PATTERN? Show help text for PATTERN", #ifndef SQLITE_SHELL_FIDDLE ".import FILE TABLE Import data from FILE into TABLE", " Options:", " --ascii Use \\037 and \\036 as column and row separators", " --csv Use , and \\n as column and row separators", " --skip N Skip the first N rows of input", " --schema S Target table to be S.TABLE", " -v \"Verbose\" - increase auxiliary output", " Notes:", " * If TABLE does not exist, it is created. The first row of input", " determines the column names.", " * If neither --csv or --ascii are used, the input mode is derived", " from the \".mode\" output mode", " * If FILE begins with \"|\" then it is a command that generates the", " input text.", #endif #ifndef SQLITE_OMIT_TEST_CONTROL ",imposter INDEX TABLE Create imposter table TABLE on index INDEX", #endif ".indexes ?TABLE? Show names of indexes", " If TABLE is specified, only show indexes for", " tables matching TABLE using the LIKE operator.", ".intck ?STEPS_PER_UNLOCK? Run an incremental integrity check on the db", #ifdef SQLITE_ENABLE_IOTRACE ",iotrace FILE Enable I/O diagnostic logging to FILE", #endif ".limit ?LIMIT? ?VAL? Display or change the value of an SQLITE_LIMIT", ".lint OPTIONS Report potential schema issues.", " Options:", " fkey-indexes Find missing foreign key indexes", #if !defined(SQLITE_OMIT_LOAD_EXTENSION) && !defined(SQLITE_SHELL_FIDDLE) ".load FILE ?ENTRY? Load an extension library", #endif #if !defined(SQLITE_SHELL_FIDDLE) ".log FILE|on|off Turn logging on or off. FILE can be stderr/stdout", #else ".log on|off Turn logging on or off.", #endif ".mode ?MODE? ?OPTIONS? Set output mode", " MODE is one of:", " ascii Columns/rows delimited by 0x1F and 0x1E", " box Tables using unicode box-drawing characters", " csv Comma-separated values", " column Output in columns. (See .width)", " html HTML <table> code", " insert SQL insert statements for TABLE", " json Results in a JSON array", " line One value per line", " list Values delimited by \"|\"", " markdown Markdown table format", " qbox Shorthand for \"box --wrap 60 --quote\"", " quote Escape answers as for SQL", " table ASCII-art table", " tabs Tab-separated values", " tcl TCL list elements", " OPTIONS: (for columnar modes or insert mode):", " --escape T ctrl-char escape;
SQLITE_API const char *sqlite3_filename_database(sqlite3_filename);
SQLITE_API const char *sqlite3_filename_journal(sqlite3_filename);
SQLITE_API const char *sqlite3_filename_wal(sqlite3_filename);
SQLITE_API int sqlite3_finalize(sqlite3_stmt *pStmt);
SQLITE_API void sqlite3_free(void*);
SQLITE_API void sqlite3_free_filename(sqlite3_filename);
SQLITE_API void sqlite3_free_table(char **result);
SQLITE_API void *sqlite3_get_auxdata(sqlite3_context*, int N);
SQLITE_API int sqlite3_get_table( sqlite3 *db, const char *zSql, char ***pazResult, int *pnRow, int *pnColumn, char **pzErrMsg ){
SQLITE_API sqlite3_int64 sqlite3_hard_heap_limit64(sqlite3_int64 N);
SQLITE_API void sqlite3_interrupt(sqlite3*);
SQLITE_API int sqlite3_keyword_check(const char*,int);
COVERAGE 26 #define SQLITE_TESTCTRL_RESULT_INTREAL 27 #define SQLITE_TESTCTRL_PRNG_SEED 28 #define SQLITE_TESTCTRL_EXTRA_SCHEMA_CHECKS 29 #define SQLITE_TESTCTRL_SEEK_COUNT 30 #define SQLITE_TESTCTRL_TRACEFLAGS 31 #define SQLITE_TESTCTRL_TUNE 32 #define SQLITE_TESTCTRL_LOGEST 33 #define SQLITE_TESTCTRL_USELONGDOUBLE 34 #define SQLITE_TESTCTRL_LAST 34 SQLITE_API int sqlite3_keyword_count(void);
SQLITE_API int sqlite3_keyword_name(int,const char**,int*);
SQLITE_API sqlite3_int64 sqlite3_last_insert_rowid(sqlite3*);
SQLITE_API const char *sqlite3_libversion(void);
SQLITE_API int sqlite3_libversion_number(void);
SQLITE_API int sqlite3_limit(sqlite3*, int id, int newVal);
SQLITE_API int sqlite3_load_extension( sqlite3 *db, const char *zFile, const char *zProc, char **pzErrMsg );
SQLITE_API void sqlite3_log(int iErrCode, const char *zFormat, ...);
SQLITE_API void *sqlite3_malloc(int);
SQLITE_API void *sqlite3_malloc64(sqlite3_uint64);
SQLITE_API sqlite3_int64 sqlite3_memory_highwater(int resetFlag);
SQLITE_API sqlite3_int64 sqlite3_memory_used(void);
SQLITE_API char *sqlite3_mprintf(const char*,...);
SQLITE_API sqlite3_uint64 sqlite3_msize(void*);
SQLITE_API sqlite3_mutex *sqlite3_mutex_alloc(int);
SQLITE_API void sqlite3_mutex_enter(sqlite3_mutex*);
SQLITE_API void sqlite3_mutex_free(sqlite3_mutex*);
SQLITE_API void sqlite3_mutex_leave(sqlite3_mutex*);
SQLITE_API int sqlite3_mutex_try(sqlite3_mutex*);
SQLITE_API sqlite3_stmt *sqlite3_next_stmt(sqlite3 *pDb, sqlite3_stmt *pStmt){
SQLITE_API int sqlite3_open( const char *filename, sqlite3 **ppDb );
SQLITE_API int sqlite3_open16( const void *filename, sqlite3 **ppDb );
SQLITE_API int sqlite3_open_v2( const char *filename, sqlite3 **ppDb, int flags, const char *zVfs );
SQLITE_API int sqlite3_overload_function(sqlite3*, const char *zFuncName, int nArg);
FUNCTION_ARG 6 #define SQLITE_LIMIT_ATTACHED 7 #define SQLITE_LIMIT_LIKE_PATTERN_LENGTH 8 #define SQLITE_LIMIT_VARIABLE_NUMBER 9 #define SQLITE_LIMIT_TRIGGER_DEPTH 10 #define SQLITE_LIMIT_WORKER_THREADS 11 #define SQLITE_PREPARE_PERSISTENT 0x01 #define SQLITE_PREPARE_NORMALIZE 0x02 #define SQLITE_PREPARE_NO_VTAB 0x04 #define SQLITE_PREPARE_DONT_LOG 0x10 SQLITE_API int sqlite3_prepare( sqlite3 *db, const char *zSql, int nByte, sqlite3_stmt **ppStmt, const char **pzTail );
SQLITE_API int sqlite3_prepare16( sqlite3 *db, const void *zSql, int nByte, sqlite3_stmt **ppStmt, const void **pzTail );
SQLITE_API int sqlite3_prepare16_v2( sqlite3 *db, const void *zSql, int nByte, sqlite3_stmt **ppStmt, const void **pzTail );
SQLITE_API int sqlite3_prepare16_v3( sqlite3 *db, const void *zSql, int nByte, unsigned int prepFlags, sqlite3_stmt **ppStmt, const void **pzTail );
SQLITE_API int sqlite3_prepare_v2( sqlite3 *db, const char *zSql, int nByte, sqlite3_stmt **ppStmt, const char **pzTail );
SQLITE_API int sqlite3_prepare_v3( sqlite3 *db, const char *zSql, int nByte, unsigned int prepFlags, sqlite3_stmt **ppStmt, const char **pzTail );
SQLITE_API SQLITE_DEPRECATED void *sqlite3_profile(sqlite3*, void(*xProfile)(void*,const char*,sqlite3_uint64), void*);
SQLITE_API void sqlite3_progress_handler(sqlite3*, int, int(*)(void*), int*, void*);
SQLITE_API void sqlite3_randomness(int N, void *P);
SQLITE_API void *sqlite3_realloc(void*, int);
SQLITE_API void *sqlite3_realloc64(void*, sqlite3_uint64);
SQLITE_API int sqlite3_release_memory(int);
SQLITE_API int sqlite3_reset(sqlite3_stmt *pStmt);
SQLITE_API void sqlite3_reset_auto_extension(void);
SQLITE_API void sqlite3_result_blob( sqlite3_context *pCtx, const void *z, int n, void (*xDel)(void *), int *xDel_signature ){
SQLITE_API void sqlite3_result_blob64(sqlite3_context*,const void*, sqlite3_uint64,void(*)(void*), int*);
SQLITE_API void sqlite3_result_double(sqlite3_context*, double);
SQLITE_API void sqlite3_result_error(sqlite3_context*, const char*, int);
SQLITE_API void sqlite3_result_error16(sqlite3_context*, const void*, int);
SQLITE_API void sqlite3_result_error_code(sqlite3_context*, int);
SQLITE_API void sqlite3_result_error_nomem(sqlite3_context*);
SQLITE_API void sqlite3_result_error_toobig(sqlite3_context*);
SQLITE_API void sqlite3_result_int(sqlite3_context*, int);
SQLITE_API void sqlite3_result_int64(sqlite3_context*, sqlite3_int64);
SQLITE_API void sqlite3_result_null(sqlite3_context*);
SQLITE_API void sqlite3_result_pointer(sqlite3_context*, void*,const char*,void(*)(void*), int*);
SQLITE_API void sqlite3_result_subtype(sqlite3_context*,unsigned int);
SQLITE_API void sqlite3_result_text(sqlite3_context*, const char*, int, void(*)(void*), int*);
SQLITE_API void sqlite3_result_text16(sqlite3_context*, const void*, int, void(*)(void*), int*);
SQLITE_API void sqlite3_result_text16be(sqlite3_context*, const void*, int,void(*)(void*), int*);
SQLITE_API void sqlite3_result_text16le(sqlite3_context*, const void*, int,void(*)(void*), int*);
SQLITE_API void sqlite3_result_text64(sqlite3_context*, const char*,sqlite3_uint64, void(*)(void*), int*, unsigned char encoding);
SQLITE_API void sqlite3_result_value(sqlite3_context*, sqlite3_value*);
SQLITE_API void sqlite3_result_zeroblob(sqlite3_context*, int n);
SQLITE_API int sqlite3_result_zeroblob64(sqlite3_context*, sqlite3_uint64 n);
SQLITE_API void *sqlite3_rollback_hook(sqlite3*, void(*)(void *), void*);
SQLITE_API int sqlite3_set_authorizer( sqlite3*, int (*xAuth)(void*,int,const char*,const char*,const char*,const char*), int *xAuth_signature, void *pUserData );
SQLITE_API void sqlite3_set_auxdata(sqlite3_context*, int N, void*, void (*)(void*), int*);
SQLITE_API void sqlite3_set_last_insert_rowid(sqlite3*,sqlite3_int64);
SQLITE_API int sqlite3_sleep(int ms){
SQLITE_API char *sqlite3_snprintf(int,char*,const char*, ...);
SQLITE_API SQLITE_DEPRECATED void sqlite3_soft_heap_limit(int N);
SQLITE_API sqlite3_int64 sqlite3_soft_heap_limit64(sqlite3_int64 N);
SQLITE_API const char *sqlite3_sourceid(void);
SQLITE_API const char *sqlite3_sql(sqlite3_stmt *pStmt);
SQLITE_API int sqlite3_status(int op, int *pCurrent, int *pHighwater, int resetFlag);
SQLITE_API int sqlite3_status64( int op, sqlite3_int64 *pCurrent, sqlite3_int64 *pHighwater, int resetFlag );
SQLITE_API int sqlite3_step(sqlite3_stmt*);
SQLITE_API int sqlite3_stmt_busy(sqlite3_stmt*);
SQLITE_API int sqlite3_stmt_isexplain(sqlite3_stmt *pStmt);
SQLITE_API int sqlite3_stmt_readonly(sqlite3_stmt *pStmt){
3 #define SQLITE_DBSTATUS_LOOKASIDE_HIT 4 #define SQLITE_DBSTATUS_LOOKASIDE_MISS_SIZE 5 #define SQLITE_DBSTATUS_LOOKASIDE_MISS_FULL 6 #define SQLITE_DBSTATUS_CACHE_HIT 7 #define SQLITE_DBSTATUS_CACHE_MISS 8 #define SQLITE_DBSTATUS_CACHE_WRITE 9 #define SQLITE_DBSTATUS_DEFERRED_FKS 10 #define SQLITE_DBSTATUS_CACHE_USED_SHARED 11 #define SQLITE_DBSTATUS_CACHE_SPILL 12 #define SQLITE_DBSTATUS_MAX 12 SQLITE_API int sqlite3_stmt_status(sqlite3_stmt*, int op,int resetFlg);
SQLITE_API void sqlite3_str_append(sqlite3_str*, const char *zIn, int N);
SQLITE_API void sqlite3_str_appendall(sqlite3_str*, const char *zIn);
SQLITE_API void sqlite3_str_appendchar(sqlite3_str*, int N, char C);
SQLITE_API void sqlite3_str_appendf(sqlite3_str*, const char *zFormat, ...);
SQLITE_API int sqlite3_str_errcode(sqlite3_str*);
SQLITE_API char *sqlite3_str_finish(sqlite3_str*);
SQLITE_API int sqlite3_str_length(sqlite3_str*);
SQLITE_API sqlite3_str *sqlite3_str_new(sqlite3*);
SQLITE_API void sqlite3_str_reset(sqlite3_str*);
SQLITE_API char *sqlite3_str_value(sqlite3_str*);
SQLITE_API void sqlite3_str_vappendf(sqlite3_str*, const char *zFormat, va_list);
SQLITE_API int sqlite3_strglob(const char *zGlob, const char *zStr);
SQLITE_API int sqlite3_stricmp(const char *, const char *);
SQLITE_API int sqlite3_strlike(const char *zGlob, const char *zStr, unsigned int cEsc);
SQLITE_API int sqlite3_strnicmp(const char *, const char *, int);
SQLITE_API int sqlite3_system_errno(sqlite3 *db){
SQLITE_API int sqlite3_table_column_metadata( sqlite3 *db, const char *zDbName, const char *zTableName, const char *zColumnName, char const **pzDataType, char const **pzCollSeq, int *pNotNull, int *pPrimaryKey, int *pAutoinc );
, " stmt Show statement stats", " vmstep Show the virtual machine step count only", #if !defined(SQLITE_NOHAVE_SYSTEM) && !defined(SQLITE_SHELL_FIDDLE) ".system CMD ARGS... Run CMD ARGS... in a system shell", #endif ".tables ?TABLE? List names of tables matching LIKE pattern TABLE", #ifndef SQLITE_SHELL_FIDDLE ",testcase NAME Begin redirecting output to 'testcase-out.txt'", #endif ",testctrl CMD ... Run various sqlite3_test_control() operations", " Run \".testctrl\" with no arguments for details", ".timeout MS Try opening locked tables for MS milliseconds", ".timer on|off Turn SQL timer on or off", #ifndef SQLITE_OMIT_TRACE ".trace ?OPTIONS? Output each SQL statement as it is run", " FILE Send output to FILE", " stdout Send output to stdout", " stderr Send output to stderr", " off Disable tracing", " --expanded Expand query parameters", #ifdef SQLITE_ENABLE_NORMALIZE " --normalized Normal the SQL statements", #endif " --plain Show SQL as it is input", " --stmt Trace statement execution (SQLITE_TRACE_STMT)", " --profile Profile statements (SQLITE_TRACE_PROFILE)", " --row Trace each row (SQLITE_TRACE_ROW)", " --close Trace connection close (SQLITE_TRACE_CLOSE)", #endif #ifdef SQLITE_DEBUG ".unmodule NAME ... Unregister virtual table modules", " --allexcept Unregister everything except those named", #endif ".version Show source, library and compiler versions", ".vfsinfo ?AUX? Information about the top-level VFS", ".vfslist List all available VFSes", ".vfsname ?AUX? Print the name of the VFS stack", ".width NUM1 NUM2 ... Set minimum column widths for columnar output", " Negative values right-justify", #ifndef SQLITE_SHELL_FIDDLE ".www Display output of the next command in web browser", " --plain Show results as text/plain, not as HTML", #endif };
SQLITE_API SQLITE_DEPRECATED void sqlite3_thread_cleanup(void);
SQLITE_API int sqlite3_threadsafe(void){
SQLITE_API int sqlite3_total_changes(sqlite3*);
SQLITE_API sqlite3_int64 sqlite3_total_changes64(sqlite3*);
SQLITE_API SQLITE_DEPRECATED int sqlite3_transfer_bindings(sqlite3_stmt*, sqlite3_stmt*);
SQLITE_API int sqlite3_txn_state(sqlite3*,const char *zSchema);
SQLITE_API int sqlite3_unlock_notify( sqlite3 *pBlocked, void (*xNotify)(void **apArg, int nArg), int *xNotify_signature, void *pNotifyArg );
SQLITE_API void *sqlite3_update_hook( sqlite3*, void(*)(void *,int ,char const *,char const *,sqlite3_int64), void* );
SQLITE_API int sqlite3_uri_boolean(sqlite3_filename z, const char *zParam, int bDefault);
SQLITE_API sqlite3_int64 sqlite3_uri_int64(sqlite3_filename, const char*, sqlite3_int64);
SQLITE_API const char *sqlite3_uri_key(sqlite3_filename z, int N);
SQLITE_API const char *sqlite3_uri_parameter(sqlite3_filename z, const char *zParam);
SQLITE_API void *sqlite3_user_data(sqlite3_context*);
SQLITE_API const void *sqlite3_value_blob(sqlite3_value *pVal){
SQLITE_API int sqlite3_value_bytes(sqlite3_value*);
SQLITE_API int sqlite3_value_bytes16(sqlite3_value*);
SQLITE_API double sqlite3_value_double(sqlite3_value*);
SQLITE_API sqlite3_value *sqlite3_value_dup(const sqlite3_value*);
SQLITE_API void sqlite3_value_free(sqlite3_value*);
SQLITE_API int sqlite3_value_frombind(sqlite3_value*);
SQLITE_API int sqlite3_value_int(sqlite3_value*);
SQLITE_API sqlite3_int64 sqlite3_value_int64(sqlite3_value*);
SQLITE_API int sqlite3_value_nochange(sqlite3_value*);
SQLITE_API int sqlite3_value_numeric_type(sqlite3_value*);
SQLITE_API void *sqlite3_value_pointer(sqlite3_value*, const char*);
SQLITE_API unsigned int sqlite3_value_subtype(sqlite3_value*);
SQLITE_API const unsigned char *sqlite3_value_text(sqlite3_value*);
SQLITE_API const void *sqlite3_value_text16(sqlite3_value*);
SQLITE_API const void *sqlite3_value_text16be(sqlite3_value*);
SQLITE_API const void *sqlite3_value_text16le(sqlite3_value*);
SQLITE_API int sqlite3_value_type(sqlite3_value*);
SQLITE_API sqlite3_vfs *sqlite3_vfs_find(const char *zVfsName);
SQLITE_API int sqlite3_vfs_register(sqlite3_vfs*, int makeDflt);
SQLITE_API int sqlite3_vfs_unregister(sqlite3_vfs*);
SQLITE_API char *sqlite3_vmprintf(const char*, va_list);
SQLITE_API char *sqlite3_vsnprintf(int,char*,const char*, va_list);
SQLITE_API const char *sqlite3_vtab_collation(sqlite3_index_info*,int);
SQLITE_API int sqlite3_vtab_config(sqlite3 *db, int op, ...){
SQLITE_API int sqlite3_vtab_nochange(sqlite3_context*);
SQLITE_API int sqlite3_vtab_on_conflict(sqlite3 *db){
SQLITE_API int sqlite3_wal_autocheckpoint(sqlite3 *db, int N);
SQLITE_API int sqlite3_wal_checkpoint(sqlite3 *db, const char *zDb);
SQLITE_API int sqlite3_wal_checkpoint_v2( sqlite3 *db, const char *zDb, int eMode, int *pnLog, int *pnCkpt );
SQLITE_API void *sqlite3_wal_hook( sqlite3*, int(*)(void *,sqlite3*,const char*,int), void* );
SQLITE_API int sqlite3session_attach( sqlite3_session *pSession, const char *zTab );
static int statBestIndex(sqlite3_vtab *tab, sqlite3_index_info *pIdxInfo){
static int statClose(sqlite3_vtab_cursor *pCursor){
static int statColumn( sqlite3_vtab_cursor *pCursor, sqlite3_context *ctx, int i ){
static int statDisconnect(sqlite3_vtab *pVtab){
static int statEof(sqlite3_vtab_cursor *pCursor){
static int statFilter( sqlite3_vtab_cursor *pCursor, int idxNum, const char *idxStr, int argc, sqlite3_value **argv ){
void statInit( sqlite3_context *context, int argc, sqlite3_value **argv ){
static int statNext(sqlite3_vtab_cursor *pCursor){
static int statOpen(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor){
static int statRowid(sqlite3_vtab_cursor *pCursor, sqlite_int64 *pRowid){
static int stmtBestIndex( sqlite3_vtab *tab, sqlite3_index_info *pIdxInfo ){
static int stmtClose(sqlite3_vtab_cursor *cur){
static int stmtColumn( sqlite3_vtab_cursor *cur, sqlite3_context *ctx, int i ){
static int stmtConnect( sqlite3 *db, void *pAux, int argc, const char *const*argv, sqlite3_vtab **ppVtab, char **pzErr ){
static int stmtDisconnect(sqlite3_vtab *pVtab){
static int stmtEof(sqlite3_vtab_cursor *cur){
static int stmtFilter( sqlite3_vtab_cursor *pVtabCursor, int idxNum, const char *idxStr, int argc, sqlite3_value **argv ){
static int stmtNext(sqlite3_vtab_cursor *cur){
static int stmtOpen(sqlite3_vtab *p, sqlite3_vtab_cursor **ppCursor){
static int stmtRowid(sqlite3_vtab_cursor *cur, sqlite_int64 *pRowid){
static int unicodeClose(sqlite3_tokenizer_cursor *pCursor){
static int unicodeCreate( int nArg, const char * const *azArg, sqlite3_tokenizer **pp ){
static int unicodeDestroy(sqlite3_tokenizer *pTokenizer){
static int unicodeNext( sqlite3_tokenizer_cursor *pC, const char **paToken, int *pnToken, int *piStart, int *piEnd, int *piPos ){
static int unicodeOpen( sqlite3_tokenizer *p, const char *aInput, int nInput, sqlite3_tokenizer_cursor **pp ){
int unixDeviceCharacteristics(sqlite3_file *id){
int unixFileMutexNotheld(unixFile *pFile){
int unixFileSize(sqlite3_file *id, i64 *pSize){
int unixRead( sqlite3_file *id, void *pBuf, int amt, sqlite3_int64 offset ){
static void unixShmBarrier( sqlite3_file *fd ){
static int unixShmUnmap( sqlite3_file *fd, int deleteFlag ){
int unixSync(sqlite3_file *id, int flags){
static int unixTruncate(sqlite3_file *id, i64 nByte){
static int unixUnfetch(sqlite3_file *fd, i64 iOff, void *p){
int unixWrite( sqlite3_file *id, const void *pBuf, int amt, sqlite3_int64 offset ){
static int vfstraceAccess(sqlite3_vfs*, const char *zName, int flags, int *);
static int vfstraceCheckReservedLock(sqlite3_file*, int *);
0x00010000 #define VTR_DELETE 0x00020000 #define VTR_ACCESS 0x00040000 #define VTR_FULLPATH 0x00080000 #define VTR_DLOPEN 0x00100000 #define VTR_DLERR 0x00200000 #define VTR_DLSYM 0x00400000 #define VTR_DLCLOSE 0x00800000 #define VTR_RAND 0x01000000 #define VTR_SLEEP 0x02000000 #define VTR_CURTIME 0x04000000 #define VTR_LASTERR 0x08000000 #define VTR_FETCH 0x10000000 static int vfstraceClose(sqlite3_file*);
static int vfstraceCurrentTime(sqlite3_vfs*, double*);
static int vfstraceCurrentTimeInt64(sqlite3_vfs*, sqlite3_int64*);
static int vfstraceDelete(sqlite3_vfs*, const char *zName, int syncDir);
static int vfstraceDeviceCharacteristics(sqlite3_file*);
static void vfstraceDlClose(sqlite3_vfs*, void*);
static void vfstraceDlError(sqlite3_vfs*, int nByte, char *zErrMsg);
static void *vfstraceDlOpen(sqlite3_vfs*, const char *zFilename);
static int vfstraceFetch(sqlite3_file *pFile, i64 iOff, int nAmt, void **pptr){
static int vfstraceFileControl(sqlite3_file*, int op, void *pArg);
static int vfstraceFileSize(sqlite3_file*, sqlite3_int64 *pSize);
static int vfstraceFullPathname(sqlite3_vfs*, const char *zName, int, char *);
static int vfstraceGetLastError(sqlite3_vfs*, int, char*);
static sqlite3_syscall_ptr vfstraceGetSystemCall(sqlite3_vfs*, const char *);
static int vfstraceLock(sqlite3_file*, int);
static const char *vfstraceNextSystemCall(sqlite3_vfs*, const char *zName);
static int vfstraceOpen(sqlite3_vfs*, const char *, sqlite3_file*, int , int *);
static int vfstraceRandomness(sqlite3_vfs*, int nByte, char *zOut);
static int vfstraceRead(sqlite3_file*, void*, int iAmt, sqlite3_int64 iOfst);
static int vfstraceSectorSize(sqlite3_file*);
static int vfstraceSetSystemCall(sqlite3_vfs*,const char*, sqlite3_syscall_ptr);
static void vfstraceShmBarrier(sqlite3_file*);
static int vfstraceShmLock(sqlite3_file*,int,int,int);
static int vfstraceShmMap(sqlite3_file*,int,int,int, void volatile **);
static int vfstraceShmUnmap(sqlite3_file*,int);
static int vfstraceSleep(sqlite3_vfs*, int microseconds);
static int vfstraceSync(sqlite3_file*, int flags);
static int vfstraceTruncate(sqlite3_file*, sqlite3_int64 size);
static int vfstraceUnfetch(sqlite3_file *pFile, i64 iOff, void *ptr){
static int vfstraceUnlock(sqlite3_file*, int);
static int vfstraceWrite(sqlite3_file*,const void*,int iAmt, sqlite3_int64);
static void (*apndDlSym(sqlite3_vfs *pVfs, void *p, const char*zSym))(void);
int whereIsCoveringIndexWalkCallback(Walker *pWalk, Expr *pExpr){
static int winAccess( sqlite3_vfs *pVfs, const char *zFilename, int flags, int *pResOut );
static int winCheckReservedLock(sqlite3_file *id, int *pResOut){
static int winCurrentTime(sqlite3_vfs *pVfs, double *prNow){
static int winDelete(sqlite3_vfs *,const char*,int);
static int winDeviceCharacteristics(sqlite3_file *id){
static void winDlClose(sqlite3_vfs *pVfs, void *pHandle){
static void winDlError(sqlite3_vfs *pVfs, int nBuf, char *zBufOut){
static int winFileControl(sqlite3_file *id, int op, void *pArg){
static int winFileSize(sqlite3_file *id, sqlite3_int64 *pSize){
static int winFullPathname( sqlite3_vfs *pVfs, const char *zRelative, int nFull, char *zFull ){
static int winGetLastError(sqlite3_vfs *pVfs, int nBuf, char *zBuf){
static sqlite3_syscall_ptr winGetSystemCall( sqlite3_vfs *pNotUsed, const char *zName ){
static int winLock(sqlite3_file *id, int locktype){
static void winMemFree(void *pPrior);
static int winMemInit(void *pAppData);
static void *winMemRealloc(void *pPrior, int nBytes);
static int winMemRoundup(int n);
static void winMemShutdown(void *pAppData);
static int winMemSize(void *p);
static sqlite3_mutex *winMutexAlloc(int iType){
static int winMutexEnd(void){
static void winMutexEnter(sqlite3_mutex *p){
static void winMutexFree(sqlite3_mutex *p){
static int winMutexInit(void){
static void winMutexLeave(sqlite3_mutex *p){
static int winMutexNotheld(sqlite3_mutex *p){
static int winMutexTry(sqlite3_mutex *p){
static const char *winNextSystemCall(sqlite3_vfs *p, const char *zName){
static int winNolockCheckReservedLock(sqlite3_file *id, int *pResOut){
static int winNolockLock(sqlite3_file *id, int locktype){
static int winNolockUnlock(sqlite3_file *id, int locktype){
static int winRead( sqlite3_file *id, void *pBuf, int amt, sqlite3_int64 offset ){
static int winSectorSize(sqlite3_file *id){
static int winSetSystemCall( sqlite3_vfs *pNotUsed, const char *zName, sqlite3_syscall_ptr pNewFunc ){
static void winShmBarrier( sqlite3_file *fd ){
static int winShmLock( sqlite3_file *fd, int ofst, int n, int flags ){
static int winShmMap( sqlite3_file *fd, int iRegion, int szRegion, int isWrite, void volatile **pp ){
static int winShmUnmap( sqlite3_file *fd, int deleteFlag ){
static int winSleep(sqlite3_vfs *pVfs, int microsec){
static int winTruncate(sqlite3_file *id, sqlite3_int64 nByte){
static int winUnfetch(sqlite3_file *fd, i64 iOff, void *p){
static int winUnlock(sqlite3_file *id, int locktype){
static int winWrite( sqlite3_file *id, const void *pBuf, int amt, sqlite3_int64 offset ){
static int xDefaultRename(void *pArg, const char *zOld, const char *zNew){
zErr = "error in xDestroy()";
static int zipfileBegin(sqlite3_vtab *pVtab){
static int zipfileBestIndex( sqlite3_vtab *tab, sqlite3_index_info *pIdxInfo ){
static int zipfileClose(sqlite3_vtab_cursor *cur){
static int zipfileColumn( sqlite3_vtab_cursor *cur, sqlite3_context *ctx, int i ){
static int zipfileCommit(sqlite3_vtab *pVtab){
static int zipfileConnect( sqlite3 *db, void *pAux, int argc, const char *const*argv, sqlite3_vtab **ppVtab, char **pzErr ){
static int zipfileDisconnect(sqlite3_vtab *pVtab){
static int zipfileEof(sqlite3_vtab_cursor *cur){
static int zipfileFilter( sqlite3_vtab_cursor *cur, int idxNum, const char *idxStr, int argc, sqlite3_value **argv ){
static int zipfileFindFunction( sqlite3_vtab *pVtab, int nArg, const char *zName, void (**pxFunc)(sqlite3_context*,int,sqlite3_value**), void **ppArg ){
static int zipfileNext(sqlite3_vtab_cursor *cur){
static int zipfileOpen(sqlite3_vtab *p, sqlite3_vtab_cursor **ppCsr){
static int zipfileRollback(sqlite3_vtab *pVtab){
static int zipfileUpdate( sqlite3_vtab *pVtab, int nVal, sqlite3_value **apVal, sqlite_int64 *pRowid ){