// ===== RETURN FUNCTION POINTER TRANSFORMATION RULES (ARROW) =====

// Transform return E->aggregate_context(args) to direct call (only 1 candidate)
@transform_return_aggregate_context_arrow@
expression E;
identifier FP_NAME = aggregate_context;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_aggregate_context(args);


// Transform return E->auto_extension(args) to direct call (only 1 candidate)
@transform_return_auto_extension_arrow@
expression E;
identifier FP_NAME = auto_extension;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_vtab_config(args);


// Transform return E->backup_finish(args) to direct call (only 1 candidate)
@transform_return_backup_finish_arrow@
expression E;
identifier FP_NAME = backup_finish;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_result_error_code(args);


// Transform return E->backup_init(args) to direct call (only 1 candidate)
@transform_return_backup_init_arrow@
expression E;
identifier FP_NAME = backup_init;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_test_control(args);


// Transform return E->backup_pagecount(args) to direct call (only 1 candidate)
@transform_return_backup_pagecount_arrow@
expression E;
identifier FP_NAME = backup_pagecount;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_randomness(args);


// Transform return E->backup_remaining(args) to direct call (only 1 candidate)
@transform_return_backup_remaining_arrow@
expression E;
identifier FP_NAME = backup_remaining;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_context_db_handle(args);


// Transform return E->backup_step(args) to direct call (only 1 candidate)
@transform_return_backup_step_arrow@
expression E;
identifier FP_NAME = backup_step;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_extended_result_codes(args);


// Transform return E->bind_blob64(args) to direct call (only 1 candidate)
@transform_return_bind_blob64_arrow@
expression E;
identifier FP_NAME = bind_blob64;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_vtab_on_conflict(args);


// Transform return E->bind_int(args) to direct call (only 1 candidate)
@transform_return_bind_int_arrow@
expression E;
identifier FP_NAME = bind_int;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_bind_double(args);


// Transform return E->bind_int64(args) to direct call (only 1 candidate)
@transform_return_bind_int64_arrow@
expression E;
identifier FP_NAME = bind_int64;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_bind_int(args);


// Transform return E->bind_null(args) to direct call (only 1 candidate)
@transform_return_bind_null_arrow@
expression E;
identifier FP_NAME = bind_null;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_bind_int64(args);


// Transform return E->bind_parameter_count(args) to direct call (only 1 candidate)
@transform_return_bind_parameter_count_arrow@
expression E;
identifier FP_NAME = bind_parameter_count;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_bind_null(args);


// Transform return E->bind_parameter_index(args) to direct call (only 1 candidate)
@transform_return_bind_parameter_index_arrow@
expression E;
identifier FP_NAME = bind_parameter_index;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_bind_parameter_count(args);


// Transform return E->bind_parameter_name(args) to direct call (only 1 candidate)
@transform_return_bind_parameter_name_arrow@
expression E;
identifier FP_NAME = bind_parameter_name;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_bind_parameter_index(args);


// Transform return E->bind_text(args) to direct call (only 1 candidate)
@transform_return_bind_text_arrow@
expression E;
identifier FP_NAME = bind_text;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_bind_parameter_name(args);


// Transform return E->bind_text16(args) to direct call (only 1 candidate)
@transform_return_bind_text16_arrow@
expression E;
identifier FP_NAME = bind_text16;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_bind_text(args);


// Transform return E->bind_text64(args) to direct call (only 1 candidate)
@transform_return_bind_text64_arrow@
expression E;
identifier FP_NAME = bind_text64;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_close_v2(args);


// Transform return E->bind_value(args) to direct call (only 1 candidate)
@transform_return_bind_value_arrow@
expression E;
identifier FP_NAME = bind_value;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_bind_text16(args);


// Transform return E->bind_zeroblob(args) to direct call (only 1 candidate)
@transform_return_bind_zeroblob_arrow@
expression E;
identifier FP_NAME = bind_zeroblob;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_prepare_v2(args);


// Transform return E->bind_zeroblob64(args) to direct call (only 1 candidate)
@transform_return_bind_zeroblob64_arrow@
expression E;
identifier FP_NAME = bind_zeroblob64;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_auto_extension(args);


// Transform return E->blob_bytes(args) to direct call (only 1 candidate)
@transform_return_blob_bytes_arrow@
expression E;
identifier FP_NAME = blob_bytes;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_prepare16_v2(args);


// Transform return E->blob_close(args) to direct call (only 1 candidate)
@transform_return_blob_close_arrow@
expression E;
identifier FP_NAME = blob_close;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_clear_bindings(args);


// Transform return E->blob_open(args) to direct call (only 1 candidate)
@transform_return_blob_open_arrow@
expression E;
identifier FP_NAME = blob_open;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_create_module_v2(args);


// Transform return E->blob_read(args) to direct call (only 1 candidate)
@transform_return_blob_read_arrow@
expression E;
identifier FP_NAME = blob_read;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_bind_zeroblob(args);


// Transform return E->blob_reopen(args) to direct call (only 1 candidate)
@transform_return_blob_reopen_arrow@
expression E;
identifier FP_NAME = blob_reopen;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_db_status(args);


// Transform return E->blob_write(args) to direct call (only 1 candidate)
@transform_return_blob_write_arrow@
expression E;
identifier FP_NAME = blob_write;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_blob_bytes(args);


// Transform return E->busy_handler(args) to direct call (only 1 candidate)
@transform_return_busy_handler_arrow@
expression E;
identifier FP_NAME = busy_handler;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_bind_value(args);


// Transform return E->busy_timeout(args) to direct call (only 1 candidate)
@transform_return_busy_timeout_arrow@
expression E;
identifier FP_NAME = busy_timeout;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_busy_handler(args);


// Transform return E->cancel_auto_extension(args) to direct call (only 1 candidate)
@transform_return_cancel_auto_extension_arrow@
expression E;
identifier FP_NAME = cancel_auto_extension;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_db_filename(args);


// Transform return E->changes(args) to direct call (only 1 candidate)
@transform_return_changes_arrow@
expression E;
identifier FP_NAME = changes;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_busy_timeout(args);


// Transform return E->changes64(args) to direct call (only 1 candidate)
@transform_return_changes64_arrow@
expression E;
identifier FP_NAME = changes64;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_str_value(args);


// Transform return E->clear_bindings(args) to direct call (only 1 candidate)
@transform_return_clear_bindings_arrow@
expression E;
identifier FP_NAME = clear_bindings;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_vmprintf(args);


// Transform return E->close(args) to direct call (only 1 candidate)
@transform_return_close_arrow@
expression E;
identifier FP_NAME = close;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_changes(args);


// Transform return E->close_v2(args) to direct call (only 1 candidate)
@transform_return_close_v2_arrow@
expression E;
identifier FP_NAME = close_v2;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_soft_heap_limit64(args);


// Transform return E->collation_needed(args) to direct call (only 1 candidate)
@transform_return_collation_needed_arrow@
expression E;
identifier FP_NAME = collation_needed;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_close(args);


// Transform return E->collation_needed16(args) to direct call (only 1 candidate)
@transform_return_collation_needed16_arrow@
expression E;
identifier FP_NAME = collation_needed16;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_collation_needed(args);


// Transform return E->column_blob(args) to direct call (only 1 candidate)
@transform_return_column_blob_arrow@
expression E;
identifier FP_NAME = column_blob;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_collation_needed16(args);


// Transform return E->column_bytes(args) to direct call (only 1 candidate)
@transform_return_column_bytes_arrow@
expression E;
identifier FP_NAME = column_bytes;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_column_blob(args);


// Transform return E->column_bytes16(args) to direct call (only 1 candidate)
@transform_return_column_bytes16_arrow@
expression E;
identifier FP_NAME = column_bytes16;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_column_bytes(args);


// Transform return E->column_count(args) to direct call (only 1 candidate)
@transform_return_column_count_arrow@
expression E;
identifier FP_NAME = column_count;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_column_bytes16(args);


// Transform return E->column_database_name(args) to direct call (only 1 candidate)
@transform_return_column_database_name_arrow@
expression E;
identifier FP_NAME = column_database_name;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_column_count(args);


// Transform return E->column_database_name16(args) to direct call (only 1 candidate)
@transform_return_column_database_name16_arrow@
expression E;
identifier FP_NAME = column_database_name16;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_column_database_name(args);


// Transform return E->column_decltype(args) to direct call (only 1 candidate)
@transform_return_column_decltype_arrow@
expression E;
identifier FP_NAME = column_decltype;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_column_database_name16(args);


// Transform return E->column_decltype16(args) to direct call (only 1 candidate)
@transform_return_column_decltype16_arrow@
expression E;
identifier FP_NAME = column_decltype16;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_column_decltype(args);


// Transform return E->column_double(args) to direct call (only 1 candidate)
@transform_return_column_double_arrow@
expression E;
identifier FP_NAME = column_double;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_column_decltype16(args);


// Transform return E->column_int(args) to direct call (only 1 candidate)
@transform_return_column_int_arrow@
expression E;
identifier FP_NAME = column_int;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_column_double(args);


// Transform return E->column_int64(args) to direct call (only 1 candidate)
@transform_return_column_int64_arrow@
expression E;
identifier FP_NAME = column_int64;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_column_int(args);


// Transform return E->column_name(args) to direct call (only 1 candidate)
@transform_return_column_name_arrow@
expression E;
identifier FP_NAME = column_name;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_column_int64(args);


// Transform return E->column_name16(args) to direct call (only 1 candidate)
@transform_return_column_name16_arrow@
expression E;
identifier FP_NAME = column_name16;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_column_name(args);


// Transform return E->column_origin_name(args) to direct call (only 1 candidate)
@transform_return_column_origin_name_arrow@
expression E;
identifier FP_NAME = column_origin_name;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_column_name16(args);


// Transform return E->column_origin_name16(args) to direct call (only 1 candidate)
@transform_return_column_origin_name16_arrow@
expression E;
identifier FP_NAME = column_origin_name16;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_column_origin_name(args);


// Transform return E->column_table_name(args) to direct call (only 1 candidate)
@transform_return_column_table_name_arrow@
expression E;
identifier FP_NAME = column_table_name;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_column_origin_name16(args);


// Transform return E->column_table_name16(args) to direct call (only 1 candidate)
@transform_return_column_table_name16_arrow@
expression E;
identifier FP_NAME = column_table_name16;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_column_table_name(args);


// Transform return E->column_text(args) to direct call (only 1 candidate)
@transform_return_column_text_arrow@
expression E;
identifier FP_NAME = column_text;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_column_table_name16(args);


// Transform return E->column_text16(args) to direct call (only 1 candidate)
@transform_return_column_text16_arrow@
expression E;
identifier FP_NAME = column_text16;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_column_text(args);


// Transform return E->column_type(args) to direct call (only 1 candidate)
@transform_return_column_type_arrow@
expression E;
identifier FP_NAME = column_type;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_column_text16(args);


// Transform return E->column_value(args) to direct call (only 1 candidate)
@transform_return_column_value_arrow@
expression E;
identifier FP_NAME = column_value;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_column_type(args);


// Transform return E->commit_hook(args) to direct call (only 1 candidate)
@transform_return_commit_hook_arrow@
expression E;
identifier FP_NAME = commit_hook;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_column_value(args);


// Transform return E->compileoption_get(args) to direct call (only 1 candidate)
@transform_return_compileoption_get_arrow@
expression E;
identifier FP_NAME = compileoption_get;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_limit(args);


// Transform return E->compileoption_used(args) to direct call (only 1 candidate)
@transform_return_compileoption_used_arrow@
expression E;
identifier FP_NAME = compileoption_used;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_next_stmt(args);


// Transform return E->complete(args) to direct call (only 1 candidate)
@transform_return_complete_arrow@
expression E;
identifier FP_NAME = complete;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_commit_hook(args);


// Transform return E->complete16(args) to direct call (only 1 candidate)
@transform_return_complete16_arrow@
expression E;
identifier FP_NAME = complete16;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_complete(args);


// Transform return E->context_db_handle(args) to direct call (only 1 candidate)
@transform_return_context_db_handle_arrow@
expression E;
identifier FP_NAME = context_db_handle;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_soft_heap_limit(args);


// Transform return E->create_collation(args) to direct call (only 1 candidate)
@transform_return_create_collation_arrow@
expression E;
identifier FP_NAME = create_collation;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_complete16(args);


// Transform return E->create_collation16(args) to direct call (only 1 candidate)
@transform_return_create_collation16_arrow@
expression E;
identifier FP_NAME = create_collation16;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_create_collation(args);


// Transform return E->create_collation_v2(args) to direct call (only 1 candidate)
@transform_return_create_collation_v2_arrow@
expression E;
identifier FP_NAME = create_collation_v2;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_blob_close(args);


// Transform return E->create_filename(args) to direct call (only 1 candidate)
@transform_return_create_filename_arrow@
expression E;
identifier FP_NAME = create_filename;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_str_appendchar(args);


// Transform return E->create_function(args) to direct call (only 1 candidate)
@transform_return_create_function_arrow@
expression E;
identifier FP_NAME = create_function;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_create_collation16(args);


// Transform return E->create_function16(args) to direct call (only 1 candidate)
@transform_return_create_function16_arrow@
expression E;
identifier FP_NAME = create_function16;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_create_function(args);


// Transform return E->create_function_v2(args) to direct call (only 1 candidate)
@transform_return_create_function_v2_arrow@
expression E;
identifier FP_NAME = create_function_v2;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_sql(args);


// Transform return E->create_module(args) to direct call (only 1 candidate)
@transform_return_create_module_arrow@
expression E;
identifier FP_NAME = create_module;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_create_function16(args);


// Transform return E->create_module_v2(args) to direct call (only 1 candidate)
@transform_return_create_module_v2_arrow@
expression E;
identifier FP_NAME = create_module_v2;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_overload_function(args);


// Transform return E->create_window_function(args) to direct call (only 1 candidate)
@transform_return_create_window_function_arrow@
expression E;
identifier FP_NAME = create_window_function;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_vtab_collation(args);


// Transform return E->data_count(args) to direct call (only 1 candidate)
@transform_return_data_count_arrow@
expression E;
identifier FP_NAME = data_count;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_create_module(args);


// Transform return E->database_file_object(args) to direct call (only 1 candidate)
@transform_return_database_file_object_arrow@
expression E;
identifier FP_NAME = database_file_object;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_str_errcode(args);


// Transform return E->db_cacheflush(args) to direct call (only 1 candidate)
@transform_return_db_cacheflush_arrow@
expression E;
identifier FP_NAME = db_cacheflush;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_malloc64(args);


// Transform return E->db_config(args) to direct call (only 1 candidate)
@transform_return_db_config_arrow@
expression E;
identifier FP_NAME = db_config;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_status(args);


// Transform return E->db_filename(args) to direct call (only 1 candidate)
@transform_return_db_filename_arrow@
expression E;
identifier FP_NAME = db_filename;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_sourceid(args);


// Transform return E->db_handle(args) to direct call (only 1 candidate)
@transform_return_db_handle_arrow@
expression E;
identifier FP_NAME = db_handle;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_data_count(args);


// Transform return E->db_mutex(args) to direct call (only 1 candidate)
@transform_return_db_mutex_arrow@
expression E;
identifier FP_NAME = db_mutex;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_backup_finish(args);


// Transform return E->db_name(args) to direct call (only 1 candidate)
@transform_return_db_name_arrow@
expression E;
identifier FP_NAME = db_name;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_filename_journal(args);


// Transform return E->db_readonly(args) to direct call (only 1 candidate)
@transform_return_db_readonly_arrow@
expression E;
identifier FP_NAME = db_readonly;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_stmt_status(args);


// Transform return E->db_release_memory(args) to direct call (only 1 candidate)
@transform_return_db_release_memory_arrow@
expression E;
identifier FP_NAME = db_release_memory;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_strnicmp(args);


// Transform return E->db_status(args) to direct call (only 1 candidate)
@transform_return_db_status_arrow@
expression E;
identifier FP_NAME = db_status;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_backup_init(args);


// Transform return E->declare_vtab(args) to direct call (only 1 candidate)
@transform_return_declare_vtab_arrow@
expression E;
identifier FP_NAME = declare_vtab;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_db_handle(args);


// Transform return E->deserialize(args) to direct call (only 1 candidate)
@transform_return_deserialize_arrow@
expression E;
identifier FP_NAME = deserialize;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_uri_key(args);


// Transform return E->drop_modules(args) to direct call (only 1 candidate)
@transform_return_drop_modules_arrow@
expression E;
identifier FP_NAME = drop_modules;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_str_new(args);


// Transform return E->enable_shared_cache(args) to direct call (only 1 candidate)
@transform_return_enable_shared_cache_arrow@
expression E;
identifier FP_NAME = enable_shared_cache;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_declare_vtab(args);


// Transform return E->errcode(args) to direct call (only 1 candidate)
@transform_return_errcode_arrow@
expression E;
identifier FP_NAME = errcode;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_enable_shared_cache(args);


// Transform return E->errmsg(args) to direct call (only 1 candidate)
@transform_return_errmsg_arrow@
expression E;
identifier FP_NAME = errmsg;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_errcode(args);


// Transform return E->errmsg16(args) to direct call (only 1 candidate)
@transform_return_errmsg16_arrow@
expression E;
identifier FP_NAME = errmsg16;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_errmsg(args);


// Transform return E->exec(args) to direct call (only 1 candidate)
@transform_return_exec_arrow@
expression E;
identifier FP_NAME = exec;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_errmsg16(args);


// Transform return E->expanded_sql(args) to direct call (only 1 candidate)
@transform_return_expanded_sql_arrow@
expression E;
identifier FP_NAME = expanded_sql;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_reset_auto_extension(args);


// Transform return E->expired(args) to direct call (only 1 candidate)
@transform_return_expired_arrow@
expression E;
identifier FP_NAME = expired;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_exec(args);


// Transform return E->extended_errcode(args) to direct call (only 1 candidate)
@transform_return_extended_errcode_arrow@
expression E;
identifier FP_NAME = extended_errcode;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_backup_pagecount(args);


// Transform return E->extended_result_codes(args) to direct call (only 1 candidate)
@transform_return_extended_result_codes_arrow@
expression E;
identifier FP_NAME = extended_result_codes;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_vfs_find(args);


// Transform return E->file_control(args) to direct call (only 1 candidate)
@transform_return_file_control_arrow@
expression E;
identifier FP_NAME = file_control;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_blob_open(args);


// Transform return E->filename_database(args) to direct call (only 1 candidate)
@transform_return_filename_database_arrow@
expression E;
identifier FP_NAME = filename_database;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_str_vappendf(args);


// Transform return E->filename_journal(args) to direct call (only 1 candidate)
@transform_return_filename_journal_arrow@
expression E;
identifier FP_NAME = filename_journal;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_str_append(args);


// Transform return E->filename_wal(args) to direct call (only 1 candidate)
@transform_return_filename_wal_arrow@
expression E;
identifier FP_NAME = filename_wal;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_str_appendall(args);


// Transform return E->free_filename(args) to direct call (only 1 candidate)
@transform_return_free_filename_arrow@
expression E;
identifier FP_NAME = free_filename;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_str_reset(args);


// Transform return E->get_autocommit(args) to direct call (only 1 candidate)
@transform_return_get_autocommit_arrow@
expression E;
identifier FP_NAME = get_autocommit;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_free(args);


// Transform return E->get_auxdata(args) to direct call (only 1 candidate)
@transform_return_get_auxdata_arrow@
expression E;
identifier FP_NAME = get_auxdata;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_free_table(args);


// Transform return E->get_clientdata(args) to direct call (only 1 candidate)
@transform_return_get_clientdata_arrow@
expression E;
identifier FP_NAME = get_clientdata;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_database_file_object(args);


// Transform return E->get_table(args) to direct call (only 1 candidate)
@transform_return_get_table_arrow@
expression E;
identifier FP_NAME = get_table;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_get_autocommit(args);


// Transform return E->global_recover(args) to direct call (only 1 candidate)
@transform_return_global_recover_arrow@
expression E;
identifier FP_NAME = global_recover;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_get_auxdata(args);


// Transform return E->hard_heap_limit64(args) to direct call (only 1 candidate)
@transform_return_hard_heap_limit64_arrow@
expression E;
identifier FP_NAME = hard_heap_limit64;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_str_finish(args);


// Transform return E->interruptx(args) to direct call (only 1 candidate)
@transform_return_interruptx_arrow@
expression E;
identifier FP_NAME = interruptx;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_get_table(args);


// Transform return E->is_interrupted(args) to direct call (only 1 candidate)
@transform_return_is_interrupted_arrow@
expression E;
identifier FP_NAME = is_interrupted;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_create_filename(args);


// Transform return E->keyword_check(args) to direct call (only 1 candidate)
@transform_return_keyword_check_arrow@
expression E;
identifier FP_NAME = keyword_check;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_db_cacheflush(args);


// Transform return E->keyword_count(args) to direct call (only 1 candidate)
@transform_return_keyword_count_arrow@
expression E;
identifier FP_NAME = keyword_count;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_status64(args);


// Transform return E->keyword_name(args) to direct call (only 1 candidate)
@transform_return_keyword_name_arrow@
expression E;
identifier FP_NAME = keyword_name;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_strlike(args);


// Transform return E->libversion(args) to direct call (only 1 candidate)
@transform_return_libversion_arrow@
expression E;
identifier FP_NAME = libversion;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_interrupt(args);


// Transform return E->libversion_number(args) to direct call (only 1 candidate)
@transform_return_libversion_number_arrow@
expression E;
identifier FP_NAME = libversion_number;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_last_insert_rowid(args);


// Transform return E->limit(args) to direct call (only 1 candidate)
@transform_return_limit_arrow@
expression E;
identifier FP_NAME = limit;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_vfs_register(args);


// Transform return E->load_extension(args) to direct call (only 1 candidate)
@transform_return_load_extension_arrow@
expression E;
identifier FP_NAME = load_extension;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_db_readonly(args);


// Transform return E->log(args) to direct call (only 1 candidate)
@transform_return_log_arrow@
expression E;
identifier FP_NAME = log;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_backup_remaining(args);


// Transform return E->malloc(args) to direct call (only 1 candidate)
@transform_return_malloc_arrow@
expression E;
identifier FP_NAME = malloc;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_libversion(args);


// Transform return E->malloc64(args) to direct call (only 1 candidate)
@transform_return_malloc64_arrow@
expression E;
identifier FP_NAME = malloc64;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_db_release_memory(args);


// Transform return E->memory_highwater(args) to direct call (only 1 candidate)
@transform_return_memory_highwater_arrow@
expression E;
identifier FP_NAME = memory_highwater;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_blob_read(args);


// Transform return E->memory_used(args) to direct call (only 1 candidate)
@transform_return_memory_used_arrow@
expression E;
identifier FP_NAME = memory_used;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_blob_write(args);


// Transform return E->mprintf(args) to direct call (only 1 candidate)
@transform_return_mprintf_arrow@
expression E;
identifier FP_NAME = mprintf;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_libversion_number(args);


// Transform return E->msize(args) to direct call (only 1 candidate)
@transform_return_msize_arrow@
expression E;
identifier FP_NAME = msize;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_errstr(args);


// Transform return E->mutex_alloc(args) to direct call (only 1 candidate)
@transform_return_mutex_alloc_arrow@
expression E;
identifier FP_NAME = mutex_alloc;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_create_collation_v2(args);


// Transform return E->mutex_enter(args) to direct call (only 1 candidate)
@transform_return_mutex_enter_arrow@
expression E;
identifier FP_NAME = mutex_enter;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_file_control(args);


// Transform return E->mutex_free(args) to direct call (only 1 candidate)
@transform_return_mutex_free_arrow@
expression E;
identifier FP_NAME = mutex_free;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_memory_highwater(args);


// Transform return E->mutex_leave(args) to direct call (only 1 candidate)
@transform_return_mutex_leave_arrow@
expression E;
identifier FP_NAME = mutex_leave;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_memory_used(args);


// Transform return E->next_stmt(args) to direct call (only 1 candidate)
@transform_return_next_stmt_arrow@
expression E;
identifier FP_NAME = next_stmt;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_vfs_unregister(args);


// Transform return E->normalized_sql(args) to direct call (only 1 candidate)
@transform_return_normalized_sql_arrow@
expression E;
identifier FP_NAME = normalized_sql;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_keyword_count(args);


// Transform return E->open(args) to direct call (only 1 candidate)
@transform_return_open_arrow@
expression E;
identifier FP_NAME = open;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_malloc(args);


// Transform return E->open16(args) to direct call (only 1 candidate)
@transform_return_open16_arrow@
expression E;
identifier FP_NAME = open16;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_mprintf(args);


// Transform return E->overload_function(args) to direct call (only 1 candidate)
@transform_return_overload_function_arrow@
expression E;
identifier FP_NAME = overload_function;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_value_text16be(args);


// Transform return E->prepare(args) to direct call (only 1 candidate)
@transform_return_prepare_arrow@
expression E;
identifier FP_NAME = prepare;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_open(args);


// Transform return E->prepare16(args) to direct call (only 1 candidate)
@transform_return_prepare16_arrow@
expression E;
identifier FP_NAME = prepare16;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_open16(args);


// Transform return E->prepare16_v2(args) to direct call (only 1 candidate)
@transform_return_prepare16_v2_arrow@
expression E;
identifier FP_NAME = prepare16_v2;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_value_type(args);


// Transform return E->prepare16_v3(args) to direct call (only 1 candidate)
@transform_return_prepare16_v3_arrow@
expression E;
identifier FP_NAME = prepare16_v3;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_strglob(args);


// Transform return E->prepare_v2(args) to direct call (only 1 candidate)
@transform_return_prepare_v2_arrow@
expression E;
identifier FP_NAME = prepare_v2;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_value_text16le(args);


// Transform return E->prepare_v3(args) to direct call (only 1 candidate)
@transform_return_prepare_v3_arrow@
expression E;
identifier FP_NAME = prepare_v3;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_result_text64(args);


// Transform return E->profile(args) to direct call (only 1 candidate)
@transform_return_profile_arrow@
expression E;
identifier FP_NAME = profile;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_prepare(args);


// Transform return E->progress_handler(args) to direct call (only 1 candidate)
@transform_return_progress_handler_arrow@
expression E;
identifier FP_NAME = progress_handler;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_prepare16(args);


// Transform return E->randomness(args) to direct call (only 1 candidate)
@transform_return_randomness_arrow@
expression E;
identifier FP_NAME = randomness;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_sleep(args);


// Transform return E->realloc(args) to direct call (only 1 candidate)
@transform_return_realloc_arrow@
expression E;
identifier FP_NAME = realloc;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_profile(args);


// Transform return E->realloc64(args) to direct call (only 1 candidate)
@transform_return_realloc64_arrow@
expression E;
identifier FP_NAME = realloc64;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_stmt_busy(args);


// Transform return E->reset(args) to direct call (only 1 candidate)
@transform_return_reset_arrow@
expression E;
identifier FP_NAME = reset;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_progress_handler(args);


// Transform return E->reset_auto_extension(args) to direct call (only 1 candidate)
@transform_return_reset_auto_extension_arrow@
expression E;
identifier FP_NAME = reset_auto_extension;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_stmt_readonly(args);


// Transform return E->result_blob(args) to direct call (only 1 candidate)
@transform_return_result_blob_arrow@
expression E;
identifier FP_NAME = result_blob;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_realloc(args);


// Transform return E->result_blob64(args) to direct call (only 1 candidate)
@transform_return_result_blob64_arrow@
expression E;
identifier FP_NAME = result_blob64;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_stricmp(args);


// Transform return E->result_double(args) to direct call (only 1 candidate)
@transform_return_result_double_arrow@
expression E;
identifier FP_NAME = result_double;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_reset(args);


// Transform return E->result_error(args) to direct call (only 1 candidate)
@transform_return_result_error_arrow@
expression E;
identifier FP_NAME = result_error;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_result_blob(args);


// Transform return E->result_error16(args) to direct call (only 1 candidate)
@transform_return_result_error16_arrow@
expression E;
identifier FP_NAME = result_error16;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_result_double(args);


// Transform return E->result_error_code(args) to direct call (only 1 candidate)
@transform_return_result_error_code_arrow@
expression E;
identifier FP_NAME = result_error_code;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_result_error_nomem(args);


// Transform return E->result_int(args) to direct call (only 1 candidate)
@transform_return_result_int_arrow@
expression E;
identifier FP_NAME = result_int;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_result_error(args);


// Transform return E->result_int64(args) to direct call (only 1 candidate)
@transform_return_result_int64_arrow@
expression E;
identifier FP_NAME = result_int64;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_result_error16(args);


// Transform return E->result_null(args) to direct call (only 1 candidate)
@transform_return_result_null_arrow@
expression E;
identifier FP_NAME = result_null;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_result_int(args);


// Transform return E->result_pointer(args) to direct call (only 1 candidate)
@transform_return_result_pointer_arrow@
expression E;
identifier FP_NAME = result_pointer;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_value_free(args);


// Transform return E->result_subtype(args) to direct call (only 1 candidate)
@transform_return_result_subtype_arrow@
expression E;
identifier FP_NAME = result_subtype;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_bind_text64(args);


// Transform return E->result_text(args) to direct call (only 1 candidate)
@transform_return_result_text_arrow@
expression E;
identifier FP_NAME = result_text;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_result_int64(args);


// Transform return E->result_text16(args) to direct call (only 1 candidate)
@transform_return_result_text16_arrow@
expression E;
identifier FP_NAME = result_text16;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_result_null(args);


// Transform return E->result_text16be(args) to direct call (only 1 candidate)
@transform_return_result_text16be_arrow@
expression E;
identifier FP_NAME = result_text16be;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_result_text(args);


// Transform return E->result_text16le(args) to direct call (only 1 candidate)
@transform_return_result_text16le_arrow@
expression E;
identifier FP_NAME = result_text16le;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_result_text16(args);


// Transform return E->result_text64(args) to direct call (only 1 candidate)
@transform_return_result_text64_arrow@
expression E;
identifier FP_NAME = result_text64;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_uri_boolean(args);


// Transform return E->result_value(args) to direct call (only 1 candidate)
@transform_return_result_value_arrow@
expression E;
identifier FP_NAME = result_value;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_result_text16be(args);


// Transform return E->result_zeroblob(args) to direct call (only 1 candidate)
@transform_return_result_zeroblob_arrow@
expression E;
identifier FP_NAME = result_zeroblob;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_release_memory(args);


// Transform return E->result_zeroblob64(args) to direct call (only 1 candidate)
@transform_return_result_zeroblob64_arrow@
expression E;
identifier FP_NAME = result_zeroblob64;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_wal_checkpoint_v2(args);


// Transform return E->rollback_hook(args) to direct call (only 1 candidate)
@transform_return_rollback_hook_arrow@
expression E;
identifier FP_NAME = rollback_hook;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_result_text16le(args);


// Transform return E->serialize(args) to direct call (only 1 candidate)
@transform_return_serialize_arrow@
expression E;
identifier FP_NAME = serialize;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_filename_database(args);


// Transform return E->set_authorizer(args) to direct call (only 1 candidate)
@transform_return_set_authorizer_arrow@
expression E;
identifier FP_NAME = set_authorizer;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_result_value(args);


// Transform return E->set_auxdata(args) to direct call (only 1 candidate)
@transform_return_set_auxdata_arrow@
expression E;
identifier FP_NAME = set_auxdata;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_rollback_hook(args);


// Transform return E->set_clientdata(args) to direct call (only 1 candidate)
@transform_return_set_clientdata_arrow@
expression E;
identifier FP_NAME = set_clientdata;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_txn_state(args);


// Transform return E->set_last_insert_rowid(args) to direct call (only 1 candidate)
@transform_return_set_last_insert_rowid_arrow@
expression E;
identifier FP_NAME = set_last_insert_rowid;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_result_blob64(args);


// Transform return E->setlk_timeout(args) to direct call (only 1 candidate)
@transform_return_setlk_timeout_arrow@
expression E;
identifier FP_NAME = setlk_timeout;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_changes64(args);


// Transform return E->soft_heap_limit(args) to direct call (only 1 candidate)
@transform_return_soft_heap_limit_arrow@
expression E;
identifier FP_NAME = soft_heap_limit;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_mutex_enter(args);


// Transform return E->soft_heap_limit64(args) to direct call (only 1 candidate)
@transform_return_soft_heap_limit64_arrow@
expression E;
identifier FP_NAME = soft_heap_limit64;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_backup_step(args);


// Transform return E->sql(args) to direct call (only 1 candidate)
@transform_return_sql_arrow@
expression E;
identifier FP_NAME = sql;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_threadsafe(args);


// Transform return E->status(args) to direct call (only 1 candidate)
@transform_return_status_arrow@
expression E;
identifier FP_NAME = status;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_result_zeroblob(args);


// Transform return E->status64(args) to direct call (only 1 candidate)
@transform_return_status64_arrow@
expression E;
identifier FP_NAME = status64;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_cancel_auto_extension(args);


// Transform return E->step(args) to direct call (only 1 candidate)
@transform_return_step_arrow@
expression E;
identifier FP_NAME = step;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_set_auxdata(args);


// Transform return E->stmt_explain(args) to direct call (only 1 candidate)
@transform_return_stmt_explain_arrow@
expression E;
identifier FP_NAME = stmt_explain;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_free_filename(args);


// Transform return E->stmt_isexplain(args) to direct call (only 1 candidate)
@transform_return_stmt_isexplain_arrow@
expression E;
identifier FP_NAME = stmt_isexplain;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_keyword_name(args);


// Transform return E->stmt_status(args) to direct call (only 1 candidate)
@transform_return_stmt_status_arrow@
expression E;
identifier FP_NAME = stmt_status;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_compileoption_used(args);


// Transform return E->str_append(args) to direct call (only 1 candidate)
@transform_return_str_append_arrow@
expression E;
identifier FP_NAME = str_append;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_prepare_v3(args);


// Transform return E->str_appendall(args) to direct call (only 1 candidate)
@transform_return_str_appendall_arrow@
expression E;
identifier FP_NAME = str_appendall;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_prepare16_v3(args);


// Transform return E->str_appendchar(args) to direct call (only 1 candidate)
@transform_return_str_appendchar_arrow@
expression E;
identifier FP_NAME = str_appendchar;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_bind_pointer(args);


// Transform return E->str_appendf(args) to direct call (only 1 candidate)
@transform_return_str_appendf_arrow@
expression E;
identifier FP_NAME = str_appendf;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_expanded_sql(args);


// Transform return E->str_errcode(args) to direct call (only 1 candidate)
@transform_return_str_errcode_arrow@
expression E;
identifier FP_NAME = str_errcode;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_value_pointer(args);


// Transform return E->str_finish(args) to direct call (only 1 candidate)
@transform_return_str_finish_arrow@
expression E;
identifier FP_NAME = str_finish;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_trace_v2(args);


// Transform return E->str_length(args) to direct call (only 1 candidate)
@transform_return_str_length_arrow@
expression E;
identifier FP_NAME = str_length;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_vtab_nochange(args);


// Transform return E->str_new(args) to direct call (only 1 candidate)
@transform_return_str_new_arrow@
expression E;
identifier FP_NAME = str_new;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_system_errno(args);


// Transform return E->str_reset(args) to direct call (only 1 candidate)
@transform_return_str_reset_arrow@
expression E;
identifier FP_NAME = str_reset;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_result_pointer(args);


// Transform return E->str_value(args) to direct call (only 1 candidate)
@transform_return_str_value_arrow@
expression E;
identifier FP_NAME = str_value;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_value_nochange(args);


// Transform return E->str_vappendf(args) to direct call (only 1 candidate)
@transform_return_str_vappendf_arrow@
expression E;
identifier FP_NAME = str_vappendf;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_set_last_insert_rowid(args);


// Transform return E->strglob(args) to direct call (only 1 candidate)
@transform_return_strglob_arrow@
expression E;
identifier FP_NAME = strglob;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_uri_int64(args);


// Transform return E->stricmp(args) to direct call (only 1 candidate)
@transform_return_stricmp_arrow@
expression E;
identifier FP_NAME = stricmp;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_wal_checkpoint(args);


// Transform return E->strlike(args) to direct call (only 1 candidate)
@transform_return_strlike_arrow@
expression E;
identifier FP_NAME = strlike;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_load_extension(args);


// Transform return E->system_errno(args) to direct call (only 1 candidate)
@transform_return_system_errno_arrow@
expression E;
identifier FP_NAME = system_errno;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_msize(args);


// Transform return E->table_column_metadata(args) to direct call (only 1 candidate)
@transform_return_table_column_metadata_arrow@
expression E;
identifier FP_NAME = table_column_metadata;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_snprintf(args);


// Transform return E->test_control(args) to direct call (only 1 candidate)
@transform_return_test_control_arrow@
expression E;
identifier FP_NAME = test_control;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_result_error_toobig(args);


// Transform return E->thread_cleanup(args) to direct call (only 1 candidate)
@transform_return_thread_cleanup_arrow@
expression E;
identifier FP_NAME = thread_cleanup;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_step(args);


// Transform return E->total_changes(args) to direct call (only 1 candidate)
@transform_return_total_changes_arrow@
expression E;
identifier FP_NAME = total_changes;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_table_column_metadata(args);


// Transform return E->total_changes64(args) to direct call (only 1 candidate)
@transform_return_total_changes64_arrow@
expression E;
identifier FP_NAME = total_changes64;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_create_window_function(args);


// Transform return E->trace_v2(args) to direct call (only 1 candidate)
@transform_return_trace_v2_arrow@
expression E;
identifier FP_NAME = trace_v2;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_realloc64(args);


// Transform return E->txn_state(args) to direct call (only 1 candidate)
@transform_return_txn_state_arrow@
expression E;
identifier FP_NAME = txn_state;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_str_length(args);


// Transform return E->uri_boolean(args) to direct call (only 1 candidate)
@transform_return_uri_boolean_arrow@
expression E;
identifier FP_NAME = uri_boolean;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_wal_hook(args);


// Transform return E->uri_key(args) to direct call (only 1 candidate)
@transform_return_uri_key_arrow@
expression E;
identifier FP_NAME = uri_key;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_str_appendf(args);


// Transform return E->user_data(args) to direct call (only 1 candidate)
@transform_return_user_data_arrow@
expression E;
identifier FP_NAME = user_data;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_trace(args);


// Transform return E->value_double(args) to direct call (only 1 candidate)
@transform_return_value_double_arrow@
expression E;
identifier FP_NAME = value_double;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_user_data(args);


// Transform return E->value_dup(args) to direct call (only 1 candidate)
@transform_return_value_dup_arrow@
expression E;
identifier FP_NAME = value_dup;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_uri_parameter(args);


// Transform return E->value_encoding(args) to direct call (only 1 candidate)
@transform_return_value_encoding_arrow@
expression E;
identifier FP_NAME = value_encoding;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_filename_wal(args);


// Transform return E->value_free(args) to direct call (only 1 candidate)
@transform_return_value_free_arrow@
expression E;
identifier FP_NAME = value_free;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_vsnprintf(args);


// Transform return E->value_frombind(args) to direct call (only 1 candidate)
@transform_return_value_frombind_arrow@
expression E;
identifier FP_NAME = value_frombind;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_keyword_check(args);


// Transform return E->value_int(args) to direct call (only 1 candidate)
@transform_return_value_int_arrow@
expression E;
identifier FP_NAME = value_int;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_value_blob(args);


// Transform return E->value_int64(args) to direct call (only 1 candidate)
@transform_return_value_int64_arrow@
expression E;
identifier FP_NAME = value_int64;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_value_bytes(args);


// Transform return E->value_nochange(args) to direct call (only 1 candidate)
@transform_return_value_nochange_arrow@
expression E;
identifier FP_NAME = value_nochange;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_value_subtype(args);


// Transform return E->value_numeric_type(args) to direct call (only 1 candidate)
@transform_return_value_numeric_type_arrow@
expression E;
identifier FP_NAME = value_numeric_type;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_value_bytes16(args);


// Transform return E->value_pointer(args) to direct call (only 1 candidate)
@transform_return_value_pointer_arrow@
expression E;
identifier FP_NAME = value_pointer;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_result_zeroblob64(args);


// Transform return E->value_subtype(args) to direct call (only 1 candidate)
@transform_return_value_subtype_arrow@
expression E;
identifier FP_NAME = value_subtype;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_bind_blob64(args);


// Transform return E->value_text(args) to direct call (only 1 candidate)
@transform_return_value_text_arrow@
expression E;
identifier FP_NAME = value_text;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_value_double(args);


// Transform return E->value_text16(args) to direct call (only 1 candidate)
@transform_return_value_text16_arrow@
expression E;
identifier FP_NAME = value_text16;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_value_int(args);


// Transform return E->value_text16be(args) to direct call (only 1 candidate)
@transform_return_value_text16be_arrow@
expression E;
identifier FP_NAME = value_text16be;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_value_int64(args);


// Transform return E->value_text16le(args) to direct call (only 1 candidate)
@transform_return_value_text16le_arrow@
expression E;
identifier FP_NAME = value_text16le;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_value_numeric_type(args);


// Transform return E->value_type(args) to direct call (only 1 candidate)
@transform_return_value_type_arrow@
expression E;
identifier FP_NAME = value_type;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_value_text(args);


// Transform return E->vfs_find(args) to direct call (only 1 candidate)
@transform_return_vfs_find_arrow@
expression E;
identifier FP_NAME = vfs_find;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_mutex_free(args);


// Transform return E->vfs_register(args) to direct call (only 1 candidate)
@transform_return_vfs_register_arrow@
expression E;
identifier FP_NAME = vfs_register;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_mutex_leave(args);


// Transform return E->vfs_unregister(args) to direct call (only 1 candidate)
@transform_return_vfs_unregister_arrow@
expression E;
identifier FP_NAME = vfs_unregister;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_mutex_try(args);


// Transform return E->vmprintf(args) to direct call (only 1 candidate)
@transform_return_vmprintf_arrow@
expression E;
identifier FP_NAME = vmprintf;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_value_text16(args);


// Transform return E->vtab_collation(args) to direct call (only 1 candidate)
@transform_return_vtab_collation_arrow@
expression E;
identifier FP_NAME = vtab_collation;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_result_subtype(args);


// Transform return E->vtab_config(args) to direct call (only 1 candidate)
@transform_return_vtab_config_arrow@
expression E;
identifier FP_NAME = vtab_config;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_extended_errcode(args);


// Transform return E->vtab_distinct(args) to direct call (only 1 candidate)
@transform_return_vtab_distinct_arrow@
expression E;
identifier FP_NAME = vtab_distinct;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_value_frombind(args);


// Transform return E->vtab_nochange(args) to direct call (only 1 candidate)
@transform_return_vtab_nochange_arrow@
expression E;
identifier FP_NAME = vtab_nochange;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_bind_zeroblob64(args);


// Transform return E->vtab_on_conflict(args) to direct call (only 1 candidate)
@transform_return_vtab_on_conflict_arrow@
expression E;
identifier FP_NAME = vtab_on_conflict;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_log(args);


// Transform return E->wal_checkpoint(args) to direct call (only 1 candidate)
@transform_return_wal_checkpoint_arrow@
expression E;
identifier FP_NAME = wal_checkpoint;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_db_config(args);


// Transform return E->wal_hook(args) to direct call (only 1 candidate)
@transform_return_wal_hook_arrow@
expression E;
identifier FP_NAME = wal_hook;
expression list args;
@@
- return E->FP_NAME(args);
+ return sqlite3_db_mutex(args);


// Transform return E->xAccess(args) to if-chain with 4 candidates
@transform_return_xAccess_arrow@
expression E;
identifier FP_NAME = xAccess;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xAccess_signature, xAccess_signatures[xAccess_apndAccess_enum], sizeof(E->xAccess_signature)) == 0) {
+ return apndAccess(args);
+ }
+ else if (memcmp(E->xAccess_signature, xAccess_signatures[xAccess_memdbAccess_enum], sizeof(E->xAccess_signature)) == 0) {
+ return memdbAccess(args);
+ }
+ else if (memcmp(E->xAccess_signature, xAccess_signatures[xAccess_vfstraceAccess_enum], sizeof(E->xAccess_signature)) == 0) {
+ return vfstraceAccess(args);
+ }
+ else if (memcmp(E->xAccess_signature, xAccess_signatures[xAccess_unixAccess_enum], sizeof(E->xAccess_signature)) == 0) {
+ return unixAccess(args);
+ }


// Transform return E->xBegin(args) to if-chain with 4 candidates
@transform_return_xBegin_arrow@
expression E;
identifier FP_NAME = xBegin;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xBegin_signature, xBegin_signatures[xBegin_0_enum], sizeof(E->xBegin_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xBegin_signature, xBegin_signatures[xBegin_dbpageBegin_enum], sizeof(E->xBegin_signature)) == 0) {
+ return dbpageBegin(args);
+ }
+ else if (memcmp(E->xBegin_signature, xBegin_signatures[xBegin_fts3BeginMethod_enum], sizeof(E->xBegin_signature)) == 0) {
+ return fts3BeginMethod(args);
+ }
+ else if (memcmp(E->xBegin_signature, xBegin_signatures[xBegin_rtreeBeginTransaction_enum], sizeof(E->xBegin_signature)) == 0) {
+ return rtreeBeginTransaction(args);
+ }
+ else if (memcmp(E->xBegin_signature, xBegin_signatures[xBegin_zipfileBegin_enum], sizeof(E->xBegin_signature)) == 0) {
+ return zipfileBegin(args);
+ }


// Transform return E->xBestIndex(args) to if-chain with 16 candidates
@transform_return_xBestIndex_arrow@
expression E;
identifier FP_NAME = xBestIndex;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xBestIndex_signature, xBestIndex_signatures[xBestIndex_bytecodevtabBestIndex_enum], sizeof(E->xBestIndex_signature)) == 0) {
+ return bytecodevtabBestIndex(args);
+ }
+ else if (memcmp(E->xBestIndex_signature, xBestIndex_signatures[xBestIndex_completionBestIndex_enum], sizeof(E->xBestIndex_signature)) == 0) {
+ return completionBestIndex(args);
+ }
+ else if (memcmp(E->xBestIndex_signature, xBestIndex_signatures[xBestIndex_dbdataBestIndex_enum], sizeof(E->xBestIndex_signature)) == 0) {
+ return dbdataBestIndex(args);
+ }
+ else if (memcmp(E->xBestIndex_signature, xBestIndex_signatures[xBestIndex_dbpageBestIndex_enum], sizeof(E->xBestIndex_signature)) == 0) {
+ return dbpageBestIndex(args);
+ }
+ else if (memcmp(E->xBestIndex_signature, xBestIndex_signatures[xBestIndex_expertBestIndex_enum], sizeof(E->xBestIndex_signature)) == 0) {
+ return expertBestIndex(args);
+ }
+ else if (memcmp(E->xBestIndex_signature, xBestIndex_signatures[xBestIndex_fsdirBestIndex_enum], sizeof(E->xBestIndex_signature)) == 0) {
+ return fsdirBestIndex(args);
+ }
+ else if (memcmp(E->xBestIndex_signature, xBestIndex_signatures[xBestIndex_fts3BestIndexMethod_enum], sizeof(E->xBestIndex_signature)) == 0) {
+ return fts3BestIndexMethod(args);
+ }
+ else if (memcmp(E->xBestIndex_signature, xBestIndex_signatures[xBestIndex_fts3auxBestIndexMethod_enum], sizeof(E->xBestIndex_signature)) == 0) {
+ return fts3auxBestIndexMethod(args);
+ }
+ else if (memcmp(E->xBestIndex_signature, xBestIndex_signatures[xBestIndex_fts3tokBestIndexMethod_enum], sizeof(E->xBestIndex_signature)) == 0) {
+ return fts3tokBestIndexMethod(args);
+ }
+ else if (memcmp(E->xBestIndex_signature, xBestIndex_signatures[xBestIndex_jsonEachBestIndex_enum], sizeof(E->xBestIndex_signature)) == 0) {
+ return jsonEachBestIndex(args);
+ }
+ else if (memcmp(E->xBestIndex_signature, xBestIndex_signatures[xBestIndex_pragmaVtabBestIndex_enum], sizeof(E->xBestIndex_signature)) == 0) {
+ return pragmaVtabBestIndex(args);
+ }
+ else if (memcmp(E->xBestIndex_signature, xBestIndex_signatures[xBestIndex_rtreeBestIndex_enum], sizeof(E->xBestIndex_signature)) == 0) {
+ return rtreeBestIndex(args);
+ }
+ else if (memcmp(E->xBestIndex_signature, xBestIndex_signatures[xBestIndex_seriesBestIndex_enum], sizeof(E->xBestIndex_signature)) == 0) {
+ return seriesBestIndex(args);
+ }
+ else if (memcmp(E->xBestIndex_signature, xBestIndex_signatures[xBestIndex_statBestIndex_enum], sizeof(E->xBestIndex_signature)) == 0) {
+ return statBestIndex(args);
+ }
+ else if (memcmp(E->xBestIndex_signature, xBestIndex_signatures[xBestIndex_stmtBestIndex_enum], sizeof(E->xBestIndex_signature)) == 0) {
+ return stmtBestIndex(args);
+ }
+ else if (memcmp(E->xBestIndex_signature, xBestIndex_signatures[xBestIndex_zipfileBestIndex_enum], sizeof(E->xBestIndex_signature)) == 0) {
+ return zipfileBestIndex(args);
+ }


// Transform return E->xCachesize(args) to if-chain with 2 candidates
@transform_return_xCachesize_arrow@
expression E;
identifier FP_NAME = xCachesize;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xCachesize_signature, xCachesize_signatures[xCachesize_pcache1Cachesize_enum], sizeof(E->xCachesize_signature)) == 0) {
+ return pcache1Cachesize(args);
+ }
+ else if (memcmp(E->xCachesize_signature, xCachesize_signatures[xCachesize_pcachetraceCachesize_enum], sizeof(E->xCachesize_signature)) == 0) {
+ return pcachetraceCachesize(args);
+ }


// Transform return E->xCellSize(args) to if-chain with 4 candidates
@transform_return_xCellSize_arrow@
expression E;
identifier FP_NAME = xCellSize;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xCellSize_signature, xCellSize_signatures[xCellSize_cellSizePtr_enum], sizeof(E->xCellSize_signature)) == 0) {
+ return cellSizePtr(args);
+ }
+ else if (memcmp(E->xCellSize_signature, xCellSize_signatures[xCellSize_cellSizePtrIdxLeaf_enum], sizeof(E->xCellSize_signature)) == 0) {
+ return cellSizePtrIdxLeaf(args);
+ }
+ else if (memcmp(E->xCellSize_signature, xCellSize_signatures[xCellSize_cellSizePtrNoPayload_enum], sizeof(E->xCellSize_signature)) == 0) {
+ return cellSizePtrNoPayload(args);
+ }
+ else if (memcmp(E->xCellSize_signature, xCellSize_signatures[xCellSize_cellSizePtrTableLeaf_enum], sizeof(E->xCellSize_signature)) == 0) {
+ return cellSizePtrTableLeaf(args);
+ }


// Transform return E->xCheckReservedLock(args) to if-chain with 6 candidates
@transform_return_xCheckReservedLock_arrow@
expression E;
identifier FP_NAME = xCheckReservedLock;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xCheckReservedLock_signature, xCheckReservedLock_signatures[xCheckReservedLock_0_enum], sizeof(E->xCheckReservedLock_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xCheckReservedLock_signature, xCheckReservedLock_signatures[xCheckReservedLock_apndCheckReservedLock_enum], sizeof(E->xCheckReservedLock_signature)) == 0) {
+ return apndCheckReservedLock(args);
+ }
+ else if (memcmp(E->xCheckReservedLock_signature, xCheckReservedLock_signatures[xCheckReservedLock_recoverVfsCheckReservedLock_enum], sizeof(E->xCheckReservedLock_signature)) == 0) {
+ return recoverVfsCheckReservedLock(args);
+ }
+ else if (memcmp(E->xCheckReservedLock_signature, xCheckReservedLock_signatures[xCheckReservedLock_vfstraceCheckReservedLock_enum], sizeof(E->xCheckReservedLock_signature)) == 0) {
+ return vfstraceCheckReservedLock(args);
+ }
+ else if (memcmp(E->xCheckReservedLock_signature, xCheckReservedLock_signatures[xCheckReservedLock_unixCheckReservedLock_enum], sizeof(E->xCheckReservedLock_signature)) == 0) {
+ return unixCheckReservedLock(args);
+ }
+ else if (memcmp(E->xCheckReservedLock_signature, xCheckReservedLock_signatures[xCheckReservedLock_nolockCheckReservedLock_enum], sizeof(E->xCheckReservedLock_signature)) == 0) {
+ return nolockCheckReservedLock(args);
+ }
+ else if (memcmp(E->xCheckReservedLock_signature, xCheckReservedLock_signatures[xCheckReservedLock_dotlockCheckReservedLock_enum], sizeof(E->xCheckReservedLock_signature)) == 0) {
+ return dotlockCheckReservedLock(args);
+ }


// Transform return E->xClose(args) to if-chain with 27 candidates
@transform_return_xClose_arrow@
expression E;
identifier FP_NAME = xClose;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xClose_signature, xClose_signatures[xClose_apndClose_enum], sizeof(E->xClose_signature)) == 0) {
+ return apndClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_bytecodevtabClose_enum], sizeof(E->xClose_signature)) == 0) {
+ return bytecodevtabClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_completionClose_enum], sizeof(E->xClose_signature)) == 0) {
+ return completionClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_dbdataClose_enum], sizeof(E->xClose_signature)) == 0) {
+ return dbdataClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_dbpageClose_enum], sizeof(E->xClose_signature)) == 0) {
+ return dbpageClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_expertClose_enum], sizeof(E->xClose_signature)) == 0) {
+ return expertClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_fsdirClose_enum], sizeof(E->xClose_signature)) == 0) {
+ return fsdirClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_fts3CloseMethod_enum], sizeof(E->xClose_signature)) == 0) {
+ return fts3CloseMethod(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_fts3auxCloseMethod_enum], sizeof(E->xClose_signature)) == 0) {
+ return fts3auxCloseMethod(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_fts3tokCloseMethod_enum], sizeof(E->xClose_signature)) == 0) {
+ return fts3tokCloseMethod(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_jsonEachClose_enum], sizeof(E->xClose_signature)) == 0) {
+ return jsonEachClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_memdbClose_enum], sizeof(E->xClose_signature)) == 0) {
+ return memdbClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_memjrnlClose_enum], sizeof(E->xClose_signature)) == 0) {
+ return memjrnlClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_porterClose_enum], sizeof(E->xClose_signature)) == 0) {
+ return porterClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_pragmaVtabClose_enum], sizeof(E->xClose_signature)) == 0) {
+ return pragmaVtabClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_recoverVfsClose_enum], sizeof(E->xClose_signature)) == 0) {
+ return recoverVfsClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_rtreeClose_enum], sizeof(E->xClose_signature)) == 0) {
+ return rtreeClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_seriesClose_enum], sizeof(E->xClose_signature)) == 0) {
+ return seriesClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_simpleClose_enum], sizeof(E->xClose_signature)) == 0) {
+ return simpleClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_statClose_enum], sizeof(E->xClose_signature)) == 0) {
+ return statClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_stmtClose_enum], sizeof(E->xClose_signature)) == 0) {
+ return stmtClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_unicodeClose_enum], sizeof(E->xClose_signature)) == 0) {
+ return unicodeClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_vfstraceClose_enum], sizeof(E->xClose_signature)) == 0) {
+ return vfstraceClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_zipfileClose_enum], sizeof(E->xClose_signature)) == 0) {
+ return zipfileClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_unixClose_enum], sizeof(E->xClose_signature)) == 0) {
+ return unixClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_nolockClose_enum], sizeof(E->xClose_signature)) == 0) {
+ return nolockClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_dotlockClose_enum], sizeof(E->xClose_signature)) == 0) {
+ return dotlockClose(args);
+ }


// Transform return E->xColumn(args) to if-chain with 44 candidates
@transform_return_xColumn_arrow@
expression E;
identifier FP_NAME = xColumn;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_amatchColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ return amatchColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_binfoColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ return binfoColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_bytecodevtabColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ return bytecodevtabColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_carrayColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ return carrayColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_cidxColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ return cidxColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_closureColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ return closureColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_completionColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ return completionColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_csvtabColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ return csvtabColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_dbdataColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ return dbdataColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_dbpageColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ return dbpageColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_deltaparsevtabColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ return deltaparsevtabColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_echoColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ return echoColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_expertColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ return expertColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_explainColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ return explainColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_fsColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ return fsColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_fsdirColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ return fsdirColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_fstreeColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ return fstreeColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_fts3ColumnMethod_enum], sizeof(E->xColumn_signature)) == 0) {
+ return fts3ColumnMethod(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_fts3auxColumnMethod_enum], sizeof(E->xColumn_signature)) == 0) {
+ return fts3auxColumnMethod(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_fts3termColumnMethod_enum], sizeof(E->xColumn_signature)) == 0) {
+ return fts3termColumnMethod(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_fts3tokColumnMethod_enum], sizeof(E->xColumn_signature)) == 0) {
+ return fts3tokColumnMethod(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_fuzzerColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ return fuzzerColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_geopolyColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ return geopolyColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_intarrayColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ return intarrayColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_jsonEachColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ return jsonEachColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_memstatColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ return memstatColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_pragmaVtabColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ return pragmaVtabColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_prefixesColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ return prefixesColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_qpvtabColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ return qpvtabColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_rtreeColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ return rtreeColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_schemaColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ return schemaColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_seriesColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ return seriesColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_spellfix1Column_enum], sizeof(E->xColumn_signature)) == 0) {
+ return spellfix1Column(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_statColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ return statColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_stmtColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ return stmtColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_tclColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ return tclColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_tclvarColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ return tclvarColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_templatevtabColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ return templatevtabColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_unionColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ return unionColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_vlogColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ return vlogColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_vstattabColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ return vstattabColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_vtablogColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ return vtablogColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_wholenumberColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ return wholenumberColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_zipfileColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ return zipfileColumn(args);
+ }


// Transform return E->xCommit(args) to if-chain with 5 candidates
@transform_return_xCommit_arrow@
expression E;
identifier FP_NAME = xCommit;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xCommit_signature, xCommit_signatures[xCommit_0_enum], sizeof(E->xCommit_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xCommit_signature, xCommit_signatures[xCommit_echoCommit_enum], sizeof(E->xCommit_signature)) == 0) {
+ return echoCommit(args);
+ }
+ else if (memcmp(E->xCommit_signature, xCommit_signatures[xCommit_fts3CommitMethod_enum], sizeof(E->xCommit_signature)) == 0) {
+ return fts3CommitMethod(args);
+ }
+ else if (memcmp(E->xCommit_signature, xCommit_signatures[xCommit_rtreeEndTransaction_enum], sizeof(E->xCommit_signature)) == 0) {
+ return rtreeEndTransaction(args);
+ }
+ else if (memcmp(E->xCommit_signature, xCommit_signatures[xCommit_vtablogCommit_enum], sizeof(E->xCommit_signature)) == 0) {
+ return vtablogCommit(args);
+ }
+ else if (memcmp(E->xCommit_signature, xCommit_signatures[xCommit_zipfileCommit_enum], sizeof(E->xCommit_signature)) == 0) {
+ return zipfileCommit(args);
+ }


// Transform return E->xConnect(args) to if-chain with 44 candidates
@transform_return_xConnect_arrow@
expression E;
identifier FP_NAME = xConnect;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_amatchConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ return amatchConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_binfoConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ return binfoConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_bytecodevtabConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ return bytecodevtabConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_carrayConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ return carrayConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_cidxConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ return cidxConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_closureConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ return closureConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_completionConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ return completionConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_csvtabConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ return csvtabConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_dbdataConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ return dbdataConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_dbpageConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ return dbpageConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_deltaparsevtabConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ return deltaparsevtabConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_echoConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ return echoConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_expertConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ return expertConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_explainConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ return explainConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_fsConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ return fsConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_fsdirConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ return fsdirConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_fstreeConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ return fstreeConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_fts3ConnectMethod_enum], sizeof(E->xConnect_signature)) == 0) {
+ return fts3ConnectMethod(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_fts3auxConnectMethod_enum], sizeof(E->xConnect_signature)) == 0) {
+ return fts3auxConnectMethod(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_fts3termConnectMethod_enum], sizeof(E->xConnect_signature)) == 0) {
+ return fts3termConnectMethod(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_fts3tokConnectMethod_enum], sizeof(E->xConnect_signature)) == 0) {
+ return fts3tokConnectMethod(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_fuzzerConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ return fuzzerConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_geopolyConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ return geopolyConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_intarrayCreate_enum], sizeof(E->xConnect_signature)) == 0) {
+ return intarrayCreate(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_jsonEachConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ return jsonEachConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_memstatConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ return memstatConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_pragmaVtabConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ return pragmaVtabConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_prefixesConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ return prefixesConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_qpvtabConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ return qpvtabConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_rtreeConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ return rtreeConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_schemaCreate_enum], sizeof(E->xConnect_signature)) == 0) {
+ return schemaCreate(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_seriesConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ return seriesConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_spellfix1Connect_enum], sizeof(E->xConnect_signature)) == 0) {
+ return spellfix1Connect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_statConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ return statConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_stmtConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ return stmtConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_tclConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ return tclConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_tclvarConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ return tclvarConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_templatevtabConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ return templatevtabConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_unionConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ return unionConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_vlogConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ return vlogConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_vstattabConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ return vstattabConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_vtablogConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ return vtablogConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_wholenumberConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ return wholenumberConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_zipfileConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ return zipfileConnect(args);
+ }


// Transform return E->xCount(args) to if-chain with 3 candidates
@transform_return_xCount_arrow@
expression E;
identifier FP_NAME = xCount;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xCount_signature, xCount_signatures[xCount_sessionDiffCount_enum], sizeof(E->xCount_signature)) == 0) {
+ return sessionDiffCount(args);
+ }
+ else if (memcmp(E->xCount_signature, xCount_signatures[xCount_sessionPreupdateCount_enum], sizeof(E->xCount_signature)) == 0) {
+ return sessionPreupdateCount(args);
+ }
+ else if (memcmp(E->xCount_signature, xCount_signatures[xCount_sessionStat1Count_enum], sizeof(E->xCount_signature)) == 0) {
+ return sessionStat1Count(args);
+ }


// Transform return E->xCreate(args) to if-chain with 34 candidates
@transform_return_xCreate_arrow@
expression E;
identifier FP_NAME = xCreate;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_0_enum], sizeof(E->xCreate_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_amatchConnect_enum], sizeof(E->xCreate_signature)) == 0) {
+ return amatchConnect(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_closureConnect_enum], sizeof(E->xCreate_signature)) == 0) {
+ return closureConnect(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_csvtabCreate_enum], sizeof(E->xCreate_signature)) == 0) {
+ return csvtabCreate(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_dbpageConnect_enum], sizeof(E->xCreate_signature)) == 0) {
+ return dbpageConnect(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_echoCreate_enum], sizeof(E->xCreate_signature)) == 0) {
+ return echoCreate(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_expertConnect_enum], sizeof(E->xCreate_signature)) == 0) {
+ return expertConnect(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_f5tOrigintextCreate_enum], sizeof(E->xCreate_signature)) == 0) {
+ return f5tOrigintextCreate(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_f5tTokenizerCreate_enum], sizeof(E->xCreate_signature)) == 0) {
+ return f5tTokenizerCreate(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_fsConnect_enum], sizeof(E->xCreate_signature)) == 0) {
+ return fsConnect(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_fsdirConnect_enum], sizeof(E->xCreate_signature)) == 0) {
+ return fsdirConnect(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_fstreeConnect_enum], sizeof(E->xCreate_signature)) == 0) {
+ return fstreeConnect(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_fts3CreateMethod_enum], sizeof(E->xCreate_signature)) == 0) {
+ return fts3CreateMethod(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_fts3auxConnectMethod_enum], sizeof(E->xCreate_signature)) == 0) {
+ return fts3auxConnectMethod(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_fts3termConnectMethod_enum], sizeof(E->xCreate_signature)) == 0) {
+ return fts3termConnectMethod(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_fts3tokConnectMethod_enum], sizeof(E->xCreate_signature)) == 0) {
+ return fts3tokConnectMethod(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_fuzzerConnect_enum], sizeof(E->xCreate_signature)) == 0) {
+ return fuzzerConnect(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_geopolyCreate_enum], sizeof(E->xCreate_signature)) == 0) {
+ return geopolyCreate(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_intarrayCreate_enum], sizeof(E->xCreate_signature)) == 0) {
+ return intarrayCreate(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_pcache1Create_enum], sizeof(E->xCreate_signature)) == 0) {
+ return pcache1Create(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_pcachetraceCreate_enum], sizeof(E->xCreate_signature)) == 0) {
+ return pcachetraceCreate(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_porterCreate_enum], sizeof(E->xCreate_signature)) == 0) {
+ return porterCreate(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_rtreeCreate_enum], sizeof(E->xCreate_signature)) == 0) {
+ return rtreeCreate(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_schemaCreate_enum], sizeof(E->xCreate_signature)) == 0) {
+ return schemaCreate(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_simpleCreate_enum], sizeof(E->xCreate_signature)) == 0) {
+ return simpleCreate(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_spellfix1Create_enum], sizeof(E->xCreate_signature)) == 0) {
+ return spellfix1Create(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_statConnect_enum], sizeof(E->xCreate_signature)) == 0) {
+ return statConnect(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_tclConnect_enum], sizeof(E->xCreate_signature)) == 0) {
+ return tclConnect(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_tclvarConnect_enum], sizeof(E->xCreate_signature)) == 0) {
+ return tclvarConnect(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_unicodeCreate_enum], sizeof(E->xCreate_signature)) == 0) {
+ return unicodeCreate(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_unionConnect_enum], sizeof(E->xCreate_signature)) == 0) {
+ return unionConnect(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_vlogConnect_enum], sizeof(E->xCreate_signature)) == 0) {
+ return vlogConnect(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_vtablogCreate_enum], sizeof(E->xCreate_signature)) == 0) {
+ return vtablogCreate(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_wholenumberConnect_enum], sizeof(E->xCreate_signature)) == 0) {
+ return wholenumberConnect(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_zipfileConnect_enum], sizeof(E->xCreate_signature)) == 0) {
+ return zipfileConnect(args);
+ }


// Transform return E->xCurrentTime(args) to if-chain with 3 candidates
@transform_return_xCurrentTime_arrow@
expression E;
identifier FP_NAME = xCurrentTime;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xCurrentTime_signature, xCurrentTime_signatures[xCurrentTime_0_enum], sizeof(E->xCurrentTime_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xCurrentTime_signature, xCurrentTime_signatures[xCurrentTime_apndCurrentTime_enum], sizeof(E->xCurrentTime_signature)) == 0) {
+ return apndCurrentTime(args);
+ }
+ else if (memcmp(E->xCurrentTime_signature, xCurrentTime_signatures[xCurrentTime_vfstraceCurrentTime_enum], sizeof(E->xCurrentTime_signature)) == 0) {
+ return vfstraceCurrentTime(args);
+ }
+ else if (memcmp(E->xCurrentTime_signature, xCurrentTime_signatures[xCurrentTime_unixCurrentTime_enum], sizeof(E->xCurrentTime_signature)) == 0) {
+ return unixCurrentTime(args);
+ }


// Transform return E->xCurrentTimeInt64(args) to if-chain with 3 candidates
@transform_return_xCurrentTimeInt64_arrow@
expression E;
identifier FP_NAME = xCurrentTimeInt64;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xCurrentTimeInt64_signature, xCurrentTimeInt64_signatures[xCurrentTimeInt64_0_enum], sizeof(E->xCurrentTimeInt64_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xCurrentTimeInt64_signature, xCurrentTimeInt64_signatures[xCurrentTimeInt64_apndCurrentTimeInt64_enum], sizeof(E->xCurrentTimeInt64_signature)) == 0) {
+ return apndCurrentTimeInt64(args);
+ }
+ else if (memcmp(E->xCurrentTimeInt64_signature, xCurrentTimeInt64_signatures[xCurrentTimeInt64_memdbCurrentTimeInt64_enum], sizeof(E->xCurrentTimeInt64_signature)) == 0) {
+ return memdbCurrentTimeInt64(args);
+ }
+ else if (memcmp(E->xCurrentTimeInt64_signature, xCurrentTimeInt64_signatures[xCurrentTimeInt64_unixCurrentTimeInt64_enum], sizeof(E->xCurrentTimeInt64_signature)) == 0) {
+ return unixCurrentTimeInt64(args);
+ }


// Transform return E->xDel(args) to if-chain with 3 candidates
@transform_return_xDel_arrow@
expression E;
identifier FP_NAME = xDel;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xDel_signature, xDel_signatures[xDel_0_enum], sizeof(E->xDel_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xDel_signature, xDel_signatures[xDel_sqlite3RowSetDelete_enum], sizeof(E->xDel_signature)) == 0) {
+ return sqlite3RowSetDelete(args);
+ }
+ else if (memcmp(E->xDel_signature, xDel_signatures[xDel_sqlite3VdbeFrameMemDel_enum], sizeof(E->xDel_signature)) == 0) {
+ return sqlite3VdbeFrameMemDel(args);
+ }
+ else if (memcmp(E->xDel_signature, xDel_signatures[xDel_sqlite3_free_enum], sizeof(E->xDel_signature)) == 0) {
+ return sqlite3_free(args);
+ }


// Transform return E->xDelete(args) to if-chain with 6 candidates
@transform_return_xDelete_arrow@
expression E;
identifier FP_NAME = xDelete;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xDelete_signature, xDelete_signatures[xDelete_0_enum], sizeof(E->xDelete_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xDelete_signature, xDelete_signatures[xDelete_apndDelete_enum], sizeof(E->xDelete_signature)) == 0) {
+ return apndDelete(args);
+ }
+ else if (memcmp(E->xDelete_signature, xDelete_signatures[xDelete_f5tOrigintextDelete_enum], sizeof(E->xDelete_signature)) == 0) {
+ return f5tOrigintextDelete(args);
+ }
+ else if (memcmp(E->xDelete_signature, xDelete_signatures[xDelete_f5tTokenizerDelete_enum], sizeof(E->xDelete_signature)) == 0) {
+ return f5tTokenizerDelete(args);
+ }
+ else if (memcmp(E->xDelete_signature, xDelete_signatures[xDelete_kvstorageDelete_enum], sizeof(E->xDelete_signature)) == 0) {
+ return kvstorageDelete(args);
+ }
+ else if (memcmp(E->xDelete_signature, xDelete_signatures[xDelete_vfstraceDelete_enum], sizeof(E->xDelete_signature)) == 0) {
+ return vfstraceDelete(args);
+ }
+ else if (memcmp(E->xDelete_signature, xDelete_signatures[xDelete_unixDelete_enum], sizeof(E->xDelete_signature)) == 0) {
+ return unixDelete(args);
+ }


// Transform return E->xDepth(args) to if-chain with 3 candidates
@transform_return_xDepth_arrow@
expression E;
identifier FP_NAME = xDepth;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xDepth_signature, xDepth_signatures[xDepth_sessionDiffDepth_enum], sizeof(E->xDepth_signature)) == 0) {
+ return sessionDiffDepth(args);
+ }
+ else if (memcmp(E->xDepth_signature, xDepth_signatures[xDepth_sessionPreupdateDepth_enum], sizeof(E->xDepth_signature)) == 0) {
+ return sessionPreupdateDepth(args);
+ }
+ else if (memcmp(E->xDepth_signature, xDepth_signatures[xDepth_sessionStat1Depth_enum], sizeof(E->xDepth_signature)) == 0) {
+ return sessionStat1Depth(args);
+ }


// Transform return E->xDestroy(args) to if-chain with 14 candidates
@transform_return_xDestroy_arrow@
expression E;
identifier FP_NAME = xDestroy;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xDestroy_signature, xDestroy_signatures[xDestroy_0_enum], sizeof(E->xDestroy_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xDestroy_signature, xDestroy_signatures[xDestroy_dbpageDisconnect_enum], sizeof(E->xDestroy_signature)) == 0) {
+ return dbpageDisconnect(args);
+ }
+ else if (memcmp(E->xDestroy_signature, xDestroy_signatures[xDestroy_expertDisconnect_enum], sizeof(E->xDestroy_signature)) == 0) {
+ return expertDisconnect(args);
+ }
+ else if (memcmp(E->xDestroy_signature, xDestroy_signatures[xDestroy_fsdirDisconnect_enum], sizeof(E->xDestroy_signature)) == 0) {
+ return fsdirDisconnect(args);
+ }
+ else if (memcmp(E->xDestroy_signature, xDestroy_signatures[xDestroy_fts3DestroyMethod_enum], sizeof(E->xDestroy_signature)) == 0) {
+ return fts3DestroyMethod(args);
+ }
+ else if (memcmp(E->xDestroy_signature, xDestroy_signatures[xDestroy_fts3auxDisconnectMethod_enum], sizeof(E->xDestroy_signature)) == 0) {
+ return fts3auxDisconnectMethod(args);
+ }
+ else if (memcmp(E->xDestroy_signature, xDestroy_signatures[xDestroy_fts3tokDisconnectMethod_enum], sizeof(E->xDestroy_signature)) == 0) {
+ return fts3tokDisconnectMethod(args);
+ }
+ else if (memcmp(E->xDestroy_signature, xDestroy_signatures[xDestroy_pcache1Destroy_enum], sizeof(E->xDestroy_signature)) == 0) {
+ return pcache1Destroy(args);
+ }
+ else if (memcmp(E->xDestroy_signature, xDestroy_signatures[xDestroy_pcachetraceDestroy_enum], sizeof(E->xDestroy_signature)) == 0) {
+ return pcachetraceDestroy(args);
+ }
+ else if (memcmp(E->xDestroy_signature, xDestroy_signatures[xDestroy_porterDestroy_enum], sizeof(E->xDestroy_signature)) == 0) {
+ return porterDestroy(args);
+ }
+ else if (memcmp(E->xDestroy_signature, xDestroy_signatures[xDestroy_rtreeDestroy_enum], sizeof(E->xDestroy_signature)) == 0) {
+ return rtreeDestroy(args);
+ }
+ else if (memcmp(E->xDestroy_signature, xDestroy_signatures[xDestroy_simpleDestroy_enum], sizeof(E->xDestroy_signature)) == 0) {
+ return simpleDestroy(args);
+ }
+ else if (memcmp(E->xDestroy_signature, xDestroy_signatures[xDestroy_statDisconnect_enum], sizeof(E->xDestroy_signature)) == 0) {
+ return statDisconnect(args);
+ }
+ else if (memcmp(E->xDestroy_signature, xDestroy_signatures[xDestroy_unicodeDestroy_enum], sizeof(E->xDestroy_signature)) == 0) {
+ return unicodeDestroy(args);
+ }
+ else if (memcmp(E->xDestroy_signature, xDestroy_signatures[xDestroy_zipfileDisconnect_enum], sizeof(E->xDestroy_signature)) == 0) {
+ return zipfileDisconnect(args);
+ }


// Transform return E->xDeviceCharacteristics(args) to if-chain with 5 candidates
@transform_return_xDeviceCharacteristics_arrow@
expression E;
identifier FP_NAME = xDeviceCharacteristics;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xDeviceCharacteristics_signature, xDeviceCharacteristics_signatures[xDeviceCharacteristics_0_enum], sizeof(E->xDeviceCharacteristics_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xDeviceCharacteristics_signature, xDeviceCharacteristics_signatures[xDeviceCharacteristics_apndDeviceCharacteristics_enum], sizeof(E->xDeviceCharacteristics_signature)) == 0) {
+ return apndDeviceCharacteristics(args);
+ }
+ else if (memcmp(E->xDeviceCharacteristics_signature, xDeviceCharacteristics_signatures[xDeviceCharacteristics_memdbDeviceCharacteristics_enum], sizeof(E->xDeviceCharacteristics_signature)) == 0) {
+ return memdbDeviceCharacteristics(args);
+ }
+ else if (memcmp(E->xDeviceCharacteristics_signature, xDeviceCharacteristics_signatures[xDeviceCharacteristics_recoverVfsDeviceCharacteristics_enum], sizeof(E->xDeviceCharacteristics_signature)) == 0) {
+ return recoverVfsDeviceCharacteristics(args);
+ }
+ else if (memcmp(E->xDeviceCharacteristics_signature, xDeviceCharacteristics_signatures[xDeviceCharacteristics_vfstraceDeviceCharacteristics_enum], sizeof(E->xDeviceCharacteristics_signature)) == 0) {
+ return vfstraceDeviceCharacteristics(args);
+ }
+ else if (memcmp(E->xDeviceCharacteristics_signature, xDeviceCharacteristics_signatures[xDeviceCharacteristics_unixDeviceCharacteristics_enum], sizeof(E->xDeviceCharacteristics_signature)) == 0) {
+ return unixDeviceCharacteristics(args);
+ }


// Transform return E->xDisconnect(args) to if-chain with 16 candidates
@transform_return_xDisconnect_arrow@
expression E;
identifier FP_NAME = xDisconnect;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xDisconnect_signature, xDisconnect_signatures[xDisconnect_bytecodevtabDisconnect_enum], sizeof(E->xDisconnect_signature)) == 0) {
+ return bytecodevtabDisconnect(args);
+ }
+ else if (memcmp(E->xDisconnect_signature, xDisconnect_signatures[xDisconnect_completionDisconnect_enum], sizeof(E->xDisconnect_signature)) == 0) {
+ return completionDisconnect(args);
+ }
+ else if (memcmp(E->xDisconnect_signature, xDisconnect_signatures[xDisconnect_dbdataDisconnect_enum], sizeof(E->xDisconnect_signature)) == 0) {
+ return dbdataDisconnect(args);
+ }
+ else if (memcmp(E->xDisconnect_signature, xDisconnect_signatures[xDisconnect_dbpageDisconnect_enum], sizeof(E->xDisconnect_signature)) == 0) {
+ return dbpageDisconnect(args);
+ }
+ else if (memcmp(E->xDisconnect_signature, xDisconnect_signatures[xDisconnect_expertDisconnect_enum], sizeof(E->xDisconnect_signature)) == 0) {
+ return expertDisconnect(args);
+ }
+ else if (memcmp(E->xDisconnect_signature, xDisconnect_signatures[xDisconnect_fsdirDisconnect_enum], sizeof(E->xDisconnect_signature)) == 0) {
+ return fsdirDisconnect(args);
+ }
+ else if (memcmp(E->xDisconnect_signature, xDisconnect_signatures[xDisconnect_fts3DisconnectMethod_enum], sizeof(E->xDisconnect_signature)) == 0) {
+ return fts3DisconnectMethod(args);
+ }
+ else if (memcmp(E->xDisconnect_signature, xDisconnect_signatures[xDisconnect_fts3auxDisconnectMethod_enum], sizeof(E->xDisconnect_signature)) == 0) {
+ return fts3auxDisconnectMethod(args);
+ }
+ else if (memcmp(E->xDisconnect_signature, xDisconnect_signatures[xDisconnect_fts3tokDisconnectMethod_enum], sizeof(E->xDisconnect_signature)) == 0) {
+ return fts3tokDisconnectMethod(args);
+ }
+ else if (memcmp(E->xDisconnect_signature, xDisconnect_signatures[xDisconnect_jsonEachDisconnect_enum], sizeof(E->xDisconnect_signature)) == 0) {
+ return jsonEachDisconnect(args);
+ }
+ else if (memcmp(E->xDisconnect_signature, xDisconnect_signatures[xDisconnect_pragmaVtabDisconnect_enum], sizeof(E->xDisconnect_signature)) == 0) {
+ return pragmaVtabDisconnect(args);
+ }
+ else if (memcmp(E->xDisconnect_signature, xDisconnect_signatures[xDisconnect_rtreeDisconnect_enum], sizeof(E->xDisconnect_signature)) == 0) {
+ return rtreeDisconnect(args);
+ }
+ else if (memcmp(E->xDisconnect_signature, xDisconnect_signatures[xDisconnect_seriesDisconnect_enum], sizeof(E->xDisconnect_signature)) == 0) {
+ return seriesDisconnect(args);
+ }
+ else if (memcmp(E->xDisconnect_signature, xDisconnect_signatures[xDisconnect_statDisconnect_enum], sizeof(E->xDisconnect_signature)) == 0) {
+ return statDisconnect(args);
+ }
+ else if (memcmp(E->xDisconnect_signature, xDisconnect_signatures[xDisconnect_stmtDisconnect_enum], sizeof(E->xDisconnect_signature)) == 0) {
+ return stmtDisconnect(args);
+ }
+ else if (memcmp(E->xDisconnect_signature, xDisconnect_signatures[xDisconnect_zipfileDisconnect_enum], sizeof(E->xDisconnect_signature)) == 0) {
+ return zipfileDisconnect(args);
+ }


// Transform return E->xDlClose(args) to if-chain with 3 candidates
@transform_return_xDlClose_arrow@
expression E;
identifier FP_NAME = xDlClose;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xDlClose_signature, xDlClose_signatures[xDlClose_0_enum], sizeof(E->xDlClose_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xDlClose_signature, xDlClose_signatures[xDlClose_apndDlClose_enum], sizeof(E->xDlClose_signature)) == 0) {
+ return apndDlClose(args);
+ }
+ else if (memcmp(E->xDlClose_signature, xDlClose_signatures[xDlClose_memdbDlClose_enum], sizeof(E->xDlClose_signature)) == 0) {
+ return memdbDlClose(args);
+ }
+ else if (memcmp(E->xDlClose_signature, xDlClose_signatures[xDlClose_unixDlClose_enum], sizeof(E->xDlClose_signature)) == 0) {
+ return unixDlClose(args);
+ }


// Transform return E->xDlError(args) to if-chain with 3 candidates
@transform_return_xDlError_arrow@
expression E;
identifier FP_NAME = xDlError;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xDlError_signature, xDlError_signatures[xDlError_0_enum], sizeof(E->xDlError_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xDlError_signature, xDlError_signatures[xDlError_apndDlError_enum], sizeof(E->xDlError_signature)) == 0) {
+ return apndDlError(args);
+ }
+ else if (memcmp(E->xDlError_signature, xDlError_signatures[xDlError_memdbDlError_enum], sizeof(E->xDlError_signature)) == 0) {
+ return memdbDlError(args);
+ }
+ else if (memcmp(E->xDlError_signature, xDlError_signatures[xDlError_unixDlError_enum], sizeof(E->xDlError_signature)) == 0) {
+ return unixDlError(args);
+ }


// Transform return E->xDlOpen(args) to if-chain with 3 candidates
@transform_return_xDlOpen_arrow@
expression E;
identifier FP_NAME = xDlOpen;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xDlOpen_signature, xDlOpen_signatures[xDlOpen_apndDlOpen_enum], sizeof(E->xDlOpen_signature)) == 0) {
+ return apndDlOpen(args);
+ }
+ else if (memcmp(E->xDlOpen_signature, xDlOpen_signatures[xDlOpen_memdbDlOpen_enum], sizeof(E->xDlOpen_signature)) == 0) {
+ return memdbDlOpen(args);
+ }
+ else if (memcmp(E->xDlOpen_signature, xDlOpen_signatures[xDlOpen_unixDlOpen_enum], sizeof(E->xDlOpen_signature)) == 0) {
+ return unixDlOpen(args);
+ }


// Transform return E->xEof(args) to if-chain with 43 candidates
@transform_return_xEof_arrow@
expression E;
identifier FP_NAME = xEof;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xEof_signature, xEof_signatures[xEof_amatchEof_enum], sizeof(E->xEof_signature)) == 0) {
+ return amatchEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_binfoEof_enum], sizeof(E->xEof_signature)) == 0) {
+ return binfoEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_bytecodevtabEof_enum], sizeof(E->xEof_signature)) == 0) {
+ return bytecodevtabEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_carrayEof_enum], sizeof(E->xEof_signature)) == 0) {
+ return carrayEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_cidxEof_enum], sizeof(E->xEof_signature)) == 0) {
+ return cidxEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_closureEof_enum], sizeof(E->xEof_signature)) == 0) {
+ return closureEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_completionEof_enum], sizeof(E->xEof_signature)) == 0) {
+ return completionEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_csvtabEof_enum], sizeof(E->xEof_signature)) == 0) {
+ return csvtabEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_dbdataEof_enum], sizeof(E->xEof_signature)) == 0) {
+ return dbdataEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_dbpageEof_enum], sizeof(E->xEof_signature)) == 0) {
+ return dbpageEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_deltaparsevtabEof_enum], sizeof(E->xEof_signature)) == 0) {
+ return deltaparsevtabEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_echoEof_enum], sizeof(E->xEof_signature)) == 0) {
+ return echoEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_expertEof_enum], sizeof(E->xEof_signature)) == 0) {
+ return expertEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_explainEof_enum], sizeof(E->xEof_signature)) == 0) {
+ return explainEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_fsEof_enum], sizeof(E->xEof_signature)) == 0) {
+ return fsEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_fsdirEof_enum], sizeof(E->xEof_signature)) == 0) {
+ return fsdirEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_fstreeEof_enum], sizeof(E->xEof_signature)) == 0) {
+ return fstreeEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_fts3EofMethod_enum], sizeof(E->xEof_signature)) == 0) {
+ return fts3EofMethod(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_fts3auxEofMethod_enum], sizeof(E->xEof_signature)) == 0) {
+ return fts3auxEofMethod(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_fts3termEofMethod_enum], sizeof(E->xEof_signature)) == 0) {
+ return fts3termEofMethod(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_fts3tokEofMethod_enum], sizeof(E->xEof_signature)) == 0) {
+ return fts3tokEofMethod(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_fuzzerEof_enum], sizeof(E->xEof_signature)) == 0) {
+ return fuzzerEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_intarrayEof_enum], sizeof(E->xEof_signature)) == 0) {
+ return intarrayEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_jsonEachEof_enum], sizeof(E->xEof_signature)) == 0) {
+ return jsonEachEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_memstatEof_enum], sizeof(E->xEof_signature)) == 0) {
+ return memstatEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_pragmaVtabEof_enum], sizeof(E->xEof_signature)) == 0) {
+ return pragmaVtabEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_prefixesEof_enum], sizeof(E->xEof_signature)) == 0) {
+ return prefixesEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_qpvtabEof_enum], sizeof(E->xEof_signature)) == 0) {
+ return qpvtabEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_rtreeEof_enum], sizeof(E->xEof_signature)) == 0) {
+ return rtreeEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_schemaEof_enum], sizeof(E->xEof_signature)) == 0) {
+ return schemaEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_seriesEof_enum], sizeof(E->xEof_signature)) == 0) {
+ return seriesEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_spellfix1Eof_enum], sizeof(E->xEof_signature)) == 0) {
+ return spellfix1Eof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_statEof_enum], sizeof(E->xEof_signature)) == 0) {
+ return statEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_stmtEof_enum], sizeof(E->xEof_signature)) == 0) {
+ return stmtEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_tclEof_enum], sizeof(E->xEof_signature)) == 0) {
+ return tclEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_tclvarEof_enum], sizeof(E->xEof_signature)) == 0) {
+ return tclvarEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_templatevtabEof_enum], sizeof(E->xEof_signature)) == 0) {
+ return templatevtabEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_unionEof_enum], sizeof(E->xEof_signature)) == 0) {
+ return unionEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_vlogEof_enum], sizeof(E->xEof_signature)) == 0) {
+ return vlogEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_vstattabEof_enum], sizeof(E->xEof_signature)) == 0) {
+ return vstattabEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_vtablogEof_enum], sizeof(E->xEof_signature)) == 0) {
+ return vtablogEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_wholenumberEof_enum], sizeof(E->xEof_signature)) == 0) {
+ return wholenumberEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_zipfileEof_enum], sizeof(E->xEof_signature)) == 0) {
+ return zipfileEof(args);
+ }


// Transform return E->xExprCallback(args) to if-chain with 37 candidates
@transform_return_xExprCallback_arrow@
expression E;
identifier FP_NAME = xExprCallback;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_agginfoPersistExprCb_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ return agginfoPersistExprCb(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_aggregateIdxEprRefToColCallback_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ return aggregateIdxEprRefToColCallback(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_analyzeAggregate_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ return analyzeAggregate(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_checkConstraintExprNode_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ return checkConstraintExprNode(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_codeCursorHintCheckExpr_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ return codeCursorHintCheckExpr(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_codeCursorHintFixExpr_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ return codeCursorHintFixExpr(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_codeCursorHintIsOrFunction_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ return codeCursorHintIsOrFunction(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_disallowAggregatesInOrderByCb_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ return disallowAggregatesInOrderByCb(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprColumnFlagUnion_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ return exprColumnFlagUnion(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprIdxCover_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ return exprIdxCover(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprNodeCanReturnSubtype_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ return exprNodeCanReturnSubtype(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprNodeIsConstant_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ return exprNodeIsConstant(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprNodeIsConstantOrGroupBy_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ return exprNodeIsConstantOrGroupBy(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprNodeIsDeterministic_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ return exprNodeIsDeterministic(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprRefToSrcList_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ return exprRefToSrcList(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_fixExprCb_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ return fixExprCb(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_gatherSelectWindowsCallback_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ return gatherSelectWindowsCallback(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_havingToWhereExprCb_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ return havingToWhereExprCb(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_impliesNotNullRow_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ return impliesNotNullRow(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_incrAggDepth_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ return incrAggDepth(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_markImmutableExprStep_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ return markImmutableExprStep(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_propagateConstantExprRewrite_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ return propagateConstantExprRewrite(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_recomputeColumnsUsedExpr_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ return recomputeColumnsUsedExpr(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_renameColumnExprCb_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ return renameColumnExprCb(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_renameQuotefixExprCb_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ return renameQuotefixExprCb(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_renameTableExprCb_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ return renameTableExprCb(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_renameUnmapExprCb_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ return renameUnmapExprCb(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_renumberCursorsCb_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ return renumberCursorsCb(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_resolveExprStep_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ return resolveExprStep(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_resolveRemoveWindowsCb_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ return resolveRemoveWindowsCb(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_selectCheckOnClausesExpr_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ return selectCheckOnClausesExpr(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_selectWindowRewriteExprCb_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ return selectWindowRewriteExprCb(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_sqlite3CursorRangeHintExprCheck_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ return sqlite3CursorRangeHintExprCheck(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_sqlite3ExprWalkNoop_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ return sqlite3ExprWalkNoop(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_sqlite3ReturningSubqueryVarSelect_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ return sqlite3ReturningSubqueryVarSelect(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_sqlite3WindowExtraAggFuncDepth_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ return sqlite3WindowExtraAggFuncDepth(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_whereIsCoveringIndexWalkCallback_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ return whereIsCoveringIndexWalkCallback(args);
+ }


// Transform return E->xFetch(args) to if-chain with 6 candidates
@transform_return_xFetch_arrow@
expression E;
identifier FP_NAME = xFetch;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xFetch_signature, xFetch_signatures[xFetch_0_enum], sizeof(E->xFetch_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xFetch_signature, xFetch_signatures[xFetch_apndFetch_enum], sizeof(E->xFetch_signature)) == 0) {
+ return apndFetch(args);
+ }
+ else if (memcmp(E->xFetch_signature, xFetch_signatures[xFetch_memdbFetch_enum], sizeof(E->xFetch_signature)) == 0) {
+ return memdbFetch(args);
+ }
+ else if (memcmp(E->xFetch_signature, xFetch_signatures[xFetch_pcache1Fetch_enum], sizeof(E->xFetch_signature)) == 0) {
+ return pcache1Fetch(args);
+ }
+ else if (memcmp(E->xFetch_signature, xFetch_signatures[xFetch_pcachetraceFetch_enum], sizeof(E->xFetch_signature)) == 0) {
+ return pcachetraceFetch(args);
+ }
+ else if (memcmp(E->xFetch_signature, xFetch_signatures[xFetch_recoverVfsFetch_enum], sizeof(E->xFetch_signature)) == 0) {
+ return recoverVfsFetch(args);
+ }
+ else if (memcmp(E->xFetch_signature, xFetch_signatures[xFetch_unixFetch_enum], sizeof(E->xFetch_signature)) == 0) {
+ return unixFetch(args);
+ }


// Transform return E->xFileControl(args) to if-chain with 5 candidates
@transform_return_xFileControl_arrow@
expression E;
identifier FP_NAME = xFileControl;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xFileControl_signature, xFileControl_signatures[xFileControl_0_enum], sizeof(E->xFileControl_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xFileControl_signature, xFileControl_signatures[xFileControl_apndFileControl_enum], sizeof(E->xFileControl_signature)) == 0) {
+ return apndFileControl(args);
+ }
+ else if (memcmp(E->xFileControl_signature, xFileControl_signatures[xFileControl_memdbFileControl_enum], sizeof(E->xFileControl_signature)) == 0) {
+ return memdbFileControl(args);
+ }
+ else if (memcmp(E->xFileControl_signature, xFileControl_signatures[xFileControl_recoverVfsFileControl_enum], sizeof(E->xFileControl_signature)) == 0) {
+ return recoverVfsFileControl(args);
+ }
+ else if (memcmp(E->xFileControl_signature, xFileControl_signatures[xFileControl_vfstraceFileControl_enum], sizeof(E->xFileControl_signature)) == 0) {
+ return vfstraceFileControl(args);
+ }
+ else if (memcmp(E->xFileControl_signature, xFileControl_signatures[xFileControl_unixFileControl_enum], sizeof(E->xFileControl_signature)) == 0) {
+ return unixFileControl(args);
+ }


// Transform return E->xFileSize(args) to if-chain with 6 candidates
@transform_return_xFileSize_arrow@
expression E;
identifier FP_NAME = xFileSize;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xFileSize_signature, xFileSize_signatures[xFileSize_apndFileSize_enum], sizeof(E->xFileSize_signature)) == 0) {
+ return apndFileSize(args);
+ }
+ else if (memcmp(E->xFileSize_signature, xFileSize_signatures[xFileSize_memdbFileSize_enum], sizeof(E->xFileSize_signature)) == 0) {
+ return memdbFileSize(args);
+ }
+ else if (memcmp(E->xFileSize_signature, xFileSize_signatures[xFileSize_memjrnlFileSize_enum], sizeof(E->xFileSize_signature)) == 0) {
+ return memjrnlFileSize(args);
+ }
+ else if (memcmp(E->xFileSize_signature, xFileSize_signatures[xFileSize_recoverVfsFileSize_enum], sizeof(E->xFileSize_signature)) == 0) {
+ return recoverVfsFileSize(args);
+ }
+ else if (memcmp(E->xFileSize_signature, xFileSize_signatures[xFileSize_vfstraceFileSize_enum], sizeof(E->xFileSize_signature)) == 0) {
+ return vfstraceFileSize(args);
+ }
+ else if (memcmp(E->xFileSize_signature, xFileSize_signatures[xFileSize_unixFileSize_enum], sizeof(E->xFileSize_signature)) == 0) {
+ return unixFileSize(args);
+ }


// Transform return E->xFilter(args) to if-chain with 44 candidates
@transform_return_xFilter_arrow@
expression E;
identifier FP_NAME = xFilter;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_amatchFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ return amatchFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_binfoFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ return binfoFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_bytecodevtabFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ return bytecodevtabFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_carrayFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ return carrayFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_cidxFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ return cidxFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_closureFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ return closureFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_completionFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ return completionFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_csvtabFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ return csvtabFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_dbdataFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ return dbdataFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_dbpageFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ return dbpageFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_deltaparsevtabFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ return deltaparsevtabFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_echoFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ return echoFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_expertFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ return expertFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_explainFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ return explainFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_fsFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ return fsFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_fsdirFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ return fsdirFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_fstreeFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ return fstreeFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_fts3FilterMethod_enum], sizeof(E->xFilter_signature)) == 0) {
+ return fts3FilterMethod(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_fts3auxFilterMethod_enum], sizeof(E->xFilter_signature)) == 0) {
+ return fts3auxFilterMethod(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_fts3termFilterMethod_enum], sizeof(E->xFilter_signature)) == 0) {
+ return fts3termFilterMethod(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_fts3tokFilterMethod_enum], sizeof(E->xFilter_signature)) == 0) {
+ return fts3tokFilterMethod(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_fuzzerFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ return fuzzerFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_geopolyFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ return geopolyFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_intarrayFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ return intarrayFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_jsonEachFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ return jsonEachFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_memstatFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ return memstatFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_pragmaVtabFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ return pragmaVtabFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_prefixesFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ return prefixesFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_qpvtabFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ return qpvtabFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_rtreeFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ return rtreeFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_schemaFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ return schemaFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_seriesFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ return seriesFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_spellfix1Filter_enum], sizeof(E->xFilter_signature)) == 0) {
+ return spellfix1Filter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_statFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ return statFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_stmtFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ return stmtFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_tclFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ return tclFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_tclvarFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ return tclvarFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_templatevtabFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ return templatevtabFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_unionFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ return unionFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_vlogFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ return vlogFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_vstattabFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ return vstattabFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_vtablogFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ return vtablogFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_wholenumberFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ return wholenumberFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_zipfileFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ return zipfileFilter(args);
+ }


// Transform return E->xFindFunction(args) to if-chain with 2 candidates
@transform_return_xFindFunction_arrow@
expression E;
identifier FP_NAME = xFindFunction;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xFindFunction_signature, xFindFunction_signatures[xFindFunction_0_enum], sizeof(E->xFindFunction_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xFindFunction_signature, xFindFunction_signatures[xFindFunction_fts3FindFunctionMethod_enum], sizeof(E->xFindFunction_signature)) == 0) {
+ return fts3FindFunctionMethod(args);
+ }
+ else if (memcmp(E->xFindFunction_signature, xFindFunction_signatures[xFindFunction_zipfileFindFunction_enum], sizeof(E->xFindFunction_signature)) == 0) {
+ return zipfileFindFunction(args);
+ }


// Transform return E->xFree(args) to if-chain with 2 candidates
@transform_return_xFree_arrow@
expression E;
identifier FP_NAME = xFree;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xFree_signature, xFree_signatures[xFree_memtraceFree_enum], sizeof(E->xFree_signature)) == 0) {
+ return memtraceFree(args);
+ }
+ else if (memcmp(E->xFree_signature, xFree_signatures[xFree_sqlite3MemFree_enum], sizeof(E->xFree_signature)) == 0) {
+ return sqlite3MemFree(args);
+ }


// Transform return E->xFullPathname(args) to if-chain with 4 candidates
@transform_return_xFullPathname_arrow@
expression E;
identifier FP_NAME = xFullPathname;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xFullPathname_signature, xFullPathname_signatures[xFullPathname_apndFullPathname_enum], sizeof(E->xFullPathname_signature)) == 0) {
+ return apndFullPathname(args);
+ }
+ else if (memcmp(E->xFullPathname_signature, xFullPathname_signatures[xFullPathname_memdbFullPathname_enum], sizeof(E->xFullPathname_signature)) == 0) {
+ return memdbFullPathname(args);
+ }
+ else if (memcmp(E->xFullPathname_signature, xFullPathname_signatures[xFullPathname_vfstraceFullPathname_enum], sizeof(E->xFullPathname_signature)) == 0) {
+ return vfstraceFullPathname(args);
+ }
+ else if (memcmp(E->xFullPathname_signature, xFullPathname_signatures[xFullPathname_unixFullPathname_enum], sizeof(E->xFullPathname_signature)) == 0) {
+ return unixFullPathname(args);
+ }


// Transform return E->xGet(args) to if-chain with 3 candidates
@transform_return_xGet_arrow@
expression E;
identifier FP_NAME = xGet;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xGet_signature, xGet_signatures[xGet_getPageError_enum], sizeof(E->xGet_signature)) == 0) {
+ return getPageError(args);
+ }
+ else if (memcmp(E->xGet_signature, xGet_signatures[xGet_getPageMMap_enum], sizeof(E->xGet_signature)) == 0) {
+ return getPageMMap(args);
+ }
+ else if (memcmp(E->xGet_signature, xGet_signatures[xGet_getPageNormal_enum], sizeof(E->xGet_signature)) == 0) {
+ return getPageNormal(args);
+ }


// Transform return E->xGetLastError(args) to if-chain with 3 candidates
@transform_return_xGetLastError_arrow@
expression E;
identifier FP_NAME = xGetLastError;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xGetLastError_signature, xGetLastError_signatures[xGetLastError_0_enum], sizeof(E->xGetLastError_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xGetLastError_signature, xGetLastError_signatures[xGetLastError_apndGetLastError_enum], sizeof(E->xGetLastError_signature)) == 0) {
+ return apndGetLastError(args);
+ }
+ else if (memcmp(E->xGetLastError_signature, xGetLastError_signatures[xGetLastError_memdbGetLastError_enum], sizeof(E->xGetLastError_signature)) == 0) {
+ return memdbGetLastError(args);
+ }
+ else if (memcmp(E->xGetLastError_signature, xGetLastError_signatures[xGetLastError_unixGetLastError_enum], sizeof(E->xGetLastError_signature)) == 0) {
+ return unixGetLastError(args);
+ }


// Transform return E->xGetSystemCall(args) to if-chain with 2 candidates
@transform_return_xGetSystemCall_arrow@
expression E;
identifier FP_NAME = xGetSystemCall;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xGetSystemCall_signature, xGetSystemCall_signatures[xGetSystemCall_0_enum], sizeof(E->xGetSystemCall_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xGetSystemCall_signature, xGetSystemCall_signatures[xGetSystemCall_apndGetSystemCall_enum], sizeof(E->xGetSystemCall_signature)) == 0) {
+ return apndGetSystemCall(args);
+ }
+ else if (memcmp(E->xGetSystemCall_signature, xGetSystemCall_signatures[xGetSystemCall_unixGetSystemCall_enum], sizeof(E->xGetSystemCall_signature)) == 0) {
+ return unixGetSystemCall(args);
+ }


// Transform return E->xInit(args) to if-chain with 4 candidates
@transform_return_xInit_arrow@
expression E;
identifier FP_NAME = xInit;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xInit_signature, xInit_signatures[xInit_memtraceInit_enum], sizeof(E->xInit_signature)) == 0) {
+ return memtraceInit(args);
+ }
+ else if (memcmp(E->xInit_signature, xInit_signatures[xInit_pcache1Init_enum], sizeof(E->xInit_signature)) == 0) {
+ return pcache1Init(args);
+ }
+ else if (memcmp(E->xInit_signature, xInit_signatures[xInit_pcachetraceInit_enum], sizeof(E->xInit_signature)) == 0) {
+ return pcachetraceInit(args);
+ }
+ else if (memcmp(E->xInit_signature, xInit_signatures[xInit_sqlite3MemInit_enum], sizeof(E->xInit_signature)) == 0) {
+ return sqlite3MemInit(args);
+ }


// Transform return E->xIntegrity(args) to if-chain with 3 candidates
@transform_return_xIntegrity_arrow@
expression E;
identifier FP_NAME = xIntegrity;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xIntegrity_signature, xIntegrity_signatures[xIntegrity_0_enum], sizeof(E->xIntegrity_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xIntegrity_signature, xIntegrity_signatures[xIntegrity_fts3IntegrityMethod_enum], sizeof(E->xIntegrity_signature)) == 0) {
+ return fts3IntegrityMethod(args);
+ }
+ else if (memcmp(E->xIntegrity_signature, xIntegrity_signatures[xIntegrity_rtreeIntegrity_enum], sizeof(E->xIntegrity_signature)) == 0) {
+ return rtreeIntegrity(args);
+ }
+ else if (memcmp(E->xIntegrity_signature, xIntegrity_signatures[xIntegrity_vtablogIntegrity_enum], sizeof(E->xIntegrity_signature)) == 0) {
+ return vtablogIntegrity(args);
+ }


// Transform return E->xLock(args) to if-chain with 7 candidates
@transform_return_xLock_arrow@
expression E;
identifier FP_NAME = xLock;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xLock_signature, xLock_signatures[xLock_0_enum], sizeof(E->xLock_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xLock_signature, xLock_signatures[xLock_apndLock_enum], sizeof(E->xLock_signature)) == 0) {
+ return apndLock(args);
+ }
+ else if (memcmp(E->xLock_signature, xLock_signatures[xLock_memdbLock_enum], sizeof(E->xLock_signature)) == 0) {
+ return memdbLock(args);
+ }
+ else if (memcmp(E->xLock_signature, xLock_signatures[xLock_recoverVfsLock_enum], sizeof(E->xLock_signature)) == 0) {
+ return recoverVfsLock(args);
+ }
+ else if (memcmp(E->xLock_signature, xLock_signatures[xLock_vfstraceLock_enum], sizeof(E->xLock_signature)) == 0) {
+ return vfstraceLock(args);
+ }
+ else if (memcmp(E->xLock_signature, xLock_signatures[xLock_unixLock_enum], sizeof(E->xLock_signature)) == 0) {
+ return unixLock(args);
+ }
+ else if (memcmp(E->xLock_signature, xLock_signatures[xLock_nolockLock_enum], sizeof(E->xLock_signature)) == 0) {
+ return nolockLock(args);
+ }
+ else if (memcmp(E->xLock_signature, xLock_signatures[xLock_dotlockLock_enum], sizeof(E->xLock_signature)) == 0) {
+ return dotlockLock(args);
+ }


// Transform return E->xMalloc(args) to if-chain with 2 candidates
@transform_return_xMalloc_arrow@
expression E;
identifier FP_NAME = xMalloc;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xMalloc_signature, xMalloc_signatures[xMalloc_memtraceMalloc_enum], sizeof(E->xMalloc_signature)) == 0) {
+ return memtraceMalloc(args);
+ }
+ else if (memcmp(E->xMalloc_signature, xMalloc_signatures[xMalloc_sqlite3MemMalloc_enum], sizeof(E->xMalloc_signature)) == 0) {
+ return sqlite3MemMalloc(args);
+ }


// Transform return E->xMutexAlloc(args) to if-chain with 7 candidates
@transform_return_xMutexAlloc_arrow@
expression E;
identifier FP_NAME = xMutexAlloc;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_checkMutexAlloc_enum], sizeof(E->xMutexAlloc_signature)) == 0) {
+ return checkMutexAlloc(args);
+ }
+ else if (memcmp(E->xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_counterMutexAlloc_enum], sizeof(E->xMutexAlloc_signature)) == 0) {
+ return counterMutexAlloc(args);
+ }
+ else if (memcmp(E->xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_debugMutexAlloc_enum], sizeof(E->xMutexAlloc_signature)) == 0) {
+ return debugMutexAlloc(args);
+ }
+ else if (memcmp(E->xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_noopMutexAlloc_enum], sizeof(E->xMutexAlloc_signature)) == 0) {
+ return noopMutexAlloc(args);
+ }
+ else if (memcmp(E->xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_pthreadMutexAlloc_enum], sizeof(E->xMutexAlloc_signature)) == 0) {
+ return pthreadMutexAlloc(args);
+ }
+ else if (memcmp(E->xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_winMutexAlloc_enum], sizeof(E->xMutexAlloc_signature)) == 0) {
+ return winMutexAlloc(args);
+ }
+ else if (memcmp(E->xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_wrMutexAlloc_enum], sizeof(E->xMutexAlloc_signature)) == 0) {
+ return wrMutexAlloc(args);
+ }


// Transform return E->xMutexEnd(args) to if-chain with 7 candidates
@transform_return_xMutexEnd_arrow@
expression E;
identifier FP_NAME = xMutexEnd;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_checkMutexEnd_enum], sizeof(E->xMutexEnd_signature)) == 0) {
+ return checkMutexEnd(args);
+ }
+ else if (memcmp(E->xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_counterMutexEnd_enum], sizeof(E->xMutexEnd_signature)) == 0) {
+ return counterMutexEnd(args);
+ }
+ else if (memcmp(E->xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_debugMutexEnd_enum], sizeof(E->xMutexEnd_signature)) == 0) {
+ return debugMutexEnd(args);
+ }
+ else if (memcmp(E->xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_noopMutexEnd_enum], sizeof(E->xMutexEnd_signature)) == 0) {
+ return noopMutexEnd(args);
+ }
+ else if (memcmp(E->xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_pthreadMutexEnd_enum], sizeof(E->xMutexEnd_signature)) == 0) {
+ return pthreadMutexEnd(args);
+ }
+ else if (memcmp(E->xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_winMutexEnd_enum], sizeof(E->xMutexEnd_signature)) == 0) {
+ return winMutexEnd(args);
+ }
+ else if (memcmp(E->xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_wrMutexEnd_enum], sizeof(E->xMutexEnd_signature)) == 0) {
+ return wrMutexEnd(args);
+ }


// Transform return E->xMutexEnter(args) to if-chain with 7 candidates
@transform_return_xMutexEnter_arrow@
expression E;
identifier FP_NAME = xMutexEnter;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_checkMutexEnter_enum], sizeof(E->xMutexEnter_signature)) == 0) {
+ return checkMutexEnter(args);
+ }
+ else if (memcmp(E->xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_counterMutexEnter_enum], sizeof(E->xMutexEnter_signature)) == 0) {
+ return counterMutexEnter(args);
+ }
+ else if (memcmp(E->xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_debugMutexEnter_enum], sizeof(E->xMutexEnter_signature)) == 0) {
+ return debugMutexEnter(args);
+ }
+ else if (memcmp(E->xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_noopMutexEnter_enum], sizeof(E->xMutexEnter_signature)) == 0) {
+ return noopMutexEnter(args);
+ }
+ else if (memcmp(E->xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_pthreadMutexEnter_enum], sizeof(E->xMutexEnter_signature)) == 0) {
+ return pthreadMutexEnter(args);
+ }
+ else if (memcmp(E->xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_winMutexEnter_enum], sizeof(E->xMutexEnter_signature)) == 0) {
+ return winMutexEnter(args);
+ }
+ else if (memcmp(E->xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_wrMutexEnter_enum], sizeof(E->xMutexEnter_signature)) == 0) {
+ return wrMutexEnter(args);
+ }


// Transform return E->xMutexFree(args) to if-chain with 7 candidates
@transform_return_xMutexFree_arrow@
expression E;
identifier FP_NAME = xMutexFree;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xMutexFree_signature, xMutexFree_signatures[xMutexFree_checkMutexFree_enum], sizeof(E->xMutexFree_signature)) == 0) {
+ return checkMutexFree(args);
+ }
+ else if (memcmp(E->xMutexFree_signature, xMutexFree_signatures[xMutexFree_counterMutexFree_enum], sizeof(E->xMutexFree_signature)) == 0) {
+ return counterMutexFree(args);
+ }
+ else if (memcmp(E->xMutexFree_signature, xMutexFree_signatures[xMutexFree_debugMutexFree_enum], sizeof(E->xMutexFree_signature)) == 0) {
+ return debugMutexFree(args);
+ }
+ else if (memcmp(E->xMutexFree_signature, xMutexFree_signatures[xMutexFree_noopMutexFree_enum], sizeof(E->xMutexFree_signature)) == 0) {
+ return noopMutexFree(args);
+ }
+ else if (memcmp(E->xMutexFree_signature, xMutexFree_signatures[xMutexFree_pthreadMutexFree_enum], sizeof(E->xMutexFree_signature)) == 0) {
+ return pthreadMutexFree(args);
+ }
+ else if (memcmp(E->xMutexFree_signature, xMutexFree_signatures[xMutexFree_winMutexFree_enum], sizeof(E->xMutexFree_signature)) == 0) {
+ return winMutexFree(args);
+ }
+ else if (memcmp(E->xMutexFree_signature, xMutexFree_signatures[xMutexFree_wrMutexFree_enum], sizeof(E->xMutexFree_signature)) == 0) {
+ return wrMutexFree(args);
+ }


// Transform return E->xMutexHeld(args) to if-chain with 3 candidates
@transform_return_xMutexHeld_arrow@
expression E;
identifier FP_NAME = xMutexHeld;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xMutexHeld_signature, xMutexHeld_signatures[xMutexHeld_0_enum], sizeof(E->xMutexHeld_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xMutexHeld_signature, xMutexHeld_signatures[xMutexHeld_counterMutexHeld_enum], sizeof(E->xMutexHeld_signature)) == 0) {
+ return counterMutexHeld(args);
+ }
+ else if (memcmp(E->xMutexHeld_signature, xMutexHeld_signatures[xMutexHeld_debugMutexHeld_enum], sizeof(E->xMutexHeld_signature)) == 0) {
+ return debugMutexHeld(args);
+ }
+ else if (memcmp(E->xMutexHeld_signature, xMutexHeld_signatures[xMutexHeld_wrMutexHeld_enum], sizeof(E->xMutexHeld_signature)) == 0) {
+ return wrMutexHeld(args);
+ }


// Transform return E->xMutexInit(args) to if-chain with 7 candidates
@transform_return_xMutexInit_arrow@
expression E;
identifier FP_NAME = xMutexInit;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xMutexInit_signature, xMutexInit_signatures[xMutexInit_checkMutexInit_enum], sizeof(E->xMutexInit_signature)) == 0) {
+ return checkMutexInit(args);
+ }
+ else if (memcmp(E->xMutexInit_signature, xMutexInit_signatures[xMutexInit_counterMutexInit_enum], sizeof(E->xMutexInit_signature)) == 0) {
+ return counterMutexInit(args);
+ }
+ else if (memcmp(E->xMutexInit_signature, xMutexInit_signatures[xMutexInit_debugMutexInit_enum], sizeof(E->xMutexInit_signature)) == 0) {
+ return debugMutexInit(args);
+ }
+ else if (memcmp(E->xMutexInit_signature, xMutexInit_signatures[xMutexInit_noopMutexInit_enum], sizeof(E->xMutexInit_signature)) == 0) {
+ return noopMutexInit(args);
+ }
+ else if (memcmp(E->xMutexInit_signature, xMutexInit_signatures[xMutexInit_pthreadMutexInit_enum], sizeof(E->xMutexInit_signature)) == 0) {
+ return pthreadMutexInit(args);
+ }
+ else if (memcmp(E->xMutexInit_signature, xMutexInit_signatures[xMutexInit_winMutexInit_enum], sizeof(E->xMutexInit_signature)) == 0) {
+ return winMutexInit(args);
+ }
+ else if (memcmp(E->xMutexInit_signature, xMutexInit_signatures[xMutexInit_wrMutexInit_enum], sizeof(E->xMutexInit_signature)) == 0) {
+ return wrMutexInit(args);
+ }


// Transform return E->xMutexLeave(args) to if-chain with 7 candidates
@transform_return_xMutexLeave_arrow@
expression E;
identifier FP_NAME = xMutexLeave;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_checkMutexLeave_enum], sizeof(E->xMutexLeave_signature)) == 0) {
+ return checkMutexLeave(args);
+ }
+ else if (memcmp(E->xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_counterMutexLeave_enum], sizeof(E->xMutexLeave_signature)) == 0) {
+ return counterMutexLeave(args);
+ }
+ else if (memcmp(E->xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_debugMutexLeave_enum], sizeof(E->xMutexLeave_signature)) == 0) {
+ return debugMutexLeave(args);
+ }
+ else if (memcmp(E->xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_noopMutexLeave_enum], sizeof(E->xMutexLeave_signature)) == 0) {
+ return noopMutexLeave(args);
+ }
+ else if (memcmp(E->xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_pthreadMutexLeave_enum], sizeof(E->xMutexLeave_signature)) == 0) {
+ return pthreadMutexLeave(args);
+ }
+ else if (memcmp(E->xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_winMutexLeave_enum], sizeof(E->xMutexLeave_signature)) == 0) {
+ return winMutexLeave(args);
+ }
+ else if (memcmp(E->xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_wrMutexLeave_enum], sizeof(E->xMutexLeave_signature)) == 0) {
+ return wrMutexLeave(args);
+ }


// Transform return E->xMutexNotheld(args) to if-chain with 3 candidates
@transform_return_xMutexNotheld_arrow@
expression E;
identifier FP_NAME = xMutexNotheld;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xMutexNotheld_signature, xMutexNotheld_signatures[xMutexNotheld_0_enum], sizeof(E->xMutexNotheld_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xMutexNotheld_signature, xMutexNotheld_signatures[xMutexNotheld_counterMutexNotheld_enum], sizeof(E->xMutexNotheld_signature)) == 0) {
+ return counterMutexNotheld(args);
+ }
+ else if (memcmp(E->xMutexNotheld_signature, xMutexNotheld_signatures[xMutexNotheld_debugMutexNotheld_enum], sizeof(E->xMutexNotheld_signature)) == 0) {
+ return debugMutexNotheld(args);
+ }
+ else if (memcmp(E->xMutexNotheld_signature, xMutexNotheld_signatures[xMutexNotheld_wrMutexNotheld_enum], sizeof(E->xMutexNotheld_signature)) == 0) {
+ return wrMutexNotheld(args);
+ }


// Transform return E->xMutexTry(args) to if-chain with 7 candidates
@transform_return_xMutexTry_arrow@
expression E;
identifier FP_NAME = xMutexTry;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xMutexTry_signature, xMutexTry_signatures[xMutexTry_checkMutexTry_enum], sizeof(E->xMutexTry_signature)) == 0) {
+ return checkMutexTry(args);
+ }
+ else if (memcmp(E->xMutexTry_signature, xMutexTry_signatures[xMutexTry_counterMutexTry_enum], sizeof(E->xMutexTry_signature)) == 0) {
+ return counterMutexTry(args);
+ }
+ else if (memcmp(E->xMutexTry_signature, xMutexTry_signatures[xMutexTry_debugMutexTry_enum], sizeof(E->xMutexTry_signature)) == 0) {
+ return debugMutexTry(args);
+ }
+ else if (memcmp(E->xMutexTry_signature, xMutexTry_signatures[xMutexTry_noopMutexTry_enum], sizeof(E->xMutexTry_signature)) == 0) {
+ return noopMutexTry(args);
+ }
+ else if (memcmp(E->xMutexTry_signature, xMutexTry_signatures[xMutexTry_pthreadMutexTry_enum], sizeof(E->xMutexTry_signature)) == 0) {
+ return pthreadMutexTry(args);
+ }
+ else if (memcmp(E->xMutexTry_signature, xMutexTry_signatures[xMutexTry_winMutexTry_enum], sizeof(E->xMutexTry_signature)) == 0) {
+ return winMutexTry(args);
+ }
+ else if (memcmp(E->xMutexTry_signature, xMutexTry_signatures[xMutexTry_wrMutexTry_enum], sizeof(E->xMutexTry_signature)) == 0) {
+ return wrMutexTry(args);
+ }


// Transform return E->xNew(args) to if-chain with 3 candidates
@transform_return_xNew_arrow@
expression E;
identifier FP_NAME = xNew;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xNew_signature, xNew_signatures[xNew_sessionDiffNew_enum], sizeof(E->xNew_signature)) == 0) {
+ return sessionDiffNew(args);
+ }
+ else if (memcmp(E->xNew_signature, xNew_signatures[xNew_sessionPreupdateNew_enum], sizeof(E->xNew_signature)) == 0) {
+ return sessionPreupdateNew(args);
+ }
+ else if (memcmp(E->xNew_signature, xNew_signatures[xNew_sessionStat1New_enum], sizeof(E->xNew_signature)) == 0) {
+ return sessionStat1New(args);
+ }


// Transform return E->xNext(args) to if-chain with 46 candidates
@transform_return_xNext_arrow@
expression E;
identifier FP_NAME = xNext;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xNext_signature, xNext_signatures[xNext_0_enum], sizeof(E->xNext_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_amatchNext_enum], sizeof(E->xNext_signature)) == 0) {
+ return amatchNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_binfoNext_enum], sizeof(E->xNext_signature)) == 0) {
+ return binfoNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_bytecodevtabNext_enum], sizeof(E->xNext_signature)) == 0) {
+ return bytecodevtabNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_carrayNext_enum], sizeof(E->xNext_signature)) == 0) {
+ return carrayNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_cidxNext_enum], sizeof(E->xNext_signature)) == 0) {
+ return cidxNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_closureNext_enum], sizeof(E->xNext_signature)) == 0) {
+ return closureNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_completionNext_enum], sizeof(E->xNext_signature)) == 0) {
+ return completionNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_csvtabNext_enum], sizeof(E->xNext_signature)) == 0) {
+ return csvtabNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_dbdataNext_enum], sizeof(E->xNext_signature)) == 0) {
+ return dbdataNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_dbpageNext_enum], sizeof(E->xNext_signature)) == 0) {
+ return dbpageNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_deltaparsevtabNext_enum], sizeof(E->xNext_signature)) == 0) {
+ return deltaparsevtabNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_echoNext_enum], sizeof(E->xNext_signature)) == 0) {
+ return echoNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_expertNext_enum], sizeof(E->xNext_signature)) == 0) {
+ return expertNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_explainNext_enum], sizeof(E->xNext_signature)) == 0) {
+ return explainNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_fsNext_enum], sizeof(E->xNext_signature)) == 0) {
+ return fsNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_fsdirNext_enum], sizeof(E->xNext_signature)) == 0) {
+ return fsdirNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_fstreeNext_enum], sizeof(E->xNext_signature)) == 0) {
+ return fstreeNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_fts3NextMethod_enum], sizeof(E->xNext_signature)) == 0) {
+ return fts3NextMethod(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_fts3auxNextMethod_enum], sizeof(E->xNext_signature)) == 0) {
+ return fts3auxNextMethod(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_fts3termNextMethod_enum], sizeof(E->xNext_signature)) == 0) {
+ return fts3termNextMethod(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_fts3tokNextMethod_enum], sizeof(E->xNext_signature)) == 0) {
+ return fts3tokNextMethod(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_fuzzerNext_enum], sizeof(E->xNext_signature)) == 0) {
+ return fuzzerNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_intarrayNext_enum], sizeof(E->xNext_signature)) == 0) {
+ return intarrayNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_jsonEachNext_enum], sizeof(E->xNext_signature)) == 0) {
+ return jsonEachNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_memstatNext_enum], sizeof(E->xNext_signature)) == 0) {
+ return memstatNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_porterNext_enum], sizeof(E->xNext_signature)) == 0) {
+ return porterNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_pragmaVtabNext_enum], sizeof(E->xNext_signature)) == 0) {
+ return pragmaVtabNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_prefixesNext_enum], sizeof(E->xNext_signature)) == 0) {
+ return prefixesNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_qpvtabNext_enum], sizeof(E->xNext_signature)) == 0) {
+ return qpvtabNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_rtreeNext_enum], sizeof(E->xNext_signature)) == 0) {
+ return rtreeNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_schemaNext_enum], sizeof(E->xNext_signature)) == 0) {
+ return schemaNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_seriesNext_enum], sizeof(E->xNext_signature)) == 0) {
+ return seriesNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_simpleNext_enum], sizeof(E->xNext_signature)) == 0) {
+ return simpleNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_spellfix1Next_enum], sizeof(E->xNext_signature)) == 0) {
+ return spellfix1Next(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_statNext_enum], sizeof(E->xNext_signature)) == 0) {
+ return statNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_stmtNext_enum], sizeof(E->xNext_signature)) == 0) {
+ return stmtNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_tclNext_enum], sizeof(E->xNext_signature)) == 0) {
+ return tclNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_tclvarNext_enum], sizeof(E->xNext_signature)) == 0) {
+ return tclvarNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_templatevtabNext_enum], sizeof(E->xNext_signature)) == 0) {
+ return templatevtabNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_unicodeNext_enum], sizeof(E->xNext_signature)) == 0) {
+ return unicodeNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_unionNext_enum], sizeof(E->xNext_signature)) == 0) {
+ return unionNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_vlogNext_enum], sizeof(E->xNext_signature)) == 0) {
+ return vlogNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_vstattabNext_enum], sizeof(E->xNext_signature)) == 0) {
+ return vstattabNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_vtablogNext_enum], sizeof(E->xNext_signature)) == 0) {
+ return vtablogNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_wholenumberNext_enum], sizeof(E->xNext_signature)) == 0) {
+ return wholenumberNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_zipfileNext_enum], sizeof(E->xNext_signature)) == 0) {
+ return zipfileNext(args);
+ }


// Transform return E->xNextSystemCall(args) to if-chain with 3 candidates
@transform_return_xNextSystemCall_arrow@
expression E;
identifier FP_NAME = xNextSystemCall;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xNextSystemCall_signature, xNextSystemCall_signatures[xNextSystemCall_0_enum], sizeof(E->xNextSystemCall_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xNextSystemCall_signature, xNextSystemCall_signatures[xNextSystemCall_apndNextSystemCall_enum], sizeof(E->xNextSystemCall_signature)) == 0) {
+ return apndNextSystemCall(args);
+ }
+ else if (memcmp(E->xNextSystemCall_signature, xNextSystemCall_signatures[xNextSystemCall_rbuVfsGetLastError_enum], sizeof(E->xNextSystemCall_signature)) == 0) {
+ return rbuVfsGetLastError(args);
+ }
+ else if (memcmp(E->xNextSystemCall_signature, xNextSystemCall_signatures[xNextSystemCall_unixNextSystemCall_enum], sizeof(E->xNextSystemCall_signature)) == 0) {
+ return unixNextSystemCall(args);
+ }


// Transform return E->xOld(args) to if-chain with 3 candidates
@transform_return_xOld_arrow@
expression E;
identifier FP_NAME = xOld;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xOld_signature, xOld_signatures[xOld_sessionDiffOld_enum], sizeof(E->xOld_signature)) == 0) {
+ return sessionDiffOld(args);
+ }
+ else if (memcmp(E->xOld_signature, xOld_signatures[xOld_sessionPreupdateOld_enum], sizeof(E->xOld_signature)) == 0) {
+ return sessionPreupdateOld(args);
+ }
+ else if (memcmp(E->xOld_signature, xOld_signatures[xOld_sessionStat1Old_enum], sizeof(E->xOld_signature)) == 0) {
+ return sessionStat1Old(args);
+ }


// Transform return E->xOpen(args) to if-chain with 51 candidates
@transform_return_xOpen_arrow@
expression E;
identifier FP_NAME = xOpen;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_amatchOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ return amatchOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_apndOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ return apndOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_binfoOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ return binfoOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_bytecodevtabOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ return bytecodevtabOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_carrayOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ return carrayOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_cidxOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ return cidxOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_closureOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ return closureOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_completionOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ return completionOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_csvtabOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ return csvtabOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_dbdataOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ return dbdataOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_dbpageOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ return dbpageOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_deltaparsevtabOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ return deltaparsevtabOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_echoOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ return echoOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_expertOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ return expertOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_explainOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ return explainOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_fsOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ return fsOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_fsdirOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ return fsdirOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_fstreeOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ return fstreeOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_fts3OpenMethod_enum], sizeof(E->xOpen_signature)) == 0) {
+ return fts3OpenMethod(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_fts3auxOpenMethod_enum], sizeof(E->xOpen_signature)) == 0) {
+ return fts3auxOpenMethod(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_fts3termOpenMethod_enum], sizeof(E->xOpen_signature)) == 0) {
+ return fts3termOpenMethod(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_fts3tokOpenMethod_enum], sizeof(E->xOpen_signature)) == 0) {
+ return fts3tokOpenMethod(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_fuzzerOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ return fuzzerOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_intarrayOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ return intarrayOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_jsonEachOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ return jsonEachOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_jsonEachOpenEach_enum], sizeof(E->xOpen_signature)) == 0) {
+ return jsonEachOpenEach(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_jsonEachOpenTree_enum], sizeof(E->xOpen_signature)) == 0) {
+ return jsonEachOpenTree(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_memdbOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ return memdbOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_memstatOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ return memstatOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_porterOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ return porterOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_pragmaVtabOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ return pragmaVtabOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_prefixesOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ return prefixesOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_qpvtabOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ return qpvtabOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_rtreeOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ return rtreeOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_schemaOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ return schemaOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_seriesOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ return seriesOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_simpleOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ return simpleOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_spellfix1Open_enum], sizeof(E->xOpen_signature)) == 0) {
+ return spellfix1Open(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_statOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ return statOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_stmtOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ return stmtOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_tclOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ return tclOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_tclvarOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ return tclvarOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_templatevtabOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ return templatevtabOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_unicodeOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ return unicodeOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_unionOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ return unionOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_vfstraceOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ return vfstraceOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_vstattabOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ return vstattabOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_vtablogOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ return vtablogOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_wholenumberOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ return wholenumberOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_zipfileOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ return zipfileOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_unixOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ return unixOpen(args);
+ }


// Transform return E->xPagecount(args) to if-chain with 2 candidates
@transform_return_xPagecount_arrow@
expression E;
identifier FP_NAME = xPagecount;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xPagecount_signature, xPagecount_signatures[xPagecount_pcache1Pagecount_enum], sizeof(E->xPagecount_signature)) == 0) {
+ return pcache1Pagecount(args);
+ }
+ else if (memcmp(E->xPagecount_signature, xPagecount_signatures[xPagecount_pcachetracePagecount_enum], sizeof(E->xPagecount_signature)) == 0) {
+ return pcachetracePagecount(args);
+ }


// Transform return E->xParseCell(args) to if-chain with 3 candidates
@transform_return_xParseCell_arrow@
expression E;
identifier FP_NAME = xParseCell;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xParseCell_signature, xParseCell_signatures[xParseCell_btreeParseCellPtr_enum], sizeof(E->xParseCell_signature)) == 0) {
+ return btreeParseCellPtr(args);
+ }
+ else if (memcmp(E->xParseCell_signature, xParseCell_signatures[xParseCell_btreeParseCellPtrIndex_enum], sizeof(E->xParseCell_signature)) == 0) {
+ return btreeParseCellPtrIndex(args);
+ }
+ else if (memcmp(E->xParseCell_signature, xParseCell_signatures[xParseCell_btreeParseCellPtrNoPayload_enum], sizeof(E->xParseCell_signature)) == 0) {
+ return btreeParseCellPtrNoPayload(args);
+ }


// Transform return E->xRandomness(args) to if-chain with 4 candidates
@transform_return_xRandomness_arrow@
expression E;
identifier FP_NAME = xRandomness;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xRandomness_signature, xRandomness_signatures[xRandomness_apndRandomness_enum], sizeof(E->xRandomness_signature)) == 0) {
+ return apndRandomness(args);
+ }
+ else if (memcmp(E->xRandomness_signature, xRandomness_signatures[xRandomness_memdbRandomness_enum], sizeof(E->xRandomness_signature)) == 0) {
+ return memdbRandomness(args);
+ }
+ else if (memcmp(E->xRandomness_signature, xRandomness_signatures[xRandomness_vfstraceRandomness_enum], sizeof(E->xRandomness_signature)) == 0) {
+ return vfstraceRandomness(args);
+ }
+ else if (memcmp(E->xRandomness_signature, xRandomness_signatures[xRandomness_unixRandomness_enum], sizeof(E->xRandomness_signature)) == 0) {
+ return unixRandomness(args);
+ }


// Transform return E->xRead(args) to if-chain with 6 candidates
@transform_return_xRead_arrow@
expression E;
identifier FP_NAME = xRead;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xRead_signature, xRead_signatures[xRead_apndRead_enum], sizeof(E->xRead_signature)) == 0) {
+ return apndRead(args);
+ }
+ else if (memcmp(E->xRead_signature, xRead_signatures[xRead_memdbRead_enum], sizeof(E->xRead_signature)) == 0) {
+ return memdbRead(args);
+ }
+ else if (memcmp(E->xRead_signature, xRead_signatures[xRead_memjrnlRead_enum], sizeof(E->xRead_signature)) == 0) {
+ return memjrnlRead(args);
+ }
+ else if (memcmp(E->xRead_signature, xRead_signatures[xRead_recoverVfsRead_enum], sizeof(E->xRead_signature)) == 0) {
+ return recoverVfsRead(args);
+ }
+ else if (memcmp(E->xRead_signature, xRead_signatures[xRead_vfstraceRead_enum], sizeof(E->xRead_signature)) == 0) {
+ return vfstraceRead(args);
+ }
+ else if (memcmp(E->xRead_signature, xRead_signatures[xRead_unixRead_enum], sizeof(E->xRead_signature)) == 0) {
+ return unixRead(args);
+ }


// Transform return E->xRealloc(args) to if-chain with 2 candidates
@transform_return_xRealloc_arrow@
expression E;
identifier FP_NAME = xRealloc;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xRealloc_signature, xRealloc_signatures[xRealloc_memtraceRealloc_enum], sizeof(E->xRealloc_signature)) == 0) {
+ return memtraceRealloc(args);
+ }
+ else if (memcmp(E->xRealloc_signature, xRealloc_signatures[xRealloc_sqlite3MemRealloc_enum], sizeof(E->xRealloc_signature)) == 0) {
+ return sqlite3MemRealloc(args);
+ }


// Transform return E->xRekey(args) to if-chain with 3 candidates
@transform_return_xRekey_arrow@
expression E;
identifier FP_NAME = xRekey;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xRekey_signature, xRekey_signatures[xRekey_pcache1Rekey_enum], sizeof(E->xRekey_signature)) == 0) {
+ return pcache1Rekey(args);
+ }
+ else if (memcmp(E->xRekey_signature, xRekey_signatures[xRekey_pcachetraceRekey_enum], sizeof(E->xRekey_signature)) == 0) {
+ return pcachetraceRekey(args);
+ }
+ else if (memcmp(E->xRekey_signature, xRekey_signatures[xRekey_unixRandomness_enum], sizeof(E->xRekey_signature)) == 0) {
+ return unixRandomness(args);
+ }


// Transform return E->xRelease(args) to if-chain with 3 candidates
@transform_return_xRelease_arrow@
expression E;
identifier FP_NAME = xRelease;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xRelease_signature, xRelease_signatures[xRelease_0_enum], sizeof(E->xRelease_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xRelease_signature, xRelease_signatures[xRelease_echoRelease_enum], sizeof(E->xRelease_signature)) == 0) {
+ return echoRelease(args);
+ }
+ else if (memcmp(E->xRelease_signature, xRelease_signatures[xRelease_fts3ReleaseMethod_enum], sizeof(E->xRelease_signature)) == 0) {
+ return fts3ReleaseMethod(args);
+ }
+ else if (memcmp(E->xRelease_signature, xRelease_signatures[xRelease_vtablogRelease_enum], sizeof(E->xRelease_signature)) == 0) {
+ return vtablogRelease(args);
+ }


// Transform return E->xRename(args) to if-chain with 5 candidates
@transform_return_xRename_arrow@
expression E;
identifier FP_NAME = xRename;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xRename_signature, xRename_signatures[xRename_0_enum], sizeof(E->xRename_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xRename_signature, xRename_signatures[xRename_echoRename_enum], sizeof(E->xRename_signature)) == 0) {
+ return echoRename(args);
+ }
+ else if (memcmp(E->xRename_signature, xRename_signatures[xRename_fts3RenameMethod_enum], sizeof(E->xRename_signature)) == 0) {
+ return fts3RenameMethod(args);
+ }
+ else if (memcmp(E->xRename_signature, xRename_signatures[xRename_rtreeRename_enum], sizeof(E->xRename_signature)) == 0) {
+ return rtreeRename(args);
+ }
+ else if (memcmp(E->xRename_signature, xRename_signatures[xRename_spellfix1Rename_enum], sizeof(E->xRename_signature)) == 0) {
+ return spellfix1Rename(args);
+ }
+ else if (memcmp(E->xRename_signature, xRename_signatures[xRename_vtablogRename_enum], sizeof(E->xRename_signature)) == 0) {
+ return vtablogRename(args);
+ }


// Transform return E->xRollback(args) to if-chain with 6 candidates
@transform_return_xRollback_arrow@
expression E;
identifier FP_NAME = xRollback;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xRollback_signature, xRollback_signatures[xRollback_0_enum], sizeof(E->xRollback_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xRollback_signature, xRollback_signatures[xRollback_echoRollback_enum], sizeof(E->xRollback_signature)) == 0) {
+ return echoRollback(args);
+ }
+ else if (memcmp(E->xRollback_signature, xRollback_signatures[xRollback_fts3RollbackMethod_enum], sizeof(E->xRollback_signature)) == 0) {
+ return fts3RollbackMethod(args);
+ }
+ else if (memcmp(E->xRollback_signature, xRollback_signatures[xRollback_rtreeEndTransaction_enum], sizeof(E->xRollback_signature)) == 0) {
+ return rtreeEndTransaction(args);
+ }
+ else if (memcmp(E->xRollback_signature, xRollback_signatures[xRollback_rtreeRollback_enum], sizeof(E->xRollback_signature)) == 0) {
+ return rtreeRollback(args);
+ }
+ else if (memcmp(E->xRollback_signature, xRollback_signatures[xRollback_vtablogRollback_enum], sizeof(E->xRollback_signature)) == 0) {
+ return vtablogRollback(args);
+ }
+ else if (memcmp(E->xRollback_signature, xRollback_signatures[xRollback_zipfileRollback_enum], sizeof(E->xRollback_signature)) == 0) {
+ return zipfileRollback(args);
+ }


// Transform return E->xRollbackTo(args) to if-chain with 4 candidates
@transform_return_xRollbackTo_arrow@
expression E;
identifier FP_NAME = xRollbackTo;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xRollbackTo_signature, xRollbackTo_signatures[xRollbackTo_0_enum], sizeof(E->xRollbackTo_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xRollbackTo_signature, xRollbackTo_signatures[xRollbackTo_dbpageRollbackTo_enum], sizeof(E->xRollbackTo_signature)) == 0) {
+ return dbpageRollbackTo(args);
+ }
+ else if (memcmp(E->xRollbackTo_signature, xRollbackTo_signatures[xRollbackTo_echoRollbackTo_enum], sizeof(E->xRollbackTo_signature)) == 0) {
+ return echoRollbackTo(args);
+ }
+ else if (memcmp(E->xRollbackTo_signature, xRollbackTo_signatures[xRollbackTo_fts3RollbackToMethod_enum], sizeof(E->xRollbackTo_signature)) == 0) {
+ return fts3RollbackToMethod(args);
+ }
+ else if (memcmp(E->xRollbackTo_signature, xRollbackTo_signatures[xRollbackTo_vtablogRollbackTo_enum], sizeof(E->xRollbackTo_signature)) == 0) {
+ return vtablogRollbackTo(args);
+ }


// Transform return E->xRoundup(args) to if-chain with 2 candidates
@transform_return_xRoundup_arrow@
expression E;
identifier FP_NAME = xRoundup;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xRoundup_signature, xRoundup_signatures[xRoundup_memtraceRoundup_enum], sizeof(E->xRoundup_signature)) == 0) {
+ return memtraceRoundup(args);
+ }
+ else if (memcmp(E->xRoundup_signature, xRoundup_signatures[xRoundup_sqlite3MemRoundup_enum], sizeof(E->xRoundup_signature)) == 0) {
+ return sqlite3MemRoundup(args);
+ }


// Transform return E->xRowid(args) to if-chain with 42 candidates
@transform_return_xRowid_arrow@
expression E;
identifier FP_NAME = xRowid;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_0_enum], sizeof(E->xRowid_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_amatchRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ return amatchRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_binfoRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ return binfoRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_bytecodevtabRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ return bytecodevtabRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_carrayRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ return carrayRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_cidxRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ return cidxRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_closureRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ return closureRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_completionRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ return completionRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_csvtabRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ return csvtabRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_dbdataRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ return dbdataRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_dbpageRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ return dbpageRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_deltaparsevtabRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ return deltaparsevtabRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_echoRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ return echoRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_expertRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ return expertRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_explainRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ return explainRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_fsRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ return fsRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_fsdirRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ return fsdirRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_fstreeRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ return fstreeRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_fts3RowidMethod_enum], sizeof(E->xRowid_signature)) == 0) {
+ return fts3RowidMethod(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_fts3auxRowidMethod_enum], sizeof(E->xRowid_signature)) == 0) {
+ return fts3auxRowidMethod(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_fts3termRowidMethod_enum], sizeof(E->xRowid_signature)) == 0) {
+ return fts3termRowidMethod(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_fts3tokRowidMethod_enum], sizeof(E->xRowid_signature)) == 0) {
+ return fts3tokRowidMethod(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_fuzzerRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ return fuzzerRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_intarrayRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ return intarrayRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_jsonEachRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ return jsonEachRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_memstatRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ return memstatRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_pragmaVtabRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ return pragmaVtabRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_prefixesRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ return prefixesRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_qpvtabRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ return qpvtabRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_rtreeRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ return rtreeRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_schemaRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ return schemaRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_seriesRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ return seriesRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_spellfix1Rowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ return spellfix1Rowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_statRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ return statRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_stmtRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ return stmtRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_tclRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ return tclRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_tclvarRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ return tclvarRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_templatevtabRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ return templatevtabRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_unionRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ return unionRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_vlogRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ return vlogRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_vstattabRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ return vstattabRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_vtablogRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ return vtablogRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_wholenumberRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ return wholenumberRowid(args);
+ }


// Transform return E->xSFunc(args) to if-chain with 5 candidates
@transform_return_xSFunc_arrow@
expression E;
identifier FP_NAME = xSFunc;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_attachFunc_enum], sizeof(E->xSFunc_signature)) == 0) {
+ return attachFunc(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_detachFunc_enum], sizeof(E->xSFunc_signature)) == 0) {
+ return detachFunc(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_statGet_enum], sizeof(E->xSFunc_signature)) == 0) {
+ return statGet(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_statInit_enum], sizeof(E->xSFunc_signature)) == 0) {
+ return statInit(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_statPush_enum], sizeof(E->xSFunc_signature)) == 0) {
+ return statPush(args);
+ }


// Transform return E->xSavepoint(args) to if-chain with 2 candidates
@transform_return_xSavepoint_arrow@
expression E;
identifier FP_NAME = xSavepoint;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xSavepoint_signature, xSavepoint_signatures[xSavepoint_0_enum], sizeof(E->xSavepoint_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xSavepoint_signature, xSavepoint_signatures[xSavepoint_fts3SavepointMethod_enum], sizeof(E->xSavepoint_signature)) == 0) {
+ return fts3SavepointMethod(args);
+ }
+ else if (memcmp(E->xSavepoint_signature, xSavepoint_signatures[xSavepoint_rtreeSavepoint_enum], sizeof(E->xSavepoint_signature)) == 0) {
+ return rtreeSavepoint(args);
+ }


// Transform return E->xSectorSize(args) to if-chain with 4 candidates
@transform_return_xSectorSize_arrow@
expression E;
identifier FP_NAME = xSectorSize;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xSectorSize_signature, xSectorSize_signatures[xSectorSize_0_enum], sizeof(E->xSectorSize_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xSectorSize_signature, xSectorSize_signatures[xSectorSize_apndSectorSize_enum], sizeof(E->xSectorSize_signature)) == 0) {
+ return apndSectorSize(args);
+ }
+ else if (memcmp(E->xSectorSize_signature, xSectorSize_signatures[xSectorSize_recoverVfsSectorSize_enum], sizeof(E->xSectorSize_signature)) == 0) {
+ return recoverVfsSectorSize(args);
+ }
+ else if (memcmp(E->xSectorSize_signature, xSectorSize_signatures[xSectorSize_vfstraceSectorSize_enum], sizeof(E->xSectorSize_signature)) == 0) {
+ return vfstraceSectorSize(args);
+ }
+ else if (memcmp(E->xSectorSize_signature, xSectorSize_signatures[xSectorSize_unixSectorSize_enum], sizeof(E->xSectorSize_signature)) == 0) {
+ return unixSectorSize(args);
+ }


// Transform return E->xSelectCallback(args) to if-chain with 16 candidates
@transform_return_xSelectCallback_arrow@
expression E;
identifier FP_NAME = xSelectCallback;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_0_enum], sizeof(E->xSelectCallback_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_convertCompoundSelectToSubquery_enum], sizeof(E->xSelectCallback_signature)) == 0) {
+ return convertCompoundSelectToSubquery(args);
+ }
+ else if (memcmp(E->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_exprSelectWalkTableConstant_enum], sizeof(E->xSelectCallback_signature)) == 0) {
+ return exprSelectWalkTableConstant(args);
+ }
+ else if (memcmp(E->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_fixSelectCb_enum], sizeof(E->xSelectCallback_signature)) == 0) {
+ return fixSelectCb(args);
+ }
+ else if (memcmp(E->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_gatherSelectWindowsSelectCallback_enum], sizeof(E->xSelectCallback_signature)) == 0) {
+ return gatherSelectWindowsSelectCallback(args);
+ }
+ else if (memcmp(E->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_renameColumnSelectCb_enum], sizeof(E->xSelectCallback_signature)) == 0) {
+ return renameColumnSelectCb(args);
+ }
+ else if (memcmp(E->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_renameTableSelectCb_enum], sizeof(E->xSelectCallback_signature)) == 0) {
+ return renameTableSelectCb(args);
+ }
+ else if (memcmp(E->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_renameUnmapSelectCb_enum], sizeof(E->xSelectCallback_signature)) == 0) {
+ return renameUnmapSelectCb(args);
+ }
+ else if (memcmp(E->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_resolveSelectStep_enum], sizeof(E->xSelectCallback_signature)) == 0) {
+ return resolveSelectStep(args);
+ }
+ else if (memcmp(E->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_selectCheckOnClausesSelect_enum], sizeof(E->xSelectCallback_signature)) == 0) {
+ return selectCheckOnClausesSelect(args);
+ }
+ else if (memcmp(E->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_selectExpander_enum], sizeof(E->xSelectCallback_signature)) == 0) {
+ return selectExpander(args);
+ }
+ else if (memcmp(E->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_selectRefEnter_enum], sizeof(E->xSelectCallback_signature)) == 0) {
+ return selectRefEnter(args);
+ }
+ else if (memcmp(E->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_selectWindowRewriteSelectCb_enum], sizeof(E->xSelectCallback_signature)) == 0) {
+ return selectWindowRewriteSelectCb(args);
+ }
+ else if (memcmp(E->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_sqlite3ReturningSubqueryCorrelated_enum], sizeof(E->xSelectCallback_signature)) == 0) {
+ return sqlite3ReturningSubqueryCorrelated(args);
+ }
+ else if (memcmp(E->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_sqlite3SelectWalkFail_enum], sizeof(E->xSelectCallback_signature)) == 0) {
+ return sqlite3SelectWalkFail(args);
+ }
+ else if (memcmp(E->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_sqlite3SelectWalkNoop_enum], sizeof(E->xSelectCallback_signature)) == 0) {
+ return sqlite3SelectWalkNoop(args);
+ }
+ else if (memcmp(E->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_sqlite3WalkerDepthIncrease_enum], sizeof(E->xSelectCallback_signature)) == 0) {
+ return sqlite3WalkerDepthIncrease(args);
+ }


// Transform return E->xSelectCallback2(args) to if-chain with 5 candidates
@transform_return_xSelectCallback2_arrow@
expression E;
identifier FP_NAME = xSelectCallback2;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_0_enum], sizeof(E->xSelectCallback2_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_selectAddSubqueryTypeInfo_enum], sizeof(E->xSelectCallback2_signature)) == 0) {
+ return selectAddSubqueryTypeInfo(args);
+ }
+ else if (memcmp(E->xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_selectRefLeave_enum], sizeof(E->xSelectCallback2_signature)) == 0) {
+ return selectRefLeave(args);
+ }
+ else if (memcmp(E->xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_sqlite3SelectPopWith_enum], sizeof(E->xSelectCallback2_signature)) == 0) {
+ return sqlite3SelectPopWith(args);
+ }
+ else if (memcmp(E->xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_sqlite3WalkWinDefnDummyCallback_enum], sizeof(E->xSelectCallback2_signature)) == 0) {
+ return sqlite3WalkWinDefnDummyCallback(args);
+ }
+ else if (memcmp(E->xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_sqlite3WalkerDepthDecrease_enum], sizeof(E->xSelectCallback2_signature)) == 0) {
+ return sqlite3WalkerDepthDecrease(args);
+ }


// Transform return E->xSetSystemCall(args) to if-chain with 5 candidates
@transform_return_xSetSystemCall_arrow@
expression E;
identifier FP_NAME = xSetSystemCall;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xSetSystemCall_signature, xSetSystemCall_signatures[xSetSystemCall_0_enum], sizeof(E->xSetSystemCall_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xSetSystemCall_signature, xSetSystemCall_signatures[xSetSystemCall_apndSetSystemCall_enum], sizeof(E->xSetSystemCall_signature)) == 0) {
+ return apndSetSystemCall(args);
+ }
+ else if (memcmp(E->xSetSystemCall_signature, xSetSystemCall_signatures[xSetSystemCall_devsymSleep_enum], sizeof(E->xSetSystemCall_signature)) == 0) {
+ return devsymSleep(args);
+ }
+ else if (memcmp(E->xSetSystemCall_signature, xSetSystemCall_signatures[xSetSystemCall_rbuVfsSleep_enum], sizeof(E->xSetSystemCall_signature)) == 0) {
+ return rbuVfsSleep(args);
+ }
+ else if (memcmp(E->xSetSystemCall_signature, xSetSystemCall_signatures[xSetSystemCall_tvfsSleep_enum], sizeof(E->xSetSystemCall_signature)) == 0) {
+ return tvfsSleep(args);
+ }
+ else if (memcmp(E->xSetSystemCall_signature, xSetSystemCall_signatures[xSetSystemCall_unixSetSystemCall_enum], sizeof(E->xSetSystemCall_signature)) == 0) {
+ return unixSetSystemCall(args);
+ }


// Transform return E->xShadowName(args) to if-chain with 2 candidates
@transform_return_xShadowName_arrow@
expression E;
identifier FP_NAME = xShadowName;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xShadowName_signature, xShadowName_signatures[xShadowName_0_enum], sizeof(E->xShadowName_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xShadowName_signature, xShadowName_signatures[xShadowName_fts3ShadowName_enum], sizeof(E->xShadowName_signature)) == 0) {
+ return fts3ShadowName(args);
+ }
+ else if (memcmp(E->xShadowName_signature, xShadowName_signatures[xShadowName_rtreeShadowName_enum], sizeof(E->xShadowName_signature)) == 0) {
+ return rtreeShadowName(args);
+ }


// Transform return E->xShmBarrier(args) to if-chain with 3 candidates
@transform_return_xShmBarrier_arrow@
expression E;
identifier FP_NAME = xShmBarrier;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xShmBarrier_signature, xShmBarrier_signatures[xShmBarrier_0_enum], sizeof(E->xShmBarrier_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xShmBarrier_signature, xShmBarrier_signatures[xShmBarrier_apndShmBarrier_enum], sizeof(E->xShmBarrier_signature)) == 0) {
+ return apndShmBarrier(args);
+ }
+ else if (memcmp(E->xShmBarrier_signature, xShmBarrier_signatures[xShmBarrier_recoverVfsShmBarrier_enum], sizeof(E->xShmBarrier_signature)) == 0) {
+ return recoverVfsShmBarrier(args);
+ }
+ else if (memcmp(E->xShmBarrier_signature, xShmBarrier_signatures[xShmBarrier_unixShmBarrier_enum], sizeof(E->xShmBarrier_signature)) == 0) {
+ return unixShmBarrier(args);
+ }


// Transform return E->xShmLock(args) to if-chain with 3 candidates
@transform_return_xShmLock_arrow@
expression E;
identifier FP_NAME = xShmLock;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xShmLock_signature, xShmLock_signatures[xShmLock_0_enum], sizeof(E->xShmLock_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xShmLock_signature, xShmLock_signatures[xShmLock_apndShmLock_enum], sizeof(E->xShmLock_signature)) == 0) {
+ return apndShmLock(args);
+ }
+ else if (memcmp(E->xShmLock_signature, xShmLock_signatures[xShmLock_recoverVfsShmLock_enum], sizeof(E->xShmLock_signature)) == 0) {
+ return recoverVfsShmLock(args);
+ }
+ else if (memcmp(E->xShmLock_signature, xShmLock_signatures[xShmLock_unixShmLock_enum], sizeof(E->xShmLock_signature)) == 0) {
+ return unixShmLock(args);
+ }


// Transform return E->xShmMap(args) to if-chain with 3 candidates
@transform_return_xShmMap_arrow@
expression E;
identifier FP_NAME = xShmMap;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xShmMap_signature, xShmMap_signatures[xShmMap_0_enum], sizeof(E->xShmMap_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xShmMap_signature, xShmMap_signatures[xShmMap_apndShmMap_enum], sizeof(E->xShmMap_signature)) == 0) {
+ return apndShmMap(args);
+ }
+ else if (memcmp(E->xShmMap_signature, xShmMap_signatures[xShmMap_recoverVfsShmMap_enum], sizeof(E->xShmMap_signature)) == 0) {
+ return recoverVfsShmMap(args);
+ }
+ else if (memcmp(E->xShmMap_signature, xShmMap_signatures[xShmMap_unixShmMap_enum], sizeof(E->xShmMap_signature)) == 0) {
+ return unixShmMap(args);
+ }


// Transform return E->xShmUnmap(args) to if-chain with 3 candidates
@transform_return_xShmUnmap_arrow@
expression E;
identifier FP_NAME = xShmUnmap;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xShmUnmap_signature, xShmUnmap_signatures[xShmUnmap_0_enum], sizeof(E->xShmUnmap_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xShmUnmap_signature, xShmUnmap_signatures[xShmUnmap_apndShmUnmap_enum], sizeof(E->xShmUnmap_signature)) == 0) {
+ return apndShmUnmap(args);
+ }
+ else if (memcmp(E->xShmUnmap_signature, xShmUnmap_signatures[xShmUnmap_recoverVfsShmUnmap_enum], sizeof(E->xShmUnmap_signature)) == 0) {
+ return recoverVfsShmUnmap(args);
+ }
+ else if (memcmp(E->xShmUnmap_signature, xShmUnmap_signatures[xShmUnmap_unixShmUnmap_enum], sizeof(E->xShmUnmap_signature)) == 0) {
+ return unixShmUnmap(args);
+ }


// Transform return E->xShrink(args) to if-chain with 2 candidates
@transform_return_xShrink_arrow@
expression E;
identifier FP_NAME = xShrink;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xShrink_signature, xShrink_signatures[xShrink_pcache1Shrink_enum], sizeof(E->xShrink_signature)) == 0) {
+ return pcache1Shrink(args);
+ }
+ else if (memcmp(E->xShrink_signature, xShrink_signatures[xShrink_pcachetraceShrink_enum], sizeof(E->xShrink_signature)) == 0) {
+ return pcachetraceShrink(args);
+ }


// Transform return E->xShutdown(args) to if-chain with 4 candidates
@transform_return_xShutdown_arrow@
expression E;
identifier FP_NAME = xShutdown;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xShutdown_signature, xShutdown_signatures[xShutdown_memtraceShutdown_enum], sizeof(E->xShutdown_signature)) == 0) {
+ return memtraceShutdown(args);
+ }
+ else if (memcmp(E->xShutdown_signature, xShutdown_signatures[xShutdown_pcache1Shutdown_enum], sizeof(E->xShutdown_signature)) == 0) {
+ return pcache1Shutdown(args);
+ }
+ else if (memcmp(E->xShutdown_signature, xShutdown_signatures[xShutdown_pcachetraceShutdown_enum], sizeof(E->xShutdown_signature)) == 0) {
+ return pcachetraceShutdown(args);
+ }
+ else if (memcmp(E->xShutdown_signature, xShutdown_signatures[xShutdown_sqlite3MemShutdown_enum], sizeof(E->xShutdown_signature)) == 0) {
+ return sqlite3MemShutdown(args);
+ }


// Transform return E->xSize(args) to if-chain with 2 candidates
@transform_return_xSize_arrow@
expression E;
identifier FP_NAME = xSize;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xSize_signature, xSize_signatures[xSize_memtraceSize_enum], sizeof(E->xSize_signature)) == 0) {
+ return memtraceSize(args);
+ }
+ else if (memcmp(E->xSize_signature, xSize_signatures[xSize_sqlite3MemSize_enum], sizeof(E->xSize_signature)) == 0) {
+ return sqlite3MemSize(args);
+ }


// Transform return E->xSleep(args) to if-chain with 4 candidates
@transform_return_xSleep_arrow@
expression E;
identifier FP_NAME = xSleep;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xSleep_signature, xSleep_signatures[xSleep_0_enum], sizeof(E->xSleep_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xSleep_signature, xSleep_signatures[xSleep_apndSleep_enum], sizeof(E->xSleep_signature)) == 0) {
+ return apndSleep(args);
+ }
+ else if (memcmp(E->xSleep_signature, xSleep_signatures[xSleep_memdbSleep_enum], sizeof(E->xSleep_signature)) == 0) {
+ return memdbSleep(args);
+ }
+ else if (memcmp(E->xSleep_signature, xSleep_signatures[xSleep_vfstraceSleep_enum], sizeof(E->xSleep_signature)) == 0) {
+ return vfstraceSleep(args);
+ }
+ else if (memcmp(E->xSleep_signature, xSleep_signatures[xSleep_unixSleep_enum], sizeof(E->xSleep_signature)) == 0) {
+ return unixSleep(args);
+ }


// Transform return E->xSync(args) to if-chain with 11 candidates
@transform_return_xSync_arrow@
expression E;
identifier FP_NAME = xSync;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xSync_signature, xSync_signatures[xSync_0_enum], sizeof(E->xSync_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xSync_signature, xSync_signatures[xSync_apndSync_enum], sizeof(E->xSync_signature)) == 0) {
+ return apndSync(args);
+ }
+ else if (memcmp(E->xSync_signature, xSync_signatures[xSync_dbpageSync_enum], sizeof(E->xSync_signature)) == 0) {
+ return dbpageSync(args);
+ }
+ else if (memcmp(E->xSync_signature, xSync_signatures[xSync_echoSync_enum], sizeof(E->xSync_signature)) == 0) {
+ return echoSync(args);
+ }
+ else if (memcmp(E->xSync_signature, xSync_signatures[xSync_fts3SyncMethod_enum], sizeof(E->xSync_signature)) == 0) {
+ return fts3SyncMethod(args);
+ }
+ else if (memcmp(E->xSync_signature, xSync_signatures[xSync_memdbSync_enum], sizeof(E->xSync_signature)) == 0) {
+ return memdbSync(args);
+ }
+ else if (memcmp(E->xSync_signature, xSync_signatures[xSync_memjrnlSync_enum], sizeof(E->xSync_signature)) == 0) {
+ return memjrnlSync(args);
+ }
+ else if (memcmp(E->xSync_signature, xSync_signatures[xSync_recoverVfsSync_enum], sizeof(E->xSync_signature)) == 0) {
+ return recoverVfsSync(args);
+ }
+ else if (memcmp(E->xSync_signature, xSync_signatures[xSync_rtreeEndTransaction_enum], sizeof(E->xSync_signature)) == 0) {
+ return rtreeEndTransaction(args);
+ }
+ else if (memcmp(E->xSync_signature, xSync_signatures[xSync_vfstraceSync_enum], sizeof(E->xSync_signature)) == 0) {
+ return vfstraceSync(args);
+ }
+ else if (memcmp(E->xSync_signature, xSync_signatures[xSync_vtablogSync_enum], sizeof(E->xSync_signature)) == 0) {
+ return vtablogSync(args);
+ }
+ else if (memcmp(E->xSync_signature, xSync_signatures[xSync_unixSync_enum], sizeof(E->xSync_signature)) == 0) {
+ return unixSync(args);
+ }


// Transform return E->xTokenize(args) to if-chain with 3 candidates
@transform_return_xTokenize_arrow@
expression E;
identifier FP_NAME = xTokenize;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xTokenize_signature, xTokenize_signatures[xTokenize_0_enum], sizeof(E->xTokenize_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xTokenize_signature, xTokenize_signatures[xTokenize_f5tOrigintextTokenize_enum], sizeof(E->xTokenize_signature)) == 0) {
+ return f5tOrigintextTokenize(args);
+ }
+ else if (memcmp(E->xTokenize_signature, xTokenize_signatures[xTokenize_f5tTokenizerTokenize_enum], sizeof(E->xTokenize_signature)) == 0) {
+ return f5tTokenizerTokenize(args);
+ }
+ else if (memcmp(E->xTokenize_signature, xTokenize_signatures[xTokenize_f5tTokenizerTokenize_v2_enum], sizeof(E->xTokenize_signature)) == 0) {
+ return f5tTokenizerTokenize_v2(args);
+ }


// Transform return E->xTruncate(args) to if-chain with 8 candidates
@transform_return_xTruncate_arrow@
expression E;
identifier FP_NAME = xTruncate;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xTruncate_signature, xTruncate_signatures[xTruncate_apndTruncate_enum], sizeof(E->xTruncate_signature)) == 0) {
+ return apndTruncate(args);
+ }
+ else if (memcmp(E->xTruncate_signature, xTruncate_signatures[xTruncate_memdbTruncate_enum], sizeof(E->xTruncate_signature)) == 0) {
+ return memdbTruncate(args);
+ }
+ else if (memcmp(E->xTruncate_signature, xTruncate_signatures[xTruncate_memjrnlTruncate_enum], sizeof(E->xTruncate_signature)) == 0) {
+ return memjrnlTruncate(args);
+ }
+ else if (memcmp(E->xTruncate_signature, xTruncate_signatures[xTruncate_pcache1Truncate_enum], sizeof(E->xTruncate_signature)) == 0) {
+ return pcache1Truncate(args);
+ }
+ else if (memcmp(E->xTruncate_signature, xTruncate_signatures[xTruncate_pcachetraceTruncate_enum], sizeof(E->xTruncate_signature)) == 0) {
+ return pcachetraceTruncate(args);
+ }
+ else if (memcmp(E->xTruncate_signature, xTruncate_signatures[xTruncate_recoverVfsTruncate_enum], sizeof(E->xTruncate_signature)) == 0) {
+ return recoverVfsTruncate(args);
+ }
+ else if (memcmp(E->xTruncate_signature, xTruncate_signatures[xTruncate_vfstraceTruncate_enum], sizeof(E->xTruncate_signature)) == 0) {
+ return vfstraceTruncate(args);
+ }
+ else if (memcmp(E->xTruncate_signature, xTruncate_signatures[xTruncate_unixTruncate_enum], sizeof(E->xTruncate_signature)) == 0) {
+ return unixTruncate(args);
+ }


// Transform return E->xUnfetch(args) to if-chain with 4 candidates
@transform_return_xUnfetch_arrow@
expression E;
identifier FP_NAME = xUnfetch;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xUnfetch_signature, xUnfetch_signatures[xUnfetch_0_enum], sizeof(E->xUnfetch_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xUnfetch_signature, xUnfetch_signatures[xUnfetch_apndUnfetch_enum], sizeof(E->xUnfetch_signature)) == 0) {
+ return apndUnfetch(args);
+ }
+ else if (memcmp(E->xUnfetch_signature, xUnfetch_signatures[xUnfetch_memdbUnfetch_enum], sizeof(E->xUnfetch_signature)) == 0) {
+ return memdbUnfetch(args);
+ }
+ else if (memcmp(E->xUnfetch_signature, xUnfetch_signatures[xUnfetch_recoverVfsUnfetch_enum], sizeof(E->xUnfetch_signature)) == 0) {
+ return recoverVfsUnfetch(args);
+ }
+ else if (memcmp(E->xUnfetch_signature, xUnfetch_signatures[xUnfetch_unixUnfetch_enum], sizeof(E->xUnfetch_signature)) == 0) {
+ return unixUnfetch(args);
+ }


// Transform return E->xUnlock(args) to if-chain with 7 candidates
@transform_return_xUnlock_arrow@
expression E;
identifier FP_NAME = xUnlock;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xUnlock_signature, xUnlock_signatures[xUnlock_0_enum], sizeof(E->xUnlock_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xUnlock_signature, xUnlock_signatures[xUnlock_apndUnlock_enum], sizeof(E->xUnlock_signature)) == 0) {
+ return apndUnlock(args);
+ }
+ else if (memcmp(E->xUnlock_signature, xUnlock_signatures[xUnlock_memdbUnlock_enum], sizeof(E->xUnlock_signature)) == 0) {
+ return memdbUnlock(args);
+ }
+ else if (memcmp(E->xUnlock_signature, xUnlock_signatures[xUnlock_recoverVfsUnlock_enum], sizeof(E->xUnlock_signature)) == 0) {
+ return recoverVfsUnlock(args);
+ }
+ else if (memcmp(E->xUnlock_signature, xUnlock_signatures[xUnlock_vfstraceUnlock_enum], sizeof(E->xUnlock_signature)) == 0) {
+ return vfstraceUnlock(args);
+ }
+ else if (memcmp(E->xUnlock_signature, xUnlock_signatures[xUnlock_unixUnlock_enum], sizeof(E->xUnlock_signature)) == 0) {
+ return unixUnlock(args);
+ }
+ else if (memcmp(E->xUnlock_signature, xUnlock_signatures[xUnlock_nolockUnlock_enum], sizeof(E->xUnlock_signature)) == 0) {
+ return nolockUnlock(args);
+ }
+ else if (memcmp(E->xUnlock_signature, xUnlock_signatures[xUnlock_dotlockUnlock_enum], sizeof(E->xUnlock_signature)) == 0) {
+ return dotlockUnlock(args);
+ }


// Transform return E->xUnpin(args) to if-chain with 2 candidates
@transform_return_xUnpin_arrow@
expression E;
identifier FP_NAME = xUnpin;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xUnpin_signature, xUnpin_signatures[xUnpin_pcache1Unpin_enum], sizeof(E->xUnpin_signature)) == 0) {
+ return pcache1Unpin(args);
+ }
+ else if (memcmp(E->xUnpin_signature, xUnpin_signatures[xUnpin_pcachetraceUnpin_enum], sizeof(E->xUnpin_signature)) == 0) {
+ return pcachetraceUnpin(args);
+ }


// Transform return E->xUpdate(args) to if-chain with 13 candidates
@transform_return_xUpdate_arrow@
expression E;
identifier FP_NAME = xUpdate;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xUpdate_signature, xUpdate_signatures[xUpdate_0_enum], sizeof(E->xUpdate_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E->xUpdate_signature, xUpdate_signatures[xUpdate_amatchUpdate_enum], sizeof(E->xUpdate_signature)) == 0) {
+ return amatchUpdate(args);
+ }
+ else if (memcmp(E->xUpdate_signature, xUpdate_signatures[xUpdate_csvtabUpdate_enum], sizeof(E->xUpdate_signature)) == 0) {
+ return csvtabUpdate(args);
+ }
+ else if (memcmp(E->xUpdate_signature, xUpdate_signatures[xUpdate_dbpageUpdate_enum], sizeof(E->xUpdate_signature)) == 0) {
+ return dbpageUpdate(args);
+ }
+ else if (memcmp(E->xUpdate_signature, xUpdate_signatures[xUpdate_echoUpdate_enum], sizeof(E->xUpdate_signature)) == 0) {
+ return echoUpdate(args);
+ }
+ else if (memcmp(E->xUpdate_signature, xUpdate_signatures[xUpdate_expertUpdate_enum], sizeof(E->xUpdate_signature)) == 0) {
+ return expertUpdate(args);
+ }
+ else if (memcmp(E->xUpdate_signature, xUpdate_signatures[xUpdate_fts3UpdateMethod_enum], sizeof(E->xUpdate_signature)) == 0) {
+ return fts3UpdateMethod(args);
+ }
+ else if (memcmp(E->xUpdate_signature, xUpdate_signatures[xUpdate_geopolyUpdate_enum], sizeof(E->xUpdate_signature)) == 0) {
+ return geopolyUpdate(args);
+ }
+ else if (memcmp(E->xUpdate_signature, xUpdate_signatures[xUpdate_rtreeUpdate_enum], sizeof(E->xUpdate_signature)) == 0) {
+ return rtreeUpdate(args);
+ }
+ else if (memcmp(E->xUpdate_signature, xUpdate_signatures[xUpdate_spellfix1Update_enum], sizeof(E->xUpdate_signature)) == 0) {
+ return spellfix1Update(args);
+ }
+ else if (memcmp(E->xUpdate_signature, xUpdate_signatures[xUpdate_tclvarUpdate_enum], sizeof(E->xUpdate_signature)) == 0) {
+ return tclvarUpdate(args);
+ }
+ else if (memcmp(E->xUpdate_signature, xUpdate_signatures[xUpdate_vstattabUpdate_enum], sizeof(E->xUpdate_signature)) == 0) {
+ return vstattabUpdate(args);
+ }
+ else if (memcmp(E->xUpdate_signature, xUpdate_signatures[xUpdate_vtablogUpdate_enum], sizeof(E->xUpdate_signature)) == 0) {
+ return vtablogUpdate(args);
+ }
+ else if (memcmp(E->xUpdate_signature, xUpdate_signatures[xUpdate_zipfileUpdate_enum], sizeof(E->xUpdate_signature)) == 0) {
+ return zipfileUpdate(args);
+ }


// Transform return E->xWrite(args) to if-chain with 7 candidates
@transform_return_xWrite_arrow@
expression E;
identifier FP_NAME = xWrite;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xWrite_signature, xWrite_signatures[xWrite_apndWrite_enum], sizeof(E->xWrite_signature)) == 0) {
+ return apndWrite(args);
+ }
+ else if (memcmp(E->xWrite_signature, xWrite_signatures[xWrite_kvstorageWrite_enum], sizeof(E->xWrite_signature)) == 0) {
+ return kvstorageWrite(args);
+ }
+ else if (memcmp(E->xWrite_signature, xWrite_signatures[xWrite_memdbWrite_enum], sizeof(E->xWrite_signature)) == 0) {
+ return memdbWrite(args);
+ }
+ else if (memcmp(E->xWrite_signature, xWrite_signatures[xWrite_memjrnlWrite_enum], sizeof(E->xWrite_signature)) == 0) {
+ return memjrnlWrite(args);
+ }
+ else if (memcmp(E->xWrite_signature, xWrite_signatures[xWrite_recoverVfsWrite_enum], sizeof(E->xWrite_signature)) == 0) {
+ return recoverVfsWrite(args);
+ }
+ else if (memcmp(E->xWrite_signature, xWrite_signatures[xWrite_vfstraceWrite_enum], sizeof(E->xWrite_signature)) == 0) {
+ return vfstraceWrite(args);
+ }
+ else if (memcmp(E->xWrite_signature, xWrite_signatures[xWrite_unixWrite_enum], sizeof(E->xWrite_signature)) == 0) {
+ return unixWrite(args);
+ }


// Transform return E->xsnprintf(args) to if-chain with 1 candidates
@transform_return_xsnprintf_arrow@
expression E;
identifier FP_NAME = xsnprintf;
expression list args;
@@
- return E->FP_NAME(args);
+ if (memcmp(E->xsnprintf_signature, xsnprintf_signatures[xsnprintf_sqlite3_set_authorizer_enum], sizeof(E->xsnprintf_signature)) == 0) {
+ return sqlite3_set_authorizer(args);
+ }

// Total return transformation rules generated: 321
// ===== RETURN FUNCTION POINTER TRANSFORMATION RULES (DOT) =====

// Transform return E.aggregate_context(args) to direct call (only 1 candidate)
@transform_return_aggregate_context@
expression E;
identifier FP_NAME = aggregate_context;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_aggregate_context(args);


// Transform return E.auto_extension(args) to direct call (only 1 candidate)
@transform_return_auto_extension@
expression E;
identifier FP_NAME = auto_extension;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_vtab_config(args);


// Transform return E.backup_finish(args) to direct call (only 1 candidate)
@transform_return_backup_finish@
expression E;
identifier FP_NAME = backup_finish;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_result_error_code(args);


// Transform return E.backup_init(args) to direct call (only 1 candidate)
@transform_return_backup_init@
expression E;
identifier FP_NAME = backup_init;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_test_control(args);


// Transform return E.backup_pagecount(args) to direct call (only 1 candidate)
@transform_return_backup_pagecount@
expression E;
identifier FP_NAME = backup_pagecount;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_randomness(args);


// Transform return E.backup_remaining(args) to direct call (only 1 candidate)
@transform_return_backup_remaining@
expression E;
identifier FP_NAME = backup_remaining;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_context_db_handle(args);


// Transform return E.backup_step(args) to direct call (only 1 candidate)
@transform_return_backup_step@
expression E;
identifier FP_NAME = backup_step;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_extended_result_codes(args);


// Transform return E.bind_blob64(args) to direct call (only 1 candidate)
@transform_return_bind_blob64@
expression E;
identifier FP_NAME = bind_blob64;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_vtab_on_conflict(args);


// Transform return E.bind_int(args) to direct call (only 1 candidate)
@transform_return_bind_int@
expression E;
identifier FP_NAME = bind_int;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_bind_double(args);


// Transform return E.bind_int64(args) to direct call (only 1 candidate)
@transform_return_bind_int64@
expression E;
identifier FP_NAME = bind_int64;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_bind_int(args);


// Transform return E.bind_null(args) to direct call (only 1 candidate)
@transform_return_bind_null@
expression E;
identifier FP_NAME = bind_null;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_bind_int64(args);


// Transform return E.bind_parameter_count(args) to direct call (only 1 candidate)
@transform_return_bind_parameter_count@
expression E;
identifier FP_NAME = bind_parameter_count;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_bind_null(args);


// Transform return E.bind_parameter_index(args) to direct call (only 1 candidate)
@transform_return_bind_parameter_index@
expression E;
identifier FP_NAME = bind_parameter_index;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_bind_parameter_count(args);


// Transform return E.bind_parameter_name(args) to direct call (only 1 candidate)
@transform_return_bind_parameter_name@
expression E;
identifier FP_NAME = bind_parameter_name;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_bind_parameter_index(args);


// Transform return E.bind_text(args) to direct call (only 1 candidate)
@transform_return_bind_text@
expression E;
identifier FP_NAME = bind_text;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_bind_parameter_name(args);


// Transform return E.bind_text16(args) to direct call (only 1 candidate)
@transform_return_bind_text16@
expression E;
identifier FP_NAME = bind_text16;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_bind_text(args);


// Transform return E.bind_text64(args) to direct call (only 1 candidate)
@transform_return_bind_text64@
expression E;
identifier FP_NAME = bind_text64;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_close_v2(args);


// Transform return E.bind_value(args) to direct call (only 1 candidate)
@transform_return_bind_value@
expression E;
identifier FP_NAME = bind_value;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_bind_text16(args);


// Transform return E.bind_zeroblob(args) to direct call (only 1 candidate)
@transform_return_bind_zeroblob@
expression E;
identifier FP_NAME = bind_zeroblob;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_prepare_v2(args);


// Transform return E.bind_zeroblob64(args) to direct call (only 1 candidate)
@transform_return_bind_zeroblob64@
expression E;
identifier FP_NAME = bind_zeroblob64;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_auto_extension(args);


// Transform return E.blob_bytes(args) to direct call (only 1 candidate)
@transform_return_blob_bytes@
expression E;
identifier FP_NAME = blob_bytes;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_prepare16_v2(args);


// Transform return E.blob_close(args) to direct call (only 1 candidate)
@transform_return_blob_close@
expression E;
identifier FP_NAME = blob_close;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_clear_bindings(args);


// Transform return E.blob_open(args) to direct call (only 1 candidate)
@transform_return_blob_open@
expression E;
identifier FP_NAME = blob_open;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_create_module_v2(args);


// Transform return E.blob_read(args) to direct call (only 1 candidate)
@transform_return_blob_read@
expression E;
identifier FP_NAME = blob_read;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_bind_zeroblob(args);


// Transform return E.blob_reopen(args) to direct call (only 1 candidate)
@transform_return_blob_reopen@
expression E;
identifier FP_NAME = blob_reopen;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_db_status(args);


// Transform return E.blob_write(args) to direct call (only 1 candidate)
@transform_return_blob_write@
expression E;
identifier FP_NAME = blob_write;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_blob_bytes(args);


// Transform return E.busy_handler(args) to direct call (only 1 candidate)
@transform_return_busy_handler@
expression E;
identifier FP_NAME = busy_handler;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_bind_value(args);


// Transform return E.busy_timeout(args) to direct call (only 1 candidate)
@transform_return_busy_timeout@
expression E;
identifier FP_NAME = busy_timeout;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_busy_handler(args);


// Transform return E.cancel_auto_extension(args) to direct call (only 1 candidate)
@transform_return_cancel_auto_extension@
expression E;
identifier FP_NAME = cancel_auto_extension;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_db_filename(args);


// Transform return E.changes(args) to direct call (only 1 candidate)
@transform_return_changes@
expression E;
identifier FP_NAME = changes;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_busy_timeout(args);


// Transform return E.changes64(args) to direct call (only 1 candidate)
@transform_return_changes64@
expression E;
identifier FP_NAME = changes64;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_str_value(args);


// Transform return E.clear_bindings(args) to direct call (only 1 candidate)
@transform_return_clear_bindings@
expression E;
identifier FP_NAME = clear_bindings;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_vmprintf(args);


// Transform return E.close(args) to direct call (only 1 candidate)
@transform_return_close@
expression E;
identifier FP_NAME = close;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_changes(args);


// Transform return E.close_v2(args) to direct call (only 1 candidate)
@transform_return_close_v2@
expression E;
identifier FP_NAME = close_v2;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_soft_heap_limit64(args);


// Transform return E.collation_needed(args) to direct call (only 1 candidate)
@transform_return_collation_needed@
expression E;
identifier FP_NAME = collation_needed;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_close(args);


// Transform return E.collation_needed16(args) to direct call (only 1 candidate)
@transform_return_collation_needed16@
expression E;
identifier FP_NAME = collation_needed16;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_collation_needed(args);


// Transform return E.column_blob(args) to direct call (only 1 candidate)
@transform_return_column_blob@
expression E;
identifier FP_NAME = column_blob;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_collation_needed16(args);


// Transform return E.column_bytes(args) to direct call (only 1 candidate)
@transform_return_column_bytes@
expression E;
identifier FP_NAME = column_bytes;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_column_blob(args);


// Transform return E.column_bytes16(args) to direct call (only 1 candidate)
@transform_return_column_bytes16@
expression E;
identifier FP_NAME = column_bytes16;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_column_bytes(args);


// Transform return E.column_count(args) to direct call (only 1 candidate)
@transform_return_column_count@
expression E;
identifier FP_NAME = column_count;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_column_bytes16(args);


// Transform return E.column_database_name(args) to direct call (only 1 candidate)
@transform_return_column_database_name@
expression E;
identifier FP_NAME = column_database_name;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_column_count(args);


// Transform return E.column_database_name16(args) to direct call (only 1 candidate)
@transform_return_column_database_name16@
expression E;
identifier FP_NAME = column_database_name16;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_column_database_name(args);


// Transform return E.column_decltype(args) to direct call (only 1 candidate)
@transform_return_column_decltype@
expression E;
identifier FP_NAME = column_decltype;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_column_database_name16(args);


// Transform return E.column_decltype16(args) to direct call (only 1 candidate)
@transform_return_column_decltype16@
expression E;
identifier FP_NAME = column_decltype16;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_column_decltype(args);


// Transform return E.column_double(args) to direct call (only 1 candidate)
@transform_return_column_double@
expression E;
identifier FP_NAME = column_double;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_column_decltype16(args);


// Transform return E.column_int(args) to direct call (only 1 candidate)
@transform_return_column_int@
expression E;
identifier FP_NAME = column_int;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_column_double(args);


// Transform return E.column_int64(args) to direct call (only 1 candidate)
@transform_return_column_int64@
expression E;
identifier FP_NAME = column_int64;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_column_int(args);


// Transform return E.column_name(args) to direct call (only 1 candidate)
@transform_return_column_name@
expression E;
identifier FP_NAME = column_name;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_column_int64(args);


// Transform return E.column_name16(args) to direct call (only 1 candidate)
@transform_return_column_name16@
expression E;
identifier FP_NAME = column_name16;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_column_name(args);


// Transform return E.column_origin_name(args) to direct call (only 1 candidate)
@transform_return_column_origin_name@
expression E;
identifier FP_NAME = column_origin_name;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_column_name16(args);


// Transform return E.column_origin_name16(args) to direct call (only 1 candidate)
@transform_return_column_origin_name16@
expression E;
identifier FP_NAME = column_origin_name16;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_column_origin_name(args);


// Transform return E.column_table_name(args) to direct call (only 1 candidate)
@transform_return_column_table_name@
expression E;
identifier FP_NAME = column_table_name;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_column_origin_name16(args);


// Transform return E.column_table_name16(args) to direct call (only 1 candidate)
@transform_return_column_table_name16@
expression E;
identifier FP_NAME = column_table_name16;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_column_table_name(args);


// Transform return E.column_text(args) to direct call (only 1 candidate)
@transform_return_column_text@
expression E;
identifier FP_NAME = column_text;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_column_table_name16(args);


// Transform return E.column_text16(args) to direct call (only 1 candidate)
@transform_return_column_text16@
expression E;
identifier FP_NAME = column_text16;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_column_text(args);


// Transform return E.column_type(args) to direct call (only 1 candidate)
@transform_return_column_type@
expression E;
identifier FP_NAME = column_type;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_column_text16(args);


// Transform return E.column_value(args) to direct call (only 1 candidate)
@transform_return_column_value@
expression E;
identifier FP_NAME = column_value;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_column_type(args);


// Transform return E.commit_hook(args) to direct call (only 1 candidate)
@transform_return_commit_hook@
expression E;
identifier FP_NAME = commit_hook;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_column_value(args);


// Transform return E.compileoption_get(args) to direct call (only 1 candidate)
@transform_return_compileoption_get@
expression E;
identifier FP_NAME = compileoption_get;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_limit(args);


// Transform return E.compileoption_used(args) to direct call (only 1 candidate)
@transform_return_compileoption_used@
expression E;
identifier FP_NAME = compileoption_used;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_next_stmt(args);


// Transform return E.complete(args) to direct call (only 1 candidate)
@transform_return_complete@
expression E;
identifier FP_NAME = complete;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_commit_hook(args);


// Transform return E.complete16(args) to direct call (only 1 candidate)
@transform_return_complete16@
expression E;
identifier FP_NAME = complete16;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_complete(args);


// Transform return E.context_db_handle(args) to direct call (only 1 candidate)
@transform_return_context_db_handle@
expression E;
identifier FP_NAME = context_db_handle;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_soft_heap_limit(args);


// Transform return E.create_collation(args) to direct call (only 1 candidate)
@transform_return_create_collation@
expression E;
identifier FP_NAME = create_collation;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_complete16(args);


// Transform return E.create_collation16(args) to direct call (only 1 candidate)
@transform_return_create_collation16@
expression E;
identifier FP_NAME = create_collation16;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_create_collation(args);


// Transform return E.create_collation_v2(args) to direct call (only 1 candidate)
@transform_return_create_collation_v2@
expression E;
identifier FP_NAME = create_collation_v2;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_blob_close(args);


// Transform return E.create_filename(args) to direct call (only 1 candidate)
@transform_return_create_filename@
expression E;
identifier FP_NAME = create_filename;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_str_appendchar(args);


// Transform return E.create_function(args) to direct call (only 1 candidate)
@transform_return_create_function@
expression E;
identifier FP_NAME = create_function;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_create_collation16(args);


// Transform return E.create_function16(args) to direct call (only 1 candidate)
@transform_return_create_function16@
expression E;
identifier FP_NAME = create_function16;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_create_function(args);


// Transform return E.create_function_v2(args) to direct call (only 1 candidate)
@transform_return_create_function_v2@
expression E;
identifier FP_NAME = create_function_v2;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_sql(args);


// Transform return E.create_module(args) to direct call (only 1 candidate)
@transform_return_create_module@
expression E;
identifier FP_NAME = create_module;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_create_function16(args);


// Transform return E.create_module_v2(args) to direct call (only 1 candidate)
@transform_return_create_module_v2@
expression E;
identifier FP_NAME = create_module_v2;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_overload_function(args);


// Transform return E.create_window_function(args) to direct call (only 1 candidate)
@transform_return_create_window_function@
expression E;
identifier FP_NAME = create_window_function;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_vtab_collation(args);


// Transform return E.data_count(args) to direct call (only 1 candidate)
@transform_return_data_count@
expression E;
identifier FP_NAME = data_count;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_create_module(args);


// Transform return E.database_file_object(args) to direct call (only 1 candidate)
@transform_return_database_file_object@
expression E;
identifier FP_NAME = database_file_object;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_str_errcode(args);


// Transform return E.db_cacheflush(args) to direct call (only 1 candidate)
@transform_return_db_cacheflush@
expression E;
identifier FP_NAME = db_cacheflush;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_malloc64(args);


// Transform return E.db_config(args) to direct call (only 1 candidate)
@transform_return_db_config@
expression E;
identifier FP_NAME = db_config;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_status(args);


// Transform return E.db_filename(args) to direct call (only 1 candidate)
@transform_return_db_filename@
expression E;
identifier FP_NAME = db_filename;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_sourceid(args);


// Transform return E.db_handle(args) to direct call (only 1 candidate)
@transform_return_db_handle@
expression E;
identifier FP_NAME = db_handle;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_data_count(args);


// Transform return E.db_mutex(args) to direct call (only 1 candidate)
@transform_return_db_mutex@
expression E;
identifier FP_NAME = db_mutex;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_backup_finish(args);


// Transform return E.db_name(args) to direct call (only 1 candidate)
@transform_return_db_name@
expression E;
identifier FP_NAME = db_name;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_filename_journal(args);


// Transform return E.db_readonly(args) to direct call (only 1 candidate)
@transform_return_db_readonly@
expression E;
identifier FP_NAME = db_readonly;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_stmt_status(args);


// Transform return E.db_release_memory(args) to direct call (only 1 candidate)
@transform_return_db_release_memory@
expression E;
identifier FP_NAME = db_release_memory;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_strnicmp(args);


// Transform return E.db_status(args) to direct call (only 1 candidate)
@transform_return_db_status@
expression E;
identifier FP_NAME = db_status;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_backup_init(args);


// Transform return E.declare_vtab(args) to direct call (only 1 candidate)
@transform_return_declare_vtab@
expression E;
identifier FP_NAME = declare_vtab;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_db_handle(args);


// Transform return E.deserialize(args) to direct call (only 1 candidate)
@transform_return_deserialize@
expression E;
identifier FP_NAME = deserialize;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_uri_key(args);


// Transform return E.drop_modules(args) to direct call (only 1 candidate)
@transform_return_drop_modules@
expression E;
identifier FP_NAME = drop_modules;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_str_new(args);


// Transform return E.enable_shared_cache(args) to direct call (only 1 candidate)
@transform_return_enable_shared_cache@
expression E;
identifier FP_NAME = enable_shared_cache;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_declare_vtab(args);


// Transform return E.errcode(args) to direct call (only 1 candidate)
@transform_return_errcode@
expression E;
identifier FP_NAME = errcode;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_enable_shared_cache(args);


// Transform return E.errmsg(args) to direct call (only 1 candidate)
@transform_return_errmsg@
expression E;
identifier FP_NAME = errmsg;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_errcode(args);


// Transform return E.errmsg16(args) to direct call (only 1 candidate)
@transform_return_errmsg16@
expression E;
identifier FP_NAME = errmsg16;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_errmsg(args);


// Transform return E.exec(args) to direct call (only 1 candidate)
@transform_return_exec@
expression E;
identifier FP_NAME = exec;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_errmsg16(args);


// Transform return E.expanded_sql(args) to direct call (only 1 candidate)
@transform_return_expanded_sql@
expression E;
identifier FP_NAME = expanded_sql;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_reset_auto_extension(args);


// Transform return E.expired(args) to direct call (only 1 candidate)
@transform_return_expired@
expression E;
identifier FP_NAME = expired;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_exec(args);


// Transform return E.extended_errcode(args) to direct call (only 1 candidate)
@transform_return_extended_errcode@
expression E;
identifier FP_NAME = extended_errcode;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_backup_pagecount(args);


// Transform return E.extended_result_codes(args) to direct call (only 1 candidate)
@transform_return_extended_result_codes@
expression E;
identifier FP_NAME = extended_result_codes;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_vfs_find(args);


// Transform return E.file_control(args) to direct call (only 1 candidate)
@transform_return_file_control@
expression E;
identifier FP_NAME = file_control;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_blob_open(args);


// Transform return E.filename_database(args) to direct call (only 1 candidate)
@transform_return_filename_database@
expression E;
identifier FP_NAME = filename_database;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_str_vappendf(args);


// Transform return E.filename_journal(args) to direct call (only 1 candidate)
@transform_return_filename_journal@
expression E;
identifier FP_NAME = filename_journal;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_str_append(args);


// Transform return E.filename_wal(args) to direct call (only 1 candidate)
@transform_return_filename_wal@
expression E;
identifier FP_NAME = filename_wal;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_str_appendall(args);


// Transform return E.free_filename(args) to direct call (only 1 candidate)
@transform_return_free_filename@
expression E;
identifier FP_NAME = free_filename;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_str_reset(args);


// Transform return E.get_autocommit(args) to direct call (only 1 candidate)
@transform_return_get_autocommit@
expression E;
identifier FP_NAME = get_autocommit;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_free(args);


// Transform return E.get_auxdata(args) to direct call (only 1 candidate)
@transform_return_get_auxdata@
expression E;
identifier FP_NAME = get_auxdata;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_free_table(args);


// Transform return E.get_clientdata(args) to direct call (only 1 candidate)
@transform_return_get_clientdata@
expression E;
identifier FP_NAME = get_clientdata;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_database_file_object(args);


// Transform return E.get_table(args) to direct call (only 1 candidate)
@transform_return_get_table@
expression E;
identifier FP_NAME = get_table;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_get_autocommit(args);


// Transform return E.global_recover(args) to direct call (only 1 candidate)
@transform_return_global_recover@
expression E;
identifier FP_NAME = global_recover;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_get_auxdata(args);


// Transform return E.hard_heap_limit64(args) to direct call (only 1 candidate)
@transform_return_hard_heap_limit64@
expression E;
identifier FP_NAME = hard_heap_limit64;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_str_finish(args);


// Transform return E.interruptx(args) to direct call (only 1 candidate)
@transform_return_interruptx@
expression E;
identifier FP_NAME = interruptx;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_get_table(args);


// Transform return E.is_interrupted(args) to direct call (only 1 candidate)
@transform_return_is_interrupted@
expression E;
identifier FP_NAME = is_interrupted;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_create_filename(args);


// Transform return E.keyword_check(args) to direct call (only 1 candidate)
@transform_return_keyword_check@
expression E;
identifier FP_NAME = keyword_check;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_db_cacheflush(args);


// Transform return E.keyword_count(args) to direct call (only 1 candidate)
@transform_return_keyword_count@
expression E;
identifier FP_NAME = keyword_count;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_status64(args);


// Transform return E.keyword_name(args) to direct call (only 1 candidate)
@transform_return_keyword_name@
expression E;
identifier FP_NAME = keyword_name;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_strlike(args);


// Transform return E.libversion(args) to direct call (only 1 candidate)
@transform_return_libversion@
expression E;
identifier FP_NAME = libversion;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_interrupt(args);


// Transform return E.libversion_number(args) to direct call (only 1 candidate)
@transform_return_libversion_number@
expression E;
identifier FP_NAME = libversion_number;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_last_insert_rowid(args);


// Transform return E.limit(args) to direct call (only 1 candidate)
@transform_return_limit@
expression E;
identifier FP_NAME = limit;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_vfs_register(args);


// Transform return E.load_extension(args) to direct call (only 1 candidate)
@transform_return_load_extension@
expression E;
identifier FP_NAME = load_extension;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_db_readonly(args);


// Transform return E.log(args) to direct call (only 1 candidate)
@transform_return_log@
expression E;
identifier FP_NAME = log;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_backup_remaining(args);


// Transform return E.malloc(args) to direct call (only 1 candidate)
@transform_return_malloc@
expression E;
identifier FP_NAME = malloc;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_libversion(args);


// Transform return E.malloc64(args) to direct call (only 1 candidate)
@transform_return_malloc64@
expression E;
identifier FP_NAME = malloc64;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_db_release_memory(args);


// Transform return E.memory_highwater(args) to direct call (only 1 candidate)
@transform_return_memory_highwater@
expression E;
identifier FP_NAME = memory_highwater;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_blob_read(args);


// Transform return E.memory_used(args) to direct call (only 1 candidate)
@transform_return_memory_used@
expression E;
identifier FP_NAME = memory_used;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_blob_write(args);


// Transform return E.mprintf(args) to direct call (only 1 candidate)
@transform_return_mprintf@
expression E;
identifier FP_NAME = mprintf;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_libversion_number(args);


// Transform return E.msize(args) to direct call (only 1 candidate)
@transform_return_msize@
expression E;
identifier FP_NAME = msize;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_errstr(args);


// Transform return E.mutex_alloc(args) to direct call (only 1 candidate)
@transform_return_mutex_alloc@
expression E;
identifier FP_NAME = mutex_alloc;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_create_collation_v2(args);


// Transform return E.mutex_enter(args) to direct call (only 1 candidate)
@transform_return_mutex_enter@
expression E;
identifier FP_NAME = mutex_enter;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_file_control(args);


// Transform return E.mutex_free(args) to direct call (only 1 candidate)
@transform_return_mutex_free@
expression E;
identifier FP_NAME = mutex_free;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_memory_highwater(args);


// Transform return E.mutex_leave(args) to direct call (only 1 candidate)
@transform_return_mutex_leave@
expression E;
identifier FP_NAME = mutex_leave;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_memory_used(args);


// Transform return E.next_stmt(args) to direct call (only 1 candidate)
@transform_return_next_stmt@
expression E;
identifier FP_NAME = next_stmt;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_vfs_unregister(args);


// Transform return E.normalized_sql(args) to direct call (only 1 candidate)
@transform_return_normalized_sql@
expression E;
identifier FP_NAME = normalized_sql;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_keyword_count(args);


// Transform return E.open(args) to direct call (only 1 candidate)
@transform_return_open@
expression E;
identifier FP_NAME = open;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_malloc(args);


// Transform return E.open16(args) to direct call (only 1 candidate)
@transform_return_open16@
expression E;
identifier FP_NAME = open16;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_mprintf(args);


// Transform return E.overload_function(args) to direct call (only 1 candidate)
@transform_return_overload_function@
expression E;
identifier FP_NAME = overload_function;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_value_text16be(args);


// Transform return E.prepare(args) to direct call (only 1 candidate)
@transform_return_prepare@
expression E;
identifier FP_NAME = prepare;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_open(args);


// Transform return E.prepare16(args) to direct call (only 1 candidate)
@transform_return_prepare16@
expression E;
identifier FP_NAME = prepare16;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_open16(args);


// Transform return E.prepare16_v2(args) to direct call (only 1 candidate)
@transform_return_prepare16_v2@
expression E;
identifier FP_NAME = prepare16_v2;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_value_type(args);


// Transform return E.prepare16_v3(args) to direct call (only 1 candidate)
@transform_return_prepare16_v3@
expression E;
identifier FP_NAME = prepare16_v3;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_strglob(args);


// Transform return E.prepare_v2(args) to direct call (only 1 candidate)
@transform_return_prepare_v2@
expression E;
identifier FP_NAME = prepare_v2;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_value_text16le(args);


// Transform return E.prepare_v3(args) to direct call (only 1 candidate)
@transform_return_prepare_v3@
expression E;
identifier FP_NAME = prepare_v3;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_result_text64(args);


// Transform return E.profile(args) to direct call (only 1 candidate)
@transform_return_profile@
expression E;
identifier FP_NAME = profile;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_prepare(args);


// Transform return E.progress_handler(args) to direct call (only 1 candidate)
@transform_return_progress_handler@
expression E;
identifier FP_NAME = progress_handler;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_prepare16(args);


// Transform return E.randomness(args) to direct call (only 1 candidate)
@transform_return_randomness@
expression E;
identifier FP_NAME = randomness;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_sleep(args);


// Transform return E.realloc(args) to direct call (only 1 candidate)
@transform_return_realloc@
expression E;
identifier FP_NAME = realloc;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_profile(args);


// Transform return E.realloc64(args) to direct call (only 1 candidate)
@transform_return_realloc64@
expression E;
identifier FP_NAME = realloc64;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_stmt_busy(args);


// Transform return E.reset(args) to direct call (only 1 candidate)
@transform_return_reset@
expression E;
identifier FP_NAME = reset;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_progress_handler(args);


// Transform return E.reset_auto_extension(args) to direct call (only 1 candidate)
@transform_return_reset_auto_extension@
expression E;
identifier FP_NAME = reset_auto_extension;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_stmt_readonly(args);


// Transform return E.result_blob(args) to direct call (only 1 candidate)
@transform_return_result_blob@
expression E;
identifier FP_NAME = result_blob;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_realloc(args);


// Transform return E.result_blob64(args) to direct call (only 1 candidate)
@transform_return_result_blob64@
expression E;
identifier FP_NAME = result_blob64;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_stricmp(args);


// Transform return E.result_double(args) to direct call (only 1 candidate)
@transform_return_result_double@
expression E;
identifier FP_NAME = result_double;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_reset(args);


// Transform return E.result_error(args) to direct call (only 1 candidate)
@transform_return_result_error@
expression E;
identifier FP_NAME = result_error;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_result_blob(args);


// Transform return E.result_error16(args) to direct call (only 1 candidate)
@transform_return_result_error16@
expression E;
identifier FP_NAME = result_error16;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_result_double(args);


// Transform return E.result_error_code(args) to direct call (only 1 candidate)
@transform_return_result_error_code@
expression E;
identifier FP_NAME = result_error_code;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_result_error_nomem(args);


// Transform return E.result_int(args) to direct call (only 1 candidate)
@transform_return_result_int@
expression E;
identifier FP_NAME = result_int;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_result_error(args);


// Transform return E.result_int64(args) to direct call (only 1 candidate)
@transform_return_result_int64@
expression E;
identifier FP_NAME = result_int64;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_result_error16(args);


// Transform return E.result_null(args) to direct call (only 1 candidate)
@transform_return_result_null@
expression E;
identifier FP_NAME = result_null;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_result_int(args);


// Transform return E.result_pointer(args) to direct call (only 1 candidate)
@transform_return_result_pointer@
expression E;
identifier FP_NAME = result_pointer;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_value_free(args);


// Transform return E.result_subtype(args) to direct call (only 1 candidate)
@transform_return_result_subtype@
expression E;
identifier FP_NAME = result_subtype;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_bind_text64(args);


// Transform return E.result_text(args) to direct call (only 1 candidate)
@transform_return_result_text@
expression E;
identifier FP_NAME = result_text;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_result_int64(args);


// Transform return E.result_text16(args) to direct call (only 1 candidate)
@transform_return_result_text16@
expression E;
identifier FP_NAME = result_text16;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_result_null(args);


// Transform return E.result_text16be(args) to direct call (only 1 candidate)
@transform_return_result_text16be@
expression E;
identifier FP_NAME = result_text16be;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_result_text(args);


// Transform return E.result_text16le(args) to direct call (only 1 candidate)
@transform_return_result_text16le@
expression E;
identifier FP_NAME = result_text16le;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_result_text16(args);


// Transform return E.result_text64(args) to direct call (only 1 candidate)
@transform_return_result_text64@
expression E;
identifier FP_NAME = result_text64;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_uri_boolean(args);


// Transform return E.result_value(args) to direct call (only 1 candidate)
@transform_return_result_value@
expression E;
identifier FP_NAME = result_value;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_result_text16be(args);


// Transform return E.result_zeroblob(args) to direct call (only 1 candidate)
@transform_return_result_zeroblob@
expression E;
identifier FP_NAME = result_zeroblob;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_release_memory(args);


// Transform return E.result_zeroblob64(args) to direct call (only 1 candidate)
@transform_return_result_zeroblob64@
expression E;
identifier FP_NAME = result_zeroblob64;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_wal_checkpoint_v2(args);


// Transform return E.rollback_hook(args) to direct call (only 1 candidate)
@transform_return_rollback_hook@
expression E;
identifier FP_NAME = rollback_hook;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_result_text16le(args);


// Transform return E.serialize(args) to direct call (only 1 candidate)
@transform_return_serialize@
expression E;
identifier FP_NAME = serialize;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_filename_database(args);


// Transform return E.set_authorizer(args) to direct call (only 1 candidate)
@transform_return_set_authorizer@
expression E;
identifier FP_NAME = set_authorizer;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_result_value(args);


// Transform return E.set_auxdata(args) to direct call (only 1 candidate)
@transform_return_set_auxdata@
expression E;
identifier FP_NAME = set_auxdata;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_rollback_hook(args);


// Transform return E.set_clientdata(args) to direct call (only 1 candidate)
@transform_return_set_clientdata@
expression E;
identifier FP_NAME = set_clientdata;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_txn_state(args);


// Transform return E.set_last_insert_rowid(args) to direct call (only 1 candidate)
@transform_return_set_last_insert_rowid@
expression E;
identifier FP_NAME = set_last_insert_rowid;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_result_blob64(args);


// Transform return E.setlk_timeout(args) to direct call (only 1 candidate)
@transform_return_setlk_timeout@
expression E;
identifier FP_NAME = setlk_timeout;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_changes64(args);


// Transform return E.soft_heap_limit(args) to direct call (only 1 candidate)
@transform_return_soft_heap_limit@
expression E;
identifier FP_NAME = soft_heap_limit;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_mutex_enter(args);


// Transform return E.soft_heap_limit64(args) to direct call (only 1 candidate)
@transform_return_soft_heap_limit64@
expression E;
identifier FP_NAME = soft_heap_limit64;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_backup_step(args);


// Transform return E.sql(args) to direct call (only 1 candidate)
@transform_return_sql@
expression E;
identifier FP_NAME = sql;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_threadsafe(args);


// Transform return E.status(args) to direct call (only 1 candidate)
@transform_return_status@
expression E;
identifier FP_NAME = status;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_result_zeroblob(args);


// Transform return E.status64(args) to direct call (only 1 candidate)
@transform_return_status64@
expression E;
identifier FP_NAME = status64;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_cancel_auto_extension(args);


// Transform return E.step(args) to direct call (only 1 candidate)
@transform_return_step@
expression E;
identifier FP_NAME = step;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_set_auxdata(args);


// Transform return E.stmt_explain(args) to direct call (only 1 candidate)
@transform_return_stmt_explain@
expression E;
identifier FP_NAME = stmt_explain;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_free_filename(args);


// Transform return E.stmt_isexplain(args) to direct call (only 1 candidate)
@transform_return_stmt_isexplain@
expression E;
identifier FP_NAME = stmt_isexplain;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_keyword_name(args);


// Transform return E.stmt_status(args) to direct call (only 1 candidate)
@transform_return_stmt_status@
expression E;
identifier FP_NAME = stmt_status;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_compileoption_used(args);


// Transform return E.str_append(args) to direct call (only 1 candidate)
@transform_return_str_append@
expression E;
identifier FP_NAME = str_append;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_prepare_v3(args);


// Transform return E.str_appendall(args) to direct call (only 1 candidate)
@transform_return_str_appendall@
expression E;
identifier FP_NAME = str_appendall;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_prepare16_v3(args);


// Transform return E.str_appendchar(args) to direct call (only 1 candidate)
@transform_return_str_appendchar@
expression E;
identifier FP_NAME = str_appendchar;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_bind_pointer(args);


// Transform return E.str_appendf(args) to direct call (only 1 candidate)
@transform_return_str_appendf@
expression E;
identifier FP_NAME = str_appendf;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_expanded_sql(args);


// Transform return E.str_errcode(args) to direct call (only 1 candidate)
@transform_return_str_errcode@
expression E;
identifier FP_NAME = str_errcode;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_value_pointer(args);


// Transform return E.str_finish(args) to direct call (only 1 candidate)
@transform_return_str_finish@
expression E;
identifier FP_NAME = str_finish;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_trace_v2(args);


// Transform return E.str_length(args) to direct call (only 1 candidate)
@transform_return_str_length@
expression E;
identifier FP_NAME = str_length;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_vtab_nochange(args);


// Transform return E.str_new(args) to direct call (only 1 candidate)
@transform_return_str_new@
expression E;
identifier FP_NAME = str_new;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_system_errno(args);


// Transform return E.str_reset(args) to direct call (only 1 candidate)
@transform_return_str_reset@
expression E;
identifier FP_NAME = str_reset;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_result_pointer(args);


// Transform return E.str_value(args) to direct call (only 1 candidate)
@transform_return_str_value@
expression E;
identifier FP_NAME = str_value;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_value_nochange(args);


// Transform return E.str_vappendf(args) to direct call (only 1 candidate)
@transform_return_str_vappendf@
expression E;
identifier FP_NAME = str_vappendf;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_set_last_insert_rowid(args);


// Transform return E.strglob(args) to direct call (only 1 candidate)
@transform_return_strglob@
expression E;
identifier FP_NAME = strglob;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_uri_int64(args);


// Transform return E.stricmp(args) to direct call (only 1 candidate)
@transform_return_stricmp@
expression E;
identifier FP_NAME = stricmp;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_wal_checkpoint(args);


// Transform return E.strlike(args) to direct call (only 1 candidate)
@transform_return_strlike@
expression E;
identifier FP_NAME = strlike;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_load_extension(args);


// Transform return E.system_errno(args) to direct call (only 1 candidate)
@transform_return_system_errno@
expression E;
identifier FP_NAME = system_errno;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_msize(args);


// Transform return E.table_column_metadata(args) to direct call (only 1 candidate)
@transform_return_table_column_metadata@
expression E;
identifier FP_NAME = table_column_metadata;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_snprintf(args);


// Transform return E.test_control(args) to direct call (only 1 candidate)
@transform_return_test_control@
expression E;
identifier FP_NAME = test_control;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_result_error_toobig(args);


// Transform return E.thread_cleanup(args) to direct call (only 1 candidate)
@transform_return_thread_cleanup@
expression E;
identifier FP_NAME = thread_cleanup;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_step(args);


// Transform return E.total_changes(args) to direct call (only 1 candidate)
@transform_return_total_changes@
expression E;
identifier FP_NAME = total_changes;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_table_column_metadata(args);


// Transform return E.total_changes64(args) to direct call (only 1 candidate)
@transform_return_total_changes64@
expression E;
identifier FP_NAME = total_changes64;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_create_window_function(args);


// Transform return E.trace_v2(args) to direct call (only 1 candidate)
@transform_return_trace_v2@
expression E;
identifier FP_NAME = trace_v2;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_realloc64(args);


// Transform return E.txn_state(args) to direct call (only 1 candidate)
@transform_return_txn_state@
expression E;
identifier FP_NAME = txn_state;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_str_length(args);


// Transform return E.uri_boolean(args) to direct call (only 1 candidate)
@transform_return_uri_boolean@
expression E;
identifier FP_NAME = uri_boolean;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_wal_hook(args);


// Transform return E.uri_key(args) to direct call (only 1 candidate)
@transform_return_uri_key@
expression E;
identifier FP_NAME = uri_key;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_str_appendf(args);


// Transform return E.user_data(args) to direct call (only 1 candidate)
@transform_return_user_data@
expression E;
identifier FP_NAME = user_data;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_trace(args);


// Transform return E.value_double(args) to direct call (only 1 candidate)
@transform_return_value_double@
expression E;
identifier FP_NAME = value_double;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_user_data(args);


// Transform return E.value_dup(args) to direct call (only 1 candidate)
@transform_return_value_dup@
expression E;
identifier FP_NAME = value_dup;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_uri_parameter(args);


// Transform return E.value_encoding(args) to direct call (only 1 candidate)
@transform_return_value_encoding@
expression E;
identifier FP_NAME = value_encoding;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_filename_wal(args);


// Transform return E.value_free(args) to direct call (only 1 candidate)
@transform_return_value_free@
expression E;
identifier FP_NAME = value_free;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_vsnprintf(args);


// Transform return E.value_frombind(args) to direct call (only 1 candidate)
@transform_return_value_frombind@
expression E;
identifier FP_NAME = value_frombind;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_keyword_check(args);


// Transform return E.value_int(args) to direct call (only 1 candidate)
@transform_return_value_int@
expression E;
identifier FP_NAME = value_int;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_value_blob(args);


// Transform return E.value_int64(args) to direct call (only 1 candidate)
@transform_return_value_int64@
expression E;
identifier FP_NAME = value_int64;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_value_bytes(args);


// Transform return E.value_nochange(args) to direct call (only 1 candidate)
@transform_return_value_nochange@
expression E;
identifier FP_NAME = value_nochange;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_value_subtype(args);


// Transform return E.value_numeric_type(args) to direct call (only 1 candidate)
@transform_return_value_numeric_type@
expression E;
identifier FP_NAME = value_numeric_type;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_value_bytes16(args);


// Transform return E.value_pointer(args) to direct call (only 1 candidate)
@transform_return_value_pointer@
expression E;
identifier FP_NAME = value_pointer;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_result_zeroblob64(args);


// Transform return E.value_subtype(args) to direct call (only 1 candidate)
@transform_return_value_subtype@
expression E;
identifier FP_NAME = value_subtype;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_bind_blob64(args);


// Transform return E.value_text(args) to direct call (only 1 candidate)
@transform_return_value_text@
expression E;
identifier FP_NAME = value_text;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_value_double(args);


// Transform return E.value_text16(args) to direct call (only 1 candidate)
@transform_return_value_text16@
expression E;
identifier FP_NAME = value_text16;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_value_int(args);


// Transform return E.value_text16be(args) to direct call (only 1 candidate)
@transform_return_value_text16be@
expression E;
identifier FP_NAME = value_text16be;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_value_int64(args);


// Transform return E.value_text16le(args) to direct call (only 1 candidate)
@transform_return_value_text16le@
expression E;
identifier FP_NAME = value_text16le;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_value_numeric_type(args);


// Transform return E.value_type(args) to direct call (only 1 candidate)
@transform_return_value_type@
expression E;
identifier FP_NAME = value_type;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_value_text(args);


// Transform return E.vfs_find(args) to direct call (only 1 candidate)
@transform_return_vfs_find@
expression E;
identifier FP_NAME = vfs_find;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_mutex_free(args);


// Transform return E.vfs_register(args) to direct call (only 1 candidate)
@transform_return_vfs_register@
expression E;
identifier FP_NAME = vfs_register;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_mutex_leave(args);


// Transform return E.vfs_unregister(args) to direct call (only 1 candidate)
@transform_return_vfs_unregister@
expression E;
identifier FP_NAME = vfs_unregister;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_mutex_try(args);


// Transform return E.vmprintf(args) to direct call (only 1 candidate)
@transform_return_vmprintf@
expression E;
identifier FP_NAME = vmprintf;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_value_text16(args);


// Transform return E.vtab_collation(args) to direct call (only 1 candidate)
@transform_return_vtab_collation@
expression E;
identifier FP_NAME = vtab_collation;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_result_subtype(args);


// Transform return E.vtab_config(args) to direct call (only 1 candidate)
@transform_return_vtab_config@
expression E;
identifier FP_NAME = vtab_config;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_extended_errcode(args);


// Transform return E.vtab_distinct(args) to direct call (only 1 candidate)
@transform_return_vtab_distinct@
expression E;
identifier FP_NAME = vtab_distinct;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_value_frombind(args);


// Transform return E.vtab_nochange(args) to direct call (only 1 candidate)
@transform_return_vtab_nochange@
expression E;
identifier FP_NAME = vtab_nochange;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_bind_zeroblob64(args);


// Transform return E.vtab_on_conflict(args) to direct call (only 1 candidate)
@transform_return_vtab_on_conflict@
expression E;
identifier FP_NAME = vtab_on_conflict;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_log(args);


// Transform return E.wal_checkpoint(args) to direct call (only 1 candidate)
@transform_return_wal_checkpoint@
expression E;
identifier FP_NAME = wal_checkpoint;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_db_config(args);


// Transform return E.wal_hook(args) to direct call (only 1 candidate)
@transform_return_wal_hook@
expression E;
identifier FP_NAME = wal_hook;
expression list args;
@@
- return E.FP_NAME(args);
+ return sqlite3_db_mutex(args);


// Transform return E.xAccess(args) to if-chain with 4 candidates
@transform_return_xAccess@
expression E;
identifier FP_NAME = xAccess;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xAccess_signature, xAccess_signatures[xAccess_apndAccess_enum], sizeof(E.xAccess_signature)) == 0) {
+ return apndAccess(args);
+ }
+ else if (memcmp(E.xAccess_signature, xAccess_signatures[xAccess_memdbAccess_enum], sizeof(E.xAccess_signature)) == 0) {
+ return memdbAccess(args);
+ }
+ else if (memcmp(E.xAccess_signature, xAccess_signatures[xAccess_vfstraceAccess_enum], sizeof(E.xAccess_signature)) == 0) {
+ return vfstraceAccess(args);
+ }
+ else if (memcmp(E.xAccess_signature, xAccess_signatures[xAccess_unixAccess_enum], sizeof(E.xAccess_signature)) == 0) {
+ return unixAccess(args);
+ }


// Transform return E.xBegin(args) to if-chain with 4 candidates
@transform_return_xBegin@
expression E;
identifier FP_NAME = xBegin;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xBegin_signature, xBegin_signatures[xBegin_0_enum], sizeof(E.xBegin_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xBegin_signature, xBegin_signatures[xBegin_dbpageBegin_enum], sizeof(E.xBegin_signature)) == 0) {
+ return dbpageBegin(args);
+ }
+ else if (memcmp(E.xBegin_signature, xBegin_signatures[xBegin_fts3BeginMethod_enum], sizeof(E.xBegin_signature)) == 0) {
+ return fts3BeginMethod(args);
+ }
+ else if (memcmp(E.xBegin_signature, xBegin_signatures[xBegin_rtreeBeginTransaction_enum], sizeof(E.xBegin_signature)) == 0) {
+ return rtreeBeginTransaction(args);
+ }
+ else if (memcmp(E.xBegin_signature, xBegin_signatures[xBegin_zipfileBegin_enum], sizeof(E.xBegin_signature)) == 0) {
+ return zipfileBegin(args);
+ }


// Transform return E.xBestIndex(args) to if-chain with 16 candidates
@transform_return_xBestIndex@
expression E;
identifier FP_NAME = xBestIndex;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xBestIndex_signature, xBestIndex_signatures[xBestIndex_bytecodevtabBestIndex_enum], sizeof(E.xBestIndex_signature)) == 0) {
+ return bytecodevtabBestIndex(args);
+ }
+ else if (memcmp(E.xBestIndex_signature, xBestIndex_signatures[xBestIndex_completionBestIndex_enum], sizeof(E.xBestIndex_signature)) == 0) {
+ return completionBestIndex(args);
+ }
+ else if (memcmp(E.xBestIndex_signature, xBestIndex_signatures[xBestIndex_dbdataBestIndex_enum], sizeof(E.xBestIndex_signature)) == 0) {
+ return dbdataBestIndex(args);
+ }
+ else if (memcmp(E.xBestIndex_signature, xBestIndex_signatures[xBestIndex_dbpageBestIndex_enum], sizeof(E.xBestIndex_signature)) == 0) {
+ return dbpageBestIndex(args);
+ }
+ else if (memcmp(E.xBestIndex_signature, xBestIndex_signatures[xBestIndex_expertBestIndex_enum], sizeof(E.xBestIndex_signature)) == 0) {
+ return expertBestIndex(args);
+ }
+ else if (memcmp(E.xBestIndex_signature, xBestIndex_signatures[xBestIndex_fsdirBestIndex_enum], sizeof(E.xBestIndex_signature)) == 0) {
+ return fsdirBestIndex(args);
+ }
+ else if (memcmp(E.xBestIndex_signature, xBestIndex_signatures[xBestIndex_fts3BestIndexMethod_enum], sizeof(E.xBestIndex_signature)) == 0) {
+ return fts3BestIndexMethod(args);
+ }
+ else if (memcmp(E.xBestIndex_signature, xBestIndex_signatures[xBestIndex_fts3auxBestIndexMethod_enum], sizeof(E.xBestIndex_signature)) == 0) {
+ return fts3auxBestIndexMethod(args);
+ }
+ else if (memcmp(E.xBestIndex_signature, xBestIndex_signatures[xBestIndex_fts3tokBestIndexMethod_enum], sizeof(E.xBestIndex_signature)) == 0) {
+ return fts3tokBestIndexMethod(args);
+ }
+ else if (memcmp(E.xBestIndex_signature, xBestIndex_signatures[xBestIndex_jsonEachBestIndex_enum], sizeof(E.xBestIndex_signature)) == 0) {
+ return jsonEachBestIndex(args);
+ }
+ else if (memcmp(E.xBestIndex_signature, xBestIndex_signatures[xBestIndex_pragmaVtabBestIndex_enum], sizeof(E.xBestIndex_signature)) == 0) {
+ return pragmaVtabBestIndex(args);
+ }
+ else if (memcmp(E.xBestIndex_signature, xBestIndex_signatures[xBestIndex_rtreeBestIndex_enum], sizeof(E.xBestIndex_signature)) == 0) {
+ return rtreeBestIndex(args);
+ }
+ else if (memcmp(E.xBestIndex_signature, xBestIndex_signatures[xBestIndex_seriesBestIndex_enum], sizeof(E.xBestIndex_signature)) == 0) {
+ return seriesBestIndex(args);
+ }
+ else if (memcmp(E.xBestIndex_signature, xBestIndex_signatures[xBestIndex_statBestIndex_enum], sizeof(E.xBestIndex_signature)) == 0) {
+ return statBestIndex(args);
+ }
+ else if (memcmp(E.xBestIndex_signature, xBestIndex_signatures[xBestIndex_stmtBestIndex_enum], sizeof(E.xBestIndex_signature)) == 0) {
+ return stmtBestIndex(args);
+ }
+ else if (memcmp(E.xBestIndex_signature, xBestIndex_signatures[xBestIndex_zipfileBestIndex_enum], sizeof(E.xBestIndex_signature)) == 0) {
+ return zipfileBestIndex(args);
+ }


// Transform return E.xCachesize(args) to if-chain with 2 candidates
@transform_return_xCachesize@
expression E;
identifier FP_NAME = xCachesize;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xCachesize_signature, xCachesize_signatures[xCachesize_pcache1Cachesize_enum], sizeof(E.xCachesize_signature)) == 0) {
+ return pcache1Cachesize(args);
+ }
+ else if (memcmp(E.xCachesize_signature, xCachesize_signatures[xCachesize_pcachetraceCachesize_enum], sizeof(E.xCachesize_signature)) == 0) {
+ return pcachetraceCachesize(args);
+ }


// Transform return E.xCellSize(args) to if-chain with 4 candidates
@transform_return_xCellSize@
expression E;
identifier FP_NAME = xCellSize;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xCellSize_signature, xCellSize_signatures[xCellSize_cellSizePtr_enum], sizeof(E.xCellSize_signature)) == 0) {
+ return cellSizePtr(args);
+ }
+ else if (memcmp(E.xCellSize_signature, xCellSize_signatures[xCellSize_cellSizePtrIdxLeaf_enum], sizeof(E.xCellSize_signature)) == 0) {
+ return cellSizePtrIdxLeaf(args);
+ }
+ else if (memcmp(E.xCellSize_signature, xCellSize_signatures[xCellSize_cellSizePtrNoPayload_enum], sizeof(E.xCellSize_signature)) == 0) {
+ return cellSizePtrNoPayload(args);
+ }
+ else if (memcmp(E.xCellSize_signature, xCellSize_signatures[xCellSize_cellSizePtrTableLeaf_enum], sizeof(E.xCellSize_signature)) == 0) {
+ return cellSizePtrTableLeaf(args);
+ }


// Transform return E.xCheckReservedLock(args) to if-chain with 6 candidates
@transform_return_xCheckReservedLock@
expression E;
identifier FP_NAME = xCheckReservedLock;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xCheckReservedLock_signature, xCheckReservedLock_signatures[xCheckReservedLock_0_enum], sizeof(E.xCheckReservedLock_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xCheckReservedLock_signature, xCheckReservedLock_signatures[xCheckReservedLock_apndCheckReservedLock_enum], sizeof(E.xCheckReservedLock_signature)) == 0) {
+ return apndCheckReservedLock(args);
+ }
+ else if (memcmp(E.xCheckReservedLock_signature, xCheckReservedLock_signatures[xCheckReservedLock_recoverVfsCheckReservedLock_enum], sizeof(E.xCheckReservedLock_signature)) == 0) {
+ return recoverVfsCheckReservedLock(args);
+ }
+ else if (memcmp(E.xCheckReservedLock_signature, xCheckReservedLock_signatures[xCheckReservedLock_vfstraceCheckReservedLock_enum], sizeof(E.xCheckReservedLock_signature)) == 0) {
+ return vfstraceCheckReservedLock(args);
+ }
+ else if (memcmp(E.xCheckReservedLock_signature, xCheckReservedLock_signatures[xCheckReservedLock_unixCheckReservedLock_enum], sizeof(E.xCheckReservedLock_signature)) == 0) {
+ return unixCheckReservedLock(args);
+ }
+ else if (memcmp(E.xCheckReservedLock_signature, xCheckReservedLock_signatures[xCheckReservedLock_nolockCheckReservedLock_enum], sizeof(E.xCheckReservedLock_signature)) == 0) {
+ return nolockCheckReservedLock(args);
+ }
+ else if (memcmp(E.xCheckReservedLock_signature, xCheckReservedLock_signatures[xCheckReservedLock_dotlockCheckReservedLock_enum], sizeof(E.xCheckReservedLock_signature)) == 0) {
+ return dotlockCheckReservedLock(args);
+ }


// Transform return E.xClose(args) to if-chain with 27 candidates
@transform_return_xClose@
expression E;
identifier FP_NAME = xClose;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xClose_signature, xClose_signatures[xClose_apndClose_enum], sizeof(E.xClose_signature)) == 0) {
+ return apndClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_bytecodevtabClose_enum], sizeof(E.xClose_signature)) == 0) {
+ return bytecodevtabClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_completionClose_enum], sizeof(E.xClose_signature)) == 0) {
+ return completionClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_dbdataClose_enum], sizeof(E.xClose_signature)) == 0) {
+ return dbdataClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_dbpageClose_enum], sizeof(E.xClose_signature)) == 0) {
+ return dbpageClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_expertClose_enum], sizeof(E.xClose_signature)) == 0) {
+ return expertClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_fsdirClose_enum], sizeof(E.xClose_signature)) == 0) {
+ return fsdirClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_fts3CloseMethod_enum], sizeof(E.xClose_signature)) == 0) {
+ return fts3CloseMethod(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_fts3auxCloseMethod_enum], sizeof(E.xClose_signature)) == 0) {
+ return fts3auxCloseMethod(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_fts3tokCloseMethod_enum], sizeof(E.xClose_signature)) == 0) {
+ return fts3tokCloseMethod(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_jsonEachClose_enum], sizeof(E.xClose_signature)) == 0) {
+ return jsonEachClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_memdbClose_enum], sizeof(E.xClose_signature)) == 0) {
+ return memdbClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_memjrnlClose_enum], sizeof(E.xClose_signature)) == 0) {
+ return memjrnlClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_porterClose_enum], sizeof(E.xClose_signature)) == 0) {
+ return porterClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_pragmaVtabClose_enum], sizeof(E.xClose_signature)) == 0) {
+ return pragmaVtabClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_recoverVfsClose_enum], sizeof(E.xClose_signature)) == 0) {
+ return recoverVfsClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_rtreeClose_enum], sizeof(E.xClose_signature)) == 0) {
+ return rtreeClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_seriesClose_enum], sizeof(E.xClose_signature)) == 0) {
+ return seriesClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_simpleClose_enum], sizeof(E.xClose_signature)) == 0) {
+ return simpleClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_statClose_enum], sizeof(E.xClose_signature)) == 0) {
+ return statClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_stmtClose_enum], sizeof(E.xClose_signature)) == 0) {
+ return stmtClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_unicodeClose_enum], sizeof(E.xClose_signature)) == 0) {
+ return unicodeClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_vfstraceClose_enum], sizeof(E.xClose_signature)) == 0) {
+ return vfstraceClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_zipfileClose_enum], sizeof(E.xClose_signature)) == 0) {
+ return zipfileClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_unixClose_enum], sizeof(E.xClose_signature)) == 0) {
+ return unixClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_nolockClose_enum], sizeof(E.xClose_signature)) == 0) {
+ return nolockClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_dotlockClose_enum], sizeof(E.xClose_signature)) == 0) {
+ return dotlockClose(args);
+ }


// Transform return E.xColumn(args) to if-chain with 44 candidates
@transform_return_xColumn@
expression E;
identifier FP_NAME = xColumn;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_amatchColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ return amatchColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_binfoColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ return binfoColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_bytecodevtabColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ return bytecodevtabColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_carrayColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ return carrayColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_cidxColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ return cidxColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_closureColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ return closureColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_completionColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ return completionColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_csvtabColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ return csvtabColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_dbdataColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ return dbdataColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_dbpageColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ return dbpageColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_deltaparsevtabColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ return deltaparsevtabColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_echoColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ return echoColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_expertColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ return expertColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_explainColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ return explainColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_fsColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ return fsColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_fsdirColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ return fsdirColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_fstreeColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ return fstreeColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_fts3ColumnMethod_enum], sizeof(E.xColumn_signature)) == 0) {
+ return fts3ColumnMethod(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_fts3auxColumnMethod_enum], sizeof(E.xColumn_signature)) == 0) {
+ return fts3auxColumnMethod(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_fts3termColumnMethod_enum], sizeof(E.xColumn_signature)) == 0) {
+ return fts3termColumnMethod(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_fts3tokColumnMethod_enum], sizeof(E.xColumn_signature)) == 0) {
+ return fts3tokColumnMethod(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_fuzzerColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ return fuzzerColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_geopolyColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ return geopolyColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_intarrayColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ return intarrayColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_jsonEachColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ return jsonEachColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_memstatColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ return memstatColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_pragmaVtabColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ return pragmaVtabColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_prefixesColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ return prefixesColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_qpvtabColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ return qpvtabColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_rtreeColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ return rtreeColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_schemaColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ return schemaColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_seriesColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ return seriesColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_spellfix1Column_enum], sizeof(E.xColumn_signature)) == 0) {
+ return spellfix1Column(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_statColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ return statColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_stmtColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ return stmtColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_tclColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ return tclColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_tclvarColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ return tclvarColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_templatevtabColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ return templatevtabColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_unionColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ return unionColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_vlogColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ return vlogColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_vstattabColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ return vstattabColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_vtablogColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ return vtablogColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_wholenumberColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ return wholenumberColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_zipfileColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ return zipfileColumn(args);
+ }


// Transform return E.xCommit(args) to if-chain with 5 candidates
@transform_return_xCommit@
expression E;
identifier FP_NAME = xCommit;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xCommit_signature, xCommit_signatures[xCommit_0_enum], sizeof(E.xCommit_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xCommit_signature, xCommit_signatures[xCommit_echoCommit_enum], sizeof(E.xCommit_signature)) == 0) {
+ return echoCommit(args);
+ }
+ else if (memcmp(E.xCommit_signature, xCommit_signatures[xCommit_fts3CommitMethod_enum], sizeof(E.xCommit_signature)) == 0) {
+ return fts3CommitMethod(args);
+ }
+ else if (memcmp(E.xCommit_signature, xCommit_signatures[xCommit_rtreeEndTransaction_enum], sizeof(E.xCommit_signature)) == 0) {
+ return rtreeEndTransaction(args);
+ }
+ else if (memcmp(E.xCommit_signature, xCommit_signatures[xCommit_vtablogCommit_enum], sizeof(E.xCommit_signature)) == 0) {
+ return vtablogCommit(args);
+ }
+ else if (memcmp(E.xCommit_signature, xCommit_signatures[xCommit_zipfileCommit_enum], sizeof(E.xCommit_signature)) == 0) {
+ return zipfileCommit(args);
+ }


// Transform return E.xConnect(args) to if-chain with 44 candidates
@transform_return_xConnect@
expression E;
identifier FP_NAME = xConnect;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_amatchConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ return amatchConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_binfoConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ return binfoConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_bytecodevtabConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ return bytecodevtabConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_carrayConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ return carrayConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_cidxConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ return cidxConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_closureConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ return closureConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_completionConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ return completionConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_csvtabConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ return csvtabConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_dbdataConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ return dbdataConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_dbpageConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ return dbpageConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_deltaparsevtabConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ return deltaparsevtabConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_echoConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ return echoConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_expertConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ return expertConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_explainConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ return explainConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_fsConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ return fsConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_fsdirConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ return fsdirConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_fstreeConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ return fstreeConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_fts3ConnectMethod_enum], sizeof(E.xConnect_signature)) == 0) {
+ return fts3ConnectMethod(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_fts3auxConnectMethod_enum], sizeof(E.xConnect_signature)) == 0) {
+ return fts3auxConnectMethod(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_fts3termConnectMethod_enum], sizeof(E.xConnect_signature)) == 0) {
+ return fts3termConnectMethod(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_fts3tokConnectMethod_enum], sizeof(E.xConnect_signature)) == 0) {
+ return fts3tokConnectMethod(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_fuzzerConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ return fuzzerConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_geopolyConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ return geopolyConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_intarrayCreate_enum], sizeof(E.xConnect_signature)) == 0) {
+ return intarrayCreate(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_jsonEachConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ return jsonEachConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_memstatConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ return memstatConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_pragmaVtabConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ return pragmaVtabConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_prefixesConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ return prefixesConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_qpvtabConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ return qpvtabConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_rtreeConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ return rtreeConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_schemaCreate_enum], sizeof(E.xConnect_signature)) == 0) {
+ return schemaCreate(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_seriesConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ return seriesConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_spellfix1Connect_enum], sizeof(E.xConnect_signature)) == 0) {
+ return spellfix1Connect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_statConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ return statConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_stmtConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ return stmtConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_tclConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ return tclConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_tclvarConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ return tclvarConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_templatevtabConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ return templatevtabConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_unionConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ return unionConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_vlogConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ return vlogConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_vstattabConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ return vstattabConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_vtablogConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ return vtablogConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_wholenumberConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ return wholenumberConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_zipfileConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ return zipfileConnect(args);
+ }


// Transform return E.xCount(args) to if-chain with 3 candidates
@transform_return_xCount@
expression E;
identifier FP_NAME = xCount;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xCount_signature, xCount_signatures[xCount_sessionDiffCount_enum], sizeof(E.xCount_signature)) == 0) {
+ return sessionDiffCount(args);
+ }
+ else if (memcmp(E.xCount_signature, xCount_signatures[xCount_sessionPreupdateCount_enum], sizeof(E.xCount_signature)) == 0) {
+ return sessionPreupdateCount(args);
+ }
+ else if (memcmp(E.xCount_signature, xCount_signatures[xCount_sessionStat1Count_enum], sizeof(E.xCount_signature)) == 0) {
+ return sessionStat1Count(args);
+ }


// Transform return E.xCreate(args) to if-chain with 34 candidates
@transform_return_xCreate@
expression E;
identifier FP_NAME = xCreate;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_0_enum], sizeof(E.xCreate_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_amatchConnect_enum], sizeof(E.xCreate_signature)) == 0) {
+ return amatchConnect(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_closureConnect_enum], sizeof(E.xCreate_signature)) == 0) {
+ return closureConnect(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_csvtabCreate_enum], sizeof(E.xCreate_signature)) == 0) {
+ return csvtabCreate(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_dbpageConnect_enum], sizeof(E.xCreate_signature)) == 0) {
+ return dbpageConnect(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_echoCreate_enum], sizeof(E.xCreate_signature)) == 0) {
+ return echoCreate(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_expertConnect_enum], sizeof(E.xCreate_signature)) == 0) {
+ return expertConnect(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_f5tOrigintextCreate_enum], sizeof(E.xCreate_signature)) == 0) {
+ return f5tOrigintextCreate(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_f5tTokenizerCreate_enum], sizeof(E.xCreate_signature)) == 0) {
+ return f5tTokenizerCreate(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_fsConnect_enum], sizeof(E.xCreate_signature)) == 0) {
+ return fsConnect(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_fsdirConnect_enum], sizeof(E.xCreate_signature)) == 0) {
+ return fsdirConnect(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_fstreeConnect_enum], sizeof(E.xCreate_signature)) == 0) {
+ return fstreeConnect(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_fts3CreateMethod_enum], sizeof(E.xCreate_signature)) == 0) {
+ return fts3CreateMethod(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_fts3auxConnectMethod_enum], sizeof(E.xCreate_signature)) == 0) {
+ return fts3auxConnectMethod(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_fts3termConnectMethod_enum], sizeof(E.xCreate_signature)) == 0) {
+ return fts3termConnectMethod(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_fts3tokConnectMethod_enum], sizeof(E.xCreate_signature)) == 0) {
+ return fts3tokConnectMethod(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_fuzzerConnect_enum], sizeof(E.xCreate_signature)) == 0) {
+ return fuzzerConnect(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_geopolyCreate_enum], sizeof(E.xCreate_signature)) == 0) {
+ return geopolyCreate(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_intarrayCreate_enum], sizeof(E.xCreate_signature)) == 0) {
+ return intarrayCreate(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_pcache1Create_enum], sizeof(E.xCreate_signature)) == 0) {
+ return pcache1Create(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_pcachetraceCreate_enum], sizeof(E.xCreate_signature)) == 0) {
+ return pcachetraceCreate(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_porterCreate_enum], sizeof(E.xCreate_signature)) == 0) {
+ return porterCreate(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_rtreeCreate_enum], sizeof(E.xCreate_signature)) == 0) {
+ return rtreeCreate(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_schemaCreate_enum], sizeof(E.xCreate_signature)) == 0) {
+ return schemaCreate(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_simpleCreate_enum], sizeof(E.xCreate_signature)) == 0) {
+ return simpleCreate(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_spellfix1Create_enum], sizeof(E.xCreate_signature)) == 0) {
+ return spellfix1Create(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_statConnect_enum], sizeof(E.xCreate_signature)) == 0) {
+ return statConnect(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_tclConnect_enum], sizeof(E.xCreate_signature)) == 0) {
+ return tclConnect(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_tclvarConnect_enum], sizeof(E.xCreate_signature)) == 0) {
+ return tclvarConnect(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_unicodeCreate_enum], sizeof(E.xCreate_signature)) == 0) {
+ return unicodeCreate(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_unionConnect_enum], sizeof(E.xCreate_signature)) == 0) {
+ return unionConnect(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_vlogConnect_enum], sizeof(E.xCreate_signature)) == 0) {
+ return vlogConnect(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_vtablogCreate_enum], sizeof(E.xCreate_signature)) == 0) {
+ return vtablogCreate(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_wholenumberConnect_enum], sizeof(E.xCreate_signature)) == 0) {
+ return wholenumberConnect(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_zipfileConnect_enum], sizeof(E.xCreate_signature)) == 0) {
+ return zipfileConnect(args);
+ }


// Transform return E.xCurrentTime(args) to if-chain with 3 candidates
@transform_return_xCurrentTime@
expression E;
identifier FP_NAME = xCurrentTime;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xCurrentTime_signature, xCurrentTime_signatures[xCurrentTime_0_enum], sizeof(E.xCurrentTime_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xCurrentTime_signature, xCurrentTime_signatures[xCurrentTime_apndCurrentTime_enum], sizeof(E.xCurrentTime_signature)) == 0) {
+ return apndCurrentTime(args);
+ }
+ else if (memcmp(E.xCurrentTime_signature, xCurrentTime_signatures[xCurrentTime_vfstraceCurrentTime_enum], sizeof(E.xCurrentTime_signature)) == 0) {
+ return vfstraceCurrentTime(args);
+ }
+ else if (memcmp(E.xCurrentTime_signature, xCurrentTime_signatures[xCurrentTime_unixCurrentTime_enum], sizeof(E.xCurrentTime_signature)) == 0) {
+ return unixCurrentTime(args);
+ }


// Transform return E.xCurrentTimeInt64(args) to if-chain with 3 candidates
@transform_return_xCurrentTimeInt64@
expression E;
identifier FP_NAME = xCurrentTimeInt64;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xCurrentTimeInt64_signature, xCurrentTimeInt64_signatures[xCurrentTimeInt64_0_enum], sizeof(E.xCurrentTimeInt64_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xCurrentTimeInt64_signature, xCurrentTimeInt64_signatures[xCurrentTimeInt64_apndCurrentTimeInt64_enum], sizeof(E.xCurrentTimeInt64_signature)) == 0) {
+ return apndCurrentTimeInt64(args);
+ }
+ else if (memcmp(E.xCurrentTimeInt64_signature, xCurrentTimeInt64_signatures[xCurrentTimeInt64_memdbCurrentTimeInt64_enum], sizeof(E.xCurrentTimeInt64_signature)) == 0) {
+ return memdbCurrentTimeInt64(args);
+ }
+ else if (memcmp(E.xCurrentTimeInt64_signature, xCurrentTimeInt64_signatures[xCurrentTimeInt64_unixCurrentTimeInt64_enum], sizeof(E.xCurrentTimeInt64_signature)) == 0) {
+ return unixCurrentTimeInt64(args);
+ }


// Transform return E.xDel(args) to if-chain with 3 candidates
@transform_return_xDel@
expression E;
identifier FP_NAME = xDel;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xDel_signature, xDel_signatures[xDel_0_enum], sizeof(E.xDel_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xDel_signature, xDel_signatures[xDel_sqlite3RowSetDelete_enum], sizeof(E.xDel_signature)) == 0) {
+ return sqlite3RowSetDelete(args);
+ }
+ else if (memcmp(E.xDel_signature, xDel_signatures[xDel_sqlite3VdbeFrameMemDel_enum], sizeof(E.xDel_signature)) == 0) {
+ return sqlite3VdbeFrameMemDel(args);
+ }
+ else if (memcmp(E.xDel_signature, xDel_signatures[xDel_sqlite3_free_enum], sizeof(E.xDel_signature)) == 0) {
+ return sqlite3_free(args);
+ }


// Transform return E.xDelete(args) to if-chain with 6 candidates
@transform_return_xDelete@
expression E;
identifier FP_NAME = xDelete;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xDelete_signature, xDelete_signatures[xDelete_0_enum], sizeof(E.xDelete_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xDelete_signature, xDelete_signatures[xDelete_apndDelete_enum], sizeof(E.xDelete_signature)) == 0) {
+ return apndDelete(args);
+ }
+ else if (memcmp(E.xDelete_signature, xDelete_signatures[xDelete_f5tOrigintextDelete_enum], sizeof(E.xDelete_signature)) == 0) {
+ return f5tOrigintextDelete(args);
+ }
+ else if (memcmp(E.xDelete_signature, xDelete_signatures[xDelete_f5tTokenizerDelete_enum], sizeof(E.xDelete_signature)) == 0) {
+ return f5tTokenizerDelete(args);
+ }
+ else if (memcmp(E.xDelete_signature, xDelete_signatures[xDelete_kvstorageDelete_enum], sizeof(E.xDelete_signature)) == 0) {
+ return kvstorageDelete(args);
+ }
+ else if (memcmp(E.xDelete_signature, xDelete_signatures[xDelete_vfstraceDelete_enum], sizeof(E.xDelete_signature)) == 0) {
+ return vfstraceDelete(args);
+ }
+ else if (memcmp(E.xDelete_signature, xDelete_signatures[xDelete_unixDelete_enum], sizeof(E.xDelete_signature)) == 0) {
+ return unixDelete(args);
+ }


// Transform return E.xDepth(args) to if-chain with 3 candidates
@transform_return_xDepth@
expression E;
identifier FP_NAME = xDepth;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xDepth_signature, xDepth_signatures[xDepth_sessionDiffDepth_enum], sizeof(E.xDepth_signature)) == 0) {
+ return sessionDiffDepth(args);
+ }
+ else if (memcmp(E.xDepth_signature, xDepth_signatures[xDepth_sessionPreupdateDepth_enum], sizeof(E.xDepth_signature)) == 0) {
+ return sessionPreupdateDepth(args);
+ }
+ else if (memcmp(E.xDepth_signature, xDepth_signatures[xDepth_sessionStat1Depth_enum], sizeof(E.xDepth_signature)) == 0) {
+ return sessionStat1Depth(args);
+ }


// Transform return E.xDestroy(args) to if-chain with 14 candidates
@transform_return_xDestroy@
expression E;
identifier FP_NAME = xDestroy;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xDestroy_signature, xDestroy_signatures[xDestroy_0_enum], sizeof(E.xDestroy_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xDestroy_signature, xDestroy_signatures[xDestroy_dbpageDisconnect_enum], sizeof(E.xDestroy_signature)) == 0) {
+ return dbpageDisconnect(args);
+ }
+ else if (memcmp(E.xDestroy_signature, xDestroy_signatures[xDestroy_expertDisconnect_enum], sizeof(E.xDestroy_signature)) == 0) {
+ return expertDisconnect(args);
+ }
+ else if (memcmp(E.xDestroy_signature, xDestroy_signatures[xDestroy_fsdirDisconnect_enum], sizeof(E.xDestroy_signature)) == 0) {
+ return fsdirDisconnect(args);
+ }
+ else if (memcmp(E.xDestroy_signature, xDestroy_signatures[xDestroy_fts3DestroyMethod_enum], sizeof(E.xDestroy_signature)) == 0) {
+ return fts3DestroyMethod(args);
+ }
+ else if (memcmp(E.xDestroy_signature, xDestroy_signatures[xDestroy_fts3auxDisconnectMethod_enum], sizeof(E.xDestroy_signature)) == 0) {
+ return fts3auxDisconnectMethod(args);
+ }
+ else if (memcmp(E.xDestroy_signature, xDestroy_signatures[xDestroy_fts3tokDisconnectMethod_enum], sizeof(E.xDestroy_signature)) == 0) {
+ return fts3tokDisconnectMethod(args);
+ }
+ else if (memcmp(E.xDestroy_signature, xDestroy_signatures[xDestroy_pcache1Destroy_enum], sizeof(E.xDestroy_signature)) == 0) {
+ return pcache1Destroy(args);
+ }
+ else if (memcmp(E.xDestroy_signature, xDestroy_signatures[xDestroy_pcachetraceDestroy_enum], sizeof(E.xDestroy_signature)) == 0) {
+ return pcachetraceDestroy(args);
+ }
+ else if (memcmp(E.xDestroy_signature, xDestroy_signatures[xDestroy_porterDestroy_enum], sizeof(E.xDestroy_signature)) == 0) {
+ return porterDestroy(args);
+ }
+ else if (memcmp(E.xDestroy_signature, xDestroy_signatures[xDestroy_rtreeDestroy_enum], sizeof(E.xDestroy_signature)) == 0) {
+ return rtreeDestroy(args);
+ }
+ else if (memcmp(E.xDestroy_signature, xDestroy_signatures[xDestroy_simpleDestroy_enum], sizeof(E.xDestroy_signature)) == 0) {
+ return simpleDestroy(args);
+ }
+ else if (memcmp(E.xDestroy_signature, xDestroy_signatures[xDestroy_statDisconnect_enum], sizeof(E.xDestroy_signature)) == 0) {
+ return statDisconnect(args);
+ }
+ else if (memcmp(E.xDestroy_signature, xDestroy_signatures[xDestroy_unicodeDestroy_enum], sizeof(E.xDestroy_signature)) == 0) {
+ return unicodeDestroy(args);
+ }
+ else if (memcmp(E.xDestroy_signature, xDestroy_signatures[xDestroy_zipfileDisconnect_enum], sizeof(E.xDestroy_signature)) == 0) {
+ return zipfileDisconnect(args);
+ }


// Transform return E.xDeviceCharacteristics(args) to if-chain with 5 candidates
@transform_return_xDeviceCharacteristics@
expression E;
identifier FP_NAME = xDeviceCharacteristics;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xDeviceCharacteristics_signature, xDeviceCharacteristics_signatures[xDeviceCharacteristics_0_enum], sizeof(E.xDeviceCharacteristics_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xDeviceCharacteristics_signature, xDeviceCharacteristics_signatures[xDeviceCharacteristics_apndDeviceCharacteristics_enum], sizeof(E.xDeviceCharacteristics_signature)) == 0) {
+ return apndDeviceCharacteristics(args);
+ }
+ else if (memcmp(E.xDeviceCharacteristics_signature, xDeviceCharacteristics_signatures[xDeviceCharacteristics_memdbDeviceCharacteristics_enum], sizeof(E.xDeviceCharacteristics_signature)) == 0) {
+ return memdbDeviceCharacteristics(args);
+ }
+ else if (memcmp(E.xDeviceCharacteristics_signature, xDeviceCharacteristics_signatures[xDeviceCharacteristics_recoverVfsDeviceCharacteristics_enum], sizeof(E.xDeviceCharacteristics_signature)) == 0) {
+ return recoverVfsDeviceCharacteristics(args);
+ }
+ else if (memcmp(E.xDeviceCharacteristics_signature, xDeviceCharacteristics_signatures[xDeviceCharacteristics_vfstraceDeviceCharacteristics_enum], sizeof(E.xDeviceCharacteristics_signature)) == 0) {
+ return vfstraceDeviceCharacteristics(args);
+ }
+ else if (memcmp(E.xDeviceCharacteristics_signature, xDeviceCharacteristics_signatures[xDeviceCharacteristics_unixDeviceCharacteristics_enum], sizeof(E.xDeviceCharacteristics_signature)) == 0) {
+ return unixDeviceCharacteristics(args);
+ }


// Transform return E.xDisconnect(args) to if-chain with 16 candidates
@transform_return_xDisconnect@
expression E;
identifier FP_NAME = xDisconnect;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xDisconnect_signature, xDisconnect_signatures[xDisconnect_bytecodevtabDisconnect_enum], sizeof(E.xDisconnect_signature)) == 0) {
+ return bytecodevtabDisconnect(args);
+ }
+ else if (memcmp(E.xDisconnect_signature, xDisconnect_signatures[xDisconnect_completionDisconnect_enum], sizeof(E.xDisconnect_signature)) == 0) {
+ return completionDisconnect(args);
+ }
+ else if (memcmp(E.xDisconnect_signature, xDisconnect_signatures[xDisconnect_dbdataDisconnect_enum], sizeof(E.xDisconnect_signature)) == 0) {
+ return dbdataDisconnect(args);
+ }
+ else if (memcmp(E.xDisconnect_signature, xDisconnect_signatures[xDisconnect_dbpageDisconnect_enum], sizeof(E.xDisconnect_signature)) == 0) {
+ return dbpageDisconnect(args);
+ }
+ else if (memcmp(E.xDisconnect_signature, xDisconnect_signatures[xDisconnect_expertDisconnect_enum], sizeof(E.xDisconnect_signature)) == 0) {
+ return expertDisconnect(args);
+ }
+ else if (memcmp(E.xDisconnect_signature, xDisconnect_signatures[xDisconnect_fsdirDisconnect_enum], sizeof(E.xDisconnect_signature)) == 0) {
+ return fsdirDisconnect(args);
+ }
+ else if (memcmp(E.xDisconnect_signature, xDisconnect_signatures[xDisconnect_fts3DisconnectMethod_enum], sizeof(E.xDisconnect_signature)) == 0) {
+ return fts3DisconnectMethod(args);
+ }
+ else if (memcmp(E.xDisconnect_signature, xDisconnect_signatures[xDisconnect_fts3auxDisconnectMethod_enum], sizeof(E.xDisconnect_signature)) == 0) {
+ return fts3auxDisconnectMethod(args);
+ }
+ else if (memcmp(E.xDisconnect_signature, xDisconnect_signatures[xDisconnect_fts3tokDisconnectMethod_enum], sizeof(E.xDisconnect_signature)) == 0) {
+ return fts3tokDisconnectMethod(args);
+ }
+ else if (memcmp(E.xDisconnect_signature, xDisconnect_signatures[xDisconnect_jsonEachDisconnect_enum], sizeof(E.xDisconnect_signature)) == 0) {
+ return jsonEachDisconnect(args);
+ }
+ else if (memcmp(E.xDisconnect_signature, xDisconnect_signatures[xDisconnect_pragmaVtabDisconnect_enum], sizeof(E.xDisconnect_signature)) == 0) {
+ return pragmaVtabDisconnect(args);
+ }
+ else if (memcmp(E.xDisconnect_signature, xDisconnect_signatures[xDisconnect_rtreeDisconnect_enum], sizeof(E.xDisconnect_signature)) == 0) {
+ return rtreeDisconnect(args);
+ }
+ else if (memcmp(E.xDisconnect_signature, xDisconnect_signatures[xDisconnect_seriesDisconnect_enum], sizeof(E.xDisconnect_signature)) == 0) {
+ return seriesDisconnect(args);
+ }
+ else if (memcmp(E.xDisconnect_signature, xDisconnect_signatures[xDisconnect_statDisconnect_enum], sizeof(E.xDisconnect_signature)) == 0) {
+ return statDisconnect(args);
+ }
+ else if (memcmp(E.xDisconnect_signature, xDisconnect_signatures[xDisconnect_stmtDisconnect_enum], sizeof(E.xDisconnect_signature)) == 0) {
+ return stmtDisconnect(args);
+ }
+ else if (memcmp(E.xDisconnect_signature, xDisconnect_signatures[xDisconnect_zipfileDisconnect_enum], sizeof(E.xDisconnect_signature)) == 0) {
+ return zipfileDisconnect(args);
+ }


// Transform return E.xDlClose(args) to if-chain with 3 candidates
@transform_return_xDlClose@
expression E;
identifier FP_NAME = xDlClose;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xDlClose_signature, xDlClose_signatures[xDlClose_0_enum], sizeof(E.xDlClose_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xDlClose_signature, xDlClose_signatures[xDlClose_apndDlClose_enum], sizeof(E.xDlClose_signature)) == 0) {
+ return apndDlClose(args);
+ }
+ else if (memcmp(E.xDlClose_signature, xDlClose_signatures[xDlClose_memdbDlClose_enum], sizeof(E.xDlClose_signature)) == 0) {
+ return memdbDlClose(args);
+ }
+ else if (memcmp(E.xDlClose_signature, xDlClose_signatures[xDlClose_unixDlClose_enum], sizeof(E.xDlClose_signature)) == 0) {
+ return unixDlClose(args);
+ }


// Transform return E.xDlError(args) to if-chain with 3 candidates
@transform_return_xDlError@
expression E;
identifier FP_NAME = xDlError;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xDlError_signature, xDlError_signatures[xDlError_0_enum], sizeof(E.xDlError_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xDlError_signature, xDlError_signatures[xDlError_apndDlError_enum], sizeof(E.xDlError_signature)) == 0) {
+ return apndDlError(args);
+ }
+ else if (memcmp(E.xDlError_signature, xDlError_signatures[xDlError_memdbDlError_enum], sizeof(E.xDlError_signature)) == 0) {
+ return memdbDlError(args);
+ }
+ else if (memcmp(E.xDlError_signature, xDlError_signatures[xDlError_unixDlError_enum], sizeof(E.xDlError_signature)) == 0) {
+ return unixDlError(args);
+ }


// Transform return E.xDlOpen(args) to if-chain with 3 candidates
@transform_return_xDlOpen@
expression E;
identifier FP_NAME = xDlOpen;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xDlOpen_signature, xDlOpen_signatures[xDlOpen_apndDlOpen_enum], sizeof(E.xDlOpen_signature)) == 0) {
+ return apndDlOpen(args);
+ }
+ else if (memcmp(E.xDlOpen_signature, xDlOpen_signatures[xDlOpen_memdbDlOpen_enum], sizeof(E.xDlOpen_signature)) == 0) {
+ return memdbDlOpen(args);
+ }
+ else if (memcmp(E.xDlOpen_signature, xDlOpen_signatures[xDlOpen_unixDlOpen_enum], sizeof(E.xDlOpen_signature)) == 0) {
+ return unixDlOpen(args);
+ }


// Transform return E.xEof(args) to if-chain with 43 candidates
@transform_return_xEof@
expression E;
identifier FP_NAME = xEof;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xEof_signature, xEof_signatures[xEof_amatchEof_enum], sizeof(E.xEof_signature)) == 0) {
+ return amatchEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_binfoEof_enum], sizeof(E.xEof_signature)) == 0) {
+ return binfoEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_bytecodevtabEof_enum], sizeof(E.xEof_signature)) == 0) {
+ return bytecodevtabEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_carrayEof_enum], sizeof(E.xEof_signature)) == 0) {
+ return carrayEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_cidxEof_enum], sizeof(E.xEof_signature)) == 0) {
+ return cidxEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_closureEof_enum], sizeof(E.xEof_signature)) == 0) {
+ return closureEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_completionEof_enum], sizeof(E.xEof_signature)) == 0) {
+ return completionEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_csvtabEof_enum], sizeof(E.xEof_signature)) == 0) {
+ return csvtabEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_dbdataEof_enum], sizeof(E.xEof_signature)) == 0) {
+ return dbdataEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_dbpageEof_enum], sizeof(E.xEof_signature)) == 0) {
+ return dbpageEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_deltaparsevtabEof_enum], sizeof(E.xEof_signature)) == 0) {
+ return deltaparsevtabEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_echoEof_enum], sizeof(E.xEof_signature)) == 0) {
+ return echoEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_expertEof_enum], sizeof(E.xEof_signature)) == 0) {
+ return expertEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_explainEof_enum], sizeof(E.xEof_signature)) == 0) {
+ return explainEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_fsEof_enum], sizeof(E.xEof_signature)) == 0) {
+ return fsEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_fsdirEof_enum], sizeof(E.xEof_signature)) == 0) {
+ return fsdirEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_fstreeEof_enum], sizeof(E.xEof_signature)) == 0) {
+ return fstreeEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_fts3EofMethod_enum], sizeof(E.xEof_signature)) == 0) {
+ return fts3EofMethod(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_fts3auxEofMethod_enum], sizeof(E.xEof_signature)) == 0) {
+ return fts3auxEofMethod(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_fts3termEofMethod_enum], sizeof(E.xEof_signature)) == 0) {
+ return fts3termEofMethod(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_fts3tokEofMethod_enum], sizeof(E.xEof_signature)) == 0) {
+ return fts3tokEofMethod(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_fuzzerEof_enum], sizeof(E.xEof_signature)) == 0) {
+ return fuzzerEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_intarrayEof_enum], sizeof(E.xEof_signature)) == 0) {
+ return intarrayEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_jsonEachEof_enum], sizeof(E.xEof_signature)) == 0) {
+ return jsonEachEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_memstatEof_enum], sizeof(E.xEof_signature)) == 0) {
+ return memstatEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_pragmaVtabEof_enum], sizeof(E.xEof_signature)) == 0) {
+ return pragmaVtabEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_prefixesEof_enum], sizeof(E.xEof_signature)) == 0) {
+ return prefixesEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_qpvtabEof_enum], sizeof(E.xEof_signature)) == 0) {
+ return qpvtabEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_rtreeEof_enum], sizeof(E.xEof_signature)) == 0) {
+ return rtreeEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_schemaEof_enum], sizeof(E.xEof_signature)) == 0) {
+ return schemaEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_seriesEof_enum], sizeof(E.xEof_signature)) == 0) {
+ return seriesEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_spellfix1Eof_enum], sizeof(E.xEof_signature)) == 0) {
+ return spellfix1Eof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_statEof_enum], sizeof(E.xEof_signature)) == 0) {
+ return statEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_stmtEof_enum], sizeof(E.xEof_signature)) == 0) {
+ return stmtEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_tclEof_enum], sizeof(E.xEof_signature)) == 0) {
+ return tclEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_tclvarEof_enum], sizeof(E.xEof_signature)) == 0) {
+ return tclvarEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_templatevtabEof_enum], sizeof(E.xEof_signature)) == 0) {
+ return templatevtabEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_unionEof_enum], sizeof(E.xEof_signature)) == 0) {
+ return unionEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_vlogEof_enum], sizeof(E.xEof_signature)) == 0) {
+ return vlogEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_vstattabEof_enum], sizeof(E.xEof_signature)) == 0) {
+ return vstattabEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_vtablogEof_enum], sizeof(E.xEof_signature)) == 0) {
+ return vtablogEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_wholenumberEof_enum], sizeof(E.xEof_signature)) == 0) {
+ return wholenumberEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_zipfileEof_enum], sizeof(E.xEof_signature)) == 0) {
+ return zipfileEof(args);
+ }


// Transform return E.xExprCallback(args) to if-chain with 37 candidates
@transform_return_xExprCallback@
expression E;
identifier FP_NAME = xExprCallback;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_agginfoPersistExprCb_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ return agginfoPersistExprCb(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_aggregateIdxEprRefToColCallback_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ return aggregateIdxEprRefToColCallback(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_analyzeAggregate_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ return analyzeAggregate(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_checkConstraintExprNode_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ return checkConstraintExprNode(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_codeCursorHintCheckExpr_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ return codeCursorHintCheckExpr(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_codeCursorHintFixExpr_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ return codeCursorHintFixExpr(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_codeCursorHintIsOrFunction_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ return codeCursorHintIsOrFunction(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_disallowAggregatesInOrderByCb_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ return disallowAggregatesInOrderByCb(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprColumnFlagUnion_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ return exprColumnFlagUnion(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprIdxCover_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ return exprIdxCover(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprNodeCanReturnSubtype_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ return exprNodeCanReturnSubtype(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprNodeIsConstant_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ return exprNodeIsConstant(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprNodeIsConstantOrGroupBy_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ return exprNodeIsConstantOrGroupBy(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprNodeIsDeterministic_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ return exprNodeIsDeterministic(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprRefToSrcList_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ return exprRefToSrcList(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_fixExprCb_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ return fixExprCb(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_gatherSelectWindowsCallback_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ return gatherSelectWindowsCallback(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_havingToWhereExprCb_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ return havingToWhereExprCb(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_impliesNotNullRow_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ return impliesNotNullRow(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_incrAggDepth_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ return incrAggDepth(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_markImmutableExprStep_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ return markImmutableExprStep(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_propagateConstantExprRewrite_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ return propagateConstantExprRewrite(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_recomputeColumnsUsedExpr_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ return recomputeColumnsUsedExpr(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_renameColumnExprCb_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ return renameColumnExprCb(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_renameQuotefixExprCb_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ return renameQuotefixExprCb(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_renameTableExprCb_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ return renameTableExprCb(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_renameUnmapExprCb_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ return renameUnmapExprCb(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_renumberCursorsCb_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ return renumberCursorsCb(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_resolveExprStep_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ return resolveExprStep(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_resolveRemoveWindowsCb_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ return resolveRemoveWindowsCb(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_selectCheckOnClausesExpr_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ return selectCheckOnClausesExpr(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_selectWindowRewriteExprCb_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ return selectWindowRewriteExprCb(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_sqlite3CursorRangeHintExprCheck_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ return sqlite3CursorRangeHintExprCheck(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_sqlite3ExprWalkNoop_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ return sqlite3ExprWalkNoop(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_sqlite3ReturningSubqueryVarSelect_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ return sqlite3ReturningSubqueryVarSelect(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_sqlite3WindowExtraAggFuncDepth_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ return sqlite3WindowExtraAggFuncDepth(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_whereIsCoveringIndexWalkCallback_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ return whereIsCoveringIndexWalkCallback(args);
+ }


// Transform return E.xFetch(args) to if-chain with 6 candidates
@transform_return_xFetch@
expression E;
identifier FP_NAME = xFetch;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xFetch_signature, xFetch_signatures[xFetch_0_enum], sizeof(E.xFetch_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xFetch_signature, xFetch_signatures[xFetch_apndFetch_enum], sizeof(E.xFetch_signature)) == 0) {
+ return apndFetch(args);
+ }
+ else if (memcmp(E.xFetch_signature, xFetch_signatures[xFetch_memdbFetch_enum], sizeof(E.xFetch_signature)) == 0) {
+ return memdbFetch(args);
+ }
+ else if (memcmp(E.xFetch_signature, xFetch_signatures[xFetch_pcache1Fetch_enum], sizeof(E.xFetch_signature)) == 0) {
+ return pcache1Fetch(args);
+ }
+ else if (memcmp(E.xFetch_signature, xFetch_signatures[xFetch_pcachetraceFetch_enum], sizeof(E.xFetch_signature)) == 0) {
+ return pcachetraceFetch(args);
+ }
+ else if (memcmp(E.xFetch_signature, xFetch_signatures[xFetch_recoverVfsFetch_enum], sizeof(E.xFetch_signature)) == 0) {
+ return recoverVfsFetch(args);
+ }
+ else if (memcmp(E.xFetch_signature, xFetch_signatures[xFetch_unixFetch_enum], sizeof(E.xFetch_signature)) == 0) {
+ return unixFetch(args);
+ }


// Transform return E.xFileControl(args) to if-chain with 5 candidates
@transform_return_xFileControl@
expression E;
identifier FP_NAME = xFileControl;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xFileControl_signature, xFileControl_signatures[xFileControl_0_enum], sizeof(E.xFileControl_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xFileControl_signature, xFileControl_signatures[xFileControl_apndFileControl_enum], sizeof(E.xFileControl_signature)) == 0) {
+ return apndFileControl(args);
+ }
+ else if (memcmp(E.xFileControl_signature, xFileControl_signatures[xFileControl_memdbFileControl_enum], sizeof(E.xFileControl_signature)) == 0) {
+ return memdbFileControl(args);
+ }
+ else if (memcmp(E.xFileControl_signature, xFileControl_signatures[xFileControl_recoverVfsFileControl_enum], sizeof(E.xFileControl_signature)) == 0) {
+ return recoverVfsFileControl(args);
+ }
+ else if (memcmp(E.xFileControl_signature, xFileControl_signatures[xFileControl_vfstraceFileControl_enum], sizeof(E.xFileControl_signature)) == 0) {
+ return vfstraceFileControl(args);
+ }
+ else if (memcmp(E.xFileControl_signature, xFileControl_signatures[xFileControl_unixFileControl_enum], sizeof(E.xFileControl_signature)) == 0) {
+ return unixFileControl(args);
+ }


// Transform return E.xFileSize(args) to if-chain with 6 candidates
@transform_return_xFileSize@
expression E;
identifier FP_NAME = xFileSize;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xFileSize_signature, xFileSize_signatures[xFileSize_apndFileSize_enum], sizeof(E.xFileSize_signature)) == 0) {
+ return apndFileSize(args);
+ }
+ else if (memcmp(E.xFileSize_signature, xFileSize_signatures[xFileSize_memdbFileSize_enum], sizeof(E.xFileSize_signature)) == 0) {
+ return memdbFileSize(args);
+ }
+ else if (memcmp(E.xFileSize_signature, xFileSize_signatures[xFileSize_memjrnlFileSize_enum], sizeof(E.xFileSize_signature)) == 0) {
+ return memjrnlFileSize(args);
+ }
+ else if (memcmp(E.xFileSize_signature, xFileSize_signatures[xFileSize_recoverVfsFileSize_enum], sizeof(E.xFileSize_signature)) == 0) {
+ return recoverVfsFileSize(args);
+ }
+ else if (memcmp(E.xFileSize_signature, xFileSize_signatures[xFileSize_vfstraceFileSize_enum], sizeof(E.xFileSize_signature)) == 0) {
+ return vfstraceFileSize(args);
+ }
+ else if (memcmp(E.xFileSize_signature, xFileSize_signatures[xFileSize_unixFileSize_enum], sizeof(E.xFileSize_signature)) == 0) {
+ return unixFileSize(args);
+ }


// Transform return E.xFilter(args) to if-chain with 44 candidates
@transform_return_xFilter@
expression E;
identifier FP_NAME = xFilter;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_amatchFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ return amatchFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_binfoFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ return binfoFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_bytecodevtabFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ return bytecodevtabFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_carrayFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ return carrayFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_cidxFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ return cidxFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_closureFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ return closureFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_completionFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ return completionFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_csvtabFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ return csvtabFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_dbdataFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ return dbdataFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_dbpageFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ return dbpageFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_deltaparsevtabFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ return deltaparsevtabFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_echoFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ return echoFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_expertFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ return expertFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_explainFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ return explainFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_fsFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ return fsFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_fsdirFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ return fsdirFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_fstreeFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ return fstreeFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_fts3FilterMethod_enum], sizeof(E.xFilter_signature)) == 0) {
+ return fts3FilterMethod(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_fts3auxFilterMethod_enum], sizeof(E.xFilter_signature)) == 0) {
+ return fts3auxFilterMethod(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_fts3termFilterMethod_enum], sizeof(E.xFilter_signature)) == 0) {
+ return fts3termFilterMethod(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_fts3tokFilterMethod_enum], sizeof(E.xFilter_signature)) == 0) {
+ return fts3tokFilterMethod(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_fuzzerFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ return fuzzerFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_geopolyFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ return geopolyFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_intarrayFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ return intarrayFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_jsonEachFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ return jsonEachFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_memstatFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ return memstatFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_pragmaVtabFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ return pragmaVtabFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_prefixesFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ return prefixesFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_qpvtabFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ return qpvtabFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_rtreeFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ return rtreeFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_schemaFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ return schemaFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_seriesFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ return seriesFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_spellfix1Filter_enum], sizeof(E.xFilter_signature)) == 0) {
+ return spellfix1Filter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_statFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ return statFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_stmtFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ return stmtFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_tclFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ return tclFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_tclvarFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ return tclvarFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_templatevtabFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ return templatevtabFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_unionFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ return unionFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_vlogFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ return vlogFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_vstattabFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ return vstattabFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_vtablogFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ return vtablogFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_wholenumberFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ return wholenumberFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_zipfileFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ return zipfileFilter(args);
+ }


// Transform return E.xFindFunction(args) to if-chain with 2 candidates
@transform_return_xFindFunction@
expression E;
identifier FP_NAME = xFindFunction;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xFindFunction_signature, xFindFunction_signatures[xFindFunction_0_enum], sizeof(E.xFindFunction_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xFindFunction_signature, xFindFunction_signatures[xFindFunction_fts3FindFunctionMethod_enum], sizeof(E.xFindFunction_signature)) == 0) {
+ return fts3FindFunctionMethod(args);
+ }
+ else if (memcmp(E.xFindFunction_signature, xFindFunction_signatures[xFindFunction_zipfileFindFunction_enum], sizeof(E.xFindFunction_signature)) == 0) {
+ return zipfileFindFunction(args);
+ }


// Transform return E.xFree(args) to if-chain with 2 candidates
@transform_return_xFree@
expression E;
identifier FP_NAME = xFree;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xFree_signature, xFree_signatures[xFree_memtraceFree_enum], sizeof(E.xFree_signature)) == 0) {
+ return memtraceFree(args);
+ }
+ else if (memcmp(E.xFree_signature, xFree_signatures[xFree_sqlite3MemFree_enum], sizeof(E.xFree_signature)) == 0) {
+ return sqlite3MemFree(args);
+ }


// Transform return E.xFullPathname(args) to if-chain with 4 candidates
@transform_return_xFullPathname@
expression E;
identifier FP_NAME = xFullPathname;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xFullPathname_signature, xFullPathname_signatures[xFullPathname_apndFullPathname_enum], sizeof(E.xFullPathname_signature)) == 0) {
+ return apndFullPathname(args);
+ }
+ else if (memcmp(E.xFullPathname_signature, xFullPathname_signatures[xFullPathname_memdbFullPathname_enum], sizeof(E.xFullPathname_signature)) == 0) {
+ return memdbFullPathname(args);
+ }
+ else if (memcmp(E.xFullPathname_signature, xFullPathname_signatures[xFullPathname_vfstraceFullPathname_enum], sizeof(E.xFullPathname_signature)) == 0) {
+ return vfstraceFullPathname(args);
+ }
+ else if (memcmp(E.xFullPathname_signature, xFullPathname_signatures[xFullPathname_unixFullPathname_enum], sizeof(E.xFullPathname_signature)) == 0) {
+ return unixFullPathname(args);
+ }


// Transform return E.xGet(args) to if-chain with 3 candidates
@transform_return_xGet@
expression E;
identifier FP_NAME = xGet;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xGet_signature, xGet_signatures[xGet_getPageError_enum], sizeof(E.xGet_signature)) == 0) {
+ return getPageError(args);
+ }
+ else if (memcmp(E.xGet_signature, xGet_signatures[xGet_getPageMMap_enum], sizeof(E.xGet_signature)) == 0) {
+ return getPageMMap(args);
+ }
+ else if (memcmp(E.xGet_signature, xGet_signatures[xGet_getPageNormal_enum], sizeof(E.xGet_signature)) == 0) {
+ return getPageNormal(args);
+ }


// Transform return E.xGetLastError(args) to if-chain with 3 candidates
@transform_return_xGetLastError@
expression E;
identifier FP_NAME = xGetLastError;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xGetLastError_signature, xGetLastError_signatures[xGetLastError_0_enum], sizeof(E.xGetLastError_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xGetLastError_signature, xGetLastError_signatures[xGetLastError_apndGetLastError_enum], sizeof(E.xGetLastError_signature)) == 0) {
+ return apndGetLastError(args);
+ }
+ else if (memcmp(E.xGetLastError_signature, xGetLastError_signatures[xGetLastError_memdbGetLastError_enum], sizeof(E.xGetLastError_signature)) == 0) {
+ return memdbGetLastError(args);
+ }
+ else if (memcmp(E.xGetLastError_signature, xGetLastError_signatures[xGetLastError_unixGetLastError_enum], sizeof(E.xGetLastError_signature)) == 0) {
+ return unixGetLastError(args);
+ }


// Transform return E.xGetSystemCall(args) to if-chain with 2 candidates
@transform_return_xGetSystemCall@
expression E;
identifier FP_NAME = xGetSystemCall;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xGetSystemCall_signature, xGetSystemCall_signatures[xGetSystemCall_0_enum], sizeof(E.xGetSystemCall_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xGetSystemCall_signature, xGetSystemCall_signatures[xGetSystemCall_apndGetSystemCall_enum], sizeof(E.xGetSystemCall_signature)) == 0) {
+ return apndGetSystemCall(args);
+ }
+ else if (memcmp(E.xGetSystemCall_signature, xGetSystemCall_signatures[xGetSystemCall_unixGetSystemCall_enum], sizeof(E.xGetSystemCall_signature)) == 0) {
+ return unixGetSystemCall(args);
+ }


// Transform return E.xInit(args) to if-chain with 4 candidates
@transform_return_xInit@
expression E;
identifier FP_NAME = xInit;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xInit_signature, xInit_signatures[xInit_memtraceInit_enum], sizeof(E.xInit_signature)) == 0) {
+ return memtraceInit(args);
+ }
+ else if (memcmp(E.xInit_signature, xInit_signatures[xInit_pcache1Init_enum], sizeof(E.xInit_signature)) == 0) {
+ return pcache1Init(args);
+ }
+ else if (memcmp(E.xInit_signature, xInit_signatures[xInit_pcachetraceInit_enum], sizeof(E.xInit_signature)) == 0) {
+ return pcachetraceInit(args);
+ }
+ else if (memcmp(E.xInit_signature, xInit_signatures[xInit_sqlite3MemInit_enum], sizeof(E.xInit_signature)) == 0) {
+ return sqlite3MemInit(args);
+ }


// Transform return E.xIntegrity(args) to if-chain with 3 candidates
@transform_return_xIntegrity@
expression E;
identifier FP_NAME = xIntegrity;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xIntegrity_signature, xIntegrity_signatures[xIntegrity_0_enum], sizeof(E.xIntegrity_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xIntegrity_signature, xIntegrity_signatures[xIntegrity_fts3IntegrityMethod_enum], sizeof(E.xIntegrity_signature)) == 0) {
+ return fts3IntegrityMethod(args);
+ }
+ else if (memcmp(E.xIntegrity_signature, xIntegrity_signatures[xIntegrity_rtreeIntegrity_enum], sizeof(E.xIntegrity_signature)) == 0) {
+ return rtreeIntegrity(args);
+ }
+ else if (memcmp(E.xIntegrity_signature, xIntegrity_signatures[xIntegrity_vtablogIntegrity_enum], sizeof(E.xIntegrity_signature)) == 0) {
+ return vtablogIntegrity(args);
+ }


// Transform return E.xLock(args) to if-chain with 7 candidates
@transform_return_xLock@
expression E;
identifier FP_NAME = xLock;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xLock_signature, xLock_signatures[xLock_0_enum], sizeof(E.xLock_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xLock_signature, xLock_signatures[xLock_apndLock_enum], sizeof(E.xLock_signature)) == 0) {
+ return apndLock(args);
+ }
+ else if (memcmp(E.xLock_signature, xLock_signatures[xLock_memdbLock_enum], sizeof(E.xLock_signature)) == 0) {
+ return memdbLock(args);
+ }
+ else if (memcmp(E.xLock_signature, xLock_signatures[xLock_recoverVfsLock_enum], sizeof(E.xLock_signature)) == 0) {
+ return recoverVfsLock(args);
+ }
+ else if (memcmp(E.xLock_signature, xLock_signatures[xLock_vfstraceLock_enum], sizeof(E.xLock_signature)) == 0) {
+ return vfstraceLock(args);
+ }
+ else if (memcmp(E.xLock_signature, xLock_signatures[xLock_unixLock_enum], sizeof(E.xLock_signature)) == 0) {
+ return unixLock(args);
+ }
+ else if (memcmp(E.xLock_signature, xLock_signatures[xLock_nolockLock_enum], sizeof(E.xLock_signature)) == 0) {
+ return nolockLock(args);
+ }
+ else if (memcmp(E.xLock_signature, xLock_signatures[xLock_dotlockLock_enum], sizeof(E.xLock_signature)) == 0) {
+ return dotlockLock(args);
+ }


// Transform return E.xMalloc(args) to if-chain with 2 candidates
@transform_return_xMalloc@
expression E;
identifier FP_NAME = xMalloc;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xMalloc_signature, xMalloc_signatures[xMalloc_memtraceMalloc_enum], sizeof(E.xMalloc_signature)) == 0) {
+ return memtraceMalloc(args);
+ }
+ else if (memcmp(E.xMalloc_signature, xMalloc_signatures[xMalloc_sqlite3MemMalloc_enum], sizeof(E.xMalloc_signature)) == 0) {
+ return sqlite3MemMalloc(args);
+ }


// Transform return E.xMutexAlloc(args) to if-chain with 7 candidates
@transform_return_xMutexAlloc@
expression E;
identifier FP_NAME = xMutexAlloc;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_checkMutexAlloc_enum], sizeof(E.xMutexAlloc_signature)) == 0) {
+ return checkMutexAlloc(args);
+ }
+ else if (memcmp(E.xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_counterMutexAlloc_enum], sizeof(E.xMutexAlloc_signature)) == 0) {
+ return counterMutexAlloc(args);
+ }
+ else if (memcmp(E.xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_debugMutexAlloc_enum], sizeof(E.xMutexAlloc_signature)) == 0) {
+ return debugMutexAlloc(args);
+ }
+ else if (memcmp(E.xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_noopMutexAlloc_enum], sizeof(E.xMutexAlloc_signature)) == 0) {
+ return noopMutexAlloc(args);
+ }
+ else if (memcmp(E.xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_pthreadMutexAlloc_enum], sizeof(E.xMutexAlloc_signature)) == 0) {
+ return pthreadMutexAlloc(args);
+ }
+ else if (memcmp(E.xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_winMutexAlloc_enum], sizeof(E.xMutexAlloc_signature)) == 0) {
+ return winMutexAlloc(args);
+ }
+ else if (memcmp(E.xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_wrMutexAlloc_enum], sizeof(E.xMutexAlloc_signature)) == 0) {
+ return wrMutexAlloc(args);
+ }


// Transform return E.xMutexEnd(args) to if-chain with 7 candidates
@transform_return_xMutexEnd@
expression E;
identifier FP_NAME = xMutexEnd;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_checkMutexEnd_enum], sizeof(E.xMutexEnd_signature)) == 0) {
+ return checkMutexEnd(args);
+ }
+ else if (memcmp(E.xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_counterMutexEnd_enum], sizeof(E.xMutexEnd_signature)) == 0) {
+ return counterMutexEnd(args);
+ }
+ else if (memcmp(E.xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_debugMutexEnd_enum], sizeof(E.xMutexEnd_signature)) == 0) {
+ return debugMutexEnd(args);
+ }
+ else if (memcmp(E.xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_noopMutexEnd_enum], sizeof(E.xMutexEnd_signature)) == 0) {
+ return noopMutexEnd(args);
+ }
+ else if (memcmp(E.xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_pthreadMutexEnd_enum], sizeof(E.xMutexEnd_signature)) == 0) {
+ return pthreadMutexEnd(args);
+ }
+ else if (memcmp(E.xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_winMutexEnd_enum], sizeof(E.xMutexEnd_signature)) == 0) {
+ return winMutexEnd(args);
+ }
+ else if (memcmp(E.xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_wrMutexEnd_enum], sizeof(E.xMutexEnd_signature)) == 0) {
+ return wrMutexEnd(args);
+ }


// Transform return E.xMutexEnter(args) to if-chain with 7 candidates
@transform_return_xMutexEnter@
expression E;
identifier FP_NAME = xMutexEnter;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_checkMutexEnter_enum], sizeof(E.xMutexEnter_signature)) == 0) {
+ return checkMutexEnter(args);
+ }
+ else if (memcmp(E.xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_counterMutexEnter_enum], sizeof(E.xMutexEnter_signature)) == 0) {
+ return counterMutexEnter(args);
+ }
+ else if (memcmp(E.xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_debugMutexEnter_enum], sizeof(E.xMutexEnter_signature)) == 0) {
+ return debugMutexEnter(args);
+ }
+ else if (memcmp(E.xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_noopMutexEnter_enum], sizeof(E.xMutexEnter_signature)) == 0) {
+ return noopMutexEnter(args);
+ }
+ else if (memcmp(E.xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_pthreadMutexEnter_enum], sizeof(E.xMutexEnter_signature)) == 0) {
+ return pthreadMutexEnter(args);
+ }
+ else if (memcmp(E.xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_winMutexEnter_enum], sizeof(E.xMutexEnter_signature)) == 0) {
+ return winMutexEnter(args);
+ }
+ else if (memcmp(E.xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_wrMutexEnter_enum], sizeof(E.xMutexEnter_signature)) == 0) {
+ return wrMutexEnter(args);
+ }


// Transform return E.xMutexFree(args) to if-chain with 7 candidates
@transform_return_xMutexFree@
expression E;
identifier FP_NAME = xMutexFree;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xMutexFree_signature, xMutexFree_signatures[xMutexFree_checkMutexFree_enum], sizeof(E.xMutexFree_signature)) == 0) {
+ return checkMutexFree(args);
+ }
+ else if (memcmp(E.xMutexFree_signature, xMutexFree_signatures[xMutexFree_counterMutexFree_enum], sizeof(E.xMutexFree_signature)) == 0) {
+ return counterMutexFree(args);
+ }
+ else if (memcmp(E.xMutexFree_signature, xMutexFree_signatures[xMutexFree_debugMutexFree_enum], sizeof(E.xMutexFree_signature)) == 0) {
+ return debugMutexFree(args);
+ }
+ else if (memcmp(E.xMutexFree_signature, xMutexFree_signatures[xMutexFree_noopMutexFree_enum], sizeof(E.xMutexFree_signature)) == 0) {
+ return noopMutexFree(args);
+ }
+ else if (memcmp(E.xMutexFree_signature, xMutexFree_signatures[xMutexFree_pthreadMutexFree_enum], sizeof(E.xMutexFree_signature)) == 0) {
+ return pthreadMutexFree(args);
+ }
+ else if (memcmp(E.xMutexFree_signature, xMutexFree_signatures[xMutexFree_winMutexFree_enum], sizeof(E.xMutexFree_signature)) == 0) {
+ return winMutexFree(args);
+ }
+ else if (memcmp(E.xMutexFree_signature, xMutexFree_signatures[xMutexFree_wrMutexFree_enum], sizeof(E.xMutexFree_signature)) == 0) {
+ return wrMutexFree(args);
+ }


// Transform return E.xMutexHeld(args) to if-chain with 3 candidates
@transform_return_xMutexHeld@
expression E;
identifier FP_NAME = xMutexHeld;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xMutexHeld_signature, xMutexHeld_signatures[xMutexHeld_0_enum], sizeof(E.xMutexHeld_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xMutexHeld_signature, xMutexHeld_signatures[xMutexHeld_counterMutexHeld_enum], sizeof(E.xMutexHeld_signature)) == 0) {
+ return counterMutexHeld(args);
+ }
+ else if (memcmp(E.xMutexHeld_signature, xMutexHeld_signatures[xMutexHeld_debugMutexHeld_enum], sizeof(E.xMutexHeld_signature)) == 0) {
+ return debugMutexHeld(args);
+ }
+ else if (memcmp(E.xMutexHeld_signature, xMutexHeld_signatures[xMutexHeld_wrMutexHeld_enum], sizeof(E.xMutexHeld_signature)) == 0) {
+ return wrMutexHeld(args);
+ }


// Transform return E.xMutexInit(args) to if-chain with 7 candidates
@transform_return_xMutexInit@
expression E;
identifier FP_NAME = xMutexInit;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xMutexInit_signature, xMutexInit_signatures[xMutexInit_checkMutexInit_enum], sizeof(E.xMutexInit_signature)) == 0) {
+ return checkMutexInit(args);
+ }
+ else if (memcmp(E.xMutexInit_signature, xMutexInit_signatures[xMutexInit_counterMutexInit_enum], sizeof(E.xMutexInit_signature)) == 0) {
+ return counterMutexInit(args);
+ }
+ else if (memcmp(E.xMutexInit_signature, xMutexInit_signatures[xMutexInit_debugMutexInit_enum], sizeof(E.xMutexInit_signature)) == 0) {
+ return debugMutexInit(args);
+ }
+ else if (memcmp(E.xMutexInit_signature, xMutexInit_signatures[xMutexInit_noopMutexInit_enum], sizeof(E.xMutexInit_signature)) == 0) {
+ return noopMutexInit(args);
+ }
+ else if (memcmp(E.xMutexInit_signature, xMutexInit_signatures[xMutexInit_pthreadMutexInit_enum], sizeof(E.xMutexInit_signature)) == 0) {
+ return pthreadMutexInit(args);
+ }
+ else if (memcmp(E.xMutexInit_signature, xMutexInit_signatures[xMutexInit_winMutexInit_enum], sizeof(E.xMutexInit_signature)) == 0) {
+ return winMutexInit(args);
+ }
+ else if (memcmp(E.xMutexInit_signature, xMutexInit_signatures[xMutexInit_wrMutexInit_enum], sizeof(E.xMutexInit_signature)) == 0) {
+ return wrMutexInit(args);
+ }


// Transform return E.xMutexLeave(args) to if-chain with 7 candidates
@transform_return_xMutexLeave@
expression E;
identifier FP_NAME = xMutexLeave;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_checkMutexLeave_enum], sizeof(E.xMutexLeave_signature)) == 0) {
+ return checkMutexLeave(args);
+ }
+ else if (memcmp(E.xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_counterMutexLeave_enum], sizeof(E.xMutexLeave_signature)) == 0) {
+ return counterMutexLeave(args);
+ }
+ else if (memcmp(E.xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_debugMutexLeave_enum], sizeof(E.xMutexLeave_signature)) == 0) {
+ return debugMutexLeave(args);
+ }
+ else if (memcmp(E.xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_noopMutexLeave_enum], sizeof(E.xMutexLeave_signature)) == 0) {
+ return noopMutexLeave(args);
+ }
+ else if (memcmp(E.xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_pthreadMutexLeave_enum], sizeof(E.xMutexLeave_signature)) == 0) {
+ return pthreadMutexLeave(args);
+ }
+ else if (memcmp(E.xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_winMutexLeave_enum], sizeof(E.xMutexLeave_signature)) == 0) {
+ return winMutexLeave(args);
+ }
+ else if (memcmp(E.xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_wrMutexLeave_enum], sizeof(E.xMutexLeave_signature)) == 0) {
+ return wrMutexLeave(args);
+ }


// Transform return E.xMutexNotheld(args) to if-chain with 3 candidates
@transform_return_xMutexNotheld@
expression E;
identifier FP_NAME = xMutexNotheld;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xMutexNotheld_signature, xMutexNotheld_signatures[xMutexNotheld_0_enum], sizeof(E.xMutexNotheld_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xMutexNotheld_signature, xMutexNotheld_signatures[xMutexNotheld_counterMutexNotheld_enum], sizeof(E.xMutexNotheld_signature)) == 0) {
+ return counterMutexNotheld(args);
+ }
+ else if (memcmp(E.xMutexNotheld_signature, xMutexNotheld_signatures[xMutexNotheld_debugMutexNotheld_enum], sizeof(E.xMutexNotheld_signature)) == 0) {
+ return debugMutexNotheld(args);
+ }
+ else if (memcmp(E.xMutexNotheld_signature, xMutexNotheld_signatures[xMutexNotheld_wrMutexNotheld_enum], sizeof(E.xMutexNotheld_signature)) == 0) {
+ return wrMutexNotheld(args);
+ }


// Transform return E.xMutexTry(args) to if-chain with 7 candidates
@transform_return_xMutexTry@
expression E;
identifier FP_NAME = xMutexTry;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xMutexTry_signature, xMutexTry_signatures[xMutexTry_checkMutexTry_enum], sizeof(E.xMutexTry_signature)) == 0) {
+ return checkMutexTry(args);
+ }
+ else if (memcmp(E.xMutexTry_signature, xMutexTry_signatures[xMutexTry_counterMutexTry_enum], sizeof(E.xMutexTry_signature)) == 0) {
+ return counterMutexTry(args);
+ }
+ else if (memcmp(E.xMutexTry_signature, xMutexTry_signatures[xMutexTry_debugMutexTry_enum], sizeof(E.xMutexTry_signature)) == 0) {
+ return debugMutexTry(args);
+ }
+ else if (memcmp(E.xMutexTry_signature, xMutexTry_signatures[xMutexTry_noopMutexTry_enum], sizeof(E.xMutexTry_signature)) == 0) {
+ return noopMutexTry(args);
+ }
+ else if (memcmp(E.xMutexTry_signature, xMutexTry_signatures[xMutexTry_pthreadMutexTry_enum], sizeof(E.xMutexTry_signature)) == 0) {
+ return pthreadMutexTry(args);
+ }
+ else if (memcmp(E.xMutexTry_signature, xMutexTry_signatures[xMutexTry_winMutexTry_enum], sizeof(E.xMutexTry_signature)) == 0) {
+ return winMutexTry(args);
+ }
+ else if (memcmp(E.xMutexTry_signature, xMutexTry_signatures[xMutexTry_wrMutexTry_enum], sizeof(E.xMutexTry_signature)) == 0) {
+ return wrMutexTry(args);
+ }


// Transform return E.xNew(args) to if-chain with 3 candidates
@transform_return_xNew@
expression E;
identifier FP_NAME = xNew;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xNew_signature, xNew_signatures[xNew_sessionDiffNew_enum], sizeof(E.xNew_signature)) == 0) {
+ return sessionDiffNew(args);
+ }
+ else if (memcmp(E.xNew_signature, xNew_signatures[xNew_sessionPreupdateNew_enum], sizeof(E.xNew_signature)) == 0) {
+ return sessionPreupdateNew(args);
+ }
+ else if (memcmp(E.xNew_signature, xNew_signatures[xNew_sessionStat1New_enum], sizeof(E.xNew_signature)) == 0) {
+ return sessionStat1New(args);
+ }


// Transform return E.xNext(args) to if-chain with 46 candidates
@transform_return_xNext@
expression E;
identifier FP_NAME = xNext;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xNext_signature, xNext_signatures[xNext_0_enum], sizeof(E.xNext_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_amatchNext_enum], sizeof(E.xNext_signature)) == 0) {
+ return amatchNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_binfoNext_enum], sizeof(E.xNext_signature)) == 0) {
+ return binfoNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_bytecodevtabNext_enum], sizeof(E.xNext_signature)) == 0) {
+ return bytecodevtabNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_carrayNext_enum], sizeof(E.xNext_signature)) == 0) {
+ return carrayNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_cidxNext_enum], sizeof(E.xNext_signature)) == 0) {
+ return cidxNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_closureNext_enum], sizeof(E.xNext_signature)) == 0) {
+ return closureNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_completionNext_enum], sizeof(E.xNext_signature)) == 0) {
+ return completionNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_csvtabNext_enum], sizeof(E.xNext_signature)) == 0) {
+ return csvtabNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_dbdataNext_enum], sizeof(E.xNext_signature)) == 0) {
+ return dbdataNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_dbpageNext_enum], sizeof(E.xNext_signature)) == 0) {
+ return dbpageNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_deltaparsevtabNext_enum], sizeof(E.xNext_signature)) == 0) {
+ return deltaparsevtabNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_echoNext_enum], sizeof(E.xNext_signature)) == 0) {
+ return echoNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_expertNext_enum], sizeof(E.xNext_signature)) == 0) {
+ return expertNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_explainNext_enum], sizeof(E.xNext_signature)) == 0) {
+ return explainNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_fsNext_enum], sizeof(E.xNext_signature)) == 0) {
+ return fsNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_fsdirNext_enum], sizeof(E.xNext_signature)) == 0) {
+ return fsdirNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_fstreeNext_enum], sizeof(E.xNext_signature)) == 0) {
+ return fstreeNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_fts3NextMethod_enum], sizeof(E.xNext_signature)) == 0) {
+ return fts3NextMethod(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_fts3auxNextMethod_enum], sizeof(E.xNext_signature)) == 0) {
+ return fts3auxNextMethod(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_fts3termNextMethod_enum], sizeof(E.xNext_signature)) == 0) {
+ return fts3termNextMethod(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_fts3tokNextMethod_enum], sizeof(E.xNext_signature)) == 0) {
+ return fts3tokNextMethod(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_fuzzerNext_enum], sizeof(E.xNext_signature)) == 0) {
+ return fuzzerNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_intarrayNext_enum], sizeof(E.xNext_signature)) == 0) {
+ return intarrayNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_jsonEachNext_enum], sizeof(E.xNext_signature)) == 0) {
+ return jsonEachNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_memstatNext_enum], sizeof(E.xNext_signature)) == 0) {
+ return memstatNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_porterNext_enum], sizeof(E.xNext_signature)) == 0) {
+ return porterNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_pragmaVtabNext_enum], sizeof(E.xNext_signature)) == 0) {
+ return pragmaVtabNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_prefixesNext_enum], sizeof(E.xNext_signature)) == 0) {
+ return prefixesNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_qpvtabNext_enum], sizeof(E.xNext_signature)) == 0) {
+ return qpvtabNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_rtreeNext_enum], sizeof(E.xNext_signature)) == 0) {
+ return rtreeNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_schemaNext_enum], sizeof(E.xNext_signature)) == 0) {
+ return schemaNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_seriesNext_enum], sizeof(E.xNext_signature)) == 0) {
+ return seriesNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_simpleNext_enum], sizeof(E.xNext_signature)) == 0) {
+ return simpleNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_spellfix1Next_enum], sizeof(E.xNext_signature)) == 0) {
+ return spellfix1Next(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_statNext_enum], sizeof(E.xNext_signature)) == 0) {
+ return statNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_stmtNext_enum], sizeof(E.xNext_signature)) == 0) {
+ return stmtNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_tclNext_enum], sizeof(E.xNext_signature)) == 0) {
+ return tclNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_tclvarNext_enum], sizeof(E.xNext_signature)) == 0) {
+ return tclvarNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_templatevtabNext_enum], sizeof(E.xNext_signature)) == 0) {
+ return templatevtabNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_unicodeNext_enum], sizeof(E.xNext_signature)) == 0) {
+ return unicodeNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_unionNext_enum], sizeof(E.xNext_signature)) == 0) {
+ return unionNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_vlogNext_enum], sizeof(E.xNext_signature)) == 0) {
+ return vlogNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_vstattabNext_enum], sizeof(E.xNext_signature)) == 0) {
+ return vstattabNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_vtablogNext_enum], sizeof(E.xNext_signature)) == 0) {
+ return vtablogNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_wholenumberNext_enum], sizeof(E.xNext_signature)) == 0) {
+ return wholenumberNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_zipfileNext_enum], sizeof(E.xNext_signature)) == 0) {
+ return zipfileNext(args);
+ }


// Transform return E.xNextSystemCall(args) to if-chain with 3 candidates
@transform_return_xNextSystemCall@
expression E;
identifier FP_NAME = xNextSystemCall;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xNextSystemCall_signature, xNextSystemCall_signatures[xNextSystemCall_0_enum], sizeof(E.xNextSystemCall_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xNextSystemCall_signature, xNextSystemCall_signatures[xNextSystemCall_apndNextSystemCall_enum], sizeof(E.xNextSystemCall_signature)) == 0) {
+ return apndNextSystemCall(args);
+ }
+ else if (memcmp(E.xNextSystemCall_signature, xNextSystemCall_signatures[xNextSystemCall_rbuVfsGetLastError_enum], sizeof(E.xNextSystemCall_signature)) == 0) {
+ return rbuVfsGetLastError(args);
+ }
+ else if (memcmp(E.xNextSystemCall_signature, xNextSystemCall_signatures[xNextSystemCall_unixNextSystemCall_enum], sizeof(E.xNextSystemCall_signature)) == 0) {
+ return unixNextSystemCall(args);
+ }


// Transform return E.xOld(args) to if-chain with 3 candidates
@transform_return_xOld@
expression E;
identifier FP_NAME = xOld;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xOld_signature, xOld_signatures[xOld_sessionDiffOld_enum], sizeof(E.xOld_signature)) == 0) {
+ return sessionDiffOld(args);
+ }
+ else if (memcmp(E.xOld_signature, xOld_signatures[xOld_sessionPreupdateOld_enum], sizeof(E.xOld_signature)) == 0) {
+ return sessionPreupdateOld(args);
+ }
+ else if (memcmp(E.xOld_signature, xOld_signatures[xOld_sessionStat1Old_enum], sizeof(E.xOld_signature)) == 0) {
+ return sessionStat1Old(args);
+ }


// Transform return E.xOpen(args) to if-chain with 51 candidates
@transform_return_xOpen@
expression E;
identifier FP_NAME = xOpen;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_amatchOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ return amatchOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_apndOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ return apndOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_binfoOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ return binfoOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_bytecodevtabOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ return bytecodevtabOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_carrayOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ return carrayOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_cidxOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ return cidxOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_closureOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ return closureOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_completionOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ return completionOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_csvtabOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ return csvtabOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_dbdataOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ return dbdataOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_dbpageOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ return dbpageOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_deltaparsevtabOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ return deltaparsevtabOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_echoOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ return echoOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_expertOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ return expertOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_explainOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ return explainOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_fsOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ return fsOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_fsdirOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ return fsdirOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_fstreeOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ return fstreeOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_fts3OpenMethod_enum], sizeof(E.xOpen_signature)) == 0) {
+ return fts3OpenMethod(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_fts3auxOpenMethod_enum], sizeof(E.xOpen_signature)) == 0) {
+ return fts3auxOpenMethod(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_fts3termOpenMethod_enum], sizeof(E.xOpen_signature)) == 0) {
+ return fts3termOpenMethod(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_fts3tokOpenMethod_enum], sizeof(E.xOpen_signature)) == 0) {
+ return fts3tokOpenMethod(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_fuzzerOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ return fuzzerOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_intarrayOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ return intarrayOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_jsonEachOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ return jsonEachOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_jsonEachOpenEach_enum], sizeof(E.xOpen_signature)) == 0) {
+ return jsonEachOpenEach(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_jsonEachOpenTree_enum], sizeof(E.xOpen_signature)) == 0) {
+ return jsonEachOpenTree(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_memdbOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ return memdbOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_memstatOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ return memstatOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_porterOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ return porterOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_pragmaVtabOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ return pragmaVtabOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_prefixesOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ return prefixesOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_qpvtabOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ return qpvtabOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_rtreeOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ return rtreeOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_schemaOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ return schemaOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_seriesOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ return seriesOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_simpleOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ return simpleOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_spellfix1Open_enum], sizeof(E.xOpen_signature)) == 0) {
+ return spellfix1Open(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_statOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ return statOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_stmtOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ return stmtOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_tclOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ return tclOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_tclvarOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ return tclvarOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_templatevtabOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ return templatevtabOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_unicodeOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ return unicodeOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_unionOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ return unionOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_vfstraceOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ return vfstraceOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_vstattabOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ return vstattabOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_vtablogOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ return vtablogOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_wholenumberOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ return wholenumberOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_zipfileOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ return zipfileOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_unixOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ return unixOpen(args);
+ }


// Transform return E.xPagecount(args) to if-chain with 2 candidates
@transform_return_xPagecount@
expression E;
identifier FP_NAME = xPagecount;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xPagecount_signature, xPagecount_signatures[xPagecount_pcache1Pagecount_enum], sizeof(E.xPagecount_signature)) == 0) {
+ return pcache1Pagecount(args);
+ }
+ else if (memcmp(E.xPagecount_signature, xPagecount_signatures[xPagecount_pcachetracePagecount_enum], sizeof(E.xPagecount_signature)) == 0) {
+ return pcachetracePagecount(args);
+ }


// Transform return E.xParseCell(args) to if-chain with 3 candidates
@transform_return_xParseCell@
expression E;
identifier FP_NAME = xParseCell;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xParseCell_signature, xParseCell_signatures[xParseCell_btreeParseCellPtr_enum], sizeof(E.xParseCell_signature)) == 0) {
+ return btreeParseCellPtr(args);
+ }
+ else if (memcmp(E.xParseCell_signature, xParseCell_signatures[xParseCell_btreeParseCellPtrIndex_enum], sizeof(E.xParseCell_signature)) == 0) {
+ return btreeParseCellPtrIndex(args);
+ }
+ else if (memcmp(E.xParseCell_signature, xParseCell_signatures[xParseCell_btreeParseCellPtrNoPayload_enum], sizeof(E.xParseCell_signature)) == 0) {
+ return btreeParseCellPtrNoPayload(args);
+ }


// Transform return E.xRandomness(args) to if-chain with 4 candidates
@transform_return_xRandomness@
expression E;
identifier FP_NAME = xRandomness;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xRandomness_signature, xRandomness_signatures[xRandomness_apndRandomness_enum], sizeof(E.xRandomness_signature)) == 0) {
+ return apndRandomness(args);
+ }
+ else if (memcmp(E.xRandomness_signature, xRandomness_signatures[xRandomness_memdbRandomness_enum], sizeof(E.xRandomness_signature)) == 0) {
+ return memdbRandomness(args);
+ }
+ else if (memcmp(E.xRandomness_signature, xRandomness_signatures[xRandomness_vfstraceRandomness_enum], sizeof(E.xRandomness_signature)) == 0) {
+ return vfstraceRandomness(args);
+ }
+ else if (memcmp(E.xRandomness_signature, xRandomness_signatures[xRandomness_unixRandomness_enum], sizeof(E.xRandomness_signature)) == 0) {
+ return unixRandomness(args);
+ }


// Transform return E.xRead(args) to if-chain with 6 candidates
@transform_return_xRead@
expression E;
identifier FP_NAME = xRead;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xRead_signature, xRead_signatures[xRead_apndRead_enum], sizeof(E.xRead_signature)) == 0) {
+ return apndRead(args);
+ }
+ else if (memcmp(E.xRead_signature, xRead_signatures[xRead_memdbRead_enum], sizeof(E.xRead_signature)) == 0) {
+ return memdbRead(args);
+ }
+ else if (memcmp(E.xRead_signature, xRead_signatures[xRead_memjrnlRead_enum], sizeof(E.xRead_signature)) == 0) {
+ return memjrnlRead(args);
+ }
+ else if (memcmp(E.xRead_signature, xRead_signatures[xRead_recoverVfsRead_enum], sizeof(E.xRead_signature)) == 0) {
+ return recoverVfsRead(args);
+ }
+ else if (memcmp(E.xRead_signature, xRead_signatures[xRead_vfstraceRead_enum], sizeof(E.xRead_signature)) == 0) {
+ return vfstraceRead(args);
+ }
+ else if (memcmp(E.xRead_signature, xRead_signatures[xRead_unixRead_enum], sizeof(E.xRead_signature)) == 0) {
+ return unixRead(args);
+ }


// Transform return E.xRealloc(args) to if-chain with 2 candidates
@transform_return_xRealloc@
expression E;
identifier FP_NAME = xRealloc;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xRealloc_signature, xRealloc_signatures[xRealloc_memtraceRealloc_enum], sizeof(E.xRealloc_signature)) == 0) {
+ return memtraceRealloc(args);
+ }
+ else if (memcmp(E.xRealloc_signature, xRealloc_signatures[xRealloc_sqlite3MemRealloc_enum], sizeof(E.xRealloc_signature)) == 0) {
+ return sqlite3MemRealloc(args);
+ }


// Transform return E.xRekey(args) to if-chain with 3 candidates
@transform_return_xRekey@
expression E;
identifier FP_NAME = xRekey;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xRekey_signature, xRekey_signatures[xRekey_pcache1Rekey_enum], sizeof(E.xRekey_signature)) == 0) {
+ return pcache1Rekey(args);
+ }
+ else if (memcmp(E.xRekey_signature, xRekey_signatures[xRekey_pcachetraceRekey_enum], sizeof(E.xRekey_signature)) == 0) {
+ return pcachetraceRekey(args);
+ }
+ else if (memcmp(E.xRekey_signature, xRekey_signatures[xRekey_unixRandomness_enum], sizeof(E.xRekey_signature)) == 0) {
+ return unixRandomness(args);
+ }


// Transform return E.xRelease(args) to if-chain with 3 candidates
@transform_return_xRelease@
expression E;
identifier FP_NAME = xRelease;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xRelease_signature, xRelease_signatures[xRelease_0_enum], sizeof(E.xRelease_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xRelease_signature, xRelease_signatures[xRelease_echoRelease_enum], sizeof(E.xRelease_signature)) == 0) {
+ return echoRelease(args);
+ }
+ else if (memcmp(E.xRelease_signature, xRelease_signatures[xRelease_fts3ReleaseMethod_enum], sizeof(E.xRelease_signature)) == 0) {
+ return fts3ReleaseMethod(args);
+ }
+ else if (memcmp(E.xRelease_signature, xRelease_signatures[xRelease_vtablogRelease_enum], sizeof(E.xRelease_signature)) == 0) {
+ return vtablogRelease(args);
+ }


// Transform return E.xRename(args) to if-chain with 5 candidates
@transform_return_xRename@
expression E;
identifier FP_NAME = xRename;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xRename_signature, xRename_signatures[xRename_0_enum], sizeof(E.xRename_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xRename_signature, xRename_signatures[xRename_echoRename_enum], sizeof(E.xRename_signature)) == 0) {
+ return echoRename(args);
+ }
+ else if (memcmp(E.xRename_signature, xRename_signatures[xRename_fts3RenameMethod_enum], sizeof(E.xRename_signature)) == 0) {
+ return fts3RenameMethod(args);
+ }
+ else if (memcmp(E.xRename_signature, xRename_signatures[xRename_rtreeRename_enum], sizeof(E.xRename_signature)) == 0) {
+ return rtreeRename(args);
+ }
+ else if (memcmp(E.xRename_signature, xRename_signatures[xRename_spellfix1Rename_enum], sizeof(E.xRename_signature)) == 0) {
+ return spellfix1Rename(args);
+ }
+ else if (memcmp(E.xRename_signature, xRename_signatures[xRename_vtablogRename_enum], sizeof(E.xRename_signature)) == 0) {
+ return vtablogRename(args);
+ }


// Transform return E.xRollback(args) to if-chain with 6 candidates
@transform_return_xRollback@
expression E;
identifier FP_NAME = xRollback;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xRollback_signature, xRollback_signatures[xRollback_0_enum], sizeof(E.xRollback_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xRollback_signature, xRollback_signatures[xRollback_echoRollback_enum], sizeof(E.xRollback_signature)) == 0) {
+ return echoRollback(args);
+ }
+ else if (memcmp(E.xRollback_signature, xRollback_signatures[xRollback_fts3RollbackMethod_enum], sizeof(E.xRollback_signature)) == 0) {
+ return fts3RollbackMethod(args);
+ }
+ else if (memcmp(E.xRollback_signature, xRollback_signatures[xRollback_rtreeEndTransaction_enum], sizeof(E.xRollback_signature)) == 0) {
+ return rtreeEndTransaction(args);
+ }
+ else if (memcmp(E.xRollback_signature, xRollback_signatures[xRollback_rtreeRollback_enum], sizeof(E.xRollback_signature)) == 0) {
+ return rtreeRollback(args);
+ }
+ else if (memcmp(E.xRollback_signature, xRollback_signatures[xRollback_vtablogRollback_enum], sizeof(E.xRollback_signature)) == 0) {
+ return vtablogRollback(args);
+ }
+ else if (memcmp(E.xRollback_signature, xRollback_signatures[xRollback_zipfileRollback_enum], sizeof(E.xRollback_signature)) == 0) {
+ return zipfileRollback(args);
+ }


// Transform return E.xRollbackTo(args) to if-chain with 4 candidates
@transform_return_xRollbackTo@
expression E;
identifier FP_NAME = xRollbackTo;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xRollbackTo_signature, xRollbackTo_signatures[xRollbackTo_0_enum], sizeof(E.xRollbackTo_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xRollbackTo_signature, xRollbackTo_signatures[xRollbackTo_dbpageRollbackTo_enum], sizeof(E.xRollbackTo_signature)) == 0) {
+ return dbpageRollbackTo(args);
+ }
+ else if (memcmp(E.xRollbackTo_signature, xRollbackTo_signatures[xRollbackTo_echoRollbackTo_enum], sizeof(E.xRollbackTo_signature)) == 0) {
+ return echoRollbackTo(args);
+ }
+ else if (memcmp(E.xRollbackTo_signature, xRollbackTo_signatures[xRollbackTo_fts3RollbackToMethod_enum], sizeof(E.xRollbackTo_signature)) == 0) {
+ return fts3RollbackToMethod(args);
+ }
+ else if (memcmp(E.xRollbackTo_signature, xRollbackTo_signatures[xRollbackTo_vtablogRollbackTo_enum], sizeof(E.xRollbackTo_signature)) == 0) {
+ return vtablogRollbackTo(args);
+ }


// Transform return E.xRoundup(args) to if-chain with 2 candidates
@transform_return_xRoundup@
expression E;
identifier FP_NAME = xRoundup;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xRoundup_signature, xRoundup_signatures[xRoundup_memtraceRoundup_enum], sizeof(E.xRoundup_signature)) == 0) {
+ return memtraceRoundup(args);
+ }
+ else if (memcmp(E.xRoundup_signature, xRoundup_signatures[xRoundup_sqlite3MemRoundup_enum], sizeof(E.xRoundup_signature)) == 0) {
+ return sqlite3MemRoundup(args);
+ }


// Transform return E.xRowid(args) to if-chain with 42 candidates
@transform_return_xRowid@
expression E;
identifier FP_NAME = xRowid;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_0_enum], sizeof(E.xRowid_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_amatchRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ return amatchRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_binfoRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ return binfoRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_bytecodevtabRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ return bytecodevtabRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_carrayRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ return carrayRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_cidxRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ return cidxRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_closureRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ return closureRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_completionRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ return completionRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_csvtabRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ return csvtabRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_dbdataRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ return dbdataRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_dbpageRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ return dbpageRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_deltaparsevtabRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ return deltaparsevtabRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_echoRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ return echoRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_expertRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ return expertRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_explainRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ return explainRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_fsRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ return fsRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_fsdirRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ return fsdirRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_fstreeRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ return fstreeRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_fts3RowidMethod_enum], sizeof(E.xRowid_signature)) == 0) {
+ return fts3RowidMethod(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_fts3auxRowidMethod_enum], sizeof(E.xRowid_signature)) == 0) {
+ return fts3auxRowidMethod(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_fts3termRowidMethod_enum], sizeof(E.xRowid_signature)) == 0) {
+ return fts3termRowidMethod(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_fts3tokRowidMethod_enum], sizeof(E.xRowid_signature)) == 0) {
+ return fts3tokRowidMethod(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_fuzzerRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ return fuzzerRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_intarrayRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ return intarrayRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_jsonEachRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ return jsonEachRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_memstatRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ return memstatRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_pragmaVtabRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ return pragmaVtabRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_prefixesRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ return prefixesRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_qpvtabRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ return qpvtabRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_rtreeRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ return rtreeRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_schemaRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ return schemaRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_seriesRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ return seriesRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_spellfix1Rowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ return spellfix1Rowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_statRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ return statRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_stmtRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ return stmtRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_tclRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ return tclRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_tclvarRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ return tclvarRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_templatevtabRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ return templatevtabRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_unionRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ return unionRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_vlogRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ return vlogRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_vstattabRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ return vstattabRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_vtablogRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ return vtablogRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_wholenumberRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ return wholenumberRowid(args);
+ }


// Transform return E.xSFunc(args) to if-chain with 5 candidates
@transform_return_xSFunc@
expression E;
identifier FP_NAME = xSFunc;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_attachFunc_enum], sizeof(E.xSFunc_signature)) == 0) {
+ return attachFunc(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_detachFunc_enum], sizeof(E.xSFunc_signature)) == 0) {
+ return detachFunc(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_statGet_enum], sizeof(E.xSFunc_signature)) == 0) {
+ return statGet(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_statInit_enum], sizeof(E.xSFunc_signature)) == 0) {
+ return statInit(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_statPush_enum], sizeof(E.xSFunc_signature)) == 0) {
+ return statPush(args);
+ }


// Transform return E.xSavepoint(args) to if-chain with 2 candidates
@transform_return_xSavepoint@
expression E;
identifier FP_NAME = xSavepoint;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xSavepoint_signature, xSavepoint_signatures[xSavepoint_0_enum], sizeof(E.xSavepoint_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xSavepoint_signature, xSavepoint_signatures[xSavepoint_fts3SavepointMethod_enum], sizeof(E.xSavepoint_signature)) == 0) {
+ return fts3SavepointMethod(args);
+ }
+ else if (memcmp(E.xSavepoint_signature, xSavepoint_signatures[xSavepoint_rtreeSavepoint_enum], sizeof(E.xSavepoint_signature)) == 0) {
+ return rtreeSavepoint(args);
+ }


// Transform return E.xSectorSize(args) to if-chain with 4 candidates
@transform_return_xSectorSize@
expression E;
identifier FP_NAME = xSectorSize;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xSectorSize_signature, xSectorSize_signatures[xSectorSize_0_enum], sizeof(E.xSectorSize_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xSectorSize_signature, xSectorSize_signatures[xSectorSize_apndSectorSize_enum], sizeof(E.xSectorSize_signature)) == 0) {
+ return apndSectorSize(args);
+ }
+ else if (memcmp(E.xSectorSize_signature, xSectorSize_signatures[xSectorSize_recoverVfsSectorSize_enum], sizeof(E.xSectorSize_signature)) == 0) {
+ return recoverVfsSectorSize(args);
+ }
+ else if (memcmp(E.xSectorSize_signature, xSectorSize_signatures[xSectorSize_vfstraceSectorSize_enum], sizeof(E.xSectorSize_signature)) == 0) {
+ return vfstraceSectorSize(args);
+ }
+ else if (memcmp(E.xSectorSize_signature, xSectorSize_signatures[xSectorSize_unixSectorSize_enum], sizeof(E.xSectorSize_signature)) == 0) {
+ return unixSectorSize(args);
+ }


// Transform return E.xSelectCallback(args) to if-chain with 16 candidates
@transform_return_xSelectCallback@
expression E;
identifier FP_NAME = xSelectCallback;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_0_enum], sizeof(E.xSelectCallback_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_convertCompoundSelectToSubquery_enum], sizeof(E.xSelectCallback_signature)) == 0) {
+ return convertCompoundSelectToSubquery(args);
+ }
+ else if (memcmp(E.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_exprSelectWalkTableConstant_enum], sizeof(E.xSelectCallback_signature)) == 0) {
+ return exprSelectWalkTableConstant(args);
+ }
+ else if (memcmp(E.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_fixSelectCb_enum], sizeof(E.xSelectCallback_signature)) == 0) {
+ return fixSelectCb(args);
+ }
+ else if (memcmp(E.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_gatherSelectWindowsSelectCallback_enum], sizeof(E.xSelectCallback_signature)) == 0) {
+ return gatherSelectWindowsSelectCallback(args);
+ }
+ else if (memcmp(E.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_renameColumnSelectCb_enum], sizeof(E.xSelectCallback_signature)) == 0) {
+ return renameColumnSelectCb(args);
+ }
+ else if (memcmp(E.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_renameTableSelectCb_enum], sizeof(E.xSelectCallback_signature)) == 0) {
+ return renameTableSelectCb(args);
+ }
+ else if (memcmp(E.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_renameUnmapSelectCb_enum], sizeof(E.xSelectCallback_signature)) == 0) {
+ return renameUnmapSelectCb(args);
+ }
+ else if (memcmp(E.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_resolveSelectStep_enum], sizeof(E.xSelectCallback_signature)) == 0) {
+ return resolveSelectStep(args);
+ }
+ else if (memcmp(E.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_selectCheckOnClausesSelect_enum], sizeof(E.xSelectCallback_signature)) == 0) {
+ return selectCheckOnClausesSelect(args);
+ }
+ else if (memcmp(E.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_selectExpander_enum], sizeof(E.xSelectCallback_signature)) == 0) {
+ return selectExpander(args);
+ }
+ else if (memcmp(E.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_selectRefEnter_enum], sizeof(E.xSelectCallback_signature)) == 0) {
+ return selectRefEnter(args);
+ }
+ else if (memcmp(E.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_selectWindowRewriteSelectCb_enum], sizeof(E.xSelectCallback_signature)) == 0) {
+ return selectWindowRewriteSelectCb(args);
+ }
+ else if (memcmp(E.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_sqlite3ReturningSubqueryCorrelated_enum], sizeof(E.xSelectCallback_signature)) == 0) {
+ return sqlite3ReturningSubqueryCorrelated(args);
+ }
+ else if (memcmp(E.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_sqlite3SelectWalkFail_enum], sizeof(E.xSelectCallback_signature)) == 0) {
+ return sqlite3SelectWalkFail(args);
+ }
+ else if (memcmp(E.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_sqlite3SelectWalkNoop_enum], sizeof(E.xSelectCallback_signature)) == 0) {
+ return sqlite3SelectWalkNoop(args);
+ }
+ else if (memcmp(E.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_sqlite3WalkerDepthIncrease_enum], sizeof(E.xSelectCallback_signature)) == 0) {
+ return sqlite3WalkerDepthIncrease(args);
+ }


// Transform return E.xSelectCallback2(args) to if-chain with 5 candidates
@transform_return_xSelectCallback2@
expression E;
identifier FP_NAME = xSelectCallback2;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_0_enum], sizeof(E.xSelectCallback2_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_selectAddSubqueryTypeInfo_enum], sizeof(E.xSelectCallback2_signature)) == 0) {
+ return selectAddSubqueryTypeInfo(args);
+ }
+ else if (memcmp(E.xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_selectRefLeave_enum], sizeof(E.xSelectCallback2_signature)) == 0) {
+ return selectRefLeave(args);
+ }
+ else if (memcmp(E.xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_sqlite3SelectPopWith_enum], sizeof(E.xSelectCallback2_signature)) == 0) {
+ return sqlite3SelectPopWith(args);
+ }
+ else if (memcmp(E.xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_sqlite3WalkWinDefnDummyCallback_enum], sizeof(E.xSelectCallback2_signature)) == 0) {
+ return sqlite3WalkWinDefnDummyCallback(args);
+ }
+ else if (memcmp(E.xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_sqlite3WalkerDepthDecrease_enum], sizeof(E.xSelectCallback2_signature)) == 0) {
+ return sqlite3WalkerDepthDecrease(args);
+ }


// Transform return E.xSetSystemCall(args) to if-chain with 5 candidates
@transform_return_xSetSystemCall@
expression E;
identifier FP_NAME = xSetSystemCall;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xSetSystemCall_signature, xSetSystemCall_signatures[xSetSystemCall_0_enum], sizeof(E.xSetSystemCall_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xSetSystemCall_signature, xSetSystemCall_signatures[xSetSystemCall_apndSetSystemCall_enum], sizeof(E.xSetSystemCall_signature)) == 0) {
+ return apndSetSystemCall(args);
+ }
+ else if (memcmp(E.xSetSystemCall_signature, xSetSystemCall_signatures[xSetSystemCall_devsymSleep_enum], sizeof(E.xSetSystemCall_signature)) == 0) {
+ return devsymSleep(args);
+ }
+ else if (memcmp(E.xSetSystemCall_signature, xSetSystemCall_signatures[xSetSystemCall_rbuVfsSleep_enum], sizeof(E.xSetSystemCall_signature)) == 0) {
+ return rbuVfsSleep(args);
+ }
+ else if (memcmp(E.xSetSystemCall_signature, xSetSystemCall_signatures[xSetSystemCall_tvfsSleep_enum], sizeof(E.xSetSystemCall_signature)) == 0) {
+ return tvfsSleep(args);
+ }
+ else if (memcmp(E.xSetSystemCall_signature, xSetSystemCall_signatures[xSetSystemCall_unixSetSystemCall_enum], sizeof(E.xSetSystemCall_signature)) == 0) {
+ return unixSetSystemCall(args);
+ }


// Transform return E.xShadowName(args) to if-chain with 2 candidates
@transform_return_xShadowName@
expression E;
identifier FP_NAME = xShadowName;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xShadowName_signature, xShadowName_signatures[xShadowName_0_enum], sizeof(E.xShadowName_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xShadowName_signature, xShadowName_signatures[xShadowName_fts3ShadowName_enum], sizeof(E.xShadowName_signature)) == 0) {
+ return fts3ShadowName(args);
+ }
+ else if (memcmp(E.xShadowName_signature, xShadowName_signatures[xShadowName_rtreeShadowName_enum], sizeof(E.xShadowName_signature)) == 0) {
+ return rtreeShadowName(args);
+ }


// Transform return E.xShmBarrier(args) to if-chain with 3 candidates
@transform_return_xShmBarrier@
expression E;
identifier FP_NAME = xShmBarrier;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xShmBarrier_signature, xShmBarrier_signatures[xShmBarrier_0_enum], sizeof(E.xShmBarrier_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xShmBarrier_signature, xShmBarrier_signatures[xShmBarrier_apndShmBarrier_enum], sizeof(E.xShmBarrier_signature)) == 0) {
+ return apndShmBarrier(args);
+ }
+ else if (memcmp(E.xShmBarrier_signature, xShmBarrier_signatures[xShmBarrier_recoverVfsShmBarrier_enum], sizeof(E.xShmBarrier_signature)) == 0) {
+ return recoverVfsShmBarrier(args);
+ }
+ else if (memcmp(E.xShmBarrier_signature, xShmBarrier_signatures[xShmBarrier_unixShmBarrier_enum], sizeof(E.xShmBarrier_signature)) == 0) {
+ return unixShmBarrier(args);
+ }


// Transform return E.xShmLock(args) to if-chain with 3 candidates
@transform_return_xShmLock@
expression E;
identifier FP_NAME = xShmLock;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xShmLock_signature, xShmLock_signatures[xShmLock_0_enum], sizeof(E.xShmLock_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xShmLock_signature, xShmLock_signatures[xShmLock_apndShmLock_enum], sizeof(E.xShmLock_signature)) == 0) {
+ return apndShmLock(args);
+ }
+ else if (memcmp(E.xShmLock_signature, xShmLock_signatures[xShmLock_recoverVfsShmLock_enum], sizeof(E.xShmLock_signature)) == 0) {
+ return recoverVfsShmLock(args);
+ }
+ else if (memcmp(E.xShmLock_signature, xShmLock_signatures[xShmLock_unixShmLock_enum], sizeof(E.xShmLock_signature)) == 0) {
+ return unixShmLock(args);
+ }


// Transform return E.xShmMap(args) to if-chain with 3 candidates
@transform_return_xShmMap@
expression E;
identifier FP_NAME = xShmMap;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xShmMap_signature, xShmMap_signatures[xShmMap_0_enum], sizeof(E.xShmMap_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xShmMap_signature, xShmMap_signatures[xShmMap_apndShmMap_enum], sizeof(E.xShmMap_signature)) == 0) {
+ return apndShmMap(args);
+ }
+ else if (memcmp(E.xShmMap_signature, xShmMap_signatures[xShmMap_recoverVfsShmMap_enum], sizeof(E.xShmMap_signature)) == 0) {
+ return recoverVfsShmMap(args);
+ }
+ else if (memcmp(E.xShmMap_signature, xShmMap_signatures[xShmMap_unixShmMap_enum], sizeof(E.xShmMap_signature)) == 0) {
+ return unixShmMap(args);
+ }


// Transform return E.xShmUnmap(args) to if-chain with 3 candidates
@transform_return_xShmUnmap@
expression E;
identifier FP_NAME = xShmUnmap;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xShmUnmap_signature, xShmUnmap_signatures[xShmUnmap_0_enum], sizeof(E.xShmUnmap_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xShmUnmap_signature, xShmUnmap_signatures[xShmUnmap_apndShmUnmap_enum], sizeof(E.xShmUnmap_signature)) == 0) {
+ return apndShmUnmap(args);
+ }
+ else if (memcmp(E.xShmUnmap_signature, xShmUnmap_signatures[xShmUnmap_recoverVfsShmUnmap_enum], sizeof(E.xShmUnmap_signature)) == 0) {
+ return recoverVfsShmUnmap(args);
+ }
+ else if (memcmp(E.xShmUnmap_signature, xShmUnmap_signatures[xShmUnmap_unixShmUnmap_enum], sizeof(E.xShmUnmap_signature)) == 0) {
+ return unixShmUnmap(args);
+ }


// Transform return E.xShrink(args) to if-chain with 2 candidates
@transform_return_xShrink@
expression E;
identifier FP_NAME = xShrink;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xShrink_signature, xShrink_signatures[xShrink_pcache1Shrink_enum], sizeof(E.xShrink_signature)) == 0) {
+ return pcache1Shrink(args);
+ }
+ else if (memcmp(E.xShrink_signature, xShrink_signatures[xShrink_pcachetraceShrink_enum], sizeof(E.xShrink_signature)) == 0) {
+ return pcachetraceShrink(args);
+ }


// Transform return E.xShutdown(args) to if-chain with 4 candidates
@transform_return_xShutdown@
expression E;
identifier FP_NAME = xShutdown;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xShutdown_signature, xShutdown_signatures[xShutdown_memtraceShutdown_enum], sizeof(E.xShutdown_signature)) == 0) {
+ return memtraceShutdown(args);
+ }
+ else if (memcmp(E.xShutdown_signature, xShutdown_signatures[xShutdown_pcache1Shutdown_enum], sizeof(E.xShutdown_signature)) == 0) {
+ return pcache1Shutdown(args);
+ }
+ else if (memcmp(E.xShutdown_signature, xShutdown_signatures[xShutdown_pcachetraceShutdown_enum], sizeof(E.xShutdown_signature)) == 0) {
+ return pcachetraceShutdown(args);
+ }
+ else if (memcmp(E.xShutdown_signature, xShutdown_signatures[xShutdown_sqlite3MemShutdown_enum], sizeof(E.xShutdown_signature)) == 0) {
+ return sqlite3MemShutdown(args);
+ }


// Transform return E.xSize(args) to if-chain with 2 candidates
@transform_return_xSize@
expression E;
identifier FP_NAME = xSize;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xSize_signature, xSize_signatures[xSize_memtraceSize_enum], sizeof(E.xSize_signature)) == 0) {
+ return memtraceSize(args);
+ }
+ else if (memcmp(E.xSize_signature, xSize_signatures[xSize_sqlite3MemSize_enum], sizeof(E.xSize_signature)) == 0) {
+ return sqlite3MemSize(args);
+ }


// Transform return E.xSleep(args) to if-chain with 4 candidates
@transform_return_xSleep@
expression E;
identifier FP_NAME = xSleep;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xSleep_signature, xSleep_signatures[xSleep_0_enum], sizeof(E.xSleep_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xSleep_signature, xSleep_signatures[xSleep_apndSleep_enum], sizeof(E.xSleep_signature)) == 0) {
+ return apndSleep(args);
+ }
+ else if (memcmp(E.xSleep_signature, xSleep_signatures[xSleep_memdbSleep_enum], sizeof(E.xSleep_signature)) == 0) {
+ return memdbSleep(args);
+ }
+ else if (memcmp(E.xSleep_signature, xSleep_signatures[xSleep_vfstraceSleep_enum], sizeof(E.xSleep_signature)) == 0) {
+ return vfstraceSleep(args);
+ }
+ else if (memcmp(E.xSleep_signature, xSleep_signatures[xSleep_unixSleep_enum], sizeof(E.xSleep_signature)) == 0) {
+ return unixSleep(args);
+ }


// Transform return E.xSync(args) to if-chain with 11 candidates
@transform_return_xSync@
expression E;
identifier FP_NAME = xSync;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xSync_signature, xSync_signatures[xSync_0_enum], sizeof(E.xSync_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xSync_signature, xSync_signatures[xSync_apndSync_enum], sizeof(E.xSync_signature)) == 0) {
+ return apndSync(args);
+ }
+ else if (memcmp(E.xSync_signature, xSync_signatures[xSync_dbpageSync_enum], sizeof(E.xSync_signature)) == 0) {
+ return dbpageSync(args);
+ }
+ else if (memcmp(E.xSync_signature, xSync_signatures[xSync_echoSync_enum], sizeof(E.xSync_signature)) == 0) {
+ return echoSync(args);
+ }
+ else if (memcmp(E.xSync_signature, xSync_signatures[xSync_fts3SyncMethod_enum], sizeof(E.xSync_signature)) == 0) {
+ return fts3SyncMethod(args);
+ }
+ else if (memcmp(E.xSync_signature, xSync_signatures[xSync_memdbSync_enum], sizeof(E.xSync_signature)) == 0) {
+ return memdbSync(args);
+ }
+ else if (memcmp(E.xSync_signature, xSync_signatures[xSync_memjrnlSync_enum], sizeof(E.xSync_signature)) == 0) {
+ return memjrnlSync(args);
+ }
+ else if (memcmp(E.xSync_signature, xSync_signatures[xSync_recoverVfsSync_enum], sizeof(E.xSync_signature)) == 0) {
+ return recoverVfsSync(args);
+ }
+ else if (memcmp(E.xSync_signature, xSync_signatures[xSync_rtreeEndTransaction_enum], sizeof(E.xSync_signature)) == 0) {
+ return rtreeEndTransaction(args);
+ }
+ else if (memcmp(E.xSync_signature, xSync_signatures[xSync_vfstraceSync_enum], sizeof(E.xSync_signature)) == 0) {
+ return vfstraceSync(args);
+ }
+ else if (memcmp(E.xSync_signature, xSync_signatures[xSync_vtablogSync_enum], sizeof(E.xSync_signature)) == 0) {
+ return vtablogSync(args);
+ }
+ else if (memcmp(E.xSync_signature, xSync_signatures[xSync_unixSync_enum], sizeof(E.xSync_signature)) == 0) {
+ return unixSync(args);
+ }


// Transform return E.xTokenize(args) to if-chain with 3 candidates
@transform_return_xTokenize@
expression E;
identifier FP_NAME = xTokenize;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xTokenize_signature, xTokenize_signatures[xTokenize_0_enum], sizeof(E.xTokenize_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xTokenize_signature, xTokenize_signatures[xTokenize_f5tOrigintextTokenize_enum], sizeof(E.xTokenize_signature)) == 0) {
+ return f5tOrigintextTokenize(args);
+ }
+ else if (memcmp(E.xTokenize_signature, xTokenize_signatures[xTokenize_f5tTokenizerTokenize_enum], sizeof(E.xTokenize_signature)) == 0) {
+ return f5tTokenizerTokenize(args);
+ }
+ else if (memcmp(E.xTokenize_signature, xTokenize_signatures[xTokenize_f5tTokenizerTokenize_v2_enum], sizeof(E.xTokenize_signature)) == 0) {
+ return f5tTokenizerTokenize_v2(args);
+ }


// Transform return E.xTruncate(args) to if-chain with 8 candidates
@transform_return_xTruncate@
expression E;
identifier FP_NAME = xTruncate;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xTruncate_signature, xTruncate_signatures[xTruncate_apndTruncate_enum], sizeof(E.xTruncate_signature)) == 0) {
+ return apndTruncate(args);
+ }
+ else if (memcmp(E.xTruncate_signature, xTruncate_signatures[xTruncate_memdbTruncate_enum], sizeof(E.xTruncate_signature)) == 0) {
+ return memdbTruncate(args);
+ }
+ else if (memcmp(E.xTruncate_signature, xTruncate_signatures[xTruncate_memjrnlTruncate_enum], sizeof(E.xTruncate_signature)) == 0) {
+ return memjrnlTruncate(args);
+ }
+ else if (memcmp(E.xTruncate_signature, xTruncate_signatures[xTruncate_pcache1Truncate_enum], sizeof(E.xTruncate_signature)) == 0) {
+ return pcache1Truncate(args);
+ }
+ else if (memcmp(E.xTruncate_signature, xTruncate_signatures[xTruncate_pcachetraceTruncate_enum], sizeof(E.xTruncate_signature)) == 0) {
+ return pcachetraceTruncate(args);
+ }
+ else if (memcmp(E.xTruncate_signature, xTruncate_signatures[xTruncate_recoverVfsTruncate_enum], sizeof(E.xTruncate_signature)) == 0) {
+ return recoverVfsTruncate(args);
+ }
+ else if (memcmp(E.xTruncate_signature, xTruncate_signatures[xTruncate_vfstraceTruncate_enum], sizeof(E.xTruncate_signature)) == 0) {
+ return vfstraceTruncate(args);
+ }
+ else if (memcmp(E.xTruncate_signature, xTruncate_signatures[xTruncate_unixTruncate_enum], sizeof(E.xTruncate_signature)) == 0) {
+ return unixTruncate(args);
+ }


// Transform return E.xUnfetch(args) to if-chain with 4 candidates
@transform_return_xUnfetch@
expression E;
identifier FP_NAME = xUnfetch;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xUnfetch_signature, xUnfetch_signatures[xUnfetch_0_enum], sizeof(E.xUnfetch_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xUnfetch_signature, xUnfetch_signatures[xUnfetch_apndUnfetch_enum], sizeof(E.xUnfetch_signature)) == 0) {
+ return apndUnfetch(args);
+ }
+ else if (memcmp(E.xUnfetch_signature, xUnfetch_signatures[xUnfetch_memdbUnfetch_enum], sizeof(E.xUnfetch_signature)) == 0) {
+ return memdbUnfetch(args);
+ }
+ else if (memcmp(E.xUnfetch_signature, xUnfetch_signatures[xUnfetch_recoverVfsUnfetch_enum], sizeof(E.xUnfetch_signature)) == 0) {
+ return recoverVfsUnfetch(args);
+ }
+ else if (memcmp(E.xUnfetch_signature, xUnfetch_signatures[xUnfetch_unixUnfetch_enum], sizeof(E.xUnfetch_signature)) == 0) {
+ return unixUnfetch(args);
+ }


// Transform return E.xUnlock(args) to if-chain with 7 candidates
@transform_return_xUnlock@
expression E;
identifier FP_NAME = xUnlock;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xUnlock_signature, xUnlock_signatures[xUnlock_0_enum], sizeof(E.xUnlock_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xUnlock_signature, xUnlock_signatures[xUnlock_apndUnlock_enum], sizeof(E.xUnlock_signature)) == 0) {
+ return apndUnlock(args);
+ }
+ else if (memcmp(E.xUnlock_signature, xUnlock_signatures[xUnlock_memdbUnlock_enum], sizeof(E.xUnlock_signature)) == 0) {
+ return memdbUnlock(args);
+ }
+ else if (memcmp(E.xUnlock_signature, xUnlock_signatures[xUnlock_recoverVfsUnlock_enum], sizeof(E.xUnlock_signature)) == 0) {
+ return recoverVfsUnlock(args);
+ }
+ else if (memcmp(E.xUnlock_signature, xUnlock_signatures[xUnlock_vfstraceUnlock_enum], sizeof(E.xUnlock_signature)) == 0) {
+ return vfstraceUnlock(args);
+ }
+ else if (memcmp(E.xUnlock_signature, xUnlock_signatures[xUnlock_unixUnlock_enum], sizeof(E.xUnlock_signature)) == 0) {
+ return unixUnlock(args);
+ }
+ else if (memcmp(E.xUnlock_signature, xUnlock_signatures[xUnlock_nolockUnlock_enum], sizeof(E.xUnlock_signature)) == 0) {
+ return nolockUnlock(args);
+ }
+ else if (memcmp(E.xUnlock_signature, xUnlock_signatures[xUnlock_dotlockUnlock_enum], sizeof(E.xUnlock_signature)) == 0) {
+ return dotlockUnlock(args);
+ }


// Transform return E.xUnpin(args) to if-chain with 2 candidates
@transform_return_xUnpin@
expression E;
identifier FP_NAME = xUnpin;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xUnpin_signature, xUnpin_signatures[xUnpin_pcache1Unpin_enum], sizeof(E.xUnpin_signature)) == 0) {
+ return pcache1Unpin(args);
+ }
+ else if (memcmp(E.xUnpin_signature, xUnpin_signatures[xUnpin_pcachetraceUnpin_enum], sizeof(E.xUnpin_signature)) == 0) {
+ return pcachetraceUnpin(args);
+ }


// Transform return E.xUpdate(args) to if-chain with 13 candidates
@transform_return_xUpdate@
expression E;
identifier FP_NAME = xUpdate;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xUpdate_signature, xUpdate_signatures[xUpdate_0_enum], sizeof(E.xUpdate_signature)) == 0) {
+ return 0;
+ }
+ else if (memcmp(E.xUpdate_signature, xUpdate_signatures[xUpdate_amatchUpdate_enum], sizeof(E.xUpdate_signature)) == 0) {
+ return amatchUpdate(args);
+ }
+ else if (memcmp(E.xUpdate_signature, xUpdate_signatures[xUpdate_csvtabUpdate_enum], sizeof(E.xUpdate_signature)) == 0) {
+ return csvtabUpdate(args);
+ }
+ else if (memcmp(E.xUpdate_signature, xUpdate_signatures[xUpdate_dbpageUpdate_enum], sizeof(E.xUpdate_signature)) == 0) {
+ return dbpageUpdate(args);
+ }
+ else if (memcmp(E.xUpdate_signature, xUpdate_signatures[xUpdate_echoUpdate_enum], sizeof(E.xUpdate_signature)) == 0) {
+ return echoUpdate(args);
+ }
+ else if (memcmp(E.xUpdate_signature, xUpdate_signatures[xUpdate_expertUpdate_enum], sizeof(E.xUpdate_signature)) == 0) {
+ return expertUpdate(args);
+ }
+ else if (memcmp(E.xUpdate_signature, xUpdate_signatures[xUpdate_fts3UpdateMethod_enum], sizeof(E.xUpdate_signature)) == 0) {
+ return fts3UpdateMethod(args);
+ }
+ else if (memcmp(E.xUpdate_signature, xUpdate_signatures[xUpdate_geopolyUpdate_enum], sizeof(E.xUpdate_signature)) == 0) {
+ return geopolyUpdate(args);
+ }
+ else if (memcmp(E.xUpdate_signature, xUpdate_signatures[xUpdate_rtreeUpdate_enum], sizeof(E.xUpdate_signature)) == 0) {
+ return rtreeUpdate(args);
+ }
+ else if (memcmp(E.xUpdate_signature, xUpdate_signatures[xUpdate_spellfix1Update_enum], sizeof(E.xUpdate_signature)) == 0) {
+ return spellfix1Update(args);
+ }
+ else if (memcmp(E.xUpdate_signature, xUpdate_signatures[xUpdate_tclvarUpdate_enum], sizeof(E.xUpdate_signature)) == 0) {
+ return tclvarUpdate(args);
+ }
+ else if (memcmp(E.xUpdate_signature, xUpdate_signatures[xUpdate_vstattabUpdate_enum], sizeof(E.xUpdate_signature)) == 0) {
+ return vstattabUpdate(args);
+ }
+ else if (memcmp(E.xUpdate_signature, xUpdate_signatures[xUpdate_vtablogUpdate_enum], sizeof(E.xUpdate_signature)) == 0) {
+ return vtablogUpdate(args);
+ }
+ else if (memcmp(E.xUpdate_signature, xUpdate_signatures[xUpdate_zipfileUpdate_enum], sizeof(E.xUpdate_signature)) == 0) {
+ return zipfileUpdate(args);
+ }


// Transform return E.xWrite(args) to if-chain with 7 candidates
@transform_return_xWrite@
expression E;
identifier FP_NAME = xWrite;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xWrite_signature, xWrite_signatures[xWrite_apndWrite_enum], sizeof(E.xWrite_signature)) == 0) {
+ return apndWrite(args);
+ }
+ else if (memcmp(E.xWrite_signature, xWrite_signatures[xWrite_kvstorageWrite_enum], sizeof(E.xWrite_signature)) == 0) {
+ return kvstorageWrite(args);
+ }
+ else if (memcmp(E.xWrite_signature, xWrite_signatures[xWrite_memdbWrite_enum], sizeof(E.xWrite_signature)) == 0) {
+ return memdbWrite(args);
+ }
+ else if (memcmp(E.xWrite_signature, xWrite_signatures[xWrite_memjrnlWrite_enum], sizeof(E.xWrite_signature)) == 0) {
+ return memjrnlWrite(args);
+ }
+ else if (memcmp(E.xWrite_signature, xWrite_signatures[xWrite_recoverVfsWrite_enum], sizeof(E.xWrite_signature)) == 0) {
+ return recoverVfsWrite(args);
+ }
+ else if (memcmp(E.xWrite_signature, xWrite_signatures[xWrite_vfstraceWrite_enum], sizeof(E.xWrite_signature)) == 0) {
+ return vfstraceWrite(args);
+ }
+ else if (memcmp(E.xWrite_signature, xWrite_signatures[xWrite_unixWrite_enum], sizeof(E.xWrite_signature)) == 0) {
+ return unixWrite(args);
+ }


// Transform return E.xsnprintf(args) to if-chain with 1 candidates
@transform_return_xsnprintf@
expression E;
identifier FP_NAME = xsnprintf;
expression list args;
@@
- return E.FP_NAME(args);
+ if (memcmp(E.xsnprintf_signature, xsnprintf_signatures[xsnprintf_sqlite3_set_authorizer_enum], sizeof(E.xsnprintf_signature)) == 0) {
+ return sqlite3_set_authorizer(args);
+ }

// Total return transformation rules generated: 321
// ===== NO RETURN FUNCTION POINTER TRANSFORMATION RULES (ARROW) =====

// Transform E->aggregate_context(args) to direct call (only 1 candidate)
@transform_no_return_aggregate_context_arrow@
expression E;
identifier FP_NAME = aggregate_context;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_aggregate_context(args);


// Transform E->auto_extension(args) to direct call (only 1 candidate)
@transform_no_return_auto_extension_arrow@
expression E;
identifier FP_NAME = auto_extension;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_vtab_config(args);


// Transform E->backup_finish(args) to direct call (only 1 candidate)
@transform_no_return_backup_finish_arrow@
expression E;
identifier FP_NAME = backup_finish;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_result_error_code(args);


// Transform E->backup_init(args) to direct call (only 1 candidate)
@transform_no_return_backup_init_arrow@
expression E;
identifier FP_NAME = backup_init;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_test_control(args);


// Transform E->backup_pagecount(args) to direct call (only 1 candidate)
@transform_no_return_backup_pagecount_arrow@
expression E;
identifier FP_NAME = backup_pagecount;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_randomness(args);


// Transform E->backup_remaining(args) to direct call (only 1 candidate)
@transform_no_return_backup_remaining_arrow@
expression E;
identifier FP_NAME = backup_remaining;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_context_db_handle(args);


// Transform E->backup_step(args) to direct call (only 1 candidate)
@transform_no_return_backup_step_arrow@
expression E;
identifier FP_NAME = backup_step;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_extended_result_codes(args);


// Transform E->bind_blob64(args) to direct call (only 1 candidate)
@transform_no_return_bind_blob64_arrow@
expression E;
identifier FP_NAME = bind_blob64;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_vtab_on_conflict(args);


// Transform E->bind_int(args) to direct call (only 1 candidate)
@transform_no_return_bind_int_arrow@
expression E;
identifier FP_NAME = bind_int;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_bind_double(args);


// Transform E->bind_int64(args) to direct call (only 1 candidate)
@transform_no_return_bind_int64_arrow@
expression E;
identifier FP_NAME = bind_int64;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_bind_int(args);


// Transform E->bind_null(args) to direct call (only 1 candidate)
@transform_no_return_bind_null_arrow@
expression E;
identifier FP_NAME = bind_null;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_bind_int64(args);


// Transform E->bind_parameter_count(args) to direct call (only 1 candidate)
@transform_no_return_bind_parameter_count_arrow@
expression E;
identifier FP_NAME = bind_parameter_count;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_bind_null(args);


// Transform E->bind_parameter_index(args) to direct call (only 1 candidate)
@transform_no_return_bind_parameter_index_arrow@
expression E;
identifier FP_NAME = bind_parameter_index;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_bind_parameter_count(args);


// Transform E->bind_parameter_name(args) to direct call (only 1 candidate)
@transform_no_return_bind_parameter_name_arrow@
expression E;
identifier FP_NAME = bind_parameter_name;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_bind_parameter_index(args);


// Transform E->bind_text(args) to direct call (only 1 candidate)
@transform_no_return_bind_text_arrow@
expression E;
identifier FP_NAME = bind_text;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_bind_parameter_name(args);


// Transform E->bind_text16(args) to direct call (only 1 candidate)
@transform_no_return_bind_text16_arrow@
expression E;
identifier FP_NAME = bind_text16;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_bind_text(args);


// Transform E->bind_text64(args) to direct call (only 1 candidate)
@transform_no_return_bind_text64_arrow@
expression E;
identifier FP_NAME = bind_text64;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_close_v2(args);


// Transform E->bind_value(args) to direct call (only 1 candidate)
@transform_no_return_bind_value_arrow@
expression E;
identifier FP_NAME = bind_value;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_bind_text16(args);


// Transform E->bind_zeroblob(args) to direct call (only 1 candidate)
@transform_no_return_bind_zeroblob_arrow@
expression E;
identifier FP_NAME = bind_zeroblob;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_prepare_v2(args);


// Transform E->bind_zeroblob64(args) to direct call (only 1 candidate)
@transform_no_return_bind_zeroblob64_arrow@
expression E;
identifier FP_NAME = bind_zeroblob64;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_auto_extension(args);


// Transform E->blob_bytes(args) to direct call (only 1 candidate)
@transform_no_return_blob_bytes_arrow@
expression E;
identifier FP_NAME = blob_bytes;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_prepare16_v2(args);


// Transform E->blob_close(args) to direct call (only 1 candidate)
@transform_no_return_blob_close_arrow@
expression E;
identifier FP_NAME = blob_close;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_clear_bindings(args);


// Transform E->blob_open(args) to direct call (only 1 candidate)
@transform_no_return_blob_open_arrow@
expression E;
identifier FP_NAME = blob_open;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_create_module_v2(args);


// Transform E->blob_read(args) to direct call (only 1 candidate)
@transform_no_return_blob_read_arrow@
expression E;
identifier FP_NAME = blob_read;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_bind_zeroblob(args);


// Transform E->blob_reopen(args) to direct call (only 1 candidate)
@transform_no_return_blob_reopen_arrow@
expression E;
identifier FP_NAME = blob_reopen;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_db_status(args);


// Transform E->blob_write(args) to direct call (only 1 candidate)
@transform_no_return_blob_write_arrow@
expression E;
identifier FP_NAME = blob_write;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_blob_bytes(args);


// Transform E->busy_handler(args) to direct call (only 1 candidate)
@transform_no_return_busy_handler_arrow@
expression E;
identifier FP_NAME = busy_handler;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_bind_value(args);


// Transform E->busy_timeout(args) to direct call (only 1 candidate)
@transform_no_return_busy_timeout_arrow@
expression E;
identifier FP_NAME = busy_timeout;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_busy_handler(args);


// Transform E->cancel_auto_extension(args) to direct call (only 1 candidate)
@transform_no_return_cancel_auto_extension_arrow@
expression E;
identifier FP_NAME = cancel_auto_extension;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_db_filename(args);


// Transform E->changes(args) to direct call (only 1 candidate)
@transform_no_return_changes_arrow@
expression E;
identifier FP_NAME = changes;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_busy_timeout(args);


// Transform E->changes64(args) to direct call (only 1 candidate)
@transform_no_return_changes64_arrow@
expression E;
identifier FP_NAME = changes64;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_str_value(args);


// Transform E->clear_bindings(args) to direct call (only 1 candidate)
@transform_no_return_clear_bindings_arrow@
expression E;
identifier FP_NAME = clear_bindings;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_vmprintf(args);


// Transform E->close(args) to direct call (only 1 candidate)
@transform_no_return_close_arrow@
expression E;
identifier FP_NAME = close;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_changes(args);


// Transform E->close_v2(args) to direct call (only 1 candidate)
@transform_no_return_close_v2_arrow@
expression E;
identifier FP_NAME = close_v2;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_soft_heap_limit64(args);


// Transform E->collation_needed(args) to direct call (only 1 candidate)
@transform_no_return_collation_needed_arrow@
expression E;
identifier FP_NAME = collation_needed;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_close(args);


// Transform E->collation_needed16(args) to direct call (only 1 candidate)
@transform_no_return_collation_needed16_arrow@
expression E;
identifier FP_NAME = collation_needed16;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_collation_needed(args);


// Transform E->column_blob(args) to direct call (only 1 candidate)
@transform_no_return_column_blob_arrow@
expression E;
identifier FP_NAME = column_blob;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_collation_needed16(args);


// Transform E->column_bytes(args) to direct call (only 1 candidate)
@transform_no_return_column_bytes_arrow@
expression E;
identifier FP_NAME = column_bytes;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_column_blob(args);


// Transform E->column_bytes16(args) to direct call (only 1 candidate)
@transform_no_return_column_bytes16_arrow@
expression E;
identifier FP_NAME = column_bytes16;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_column_bytes(args);


// Transform E->column_count(args) to direct call (only 1 candidate)
@transform_no_return_column_count_arrow@
expression E;
identifier FP_NAME = column_count;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_column_bytes16(args);


// Transform E->column_database_name(args) to direct call (only 1 candidate)
@transform_no_return_column_database_name_arrow@
expression E;
identifier FP_NAME = column_database_name;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_column_count(args);


// Transform E->column_database_name16(args) to direct call (only 1 candidate)
@transform_no_return_column_database_name16_arrow@
expression E;
identifier FP_NAME = column_database_name16;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_column_database_name(args);


// Transform E->column_decltype(args) to direct call (only 1 candidate)
@transform_no_return_column_decltype_arrow@
expression E;
identifier FP_NAME = column_decltype;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_column_database_name16(args);


// Transform E->column_decltype16(args) to direct call (only 1 candidate)
@transform_no_return_column_decltype16_arrow@
expression E;
identifier FP_NAME = column_decltype16;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_column_decltype(args);


// Transform E->column_double(args) to direct call (only 1 candidate)
@transform_no_return_column_double_arrow@
expression E;
identifier FP_NAME = column_double;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_column_decltype16(args);


// Transform E->column_int(args) to direct call (only 1 candidate)
@transform_no_return_column_int_arrow@
expression E;
identifier FP_NAME = column_int;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_column_double(args);


// Transform E->column_int64(args) to direct call (only 1 candidate)
@transform_no_return_column_int64_arrow@
expression E;
identifier FP_NAME = column_int64;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_column_int(args);


// Transform E->column_name(args) to direct call (only 1 candidate)
@transform_no_return_column_name_arrow@
expression E;
identifier FP_NAME = column_name;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_column_int64(args);


// Transform E->column_name16(args) to direct call (only 1 candidate)
@transform_no_return_column_name16_arrow@
expression E;
identifier FP_NAME = column_name16;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_column_name(args);


// Transform E->column_origin_name(args) to direct call (only 1 candidate)
@transform_no_return_column_origin_name_arrow@
expression E;
identifier FP_NAME = column_origin_name;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_column_name16(args);


// Transform E->column_origin_name16(args) to direct call (only 1 candidate)
@transform_no_return_column_origin_name16_arrow@
expression E;
identifier FP_NAME = column_origin_name16;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_column_origin_name(args);


// Transform E->column_table_name(args) to direct call (only 1 candidate)
@transform_no_return_column_table_name_arrow@
expression E;
identifier FP_NAME = column_table_name;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_column_origin_name16(args);


// Transform E->column_table_name16(args) to direct call (only 1 candidate)
@transform_no_return_column_table_name16_arrow@
expression E;
identifier FP_NAME = column_table_name16;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_column_table_name(args);


// Transform E->column_text(args) to direct call (only 1 candidate)
@transform_no_return_column_text_arrow@
expression E;
identifier FP_NAME = column_text;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_column_table_name16(args);


// Transform E->column_text16(args) to direct call (only 1 candidate)
@transform_no_return_column_text16_arrow@
expression E;
identifier FP_NAME = column_text16;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_column_text(args);


// Transform E->column_type(args) to direct call (only 1 candidate)
@transform_no_return_column_type_arrow@
expression E;
identifier FP_NAME = column_type;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_column_text16(args);


// Transform E->column_value(args) to direct call (only 1 candidate)
@transform_no_return_column_value_arrow@
expression E;
identifier FP_NAME = column_value;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_column_type(args);


// Transform E->commit_hook(args) to direct call (only 1 candidate)
@transform_no_return_commit_hook_arrow@
expression E;
identifier FP_NAME = commit_hook;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_column_value(args);


// Transform E->compileoption_get(args) to direct call (only 1 candidate)
@transform_no_return_compileoption_get_arrow@
expression E;
identifier FP_NAME = compileoption_get;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_limit(args);


// Transform E->compileoption_used(args) to direct call (only 1 candidate)
@transform_no_return_compileoption_used_arrow@
expression E;
identifier FP_NAME = compileoption_used;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_next_stmt(args);


// Transform E->complete(args) to direct call (only 1 candidate)
@transform_no_return_complete_arrow@
expression E;
identifier FP_NAME = complete;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_commit_hook(args);


// Transform E->complete16(args) to direct call (only 1 candidate)
@transform_no_return_complete16_arrow@
expression E;
identifier FP_NAME = complete16;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_complete(args);


// Transform E->context_db_handle(args) to direct call (only 1 candidate)
@transform_no_return_context_db_handle_arrow@
expression E;
identifier FP_NAME = context_db_handle;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_soft_heap_limit(args);


// Transform E->create_collation(args) to direct call (only 1 candidate)
@transform_no_return_create_collation_arrow@
expression E;
identifier FP_NAME = create_collation;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_complete16(args);


// Transform E->create_collation16(args) to direct call (only 1 candidate)
@transform_no_return_create_collation16_arrow@
expression E;
identifier FP_NAME = create_collation16;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_create_collation(args);


// Transform E->create_collation_v2(args) to direct call (only 1 candidate)
@transform_no_return_create_collation_v2_arrow@
expression E;
identifier FP_NAME = create_collation_v2;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_blob_close(args);


// Transform E->create_filename(args) to direct call (only 1 candidate)
@transform_no_return_create_filename_arrow@
expression E;
identifier FP_NAME = create_filename;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_str_appendchar(args);


// Transform E->create_function(args) to direct call (only 1 candidate)
@transform_no_return_create_function_arrow@
expression E;
identifier FP_NAME = create_function;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_create_collation16(args);


// Transform E->create_function16(args) to direct call (only 1 candidate)
@transform_no_return_create_function16_arrow@
expression E;
identifier FP_NAME = create_function16;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_create_function(args);


// Transform E->create_function_v2(args) to direct call (only 1 candidate)
@transform_no_return_create_function_v2_arrow@
expression E;
identifier FP_NAME = create_function_v2;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_sql(args);


// Transform E->create_module(args) to direct call (only 1 candidate)
@transform_no_return_create_module_arrow@
expression E;
identifier FP_NAME = create_module;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_create_function16(args);


// Transform E->create_module_v2(args) to direct call (only 1 candidate)
@transform_no_return_create_module_v2_arrow@
expression E;
identifier FP_NAME = create_module_v2;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_overload_function(args);


// Transform E->create_window_function(args) to direct call (only 1 candidate)
@transform_no_return_create_window_function_arrow@
expression E;
identifier FP_NAME = create_window_function;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_vtab_collation(args);


// Transform E->data_count(args) to direct call (only 1 candidate)
@transform_no_return_data_count_arrow@
expression E;
identifier FP_NAME = data_count;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_create_module(args);


// Transform E->database_file_object(args) to direct call (only 1 candidate)
@transform_no_return_database_file_object_arrow@
expression E;
identifier FP_NAME = database_file_object;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_str_errcode(args);


// Transform E->db_cacheflush(args) to direct call (only 1 candidate)
@transform_no_return_db_cacheflush_arrow@
expression E;
identifier FP_NAME = db_cacheflush;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_malloc64(args);


// Transform E->db_config(args) to direct call (only 1 candidate)
@transform_no_return_db_config_arrow@
expression E;
identifier FP_NAME = db_config;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_status(args);


// Transform E->db_filename(args) to direct call (only 1 candidate)
@transform_no_return_db_filename_arrow@
expression E;
identifier FP_NAME = db_filename;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_sourceid(args);


// Transform E->db_handle(args) to direct call (only 1 candidate)
@transform_no_return_db_handle_arrow@
expression E;
identifier FP_NAME = db_handle;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_data_count(args);


// Transform E->db_mutex(args) to direct call (only 1 candidate)
@transform_no_return_db_mutex_arrow@
expression E;
identifier FP_NAME = db_mutex;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_backup_finish(args);


// Transform E->db_name(args) to direct call (only 1 candidate)
@transform_no_return_db_name_arrow@
expression E;
identifier FP_NAME = db_name;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_filename_journal(args);


// Transform E->db_readonly(args) to direct call (only 1 candidate)
@transform_no_return_db_readonly_arrow@
expression E;
identifier FP_NAME = db_readonly;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_stmt_status(args);


// Transform E->db_release_memory(args) to direct call (only 1 candidate)
@transform_no_return_db_release_memory_arrow@
expression E;
identifier FP_NAME = db_release_memory;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_strnicmp(args);


// Transform E->db_status(args) to direct call (only 1 candidate)
@transform_no_return_db_status_arrow@
expression E;
identifier FP_NAME = db_status;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_backup_init(args);


// Transform E->declare_vtab(args) to direct call (only 1 candidate)
@transform_no_return_declare_vtab_arrow@
expression E;
identifier FP_NAME = declare_vtab;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_db_handle(args);


// Transform E->deserialize(args) to direct call (only 1 candidate)
@transform_no_return_deserialize_arrow@
expression E;
identifier FP_NAME = deserialize;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_uri_key(args);


// Transform E->drop_modules(args) to direct call (only 1 candidate)
@transform_no_return_drop_modules_arrow@
expression E;
identifier FP_NAME = drop_modules;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_str_new(args);


// Transform E->enable_shared_cache(args) to direct call (only 1 candidate)
@transform_no_return_enable_shared_cache_arrow@
expression E;
identifier FP_NAME = enable_shared_cache;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_declare_vtab(args);


// Transform E->errcode(args) to direct call (only 1 candidate)
@transform_no_return_errcode_arrow@
expression E;
identifier FP_NAME = errcode;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_enable_shared_cache(args);


// Transform E->errmsg(args) to direct call (only 1 candidate)
@transform_no_return_errmsg_arrow@
expression E;
identifier FP_NAME = errmsg;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_errcode(args);


// Transform E->errmsg16(args) to direct call (only 1 candidate)
@transform_no_return_errmsg16_arrow@
expression E;
identifier FP_NAME = errmsg16;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_errmsg(args);


// Transform E->exec(args) to direct call (only 1 candidate)
@transform_no_return_exec_arrow@
expression E;
identifier FP_NAME = exec;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_errmsg16(args);


// Transform E->expanded_sql(args) to direct call (only 1 candidate)
@transform_no_return_expanded_sql_arrow@
expression E;
identifier FP_NAME = expanded_sql;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_reset_auto_extension(args);


// Transform E->expired(args) to direct call (only 1 candidate)
@transform_no_return_expired_arrow@
expression E;
identifier FP_NAME = expired;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_exec(args);


// Transform E->extended_errcode(args) to direct call (only 1 candidate)
@transform_no_return_extended_errcode_arrow@
expression E;
identifier FP_NAME = extended_errcode;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_backup_pagecount(args);


// Transform E->extended_result_codes(args) to direct call (only 1 candidate)
@transform_no_return_extended_result_codes_arrow@
expression E;
identifier FP_NAME = extended_result_codes;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_vfs_find(args);


// Transform E->file_control(args) to direct call (only 1 candidate)
@transform_no_return_file_control_arrow@
expression E;
identifier FP_NAME = file_control;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_blob_open(args);


// Transform E->filename_database(args) to direct call (only 1 candidate)
@transform_no_return_filename_database_arrow@
expression E;
identifier FP_NAME = filename_database;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_str_vappendf(args);


// Transform E->filename_journal(args) to direct call (only 1 candidate)
@transform_no_return_filename_journal_arrow@
expression E;
identifier FP_NAME = filename_journal;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_str_append(args);


// Transform E->filename_wal(args) to direct call (only 1 candidate)
@transform_no_return_filename_wal_arrow@
expression E;
identifier FP_NAME = filename_wal;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_str_appendall(args);


// Transform E->free_filename(args) to direct call (only 1 candidate)
@transform_no_return_free_filename_arrow@
expression E;
identifier FP_NAME = free_filename;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_str_reset(args);


// Transform E->get_autocommit(args) to direct call (only 1 candidate)
@transform_no_return_get_autocommit_arrow@
expression E;
identifier FP_NAME = get_autocommit;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_free(args);


// Transform E->get_auxdata(args) to direct call (only 1 candidate)
@transform_no_return_get_auxdata_arrow@
expression E;
identifier FP_NAME = get_auxdata;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_free_table(args);


// Transform E->get_clientdata(args) to direct call (only 1 candidate)
@transform_no_return_get_clientdata_arrow@
expression E;
identifier FP_NAME = get_clientdata;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_database_file_object(args);


// Transform E->get_table(args) to direct call (only 1 candidate)
@transform_no_return_get_table_arrow@
expression E;
identifier FP_NAME = get_table;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_get_autocommit(args);


// Transform E->global_recover(args) to direct call (only 1 candidate)
@transform_no_return_global_recover_arrow@
expression E;
identifier FP_NAME = global_recover;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_get_auxdata(args);


// Transform E->hard_heap_limit64(args) to direct call (only 1 candidate)
@transform_no_return_hard_heap_limit64_arrow@
expression E;
identifier FP_NAME = hard_heap_limit64;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_str_finish(args);


// Transform E->interruptx(args) to direct call (only 1 candidate)
@transform_no_return_interruptx_arrow@
expression E;
identifier FP_NAME = interruptx;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_get_table(args);


// Transform E->is_interrupted(args) to direct call (only 1 candidate)
@transform_no_return_is_interrupted_arrow@
expression E;
identifier FP_NAME = is_interrupted;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_create_filename(args);


// Transform E->keyword_check(args) to direct call (only 1 candidate)
@transform_no_return_keyword_check_arrow@
expression E;
identifier FP_NAME = keyword_check;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_db_cacheflush(args);


// Transform E->keyword_count(args) to direct call (only 1 candidate)
@transform_no_return_keyword_count_arrow@
expression E;
identifier FP_NAME = keyword_count;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_status64(args);


// Transform E->keyword_name(args) to direct call (only 1 candidate)
@transform_no_return_keyword_name_arrow@
expression E;
identifier FP_NAME = keyword_name;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_strlike(args);


// Transform E->libversion(args) to direct call (only 1 candidate)
@transform_no_return_libversion_arrow@
expression E;
identifier FP_NAME = libversion;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_interrupt(args);


// Transform E->libversion_number(args) to direct call (only 1 candidate)
@transform_no_return_libversion_number_arrow@
expression E;
identifier FP_NAME = libversion_number;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_last_insert_rowid(args);


// Transform E->limit(args) to direct call (only 1 candidate)
@transform_no_return_limit_arrow@
expression E;
identifier FP_NAME = limit;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_vfs_register(args);


// Transform E->load_extension(args) to direct call (only 1 candidate)
@transform_no_return_load_extension_arrow@
expression E;
identifier FP_NAME = load_extension;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_db_readonly(args);


// Transform E->log(args) to direct call (only 1 candidate)
@transform_no_return_log_arrow@
expression E;
identifier FP_NAME = log;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_backup_remaining(args);


// Transform E->malloc(args) to direct call (only 1 candidate)
@transform_no_return_malloc_arrow@
expression E;
identifier FP_NAME = malloc;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_libversion(args);


// Transform E->malloc64(args) to direct call (only 1 candidate)
@transform_no_return_malloc64_arrow@
expression E;
identifier FP_NAME = malloc64;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_db_release_memory(args);


// Transform E->memory_highwater(args) to direct call (only 1 candidate)
@transform_no_return_memory_highwater_arrow@
expression E;
identifier FP_NAME = memory_highwater;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_blob_read(args);


// Transform E->memory_used(args) to direct call (only 1 candidate)
@transform_no_return_memory_used_arrow@
expression E;
identifier FP_NAME = memory_used;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_blob_write(args);


// Transform E->mprintf(args) to direct call (only 1 candidate)
@transform_no_return_mprintf_arrow@
expression E;
identifier FP_NAME = mprintf;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_libversion_number(args);


// Transform E->msize(args) to direct call (only 1 candidate)
@transform_no_return_msize_arrow@
expression E;
identifier FP_NAME = msize;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_errstr(args);


// Transform E->mutex_alloc(args) to direct call (only 1 candidate)
@transform_no_return_mutex_alloc_arrow@
expression E;
identifier FP_NAME = mutex_alloc;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_create_collation_v2(args);


// Transform E->mutex_enter(args) to direct call (only 1 candidate)
@transform_no_return_mutex_enter_arrow@
expression E;
identifier FP_NAME = mutex_enter;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_file_control(args);


// Transform E->mutex_free(args) to direct call (only 1 candidate)
@transform_no_return_mutex_free_arrow@
expression E;
identifier FP_NAME = mutex_free;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_memory_highwater(args);


// Transform E->mutex_leave(args) to direct call (only 1 candidate)
@transform_no_return_mutex_leave_arrow@
expression E;
identifier FP_NAME = mutex_leave;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_memory_used(args);


// Transform E->next_stmt(args) to direct call (only 1 candidate)
@transform_no_return_next_stmt_arrow@
expression E;
identifier FP_NAME = next_stmt;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_vfs_unregister(args);


// Transform E->normalized_sql(args) to direct call (only 1 candidate)
@transform_no_return_normalized_sql_arrow@
expression E;
identifier FP_NAME = normalized_sql;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_keyword_count(args);


// Transform E->open(args) to direct call (only 1 candidate)
@transform_no_return_open_arrow@
expression E;
identifier FP_NAME = open;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_malloc(args);


// Transform E->open16(args) to direct call (only 1 candidate)
@transform_no_return_open16_arrow@
expression E;
identifier FP_NAME = open16;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_mprintf(args);


// Transform E->overload_function(args) to direct call (only 1 candidate)
@transform_no_return_overload_function_arrow@
expression E;
identifier FP_NAME = overload_function;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_value_text16be(args);


// Transform E->prepare(args) to direct call (only 1 candidate)
@transform_no_return_prepare_arrow@
expression E;
identifier FP_NAME = prepare;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_open(args);


// Transform E->prepare16(args) to direct call (only 1 candidate)
@transform_no_return_prepare16_arrow@
expression E;
identifier FP_NAME = prepare16;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_open16(args);


// Transform E->prepare16_v2(args) to direct call (only 1 candidate)
@transform_no_return_prepare16_v2_arrow@
expression E;
identifier FP_NAME = prepare16_v2;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_value_type(args);


// Transform E->prepare16_v3(args) to direct call (only 1 candidate)
@transform_no_return_prepare16_v3_arrow@
expression E;
identifier FP_NAME = prepare16_v3;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_strglob(args);


// Transform E->prepare_v2(args) to direct call (only 1 candidate)
@transform_no_return_prepare_v2_arrow@
expression E;
identifier FP_NAME = prepare_v2;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_value_text16le(args);


// Transform E->prepare_v3(args) to direct call (only 1 candidate)
@transform_no_return_prepare_v3_arrow@
expression E;
identifier FP_NAME = prepare_v3;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_result_text64(args);


// Transform E->profile(args) to direct call (only 1 candidate)
@transform_no_return_profile_arrow@
expression E;
identifier FP_NAME = profile;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_prepare(args);


// Transform E->progress_handler(args) to direct call (only 1 candidate)
@transform_no_return_progress_handler_arrow@
expression E;
identifier FP_NAME = progress_handler;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_prepare16(args);


// Transform E->randomness(args) to direct call (only 1 candidate)
@transform_no_return_randomness_arrow@
expression E;
identifier FP_NAME = randomness;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_sleep(args);


// Transform E->realloc(args) to direct call (only 1 candidate)
@transform_no_return_realloc_arrow@
expression E;
identifier FP_NAME = realloc;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_profile(args);


// Transform E->realloc64(args) to direct call (only 1 candidate)
@transform_no_return_realloc64_arrow@
expression E;
identifier FP_NAME = realloc64;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_stmt_busy(args);


// Transform E->reset(args) to direct call (only 1 candidate)
@transform_no_return_reset_arrow@
expression E;
identifier FP_NAME = reset;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_progress_handler(args);


// Transform E->reset_auto_extension(args) to direct call (only 1 candidate)
@transform_no_return_reset_auto_extension_arrow@
expression E;
identifier FP_NAME = reset_auto_extension;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_stmt_readonly(args);


// Transform E->result_blob(args) to direct call (only 1 candidate)
@transform_no_return_result_blob_arrow@
expression E;
identifier FP_NAME = result_blob;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_realloc(args);


// Transform E->result_blob64(args) to direct call (only 1 candidate)
@transform_no_return_result_blob64_arrow@
expression E;
identifier FP_NAME = result_blob64;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_stricmp(args);


// Transform E->result_double(args) to direct call (only 1 candidate)
@transform_no_return_result_double_arrow@
expression E;
identifier FP_NAME = result_double;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_reset(args);


// Transform E->result_error(args) to direct call (only 1 candidate)
@transform_no_return_result_error_arrow@
expression E;
identifier FP_NAME = result_error;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_result_blob(args);


// Transform E->result_error16(args) to direct call (only 1 candidate)
@transform_no_return_result_error16_arrow@
expression E;
identifier FP_NAME = result_error16;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_result_double(args);


// Transform E->result_error_code(args) to direct call (only 1 candidate)
@transform_no_return_result_error_code_arrow@
expression E;
identifier FP_NAME = result_error_code;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_result_error_nomem(args);


// Transform E->result_int(args) to direct call (only 1 candidate)
@transform_no_return_result_int_arrow@
expression E;
identifier FP_NAME = result_int;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_result_error(args);


// Transform E->result_int64(args) to direct call (only 1 candidate)
@transform_no_return_result_int64_arrow@
expression E;
identifier FP_NAME = result_int64;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_result_error16(args);


// Transform E->result_null(args) to direct call (only 1 candidate)
@transform_no_return_result_null_arrow@
expression E;
identifier FP_NAME = result_null;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_result_int(args);


// Transform E->result_pointer(args) to direct call (only 1 candidate)
@transform_no_return_result_pointer_arrow@
expression E;
identifier FP_NAME = result_pointer;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_value_free(args);


// Transform E->result_subtype(args) to direct call (only 1 candidate)
@transform_no_return_result_subtype_arrow@
expression E;
identifier FP_NAME = result_subtype;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_bind_text64(args);


// Transform E->result_text(args) to direct call (only 1 candidate)
@transform_no_return_result_text_arrow@
expression E;
identifier FP_NAME = result_text;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_result_int64(args);


// Transform E->result_text16(args) to direct call (only 1 candidate)
@transform_no_return_result_text16_arrow@
expression E;
identifier FP_NAME = result_text16;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_result_null(args);


// Transform E->result_text16be(args) to direct call (only 1 candidate)
@transform_no_return_result_text16be_arrow@
expression E;
identifier FP_NAME = result_text16be;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_result_text(args);


// Transform E->result_text16le(args) to direct call (only 1 candidate)
@transform_no_return_result_text16le_arrow@
expression E;
identifier FP_NAME = result_text16le;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_result_text16(args);


// Transform E->result_text64(args) to direct call (only 1 candidate)
@transform_no_return_result_text64_arrow@
expression E;
identifier FP_NAME = result_text64;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_uri_boolean(args);


// Transform E->result_value(args) to direct call (only 1 candidate)
@transform_no_return_result_value_arrow@
expression E;
identifier FP_NAME = result_value;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_result_text16be(args);


// Transform E->result_zeroblob(args) to direct call (only 1 candidate)
@transform_no_return_result_zeroblob_arrow@
expression E;
identifier FP_NAME = result_zeroblob;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_release_memory(args);


// Transform E->result_zeroblob64(args) to direct call (only 1 candidate)
@transform_no_return_result_zeroblob64_arrow@
expression E;
identifier FP_NAME = result_zeroblob64;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_wal_checkpoint_v2(args);


// Transform E->rollback_hook(args) to direct call (only 1 candidate)
@transform_no_return_rollback_hook_arrow@
expression E;
identifier FP_NAME = rollback_hook;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_result_text16le(args);


// Transform E->serialize(args) to direct call (only 1 candidate)
@transform_no_return_serialize_arrow@
expression E;
identifier FP_NAME = serialize;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_filename_database(args);


// Transform E->set_authorizer(args) to direct call (only 1 candidate)
@transform_no_return_set_authorizer_arrow@
expression E;
identifier FP_NAME = set_authorizer;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_result_value(args);


// Transform E->set_auxdata(args) to direct call (only 1 candidate)
@transform_no_return_set_auxdata_arrow@
expression E;
identifier FP_NAME = set_auxdata;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_rollback_hook(args);


// Transform E->set_clientdata(args) to direct call (only 1 candidate)
@transform_no_return_set_clientdata_arrow@
expression E;
identifier FP_NAME = set_clientdata;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_txn_state(args);


// Transform E->set_last_insert_rowid(args) to direct call (only 1 candidate)
@transform_no_return_set_last_insert_rowid_arrow@
expression E;
identifier FP_NAME = set_last_insert_rowid;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_result_blob64(args);


// Transform E->setlk_timeout(args) to direct call (only 1 candidate)
@transform_no_return_setlk_timeout_arrow@
expression E;
identifier FP_NAME = setlk_timeout;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_changes64(args);


// Transform E->soft_heap_limit(args) to direct call (only 1 candidate)
@transform_no_return_soft_heap_limit_arrow@
expression E;
identifier FP_NAME = soft_heap_limit;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_mutex_enter(args);


// Transform E->soft_heap_limit64(args) to direct call (only 1 candidate)
@transform_no_return_soft_heap_limit64_arrow@
expression E;
identifier FP_NAME = soft_heap_limit64;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_backup_step(args);


// Transform E->sql(args) to direct call (only 1 candidate)
@transform_no_return_sql_arrow@
expression E;
identifier FP_NAME = sql;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_threadsafe(args);


// Transform E->status(args) to direct call (only 1 candidate)
@transform_no_return_status_arrow@
expression E;
identifier FP_NAME = status;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_result_zeroblob(args);


// Transform E->status64(args) to direct call (only 1 candidate)
@transform_no_return_status64_arrow@
expression E;
identifier FP_NAME = status64;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_cancel_auto_extension(args);


// Transform E->step(args) to direct call (only 1 candidate)
@transform_no_return_step_arrow@
expression E;
identifier FP_NAME = step;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_set_auxdata(args);


// Transform E->stmt_explain(args) to direct call (only 1 candidate)
@transform_no_return_stmt_explain_arrow@
expression E;
identifier FP_NAME = stmt_explain;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_free_filename(args);


// Transform E->stmt_isexplain(args) to direct call (only 1 candidate)
@transform_no_return_stmt_isexplain_arrow@
expression E;
identifier FP_NAME = stmt_isexplain;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_keyword_name(args);


// Transform E->stmt_status(args) to direct call (only 1 candidate)
@transform_no_return_stmt_status_arrow@
expression E;
identifier FP_NAME = stmt_status;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_compileoption_used(args);


// Transform E->str_append(args) to direct call (only 1 candidate)
@transform_no_return_str_append_arrow@
expression E;
identifier FP_NAME = str_append;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_prepare_v3(args);


// Transform E->str_appendall(args) to direct call (only 1 candidate)
@transform_no_return_str_appendall_arrow@
expression E;
identifier FP_NAME = str_appendall;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_prepare16_v3(args);


// Transform E->str_appendchar(args) to direct call (only 1 candidate)
@transform_no_return_str_appendchar_arrow@
expression E;
identifier FP_NAME = str_appendchar;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_bind_pointer(args);


// Transform E->str_appendf(args) to direct call (only 1 candidate)
@transform_no_return_str_appendf_arrow@
expression E;
identifier FP_NAME = str_appendf;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_expanded_sql(args);


// Transform E->str_errcode(args) to direct call (only 1 candidate)
@transform_no_return_str_errcode_arrow@
expression E;
identifier FP_NAME = str_errcode;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_value_pointer(args);


// Transform E->str_finish(args) to direct call (only 1 candidate)
@transform_no_return_str_finish_arrow@
expression E;
identifier FP_NAME = str_finish;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_trace_v2(args);


// Transform E->str_length(args) to direct call (only 1 candidate)
@transform_no_return_str_length_arrow@
expression E;
identifier FP_NAME = str_length;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_vtab_nochange(args);


// Transform E->str_new(args) to direct call (only 1 candidate)
@transform_no_return_str_new_arrow@
expression E;
identifier FP_NAME = str_new;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_system_errno(args);


// Transform E->str_reset(args) to direct call (only 1 candidate)
@transform_no_return_str_reset_arrow@
expression E;
identifier FP_NAME = str_reset;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_result_pointer(args);


// Transform E->str_value(args) to direct call (only 1 candidate)
@transform_no_return_str_value_arrow@
expression E;
identifier FP_NAME = str_value;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_value_nochange(args);


// Transform E->str_vappendf(args) to direct call (only 1 candidate)
@transform_no_return_str_vappendf_arrow@
expression E;
identifier FP_NAME = str_vappendf;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_set_last_insert_rowid(args);


// Transform E->strglob(args) to direct call (only 1 candidate)
@transform_no_return_strglob_arrow@
expression E;
identifier FP_NAME = strglob;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_uri_int64(args);


// Transform E->stricmp(args) to direct call (only 1 candidate)
@transform_no_return_stricmp_arrow@
expression E;
identifier FP_NAME = stricmp;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_wal_checkpoint(args);


// Transform E->strlike(args) to direct call (only 1 candidate)
@transform_no_return_strlike_arrow@
expression E;
identifier FP_NAME = strlike;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_load_extension(args);


// Transform E->system_errno(args) to direct call (only 1 candidate)
@transform_no_return_system_errno_arrow@
expression E;
identifier FP_NAME = system_errno;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_msize(args);


// Transform E->table_column_metadata(args) to direct call (only 1 candidate)
@transform_no_return_table_column_metadata_arrow@
expression E;
identifier FP_NAME = table_column_metadata;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_snprintf(args);


// Transform E->test_control(args) to direct call (only 1 candidate)
@transform_no_return_test_control_arrow@
expression E;
identifier FP_NAME = test_control;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_result_error_toobig(args);


// Transform E->thread_cleanup(args) to direct call (only 1 candidate)
@transform_no_return_thread_cleanup_arrow@
expression E;
identifier FP_NAME = thread_cleanup;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_step(args);


// Transform E->total_changes(args) to direct call (only 1 candidate)
@transform_no_return_total_changes_arrow@
expression E;
identifier FP_NAME = total_changes;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_table_column_metadata(args);


// Transform E->total_changes64(args) to direct call (only 1 candidate)
@transform_no_return_total_changes64_arrow@
expression E;
identifier FP_NAME = total_changes64;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_create_window_function(args);


// Transform E->trace_v2(args) to direct call (only 1 candidate)
@transform_no_return_trace_v2_arrow@
expression E;
identifier FP_NAME = trace_v2;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_realloc64(args);


// Transform E->txn_state(args) to direct call (only 1 candidate)
@transform_no_return_txn_state_arrow@
expression E;
identifier FP_NAME = txn_state;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_str_length(args);


// Transform E->uri_boolean(args) to direct call (only 1 candidate)
@transform_no_return_uri_boolean_arrow@
expression E;
identifier FP_NAME = uri_boolean;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_wal_hook(args);


// Transform E->uri_key(args) to direct call (only 1 candidate)
@transform_no_return_uri_key_arrow@
expression E;
identifier FP_NAME = uri_key;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_str_appendf(args);


// Transform E->user_data(args) to direct call (only 1 candidate)
@transform_no_return_user_data_arrow@
expression E;
identifier FP_NAME = user_data;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_trace(args);


// Transform E->value_double(args) to direct call (only 1 candidate)
@transform_no_return_value_double_arrow@
expression E;
identifier FP_NAME = value_double;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_user_data(args);


// Transform E->value_dup(args) to direct call (only 1 candidate)
@transform_no_return_value_dup_arrow@
expression E;
identifier FP_NAME = value_dup;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_uri_parameter(args);


// Transform E->value_encoding(args) to direct call (only 1 candidate)
@transform_no_return_value_encoding_arrow@
expression E;
identifier FP_NAME = value_encoding;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_filename_wal(args);


// Transform E->value_free(args) to direct call (only 1 candidate)
@transform_no_return_value_free_arrow@
expression E;
identifier FP_NAME = value_free;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_vsnprintf(args);


// Transform E->value_frombind(args) to direct call (only 1 candidate)
@transform_no_return_value_frombind_arrow@
expression E;
identifier FP_NAME = value_frombind;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_keyword_check(args);


// Transform E->value_int(args) to direct call (only 1 candidate)
@transform_no_return_value_int_arrow@
expression E;
identifier FP_NAME = value_int;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_value_blob(args);


// Transform E->value_int64(args) to direct call (only 1 candidate)
@transform_no_return_value_int64_arrow@
expression E;
identifier FP_NAME = value_int64;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_value_bytes(args);


// Transform E->value_nochange(args) to direct call (only 1 candidate)
@transform_no_return_value_nochange_arrow@
expression E;
identifier FP_NAME = value_nochange;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_value_subtype(args);


// Transform E->value_numeric_type(args) to direct call (only 1 candidate)
@transform_no_return_value_numeric_type_arrow@
expression E;
identifier FP_NAME = value_numeric_type;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_value_bytes16(args);


// Transform E->value_pointer(args) to direct call (only 1 candidate)
@transform_no_return_value_pointer_arrow@
expression E;
identifier FP_NAME = value_pointer;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_result_zeroblob64(args);


// Transform E->value_subtype(args) to direct call (only 1 candidate)
@transform_no_return_value_subtype_arrow@
expression E;
identifier FP_NAME = value_subtype;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_bind_blob64(args);


// Transform E->value_text(args) to direct call (only 1 candidate)
@transform_no_return_value_text_arrow@
expression E;
identifier FP_NAME = value_text;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_value_double(args);


// Transform E->value_text16(args) to direct call (only 1 candidate)
@transform_no_return_value_text16_arrow@
expression E;
identifier FP_NAME = value_text16;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_value_int(args);


// Transform E->value_text16be(args) to direct call (only 1 candidate)
@transform_no_return_value_text16be_arrow@
expression E;
identifier FP_NAME = value_text16be;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_value_int64(args);


// Transform E->value_text16le(args) to direct call (only 1 candidate)
@transform_no_return_value_text16le_arrow@
expression E;
identifier FP_NAME = value_text16le;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_value_numeric_type(args);


// Transform E->value_type(args) to direct call (only 1 candidate)
@transform_no_return_value_type_arrow@
expression E;
identifier FP_NAME = value_type;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_value_text(args);


// Transform E->vfs_find(args) to direct call (only 1 candidate)
@transform_no_return_vfs_find_arrow@
expression E;
identifier FP_NAME = vfs_find;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_mutex_free(args);


// Transform E->vfs_register(args) to direct call (only 1 candidate)
@transform_no_return_vfs_register_arrow@
expression E;
identifier FP_NAME = vfs_register;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_mutex_leave(args);


// Transform E->vfs_unregister(args) to direct call (only 1 candidate)
@transform_no_return_vfs_unregister_arrow@
expression E;
identifier FP_NAME = vfs_unregister;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_mutex_try(args);


// Transform E->vmprintf(args) to direct call (only 1 candidate)
@transform_no_return_vmprintf_arrow@
expression E;
identifier FP_NAME = vmprintf;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_value_text16(args);


// Transform E->vtab_collation(args) to direct call (only 1 candidate)
@transform_no_return_vtab_collation_arrow@
expression E;
identifier FP_NAME = vtab_collation;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_result_subtype(args);


// Transform E->vtab_config(args) to direct call (only 1 candidate)
@transform_no_return_vtab_config_arrow@
expression E;
identifier FP_NAME = vtab_config;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_extended_errcode(args);


// Transform E->vtab_distinct(args) to direct call (only 1 candidate)
@transform_no_return_vtab_distinct_arrow@
expression E;
identifier FP_NAME = vtab_distinct;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_value_frombind(args);


// Transform E->vtab_nochange(args) to direct call (only 1 candidate)
@transform_no_return_vtab_nochange_arrow@
expression E;
identifier FP_NAME = vtab_nochange;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_bind_zeroblob64(args);


// Transform E->vtab_on_conflict(args) to direct call (only 1 candidate)
@transform_no_return_vtab_on_conflict_arrow@
expression E;
identifier FP_NAME = vtab_on_conflict;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_log(args);


// Transform E->wal_checkpoint(args) to direct call (only 1 candidate)
@transform_no_return_wal_checkpoint_arrow@
expression E;
identifier FP_NAME = wal_checkpoint;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_db_config(args);


// Transform E->wal_hook(args) to direct call (only 1 candidate)
@transform_no_return_wal_hook_arrow@
expression E;
identifier FP_NAME = wal_hook;
expression list args;
@@
- E->FP_NAME(args);
+ sqlite3_db_mutex(args);


// Transform E->xAccess(args) to if-chain with 4 candidates
@transform_no_return_xAccess_arrow@
expression E;
identifier FP_NAME = xAccess;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xAccess_signature, xAccess_signatures[xAccess_apndAccess_enum], sizeof(E->xAccess_signature)) == 0) {
+ apndAccess(args);
+ }
+ else if (memcmp(E->xAccess_signature, xAccess_signatures[xAccess_memdbAccess_enum], sizeof(E->xAccess_signature)) == 0) {
+ memdbAccess(args);
+ }
+ else if (memcmp(E->xAccess_signature, xAccess_signatures[xAccess_vfstraceAccess_enum], sizeof(E->xAccess_signature)) == 0) {
+ vfstraceAccess(args);
+ }
+ else if (memcmp(E->xAccess_signature, xAccess_signatures[xAccess_unixAccess_enum], sizeof(E->xAccess_signature)) == 0) {
+ unixAccess(args);
+ }


// Transform E->xBegin(args) to if-chain with 4 candidates
@transform_no_return_xBegin_arrow@
expression E;
identifier FP_NAME = xBegin;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xBegin_signature, xBegin_signatures[xBegin_0_enum], sizeof(E->xBegin_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xBegin_signature, xBegin_signatures[xBegin_dbpageBegin_enum], sizeof(E->xBegin_signature)) == 0) {
+ dbpageBegin(args);
+ }
+ else if (memcmp(E->xBegin_signature, xBegin_signatures[xBegin_fts3BeginMethod_enum], sizeof(E->xBegin_signature)) == 0) {
+ fts3BeginMethod(args);
+ }
+ else if (memcmp(E->xBegin_signature, xBegin_signatures[xBegin_rtreeBeginTransaction_enum], sizeof(E->xBegin_signature)) == 0) {
+ rtreeBeginTransaction(args);
+ }
+ else if (memcmp(E->xBegin_signature, xBegin_signatures[xBegin_zipfileBegin_enum], sizeof(E->xBegin_signature)) == 0) {
+ zipfileBegin(args);
+ }


// Transform E->xBestIndex(args) to if-chain with 16 candidates
@transform_no_return_xBestIndex_arrow@
expression E;
identifier FP_NAME = xBestIndex;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xBestIndex_signature, xBestIndex_signatures[xBestIndex_bytecodevtabBestIndex_enum], sizeof(E->xBestIndex_signature)) == 0) {
+ bytecodevtabBestIndex(args);
+ }
+ else if (memcmp(E->xBestIndex_signature, xBestIndex_signatures[xBestIndex_completionBestIndex_enum], sizeof(E->xBestIndex_signature)) == 0) {
+ completionBestIndex(args);
+ }
+ else if (memcmp(E->xBestIndex_signature, xBestIndex_signatures[xBestIndex_dbdataBestIndex_enum], sizeof(E->xBestIndex_signature)) == 0) {
+ dbdataBestIndex(args);
+ }
+ else if (memcmp(E->xBestIndex_signature, xBestIndex_signatures[xBestIndex_dbpageBestIndex_enum], sizeof(E->xBestIndex_signature)) == 0) {
+ dbpageBestIndex(args);
+ }
+ else if (memcmp(E->xBestIndex_signature, xBestIndex_signatures[xBestIndex_expertBestIndex_enum], sizeof(E->xBestIndex_signature)) == 0) {
+ expertBestIndex(args);
+ }
+ else if (memcmp(E->xBestIndex_signature, xBestIndex_signatures[xBestIndex_fsdirBestIndex_enum], sizeof(E->xBestIndex_signature)) == 0) {
+ fsdirBestIndex(args);
+ }
+ else if (memcmp(E->xBestIndex_signature, xBestIndex_signatures[xBestIndex_fts3BestIndexMethod_enum], sizeof(E->xBestIndex_signature)) == 0) {
+ fts3BestIndexMethod(args);
+ }
+ else if (memcmp(E->xBestIndex_signature, xBestIndex_signatures[xBestIndex_fts3auxBestIndexMethod_enum], sizeof(E->xBestIndex_signature)) == 0) {
+ fts3auxBestIndexMethod(args);
+ }
+ else if (memcmp(E->xBestIndex_signature, xBestIndex_signatures[xBestIndex_fts3tokBestIndexMethod_enum], sizeof(E->xBestIndex_signature)) == 0) {
+ fts3tokBestIndexMethod(args);
+ }
+ else if (memcmp(E->xBestIndex_signature, xBestIndex_signatures[xBestIndex_jsonEachBestIndex_enum], sizeof(E->xBestIndex_signature)) == 0) {
+ jsonEachBestIndex(args);
+ }
+ else if (memcmp(E->xBestIndex_signature, xBestIndex_signatures[xBestIndex_pragmaVtabBestIndex_enum], sizeof(E->xBestIndex_signature)) == 0) {
+ pragmaVtabBestIndex(args);
+ }
+ else if (memcmp(E->xBestIndex_signature, xBestIndex_signatures[xBestIndex_rtreeBestIndex_enum], sizeof(E->xBestIndex_signature)) == 0) {
+ rtreeBestIndex(args);
+ }
+ else if (memcmp(E->xBestIndex_signature, xBestIndex_signatures[xBestIndex_seriesBestIndex_enum], sizeof(E->xBestIndex_signature)) == 0) {
+ seriesBestIndex(args);
+ }
+ else if (memcmp(E->xBestIndex_signature, xBestIndex_signatures[xBestIndex_statBestIndex_enum], sizeof(E->xBestIndex_signature)) == 0) {
+ statBestIndex(args);
+ }
+ else if (memcmp(E->xBestIndex_signature, xBestIndex_signatures[xBestIndex_stmtBestIndex_enum], sizeof(E->xBestIndex_signature)) == 0) {
+ stmtBestIndex(args);
+ }
+ else if (memcmp(E->xBestIndex_signature, xBestIndex_signatures[xBestIndex_zipfileBestIndex_enum], sizeof(E->xBestIndex_signature)) == 0) {
+ zipfileBestIndex(args);
+ }


// Transform E->xCachesize(args) to if-chain with 2 candidates
@transform_no_return_xCachesize_arrow@
expression E;
identifier FP_NAME = xCachesize;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xCachesize_signature, xCachesize_signatures[xCachesize_pcache1Cachesize_enum], sizeof(E->xCachesize_signature)) == 0) {
+ pcache1Cachesize(args);
+ }
+ else if (memcmp(E->xCachesize_signature, xCachesize_signatures[xCachesize_pcachetraceCachesize_enum], sizeof(E->xCachesize_signature)) == 0) {
+ pcachetraceCachesize(args);
+ }


// Transform E->xCellSize(args) to if-chain with 4 candidates
@transform_no_return_xCellSize_arrow@
expression E;
identifier FP_NAME = xCellSize;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xCellSize_signature, xCellSize_signatures[xCellSize_cellSizePtr_enum], sizeof(E->xCellSize_signature)) == 0) {
+ cellSizePtr(args);
+ }
+ else if (memcmp(E->xCellSize_signature, xCellSize_signatures[xCellSize_cellSizePtrIdxLeaf_enum], sizeof(E->xCellSize_signature)) == 0) {
+ cellSizePtrIdxLeaf(args);
+ }
+ else if (memcmp(E->xCellSize_signature, xCellSize_signatures[xCellSize_cellSizePtrNoPayload_enum], sizeof(E->xCellSize_signature)) == 0) {
+ cellSizePtrNoPayload(args);
+ }
+ else if (memcmp(E->xCellSize_signature, xCellSize_signatures[xCellSize_cellSizePtrTableLeaf_enum], sizeof(E->xCellSize_signature)) == 0) {
+ cellSizePtrTableLeaf(args);
+ }


// Transform E->xCheckReservedLock(args) to if-chain with 6 candidates
@transform_no_return_xCheckReservedLock_arrow@
expression E;
identifier FP_NAME = xCheckReservedLock;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xCheckReservedLock_signature, xCheckReservedLock_signatures[xCheckReservedLock_0_enum], sizeof(E->xCheckReservedLock_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xCheckReservedLock_signature, xCheckReservedLock_signatures[xCheckReservedLock_apndCheckReservedLock_enum], sizeof(E->xCheckReservedLock_signature)) == 0) {
+ apndCheckReservedLock(args);
+ }
+ else if (memcmp(E->xCheckReservedLock_signature, xCheckReservedLock_signatures[xCheckReservedLock_recoverVfsCheckReservedLock_enum], sizeof(E->xCheckReservedLock_signature)) == 0) {
+ recoverVfsCheckReservedLock(args);
+ }
+ else if (memcmp(E->xCheckReservedLock_signature, xCheckReservedLock_signatures[xCheckReservedLock_vfstraceCheckReservedLock_enum], sizeof(E->xCheckReservedLock_signature)) == 0) {
+ vfstraceCheckReservedLock(args);
+ }
+ else if (memcmp(E->xCheckReservedLock_signature, xCheckReservedLock_signatures[xCheckReservedLock_unixCheckReservedLock_enum], sizeof(E->xCheckReservedLock_signature)) == 0) {
+ unixCheckReservedLock(args);
+ }
+ else if (memcmp(E->xCheckReservedLock_signature, xCheckReservedLock_signatures[xCheckReservedLock_nolockCheckReservedLock_enum], sizeof(E->xCheckReservedLock_signature)) == 0) {
+ nolockCheckReservedLock(args);
+ }
+ else if (memcmp(E->xCheckReservedLock_signature, xCheckReservedLock_signatures[xCheckReservedLock_dotlockCheckReservedLock_enum], sizeof(E->xCheckReservedLock_signature)) == 0) {
+ dotlockCheckReservedLock(args);
+ }


// Transform E->xClose(args) to if-chain with 27 candidates
@transform_no_return_xClose_arrow@
expression E;
identifier FP_NAME = xClose;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xClose_signature, xClose_signatures[xClose_apndClose_enum], sizeof(E->xClose_signature)) == 0) {
+ apndClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_bytecodevtabClose_enum], sizeof(E->xClose_signature)) == 0) {
+ bytecodevtabClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_completionClose_enum], sizeof(E->xClose_signature)) == 0) {
+ completionClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_dbdataClose_enum], sizeof(E->xClose_signature)) == 0) {
+ dbdataClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_dbpageClose_enum], sizeof(E->xClose_signature)) == 0) {
+ dbpageClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_expertClose_enum], sizeof(E->xClose_signature)) == 0) {
+ expertClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_fsdirClose_enum], sizeof(E->xClose_signature)) == 0) {
+ fsdirClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_fts3CloseMethod_enum], sizeof(E->xClose_signature)) == 0) {
+ fts3CloseMethod(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_fts3auxCloseMethod_enum], sizeof(E->xClose_signature)) == 0) {
+ fts3auxCloseMethod(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_fts3tokCloseMethod_enum], sizeof(E->xClose_signature)) == 0) {
+ fts3tokCloseMethod(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_jsonEachClose_enum], sizeof(E->xClose_signature)) == 0) {
+ jsonEachClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_memdbClose_enum], sizeof(E->xClose_signature)) == 0) {
+ memdbClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_memjrnlClose_enum], sizeof(E->xClose_signature)) == 0) {
+ memjrnlClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_porterClose_enum], sizeof(E->xClose_signature)) == 0) {
+ porterClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_pragmaVtabClose_enum], sizeof(E->xClose_signature)) == 0) {
+ pragmaVtabClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_recoverVfsClose_enum], sizeof(E->xClose_signature)) == 0) {
+ recoverVfsClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_rtreeClose_enum], sizeof(E->xClose_signature)) == 0) {
+ rtreeClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_seriesClose_enum], sizeof(E->xClose_signature)) == 0) {
+ seriesClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_simpleClose_enum], sizeof(E->xClose_signature)) == 0) {
+ simpleClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_statClose_enum], sizeof(E->xClose_signature)) == 0) {
+ statClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_stmtClose_enum], sizeof(E->xClose_signature)) == 0) {
+ stmtClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_unicodeClose_enum], sizeof(E->xClose_signature)) == 0) {
+ unicodeClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_vfstraceClose_enum], sizeof(E->xClose_signature)) == 0) {
+ vfstraceClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_zipfileClose_enum], sizeof(E->xClose_signature)) == 0) {
+ zipfileClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_unixClose_enum], sizeof(E->xClose_signature)) == 0) {
+ unixClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_nolockClose_enum], sizeof(E->xClose_signature)) == 0) {
+ nolockClose(args);
+ }
+ else if (memcmp(E->xClose_signature, xClose_signatures[xClose_dotlockClose_enum], sizeof(E->xClose_signature)) == 0) {
+ dotlockClose(args);
+ }


// Transform E->xColumn(args) to if-chain with 44 candidates
@transform_no_return_xColumn_arrow@
expression E;
identifier FP_NAME = xColumn;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_amatchColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ amatchColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_binfoColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ binfoColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_bytecodevtabColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ bytecodevtabColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_carrayColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ carrayColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_cidxColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ cidxColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_closureColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ closureColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_completionColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ completionColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_csvtabColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ csvtabColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_dbdataColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ dbdataColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_dbpageColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ dbpageColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_deltaparsevtabColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ deltaparsevtabColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_echoColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ echoColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_expertColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ expertColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_explainColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ explainColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_fsColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ fsColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_fsdirColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ fsdirColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_fstreeColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ fstreeColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_fts3ColumnMethod_enum], sizeof(E->xColumn_signature)) == 0) {
+ fts3ColumnMethod(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_fts3auxColumnMethod_enum], sizeof(E->xColumn_signature)) == 0) {
+ fts3auxColumnMethod(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_fts3termColumnMethod_enum], sizeof(E->xColumn_signature)) == 0) {
+ fts3termColumnMethod(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_fts3tokColumnMethod_enum], sizeof(E->xColumn_signature)) == 0) {
+ fts3tokColumnMethod(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_fuzzerColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ fuzzerColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_geopolyColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ geopolyColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_intarrayColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ intarrayColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_jsonEachColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ jsonEachColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_memstatColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ memstatColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_pragmaVtabColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ pragmaVtabColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_prefixesColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ prefixesColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_qpvtabColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ qpvtabColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_rtreeColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ rtreeColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_schemaColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ schemaColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_seriesColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ seriesColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_spellfix1Column_enum], sizeof(E->xColumn_signature)) == 0) {
+ spellfix1Column(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_statColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ statColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_stmtColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ stmtColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_tclColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ tclColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_tclvarColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ tclvarColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_templatevtabColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ templatevtabColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_unionColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ unionColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_vlogColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ vlogColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_vstattabColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ vstattabColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_vtablogColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ vtablogColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_wholenumberColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ wholenumberColumn(args);
+ }
+ else if (memcmp(E->xColumn_signature, xColumn_signatures[xColumn_zipfileColumn_enum], sizeof(E->xColumn_signature)) == 0) {
+ zipfileColumn(args);
+ }


// Transform E->xCommit(args) to if-chain with 5 candidates
@transform_no_return_xCommit_arrow@
expression E;
identifier FP_NAME = xCommit;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xCommit_signature, xCommit_signatures[xCommit_0_enum], sizeof(E->xCommit_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xCommit_signature, xCommit_signatures[xCommit_echoCommit_enum], sizeof(E->xCommit_signature)) == 0) {
+ echoCommit(args);
+ }
+ else if (memcmp(E->xCommit_signature, xCommit_signatures[xCommit_fts3CommitMethod_enum], sizeof(E->xCommit_signature)) == 0) {
+ fts3CommitMethod(args);
+ }
+ else if (memcmp(E->xCommit_signature, xCommit_signatures[xCommit_rtreeEndTransaction_enum], sizeof(E->xCommit_signature)) == 0) {
+ rtreeEndTransaction(args);
+ }
+ else if (memcmp(E->xCommit_signature, xCommit_signatures[xCommit_vtablogCommit_enum], sizeof(E->xCommit_signature)) == 0) {
+ vtablogCommit(args);
+ }
+ else if (memcmp(E->xCommit_signature, xCommit_signatures[xCommit_zipfileCommit_enum], sizeof(E->xCommit_signature)) == 0) {
+ zipfileCommit(args);
+ }


// Transform E->xConnect(args) to if-chain with 44 candidates
@transform_no_return_xConnect_arrow@
expression E;
identifier FP_NAME = xConnect;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_amatchConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ amatchConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_binfoConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ binfoConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_bytecodevtabConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ bytecodevtabConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_carrayConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ carrayConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_cidxConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ cidxConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_closureConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ closureConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_completionConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ completionConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_csvtabConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ csvtabConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_dbdataConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ dbdataConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_dbpageConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ dbpageConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_deltaparsevtabConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ deltaparsevtabConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_echoConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ echoConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_expertConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ expertConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_explainConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ explainConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_fsConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ fsConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_fsdirConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ fsdirConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_fstreeConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ fstreeConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_fts3ConnectMethod_enum], sizeof(E->xConnect_signature)) == 0) {
+ fts3ConnectMethod(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_fts3auxConnectMethod_enum], sizeof(E->xConnect_signature)) == 0) {
+ fts3auxConnectMethod(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_fts3termConnectMethod_enum], sizeof(E->xConnect_signature)) == 0) {
+ fts3termConnectMethod(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_fts3tokConnectMethod_enum], sizeof(E->xConnect_signature)) == 0) {
+ fts3tokConnectMethod(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_fuzzerConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ fuzzerConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_geopolyConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ geopolyConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_intarrayCreate_enum], sizeof(E->xConnect_signature)) == 0) {
+ intarrayCreate(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_jsonEachConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ jsonEachConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_memstatConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ memstatConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_pragmaVtabConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ pragmaVtabConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_prefixesConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ prefixesConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_qpvtabConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ qpvtabConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_rtreeConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ rtreeConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_schemaCreate_enum], sizeof(E->xConnect_signature)) == 0) {
+ schemaCreate(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_seriesConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ seriesConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_spellfix1Connect_enum], sizeof(E->xConnect_signature)) == 0) {
+ spellfix1Connect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_statConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ statConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_stmtConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ stmtConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_tclConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ tclConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_tclvarConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ tclvarConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_templatevtabConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ templatevtabConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_unionConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ unionConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_vlogConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ vlogConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_vstattabConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ vstattabConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_vtablogConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ vtablogConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_wholenumberConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ wholenumberConnect(args);
+ }
+ else if (memcmp(E->xConnect_signature, xConnect_signatures[xConnect_zipfileConnect_enum], sizeof(E->xConnect_signature)) == 0) {
+ zipfileConnect(args);
+ }


// Transform E->xCount(args) to if-chain with 3 candidates
@transform_no_return_xCount_arrow@
expression E;
identifier FP_NAME = xCount;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xCount_signature, xCount_signatures[xCount_sessionDiffCount_enum], sizeof(E->xCount_signature)) == 0) {
+ sessionDiffCount(args);
+ }
+ else if (memcmp(E->xCount_signature, xCount_signatures[xCount_sessionPreupdateCount_enum], sizeof(E->xCount_signature)) == 0) {
+ sessionPreupdateCount(args);
+ }
+ else if (memcmp(E->xCount_signature, xCount_signatures[xCount_sessionStat1Count_enum], sizeof(E->xCount_signature)) == 0) {
+ sessionStat1Count(args);
+ }


// Transform E->xCreate(args) to if-chain with 34 candidates
@transform_no_return_xCreate_arrow@
expression E;
identifier FP_NAME = xCreate;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_0_enum], sizeof(E->xCreate_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_amatchConnect_enum], sizeof(E->xCreate_signature)) == 0) {
+ amatchConnect(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_closureConnect_enum], sizeof(E->xCreate_signature)) == 0) {
+ closureConnect(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_csvtabCreate_enum], sizeof(E->xCreate_signature)) == 0) {
+ csvtabCreate(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_dbpageConnect_enum], sizeof(E->xCreate_signature)) == 0) {
+ dbpageConnect(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_echoCreate_enum], sizeof(E->xCreate_signature)) == 0) {
+ echoCreate(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_expertConnect_enum], sizeof(E->xCreate_signature)) == 0) {
+ expertConnect(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_f5tOrigintextCreate_enum], sizeof(E->xCreate_signature)) == 0) {
+ f5tOrigintextCreate(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_f5tTokenizerCreate_enum], sizeof(E->xCreate_signature)) == 0) {
+ f5tTokenizerCreate(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_fsConnect_enum], sizeof(E->xCreate_signature)) == 0) {
+ fsConnect(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_fsdirConnect_enum], sizeof(E->xCreate_signature)) == 0) {
+ fsdirConnect(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_fstreeConnect_enum], sizeof(E->xCreate_signature)) == 0) {
+ fstreeConnect(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_fts3CreateMethod_enum], sizeof(E->xCreate_signature)) == 0) {
+ fts3CreateMethod(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_fts3auxConnectMethod_enum], sizeof(E->xCreate_signature)) == 0) {
+ fts3auxConnectMethod(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_fts3termConnectMethod_enum], sizeof(E->xCreate_signature)) == 0) {
+ fts3termConnectMethod(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_fts3tokConnectMethod_enum], sizeof(E->xCreate_signature)) == 0) {
+ fts3tokConnectMethod(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_fuzzerConnect_enum], sizeof(E->xCreate_signature)) == 0) {
+ fuzzerConnect(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_geopolyCreate_enum], sizeof(E->xCreate_signature)) == 0) {
+ geopolyCreate(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_intarrayCreate_enum], sizeof(E->xCreate_signature)) == 0) {
+ intarrayCreate(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_pcache1Create_enum], sizeof(E->xCreate_signature)) == 0) {
+ pcache1Create(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_pcachetraceCreate_enum], sizeof(E->xCreate_signature)) == 0) {
+ pcachetraceCreate(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_porterCreate_enum], sizeof(E->xCreate_signature)) == 0) {
+ porterCreate(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_rtreeCreate_enum], sizeof(E->xCreate_signature)) == 0) {
+ rtreeCreate(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_schemaCreate_enum], sizeof(E->xCreate_signature)) == 0) {
+ schemaCreate(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_simpleCreate_enum], sizeof(E->xCreate_signature)) == 0) {
+ simpleCreate(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_spellfix1Create_enum], sizeof(E->xCreate_signature)) == 0) {
+ spellfix1Create(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_statConnect_enum], sizeof(E->xCreate_signature)) == 0) {
+ statConnect(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_tclConnect_enum], sizeof(E->xCreate_signature)) == 0) {
+ tclConnect(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_tclvarConnect_enum], sizeof(E->xCreate_signature)) == 0) {
+ tclvarConnect(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_unicodeCreate_enum], sizeof(E->xCreate_signature)) == 0) {
+ unicodeCreate(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_unionConnect_enum], sizeof(E->xCreate_signature)) == 0) {
+ unionConnect(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_vlogConnect_enum], sizeof(E->xCreate_signature)) == 0) {
+ vlogConnect(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_vtablogCreate_enum], sizeof(E->xCreate_signature)) == 0) {
+ vtablogCreate(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_wholenumberConnect_enum], sizeof(E->xCreate_signature)) == 0) {
+ wholenumberConnect(args);
+ }
+ else if (memcmp(E->xCreate_signature, xCreate_signatures[xCreate_zipfileConnect_enum], sizeof(E->xCreate_signature)) == 0) {
+ zipfileConnect(args);
+ }


// Transform E->xCurrentTime(args) to if-chain with 3 candidates
@transform_no_return_xCurrentTime_arrow@
expression E;
identifier FP_NAME = xCurrentTime;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xCurrentTime_signature, xCurrentTime_signatures[xCurrentTime_0_enum], sizeof(E->xCurrentTime_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xCurrentTime_signature, xCurrentTime_signatures[xCurrentTime_apndCurrentTime_enum], sizeof(E->xCurrentTime_signature)) == 0) {
+ apndCurrentTime(args);
+ }
+ else if (memcmp(E->xCurrentTime_signature, xCurrentTime_signatures[xCurrentTime_vfstraceCurrentTime_enum], sizeof(E->xCurrentTime_signature)) == 0) {
+ vfstraceCurrentTime(args);
+ }
+ else if (memcmp(E->xCurrentTime_signature, xCurrentTime_signatures[xCurrentTime_unixCurrentTime_enum], sizeof(E->xCurrentTime_signature)) == 0) {
+ unixCurrentTime(args);
+ }


// Transform E->xCurrentTimeInt64(args) to if-chain with 3 candidates
@transform_no_return_xCurrentTimeInt64_arrow@
expression E;
identifier FP_NAME = xCurrentTimeInt64;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xCurrentTimeInt64_signature, xCurrentTimeInt64_signatures[xCurrentTimeInt64_0_enum], sizeof(E->xCurrentTimeInt64_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xCurrentTimeInt64_signature, xCurrentTimeInt64_signatures[xCurrentTimeInt64_apndCurrentTimeInt64_enum], sizeof(E->xCurrentTimeInt64_signature)) == 0) {
+ apndCurrentTimeInt64(args);
+ }
+ else if (memcmp(E->xCurrentTimeInt64_signature, xCurrentTimeInt64_signatures[xCurrentTimeInt64_memdbCurrentTimeInt64_enum], sizeof(E->xCurrentTimeInt64_signature)) == 0) {
+ memdbCurrentTimeInt64(args);
+ }
+ else if (memcmp(E->xCurrentTimeInt64_signature, xCurrentTimeInt64_signatures[xCurrentTimeInt64_unixCurrentTimeInt64_enum], sizeof(E->xCurrentTimeInt64_signature)) == 0) {
+ unixCurrentTimeInt64(args);
+ }


// Transform E->xDel(args) to if-chain with 3 candidates
@transform_no_return_xDel_arrow@
expression E;
identifier FP_NAME = xDel;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xDel_signature, xDel_signatures[xDel_0_enum], sizeof(E->xDel_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xDel_signature, xDel_signatures[xDel_sqlite3RowSetDelete_enum], sizeof(E->xDel_signature)) == 0) {
+ sqlite3RowSetDelete(args);
+ }
+ else if (memcmp(E->xDel_signature, xDel_signatures[xDel_sqlite3VdbeFrameMemDel_enum], sizeof(E->xDel_signature)) == 0) {
+ sqlite3VdbeFrameMemDel(args);
+ }
+ else if (memcmp(E->xDel_signature, xDel_signatures[xDel_sqlite3_free_enum], sizeof(E->xDel_signature)) == 0) {
+ sqlite3_free(args);
+ }


// Transform E->xDelete(args) to if-chain with 6 candidates
@transform_no_return_xDelete_arrow@
expression E;
identifier FP_NAME = xDelete;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xDelete_signature, xDelete_signatures[xDelete_0_enum], sizeof(E->xDelete_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xDelete_signature, xDelete_signatures[xDelete_apndDelete_enum], sizeof(E->xDelete_signature)) == 0) {
+ apndDelete(args);
+ }
+ else if (memcmp(E->xDelete_signature, xDelete_signatures[xDelete_f5tOrigintextDelete_enum], sizeof(E->xDelete_signature)) == 0) {
+ f5tOrigintextDelete(args);
+ }
+ else if (memcmp(E->xDelete_signature, xDelete_signatures[xDelete_f5tTokenizerDelete_enum], sizeof(E->xDelete_signature)) == 0) {
+ f5tTokenizerDelete(args);
+ }
+ else if (memcmp(E->xDelete_signature, xDelete_signatures[xDelete_kvstorageDelete_enum], sizeof(E->xDelete_signature)) == 0) {
+ kvstorageDelete(args);
+ }
+ else if (memcmp(E->xDelete_signature, xDelete_signatures[xDelete_vfstraceDelete_enum], sizeof(E->xDelete_signature)) == 0) {
+ vfstraceDelete(args);
+ }
+ else if (memcmp(E->xDelete_signature, xDelete_signatures[xDelete_unixDelete_enum], sizeof(E->xDelete_signature)) == 0) {
+ unixDelete(args);
+ }


// Transform E->xDepth(args) to if-chain with 3 candidates
@transform_no_return_xDepth_arrow@
expression E;
identifier FP_NAME = xDepth;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xDepth_signature, xDepth_signatures[xDepth_sessionDiffDepth_enum], sizeof(E->xDepth_signature)) == 0) {
+ sessionDiffDepth(args);
+ }
+ else if (memcmp(E->xDepth_signature, xDepth_signatures[xDepth_sessionPreupdateDepth_enum], sizeof(E->xDepth_signature)) == 0) {
+ sessionPreupdateDepth(args);
+ }
+ else if (memcmp(E->xDepth_signature, xDepth_signatures[xDepth_sessionStat1Depth_enum], sizeof(E->xDepth_signature)) == 0) {
+ sessionStat1Depth(args);
+ }


// Transform E->xDestroy(args) to if-chain with 14 candidates
@transform_no_return_xDestroy_arrow@
expression E;
identifier FP_NAME = xDestroy;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xDestroy_signature, xDestroy_signatures[xDestroy_0_enum], sizeof(E->xDestroy_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xDestroy_signature, xDestroy_signatures[xDestroy_dbpageDisconnect_enum], sizeof(E->xDestroy_signature)) == 0) {
+ dbpageDisconnect(args);
+ }
+ else if (memcmp(E->xDestroy_signature, xDestroy_signatures[xDestroy_expertDisconnect_enum], sizeof(E->xDestroy_signature)) == 0) {
+ expertDisconnect(args);
+ }
+ else if (memcmp(E->xDestroy_signature, xDestroy_signatures[xDestroy_fsdirDisconnect_enum], sizeof(E->xDestroy_signature)) == 0) {
+ fsdirDisconnect(args);
+ }
+ else if (memcmp(E->xDestroy_signature, xDestroy_signatures[xDestroy_fts3DestroyMethod_enum], sizeof(E->xDestroy_signature)) == 0) {
+ fts3DestroyMethod(args);
+ }
+ else if (memcmp(E->xDestroy_signature, xDestroy_signatures[xDestroy_fts3auxDisconnectMethod_enum], sizeof(E->xDestroy_signature)) == 0) {
+ fts3auxDisconnectMethod(args);
+ }
+ else if (memcmp(E->xDestroy_signature, xDestroy_signatures[xDestroy_fts3tokDisconnectMethod_enum], sizeof(E->xDestroy_signature)) == 0) {
+ fts3tokDisconnectMethod(args);
+ }
+ else if (memcmp(E->xDestroy_signature, xDestroy_signatures[xDestroy_pcache1Destroy_enum], sizeof(E->xDestroy_signature)) == 0) {
+ pcache1Destroy(args);
+ }
+ else if (memcmp(E->xDestroy_signature, xDestroy_signatures[xDestroy_pcachetraceDestroy_enum], sizeof(E->xDestroy_signature)) == 0) {
+ pcachetraceDestroy(args);
+ }
+ else if (memcmp(E->xDestroy_signature, xDestroy_signatures[xDestroy_porterDestroy_enum], sizeof(E->xDestroy_signature)) == 0) {
+ porterDestroy(args);
+ }
+ else if (memcmp(E->xDestroy_signature, xDestroy_signatures[xDestroy_rtreeDestroy_enum], sizeof(E->xDestroy_signature)) == 0) {
+ rtreeDestroy(args);
+ }
+ else if (memcmp(E->xDestroy_signature, xDestroy_signatures[xDestroy_simpleDestroy_enum], sizeof(E->xDestroy_signature)) == 0) {
+ simpleDestroy(args);
+ }
+ else if (memcmp(E->xDestroy_signature, xDestroy_signatures[xDestroy_statDisconnect_enum], sizeof(E->xDestroy_signature)) == 0) {
+ statDisconnect(args);
+ }
+ else if (memcmp(E->xDestroy_signature, xDestroy_signatures[xDestroy_unicodeDestroy_enum], sizeof(E->xDestroy_signature)) == 0) {
+ unicodeDestroy(args);
+ }
+ else if (memcmp(E->xDestroy_signature, xDestroy_signatures[xDestroy_zipfileDisconnect_enum], sizeof(E->xDestroy_signature)) == 0) {
+ zipfileDisconnect(args);
+ }


// Transform E->xDeviceCharacteristics(args) to if-chain with 5 candidates
@transform_no_return_xDeviceCharacteristics_arrow@
expression E;
identifier FP_NAME = xDeviceCharacteristics;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xDeviceCharacteristics_signature, xDeviceCharacteristics_signatures[xDeviceCharacteristics_0_enum], sizeof(E->xDeviceCharacteristics_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xDeviceCharacteristics_signature, xDeviceCharacteristics_signatures[xDeviceCharacteristics_apndDeviceCharacteristics_enum], sizeof(E->xDeviceCharacteristics_signature)) == 0) {
+ apndDeviceCharacteristics(args);
+ }
+ else if (memcmp(E->xDeviceCharacteristics_signature, xDeviceCharacteristics_signatures[xDeviceCharacteristics_memdbDeviceCharacteristics_enum], sizeof(E->xDeviceCharacteristics_signature)) == 0) {
+ memdbDeviceCharacteristics(args);
+ }
+ else if (memcmp(E->xDeviceCharacteristics_signature, xDeviceCharacteristics_signatures[xDeviceCharacteristics_recoverVfsDeviceCharacteristics_enum], sizeof(E->xDeviceCharacteristics_signature)) == 0) {
+ recoverVfsDeviceCharacteristics(args);
+ }
+ else if (memcmp(E->xDeviceCharacteristics_signature, xDeviceCharacteristics_signatures[xDeviceCharacteristics_vfstraceDeviceCharacteristics_enum], sizeof(E->xDeviceCharacteristics_signature)) == 0) {
+ vfstraceDeviceCharacteristics(args);
+ }
+ else if (memcmp(E->xDeviceCharacteristics_signature, xDeviceCharacteristics_signatures[xDeviceCharacteristics_unixDeviceCharacteristics_enum], sizeof(E->xDeviceCharacteristics_signature)) == 0) {
+ unixDeviceCharacteristics(args);
+ }


// Transform E->xDisconnect(args) to if-chain with 16 candidates
@transform_no_return_xDisconnect_arrow@
expression E;
identifier FP_NAME = xDisconnect;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xDisconnect_signature, xDisconnect_signatures[xDisconnect_bytecodevtabDisconnect_enum], sizeof(E->xDisconnect_signature)) == 0) {
+ bytecodevtabDisconnect(args);
+ }
+ else if (memcmp(E->xDisconnect_signature, xDisconnect_signatures[xDisconnect_completionDisconnect_enum], sizeof(E->xDisconnect_signature)) == 0) {
+ completionDisconnect(args);
+ }
+ else if (memcmp(E->xDisconnect_signature, xDisconnect_signatures[xDisconnect_dbdataDisconnect_enum], sizeof(E->xDisconnect_signature)) == 0) {
+ dbdataDisconnect(args);
+ }
+ else if (memcmp(E->xDisconnect_signature, xDisconnect_signatures[xDisconnect_dbpageDisconnect_enum], sizeof(E->xDisconnect_signature)) == 0) {
+ dbpageDisconnect(args);
+ }
+ else if (memcmp(E->xDisconnect_signature, xDisconnect_signatures[xDisconnect_expertDisconnect_enum], sizeof(E->xDisconnect_signature)) == 0) {
+ expertDisconnect(args);
+ }
+ else if (memcmp(E->xDisconnect_signature, xDisconnect_signatures[xDisconnect_fsdirDisconnect_enum], sizeof(E->xDisconnect_signature)) == 0) {
+ fsdirDisconnect(args);
+ }
+ else if (memcmp(E->xDisconnect_signature, xDisconnect_signatures[xDisconnect_fts3DisconnectMethod_enum], sizeof(E->xDisconnect_signature)) == 0) {
+ fts3DisconnectMethod(args);
+ }
+ else if (memcmp(E->xDisconnect_signature, xDisconnect_signatures[xDisconnect_fts3auxDisconnectMethod_enum], sizeof(E->xDisconnect_signature)) == 0) {
+ fts3auxDisconnectMethod(args);
+ }
+ else if (memcmp(E->xDisconnect_signature, xDisconnect_signatures[xDisconnect_fts3tokDisconnectMethod_enum], sizeof(E->xDisconnect_signature)) == 0) {
+ fts3tokDisconnectMethod(args);
+ }
+ else if (memcmp(E->xDisconnect_signature, xDisconnect_signatures[xDisconnect_jsonEachDisconnect_enum], sizeof(E->xDisconnect_signature)) == 0) {
+ jsonEachDisconnect(args);
+ }
+ else if (memcmp(E->xDisconnect_signature, xDisconnect_signatures[xDisconnect_pragmaVtabDisconnect_enum], sizeof(E->xDisconnect_signature)) == 0) {
+ pragmaVtabDisconnect(args);
+ }
+ else if (memcmp(E->xDisconnect_signature, xDisconnect_signatures[xDisconnect_rtreeDisconnect_enum], sizeof(E->xDisconnect_signature)) == 0) {
+ rtreeDisconnect(args);
+ }
+ else if (memcmp(E->xDisconnect_signature, xDisconnect_signatures[xDisconnect_seriesDisconnect_enum], sizeof(E->xDisconnect_signature)) == 0) {
+ seriesDisconnect(args);
+ }
+ else if (memcmp(E->xDisconnect_signature, xDisconnect_signatures[xDisconnect_statDisconnect_enum], sizeof(E->xDisconnect_signature)) == 0) {
+ statDisconnect(args);
+ }
+ else if (memcmp(E->xDisconnect_signature, xDisconnect_signatures[xDisconnect_stmtDisconnect_enum], sizeof(E->xDisconnect_signature)) == 0) {
+ stmtDisconnect(args);
+ }
+ else if (memcmp(E->xDisconnect_signature, xDisconnect_signatures[xDisconnect_zipfileDisconnect_enum], sizeof(E->xDisconnect_signature)) == 0) {
+ zipfileDisconnect(args);
+ }


// Transform E->xDlClose(args) to if-chain with 3 candidates
@transform_no_return_xDlClose_arrow@
expression E;
identifier FP_NAME = xDlClose;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xDlClose_signature, xDlClose_signatures[xDlClose_0_enum], sizeof(E->xDlClose_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xDlClose_signature, xDlClose_signatures[xDlClose_apndDlClose_enum], sizeof(E->xDlClose_signature)) == 0) {
+ apndDlClose(args);
+ }
+ else if (memcmp(E->xDlClose_signature, xDlClose_signatures[xDlClose_memdbDlClose_enum], sizeof(E->xDlClose_signature)) == 0) {
+ memdbDlClose(args);
+ }
+ else if (memcmp(E->xDlClose_signature, xDlClose_signatures[xDlClose_unixDlClose_enum], sizeof(E->xDlClose_signature)) == 0) {
+ unixDlClose(args);
+ }


// Transform E->xDlError(args) to if-chain with 3 candidates
@transform_no_return_xDlError_arrow@
expression E;
identifier FP_NAME = xDlError;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xDlError_signature, xDlError_signatures[xDlError_0_enum], sizeof(E->xDlError_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xDlError_signature, xDlError_signatures[xDlError_apndDlError_enum], sizeof(E->xDlError_signature)) == 0) {
+ apndDlError(args);
+ }
+ else if (memcmp(E->xDlError_signature, xDlError_signatures[xDlError_memdbDlError_enum], sizeof(E->xDlError_signature)) == 0) {
+ memdbDlError(args);
+ }
+ else if (memcmp(E->xDlError_signature, xDlError_signatures[xDlError_unixDlError_enum], sizeof(E->xDlError_signature)) == 0) {
+ unixDlError(args);
+ }


// Transform E->xDlOpen(args) to if-chain with 3 candidates
@transform_no_return_xDlOpen_arrow@
expression E;
identifier FP_NAME = xDlOpen;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xDlOpen_signature, xDlOpen_signatures[xDlOpen_apndDlOpen_enum], sizeof(E->xDlOpen_signature)) == 0) {
+ apndDlOpen(args);
+ }
+ else if (memcmp(E->xDlOpen_signature, xDlOpen_signatures[xDlOpen_memdbDlOpen_enum], sizeof(E->xDlOpen_signature)) == 0) {
+ memdbDlOpen(args);
+ }
+ else if (memcmp(E->xDlOpen_signature, xDlOpen_signatures[xDlOpen_unixDlOpen_enum], sizeof(E->xDlOpen_signature)) == 0) {
+ unixDlOpen(args);
+ }


// Transform E->xEof(args) to if-chain with 43 candidates
@transform_no_return_xEof_arrow@
expression E;
identifier FP_NAME = xEof;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xEof_signature, xEof_signatures[xEof_amatchEof_enum], sizeof(E->xEof_signature)) == 0) {
+ amatchEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_binfoEof_enum], sizeof(E->xEof_signature)) == 0) {
+ binfoEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_bytecodevtabEof_enum], sizeof(E->xEof_signature)) == 0) {
+ bytecodevtabEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_carrayEof_enum], sizeof(E->xEof_signature)) == 0) {
+ carrayEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_cidxEof_enum], sizeof(E->xEof_signature)) == 0) {
+ cidxEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_closureEof_enum], sizeof(E->xEof_signature)) == 0) {
+ closureEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_completionEof_enum], sizeof(E->xEof_signature)) == 0) {
+ completionEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_csvtabEof_enum], sizeof(E->xEof_signature)) == 0) {
+ csvtabEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_dbdataEof_enum], sizeof(E->xEof_signature)) == 0) {
+ dbdataEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_dbpageEof_enum], sizeof(E->xEof_signature)) == 0) {
+ dbpageEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_deltaparsevtabEof_enum], sizeof(E->xEof_signature)) == 0) {
+ deltaparsevtabEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_echoEof_enum], sizeof(E->xEof_signature)) == 0) {
+ echoEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_expertEof_enum], sizeof(E->xEof_signature)) == 0) {
+ expertEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_explainEof_enum], sizeof(E->xEof_signature)) == 0) {
+ explainEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_fsEof_enum], sizeof(E->xEof_signature)) == 0) {
+ fsEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_fsdirEof_enum], sizeof(E->xEof_signature)) == 0) {
+ fsdirEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_fstreeEof_enum], sizeof(E->xEof_signature)) == 0) {
+ fstreeEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_fts3EofMethod_enum], sizeof(E->xEof_signature)) == 0) {
+ fts3EofMethod(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_fts3auxEofMethod_enum], sizeof(E->xEof_signature)) == 0) {
+ fts3auxEofMethod(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_fts3termEofMethod_enum], sizeof(E->xEof_signature)) == 0) {
+ fts3termEofMethod(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_fts3tokEofMethod_enum], sizeof(E->xEof_signature)) == 0) {
+ fts3tokEofMethod(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_fuzzerEof_enum], sizeof(E->xEof_signature)) == 0) {
+ fuzzerEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_intarrayEof_enum], sizeof(E->xEof_signature)) == 0) {
+ intarrayEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_jsonEachEof_enum], sizeof(E->xEof_signature)) == 0) {
+ jsonEachEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_memstatEof_enum], sizeof(E->xEof_signature)) == 0) {
+ memstatEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_pragmaVtabEof_enum], sizeof(E->xEof_signature)) == 0) {
+ pragmaVtabEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_prefixesEof_enum], sizeof(E->xEof_signature)) == 0) {
+ prefixesEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_qpvtabEof_enum], sizeof(E->xEof_signature)) == 0) {
+ qpvtabEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_rtreeEof_enum], sizeof(E->xEof_signature)) == 0) {
+ rtreeEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_schemaEof_enum], sizeof(E->xEof_signature)) == 0) {
+ schemaEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_seriesEof_enum], sizeof(E->xEof_signature)) == 0) {
+ seriesEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_spellfix1Eof_enum], sizeof(E->xEof_signature)) == 0) {
+ spellfix1Eof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_statEof_enum], sizeof(E->xEof_signature)) == 0) {
+ statEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_stmtEof_enum], sizeof(E->xEof_signature)) == 0) {
+ stmtEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_tclEof_enum], sizeof(E->xEof_signature)) == 0) {
+ tclEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_tclvarEof_enum], sizeof(E->xEof_signature)) == 0) {
+ tclvarEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_templatevtabEof_enum], sizeof(E->xEof_signature)) == 0) {
+ templatevtabEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_unionEof_enum], sizeof(E->xEof_signature)) == 0) {
+ unionEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_vlogEof_enum], sizeof(E->xEof_signature)) == 0) {
+ vlogEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_vstattabEof_enum], sizeof(E->xEof_signature)) == 0) {
+ vstattabEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_vtablogEof_enum], sizeof(E->xEof_signature)) == 0) {
+ vtablogEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_wholenumberEof_enum], sizeof(E->xEof_signature)) == 0) {
+ wholenumberEof(args);
+ }
+ else if (memcmp(E->xEof_signature, xEof_signatures[xEof_zipfileEof_enum], sizeof(E->xEof_signature)) == 0) {
+ zipfileEof(args);
+ }


// Transform E->xExprCallback(args) to if-chain with 37 candidates
@transform_no_return_xExprCallback_arrow@
expression E;
identifier FP_NAME = xExprCallback;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_agginfoPersistExprCb_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ agginfoPersistExprCb(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_aggregateIdxEprRefToColCallback_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ aggregateIdxEprRefToColCallback(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_analyzeAggregate_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ analyzeAggregate(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_checkConstraintExprNode_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ checkConstraintExprNode(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_codeCursorHintCheckExpr_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ codeCursorHintCheckExpr(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_codeCursorHintFixExpr_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ codeCursorHintFixExpr(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_codeCursorHintIsOrFunction_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ codeCursorHintIsOrFunction(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_disallowAggregatesInOrderByCb_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ disallowAggregatesInOrderByCb(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprColumnFlagUnion_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ exprColumnFlagUnion(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprIdxCover_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ exprIdxCover(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprNodeCanReturnSubtype_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ exprNodeCanReturnSubtype(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprNodeIsConstant_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ exprNodeIsConstant(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprNodeIsConstantOrGroupBy_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ exprNodeIsConstantOrGroupBy(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprNodeIsDeterministic_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ exprNodeIsDeterministic(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprRefToSrcList_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ exprRefToSrcList(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_fixExprCb_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ fixExprCb(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_gatherSelectWindowsCallback_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ gatherSelectWindowsCallback(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_havingToWhereExprCb_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ havingToWhereExprCb(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_impliesNotNullRow_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ impliesNotNullRow(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_incrAggDepth_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ incrAggDepth(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_markImmutableExprStep_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ markImmutableExprStep(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_propagateConstantExprRewrite_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ propagateConstantExprRewrite(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_recomputeColumnsUsedExpr_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ recomputeColumnsUsedExpr(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_renameColumnExprCb_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ renameColumnExprCb(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_renameQuotefixExprCb_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ renameQuotefixExprCb(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_renameTableExprCb_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ renameTableExprCb(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_renameUnmapExprCb_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ renameUnmapExprCb(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_renumberCursorsCb_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ renumberCursorsCb(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_resolveExprStep_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ resolveExprStep(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_resolveRemoveWindowsCb_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ resolveRemoveWindowsCb(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_selectCheckOnClausesExpr_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ selectCheckOnClausesExpr(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_selectWindowRewriteExprCb_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ selectWindowRewriteExprCb(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_sqlite3CursorRangeHintExprCheck_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ sqlite3CursorRangeHintExprCheck(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_sqlite3ExprWalkNoop_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ sqlite3ExprWalkNoop(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_sqlite3ReturningSubqueryVarSelect_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ sqlite3ReturningSubqueryVarSelect(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_sqlite3WindowExtraAggFuncDepth_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ sqlite3WindowExtraAggFuncDepth(args);
+ }
+ else if (memcmp(E->xExprCallback_signature, xExprCallback_signatures[xExprCallback_whereIsCoveringIndexWalkCallback_enum], sizeof(E->xExprCallback_signature)) == 0) {
+ whereIsCoveringIndexWalkCallback(args);
+ }


// Transform E->xFetch(args) to if-chain with 6 candidates
@transform_no_return_xFetch_arrow@
expression E;
identifier FP_NAME = xFetch;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xFetch_signature, xFetch_signatures[xFetch_0_enum], sizeof(E->xFetch_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xFetch_signature, xFetch_signatures[xFetch_apndFetch_enum], sizeof(E->xFetch_signature)) == 0) {
+ apndFetch(args);
+ }
+ else if (memcmp(E->xFetch_signature, xFetch_signatures[xFetch_memdbFetch_enum], sizeof(E->xFetch_signature)) == 0) {
+ memdbFetch(args);
+ }
+ else if (memcmp(E->xFetch_signature, xFetch_signatures[xFetch_pcache1Fetch_enum], sizeof(E->xFetch_signature)) == 0) {
+ pcache1Fetch(args);
+ }
+ else if (memcmp(E->xFetch_signature, xFetch_signatures[xFetch_pcachetraceFetch_enum], sizeof(E->xFetch_signature)) == 0) {
+ pcachetraceFetch(args);
+ }
+ else if (memcmp(E->xFetch_signature, xFetch_signatures[xFetch_recoverVfsFetch_enum], sizeof(E->xFetch_signature)) == 0) {
+ recoverVfsFetch(args);
+ }
+ else if (memcmp(E->xFetch_signature, xFetch_signatures[xFetch_unixFetch_enum], sizeof(E->xFetch_signature)) == 0) {
+ unixFetch(args);
+ }


// Transform E->xFileControl(args) to if-chain with 5 candidates
@transform_no_return_xFileControl_arrow@
expression E;
identifier FP_NAME = xFileControl;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xFileControl_signature, xFileControl_signatures[xFileControl_0_enum], sizeof(E->xFileControl_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xFileControl_signature, xFileControl_signatures[xFileControl_apndFileControl_enum], sizeof(E->xFileControl_signature)) == 0) {
+ apndFileControl(args);
+ }
+ else if (memcmp(E->xFileControl_signature, xFileControl_signatures[xFileControl_memdbFileControl_enum], sizeof(E->xFileControl_signature)) == 0) {
+ memdbFileControl(args);
+ }
+ else if (memcmp(E->xFileControl_signature, xFileControl_signatures[xFileControl_recoverVfsFileControl_enum], sizeof(E->xFileControl_signature)) == 0) {
+ recoverVfsFileControl(args);
+ }
+ else if (memcmp(E->xFileControl_signature, xFileControl_signatures[xFileControl_vfstraceFileControl_enum], sizeof(E->xFileControl_signature)) == 0) {
+ vfstraceFileControl(args);
+ }
+ else if (memcmp(E->xFileControl_signature, xFileControl_signatures[xFileControl_unixFileControl_enum], sizeof(E->xFileControl_signature)) == 0) {
+ unixFileControl(args);
+ }


// Transform E->xFileSize(args) to if-chain with 6 candidates
@transform_no_return_xFileSize_arrow@
expression E;
identifier FP_NAME = xFileSize;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xFileSize_signature, xFileSize_signatures[xFileSize_apndFileSize_enum], sizeof(E->xFileSize_signature)) == 0) {
+ apndFileSize(args);
+ }
+ else if (memcmp(E->xFileSize_signature, xFileSize_signatures[xFileSize_memdbFileSize_enum], sizeof(E->xFileSize_signature)) == 0) {
+ memdbFileSize(args);
+ }
+ else if (memcmp(E->xFileSize_signature, xFileSize_signatures[xFileSize_memjrnlFileSize_enum], sizeof(E->xFileSize_signature)) == 0) {
+ memjrnlFileSize(args);
+ }
+ else if (memcmp(E->xFileSize_signature, xFileSize_signatures[xFileSize_recoverVfsFileSize_enum], sizeof(E->xFileSize_signature)) == 0) {
+ recoverVfsFileSize(args);
+ }
+ else if (memcmp(E->xFileSize_signature, xFileSize_signatures[xFileSize_vfstraceFileSize_enum], sizeof(E->xFileSize_signature)) == 0) {
+ vfstraceFileSize(args);
+ }
+ else if (memcmp(E->xFileSize_signature, xFileSize_signatures[xFileSize_unixFileSize_enum], sizeof(E->xFileSize_signature)) == 0) {
+ unixFileSize(args);
+ }


// Transform E->xFilter(args) to if-chain with 44 candidates
@transform_no_return_xFilter_arrow@
expression E;
identifier FP_NAME = xFilter;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_amatchFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ amatchFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_binfoFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ binfoFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_bytecodevtabFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ bytecodevtabFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_carrayFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ carrayFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_cidxFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ cidxFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_closureFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ closureFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_completionFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ completionFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_csvtabFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ csvtabFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_dbdataFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ dbdataFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_dbpageFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ dbpageFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_deltaparsevtabFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ deltaparsevtabFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_echoFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ echoFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_expertFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ expertFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_explainFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ explainFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_fsFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ fsFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_fsdirFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ fsdirFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_fstreeFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ fstreeFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_fts3FilterMethod_enum], sizeof(E->xFilter_signature)) == 0) {
+ fts3FilterMethod(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_fts3auxFilterMethod_enum], sizeof(E->xFilter_signature)) == 0) {
+ fts3auxFilterMethod(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_fts3termFilterMethod_enum], sizeof(E->xFilter_signature)) == 0) {
+ fts3termFilterMethod(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_fts3tokFilterMethod_enum], sizeof(E->xFilter_signature)) == 0) {
+ fts3tokFilterMethod(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_fuzzerFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ fuzzerFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_geopolyFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ geopolyFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_intarrayFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ intarrayFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_jsonEachFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ jsonEachFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_memstatFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ memstatFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_pragmaVtabFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ pragmaVtabFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_prefixesFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ prefixesFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_qpvtabFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ qpvtabFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_rtreeFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ rtreeFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_schemaFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ schemaFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_seriesFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ seriesFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_spellfix1Filter_enum], sizeof(E->xFilter_signature)) == 0) {
+ spellfix1Filter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_statFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ statFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_stmtFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ stmtFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_tclFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ tclFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_tclvarFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ tclvarFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_templatevtabFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ templatevtabFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_unionFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ unionFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_vlogFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ vlogFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_vstattabFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ vstattabFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_vtablogFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ vtablogFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_wholenumberFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ wholenumberFilter(args);
+ }
+ else if (memcmp(E->xFilter_signature, xFilter_signatures[xFilter_zipfileFilter_enum], sizeof(E->xFilter_signature)) == 0) {
+ zipfileFilter(args);
+ }


// Transform E->xFindFunction(args) to if-chain with 2 candidates
@transform_no_return_xFindFunction_arrow@
expression E;
identifier FP_NAME = xFindFunction;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xFindFunction_signature, xFindFunction_signatures[xFindFunction_0_enum], sizeof(E->xFindFunction_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xFindFunction_signature, xFindFunction_signatures[xFindFunction_fts3FindFunctionMethod_enum], sizeof(E->xFindFunction_signature)) == 0) {
+ fts3FindFunctionMethod(args);
+ }
+ else if (memcmp(E->xFindFunction_signature, xFindFunction_signatures[xFindFunction_zipfileFindFunction_enum], sizeof(E->xFindFunction_signature)) == 0) {
+ zipfileFindFunction(args);
+ }


// Transform E->xFree(args) to if-chain with 2 candidates
@transform_no_return_xFree_arrow@
expression E;
identifier FP_NAME = xFree;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xFree_signature, xFree_signatures[xFree_memtraceFree_enum], sizeof(E->xFree_signature)) == 0) {
+ memtraceFree(args);
+ }
+ else if (memcmp(E->xFree_signature, xFree_signatures[xFree_sqlite3MemFree_enum], sizeof(E->xFree_signature)) == 0) {
+ sqlite3MemFree(args);
+ }


// Transform E->xFullPathname(args) to if-chain with 4 candidates
@transform_no_return_xFullPathname_arrow@
expression E;
identifier FP_NAME = xFullPathname;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xFullPathname_signature, xFullPathname_signatures[xFullPathname_apndFullPathname_enum], sizeof(E->xFullPathname_signature)) == 0) {
+ apndFullPathname(args);
+ }
+ else if (memcmp(E->xFullPathname_signature, xFullPathname_signatures[xFullPathname_memdbFullPathname_enum], sizeof(E->xFullPathname_signature)) == 0) {
+ memdbFullPathname(args);
+ }
+ else if (memcmp(E->xFullPathname_signature, xFullPathname_signatures[xFullPathname_vfstraceFullPathname_enum], sizeof(E->xFullPathname_signature)) == 0) {
+ vfstraceFullPathname(args);
+ }
+ else if (memcmp(E->xFullPathname_signature, xFullPathname_signatures[xFullPathname_unixFullPathname_enum], sizeof(E->xFullPathname_signature)) == 0) {
+ unixFullPathname(args);
+ }


// Transform E->xGet(args) to if-chain with 3 candidates
@transform_no_return_xGet_arrow@
expression E;
identifier FP_NAME = xGet;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xGet_signature, xGet_signatures[xGet_getPageError_enum], sizeof(E->xGet_signature)) == 0) {
+ getPageError(args);
+ }
+ else if (memcmp(E->xGet_signature, xGet_signatures[xGet_getPageMMap_enum], sizeof(E->xGet_signature)) == 0) {
+ getPageMMap(args);
+ }
+ else if (memcmp(E->xGet_signature, xGet_signatures[xGet_getPageNormal_enum], sizeof(E->xGet_signature)) == 0) {
+ getPageNormal(args);
+ }


// Transform E->xGetLastError(args) to if-chain with 3 candidates
@transform_no_return_xGetLastError_arrow@
expression E;
identifier FP_NAME = xGetLastError;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xGetLastError_signature, xGetLastError_signatures[xGetLastError_0_enum], sizeof(E->xGetLastError_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xGetLastError_signature, xGetLastError_signatures[xGetLastError_apndGetLastError_enum], sizeof(E->xGetLastError_signature)) == 0) {
+ apndGetLastError(args);
+ }
+ else if (memcmp(E->xGetLastError_signature, xGetLastError_signatures[xGetLastError_memdbGetLastError_enum], sizeof(E->xGetLastError_signature)) == 0) {
+ memdbGetLastError(args);
+ }
+ else if (memcmp(E->xGetLastError_signature, xGetLastError_signatures[xGetLastError_unixGetLastError_enum], sizeof(E->xGetLastError_signature)) == 0) {
+ unixGetLastError(args);
+ }


// Transform E->xGetSystemCall(args) to if-chain with 2 candidates
@transform_no_return_xGetSystemCall_arrow@
expression E;
identifier FP_NAME = xGetSystemCall;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xGetSystemCall_signature, xGetSystemCall_signatures[xGetSystemCall_0_enum], sizeof(E->xGetSystemCall_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xGetSystemCall_signature, xGetSystemCall_signatures[xGetSystemCall_apndGetSystemCall_enum], sizeof(E->xGetSystemCall_signature)) == 0) {
+ apndGetSystemCall(args);
+ }
+ else if (memcmp(E->xGetSystemCall_signature, xGetSystemCall_signatures[xGetSystemCall_unixGetSystemCall_enum], sizeof(E->xGetSystemCall_signature)) == 0) {
+ unixGetSystemCall(args);
+ }


// Transform E->xInit(args) to if-chain with 4 candidates
@transform_no_return_xInit_arrow@
expression E;
identifier FP_NAME = xInit;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xInit_signature, xInit_signatures[xInit_memtraceInit_enum], sizeof(E->xInit_signature)) == 0) {
+ memtraceInit(args);
+ }
+ else if (memcmp(E->xInit_signature, xInit_signatures[xInit_pcache1Init_enum], sizeof(E->xInit_signature)) == 0) {
+ pcache1Init(args);
+ }
+ else if (memcmp(E->xInit_signature, xInit_signatures[xInit_pcachetraceInit_enum], sizeof(E->xInit_signature)) == 0) {
+ pcachetraceInit(args);
+ }
+ else if (memcmp(E->xInit_signature, xInit_signatures[xInit_sqlite3MemInit_enum], sizeof(E->xInit_signature)) == 0) {
+ sqlite3MemInit(args);
+ }


// Transform E->xIntegrity(args) to if-chain with 3 candidates
@transform_no_return_xIntegrity_arrow@
expression E;
identifier FP_NAME = xIntegrity;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xIntegrity_signature, xIntegrity_signatures[xIntegrity_0_enum], sizeof(E->xIntegrity_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xIntegrity_signature, xIntegrity_signatures[xIntegrity_fts3IntegrityMethod_enum], sizeof(E->xIntegrity_signature)) == 0) {
+ fts3IntegrityMethod(args);
+ }
+ else if (memcmp(E->xIntegrity_signature, xIntegrity_signatures[xIntegrity_rtreeIntegrity_enum], sizeof(E->xIntegrity_signature)) == 0) {
+ rtreeIntegrity(args);
+ }
+ else if (memcmp(E->xIntegrity_signature, xIntegrity_signatures[xIntegrity_vtablogIntegrity_enum], sizeof(E->xIntegrity_signature)) == 0) {
+ vtablogIntegrity(args);
+ }


// Transform E->xLock(args) to if-chain with 7 candidates
@transform_no_return_xLock_arrow@
expression E;
identifier FP_NAME = xLock;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xLock_signature, xLock_signatures[xLock_0_enum], sizeof(E->xLock_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xLock_signature, xLock_signatures[xLock_apndLock_enum], sizeof(E->xLock_signature)) == 0) {
+ apndLock(args);
+ }
+ else if (memcmp(E->xLock_signature, xLock_signatures[xLock_memdbLock_enum], sizeof(E->xLock_signature)) == 0) {
+ memdbLock(args);
+ }
+ else if (memcmp(E->xLock_signature, xLock_signatures[xLock_recoverVfsLock_enum], sizeof(E->xLock_signature)) == 0) {
+ recoverVfsLock(args);
+ }
+ else if (memcmp(E->xLock_signature, xLock_signatures[xLock_vfstraceLock_enum], sizeof(E->xLock_signature)) == 0) {
+ vfstraceLock(args);
+ }
+ else if (memcmp(E->xLock_signature, xLock_signatures[xLock_unixLock_enum], sizeof(E->xLock_signature)) == 0) {
+ unixLock(args);
+ }
+ else if (memcmp(E->xLock_signature, xLock_signatures[xLock_nolockLock_enum], sizeof(E->xLock_signature)) == 0) {
+ nolockLock(args);
+ }
+ else if (memcmp(E->xLock_signature, xLock_signatures[xLock_dotlockLock_enum], sizeof(E->xLock_signature)) == 0) {
+ dotlockLock(args);
+ }


// Transform E->xMalloc(args) to if-chain with 2 candidates
@transform_no_return_xMalloc_arrow@
expression E;
identifier FP_NAME = xMalloc;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xMalloc_signature, xMalloc_signatures[xMalloc_memtraceMalloc_enum], sizeof(E->xMalloc_signature)) == 0) {
+ memtraceMalloc(args);
+ }
+ else if (memcmp(E->xMalloc_signature, xMalloc_signatures[xMalloc_sqlite3MemMalloc_enum], sizeof(E->xMalloc_signature)) == 0) {
+ sqlite3MemMalloc(args);
+ }


// Transform E->xMutexAlloc(args) to if-chain with 7 candidates
@transform_no_return_xMutexAlloc_arrow@
expression E;
identifier FP_NAME = xMutexAlloc;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_checkMutexAlloc_enum], sizeof(E->xMutexAlloc_signature)) == 0) {
+ checkMutexAlloc(args);
+ }
+ else if (memcmp(E->xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_counterMutexAlloc_enum], sizeof(E->xMutexAlloc_signature)) == 0) {
+ counterMutexAlloc(args);
+ }
+ else if (memcmp(E->xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_debugMutexAlloc_enum], sizeof(E->xMutexAlloc_signature)) == 0) {
+ debugMutexAlloc(args);
+ }
+ else if (memcmp(E->xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_noopMutexAlloc_enum], sizeof(E->xMutexAlloc_signature)) == 0) {
+ noopMutexAlloc(args);
+ }
+ else if (memcmp(E->xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_pthreadMutexAlloc_enum], sizeof(E->xMutexAlloc_signature)) == 0) {
+ pthreadMutexAlloc(args);
+ }
+ else if (memcmp(E->xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_winMutexAlloc_enum], sizeof(E->xMutexAlloc_signature)) == 0) {
+ winMutexAlloc(args);
+ }
+ else if (memcmp(E->xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_wrMutexAlloc_enum], sizeof(E->xMutexAlloc_signature)) == 0) {
+ wrMutexAlloc(args);
+ }


// Transform E->xMutexEnd(args) to if-chain with 7 candidates
@transform_no_return_xMutexEnd_arrow@
expression E;
identifier FP_NAME = xMutexEnd;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_checkMutexEnd_enum], sizeof(E->xMutexEnd_signature)) == 0) {
+ checkMutexEnd(args);
+ }
+ else if (memcmp(E->xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_counterMutexEnd_enum], sizeof(E->xMutexEnd_signature)) == 0) {
+ counterMutexEnd(args);
+ }
+ else if (memcmp(E->xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_debugMutexEnd_enum], sizeof(E->xMutexEnd_signature)) == 0) {
+ debugMutexEnd(args);
+ }
+ else if (memcmp(E->xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_noopMutexEnd_enum], sizeof(E->xMutexEnd_signature)) == 0) {
+ noopMutexEnd(args);
+ }
+ else if (memcmp(E->xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_pthreadMutexEnd_enum], sizeof(E->xMutexEnd_signature)) == 0) {
+ pthreadMutexEnd(args);
+ }
+ else if (memcmp(E->xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_winMutexEnd_enum], sizeof(E->xMutexEnd_signature)) == 0) {
+ winMutexEnd(args);
+ }
+ else if (memcmp(E->xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_wrMutexEnd_enum], sizeof(E->xMutexEnd_signature)) == 0) {
+ wrMutexEnd(args);
+ }


// Transform E->xMutexEnter(args) to if-chain with 7 candidates
@transform_no_return_xMutexEnter_arrow@
expression E;
identifier FP_NAME = xMutexEnter;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_checkMutexEnter_enum], sizeof(E->xMutexEnter_signature)) == 0) {
+ checkMutexEnter(args);
+ }
+ else if (memcmp(E->xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_counterMutexEnter_enum], sizeof(E->xMutexEnter_signature)) == 0) {
+ counterMutexEnter(args);
+ }
+ else if (memcmp(E->xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_debugMutexEnter_enum], sizeof(E->xMutexEnter_signature)) == 0) {
+ debugMutexEnter(args);
+ }
+ else if (memcmp(E->xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_noopMutexEnter_enum], sizeof(E->xMutexEnter_signature)) == 0) {
+ noopMutexEnter(args);
+ }
+ else if (memcmp(E->xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_pthreadMutexEnter_enum], sizeof(E->xMutexEnter_signature)) == 0) {
+ pthreadMutexEnter(args);
+ }
+ else if (memcmp(E->xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_winMutexEnter_enum], sizeof(E->xMutexEnter_signature)) == 0) {
+ winMutexEnter(args);
+ }
+ else if (memcmp(E->xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_wrMutexEnter_enum], sizeof(E->xMutexEnter_signature)) == 0) {
+ wrMutexEnter(args);
+ }


// Transform E->xMutexFree(args) to if-chain with 7 candidates
@transform_no_return_xMutexFree_arrow@
expression E;
identifier FP_NAME = xMutexFree;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xMutexFree_signature, xMutexFree_signatures[xMutexFree_checkMutexFree_enum], sizeof(E->xMutexFree_signature)) == 0) {
+ checkMutexFree(args);
+ }
+ else if (memcmp(E->xMutexFree_signature, xMutexFree_signatures[xMutexFree_counterMutexFree_enum], sizeof(E->xMutexFree_signature)) == 0) {
+ counterMutexFree(args);
+ }
+ else if (memcmp(E->xMutexFree_signature, xMutexFree_signatures[xMutexFree_debugMutexFree_enum], sizeof(E->xMutexFree_signature)) == 0) {
+ debugMutexFree(args);
+ }
+ else if (memcmp(E->xMutexFree_signature, xMutexFree_signatures[xMutexFree_noopMutexFree_enum], sizeof(E->xMutexFree_signature)) == 0) {
+ noopMutexFree(args);
+ }
+ else if (memcmp(E->xMutexFree_signature, xMutexFree_signatures[xMutexFree_pthreadMutexFree_enum], sizeof(E->xMutexFree_signature)) == 0) {
+ pthreadMutexFree(args);
+ }
+ else if (memcmp(E->xMutexFree_signature, xMutexFree_signatures[xMutexFree_winMutexFree_enum], sizeof(E->xMutexFree_signature)) == 0) {
+ winMutexFree(args);
+ }
+ else if (memcmp(E->xMutexFree_signature, xMutexFree_signatures[xMutexFree_wrMutexFree_enum], sizeof(E->xMutexFree_signature)) == 0) {
+ wrMutexFree(args);
+ }


// Transform E->xMutexHeld(args) to if-chain with 3 candidates
@transform_no_return_xMutexHeld_arrow@
expression E;
identifier FP_NAME = xMutexHeld;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xMutexHeld_signature, xMutexHeld_signatures[xMutexHeld_0_enum], sizeof(E->xMutexHeld_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xMutexHeld_signature, xMutexHeld_signatures[xMutexHeld_counterMutexHeld_enum], sizeof(E->xMutexHeld_signature)) == 0) {
+ counterMutexHeld(args);
+ }
+ else if (memcmp(E->xMutexHeld_signature, xMutexHeld_signatures[xMutexHeld_debugMutexHeld_enum], sizeof(E->xMutexHeld_signature)) == 0) {
+ debugMutexHeld(args);
+ }
+ else if (memcmp(E->xMutexHeld_signature, xMutexHeld_signatures[xMutexHeld_wrMutexHeld_enum], sizeof(E->xMutexHeld_signature)) == 0) {
+ wrMutexHeld(args);
+ }


// Transform E->xMutexInit(args) to if-chain with 7 candidates
@transform_no_return_xMutexInit_arrow@
expression E;
identifier FP_NAME = xMutexInit;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xMutexInit_signature, xMutexInit_signatures[xMutexInit_checkMutexInit_enum], sizeof(E->xMutexInit_signature)) == 0) {
+ checkMutexInit(args);
+ }
+ else if (memcmp(E->xMutexInit_signature, xMutexInit_signatures[xMutexInit_counterMutexInit_enum], sizeof(E->xMutexInit_signature)) == 0) {
+ counterMutexInit(args);
+ }
+ else if (memcmp(E->xMutexInit_signature, xMutexInit_signatures[xMutexInit_debugMutexInit_enum], sizeof(E->xMutexInit_signature)) == 0) {
+ debugMutexInit(args);
+ }
+ else if (memcmp(E->xMutexInit_signature, xMutexInit_signatures[xMutexInit_noopMutexInit_enum], sizeof(E->xMutexInit_signature)) == 0) {
+ noopMutexInit(args);
+ }
+ else if (memcmp(E->xMutexInit_signature, xMutexInit_signatures[xMutexInit_pthreadMutexInit_enum], sizeof(E->xMutexInit_signature)) == 0) {
+ pthreadMutexInit(args);
+ }
+ else if (memcmp(E->xMutexInit_signature, xMutexInit_signatures[xMutexInit_winMutexInit_enum], sizeof(E->xMutexInit_signature)) == 0) {
+ winMutexInit(args);
+ }
+ else if (memcmp(E->xMutexInit_signature, xMutexInit_signatures[xMutexInit_wrMutexInit_enum], sizeof(E->xMutexInit_signature)) == 0) {
+ wrMutexInit(args);
+ }


// Transform E->xMutexLeave(args) to if-chain with 7 candidates
@transform_no_return_xMutexLeave_arrow@
expression E;
identifier FP_NAME = xMutexLeave;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_checkMutexLeave_enum], sizeof(E->xMutexLeave_signature)) == 0) {
+ checkMutexLeave(args);
+ }
+ else if (memcmp(E->xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_counterMutexLeave_enum], sizeof(E->xMutexLeave_signature)) == 0) {
+ counterMutexLeave(args);
+ }
+ else if (memcmp(E->xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_debugMutexLeave_enum], sizeof(E->xMutexLeave_signature)) == 0) {
+ debugMutexLeave(args);
+ }
+ else if (memcmp(E->xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_noopMutexLeave_enum], sizeof(E->xMutexLeave_signature)) == 0) {
+ noopMutexLeave(args);
+ }
+ else if (memcmp(E->xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_pthreadMutexLeave_enum], sizeof(E->xMutexLeave_signature)) == 0) {
+ pthreadMutexLeave(args);
+ }
+ else if (memcmp(E->xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_winMutexLeave_enum], sizeof(E->xMutexLeave_signature)) == 0) {
+ winMutexLeave(args);
+ }
+ else if (memcmp(E->xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_wrMutexLeave_enum], sizeof(E->xMutexLeave_signature)) == 0) {
+ wrMutexLeave(args);
+ }


// Transform E->xMutexNotheld(args) to if-chain with 3 candidates
@transform_no_return_xMutexNotheld_arrow@
expression E;
identifier FP_NAME = xMutexNotheld;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xMutexNotheld_signature, xMutexNotheld_signatures[xMutexNotheld_0_enum], sizeof(E->xMutexNotheld_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xMutexNotheld_signature, xMutexNotheld_signatures[xMutexNotheld_counterMutexNotheld_enum], sizeof(E->xMutexNotheld_signature)) == 0) {
+ counterMutexNotheld(args);
+ }
+ else if (memcmp(E->xMutexNotheld_signature, xMutexNotheld_signatures[xMutexNotheld_debugMutexNotheld_enum], sizeof(E->xMutexNotheld_signature)) == 0) {
+ debugMutexNotheld(args);
+ }
+ else if (memcmp(E->xMutexNotheld_signature, xMutexNotheld_signatures[xMutexNotheld_wrMutexNotheld_enum], sizeof(E->xMutexNotheld_signature)) == 0) {
+ wrMutexNotheld(args);
+ }


// Transform E->xMutexTry(args) to if-chain with 7 candidates
@transform_no_return_xMutexTry_arrow@
expression E;
identifier FP_NAME = xMutexTry;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xMutexTry_signature, xMutexTry_signatures[xMutexTry_checkMutexTry_enum], sizeof(E->xMutexTry_signature)) == 0) {
+ checkMutexTry(args);
+ }
+ else if (memcmp(E->xMutexTry_signature, xMutexTry_signatures[xMutexTry_counterMutexTry_enum], sizeof(E->xMutexTry_signature)) == 0) {
+ counterMutexTry(args);
+ }
+ else if (memcmp(E->xMutexTry_signature, xMutexTry_signatures[xMutexTry_debugMutexTry_enum], sizeof(E->xMutexTry_signature)) == 0) {
+ debugMutexTry(args);
+ }
+ else if (memcmp(E->xMutexTry_signature, xMutexTry_signatures[xMutexTry_noopMutexTry_enum], sizeof(E->xMutexTry_signature)) == 0) {
+ noopMutexTry(args);
+ }
+ else if (memcmp(E->xMutexTry_signature, xMutexTry_signatures[xMutexTry_pthreadMutexTry_enum], sizeof(E->xMutexTry_signature)) == 0) {
+ pthreadMutexTry(args);
+ }
+ else if (memcmp(E->xMutexTry_signature, xMutexTry_signatures[xMutexTry_winMutexTry_enum], sizeof(E->xMutexTry_signature)) == 0) {
+ winMutexTry(args);
+ }
+ else if (memcmp(E->xMutexTry_signature, xMutexTry_signatures[xMutexTry_wrMutexTry_enum], sizeof(E->xMutexTry_signature)) == 0) {
+ wrMutexTry(args);
+ }


// Transform E->xNew(args) to if-chain with 3 candidates
@transform_no_return_xNew_arrow@
expression E;
identifier FP_NAME = xNew;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xNew_signature, xNew_signatures[xNew_sessionDiffNew_enum], sizeof(E->xNew_signature)) == 0) {
+ sessionDiffNew(args);
+ }
+ else if (memcmp(E->xNew_signature, xNew_signatures[xNew_sessionPreupdateNew_enum], sizeof(E->xNew_signature)) == 0) {
+ sessionPreupdateNew(args);
+ }
+ else if (memcmp(E->xNew_signature, xNew_signatures[xNew_sessionStat1New_enum], sizeof(E->xNew_signature)) == 0) {
+ sessionStat1New(args);
+ }


// Transform E->xNext(args) to if-chain with 46 candidates
@transform_no_return_xNext_arrow@
expression E;
identifier FP_NAME = xNext;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xNext_signature, xNext_signatures[xNext_0_enum], sizeof(E->xNext_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_amatchNext_enum], sizeof(E->xNext_signature)) == 0) {
+ amatchNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_binfoNext_enum], sizeof(E->xNext_signature)) == 0) {
+ binfoNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_bytecodevtabNext_enum], sizeof(E->xNext_signature)) == 0) {
+ bytecodevtabNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_carrayNext_enum], sizeof(E->xNext_signature)) == 0) {
+ carrayNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_cidxNext_enum], sizeof(E->xNext_signature)) == 0) {
+ cidxNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_closureNext_enum], sizeof(E->xNext_signature)) == 0) {
+ closureNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_completionNext_enum], sizeof(E->xNext_signature)) == 0) {
+ completionNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_csvtabNext_enum], sizeof(E->xNext_signature)) == 0) {
+ csvtabNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_dbdataNext_enum], sizeof(E->xNext_signature)) == 0) {
+ dbdataNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_dbpageNext_enum], sizeof(E->xNext_signature)) == 0) {
+ dbpageNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_deltaparsevtabNext_enum], sizeof(E->xNext_signature)) == 0) {
+ deltaparsevtabNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_echoNext_enum], sizeof(E->xNext_signature)) == 0) {
+ echoNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_expertNext_enum], sizeof(E->xNext_signature)) == 0) {
+ expertNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_explainNext_enum], sizeof(E->xNext_signature)) == 0) {
+ explainNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_fsNext_enum], sizeof(E->xNext_signature)) == 0) {
+ fsNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_fsdirNext_enum], sizeof(E->xNext_signature)) == 0) {
+ fsdirNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_fstreeNext_enum], sizeof(E->xNext_signature)) == 0) {
+ fstreeNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_fts3NextMethod_enum], sizeof(E->xNext_signature)) == 0) {
+ fts3NextMethod(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_fts3auxNextMethod_enum], sizeof(E->xNext_signature)) == 0) {
+ fts3auxNextMethod(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_fts3termNextMethod_enum], sizeof(E->xNext_signature)) == 0) {
+ fts3termNextMethod(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_fts3tokNextMethod_enum], sizeof(E->xNext_signature)) == 0) {
+ fts3tokNextMethod(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_fuzzerNext_enum], sizeof(E->xNext_signature)) == 0) {
+ fuzzerNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_intarrayNext_enum], sizeof(E->xNext_signature)) == 0) {
+ intarrayNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_jsonEachNext_enum], sizeof(E->xNext_signature)) == 0) {
+ jsonEachNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_memstatNext_enum], sizeof(E->xNext_signature)) == 0) {
+ memstatNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_porterNext_enum], sizeof(E->xNext_signature)) == 0) {
+ porterNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_pragmaVtabNext_enum], sizeof(E->xNext_signature)) == 0) {
+ pragmaVtabNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_prefixesNext_enum], sizeof(E->xNext_signature)) == 0) {
+ prefixesNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_qpvtabNext_enum], sizeof(E->xNext_signature)) == 0) {
+ qpvtabNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_rtreeNext_enum], sizeof(E->xNext_signature)) == 0) {
+ rtreeNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_schemaNext_enum], sizeof(E->xNext_signature)) == 0) {
+ schemaNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_seriesNext_enum], sizeof(E->xNext_signature)) == 0) {
+ seriesNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_simpleNext_enum], sizeof(E->xNext_signature)) == 0) {
+ simpleNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_spellfix1Next_enum], sizeof(E->xNext_signature)) == 0) {
+ spellfix1Next(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_statNext_enum], sizeof(E->xNext_signature)) == 0) {
+ statNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_stmtNext_enum], sizeof(E->xNext_signature)) == 0) {
+ stmtNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_tclNext_enum], sizeof(E->xNext_signature)) == 0) {
+ tclNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_tclvarNext_enum], sizeof(E->xNext_signature)) == 0) {
+ tclvarNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_templatevtabNext_enum], sizeof(E->xNext_signature)) == 0) {
+ templatevtabNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_unicodeNext_enum], sizeof(E->xNext_signature)) == 0) {
+ unicodeNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_unionNext_enum], sizeof(E->xNext_signature)) == 0) {
+ unionNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_vlogNext_enum], sizeof(E->xNext_signature)) == 0) {
+ vlogNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_vstattabNext_enum], sizeof(E->xNext_signature)) == 0) {
+ vstattabNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_vtablogNext_enum], sizeof(E->xNext_signature)) == 0) {
+ vtablogNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_wholenumberNext_enum], sizeof(E->xNext_signature)) == 0) {
+ wholenumberNext(args);
+ }
+ else if (memcmp(E->xNext_signature, xNext_signatures[xNext_zipfileNext_enum], sizeof(E->xNext_signature)) == 0) {
+ zipfileNext(args);
+ }


// Transform E->xNextSystemCall(args) to if-chain with 3 candidates
@transform_no_return_xNextSystemCall_arrow@
expression E;
identifier FP_NAME = xNextSystemCall;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xNextSystemCall_signature, xNextSystemCall_signatures[xNextSystemCall_0_enum], sizeof(E->xNextSystemCall_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xNextSystemCall_signature, xNextSystemCall_signatures[xNextSystemCall_apndNextSystemCall_enum], sizeof(E->xNextSystemCall_signature)) == 0) {
+ apndNextSystemCall(args);
+ }
+ else if (memcmp(E->xNextSystemCall_signature, xNextSystemCall_signatures[xNextSystemCall_rbuVfsGetLastError_enum], sizeof(E->xNextSystemCall_signature)) == 0) {
+ rbuVfsGetLastError(args);
+ }
+ else if (memcmp(E->xNextSystemCall_signature, xNextSystemCall_signatures[xNextSystemCall_unixNextSystemCall_enum], sizeof(E->xNextSystemCall_signature)) == 0) {
+ unixNextSystemCall(args);
+ }


// Transform E->xOld(args) to if-chain with 3 candidates
@transform_no_return_xOld_arrow@
expression E;
identifier FP_NAME = xOld;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xOld_signature, xOld_signatures[xOld_sessionDiffOld_enum], sizeof(E->xOld_signature)) == 0) {
+ sessionDiffOld(args);
+ }
+ else if (memcmp(E->xOld_signature, xOld_signatures[xOld_sessionPreupdateOld_enum], sizeof(E->xOld_signature)) == 0) {
+ sessionPreupdateOld(args);
+ }
+ else if (memcmp(E->xOld_signature, xOld_signatures[xOld_sessionStat1Old_enum], sizeof(E->xOld_signature)) == 0) {
+ sessionStat1Old(args);
+ }


// Transform E->xOpen(args) to if-chain with 51 candidates
@transform_no_return_xOpen_arrow@
expression E;
identifier FP_NAME = xOpen;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_amatchOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ amatchOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_apndOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ apndOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_binfoOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ binfoOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_bytecodevtabOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ bytecodevtabOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_carrayOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ carrayOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_cidxOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ cidxOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_closureOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ closureOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_completionOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ completionOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_csvtabOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ csvtabOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_dbdataOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ dbdataOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_dbpageOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ dbpageOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_deltaparsevtabOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ deltaparsevtabOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_echoOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ echoOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_expertOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ expertOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_explainOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ explainOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_fsOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ fsOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_fsdirOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ fsdirOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_fstreeOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ fstreeOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_fts3OpenMethod_enum], sizeof(E->xOpen_signature)) == 0) {
+ fts3OpenMethod(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_fts3auxOpenMethod_enum], sizeof(E->xOpen_signature)) == 0) {
+ fts3auxOpenMethod(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_fts3termOpenMethod_enum], sizeof(E->xOpen_signature)) == 0) {
+ fts3termOpenMethod(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_fts3tokOpenMethod_enum], sizeof(E->xOpen_signature)) == 0) {
+ fts3tokOpenMethod(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_fuzzerOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ fuzzerOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_intarrayOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ intarrayOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_jsonEachOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ jsonEachOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_jsonEachOpenEach_enum], sizeof(E->xOpen_signature)) == 0) {
+ jsonEachOpenEach(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_jsonEachOpenTree_enum], sizeof(E->xOpen_signature)) == 0) {
+ jsonEachOpenTree(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_memdbOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ memdbOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_memstatOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ memstatOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_porterOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ porterOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_pragmaVtabOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ pragmaVtabOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_prefixesOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ prefixesOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_qpvtabOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ qpvtabOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_rtreeOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ rtreeOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_schemaOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ schemaOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_seriesOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ seriesOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_simpleOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ simpleOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_spellfix1Open_enum], sizeof(E->xOpen_signature)) == 0) {
+ spellfix1Open(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_statOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ statOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_stmtOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ stmtOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_tclOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ tclOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_tclvarOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ tclvarOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_templatevtabOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ templatevtabOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_unicodeOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ unicodeOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_unionOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ unionOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_vfstraceOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ vfstraceOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_vstattabOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ vstattabOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_vtablogOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ vtablogOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_wholenumberOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ wholenumberOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_zipfileOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ zipfileOpen(args);
+ }
+ else if (memcmp(E->xOpen_signature, xOpen_signatures[xOpen_unixOpen_enum], sizeof(E->xOpen_signature)) == 0) {
+ unixOpen(args);
+ }


// Transform E->xPagecount(args) to if-chain with 2 candidates
@transform_no_return_xPagecount_arrow@
expression E;
identifier FP_NAME = xPagecount;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xPagecount_signature, xPagecount_signatures[xPagecount_pcache1Pagecount_enum], sizeof(E->xPagecount_signature)) == 0) {
+ pcache1Pagecount(args);
+ }
+ else if (memcmp(E->xPagecount_signature, xPagecount_signatures[xPagecount_pcachetracePagecount_enum], sizeof(E->xPagecount_signature)) == 0) {
+ pcachetracePagecount(args);
+ }


// Transform E->xParseCell(args) to if-chain with 3 candidates
@transform_no_return_xParseCell_arrow@
expression E;
identifier FP_NAME = xParseCell;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xParseCell_signature, xParseCell_signatures[xParseCell_btreeParseCellPtr_enum], sizeof(E->xParseCell_signature)) == 0) {
+ btreeParseCellPtr(args);
+ }
+ else if (memcmp(E->xParseCell_signature, xParseCell_signatures[xParseCell_btreeParseCellPtrIndex_enum], sizeof(E->xParseCell_signature)) == 0) {
+ btreeParseCellPtrIndex(args);
+ }
+ else if (memcmp(E->xParseCell_signature, xParseCell_signatures[xParseCell_btreeParseCellPtrNoPayload_enum], sizeof(E->xParseCell_signature)) == 0) {
+ btreeParseCellPtrNoPayload(args);
+ }


// Transform E->xRandomness(args) to if-chain with 4 candidates
@transform_no_return_xRandomness_arrow@
expression E;
identifier FP_NAME = xRandomness;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xRandomness_signature, xRandomness_signatures[xRandomness_apndRandomness_enum], sizeof(E->xRandomness_signature)) == 0) {
+ apndRandomness(args);
+ }
+ else if (memcmp(E->xRandomness_signature, xRandomness_signatures[xRandomness_memdbRandomness_enum], sizeof(E->xRandomness_signature)) == 0) {
+ memdbRandomness(args);
+ }
+ else if (memcmp(E->xRandomness_signature, xRandomness_signatures[xRandomness_vfstraceRandomness_enum], sizeof(E->xRandomness_signature)) == 0) {
+ vfstraceRandomness(args);
+ }
+ else if (memcmp(E->xRandomness_signature, xRandomness_signatures[xRandomness_unixRandomness_enum], sizeof(E->xRandomness_signature)) == 0) {
+ unixRandomness(args);
+ }


// Transform E->xRead(args) to if-chain with 6 candidates
@transform_no_return_xRead_arrow@
expression E;
identifier FP_NAME = xRead;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xRead_signature, xRead_signatures[xRead_apndRead_enum], sizeof(E->xRead_signature)) == 0) {
+ apndRead(args);
+ }
+ else if (memcmp(E->xRead_signature, xRead_signatures[xRead_memdbRead_enum], sizeof(E->xRead_signature)) == 0) {
+ memdbRead(args);
+ }
+ else if (memcmp(E->xRead_signature, xRead_signatures[xRead_memjrnlRead_enum], sizeof(E->xRead_signature)) == 0) {
+ memjrnlRead(args);
+ }
+ else if (memcmp(E->xRead_signature, xRead_signatures[xRead_recoverVfsRead_enum], sizeof(E->xRead_signature)) == 0) {
+ recoverVfsRead(args);
+ }
+ else if (memcmp(E->xRead_signature, xRead_signatures[xRead_vfstraceRead_enum], sizeof(E->xRead_signature)) == 0) {
+ vfstraceRead(args);
+ }
+ else if (memcmp(E->xRead_signature, xRead_signatures[xRead_unixRead_enum], sizeof(E->xRead_signature)) == 0) {
+ unixRead(args);
+ }


// Transform E->xRealloc(args) to if-chain with 2 candidates
@transform_no_return_xRealloc_arrow@
expression E;
identifier FP_NAME = xRealloc;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xRealloc_signature, xRealloc_signatures[xRealloc_memtraceRealloc_enum], sizeof(E->xRealloc_signature)) == 0) {
+ memtraceRealloc(args);
+ }
+ else if (memcmp(E->xRealloc_signature, xRealloc_signatures[xRealloc_sqlite3MemRealloc_enum], sizeof(E->xRealloc_signature)) == 0) {
+ sqlite3MemRealloc(args);
+ }


// Transform E->xRekey(args) to if-chain with 3 candidates
@transform_no_return_xRekey_arrow@
expression E;
identifier FP_NAME = xRekey;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xRekey_signature, xRekey_signatures[xRekey_pcache1Rekey_enum], sizeof(E->xRekey_signature)) == 0) {
+ pcache1Rekey(args);
+ }
+ else if (memcmp(E->xRekey_signature, xRekey_signatures[xRekey_pcachetraceRekey_enum], sizeof(E->xRekey_signature)) == 0) {
+ pcachetraceRekey(args);
+ }
+ else if (memcmp(E->xRekey_signature, xRekey_signatures[xRekey_unixRandomness_enum], sizeof(E->xRekey_signature)) == 0) {
+ unixRandomness(args);
+ }


// Transform E->xRelease(args) to if-chain with 3 candidates
@transform_no_return_xRelease_arrow@
expression E;
identifier FP_NAME = xRelease;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xRelease_signature, xRelease_signatures[xRelease_0_enum], sizeof(E->xRelease_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xRelease_signature, xRelease_signatures[xRelease_echoRelease_enum], sizeof(E->xRelease_signature)) == 0) {
+ echoRelease(args);
+ }
+ else if (memcmp(E->xRelease_signature, xRelease_signatures[xRelease_fts3ReleaseMethod_enum], sizeof(E->xRelease_signature)) == 0) {
+ fts3ReleaseMethod(args);
+ }
+ else if (memcmp(E->xRelease_signature, xRelease_signatures[xRelease_vtablogRelease_enum], sizeof(E->xRelease_signature)) == 0) {
+ vtablogRelease(args);
+ }


// Transform E->xRename(args) to if-chain with 5 candidates
@transform_no_return_xRename_arrow@
expression E;
identifier FP_NAME = xRename;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xRename_signature, xRename_signatures[xRename_0_enum], sizeof(E->xRename_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xRename_signature, xRename_signatures[xRename_echoRename_enum], sizeof(E->xRename_signature)) == 0) {
+ echoRename(args);
+ }
+ else if (memcmp(E->xRename_signature, xRename_signatures[xRename_fts3RenameMethod_enum], sizeof(E->xRename_signature)) == 0) {
+ fts3RenameMethod(args);
+ }
+ else if (memcmp(E->xRename_signature, xRename_signatures[xRename_rtreeRename_enum], sizeof(E->xRename_signature)) == 0) {
+ rtreeRename(args);
+ }
+ else if (memcmp(E->xRename_signature, xRename_signatures[xRename_spellfix1Rename_enum], sizeof(E->xRename_signature)) == 0) {
+ spellfix1Rename(args);
+ }
+ else if (memcmp(E->xRename_signature, xRename_signatures[xRename_vtablogRename_enum], sizeof(E->xRename_signature)) == 0) {
+ vtablogRename(args);
+ }


// Transform E->xRollback(args) to if-chain with 6 candidates
@transform_no_return_xRollback_arrow@
expression E;
identifier FP_NAME = xRollback;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xRollback_signature, xRollback_signatures[xRollback_0_enum], sizeof(E->xRollback_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xRollback_signature, xRollback_signatures[xRollback_echoRollback_enum], sizeof(E->xRollback_signature)) == 0) {
+ echoRollback(args);
+ }
+ else if (memcmp(E->xRollback_signature, xRollback_signatures[xRollback_fts3RollbackMethod_enum], sizeof(E->xRollback_signature)) == 0) {
+ fts3RollbackMethod(args);
+ }
+ else if (memcmp(E->xRollback_signature, xRollback_signatures[xRollback_rtreeEndTransaction_enum], sizeof(E->xRollback_signature)) == 0) {
+ rtreeEndTransaction(args);
+ }
+ else if (memcmp(E->xRollback_signature, xRollback_signatures[xRollback_rtreeRollback_enum], sizeof(E->xRollback_signature)) == 0) {
+ rtreeRollback(args);
+ }
+ else if (memcmp(E->xRollback_signature, xRollback_signatures[xRollback_vtablogRollback_enum], sizeof(E->xRollback_signature)) == 0) {
+ vtablogRollback(args);
+ }
+ else if (memcmp(E->xRollback_signature, xRollback_signatures[xRollback_zipfileRollback_enum], sizeof(E->xRollback_signature)) == 0) {
+ zipfileRollback(args);
+ }


// Transform E->xRollbackTo(args) to if-chain with 4 candidates
@transform_no_return_xRollbackTo_arrow@
expression E;
identifier FP_NAME = xRollbackTo;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xRollbackTo_signature, xRollbackTo_signatures[xRollbackTo_0_enum], sizeof(E->xRollbackTo_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xRollbackTo_signature, xRollbackTo_signatures[xRollbackTo_dbpageRollbackTo_enum], sizeof(E->xRollbackTo_signature)) == 0) {
+ dbpageRollbackTo(args);
+ }
+ else if (memcmp(E->xRollbackTo_signature, xRollbackTo_signatures[xRollbackTo_echoRollbackTo_enum], sizeof(E->xRollbackTo_signature)) == 0) {
+ echoRollbackTo(args);
+ }
+ else if (memcmp(E->xRollbackTo_signature, xRollbackTo_signatures[xRollbackTo_fts3RollbackToMethod_enum], sizeof(E->xRollbackTo_signature)) == 0) {
+ fts3RollbackToMethod(args);
+ }
+ else if (memcmp(E->xRollbackTo_signature, xRollbackTo_signatures[xRollbackTo_vtablogRollbackTo_enum], sizeof(E->xRollbackTo_signature)) == 0) {
+ vtablogRollbackTo(args);
+ }


// Transform E->xRoundup(args) to if-chain with 2 candidates
@transform_no_return_xRoundup_arrow@
expression E;
identifier FP_NAME = xRoundup;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xRoundup_signature, xRoundup_signatures[xRoundup_memtraceRoundup_enum], sizeof(E->xRoundup_signature)) == 0) {
+ memtraceRoundup(args);
+ }
+ else if (memcmp(E->xRoundup_signature, xRoundup_signatures[xRoundup_sqlite3MemRoundup_enum], sizeof(E->xRoundup_signature)) == 0) {
+ sqlite3MemRoundup(args);
+ }


// Transform E->xRowid(args) to if-chain with 42 candidates
@transform_no_return_xRowid_arrow@
expression E;
identifier FP_NAME = xRowid;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_0_enum], sizeof(E->xRowid_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_amatchRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ amatchRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_binfoRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ binfoRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_bytecodevtabRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ bytecodevtabRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_carrayRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ carrayRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_cidxRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ cidxRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_closureRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ closureRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_completionRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ completionRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_csvtabRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ csvtabRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_dbdataRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ dbdataRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_dbpageRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ dbpageRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_deltaparsevtabRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ deltaparsevtabRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_echoRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ echoRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_expertRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ expertRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_explainRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ explainRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_fsRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ fsRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_fsdirRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ fsdirRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_fstreeRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ fstreeRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_fts3RowidMethod_enum], sizeof(E->xRowid_signature)) == 0) {
+ fts3RowidMethod(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_fts3auxRowidMethod_enum], sizeof(E->xRowid_signature)) == 0) {
+ fts3auxRowidMethod(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_fts3termRowidMethod_enum], sizeof(E->xRowid_signature)) == 0) {
+ fts3termRowidMethod(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_fts3tokRowidMethod_enum], sizeof(E->xRowid_signature)) == 0) {
+ fts3tokRowidMethod(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_fuzzerRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ fuzzerRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_intarrayRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ intarrayRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_jsonEachRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ jsonEachRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_memstatRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ memstatRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_pragmaVtabRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ pragmaVtabRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_prefixesRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ prefixesRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_qpvtabRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ qpvtabRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_rtreeRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ rtreeRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_schemaRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ schemaRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_seriesRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ seriesRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_spellfix1Rowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ spellfix1Rowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_statRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ statRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_stmtRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ stmtRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_tclRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ tclRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_tclvarRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ tclvarRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_templatevtabRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ templatevtabRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_unionRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ unionRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_vlogRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ vlogRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_vstattabRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ vstattabRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_vtablogRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ vtablogRowid(args);
+ }
+ else if (memcmp(E->xRowid_signature, xRowid_signatures[xRowid_wholenumberRowid_enum], sizeof(E->xRowid_signature)) == 0) {
+ wholenumberRowid(args);
+ }


// Transform E->xSFunc(args) to if-chain with 5 candidates
@transform_no_return_xSFunc_arrow@
expression E;
identifier FP_NAME = xSFunc;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_attachFunc_enum], sizeof(E->xSFunc_signature)) == 0) {
+ attachFunc(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_detachFunc_enum], sizeof(E->xSFunc_signature)) == 0) {
+ detachFunc(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_statGet_enum], sizeof(E->xSFunc_signature)) == 0) {
+ statGet(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_statInit_enum], sizeof(E->xSFunc_signature)) == 0) {
+ statInit(args);
+ }
+ else if (memcmp(E->xSFunc_signature, xSFunc_signatures[xSFunc_statPush_enum], sizeof(E->xSFunc_signature)) == 0) {
+ statPush(args);
+ }


// Transform E->xSavepoint(args) to if-chain with 2 candidates
@transform_no_return_xSavepoint_arrow@
expression E;
identifier FP_NAME = xSavepoint;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xSavepoint_signature, xSavepoint_signatures[xSavepoint_0_enum], sizeof(E->xSavepoint_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xSavepoint_signature, xSavepoint_signatures[xSavepoint_fts3SavepointMethod_enum], sizeof(E->xSavepoint_signature)) == 0) {
+ fts3SavepointMethod(args);
+ }
+ else if (memcmp(E->xSavepoint_signature, xSavepoint_signatures[xSavepoint_rtreeSavepoint_enum], sizeof(E->xSavepoint_signature)) == 0) {
+ rtreeSavepoint(args);
+ }


// Transform E->xSectorSize(args) to if-chain with 4 candidates
@transform_no_return_xSectorSize_arrow@
expression E;
identifier FP_NAME = xSectorSize;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xSectorSize_signature, xSectorSize_signatures[xSectorSize_0_enum], sizeof(E->xSectorSize_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xSectorSize_signature, xSectorSize_signatures[xSectorSize_apndSectorSize_enum], sizeof(E->xSectorSize_signature)) == 0) {
+ apndSectorSize(args);
+ }
+ else if (memcmp(E->xSectorSize_signature, xSectorSize_signatures[xSectorSize_recoverVfsSectorSize_enum], sizeof(E->xSectorSize_signature)) == 0) {
+ recoverVfsSectorSize(args);
+ }
+ else if (memcmp(E->xSectorSize_signature, xSectorSize_signatures[xSectorSize_vfstraceSectorSize_enum], sizeof(E->xSectorSize_signature)) == 0) {
+ vfstraceSectorSize(args);
+ }
+ else if (memcmp(E->xSectorSize_signature, xSectorSize_signatures[xSectorSize_unixSectorSize_enum], sizeof(E->xSectorSize_signature)) == 0) {
+ unixSectorSize(args);
+ }


// Transform E->xSelectCallback(args) to if-chain with 16 candidates
@transform_no_return_xSelectCallback_arrow@
expression E;
identifier FP_NAME = xSelectCallback;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_0_enum], sizeof(E->xSelectCallback_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_convertCompoundSelectToSubquery_enum], sizeof(E->xSelectCallback_signature)) == 0) {
+ convertCompoundSelectToSubquery(args);
+ }
+ else if (memcmp(E->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_exprSelectWalkTableConstant_enum], sizeof(E->xSelectCallback_signature)) == 0) {
+ exprSelectWalkTableConstant(args);
+ }
+ else if (memcmp(E->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_fixSelectCb_enum], sizeof(E->xSelectCallback_signature)) == 0) {
+ fixSelectCb(args);
+ }
+ else if (memcmp(E->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_gatherSelectWindowsSelectCallback_enum], sizeof(E->xSelectCallback_signature)) == 0) {
+ gatherSelectWindowsSelectCallback(args);
+ }
+ else if (memcmp(E->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_renameColumnSelectCb_enum], sizeof(E->xSelectCallback_signature)) == 0) {
+ renameColumnSelectCb(args);
+ }
+ else if (memcmp(E->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_renameTableSelectCb_enum], sizeof(E->xSelectCallback_signature)) == 0) {
+ renameTableSelectCb(args);
+ }
+ else if (memcmp(E->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_renameUnmapSelectCb_enum], sizeof(E->xSelectCallback_signature)) == 0) {
+ renameUnmapSelectCb(args);
+ }
+ else if (memcmp(E->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_resolveSelectStep_enum], sizeof(E->xSelectCallback_signature)) == 0) {
+ resolveSelectStep(args);
+ }
+ else if (memcmp(E->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_selectCheckOnClausesSelect_enum], sizeof(E->xSelectCallback_signature)) == 0) {
+ selectCheckOnClausesSelect(args);
+ }
+ else if (memcmp(E->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_selectExpander_enum], sizeof(E->xSelectCallback_signature)) == 0) {
+ selectExpander(args);
+ }
+ else if (memcmp(E->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_selectRefEnter_enum], sizeof(E->xSelectCallback_signature)) == 0) {
+ selectRefEnter(args);
+ }
+ else if (memcmp(E->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_selectWindowRewriteSelectCb_enum], sizeof(E->xSelectCallback_signature)) == 0) {
+ selectWindowRewriteSelectCb(args);
+ }
+ else if (memcmp(E->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_sqlite3ReturningSubqueryCorrelated_enum], sizeof(E->xSelectCallback_signature)) == 0) {
+ sqlite3ReturningSubqueryCorrelated(args);
+ }
+ else if (memcmp(E->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_sqlite3SelectWalkFail_enum], sizeof(E->xSelectCallback_signature)) == 0) {
+ sqlite3SelectWalkFail(args);
+ }
+ else if (memcmp(E->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_sqlite3SelectWalkNoop_enum], sizeof(E->xSelectCallback_signature)) == 0) {
+ sqlite3SelectWalkNoop(args);
+ }
+ else if (memcmp(E->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_sqlite3WalkerDepthIncrease_enum], sizeof(E->xSelectCallback_signature)) == 0) {
+ sqlite3WalkerDepthIncrease(args);
+ }


// Transform E->xSelectCallback2(args) to if-chain with 5 candidates
@transform_no_return_xSelectCallback2_arrow@
expression E;
identifier FP_NAME = xSelectCallback2;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_0_enum], sizeof(E->xSelectCallback2_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_selectAddSubqueryTypeInfo_enum], sizeof(E->xSelectCallback2_signature)) == 0) {
+ selectAddSubqueryTypeInfo(args);
+ }
+ else if (memcmp(E->xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_selectRefLeave_enum], sizeof(E->xSelectCallback2_signature)) == 0) {
+ selectRefLeave(args);
+ }
+ else if (memcmp(E->xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_sqlite3SelectPopWith_enum], sizeof(E->xSelectCallback2_signature)) == 0) {
+ sqlite3SelectPopWith(args);
+ }
+ else if (memcmp(E->xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_sqlite3WalkWinDefnDummyCallback_enum], sizeof(E->xSelectCallback2_signature)) == 0) {
+ sqlite3WalkWinDefnDummyCallback(args);
+ }
+ else if (memcmp(E->xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_sqlite3WalkerDepthDecrease_enum], sizeof(E->xSelectCallback2_signature)) == 0) {
+ sqlite3WalkerDepthDecrease(args);
+ }


// Transform E->xSetSystemCall(args) to if-chain with 5 candidates
@transform_no_return_xSetSystemCall_arrow@
expression E;
identifier FP_NAME = xSetSystemCall;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xSetSystemCall_signature, xSetSystemCall_signatures[xSetSystemCall_0_enum], sizeof(E->xSetSystemCall_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xSetSystemCall_signature, xSetSystemCall_signatures[xSetSystemCall_apndSetSystemCall_enum], sizeof(E->xSetSystemCall_signature)) == 0) {
+ apndSetSystemCall(args);
+ }
+ else if (memcmp(E->xSetSystemCall_signature, xSetSystemCall_signatures[xSetSystemCall_devsymSleep_enum], sizeof(E->xSetSystemCall_signature)) == 0) {
+ devsymSleep(args);
+ }
+ else if (memcmp(E->xSetSystemCall_signature, xSetSystemCall_signatures[xSetSystemCall_rbuVfsSleep_enum], sizeof(E->xSetSystemCall_signature)) == 0) {
+ rbuVfsSleep(args);
+ }
+ else if (memcmp(E->xSetSystemCall_signature, xSetSystemCall_signatures[xSetSystemCall_tvfsSleep_enum], sizeof(E->xSetSystemCall_signature)) == 0) {
+ tvfsSleep(args);
+ }
+ else if (memcmp(E->xSetSystemCall_signature, xSetSystemCall_signatures[xSetSystemCall_unixSetSystemCall_enum], sizeof(E->xSetSystemCall_signature)) == 0) {
+ unixSetSystemCall(args);
+ }


// Transform E->xShadowName(args) to if-chain with 2 candidates
@transform_no_return_xShadowName_arrow@
expression E;
identifier FP_NAME = xShadowName;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xShadowName_signature, xShadowName_signatures[xShadowName_0_enum], sizeof(E->xShadowName_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xShadowName_signature, xShadowName_signatures[xShadowName_fts3ShadowName_enum], sizeof(E->xShadowName_signature)) == 0) {
+ fts3ShadowName(args);
+ }
+ else if (memcmp(E->xShadowName_signature, xShadowName_signatures[xShadowName_rtreeShadowName_enum], sizeof(E->xShadowName_signature)) == 0) {
+ rtreeShadowName(args);
+ }


// Transform E->xShmBarrier(args) to if-chain with 3 candidates
@transform_no_return_xShmBarrier_arrow@
expression E;
identifier FP_NAME = xShmBarrier;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xShmBarrier_signature, xShmBarrier_signatures[xShmBarrier_0_enum], sizeof(E->xShmBarrier_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xShmBarrier_signature, xShmBarrier_signatures[xShmBarrier_apndShmBarrier_enum], sizeof(E->xShmBarrier_signature)) == 0) {
+ apndShmBarrier(args);
+ }
+ else if (memcmp(E->xShmBarrier_signature, xShmBarrier_signatures[xShmBarrier_recoverVfsShmBarrier_enum], sizeof(E->xShmBarrier_signature)) == 0) {
+ recoverVfsShmBarrier(args);
+ }
+ else if (memcmp(E->xShmBarrier_signature, xShmBarrier_signatures[xShmBarrier_unixShmBarrier_enum], sizeof(E->xShmBarrier_signature)) == 0) {
+ unixShmBarrier(args);
+ }


// Transform E->xShmLock(args) to if-chain with 3 candidates
@transform_no_return_xShmLock_arrow@
expression E;
identifier FP_NAME = xShmLock;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xShmLock_signature, xShmLock_signatures[xShmLock_0_enum], sizeof(E->xShmLock_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xShmLock_signature, xShmLock_signatures[xShmLock_apndShmLock_enum], sizeof(E->xShmLock_signature)) == 0) {
+ apndShmLock(args);
+ }
+ else if (memcmp(E->xShmLock_signature, xShmLock_signatures[xShmLock_recoverVfsShmLock_enum], sizeof(E->xShmLock_signature)) == 0) {
+ recoverVfsShmLock(args);
+ }
+ else if (memcmp(E->xShmLock_signature, xShmLock_signatures[xShmLock_unixShmLock_enum], sizeof(E->xShmLock_signature)) == 0) {
+ unixShmLock(args);
+ }


// Transform E->xShmMap(args) to if-chain with 3 candidates
@transform_no_return_xShmMap_arrow@
expression E;
identifier FP_NAME = xShmMap;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xShmMap_signature, xShmMap_signatures[xShmMap_0_enum], sizeof(E->xShmMap_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xShmMap_signature, xShmMap_signatures[xShmMap_apndShmMap_enum], sizeof(E->xShmMap_signature)) == 0) {
+ apndShmMap(args);
+ }
+ else if (memcmp(E->xShmMap_signature, xShmMap_signatures[xShmMap_recoverVfsShmMap_enum], sizeof(E->xShmMap_signature)) == 0) {
+ recoverVfsShmMap(args);
+ }
+ else if (memcmp(E->xShmMap_signature, xShmMap_signatures[xShmMap_unixShmMap_enum], sizeof(E->xShmMap_signature)) == 0) {
+ unixShmMap(args);
+ }


// Transform E->xShmUnmap(args) to if-chain with 3 candidates
@transform_no_return_xShmUnmap_arrow@
expression E;
identifier FP_NAME = xShmUnmap;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xShmUnmap_signature, xShmUnmap_signatures[xShmUnmap_0_enum], sizeof(E->xShmUnmap_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xShmUnmap_signature, xShmUnmap_signatures[xShmUnmap_apndShmUnmap_enum], sizeof(E->xShmUnmap_signature)) == 0) {
+ apndShmUnmap(args);
+ }
+ else if (memcmp(E->xShmUnmap_signature, xShmUnmap_signatures[xShmUnmap_recoverVfsShmUnmap_enum], sizeof(E->xShmUnmap_signature)) == 0) {
+ recoverVfsShmUnmap(args);
+ }
+ else if (memcmp(E->xShmUnmap_signature, xShmUnmap_signatures[xShmUnmap_unixShmUnmap_enum], sizeof(E->xShmUnmap_signature)) == 0) {
+ unixShmUnmap(args);
+ }


// Transform E->xShrink(args) to if-chain with 2 candidates
@transform_no_return_xShrink_arrow@
expression E;
identifier FP_NAME = xShrink;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xShrink_signature, xShrink_signatures[xShrink_pcache1Shrink_enum], sizeof(E->xShrink_signature)) == 0) {
+ pcache1Shrink(args);
+ }
+ else if (memcmp(E->xShrink_signature, xShrink_signatures[xShrink_pcachetraceShrink_enum], sizeof(E->xShrink_signature)) == 0) {
+ pcachetraceShrink(args);
+ }


// Transform E->xShutdown(args) to if-chain with 4 candidates
@transform_no_return_xShutdown_arrow@
expression E;
identifier FP_NAME = xShutdown;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xShutdown_signature, xShutdown_signatures[xShutdown_memtraceShutdown_enum], sizeof(E->xShutdown_signature)) == 0) {
+ memtraceShutdown(args);
+ }
+ else if (memcmp(E->xShutdown_signature, xShutdown_signatures[xShutdown_pcache1Shutdown_enum], sizeof(E->xShutdown_signature)) == 0) {
+ pcache1Shutdown(args);
+ }
+ else if (memcmp(E->xShutdown_signature, xShutdown_signatures[xShutdown_pcachetraceShutdown_enum], sizeof(E->xShutdown_signature)) == 0) {
+ pcachetraceShutdown(args);
+ }
+ else if (memcmp(E->xShutdown_signature, xShutdown_signatures[xShutdown_sqlite3MemShutdown_enum], sizeof(E->xShutdown_signature)) == 0) {
+ sqlite3MemShutdown(args);
+ }


// Transform E->xSize(args) to if-chain with 2 candidates
@transform_no_return_xSize_arrow@
expression E;
identifier FP_NAME = xSize;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xSize_signature, xSize_signatures[xSize_memtraceSize_enum], sizeof(E->xSize_signature)) == 0) {
+ memtraceSize(args);
+ }
+ else if (memcmp(E->xSize_signature, xSize_signatures[xSize_sqlite3MemSize_enum], sizeof(E->xSize_signature)) == 0) {
+ sqlite3MemSize(args);
+ }


// Transform E->xSleep(args) to if-chain with 4 candidates
@transform_no_return_xSleep_arrow@
expression E;
identifier FP_NAME = xSleep;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xSleep_signature, xSleep_signatures[xSleep_0_enum], sizeof(E->xSleep_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xSleep_signature, xSleep_signatures[xSleep_apndSleep_enum], sizeof(E->xSleep_signature)) == 0) {
+ apndSleep(args);
+ }
+ else if (memcmp(E->xSleep_signature, xSleep_signatures[xSleep_memdbSleep_enum], sizeof(E->xSleep_signature)) == 0) {
+ memdbSleep(args);
+ }
+ else if (memcmp(E->xSleep_signature, xSleep_signatures[xSleep_vfstraceSleep_enum], sizeof(E->xSleep_signature)) == 0) {
+ vfstraceSleep(args);
+ }
+ else if (memcmp(E->xSleep_signature, xSleep_signatures[xSleep_unixSleep_enum], sizeof(E->xSleep_signature)) == 0) {
+ unixSleep(args);
+ }


// Transform E->xSync(args) to if-chain with 11 candidates
@transform_no_return_xSync_arrow@
expression E;
identifier FP_NAME = xSync;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xSync_signature, xSync_signatures[xSync_0_enum], sizeof(E->xSync_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xSync_signature, xSync_signatures[xSync_apndSync_enum], sizeof(E->xSync_signature)) == 0) {
+ apndSync(args);
+ }
+ else if (memcmp(E->xSync_signature, xSync_signatures[xSync_dbpageSync_enum], sizeof(E->xSync_signature)) == 0) {
+ dbpageSync(args);
+ }
+ else if (memcmp(E->xSync_signature, xSync_signatures[xSync_echoSync_enum], sizeof(E->xSync_signature)) == 0) {
+ echoSync(args);
+ }
+ else if (memcmp(E->xSync_signature, xSync_signatures[xSync_fts3SyncMethod_enum], sizeof(E->xSync_signature)) == 0) {
+ fts3SyncMethod(args);
+ }
+ else if (memcmp(E->xSync_signature, xSync_signatures[xSync_memdbSync_enum], sizeof(E->xSync_signature)) == 0) {
+ memdbSync(args);
+ }
+ else if (memcmp(E->xSync_signature, xSync_signatures[xSync_memjrnlSync_enum], sizeof(E->xSync_signature)) == 0) {
+ memjrnlSync(args);
+ }
+ else if (memcmp(E->xSync_signature, xSync_signatures[xSync_recoverVfsSync_enum], sizeof(E->xSync_signature)) == 0) {
+ recoverVfsSync(args);
+ }
+ else if (memcmp(E->xSync_signature, xSync_signatures[xSync_rtreeEndTransaction_enum], sizeof(E->xSync_signature)) == 0) {
+ rtreeEndTransaction(args);
+ }
+ else if (memcmp(E->xSync_signature, xSync_signatures[xSync_vfstraceSync_enum], sizeof(E->xSync_signature)) == 0) {
+ vfstraceSync(args);
+ }
+ else if (memcmp(E->xSync_signature, xSync_signatures[xSync_vtablogSync_enum], sizeof(E->xSync_signature)) == 0) {
+ vtablogSync(args);
+ }
+ else if (memcmp(E->xSync_signature, xSync_signatures[xSync_unixSync_enum], sizeof(E->xSync_signature)) == 0) {
+ unixSync(args);
+ }


// Transform E->xTokenize(args) to if-chain with 3 candidates
@transform_no_return_xTokenize_arrow@
expression E;
identifier FP_NAME = xTokenize;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xTokenize_signature, xTokenize_signatures[xTokenize_0_enum], sizeof(E->xTokenize_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xTokenize_signature, xTokenize_signatures[xTokenize_f5tOrigintextTokenize_enum], sizeof(E->xTokenize_signature)) == 0) {
+ f5tOrigintextTokenize(args);
+ }
+ else if (memcmp(E->xTokenize_signature, xTokenize_signatures[xTokenize_f5tTokenizerTokenize_enum], sizeof(E->xTokenize_signature)) == 0) {
+ f5tTokenizerTokenize(args);
+ }
+ else if (memcmp(E->xTokenize_signature, xTokenize_signatures[xTokenize_f5tTokenizerTokenize_v2_enum], sizeof(E->xTokenize_signature)) == 0) {
+ f5tTokenizerTokenize_v2(args);
+ }


// Transform E->xTruncate(args) to if-chain with 8 candidates
@transform_no_return_xTruncate_arrow@
expression E;
identifier FP_NAME = xTruncate;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xTruncate_signature, xTruncate_signatures[xTruncate_apndTruncate_enum], sizeof(E->xTruncate_signature)) == 0) {
+ apndTruncate(args);
+ }
+ else if (memcmp(E->xTruncate_signature, xTruncate_signatures[xTruncate_memdbTruncate_enum], sizeof(E->xTruncate_signature)) == 0) {
+ memdbTruncate(args);
+ }
+ else if (memcmp(E->xTruncate_signature, xTruncate_signatures[xTruncate_memjrnlTruncate_enum], sizeof(E->xTruncate_signature)) == 0) {
+ memjrnlTruncate(args);
+ }
+ else if (memcmp(E->xTruncate_signature, xTruncate_signatures[xTruncate_pcache1Truncate_enum], sizeof(E->xTruncate_signature)) == 0) {
+ pcache1Truncate(args);
+ }
+ else if (memcmp(E->xTruncate_signature, xTruncate_signatures[xTruncate_pcachetraceTruncate_enum], sizeof(E->xTruncate_signature)) == 0) {
+ pcachetraceTruncate(args);
+ }
+ else if (memcmp(E->xTruncate_signature, xTruncate_signatures[xTruncate_recoverVfsTruncate_enum], sizeof(E->xTruncate_signature)) == 0) {
+ recoverVfsTruncate(args);
+ }
+ else if (memcmp(E->xTruncate_signature, xTruncate_signatures[xTruncate_vfstraceTruncate_enum], sizeof(E->xTruncate_signature)) == 0) {
+ vfstraceTruncate(args);
+ }
+ else if (memcmp(E->xTruncate_signature, xTruncate_signatures[xTruncate_unixTruncate_enum], sizeof(E->xTruncate_signature)) == 0) {
+ unixTruncate(args);
+ }


// Transform E->xUnfetch(args) to if-chain with 4 candidates
@transform_no_return_xUnfetch_arrow@
expression E;
identifier FP_NAME = xUnfetch;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xUnfetch_signature, xUnfetch_signatures[xUnfetch_0_enum], sizeof(E->xUnfetch_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xUnfetch_signature, xUnfetch_signatures[xUnfetch_apndUnfetch_enum], sizeof(E->xUnfetch_signature)) == 0) {
+ apndUnfetch(args);
+ }
+ else if (memcmp(E->xUnfetch_signature, xUnfetch_signatures[xUnfetch_memdbUnfetch_enum], sizeof(E->xUnfetch_signature)) == 0) {
+ memdbUnfetch(args);
+ }
+ else if (memcmp(E->xUnfetch_signature, xUnfetch_signatures[xUnfetch_recoverVfsUnfetch_enum], sizeof(E->xUnfetch_signature)) == 0) {
+ recoverVfsUnfetch(args);
+ }
+ else if (memcmp(E->xUnfetch_signature, xUnfetch_signatures[xUnfetch_unixUnfetch_enum], sizeof(E->xUnfetch_signature)) == 0) {
+ unixUnfetch(args);
+ }


// Transform E->xUnlock(args) to if-chain with 7 candidates
@transform_no_return_xUnlock_arrow@
expression E;
identifier FP_NAME = xUnlock;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xUnlock_signature, xUnlock_signatures[xUnlock_0_enum], sizeof(E->xUnlock_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xUnlock_signature, xUnlock_signatures[xUnlock_apndUnlock_enum], sizeof(E->xUnlock_signature)) == 0) {
+ apndUnlock(args);
+ }
+ else if (memcmp(E->xUnlock_signature, xUnlock_signatures[xUnlock_memdbUnlock_enum], sizeof(E->xUnlock_signature)) == 0) {
+ memdbUnlock(args);
+ }
+ else if (memcmp(E->xUnlock_signature, xUnlock_signatures[xUnlock_recoverVfsUnlock_enum], sizeof(E->xUnlock_signature)) == 0) {
+ recoverVfsUnlock(args);
+ }
+ else if (memcmp(E->xUnlock_signature, xUnlock_signatures[xUnlock_vfstraceUnlock_enum], sizeof(E->xUnlock_signature)) == 0) {
+ vfstraceUnlock(args);
+ }
+ else if (memcmp(E->xUnlock_signature, xUnlock_signatures[xUnlock_unixUnlock_enum], sizeof(E->xUnlock_signature)) == 0) {
+ unixUnlock(args);
+ }
+ else if (memcmp(E->xUnlock_signature, xUnlock_signatures[xUnlock_nolockUnlock_enum], sizeof(E->xUnlock_signature)) == 0) {
+ nolockUnlock(args);
+ }
+ else if (memcmp(E->xUnlock_signature, xUnlock_signatures[xUnlock_dotlockUnlock_enum], sizeof(E->xUnlock_signature)) == 0) {
+ dotlockUnlock(args);
+ }


// Transform E->xUnpin(args) to if-chain with 2 candidates
@transform_no_return_xUnpin_arrow@
expression E;
identifier FP_NAME = xUnpin;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xUnpin_signature, xUnpin_signatures[xUnpin_pcache1Unpin_enum], sizeof(E->xUnpin_signature)) == 0) {
+ pcache1Unpin(args);
+ }
+ else if (memcmp(E->xUnpin_signature, xUnpin_signatures[xUnpin_pcachetraceUnpin_enum], sizeof(E->xUnpin_signature)) == 0) {
+ pcachetraceUnpin(args);
+ }


// Transform E->xUpdate(args) to if-chain with 13 candidates
@transform_no_return_xUpdate_arrow@
expression E;
identifier FP_NAME = xUpdate;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xUpdate_signature, xUpdate_signatures[xUpdate_0_enum], sizeof(E->xUpdate_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E->xUpdate_signature, xUpdate_signatures[xUpdate_amatchUpdate_enum], sizeof(E->xUpdate_signature)) == 0) {
+ amatchUpdate(args);
+ }
+ else if (memcmp(E->xUpdate_signature, xUpdate_signatures[xUpdate_csvtabUpdate_enum], sizeof(E->xUpdate_signature)) == 0) {
+ csvtabUpdate(args);
+ }
+ else if (memcmp(E->xUpdate_signature, xUpdate_signatures[xUpdate_dbpageUpdate_enum], sizeof(E->xUpdate_signature)) == 0) {
+ dbpageUpdate(args);
+ }
+ else if (memcmp(E->xUpdate_signature, xUpdate_signatures[xUpdate_echoUpdate_enum], sizeof(E->xUpdate_signature)) == 0) {
+ echoUpdate(args);
+ }
+ else if (memcmp(E->xUpdate_signature, xUpdate_signatures[xUpdate_expertUpdate_enum], sizeof(E->xUpdate_signature)) == 0) {
+ expertUpdate(args);
+ }
+ else if (memcmp(E->xUpdate_signature, xUpdate_signatures[xUpdate_fts3UpdateMethod_enum], sizeof(E->xUpdate_signature)) == 0) {
+ fts3UpdateMethod(args);
+ }
+ else if (memcmp(E->xUpdate_signature, xUpdate_signatures[xUpdate_geopolyUpdate_enum], sizeof(E->xUpdate_signature)) == 0) {
+ geopolyUpdate(args);
+ }
+ else if (memcmp(E->xUpdate_signature, xUpdate_signatures[xUpdate_rtreeUpdate_enum], sizeof(E->xUpdate_signature)) == 0) {
+ rtreeUpdate(args);
+ }
+ else if (memcmp(E->xUpdate_signature, xUpdate_signatures[xUpdate_spellfix1Update_enum], sizeof(E->xUpdate_signature)) == 0) {
+ spellfix1Update(args);
+ }
+ else if (memcmp(E->xUpdate_signature, xUpdate_signatures[xUpdate_tclvarUpdate_enum], sizeof(E->xUpdate_signature)) == 0) {
+ tclvarUpdate(args);
+ }
+ else if (memcmp(E->xUpdate_signature, xUpdate_signatures[xUpdate_vstattabUpdate_enum], sizeof(E->xUpdate_signature)) == 0) {
+ vstattabUpdate(args);
+ }
+ else if (memcmp(E->xUpdate_signature, xUpdate_signatures[xUpdate_vtablogUpdate_enum], sizeof(E->xUpdate_signature)) == 0) {
+ vtablogUpdate(args);
+ }
+ else if (memcmp(E->xUpdate_signature, xUpdate_signatures[xUpdate_zipfileUpdate_enum], sizeof(E->xUpdate_signature)) == 0) {
+ zipfileUpdate(args);
+ }


// Transform E->xWrite(args) to if-chain with 7 candidates
@transform_no_return_xWrite_arrow@
expression E;
identifier FP_NAME = xWrite;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xWrite_signature, xWrite_signatures[xWrite_apndWrite_enum], sizeof(E->xWrite_signature)) == 0) {
+ apndWrite(args);
+ }
+ else if (memcmp(E->xWrite_signature, xWrite_signatures[xWrite_kvstorageWrite_enum], sizeof(E->xWrite_signature)) == 0) {
+ kvstorageWrite(args);
+ }
+ else if (memcmp(E->xWrite_signature, xWrite_signatures[xWrite_memdbWrite_enum], sizeof(E->xWrite_signature)) == 0) {
+ memdbWrite(args);
+ }
+ else if (memcmp(E->xWrite_signature, xWrite_signatures[xWrite_memjrnlWrite_enum], sizeof(E->xWrite_signature)) == 0) {
+ memjrnlWrite(args);
+ }
+ else if (memcmp(E->xWrite_signature, xWrite_signatures[xWrite_recoverVfsWrite_enum], sizeof(E->xWrite_signature)) == 0) {
+ recoverVfsWrite(args);
+ }
+ else if (memcmp(E->xWrite_signature, xWrite_signatures[xWrite_vfstraceWrite_enum], sizeof(E->xWrite_signature)) == 0) {
+ vfstraceWrite(args);
+ }
+ else if (memcmp(E->xWrite_signature, xWrite_signatures[xWrite_unixWrite_enum], sizeof(E->xWrite_signature)) == 0) {
+ unixWrite(args);
+ }


// Transform E->xsnprintf(args) to if-chain with 1 candidates
@transform_no_return_xsnprintf_arrow@
expression E;
identifier FP_NAME = xsnprintf;
expression list args;
@@
- E->FP_NAME(args);
+ if (memcmp(E->xsnprintf_signature, xsnprintf_signatures[xsnprintf_sqlite3_set_authorizer_enum], sizeof(E->xsnprintf_signature)) == 0) {
+ sqlite3_set_authorizer(args);
+ }

// Total no return transformation rules generated: 321
// ===== NO RETURN FUNCTION POINTER TRANSFORMATION RULES (DOT) =====

// Transform E.aggregate_context(args) to direct call (only 1 candidate)
@transform_no_return_aggregate_context@
expression E;
identifier FP_NAME = aggregate_context;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_aggregate_context(args);


// Transform E.auto_extension(args) to direct call (only 1 candidate)
@transform_no_return_auto_extension@
expression E;
identifier FP_NAME = auto_extension;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_vtab_config(args);


// Transform E.backup_finish(args) to direct call (only 1 candidate)
@transform_no_return_backup_finish@
expression E;
identifier FP_NAME = backup_finish;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_result_error_code(args);


// Transform E.backup_init(args) to direct call (only 1 candidate)
@transform_no_return_backup_init@
expression E;
identifier FP_NAME = backup_init;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_test_control(args);


// Transform E.backup_pagecount(args) to direct call (only 1 candidate)
@transform_no_return_backup_pagecount@
expression E;
identifier FP_NAME = backup_pagecount;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_randomness(args);


// Transform E.backup_remaining(args) to direct call (only 1 candidate)
@transform_no_return_backup_remaining@
expression E;
identifier FP_NAME = backup_remaining;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_context_db_handle(args);


// Transform E.backup_step(args) to direct call (only 1 candidate)
@transform_no_return_backup_step@
expression E;
identifier FP_NAME = backup_step;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_extended_result_codes(args);


// Transform E.bind_blob64(args) to direct call (only 1 candidate)
@transform_no_return_bind_blob64@
expression E;
identifier FP_NAME = bind_blob64;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_vtab_on_conflict(args);


// Transform E.bind_int(args) to direct call (only 1 candidate)
@transform_no_return_bind_int@
expression E;
identifier FP_NAME = bind_int;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_bind_double(args);


// Transform E.bind_int64(args) to direct call (only 1 candidate)
@transform_no_return_bind_int64@
expression E;
identifier FP_NAME = bind_int64;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_bind_int(args);


// Transform E.bind_null(args) to direct call (only 1 candidate)
@transform_no_return_bind_null@
expression E;
identifier FP_NAME = bind_null;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_bind_int64(args);


// Transform E.bind_parameter_count(args) to direct call (only 1 candidate)
@transform_no_return_bind_parameter_count@
expression E;
identifier FP_NAME = bind_parameter_count;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_bind_null(args);


// Transform E.bind_parameter_index(args) to direct call (only 1 candidate)
@transform_no_return_bind_parameter_index@
expression E;
identifier FP_NAME = bind_parameter_index;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_bind_parameter_count(args);


// Transform E.bind_parameter_name(args) to direct call (only 1 candidate)
@transform_no_return_bind_parameter_name@
expression E;
identifier FP_NAME = bind_parameter_name;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_bind_parameter_index(args);


// Transform E.bind_text(args) to direct call (only 1 candidate)
@transform_no_return_bind_text@
expression E;
identifier FP_NAME = bind_text;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_bind_parameter_name(args);


// Transform E.bind_text16(args) to direct call (only 1 candidate)
@transform_no_return_bind_text16@
expression E;
identifier FP_NAME = bind_text16;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_bind_text(args);


// Transform E.bind_text64(args) to direct call (only 1 candidate)
@transform_no_return_bind_text64@
expression E;
identifier FP_NAME = bind_text64;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_close_v2(args);


// Transform E.bind_value(args) to direct call (only 1 candidate)
@transform_no_return_bind_value@
expression E;
identifier FP_NAME = bind_value;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_bind_text16(args);


// Transform E.bind_zeroblob(args) to direct call (only 1 candidate)
@transform_no_return_bind_zeroblob@
expression E;
identifier FP_NAME = bind_zeroblob;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_prepare_v2(args);


// Transform E.bind_zeroblob64(args) to direct call (only 1 candidate)
@transform_no_return_bind_zeroblob64@
expression E;
identifier FP_NAME = bind_zeroblob64;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_auto_extension(args);


// Transform E.blob_bytes(args) to direct call (only 1 candidate)
@transform_no_return_blob_bytes@
expression E;
identifier FP_NAME = blob_bytes;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_prepare16_v2(args);


// Transform E.blob_close(args) to direct call (only 1 candidate)
@transform_no_return_blob_close@
expression E;
identifier FP_NAME = blob_close;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_clear_bindings(args);


// Transform E.blob_open(args) to direct call (only 1 candidate)
@transform_no_return_blob_open@
expression E;
identifier FP_NAME = blob_open;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_create_module_v2(args);


// Transform E.blob_read(args) to direct call (only 1 candidate)
@transform_no_return_blob_read@
expression E;
identifier FP_NAME = blob_read;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_bind_zeroblob(args);


// Transform E.blob_reopen(args) to direct call (only 1 candidate)
@transform_no_return_blob_reopen@
expression E;
identifier FP_NAME = blob_reopen;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_db_status(args);


// Transform E.blob_write(args) to direct call (only 1 candidate)
@transform_no_return_blob_write@
expression E;
identifier FP_NAME = blob_write;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_blob_bytes(args);


// Transform E.busy_handler(args) to direct call (only 1 candidate)
@transform_no_return_busy_handler@
expression E;
identifier FP_NAME = busy_handler;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_bind_value(args);


// Transform E.busy_timeout(args) to direct call (only 1 candidate)
@transform_no_return_busy_timeout@
expression E;
identifier FP_NAME = busy_timeout;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_busy_handler(args);


// Transform E.cancel_auto_extension(args) to direct call (only 1 candidate)
@transform_no_return_cancel_auto_extension@
expression E;
identifier FP_NAME = cancel_auto_extension;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_db_filename(args);


// Transform E.changes(args) to direct call (only 1 candidate)
@transform_no_return_changes@
expression E;
identifier FP_NAME = changes;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_busy_timeout(args);


// Transform E.changes64(args) to direct call (only 1 candidate)
@transform_no_return_changes64@
expression E;
identifier FP_NAME = changes64;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_str_value(args);


// Transform E.clear_bindings(args) to direct call (only 1 candidate)
@transform_no_return_clear_bindings@
expression E;
identifier FP_NAME = clear_bindings;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_vmprintf(args);


// Transform E.close(args) to direct call (only 1 candidate)
@transform_no_return_close@
expression E;
identifier FP_NAME = close;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_changes(args);


// Transform E.close_v2(args) to direct call (only 1 candidate)
@transform_no_return_close_v2@
expression E;
identifier FP_NAME = close_v2;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_soft_heap_limit64(args);


// Transform E.collation_needed(args) to direct call (only 1 candidate)
@transform_no_return_collation_needed@
expression E;
identifier FP_NAME = collation_needed;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_close(args);


// Transform E.collation_needed16(args) to direct call (only 1 candidate)
@transform_no_return_collation_needed16@
expression E;
identifier FP_NAME = collation_needed16;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_collation_needed(args);


// Transform E.column_blob(args) to direct call (only 1 candidate)
@transform_no_return_column_blob@
expression E;
identifier FP_NAME = column_blob;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_collation_needed16(args);


// Transform E.column_bytes(args) to direct call (only 1 candidate)
@transform_no_return_column_bytes@
expression E;
identifier FP_NAME = column_bytes;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_column_blob(args);


// Transform E.column_bytes16(args) to direct call (only 1 candidate)
@transform_no_return_column_bytes16@
expression E;
identifier FP_NAME = column_bytes16;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_column_bytes(args);


// Transform E.column_count(args) to direct call (only 1 candidate)
@transform_no_return_column_count@
expression E;
identifier FP_NAME = column_count;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_column_bytes16(args);


// Transform E.column_database_name(args) to direct call (only 1 candidate)
@transform_no_return_column_database_name@
expression E;
identifier FP_NAME = column_database_name;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_column_count(args);


// Transform E.column_database_name16(args) to direct call (only 1 candidate)
@transform_no_return_column_database_name16@
expression E;
identifier FP_NAME = column_database_name16;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_column_database_name(args);


// Transform E.column_decltype(args) to direct call (only 1 candidate)
@transform_no_return_column_decltype@
expression E;
identifier FP_NAME = column_decltype;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_column_database_name16(args);


// Transform E.column_decltype16(args) to direct call (only 1 candidate)
@transform_no_return_column_decltype16@
expression E;
identifier FP_NAME = column_decltype16;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_column_decltype(args);


// Transform E.column_double(args) to direct call (only 1 candidate)
@transform_no_return_column_double@
expression E;
identifier FP_NAME = column_double;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_column_decltype16(args);


// Transform E.column_int(args) to direct call (only 1 candidate)
@transform_no_return_column_int@
expression E;
identifier FP_NAME = column_int;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_column_double(args);


// Transform E.column_int64(args) to direct call (only 1 candidate)
@transform_no_return_column_int64@
expression E;
identifier FP_NAME = column_int64;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_column_int(args);


// Transform E.column_name(args) to direct call (only 1 candidate)
@transform_no_return_column_name@
expression E;
identifier FP_NAME = column_name;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_column_int64(args);


// Transform E.column_name16(args) to direct call (only 1 candidate)
@transform_no_return_column_name16@
expression E;
identifier FP_NAME = column_name16;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_column_name(args);


// Transform E.column_origin_name(args) to direct call (only 1 candidate)
@transform_no_return_column_origin_name@
expression E;
identifier FP_NAME = column_origin_name;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_column_name16(args);


// Transform E.column_origin_name16(args) to direct call (only 1 candidate)
@transform_no_return_column_origin_name16@
expression E;
identifier FP_NAME = column_origin_name16;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_column_origin_name(args);


// Transform E.column_table_name(args) to direct call (only 1 candidate)
@transform_no_return_column_table_name@
expression E;
identifier FP_NAME = column_table_name;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_column_origin_name16(args);


// Transform E.column_table_name16(args) to direct call (only 1 candidate)
@transform_no_return_column_table_name16@
expression E;
identifier FP_NAME = column_table_name16;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_column_table_name(args);


// Transform E.column_text(args) to direct call (only 1 candidate)
@transform_no_return_column_text@
expression E;
identifier FP_NAME = column_text;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_column_table_name16(args);


// Transform E.column_text16(args) to direct call (only 1 candidate)
@transform_no_return_column_text16@
expression E;
identifier FP_NAME = column_text16;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_column_text(args);


// Transform E.column_type(args) to direct call (only 1 candidate)
@transform_no_return_column_type@
expression E;
identifier FP_NAME = column_type;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_column_text16(args);


// Transform E.column_value(args) to direct call (only 1 candidate)
@transform_no_return_column_value@
expression E;
identifier FP_NAME = column_value;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_column_type(args);


// Transform E.commit_hook(args) to direct call (only 1 candidate)
@transform_no_return_commit_hook@
expression E;
identifier FP_NAME = commit_hook;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_column_value(args);


// Transform E.compileoption_get(args) to direct call (only 1 candidate)
@transform_no_return_compileoption_get@
expression E;
identifier FP_NAME = compileoption_get;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_limit(args);


// Transform E.compileoption_used(args) to direct call (only 1 candidate)
@transform_no_return_compileoption_used@
expression E;
identifier FP_NAME = compileoption_used;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_next_stmt(args);


// Transform E.complete(args) to direct call (only 1 candidate)
@transform_no_return_complete@
expression E;
identifier FP_NAME = complete;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_commit_hook(args);


// Transform E.complete16(args) to direct call (only 1 candidate)
@transform_no_return_complete16@
expression E;
identifier FP_NAME = complete16;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_complete(args);


// Transform E.context_db_handle(args) to direct call (only 1 candidate)
@transform_no_return_context_db_handle@
expression E;
identifier FP_NAME = context_db_handle;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_soft_heap_limit(args);


// Transform E.create_collation(args) to direct call (only 1 candidate)
@transform_no_return_create_collation@
expression E;
identifier FP_NAME = create_collation;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_complete16(args);


// Transform E.create_collation16(args) to direct call (only 1 candidate)
@transform_no_return_create_collation16@
expression E;
identifier FP_NAME = create_collation16;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_create_collation(args);


// Transform E.create_collation_v2(args) to direct call (only 1 candidate)
@transform_no_return_create_collation_v2@
expression E;
identifier FP_NAME = create_collation_v2;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_blob_close(args);


// Transform E.create_filename(args) to direct call (only 1 candidate)
@transform_no_return_create_filename@
expression E;
identifier FP_NAME = create_filename;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_str_appendchar(args);


// Transform E.create_function(args) to direct call (only 1 candidate)
@transform_no_return_create_function@
expression E;
identifier FP_NAME = create_function;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_create_collation16(args);


// Transform E.create_function16(args) to direct call (only 1 candidate)
@transform_no_return_create_function16@
expression E;
identifier FP_NAME = create_function16;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_create_function(args);


// Transform E.create_function_v2(args) to direct call (only 1 candidate)
@transform_no_return_create_function_v2@
expression E;
identifier FP_NAME = create_function_v2;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_sql(args);


// Transform E.create_module(args) to direct call (only 1 candidate)
@transform_no_return_create_module@
expression E;
identifier FP_NAME = create_module;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_create_function16(args);


// Transform E.create_module_v2(args) to direct call (only 1 candidate)
@transform_no_return_create_module_v2@
expression E;
identifier FP_NAME = create_module_v2;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_overload_function(args);


// Transform E.create_window_function(args) to direct call (only 1 candidate)
@transform_no_return_create_window_function@
expression E;
identifier FP_NAME = create_window_function;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_vtab_collation(args);


// Transform E.data_count(args) to direct call (only 1 candidate)
@transform_no_return_data_count@
expression E;
identifier FP_NAME = data_count;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_create_module(args);


// Transform E.database_file_object(args) to direct call (only 1 candidate)
@transform_no_return_database_file_object@
expression E;
identifier FP_NAME = database_file_object;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_str_errcode(args);


// Transform E.db_cacheflush(args) to direct call (only 1 candidate)
@transform_no_return_db_cacheflush@
expression E;
identifier FP_NAME = db_cacheflush;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_malloc64(args);


// Transform E.db_config(args) to direct call (only 1 candidate)
@transform_no_return_db_config@
expression E;
identifier FP_NAME = db_config;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_status(args);


// Transform E.db_filename(args) to direct call (only 1 candidate)
@transform_no_return_db_filename@
expression E;
identifier FP_NAME = db_filename;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_sourceid(args);


// Transform E.db_handle(args) to direct call (only 1 candidate)
@transform_no_return_db_handle@
expression E;
identifier FP_NAME = db_handle;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_data_count(args);


// Transform E.db_mutex(args) to direct call (only 1 candidate)
@transform_no_return_db_mutex@
expression E;
identifier FP_NAME = db_mutex;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_backup_finish(args);


// Transform E.db_name(args) to direct call (only 1 candidate)
@transform_no_return_db_name@
expression E;
identifier FP_NAME = db_name;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_filename_journal(args);


// Transform E.db_readonly(args) to direct call (only 1 candidate)
@transform_no_return_db_readonly@
expression E;
identifier FP_NAME = db_readonly;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_stmt_status(args);


// Transform E.db_release_memory(args) to direct call (only 1 candidate)
@transform_no_return_db_release_memory@
expression E;
identifier FP_NAME = db_release_memory;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_strnicmp(args);


// Transform E.db_status(args) to direct call (only 1 candidate)
@transform_no_return_db_status@
expression E;
identifier FP_NAME = db_status;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_backup_init(args);


// Transform E.declare_vtab(args) to direct call (only 1 candidate)
@transform_no_return_declare_vtab@
expression E;
identifier FP_NAME = declare_vtab;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_db_handle(args);


// Transform E.deserialize(args) to direct call (only 1 candidate)
@transform_no_return_deserialize@
expression E;
identifier FP_NAME = deserialize;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_uri_key(args);


// Transform E.drop_modules(args) to direct call (only 1 candidate)
@transform_no_return_drop_modules@
expression E;
identifier FP_NAME = drop_modules;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_str_new(args);


// Transform E.enable_shared_cache(args) to direct call (only 1 candidate)
@transform_no_return_enable_shared_cache@
expression E;
identifier FP_NAME = enable_shared_cache;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_declare_vtab(args);


// Transform E.errcode(args) to direct call (only 1 candidate)
@transform_no_return_errcode@
expression E;
identifier FP_NAME = errcode;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_enable_shared_cache(args);


// Transform E.errmsg(args) to direct call (only 1 candidate)
@transform_no_return_errmsg@
expression E;
identifier FP_NAME = errmsg;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_errcode(args);


// Transform E.errmsg16(args) to direct call (only 1 candidate)
@transform_no_return_errmsg16@
expression E;
identifier FP_NAME = errmsg16;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_errmsg(args);


// Transform E.exec(args) to direct call (only 1 candidate)
@transform_no_return_exec@
expression E;
identifier FP_NAME = exec;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_errmsg16(args);


// Transform E.expanded_sql(args) to direct call (only 1 candidate)
@transform_no_return_expanded_sql@
expression E;
identifier FP_NAME = expanded_sql;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_reset_auto_extension(args);


// Transform E.expired(args) to direct call (only 1 candidate)
@transform_no_return_expired@
expression E;
identifier FP_NAME = expired;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_exec(args);


// Transform E.extended_errcode(args) to direct call (only 1 candidate)
@transform_no_return_extended_errcode@
expression E;
identifier FP_NAME = extended_errcode;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_backup_pagecount(args);


// Transform E.extended_result_codes(args) to direct call (only 1 candidate)
@transform_no_return_extended_result_codes@
expression E;
identifier FP_NAME = extended_result_codes;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_vfs_find(args);


// Transform E.file_control(args) to direct call (only 1 candidate)
@transform_no_return_file_control@
expression E;
identifier FP_NAME = file_control;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_blob_open(args);


// Transform E.filename_database(args) to direct call (only 1 candidate)
@transform_no_return_filename_database@
expression E;
identifier FP_NAME = filename_database;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_str_vappendf(args);


// Transform E.filename_journal(args) to direct call (only 1 candidate)
@transform_no_return_filename_journal@
expression E;
identifier FP_NAME = filename_journal;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_str_append(args);


// Transform E.filename_wal(args) to direct call (only 1 candidate)
@transform_no_return_filename_wal@
expression E;
identifier FP_NAME = filename_wal;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_str_appendall(args);


// Transform E.free_filename(args) to direct call (only 1 candidate)
@transform_no_return_free_filename@
expression E;
identifier FP_NAME = free_filename;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_str_reset(args);


// Transform E.get_autocommit(args) to direct call (only 1 candidate)
@transform_no_return_get_autocommit@
expression E;
identifier FP_NAME = get_autocommit;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_free(args);


// Transform E.get_auxdata(args) to direct call (only 1 candidate)
@transform_no_return_get_auxdata@
expression E;
identifier FP_NAME = get_auxdata;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_free_table(args);


// Transform E.get_clientdata(args) to direct call (only 1 candidate)
@transform_no_return_get_clientdata@
expression E;
identifier FP_NAME = get_clientdata;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_database_file_object(args);


// Transform E.get_table(args) to direct call (only 1 candidate)
@transform_no_return_get_table@
expression E;
identifier FP_NAME = get_table;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_get_autocommit(args);


// Transform E.global_recover(args) to direct call (only 1 candidate)
@transform_no_return_global_recover@
expression E;
identifier FP_NAME = global_recover;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_get_auxdata(args);


// Transform E.hard_heap_limit64(args) to direct call (only 1 candidate)
@transform_no_return_hard_heap_limit64@
expression E;
identifier FP_NAME = hard_heap_limit64;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_str_finish(args);


// Transform E.interruptx(args) to direct call (only 1 candidate)
@transform_no_return_interruptx@
expression E;
identifier FP_NAME = interruptx;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_get_table(args);


// Transform E.is_interrupted(args) to direct call (only 1 candidate)
@transform_no_return_is_interrupted@
expression E;
identifier FP_NAME = is_interrupted;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_create_filename(args);


// Transform E.keyword_check(args) to direct call (only 1 candidate)
@transform_no_return_keyword_check@
expression E;
identifier FP_NAME = keyword_check;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_db_cacheflush(args);


// Transform E.keyword_count(args) to direct call (only 1 candidate)
@transform_no_return_keyword_count@
expression E;
identifier FP_NAME = keyword_count;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_status64(args);


// Transform E.keyword_name(args) to direct call (only 1 candidate)
@transform_no_return_keyword_name@
expression E;
identifier FP_NAME = keyword_name;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_strlike(args);


// Transform E.libversion(args) to direct call (only 1 candidate)
@transform_no_return_libversion@
expression E;
identifier FP_NAME = libversion;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_interrupt(args);


// Transform E.libversion_number(args) to direct call (only 1 candidate)
@transform_no_return_libversion_number@
expression E;
identifier FP_NAME = libversion_number;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_last_insert_rowid(args);


// Transform E.limit(args) to direct call (only 1 candidate)
@transform_no_return_limit@
expression E;
identifier FP_NAME = limit;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_vfs_register(args);


// Transform E.load_extension(args) to direct call (only 1 candidate)
@transform_no_return_load_extension@
expression E;
identifier FP_NAME = load_extension;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_db_readonly(args);


// Transform E.log(args) to direct call (only 1 candidate)
@transform_no_return_log@
expression E;
identifier FP_NAME = log;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_backup_remaining(args);


// Transform E.malloc(args) to direct call (only 1 candidate)
@transform_no_return_malloc@
expression E;
identifier FP_NAME = malloc;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_libversion(args);


// Transform E.malloc64(args) to direct call (only 1 candidate)
@transform_no_return_malloc64@
expression E;
identifier FP_NAME = malloc64;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_db_release_memory(args);


// Transform E.memory_highwater(args) to direct call (only 1 candidate)
@transform_no_return_memory_highwater@
expression E;
identifier FP_NAME = memory_highwater;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_blob_read(args);


// Transform E.memory_used(args) to direct call (only 1 candidate)
@transform_no_return_memory_used@
expression E;
identifier FP_NAME = memory_used;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_blob_write(args);


// Transform E.mprintf(args) to direct call (only 1 candidate)
@transform_no_return_mprintf@
expression E;
identifier FP_NAME = mprintf;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_libversion_number(args);


// Transform E.msize(args) to direct call (only 1 candidate)
@transform_no_return_msize@
expression E;
identifier FP_NAME = msize;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_errstr(args);


// Transform E.mutex_alloc(args) to direct call (only 1 candidate)
@transform_no_return_mutex_alloc@
expression E;
identifier FP_NAME = mutex_alloc;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_create_collation_v2(args);


// Transform E.mutex_enter(args) to direct call (only 1 candidate)
@transform_no_return_mutex_enter@
expression E;
identifier FP_NAME = mutex_enter;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_file_control(args);


// Transform E.mutex_free(args) to direct call (only 1 candidate)
@transform_no_return_mutex_free@
expression E;
identifier FP_NAME = mutex_free;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_memory_highwater(args);


// Transform E.mutex_leave(args) to direct call (only 1 candidate)
@transform_no_return_mutex_leave@
expression E;
identifier FP_NAME = mutex_leave;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_memory_used(args);


// Transform E.next_stmt(args) to direct call (only 1 candidate)
@transform_no_return_next_stmt@
expression E;
identifier FP_NAME = next_stmt;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_vfs_unregister(args);


// Transform E.normalized_sql(args) to direct call (only 1 candidate)
@transform_no_return_normalized_sql@
expression E;
identifier FP_NAME = normalized_sql;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_keyword_count(args);


// Transform E.open(args) to direct call (only 1 candidate)
@transform_no_return_open@
expression E;
identifier FP_NAME = open;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_malloc(args);


// Transform E.open16(args) to direct call (only 1 candidate)
@transform_no_return_open16@
expression E;
identifier FP_NAME = open16;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_mprintf(args);


// Transform E.overload_function(args) to direct call (only 1 candidate)
@transform_no_return_overload_function@
expression E;
identifier FP_NAME = overload_function;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_value_text16be(args);


// Transform E.prepare(args) to direct call (only 1 candidate)
@transform_no_return_prepare@
expression E;
identifier FP_NAME = prepare;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_open(args);


// Transform E.prepare16(args) to direct call (only 1 candidate)
@transform_no_return_prepare16@
expression E;
identifier FP_NAME = prepare16;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_open16(args);


// Transform E.prepare16_v2(args) to direct call (only 1 candidate)
@transform_no_return_prepare16_v2@
expression E;
identifier FP_NAME = prepare16_v2;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_value_type(args);


// Transform E.prepare16_v3(args) to direct call (only 1 candidate)
@transform_no_return_prepare16_v3@
expression E;
identifier FP_NAME = prepare16_v3;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_strglob(args);


// Transform E.prepare_v2(args) to direct call (only 1 candidate)
@transform_no_return_prepare_v2@
expression E;
identifier FP_NAME = prepare_v2;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_value_text16le(args);


// Transform E.prepare_v3(args) to direct call (only 1 candidate)
@transform_no_return_prepare_v3@
expression E;
identifier FP_NAME = prepare_v3;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_result_text64(args);


// Transform E.profile(args) to direct call (only 1 candidate)
@transform_no_return_profile@
expression E;
identifier FP_NAME = profile;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_prepare(args);


// Transform E.progress_handler(args) to direct call (only 1 candidate)
@transform_no_return_progress_handler@
expression E;
identifier FP_NAME = progress_handler;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_prepare16(args);


// Transform E.randomness(args) to direct call (only 1 candidate)
@transform_no_return_randomness@
expression E;
identifier FP_NAME = randomness;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_sleep(args);


// Transform E.realloc(args) to direct call (only 1 candidate)
@transform_no_return_realloc@
expression E;
identifier FP_NAME = realloc;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_profile(args);


// Transform E.realloc64(args) to direct call (only 1 candidate)
@transform_no_return_realloc64@
expression E;
identifier FP_NAME = realloc64;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_stmt_busy(args);


// Transform E.reset(args) to direct call (only 1 candidate)
@transform_no_return_reset@
expression E;
identifier FP_NAME = reset;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_progress_handler(args);


// Transform E.reset_auto_extension(args) to direct call (only 1 candidate)
@transform_no_return_reset_auto_extension@
expression E;
identifier FP_NAME = reset_auto_extension;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_stmt_readonly(args);


// Transform E.result_blob(args) to direct call (only 1 candidate)
@transform_no_return_result_blob@
expression E;
identifier FP_NAME = result_blob;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_realloc(args);


// Transform E.result_blob64(args) to direct call (only 1 candidate)
@transform_no_return_result_blob64@
expression E;
identifier FP_NAME = result_blob64;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_stricmp(args);


// Transform E.result_double(args) to direct call (only 1 candidate)
@transform_no_return_result_double@
expression E;
identifier FP_NAME = result_double;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_reset(args);


// Transform E.result_error(args) to direct call (only 1 candidate)
@transform_no_return_result_error@
expression E;
identifier FP_NAME = result_error;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_result_blob(args);


// Transform E.result_error16(args) to direct call (only 1 candidate)
@transform_no_return_result_error16@
expression E;
identifier FP_NAME = result_error16;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_result_double(args);


// Transform E.result_error_code(args) to direct call (only 1 candidate)
@transform_no_return_result_error_code@
expression E;
identifier FP_NAME = result_error_code;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_result_error_nomem(args);


// Transform E.result_int(args) to direct call (only 1 candidate)
@transform_no_return_result_int@
expression E;
identifier FP_NAME = result_int;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_result_error(args);


// Transform E.result_int64(args) to direct call (only 1 candidate)
@transform_no_return_result_int64@
expression E;
identifier FP_NAME = result_int64;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_result_error16(args);


// Transform E.result_null(args) to direct call (only 1 candidate)
@transform_no_return_result_null@
expression E;
identifier FP_NAME = result_null;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_result_int(args);


// Transform E.result_pointer(args) to direct call (only 1 candidate)
@transform_no_return_result_pointer@
expression E;
identifier FP_NAME = result_pointer;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_value_free(args);


// Transform E.result_subtype(args) to direct call (only 1 candidate)
@transform_no_return_result_subtype@
expression E;
identifier FP_NAME = result_subtype;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_bind_text64(args);


// Transform E.result_text(args) to direct call (only 1 candidate)
@transform_no_return_result_text@
expression E;
identifier FP_NAME = result_text;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_result_int64(args);


// Transform E.result_text16(args) to direct call (only 1 candidate)
@transform_no_return_result_text16@
expression E;
identifier FP_NAME = result_text16;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_result_null(args);


// Transform E.result_text16be(args) to direct call (only 1 candidate)
@transform_no_return_result_text16be@
expression E;
identifier FP_NAME = result_text16be;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_result_text(args);


// Transform E.result_text16le(args) to direct call (only 1 candidate)
@transform_no_return_result_text16le@
expression E;
identifier FP_NAME = result_text16le;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_result_text16(args);


// Transform E.result_text64(args) to direct call (only 1 candidate)
@transform_no_return_result_text64@
expression E;
identifier FP_NAME = result_text64;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_uri_boolean(args);


// Transform E.result_value(args) to direct call (only 1 candidate)
@transform_no_return_result_value@
expression E;
identifier FP_NAME = result_value;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_result_text16be(args);


// Transform E.result_zeroblob(args) to direct call (only 1 candidate)
@transform_no_return_result_zeroblob@
expression E;
identifier FP_NAME = result_zeroblob;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_release_memory(args);


// Transform E.result_zeroblob64(args) to direct call (only 1 candidate)
@transform_no_return_result_zeroblob64@
expression E;
identifier FP_NAME = result_zeroblob64;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_wal_checkpoint_v2(args);


// Transform E.rollback_hook(args) to direct call (only 1 candidate)
@transform_no_return_rollback_hook@
expression E;
identifier FP_NAME = rollback_hook;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_result_text16le(args);


// Transform E.serialize(args) to direct call (only 1 candidate)
@transform_no_return_serialize@
expression E;
identifier FP_NAME = serialize;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_filename_database(args);


// Transform E.set_authorizer(args) to direct call (only 1 candidate)
@transform_no_return_set_authorizer@
expression E;
identifier FP_NAME = set_authorizer;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_result_value(args);


// Transform E.set_auxdata(args) to direct call (only 1 candidate)
@transform_no_return_set_auxdata@
expression E;
identifier FP_NAME = set_auxdata;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_rollback_hook(args);


// Transform E.set_clientdata(args) to direct call (only 1 candidate)
@transform_no_return_set_clientdata@
expression E;
identifier FP_NAME = set_clientdata;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_txn_state(args);


// Transform E.set_last_insert_rowid(args) to direct call (only 1 candidate)
@transform_no_return_set_last_insert_rowid@
expression E;
identifier FP_NAME = set_last_insert_rowid;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_result_blob64(args);


// Transform E.setlk_timeout(args) to direct call (only 1 candidate)
@transform_no_return_setlk_timeout@
expression E;
identifier FP_NAME = setlk_timeout;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_changes64(args);


// Transform E.soft_heap_limit(args) to direct call (only 1 candidate)
@transform_no_return_soft_heap_limit@
expression E;
identifier FP_NAME = soft_heap_limit;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_mutex_enter(args);


// Transform E.soft_heap_limit64(args) to direct call (only 1 candidate)
@transform_no_return_soft_heap_limit64@
expression E;
identifier FP_NAME = soft_heap_limit64;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_backup_step(args);


// Transform E.sql(args) to direct call (only 1 candidate)
@transform_no_return_sql@
expression E;
identifier FP_NAME = sql;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_threadsafe(args);


// Transform E.status(args) to direct call (only 1 candidate)
@transform_no_return_status@
expression E;
identifier FP_NAME = status;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_result_zeroblob(args);


// Transform E.status64(args) to direct call (only 1 candidate)
@transform_no_return_status64@
expression E;
identifier FP_NAME = status64;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_cancel_auto_extension(args);


// Transform E.step(args) to direct call (only 1 candidate)
@transform_no_return_step@
expression E;
identifier FP_NAME = step;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_set_auxdata(args);


// Transform E.stmt_explain(args) to direct call (only 1 candidate)
@transform_no_return_stmt_explain@
expression E;
identifier FP_NAME = stmt_explain;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_free_filename(args);


// Transform E.stmt_isexplain(args) to direct call (only 1 candidate)
@transform_no_return_stmt_isexplain@
expression E;
identifier FP_NAME = stmt_isexplain;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_keyword_name(args);


// Transform E.stmt_status(args) to direct call (only 1 candidate)
@transform_no_return_stmt_status@
expression E;
identifier FP_NAME = stmt_status;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_compileoption_used(args);


// Transform E.str_append(args) to direct call (only 1 candidate)
@transform_no_return_str_append@
expression E;
identifier FP_NAME = str_append;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_prepare_v3(args);


// Transform E.str_appendall(args) to direct call (only 1 candidate)
@transform_no_return_str_appendall@
expression E;
identifier FP_NAME = str_appendall;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_prepare16_v3(args);


// Transform E.str_appendchar(args) to direct call (only 1 candidate)
@transform_no_return_str_appendchar@
expression E;
identifier FP_NAME = str_appendchar;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_bind_pointer(args);


// Transform E.str_appendf(args) to direct call (only 1 candidate)
@transform_no_return_str_appendf@
expression E;
identifier FP_NAME = str_appendf;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_expanded_sql(args);


// Transform E.str_errcode(args) to direct call (only 1 candidate)
@transform_no_return_str_errcode@
expression E;
identifier FP_NAME = str_errcode;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_value_pointer(args);


// Transform E.str_finish(args) to direct call (only 1 candidate)
@transform_no_return_str_finish@
expression E;
identifier FP_NAME = str_finish;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_trace_v2(args);


// Transform E.str_length(args) to direct call (only 1 candidate)
@transform_no_return_str_length@
expression E;
identifier FP_NAME = str_length;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_vtab_nochange(args);


// Transform E.str_new(args) to direct call (only 1 candidate)
@transform_no_return_str_new@
expression E;
identifier FP_NAME = str_new;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_system_errno(args);


// Transform E.str_reset(args) to direct call (only 1 candidate)
@transform_no_return_str_reset@
expression E;
identifier FP_NAME = str_reset;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_result_pointer(args);


// Transform E.str_value(args) to direct call (only 1 candidate)
@transform_no_return_str_value@
expression E;
identifier FP_NAME = str_value;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_value_nochange(args);


// Transform E.str_vappendf(args) to direct call (only 1 candidate)
@transform_no_return_str_vappendf@
expression E;
identifier FP_NAME = str_vappendf;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_set_last_insert_rowid(args);


// Transform E.strglob(args) to direct call (only 1 candidate)
@transform_no_return_strglob@
expression E;
identifier FP_NAME = strglob;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_uri_int64(args);


// Transform E.stricmp(args) to direct call (only 1 candidate)
@transform_no_return_stricmp@
expression E;
identifier FP_NAME = stricmp;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_wal_checkpoint(args);


// Transform E.strlike(args) to direct call (only 1 candidate)
@transform_no_return_strlike@
expression E;
identifier FP_NAME = strlike;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_load_extension(args);


// Transform E.system_errno(args) to direct call (only 1 candidate)
@transform_no_return_system_errno@
expression E;
identifier FP_NAME = system_errno;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_msize(args);


// Transform E.table_column_metadata(args) to direct call (only 1 candidate)
@transform_no_return_table_column_metadata@
expression E;
identifier FP_NAME = table_column_metadata;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_snprintf(args);


// Transform E.test_control(args) to direct call (only 1 candidate)
@transform_no_return_test_control@
expression E;
identifier FP_NAME = test_control;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_result_error_toobig(args);


// Transform E.thread_cleanup(args) to direct call (only 1 candidate)
@transform_no_return_thread_cleanup@
expression E;
identifier FP_NAME = thread_cleanup;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_step(args);


// Transform E.total_changes(args) to direct call (only 1 candidate)
@transform_no_return_total_changes@
expression E;
identifier FP_NAME = total_changes;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_table_column_metadata(args);


// Transform E.total_changes64(args) to direct call (only 1 candidate)
@transform_no_return_total_changes64@
expression E;
identifier FP_NAME = total_changes64;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_create_window_function(args);


// Transform E.trace_v2(args) to direct call (only 1 candidate)
@transform_no_return_trace_v2@
expression E;
identifier FP_NAME = trace_v2;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_realloc64(args);


// Transform E.txn_state(args) to direct call (only 1 candidate)
@transform_no_return_txn_state@
expression E;
identifier FP_NAME = txn_state;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_str_length(args);


// Transform E.uri_boolean(args) to direct call (only 1 candidate)
@transform_no_return_uri_boolean@
expression E;
identifier FP_NAME = uri_boolean;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_wal_hook(args);


// Transform E.uri_key(args) to direct call (only 1 candidate)
@transform_no_return_uri_key@
expression E;
identifier FP_NAME = uri_key;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_str_appendf(args);


// Transform E.user_data(args) to direct call (only 1 candidate)
@transform_no_return_user_data@
expression E;
identifier FP_NAME = user_data;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_trace(args);


// Transform E.value_double(args) to direct call (only 1 candidate)
@transform_no_return_value_double@
expression E;
identifier FP_NAME = value_double;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_user_data(args);


// Transform E.value_dup(args) to direct call (only 1 candidate)
@transform_no_return_value_dup@
expression E;
identifier FP_NAME = value_dup;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_uri_parameter(args);


// Transform E.value_encoding(args) to direct call (only 1 candidate)
@transform_no_return_value_encoding@
expression E;
identifier FP_NAME = value_encoding;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_filename_wal(args);


// Transform E.value_free(args) to direct call (only 1 candidate)
@transform_no_return_value_free@
expression E;
identifier FP_NAME = value_free;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_vsnprintf(args);


// Transform E.value_frombind(args) to direct call (only 1 candidate)
@transform_no_return_value_frombind@
expression E;
identifier FP_NAME = value_frombind;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_keyword_check(args);


// Transform E.value_int(args) to direct call (only 1 candidate)
@transform_no_return_value_int@
expression E;
identifier FP_NAME = value_int;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_value_blob(args);


// Transform E.value_int64(args) to direct call (only 1 candidate)
@transform_no_return_value_int64@
expression E;
identifier FP_NAME = value_int64;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_value_bytes(args);


// Transform E.value_nochange(args) to direct call (only 1 candidate)
@transform_no_return_value_nochange@
expression E;
identifier FP_NAME = value_nochange;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_value_subtype(args);


// Transform E.value_numeric_type(args) to direct call (only 1 candidate)
@transform_no_return_value_numeric_type@
expression E;
identifier FP_NAME = value_numeric_type;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_value_bytes16(args);


// Transform E.value_pointer(args) to direct call (only 1 candidate)
@transform_no_return_value_pointer@
expression E;
identifier FP_NAME = value_pointer;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_result_zeroblob64(args);


// Transform E.value_subtype(args) to direct call (only 1 candidate)
@transform_no_return_value_subtype@
expression E;
identifier FP_NAME = value_subtype;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_bind_blob64(args);


// Transform E.value_text(args) to direct call (only 1 candidate)
@transform_no_return_value_text@
expression E;
identifier FP_NAME = value_text;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_value_double(args);


// Transform E.value_text16(args) to direct call (only 1 candidate)
@transform_no_return_value_text16@
expression E;
identifier FP_NAME = value_text16;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_value_int(args);


// Transform E.value_text16be(args) to direct call (only 1 candidate)
@transform_no_return_value_text16be@
expression E;
identifier FP_NAME = value_text16be;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_value_int64(args);


// Transform E.value_text16le(args) to direct call (only 1 candidate)
@transform_no_return_value_text16le@
expression E;
identifier FP_NAME = value_text16le;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_value_numeric_type(args);


// Transform E.value_type(args) to direct call (only 1 candidate)
@transform_no_return_value_type@
expression E;
identifier FP_NAME = value_type;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_value_text(args);


// Transform E.vfs_find(args) to direct call (only 1 candidate)
@transform_no_return_vfs_find@
expression E;
identifier FP_NAME = vfs_find;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_mutex_free(args);


// Transform E.vfs_register(args) to direct call (only 1 candidate)
@transform_no_return_vfs_register@
expression E;
identifier FP_NAME = vfs_register;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_mutex_leave(args);


// Transform E.vfs_unregister(args) to direct call (only 1 candidate)
@transform_no_return_vfs_unregister@
expression E;
identifier FP_NAME = vfs_unregister;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_mutex_try(args);


// Transform E.vmprintf(args) to direct call (only 1 candidate)
@transform_no_return_vmprintf@
expression E;
identifier FP_NAME = vmprintf;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_value_text16(args);


// Transform E.vtab_collation(args) to direct call (only 1 candidate)
@transform_no_return_vtab_collation@
expression E;
identifier FP_NAME = vtab_collation;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_result_subtype(args);


// Transform E.vtab_config(args) to direct call (only 1 candidate)
@transform_no_return_vtab_config@
expression E;
identifier FP_NAME = vtab_config;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_extended_errcode(args);


// Transform E.vtab_distinct(args) to direct call (only 1 candidate)
@transform_no_return_vtab_distinct@
expression E;
identifier FP_NAME = vtab_distinct;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_value_frombind(args);


// Transform E.vtab_nochange(args) to direct call (only 1 candidate)
@transform_no_return_vtab_nochange@
expression E;
identifier FP_NAME = vtab_nochange;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_bind_zeroblob64(args);


// Transform E.vtab_on_conflict(args) to direct call (only 1 candidate)
@transform_no_return_vtab_on_conflict@
expression E;
identifier FP_NAME = vtab_on_conflict;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_log(args);


// Transform E.wal_checkpoint(args) to direct call (only 1 candidate)
@transform_no_return_wal_checkpoint@
expression E;
identifier FP_NAME = wal_checkpoint;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_db_config(args);


// Transform E.wal_hook(args) to direct call (only 1 candidate)
@transform_no_return_wal_hook@
expression E;
identifier FP_NAME = wal_hook;
expression list args;
@@
- E.FP_NAME(args);
+ sqlite3_db_mutex(args);


// Transform E.xAccess(args) to if-chain with 4 candidates
@transform_no_return_xAccess@
expression E;
identifier FP_NAME = xAccess;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xAccess_signature, xAccess_signatures[xAccess_apndAccess_enum], sizeof(E.xAccess_signature)) == 0) {
+ apndAccess(args);
+ }
+ else if (memcmp(E.xAccess_signature, xAccess_signatures[xAccess_memdbAccess_enum], sizeof(E.xAccess_signature)) == 0) {
+ memdbAccess(args);
+ }
+ else if (memcmp(E.xAccess_signature, xAccess_signatures[xAccess_vfstraceAccess_enum], sizeof(E.xAccess_signature)) == 0) {
+ vfstraceAccess(args);
+ }
+ else if (memcmp(E.xAccess_signature, xAccess_signatures[xAccess_unixAccess_enum], sizeof(E.xAccess_signature)) == 0) {
+ unixAccess(args);
+ }


// Transform E.xBegin(args) to if-chain with 4 candidates
@transform_no_return_xBegin@
expression E;
identifier FP_NAME = xBegin;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xBegin_signature, xBegin_signatures[xBegin_0_enum], sizeof(E.xBegin_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xBegin_signature, xBegin_signatures[xBegin_dbpageBegin_enum], sizeof(E.xBegin_signature)) == 0) {
+ dbpageBegin(args);
+ }
+ else if (memcmp(E.xBegin_signature, xBegin_signatures[xBegin_fts3BeginMethod_enum], sizeof(E.xBegin_signature)) == 0) {
+ fts3BeginMethod(args);
+ }
+ else if (memcmp(E.xBegin_signature, xBegin_signatures[xBegin_rtreeBeginTransaction_enum], sizeof(E.xBegin_signature)) == 0) {
+ rtreeBeginTransaction(args);
+ }
+ else if (memcmp(E.xBegin_signature, xBegin_signatures[xBegin_zipfileBegin_enum], sizeof(E.xBegin_signature)) == 0) {
+ zipfileBegin(args);
+ }


// Transform E.xBestIndex(args) to if-chain with 16 candidates
@transform_no_return_xBestIndex@
expression E;
identifier FP_NAME = xBestIndex;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xBestIndex_signature, xBestIndex_signatures[xBestIndex_bytecodevtabBestIndex_enum], sizeof(E.xBestIndex_signature)) == 0) {
+ bytecodevtabBestIndex(args);
+ }
+ else if (memcmp(E.xBestIndex_signature, xBestIndex_signatures[xBestIndex_completionBestIndex_enum], sizeof(E.xBestIndex_signature)) == 0) {
+ completionBestIndex(args);
+ }
+ else if (memcmp(E.xBestIndex_signature, xBestIndex_signatures[xBestIndex_dbdataBestIndex_enum], sizeof(E.xBestIndex_signature)) == 0) {
+ dbdataBestIndex(args);
+ }
+ else if (memcmp(E.xBestIndex_signature, xBestIndex_signatures[xBestIndex_dbpageBestIndex_enum], sizeof(E.xBestIndex_signature)) == 0) {
+ dbpageBestIndex(args);
+ }
+ else if (memcmp(E.xBestIndex_signature, xBestIndex_signatures[xBestIndex_expertBestIndex_enum], sizeof(E.xBestIndex_signature)) == 0) {
+ expertBestIndex(args);
+ }
+ else if (memcmp(E.xBestIndex_signature, xBestIndex_signatures[xBestIndex_fsdirBestIndex_enum], sizeof(E.xBestIndex_signature)) == 0) {
+ fsdirBestIndex(args);
+ }
+ else if (memcmp(E.xBestIndex_signature, xBestIndex_signatures[xBestIndex_fts3BestIndexMethod_enum], sizeof(E.xBestIndex_signature)) == 0) {
+ fts3BestIndexMethod(args);
+ }
+ else if (memcmp(E.xBestIndex_signature, xBestIndex_signatures[xBestIndex_fts3auxBestIndexMethod_enum], sizeof(E.xBestIndex_signature)) == 0) {
+ fts3auxBestIndexMethod(args);
+ }
+ else if (memcmp(E.xBestIndex_signature, xBestIndex_signatures[xBestIndex_fts3tokBestIndexMethod_enum], sizeof(E.xBestIndex_signature)) == 0) {
+ fts3tokBestIndexMethod(args);
+ }
+ else if (memcmp(E.xBestIndex_signature, xBestIndex_signatures[xBestIndex_jsonEachBestIndex_enum], sizeof(E.xBestIndex_signature)) == 0) {
+ jsonEachBestIndex(args);
+ }
+ else if (memcmp(E.xBestIndex_signature, xBestIndex_signatures[xBestIndex_pragmaVtabBestIndex_enum], sizeof(E.xBestIndex_signature)) == 0) {
+ pragmaVtabBestIndex(args);
+ }
+ else if (memcmp(E.xBestIndex_signature, xBestIndex_signatures[xBestIndex_rtreeBestIndex_enum], sizeof(E.xBestIndex_signature)) == 0) {
+ rtreeBestIndex(args);
+ }
+ else if (memcmp(E.xBestIndex_signature, xBestIndex_signatures[xBestIndex_seriesBestIndex_enum], sizeof(E.xBestIndex_signature)) == 0) {
+ seriesBestIndex(args);
+ }
+ else if (memcmp(E.xBestIndex_signature, xBestIndex_signatures[xBestIndex_statBestIndex_enum], sizeof(E.xBestIndex_signature)) == 0) {
+ statBestIndex(args);
+ }
+ else if (memcmp(E.xBestIndex_signature, xBestIndex_signatures[xBestIndex_stmtBestIndex_enum], sizeof(E.xBestIndex_signature)) == 0) {
+ stmtBestIndex(args);
+ }
+ else if (memcmp(E.xBestIndex_signature, xBestIndex_signatures[xBestIndex_zipfileBestIndex_enum], sizeof(E.xBestIndex_signature)) == 0) {
+ zipfileBestIndex(args);
+ }


// Transform E.xCachesize(args) to if-chain with 2 candidates
@transform_no_return_xCachesize@
expression E;
identifier FP_NAME = xCachesize;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xCachesize_signature, xCachesize_signatures[xCachesize_pcache1Cachesize_enum], sizeof(E.xCachesize_signature)) == 0) {
+ pcache1Cachesize(args);
+ }
+ else if (memcmp(E.xCachesize_signature, xCachesize_signatures[xCachesize_pcachetraceCachesize_enum], sizeof(E.xCachesize_signature)) == 0) {
+ pcachetraceCachesize(args);
+ }


// Transform E.xCellSize(args) to if-chain with 4 candidates
@transform_no_return_xCellSize@
expression E;
identifier FP_NAME = xCellSize;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xCellSize_signature, xCellSize_signatures[xCellSize_cellSizePtr_enum], sizeof(E.xCellSize_signature)) == 0) {
+ cellSizePtr(args);
+ }
+ else if (memcmp(E.xCellSize_signature, xCellSize_signatures[xCellSize_cellSizePtrIdxLeaf_enum], sizeof(E.xCellSize_signature)) == 0) {
+ cellSizePtrIdxLeaf(args);
+ }
+ else if (memcmp(E.xCellSize_signature, xCellSize_signatures[xCellSize_cellSizePtrNoPayload_enum], sizeof(E.xCellSize_signature)) == 0) {
+ cellSizePtrNoPayload(args);
+ }
+ else if (memcmp(E.xCellSize_signature, xCellSize_signatures[xCellSize_cellSizePtrTableLeaf_enum], sizeof(E.xCellSize_signature)) == 0) {
+ cellSizePtrTableLeaf(args);
+ }


// Transform E.xCheckReservedLock(args) to if-chain with 6 candidates
@transform_no_return_xCheckReservedLock@
expression E;
identifier FP_NAME = xCheckReservedLock;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xCheckReservedLock_signature, xCheckReservedLock_signatures[xCheckReservedLock_0_enum], sizeof(E.xCheckReservedLock_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xCheckReservedLock_signature, xCheckReservedLock_signatures[xCheckReservedLock_apndCheckReservedLock_enum], sizeof(E.xCheckReservedLock_signature)) == 0) {
+ apndCheckReservedLock(args);
+ }
+ else if (memcmp(E.xCheckReservedLock_signature, xCheckReservedLock_signatures[xCheckReservedLock_recoverVfsCheckReservedLock_enum], sizeof(E.xCheckReservedLock_signature)) == 0) {
+ recoverVfsCheckReservedLock(args);
+ }
+ else if (memcmp(E.xCheckReservedLock_signature, xCheckReservedLock_signatures[xCheckReservedLock_vfstraceCheckReservedLock_enum], sizeof(E.xCheckReservedLock_signature)) == 0) {
+ vfstraceCheckReservedLock(args);
+ }
+ else if (memcmp(E.xCheckReservedLock_signature, xCheckReservedLock_signatures[xCheckReservedLock_unixCheckReservedLock_enum], sizeof(E.xCheckReservedLock_signature)) == 0) {
+ unixCheckReservedLock(args);
+ }
+ else if (memcmp(E.xCheckReservedLock_signature, xCheckReservedLock_signatures[xCheckReservedLock_nolockCheckReservedLock_enum], sizeof(E.xCheckReservedLock_signature)) == 0) {
+ nolockCheckReservedLock(args);
+ }
+ else if (memcmp(E.xCheckReservedLock_signature, xCheckReservedLock_signatures[xCheckReservedLock_dotlockCheckReservedLock_enum], sizeof(E.xCheckReservedLock_signature)) == 0) {
+ dotlockCheckReservedLock(args);
+ }


// Transform E.xClose(args) to if-chain with 27 candidates
@transform_no_return_xClose@
expression E;
identifier FP_NAME = xClose;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xClose_signature, xClose_signatures[xClose_apndClose_enum], sizeof(E.xClose_signature)) == 0) {
+ apndClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_bytecodevtabClose_enum], sizeof(E.xClose_signature)) == 0) {
+ bytecodevtabClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_completionClose_enum], sizeof(E.xClose_signature)) == 0) {
+ completionClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_dbdataClose_enum], sizeof(E.xClose_signature)) == 0) {
+ dbdataClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_dbpageClose_enum], sizeof(E.xClose_signature)) == 0) {
+ dbpageClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_expertClose_enum], sizeof(E.xClose_signature)) == 0) {
+ expertClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_fsdirClose_enum], sizeof(E.xClose_signature)) == 0) {
+ fsdirClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_fts3CloseMethod_enum], sizeof(E.xClose_signature)) == 0) {
+ fts3CloseMethod(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_fts3auxCloseMethod_enum], sizeof(E.xClose_signature)) == 0) {
+ fts3auxCloseMethod(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_fts3tokCloseMethod_enum], sizeof(E.xClose_signature)) == 0) {
+ fts3tokCloseMethod(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_jsonEachClose_enum], sizeof(E.xClose_signature)) == 0) {
+ jsonEachClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_memdbClose_enum], sizeof(E.xClose_signature)) == 0) {
+ memdbClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_memjrnlClose_enum], sizeof(E.xClose_signature)) == 0) {
+ memjrnlClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_porterClose_enum], sizeof(E.xClose_signature)) == 0) {
+ porterClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_pragmaVtabClose_enum], sizeof(E.xClose_signature)) == 0) {
+ pragmaVtabClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_recoverVfsClose_enum], sizeof(E.xClose_signature)) == 0) {
+ recoverVfsClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_rtreeClose_enum], sizeof(E.xClose_signature)) == 0) {
+ rtreeClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_seriesClose_enum], sizeof(E.xClose_signature)) == 0) {
+ seriesClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_simpleClose_enum], sizeof(E.xClose_signature)) == 0) {
+ simpleClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_statClose_enum], sizeof(E.xClose_signature)) == 0) {
+ statClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_stmtClose_enum], sizeof(E.xClose_signature)) == 0) {
+ stmtClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_unicodeClose_enum], sizeof(E.xClose_signature)) == 0) {
+ unicodeClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_vfstraceClose_enum], sizeof(E.xClose_signature)) == 0) {
+ vfstraceClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_zipfileClose_enum], sizeof(E.xClose_signature)) == 0) {
+ zipfileClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_unixClose_enum], sizeof(E.xClose_signature)) == 0) {
+ unixClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_nolockClose_enum], sizeof(E.xClose_signature)) == 0) {
+ nolockClose(args);
+ }
+ else if (memcmp(E.xClose_signature, xClose_signatures[xClose_dotlockClose_enum], sizeof(E.xClose_signature)) == 0) {
+ dotlockClose(args);
+ }


// Transform E.xColumn(args) to if-chain with 44 candidates
@transform_no_return_xColumn@
expression E;
identifier FP_NAME = xColumn;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_amatchColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ amatchColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_binfoColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ binfoColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_bytecodevtabColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ bytecodevtabColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_carrayColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ carrayColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_cidxColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ cidxColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_closureColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ closureColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_completionColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ completionColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_csvtabColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ csvtabColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_dbdataColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ dbdataColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_dbpageColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ dbpageColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_deltaparsevtabColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ deltaparsevtabColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_echoColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ echoColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_expertColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ expertColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_explainColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ explainColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_fsColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ fsColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_fsdirColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ fsdirColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_fstreeColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ fstreeColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_fts3ColumnMethod_enum], sizeof(E.xColumn_signature)) == 0) {
+ fts3ColumnMethod(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_fts3auxColumnMethod_enum], sizeof(E.xColumn_signature)) == 0) {
+ fts3auxColumnMethod(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_fts3termColumnMethod_enum], sizeof(E.xColumn_signature)) == 0) {
+ fts3termColumnMethod(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_fts3tokColumnMethod_enum], sizeof(E.xColumn_signature)) == 0) {
+ fts3tokColumnMethod(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_fuzzerColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ fuzzerColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_geopolyColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ geopolyColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_intarrayColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ intarrayColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_jsonEachColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ jsonEachColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_memstatColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ memstatColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_pragmaVtabColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ pragmaVtabColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_prefixesColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ prefixesColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_qpvtabColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ qpvtabColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_rtreeColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ rtreeColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_schemaColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ schemaColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_seriesColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ seriesColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_spellfix1Column_enum], sizeof(E.xColumn_signature)) == 0) {
+ spellfix1Column(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_statColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ statColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_stmtColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ stmtColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_tclColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ tclColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_tclvarColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ tclvarColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_templatevtabColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ templatevtabColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_unionColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ unionColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_vlogColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ vlogColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_vstattabColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ vstattabColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_vtablogColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ vtablogColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_wholenumberColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ wholenumberColumn(args);
+ }
+ else if (memcmp(E.xColumn_signature, xColumn_signatures[xColumn_zipfileColumn_enum], sizeof(E.xColumn_signature)) == 0) {
+ zipfileColumn(args);
+ }


// Transform E.xCommit(args) to if-chain with 5 candidates
@transform_no_return_xCommit@
expression E;
identifier FP_NAME = xCommit;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xCommit_signature, xCommit_signatures[xCommit_0_enum], sizeof(E.xCommit_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xCommit_signature, xCommit_signatures[xCommit_echoCommit_enum], sizeof(E.xCommit_signature)) == 0) {
+ echoCommit(args);
+ }
+ else if (memcmp(E.xCommit_signature, xCommit_signatures[xCommit_fts3CommitMethod_enum], sizeof(E.xCommit_signature)) == 0) {
+ fts3CommitMethod(args);
+ }
+ else if (memcmp(E.xCommit_signature, xCommit_signatures[xCommit_rtreeEndTransaction_enum], sizeof(E.xCommit_signature)) == 0) {
+ rtreeEndTransaction(args);
+ }
+ else if (memcmp(E.xCommit_signature, xCommit_signatures[xCommit_vtablogCommit_enum], sizeof(E.xCommit_signature)) == 0) {
+ vtablogCommit(args);
+ }
+ else if (memcmp(E.xCommit_signature, xCommit_signatures[xCommit_zipfileCommit_enum], sizeof(E.xCommit_signature)) == 0) {
+ zipfileCommit(args);
+ }


// Transform E.xConnect(args) to if-chain with 44 candidates
@transform_no_return_xConnect@
expression E;
identifier FP_NAME = xConnect;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_amatchConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ amatchConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_binfoConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ binfoConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_bytecodevtabConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ bytecodevtabConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_carrayConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ carrayConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_cidxConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ cidxConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_closureConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ closureConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_completionConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ completionConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_csvtabConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ csvtabConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_dbdataConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ dbdataConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_dbpageConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ dbpageConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_deltaparsevtabConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ deltaparsevtabConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_echoConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ echoConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_expertConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ expertConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_explainConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ explainConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_fsConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ fsConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_fsdirConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ fsdirConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_fstreeConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ fstreeConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_fts3ConnectMethod_enum], sizeof(E.xConnect_signature)) == 0) {
+ fts3ConnectMethod(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_fts3auxConnectMethod_enum], sizeof(E.xConnect_signature)) == 0) {
+ fts3auxConnectMethod(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_fts3termConnectMethod_enum], sizeof(E.xConnect_signature)) == 0) {
+ fts3termConnectMethod(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_fts3tokConnectMethod_enum], sizeof(E.xConnect_signature)) == 0) {
+ fts3tokConnectMethod(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_fuzzerConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ fuzzerConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_geopolyConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ geopolyConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_intarrayCreate_enum], sizeof(E.xConnect_signature)) == 0) {
+ intarrayCreate(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_jsonEachConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ jsonEachConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_memstatConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ memstatConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_pragmaVtabConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ pragmaVtabConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_prefixesConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ prefixesConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_qpvtabConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ qpvtabConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_rtreeConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ rtreeConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_schemaCreate_enum], sizeof(E.xConnect_signature)) == 0) {
+ schemaCreate(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_seriesConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ seriesConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_spellfix1Connect_enum], sizeof(E.xConnect_signature)) == 0) {
+ spellfix1Connect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_statConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ statConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_stmtConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ stmtConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_tclConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ tclConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_tclvarConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ tclvarConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_templatevtabConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ templatevtabConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_unionConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ unionConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_vlogConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ vlogConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_vstattabConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ vstattabConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_vtablogConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ vtablogConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_wholenumberConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ wholenumberConnect(args);
+ }
+ else if (memcmp(E.xConnect_signature, xConnect_signatures[xConnect_zipfileConnect_enum], sizeof(E.xConnect_signature)) == 0) {
+ zipfileConnect(args);
+ }


// Transform E.xCount(args) to if-chain with 3 candidates
@transform_no_return_xCount@
expression E;
identifier FP_NAME = xCount;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xCount_signature, xCount_signatures[xCount_sessionDiffCount_enum], sizeof(E.xCount_signature)) == 0) {
+ sessionDiffCount(args);
+ }
+ else if (memcmp(E.xCount_signature, xCount_signatures[xCount_sessionPreupdateCount_enum], sizeof(E.xCount_signature)) == 0) {
+ sessionPreupdateCount(args);
+ }
+ else if (memcmp(E.xCount_signature, xCount_signatures[xCount_sessionStat1Count_enum], sizeof(E.xCount_signature)) == 0) {
+ sessionStat1Count(args);
+ }


// Transform E.xCreate(args) to if-chain with 34 candidates
@transform_no_return_xCreate@
expression E;
identifier FP_NAME = xCreate;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_0_enum], sizeof(E.xCreate_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_amatchConnect_enum], sizeof(E.xCreate_signature)) == 0) {
+ amatchConnect(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_closureConnect_enum], sizeof(E.xCreate_signature)) == 0) {
+ closureConnect(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_csvtabCreate_enum], sizeof(E.xCreate_signature)) == 0) {
+ csvtabCreate(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_dbpageConnect_enum], sizeof(E.xCreate_signature)) == 0) {
+ dbpageConnect(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_echoCreate_enum], sizeof(E.xCreate_signature)) == 0) {
+ echoCreate(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_expertConnect_enum], sizeof(E.xCreate_signature)) == 0) {
+ expertConnect(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_f5tOrigintextCreate_enum], sizeof(E.xCreate_signature)) == 0) {
+ f5tOrigintextCreate(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_f5tTokenizerCreate_enum], sizeof(E.xCreate_signature)) == 0) {
+ f5tTokenizerCreate(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_fsConnect_enum], sizeof(E.xCreate_signature)) == 0) {
+ fsConnect(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_fsdirConnect_enum], sizeof(E.xCreate_signature)) == 0) {
+ fsdirConnect(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_fstreeConnect_enum], sizeof(E.xCreate_signature)) == 0) {
+ fstreeConnect(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_fts3CreateMethod_enum], sizeof(E.xCreate_signature)) == 0) {
+ fts3CreateMethod(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_fts3auxConnectMethod_enum], sizeof(E.xCreate_signature)) == 0) {
+ fts3auxConnectMethod(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_fts3termConnectMethod_enum], sizeof(E.xCreate_signature)) == 0) {
+ fts3termConnectMethod(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_fts3tokConnectMethod_enum], sizeof(E.xCreate_signature)) == 0) {
+ fts3tokConnectMethod(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_fuzzerConnect_enum], sizeof(E.xCreate_signature)) == 0) {
+ fuzzerConnect(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_geopolyCreate_enum], sizeof(E.xCreate_signature)) == 0) {
+ geopolyCreate(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_intarrayCreate_enum], sizeof(E.xCreate_signature)) == 0) {
+ intarrayCreate(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_pcache1Create_enum], sizeof(E.xCreate_signature)) == 0) {
+ pcache1Create(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_pcachetraceCreate_enum], sizeof(E.xCreate_signature)) == 0) {
+ pcachetraceCreate(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_porterCreate_enum], sizeof(E.xCreate_signature)) == 0) {
+ porterCreate(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_rtreeCreate_enum], sizeof(E.xCreate_signature)) == 0) {
+ rtreeCreate(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_schemaCreate_enum], sizeof(E.xCreate_signature)) == 0) {
+ schemaCreate(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_simpleCreate_enum], sizeof(E.xCreate_signature)) == 0) {
+ simpleCreate(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_spellfix1Create_enum], sizeof(E.xCreate_signature)) == 0) {
+ spellfix1Create(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_statConnect_enum], sizeof(E.xCreate_signature)) == 0) {
+ statConnect(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_tclConnect_enum], sizeof(E.xCreate_signature)) == 0) {
+ tclConnect(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_tclvarConnect_enum], sizeof(E.xCreate_signature)) == 0) {
+ tclvarConnect(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_unicodeCreate_enum], sizeof(E.xCreate_signature)) == 0) {
+ unicodeCreate(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_unionConnect_enum], sizeof(E.xCreate_signature)) == 0) {
+ unionConnect(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_vlogConnect_enum], sizeof(E.xCreate_signature)) == 0) {
+ vlogConnect(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_vtablogCreate_enum], sizeof(E.xCreate_signature)) == 0) {
+ vtablogCreate(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_wholenumberConnect_enum], sizeof(E.xCreate_signature)) == 0) {
+ wholenumberConnect(args);
+ }
+ else if (memcmp(E.xCreate_signature, xCreate_signatures[xCreate_zipfileConnect_enum], sizeof(E.xCreate_signature)) == 0) {
+ zipfileConnect(args);
+ }


// Transform E.xCurrentTime(args) to if-chain with 3 candidates
@transform_no_return_xCurrentTime@
expression E;
identifier FP_NAME = xCurrentTime;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xCurrentTime_signature, xCurrentTime_signatures[xCurrentTime_0_enum], sizeof(E.xCurrentTime_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xCurrentTime_signature, xCurrentTime_signatures[xCurrentTime_apndCurrentTime_enum], sizeof(E.xCurrentTime_signature)) == 0) {
+ apndCurrentTime(args);
+ }
+ else if (memcmp(E.xCurrentTime_signature, xCurrentTime_signatures[xCurrentTime_vfstraceCurrentTime_enum], sizeof(E.xCurrentTime_signature)) == 0) {
+ vfstraceCurrentTime(args);
+ }
+ else if (memcmp(E.xCurrentTime_signature, xCurrentTime_signatures[xCurrentTime_unixCurrentTime_enum], sizeof(E.xCurrentTime_signature)) == 0) {
+ unixCurrentTime(args);
+ }


// Transform E.xCurrentTimeInt64(args) to if-chain with 3 candidates
@transform_no_return_xCurrentTimeInt64@
expression E;
identifier FP_NAME = xCurrentTimeInt64;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xCurrentTimeInt64_signature, xCurrentTimeInt64_signatures[xCurrentTimeInt64_0_enum], sizeof(E.xCurrentTimeInt64_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xCurrentTimeInt64_signature, xCurrentTimeInt64_signatures[xCurrentTimeInt64_apndCurrentTimeInt64_enum], sizeof(E.xCurrentTimeInt64_signature)) == 0) {
+ apndCurrentTimeInt64(args);
+ }
+ else if (memcmp(E.xCurrentTimeInt64_signature, xCurrentTimeInt64_signatures[xCurrentTimeInt64_memdbCurrentTimeInt64_enum], sizeof(E.xCurrentTimeInt64_signature)) == 0) {
+ memdbCurrentTimeInt64(args);
+ }
+ else if (memcmp(E.xCurrentTimeInt64_signature, xCurrentTimeInt64_signatures[xCurrentTimeInt64_unixCurrentTimeInt64_enum], sizeof(E.xCurrentTimeInt64_signature)) == 0) {
+ unixCurrentTimeInt64(args);
+ }


// Transform E.xDel(args) to if-chain with 3 candidates
@transform_no_return_xDel@
expression E;
identifier FP_NAME = xDel;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xDel_signature, xDel_signatures[xDel_0_enum], sizeof(E.xDel_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xDel_signature, xDel_signatures[xDel_sqlite3RowSetDelete_enum], sizeof(E.xDel_signature)) == 0) {
+ sqlite3RowSetDelete(args);
+ }
+ else if (memcmp(E.xDel_signature, xDel_signatures[xDel_sqlite3VdbeFrameMemDel_enum], sizeof(E.xDel_signature)) == 0) {
+ sqlite3VdbeFrameMemDel(args);
+ }
+ else if (memcmp(E.xDel_signature, xDel_signatures[xDel_sqlite3_free_enum], sizeof(E.xDel_signature)) == 0) {
+ sqlite3_free(args);
+ }


// Transform E.xDelete(args) to if-chain with 6 candidates
@transform_no_return_xDelete@
expression E;
identifier FP_NAME = xDelete;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xDelete_signature, xDelete_signatures[xDelete_0_enum], sizeof(E.xDelete_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xDelete_signature, xDelete_signatures[xDelete_apndDelete_enum], sizeof(E.xDelete_signature)) == 0) {
+ apndDelete(args);
+ }
+ else if (memcmp(E.xDelete_signature, xDelete_signatures[xDelete_f5tOrigintextDelete_enum], sizeof(E.xDelete_signature)) == 0) {
+ f5tOrigintextDelete(args);
+ }
+ else if (memcmp(E.xDelete_signature, xDelete_signatures[xDelete_f5tTokenizerDelete_enum], sizeof(E.xDelete_signature)) == 0) {
+ f5tTokenizerDelete(args);
+ }
+ else if (memcmp(E.xDelete_signature, xDelete_signatures[xDelete_kvstorageDelete_enum], sizeof(E.xDelete_signature)) == 0) {
+ kvstorageDelete(args);
+ }
+ else if (memcmp(E.xDelete_signature, xDelete_signatures[xDelete_vfstraceDelete_enum], sizeof(E.xDelete_signature)) == 0) {
+ vfstraceDelete(args);
+ }
+ else if (memcmp(E.xDelete_signature, xDelete_signatures[xDelete_unixDelete_enum], sizeof(E.xDelete_signature)) == 0) {
+ unixDelete(args);
+ }


// Transform E.xDepth(args) to if-chain with 3 candidates
@transform_no_return_xDepth@
expression E;
identifier FP_NAME = xDepth;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xDepth_signature, xDepth_signatures[xDepth_sessionDiffDepth_enum], sizeof(E.xDepth_signature)) == 0) {
+ sessionDiffDepth(args);
+ }
+ else if (memcmp(E.xDepth_signature, xDepth_signatures[xDepth_sessionPreupdateDepth_enum], sizeof(E.xDepth_signature)) == 0) {
+ sessionPreupdateDepth(args);
+ }
+ else if (memcmp(E.xDepth_signature, xDepth_signatures[xDepth_sessionStat1Depth_enum], sizeof(E.xDepth_signature)) == 0) {
+ sessionStat1Depth(args);
+ }


// Transform E.xDestroy(args) to if-chain with 14 candidates
@transform_no_return_xDestroy@
expression E;
identifier FP_NAME = xDestroy;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xDestroy_signature, xDestroy_signatures[xDestroy_0_enum], sizeof(E.xDestroy_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xDestroy_signature, xDestroy_signatures[xDestroy_dbpageDisconnect_enum], sizeof(E.xDestroy_signature)) == 0) {
+ dbpageDisconnect(args);
+ }
+ else if (memcmp(E.xDestroy_signature, xDestroy_signatures[xDestroy_expertDisconnect_enum], sizeof(E.xDestroy_signature)) == 0) {
+ expertDisconnect(args);
+ }
+ else if (memcmp(E.xDestroy_signature, xDestroy_signatures[xDestroy_fsdirDisconnect_enum], sizeof(E.xDestroy_signature)) == 0) {
+ fsdirDisconnect(args);
+ }
+ else if (memcmp(E.xDestroy_signature, xDestroy_signatures[xDestroy_fts3DestroyMethod_enum], sizeof(E.xDestroy_signature)) == 0) {
+ fts3DestroyMethod(args);
+ }
+ else if (memcmp(E.xDestroy_signature, xDestroy_signatures[xDestroy_fts3auxDisconnectMethod_enum], sizeof(E.xDestroy_signature)) == 0) {
+ fts3auxDisconnectMethod(args);
+ }
+ else if (memcmp(E.xDestroy_signature, xDestroy_signatures[xDestroy_fts3tokDisconnectMethod_enum], sizeof(E.xDestroy_signature)) == 0) {
+ fts3tokDisconnectMethod(args);
+ }
+ else if (memcmp(E.xDestroy_signature, xDestroy_signatures[xDestroy_pcache1Destroy_enum], sizeof(E.xDestroy_signature)) == 0) {
+ pcache1Destroy(args);
+ }
+ else if (memcmp(E.xDestroy_signature, xDestroy_signatures[xDestroy_pcachetraceDestroy_enum], sizeof(E.xDestroy_signature)) == 0) {
+ pcachetraceDestroy(args);
+ }
+ else if (memcmp(E.xDestroy_signature, xDestroy_signatures[xDestroy_porterDestroy_enum], sizeof(E.xDestroy_signature)) == 0) {
+ porterDestroy(args);
+ }
+ else if (memcmp(E.xDestroy_signature, xDestroy_signatures[xDestroy_rtreeDestroy_enum], sizeof(E.xDestroy_signature)) == 0) {
+ rtreeDestroy(args);
+ }
+ else if (memcmp(E.xDestroy_signature, xDestroy_signatures[xDestroy_simpleDestroy_enum], sizeof(E.xDestroy_signature)) == 0) {
+ simpleDestroy(args);
+ }
+ else if (memcmp(E.xDestroy_signature, xDestroy_signatures[xDestroy_statDisconnect_enum], sizeof(E.xDestroy_signature)) == 0) {
+ statDisconnect(args);
+ }
+ else if (memcmp(E.xDestroy_signature, xDestroy_signatures[xDestroy_unicodeDestroy_enum], sizeof(E.xDestroy_signature)) == 0) {
+ unicodeDestroy(args);
+ }
+ else if (memcmp(E.xDestroy_signature, xDestroy_signatures[xDestroy_zipfileDisconnect_enum], sizeof(E.xDestroy_signature)) == 0) {
+ zipfileDisconnect(args);
+ }


// Transform E.xDeviceCharacteristics(args) to if-chain with 5 candidates
@transform_no_return_xDeviceCharacteristics@
expression E;
identifier FP_NAME = xDeviceCharacteristics;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xDeviceCharacteristics_signature, xDeviceCharacteristics_signatures[xDeviceCharacteristics_0_enum], sizeof(E.xDeviceCharacteristics_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xDeviceCharacteristics_signature, xDeviceCharacteristics_signatures[xDeviceCharacteristics_apndDeviceCharacteristics_enum], sizeof(E.xDeviceCharacteristics_signature)) == 0) {
+ apndDeviceCharacteristics(args);
+ }
+ else if (memcmp(E.xDeviceCharacteristics_signature, xDeviceCharacteristics_signatures[xDeviceCharacteristics_memdbDeviceCharacteristics_enum], sizeof(E.xDeviceCharacteristics_signature)) == 0) {
+ memdbDeviceCharacteristics(args);
+ }
+ else if (memcmp(E.xDeviceCharacteristics_signature, xDeviceCharacteristics_signatures[xDeviceCharacteristics_recoverVfsDeviceCharacteristics_enum], sizeof(E.xDeviceCharacteristics_signature)) == 0) {
+ recoverVfsDeviceCharacteristics(args);
+ }
+ else if (memcmp(E.xDeviceCharacteristics_signature, xDeviceCharacteristics_signatures[xDeviceCharacteristics_vfstraceDeviceCharacteristics_enum], sizeof(E.xDeviceCharacteristics_signature)) == 0) {
+ vfstraceDeviceCharacteristics(args);
+ }
+ else if (memcmp(E.xDeviceCharacteristics_signature, xDeviceCharacteristics_signatures[xDeviceCharacteristics_unixDeviceCharacteristics_enum], sizeof(E.xDeviceCharacteristics_signature)) == 0) {
+ unixDeviceCharacteristics(args);
+ }


// Transform E.xDisconnect(args) to if-chain with 16 candidates
@transform_no_return_xDisconnect@
expression E;
identifier FP_NAME = xDisconnect;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xDisconnect_signature, xDisconnect_signatures[xDisconnect_bytecodevtabDisconnect_enum], sizeof(E.xDisconnect_signature)) == 0) {
+ bytecodevtabDisconnect(args);
+ }
+ else if (memcmp(E.xDisconnect_signature, xDisconnect_signatures[xDisconnect_completionDisconnect_enum], sizeof(E.xDisconnect_signature)) == 0) {
+ completionDisconnect(args);
+ }
+ else if (memcmp(E.xDisconnect_signature, xDisconnect_signatures[xDisconnect_dbdataDisconnect_enum], sizeof(E.xDisconnect_signature)) == 0) {
+ dbdataDisconnect(args);
+ }
+ else if (memcmp(E.xDisconnect_signature, xDisconnect_signatures[xDisconnect_dbpageDisconnect_enum], sizeof(E.xDisconnect_signature)) == 0) {
+ dbpageDisconnect(args);
+ }
+ else if (memcmp(E.xDisconnect_signature, xDisconnect_signatures[xDisconnect_expertDisconnect_enum], sizeof(E.xDisconnect_signature)) == 0) {
+ expertDisconnect(args);
+ }
+ else if (memcmp(E.xDisconnect_signature, xDisconnect_signatures[xDisconnect_fsdirDisconnect_enum], sizeof(E.xDisconnect_signature)) == 0) {
+ fsdirDisconnect(args);
+ }
+ else if (memcmp(E.xDisconnect_signature, xDisconnect_signatures[xDisconnect_fts3DisconnectMethod_enum], sizeof(E.xDisconnect_signature)) == 0) {
+ fts3DisconnectMethod(args);
+ }
+ else if (memcmp(E.xDisconnect_signature, xDisconnect_signatures[xDisconnect_fts3auxDisconnectMethod_enum], sizeof(E.xDisconnect_signature)) == 0) {
+ fts3auxDisconnectMethod(args);
+ }
+ else if (memcmp(E.xDisconnect_signature, xDisconnect_signatures[xDisconnect_fts3tokDisconnectMethod_enum], sizeof(E.xDisconnect_signature)) == 0) {
+ fts3tokDisconnectMethod(args);
+ }
+ else if (memcmp(E.xDisconnect_signature, xDisconnect_signatures[xDisconnect_jsonEachDisconnect_enum], sizeof(E.xDisconnect_signature)) == 0) {
+ jsonEachDisconnect(args);
+ }
+ else if (memcmp(E.xDisconnect_signature, xDisconnect_signatures[xDisconnect_pragmaVtabDisconnect_enum], sizeof(E.xDisconnect_signature)) == 0) {
+ pragmaVtabDisconnect(args);
+ }
+ else if (memcmp(E.xDisconnect_signature, xDisconnect_signatures[xDisconnect_rtreeDisconnect_enum], sizeof(E.xDisconnect_signature)) == 0) {
+ rtreeDisconnect(args);
+ }
+ else if (memcmp(E.xDisconnect_signature, xDisconnect_signatures[xDisconnect_seriesDisconnect_enum], sizeof(E.xDisconnect_signature)) == 0) {
+ seriesDisconnect(args);
+ }
+ else if (memcmp(E.xDisconnect_signature, xDisconnect_signatures[xDisconnect_statDisconnect_enum], sizeof(E.xDisconnect_signature)) == 0) {
+ statDisconnect(args);
+ }
+ else if (memcmp(E.xDisconnect_signature, xDisconnect_signatures[xDisconnect_stmtDisconnect_enum], sizeof(E.xDisconnect_signature)) == 0) {
+ stmtDisconnect(args);
+ }
+ else if (memcmp(E.xDisconnect_signature, xDisconnect_signatures[xDisconnect_zipfileDisconnect_enum], sizeof(E.xDisconnect_signature)) == 0) {
+ zipfileDisconnect(args);
+ }


// Transform E.xDlClose(args) to if-chain with 3 candidates
@transform_no_return_xDlClose@
expression E;
identifier FP_NAME = xDlClose;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xDlClose_signature, xDlClose_signatures[xDlClose_0_enum], sizeof(E.xDlClose_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xDlClose_signature, xDlClose_signatures[xDlClose_apndDlClose_enum], sizeof(E.xDlClose_signature)) == 0) {
+ apndDlClose(args);
+ }
+ else if (memcmp(E.xDlClose_signature, xDlClose_signatures[xDlClose_memdbDlClose_enum], sizeof(E.xDlClose_signature)) == 0) {
+ memdbDlClose(args);
+ }
+ else if (memcmp(E.xDlClose_signature, xDlClose_signatures[xDlClose_unixDlClose_enum], sizeof(E.xDlClose_signature)) == 0) {
+ unixDlClose(args);
+ }


// Transform E.xDlError(args) to if-chain with 3 candidates
@transform_no_return_xDlError@
expression E;
identifier FP_NAME = xDlError;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xDlError_signature, xDlError_signatures[xDlError_0_enum], sizeof(E.xDlError_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xDlError_signature, xDlError_signatures[xDlError_apndDlError_enum], sizeof(E.xDlError_signature)) == 0) {
+ apndDlError(args);
+ }
+ else if (memcmp(E.xDlError_signature, xDlError_signatures[xDlError_memdbDlError_enum], sizeof(E.xDlError_signature)) == 0) {
+ memdbDlError(args);
+ }
+ else if (memcmp(E.xDlError_signature, xDlError_signatures[xDlError_unixDlError_enum], sizeof(E.xDlError_signature)) == 0) {
+ unixDlError(args);
+ }


// Transform E.xDlOpen(args) to if-chain with 3 candidates
@transform_no_return_xDlOpen@
expression E;
identifier FP_NAME = xDlOpen;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xDlOpen_signature, xDlOpen_signatures[xDlOpen_apndDlOpen_enum], sizeof(E.xDlOpen_signature)) == 0) {
+ apndDlOpen(args);
+ }
+ else if (memcmp(E.xDlOpen_signature, xDlOpen_signatures[xDlOpen_memdbDlOpen_enum], sizeof(E.xDlOpen_signature)) == 0) {
+ memdbDlOpen(args);
+ }
+ else if (memcmp(E.xDlOpen_signature, xDlOpen_signatures[xDlOpen_unixDlOpen_enum], sizeof(E.xDlOpen_signature)) == 0) {
+ unixDlOpen(args);
+ }


// Transform E.xEof(args) to if-chain with 43 candidates
@transform_no_return_xEof@
expression E;
identifier FP_NAME = xEof;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xEof_signature, xEof_signatures[xEof_amatchEof_enum], sizeof(E.xEof_signature)) == 0) {
+ amatchEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_binfoEof_enum], sizeof(E.xEof_signature)) == 0) {
+ binfoEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_bytecodevtabEof_enum], sizeof(E.xEof_signature)) == 0) {
+ bytecodevtabEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_carrayEof_enum], sizeof(E.xEof_signature)) == 0) {
+ carrayEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_cidxEof_enum], sizeof(E.xEof_signature)) == 0) {
+ cidxEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_closureEof_enum], sizeof(E.xEof_signature)) == 0) {
+ closureEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_completionEof_enum], sizeof(E.xEof_signature)) == 0) {
+ completionEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_csvtabEof_enum], sizeof(E.xEof_signature)) == 0) {
+ csvtabEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_dbdataEof_enum], sizeof(E.xEof_signature)) == 0) {
+ dbdataEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_dbpageEof_enum], sizeof(E.xEof_signature)) == 0) {
+ dbpageEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_deltaparsevtabEof_enum], sizeof(E.xEof_signature)) == 0) {
+ deltaparsevtabEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_echoEof_enum], sizeof(E.xEof_signature)) == 0) {
+ echoEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_expertEof_enum], sizeof(E.xEof_signature)) == 0) {
+ expertEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_explainEof_enum], sizeof(E.xEof_signature)) == 0) {
+ explainEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_fsEof_enum], sizeof(E.xEof_signature)) == 0) {
+ fsEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_fsdirEof_enum], sizeof(E.xEof_signature)) == 0) {
+ fsdirEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_fstreeEof_enum], sizeof(E.xEof_signature)) == 0) {
+ fstreeEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_fts3EofMethod_enum], sizeof(E.xEof_signature)) == 0) {
+ fts3EofMethod(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_fts3auxEofMethod_enum], sizeof(E.xEof_signature)) == 0) {
+ fts3auxEofMethod(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_fts3termEofMethod_enum], sizeof(E.xEof_signature)) == 0) {
+ fts3termEofMethod(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_fts3tokEofMethod_enum], sizeof(E.xEof_signature)) == 0) {
+ fts3tokEofMethod(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_fuzzerEof_enum], sizeof(E.xEof_signature)) == 0) {
+ fuzzerEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_intarrayEof_enum], sizeof(E.xEof_signature)) == 0) {
+ intarrayEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_jsonEachEof_enum], sizeof(E.xEof_signature)) == 0) {
+ jsonEachEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_memstatEof_enum], sizeof(E.xEof_signature)) == 0) {
+ memstatEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_pragmaVtabEof_enum], sizeof(E.xEof_signature)) == 0) {
+ pragmaVtabEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_prefixesEof_enum], sizeof(E.xEof_signature)) == 0) {
+ prefixesEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_qpvtabEof_enum], sizeof(E.xEof_signature)) == 0) {
+ qpvtabEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_rtreeEof_enum], sizeof(E.xEof_signature)) == 0) {
+ rtreeEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_schemaEof_enum], sizeof(E.xEof_signature)) == 0) {
+ schemaEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_seriesEof_enum], sizeof(E.xEof_signature)) == 0) {
+ seriesEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_spellfix1Eof_enum], sizeof(E.xEof_signature)) == 0) {
+ spellfix1Eof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_statEof_enum], sizeof(E.xEof_signature)) == 0) {
+ statEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_stmtEof_enum], sizeof(E.xEof_signature)) == 0) {
+ stmtEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_tclEof_enum], sizeof(E.xEof_signature)) == 0) {
+ tclEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_tclvarEof_enum], sizeof(E.xEof_signature)) == 0) {
+ tclvarEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_templatevtabEof_enum], sizeof(E.xEof_signature)) == 0) {
+ templatevtabEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_unionEof_enum], sizeof(E.xEof_signature)) == 0) {
+ unionEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_vlogEof_enum], sizeof(E.xEof_signature)) == 0) {
+ vlogEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_vstattabEof_enum], sizeof(E.xEof_signature)) == 0) {
+ vstattabEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_vtablogEof_enum], sizeof(E.xEof_signature)) == 0) {
+ vtablogEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_wholenumberEof_enum], sizeof(E.xEof_signature)) == 0) {
+ wholenumberEof(args);
+ }
+ else if (memcmp(E.xEof_signature, xEof_signatures[xEof_zipfileEof_enum], sizeof(E.xEof_signature)) == 0) {
+ zipfileEof(args);
+ }


// Transform E.xExprCallback(args) to if-chain with 37 candidates
@transform_no_return_xExprCallback@
expression E;
identifier FP_NAME = xExprCallback;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_agginfoPersistExprCb_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ agginfoPersistExprCb(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_aggregateIdxEprRefToColCallback_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ aggregateIdxEprRefToColCallback(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_analyzeAggregate_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ analyzeAggregate(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_checkConstraintExprNode_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ checkConstraintExprNode(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_codeCursorHintCheckExpr_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ codeCursorHintCheckExpr(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_codeCursorHintFixExpr_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ codeCursorHintFixExpr(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_codeCursorHintIsOrFunction_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ codeCursorHintIsOrFunction(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_disallowAggregatesInOrderByCb_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ disallowAggregatesInOrderByCb(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprColumnFlagUnion_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ exprColumnFlagUnion(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprIdxCover_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ exprIdxCover(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprNodeCanReturnSubtype_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ exprNodeCanReturnSubtype(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprNodeIsConstant_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ exprNodeIsConstant(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprNodeIsConstantOrGroupBy_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ exprNodeIsConstantOrGroupBy(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprNodeIsDeterministic_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ exprNodeIsDeterministic(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprRefToSrcList_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ exprRefToSrcList(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_fixExprCb_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ fixExprCb(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_gatherSelectWindowsCallback_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ gatherSelectWindowsCallback(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_havingToWhereExprCb_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ havingToWhereExprCb(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_impliesNotNullRow_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ impliesNotNullRow(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_incrAggDepth_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ incrAggDepth(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_markImmutableExprStep_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ markImmutableExprStep(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_propagateConstantExprRewrite_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ propagateConstantExprRewrite(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_recomputeColumnsUsedExpr_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ recomputeColumnsUsedExpr(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_renameColumnExprCb_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ renameColumnExprCb(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_renameQuotefixExprCb_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ renameQuotefixExprCb(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_renameTableExprCb_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ renameTableExprCb(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_renameUnmapExprCb_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ renameUnmapExprCb(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_renumberCursorsCb_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ renumberCursorsCb(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_resolveExprStep_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ resolveExprStep(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_resolveRemoveWindowsCb_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ resolveRemoveWindowsCb(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_selectCheckOnClausesExpr_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ selectCheckOnClausesExpr(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_selectWindowRewriteExprCb_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ selectWindowRewriteExprCb(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_sqlite3CursorRangeHintExprCheck_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ sqlite3CursorRangeHintExprCheck(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_sqlite3ExprWalkNoop_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ sqlite3ExprWalkNoop(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_sqlite3ReturningSubqueryVarSelect_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ sqlite3ReturningSubqueryVarSelect(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_sqlite3WindowExtraAggFuncDepth_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ sqlite3WindowExtraAggFuncDepth(args);
+ }
+ else if (memcmp(E.xExprCallback_signature, xExprCallback_signatures[xExprCallback_whereIsCoveringIndexWalkCallback_enum], sizeof(E.xExprCallback_signature)) == 0) {
+ whereIsCoveringIndexWalkCallback(args);
+ }


// Transform E.xFetch(args) to if-chain with 6 candidates
@transform_no_return_xFetch@
expression E;
identifier FP_NAME = xFetch;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xFetch_signature, xFetch_signatures[xFetch_0_enum], sizeof(E.xFetch_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xFetch_signature, xFetch_signatures[xFetch_apndFetch_enum], sizeof(E.xFetch_signature)) == 0) {
+ apndFetch(args);
+ }
+ else if (memcmp(E.xFetch_signature, xFetch_signatures[xFetch_memdbFetch_enum], sizeof(E.xFetch_signature)) == 0) {
+ memdbFetch(args);
+ }
+ else if (memcmp(E.xFetch_signature, xFetch_signatures[xFetch_pcache1Fetch_enum], sizeof(E.xFetch_signature)) == 0) {
+ pcache1Fetch(args);
+ }
+ else if (memcmp(E.xFetch_signature, xFetch_signatures[xFetch_pcachetraceFetch_enum], sizeof(E.xFetch_signature)) == 0) {
+ pcachetraceFetch(args);
+ }
+ else if (memcmp(E.xFetch_signature, xFetch_signatures[xFetch_recoverVfsFetch_enum], sizeof(E.xFetch_signature)) == 0) {
+ recoverVfsFetch(args);
+ }
+ else if (memcmp(E.xFetch_signature, xFetch_signatures[xFetch_unixFetch_enum], sizeof(E.xFetch_signature)) == 0) {
+ unixFetch(args);
+ }


// Transform E.xFileControl(args) to if-chain with 5 candidates
@transform_no_return_xFileControl@
expression E;
identifier FP_NAME = xFileControl;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xFileControl_signature, xFileControl_signatures[xFileControl_0_enum], sizeof(E.xFileControl_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xFileControl_signature, xFileControl_signatures[xFileControl_apndFileControl_enum], sizeof(E.xFileControl_signature)) == 0) {
+ apndFileControl(args);
+ }
+ else if (memcmp(E.xFileControl_signature, xFileControl_signatures[xFileControl_memdbFileControl_enum], sizeof(E.xFileControl_signature)) == 0) {
+ memdbFileControl(args);
+ }
+ else if (memcmp(E.xFileControl_signature, xFileControl_signatures[xFileControl_recoverVfsFileControl_enum], sizeof(E.xFileControl_signature)) == 0) {
+ recoverVfsFileControl(args);
+ }
+ else if (memcmp(E.xFileControl_signature, xFileControl_signatures[xFileControl_vfstraceFileControl_enum], sizeof(E.xFileControl_signature)) == 0) {
+ vfstraceFileControl(args);
+ }
+ else if (memcmp(E.xFileControl_signature, xFileControl_signatures[xFileControl_unixFileControl_enum], sizeof(E.xFileControl_signature)) == 0) {
+ unixFileControl(args);
+ }


// Transform E.xFileSize(args) to if-chain with 6 candidates
@transform_no_return_xFileSize@
expression E;
identifier FP_NAME = xFileSize;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xFileSize_signature, xFileSize_signatures[xFileSize_apndFileSize_enum], sizeof(E.xFileSize_signature)) == 0) {
+ apndFileSize(args);
+ }
+ else if (memcmp(E.xFileSize_signature, xFileSize_signatures[xFileSize_memdbFileSize_enum], sizeof(E.xFileSize_signature)) == 0) {
+ memdbFileSize(args);
+ }
+ else if (memcmp(E.xFileSize_signature, xFileSize_signatures[xFileSize_memjrnlFileSize_enum], sizeof(E.xFileSize_signature)) == 0) {
+ memjrnlFileSize(args);
+ }
+ else if (memcmp(E.xFileSize_signature, xFileSize_signatures[xFileSize_recoverVfsFileSize_enum], sizeof(E.xFileSize_signature)) == 0) {
+ recoverVfsFileSize(args);
+ }
+ else if (memcmp(E.xFileSize_signature, xFileSize_signatures[xFileSize_vfstraceFileSize_enum], sizeof(E.xFileSize_signature)) == 0) {
+ vfstraceFileSize(args);
+ }
+ else if (memcmp(E.xFileSize_signature, xFileSize_signatures[xFileSize_unixFileSize_enum], sizeof(E.xFileSize_signature)) == 0) {
+ unixFileSize(args);
+ }


// Transform E.xFilter(args) to if-chain with 44 candidates
@transform_no_return_xFilter@
expression E;
identifier FP_NAME = xFilter;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_amatchFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ amatchFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_binfoFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ binfoFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_bytecodevtabFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ bytecodevtabFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_carrayFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ carrayFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_cidxFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ cidxFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_closureFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ closureFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_completionFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ completionFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_csvtabFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ csvtabFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_dbdataFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ dbdataFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_dbpageFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ dbpageFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_deltaparsevtabFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ deltaparsevtabFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_echoFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ echoFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_expertFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ expertFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_explainFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ explainFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_fsFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ fsFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_fsdirFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ fsdirFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_fstreeFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ fstreeFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_fts3FilterMethod_enum], sizeof(E.xFilter_signature)) == 0) {
+ fts3FilterMethod(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_fts3auxFilterMethod_enum], sizeof(E.xFilter_signature)) == 0) {
+ fts3auxFilterMethod(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_fts3termFilterMethod_enum], sizeof(E.xFilter_signature)) == 0) {
+ fts3termFilterMethod(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_fts3tokFilterMethod_enum], sizeof(E.xFilter_signature)) == 0) {
+ fts3tokFilterMethod(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_fuzzerFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ fuzzerFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_geopolyFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ geopolyFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_intarrayFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ intarrayFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_jsonEachFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ jsonEachFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_memstatFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ memstatFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_pragmaVtabFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ pragmaVtabFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_prefixesFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ prefixesFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_qpvtabFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ qpvtabFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_rtreeFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ rtreeFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_schemaFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ schemaFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_seriesFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ seriesFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_spellfix1Filter_enum], sizeof(E.xFilter_signature)) == 0) {
+ spellfix1Filter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_statFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ statFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_stmtFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ stmtFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_tclFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ tclFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_tclvarFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ tclvarFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_templatevtabFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ templatevtabFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_unionFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ unionFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_vlogFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ vlogFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_vstattabFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ vstattabFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_vtablogFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ vtablogFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_wholenumberFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ wholenumberFilter(args);
+ }
+ else if (memcmp(E.xFilter_signature, xFilter_signatures[xFilter_zipfileFilter_enum], sizeof(E.xFilter_signature)) == 0) {
+ zipfileFilter(args);
+ }


// Transform E.xFindFunction(args) to if-chain with 2 candidates
@transform_no_return_xFindFunction@
expression E;
identifier FP_NAME = xFindFunction;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xFindFunction_signature, xFindFunction_signatures[xFindFunction_0_enum], sizeof(E.xFindFunction_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xFindFunction_signature, xFindFunction_signatures[xFindFunction_fts3FindFunctionMethod_enum], sizeof(E.xFindFunction_signature)) == 0) {
+ fts3FindFunctionMethod(args);
+ }
+ else if (memcmp(E.xFindFunction_signature, xFindFunction_signatures[xFindFunction_zipfileFindFunction_enum], sizeof(E.xFindFunction_signature)) == 0) {
+ zipfileFindFunction(args);
+ }


// Transform E.xFree(args) to if-chain with 2 candidates
@transform_no_return_xFree@
expression E;
identifier FP_NAME = xFree;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xFree_signature, xFree_signatures[xFree_memtraceFree_enum], sizeof(E.xFree_signature)) == 0) {
+ memtraceFree(args);
+ }
+ else if (memcmp(E.xFree_signature, xFree_signatures[xFree_sqlite3MemFree_enum], sizeof(E.xFree_signature)) == 0) {
+ sqlite3MemFree(args);
+ }


// Transform E.xFullPathname(args) to if-chain with 4 candidates
@transform_no_return_xFullPathname@
expression E;
identifier FP_NAME = xFullPathname;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xFullPathname_signature, xFullPathname_signatures[xFullPathname_apndFullPathname_enum], sizeof(E.xFullPathname_signature)) == 0) {
+ apndFullPathname(args);
+ }
+ else if (memcmp(E.xFullPathname_signature, xFullPathname_signatures[xFullPathname_memdbFullPathname_enum], sizeof(E.xFullPathname_signature)) == 0) {
+ memdbFullPathname(args);
+ }
+ else if (memcmp(E.xFullPathname_signature, xFullPathname_signatures[xFullPathname_vfstraceFullPathname_enum], sizeof(E.xFullPathname_signature)) == 0) {
+ vfstraceFullPathname(args);
+ }
+ else if (memcmp(E.xFullPathname_signature, xFullPathname_signatures[xFullPathname_unixFullPathname_enum], sizeof(E.xFullPathname_signature)) == 0) {
+ unixFullPathname(args);
+ }


// Transform E.xGet(args) to if-chain with 3 candidates
@transform_no_return_xGet@
expression E;
identifier FP_NAME = xGet;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xGet_signature, xGet_signatures[xGet_getPageError_enum], sizeof(E.xGet_signature)) == 0) {
+ getPageError(args);
+ }
+ else if (memcmp(E.xGet_signature, xGet_signatures[xGet_getPageMMap_enum], sizeof(E.xGet_signature)) == 0) {
+ getPageMMap(args);
+ }
+ else if (memcmp(E.xGet_signature, xGet_signatures[xGet_getPageNormal_enum], sizeof(E.xGet_signature)) == 0) {
+ getPageNormal(args);
+ }


// Transform E.xGetLastError(args) to if-chain with 3 candidates
@transform_no_return_xGetLastError@
expression E;
identifier FP_NAME = xGetLastError;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xGetLastError_signature, xGetLastError_signatures[xGetLastError_0_enum], sizeof(E.xGetLastError_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xGetLastError_signature, xGetLastError_signatures[xGetLastError_apndGetLastError_enum], sizeof(E.xGetLastError_signature)) == 0) {
+ apndGetLastError(args);
+ }
+ else if (memcmp(E.xGetLastError_signature, xGetLastError_signatures[xGetLastError_memdbGetLastError_enum], sizeof(E.xGetLastError_signature)) == 0) {
+ memdbGetLastError(args);
+ }
+ else if (memcmp(E.xGetLastError_signature, xGetLastError_signatures[xGetLastError_unixGetLastError_enum], sizeof(E.xGetLastError_signature)) == 0) {
+ unixGetLastError(args);
+ }


// Transform E.xGetSystemCall(args) to if-chain with 2 candidates
@transform_no_return_xGetSystemCall@
expression E;
identifier FP_NAME = xGetSystemCall;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xGetSystemCall_signature, xGetSystemCall_signatures[xGetSystemCall_0_enum], sizeof(E.xGetSystemCall_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xGetSystemCall_signature, xGetSystemCall_signatures[xGetSystemCall_apndGetSystemCall_enum], sizeof(E.xGetSystemCall_signature)) == 0) {
+ apndGetSystemCall(args);
+ }
+ else if (memcmp(E.xGetSystemCall_signature, xGetSystemCall_signatures[xGetSystemCall_unixGetSystemCall_enum], sizeof(E.xGetSystemCall_signature)) == 0) {
+ unixGetSystemCall(args);
+ }


// Transform E.xInit(args) to if-chain with 4 candidates
@transform_no_return_xInit@
expression E;
identifier FP_NAME = xInit;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xInit_signature, xInit_signatures[xInit_memtraceInit_enum], sizeof(E.xInit_signature)) == 0) {
+ memtraceInit(args);
+ }
+ else if (memcmp(E.xInit_signature, xInit_signatures[xInit_pcache1Init_enum], sizeof(E.xInit_signature)) == 0) {
+ pcache1Init(args);
+ }
+ else if (memcmp(E.xInit_signature, xInit_signatures[xInit_pcachetraceInit_enum], sizeof(E.xInit_signature)) == 0) {
+ pcachetraceInit(args);
+ }
+ else if (memcmp(E.xInit_signature, xInit_signatures[xInit_sqlite3MemInit_enum], sizeof(E.xInit_signature)) == 0) {
+ sqlite3MemInit(args);
+ }


// Transform E.xIntegrity(args) to if-chain with 3 candidates
@transform_no_return_xIntegrity@
expression E;
identifier FP_NAME = xIntegrity;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xIntegrity_signature, xIntegrity_signatures[xIntegrity_0_enum], sizeof(E.xIntegrity_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xIntegrity_signature, xIntegrity_signatures[xIntegrity_fts3IntegrityMethod_enum], sizeof(E.xIntegrity_signature)) == 0) {
+ fts3IntegrityMethod(args);
+ }
+ else if (memcmp(E.xIntegrity_signature, xIntegrity_signatures[xIntegrity_rtreeIntegrity_enum], sizeof(E.xIntegrity_signature)) == 0) {
+ rtreeIntegrity(args);
+ }
+ else if (memcmp(E.xIntegrity_signature, xIntegrity_signatures[xIntegrity_vtablogIntegrity_enum], sizeof(E.xIntegrity_signature)) == 0) {
+ vtablogIntegrity(args);
+ }


// Transform E.xLock(args) to if-chain with 7 candidates
@transform_no_return_xLock@
expression E;
identifier FP_NAME = xLock;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xLock_signature, xLock_signatures[xLock_0_enum], sizeof(E.xLock_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xLock_signature, xLock_signatures[xLock_apndLock_enum], sizeof(E.xLock_signature)) == 0) {
+ apndLock(args);
+ }
+ else if (memcmp(E.xLock_signature, xLock_signatures[xLock_memdbLock_enum], sizeof(E.xLock_signature)) == 0) {
+ memdbLock(args);
+ }
+ else if (memcmp(E.xLock_signature, xLock_signatures[xLock_recoverVfsLock_enum], sizeof(E.xLock_signature)) == 0) {
+ recoverVfsLock(args);
+ }
+ else if (memcmp(E.xLock_signature, xLock_signatures[xLock_vfstraceLock_enum], sizeof(E.xLock_signature)) == 0) {
+ vfstraceLock(args);
+ }
+ else if (memcmp(E.xLock_signature, xLock_signatures[xLock_unixLock_enum], sizeof(E.xLock_signature)) == 0) {
+ unixLock(args);
+ }
+ else if (memcmp(E.xLock_signature, xLock_signatures[xLock_nolockLock_enum], sizeof(E.xLock_signature)) == 0) {
+ nolockLock(args);
+ }
+ else if (memcmp(E.xLock_signature, xLock_signatures[xLock_dotlockLock_enum], sizeof(E.xLock_signature)) == 0) {
+ dotlockLock(args);
+ }


// Transform E.xMalloc(args) to if-chain with 2 candidates
@transform_no_return_xMalloc@
expression E;
identifier FP_NAME = xMalloc;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xMalloc_signature, xMalloc_signatures[xMalloc_memtraceMalloc_enum], sizeof(E.xMalloc_signature)) == 0) {
+ memtraceMalloc(args);
+ }
+ else if (memcmp(E.xMalloc_signature, xMalloc_signatures[xMalloc_sqlite3MemMalloc_enum], sizeof(E.xMalloc_signature)) == 0) {
+ sqlite3MemMalloc(args);
+ }


// Transform E.xMutexAlloc(args) to if-chain with 7 candidates
@transform_no_return_xMutexAlloc@
expression E;
identifier FP_NAME = xMutexAlloc;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_checkMutexAlloc_enum], sizeof(E.xMutexAlloc_signature)) == 0) {
+ checkMutexAlloc(args);
+ }
+ else if (memcmp(E.xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_counterMutexAlloc_enum], sizeof(E.xMutexAlloc_signature)) == 0) {
+ counterMutexAlloc(args);
+ }
+ else if (memcmp(E.xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_debugMutexAlloc_enum], sizeof(E.xMutexAlloc_signature)) == 0) {
+ debugMutexAlloc(args);
+ }
+ else if (memcmp(E.xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_noopMutexAlloc_enum], sizeof(E.xMutexAlloc_signature)) == 0) {
+ noopMutexAlloc(args);
+ }
+ else if (memcmp(E.xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_pthreadMutexAlloc_enum], sizeof(E.xMutexAlloc_signature)) == 0) {
+ pthreadMutexAlloc(args);
+ }
+ else if (memcmp(E.xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_winMutexAlloc_enum], sizeof(E.xMutexAlloc_signature)) == 0) {
+ winMutexAlloc(args);
+ }
+ else if (memcmp(E.xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_wrMutexAlloc_enum], sizeof(E.xMutexAlloc_signature)) == 0) {
+ wrMutexAlloc(args);
+ }


// Transform E.xMutexEnd(args) to if-chain with 7 candidates
@transform_no_return_xMutexEnd@
expression E;
identifier FP_NAME = xMutexEnd;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_checkMutexEnd_enum], sizeof(E.xMutexEnd_signature)) == 0) {
+ checkMutexEnd(args);
+ }
+ else if (memcmp(E.xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_counterMutexEnd_enum], sizeof(E.xMutexEnd_signature)) == 0) {
+ counterMutexEnd(args);
+ }
+ else if (memcmp(E.xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_debugMutexEnd_enum], sizeof(E.xMutexEnd_signature)) == 0) {
+ debugMutexEnd(args);
+ }
+ else if (memcmp(E.xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_noopMutexEnd_enum], sizeof(E.xMutexEnd_signature)) == 0) {
+ noopMutexEnd(args);
+ }
+ else if (memcmp(E.xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_pthreadMutexEnd_enum], sizeof(E.xMutexEnd_signature)) == 0) {
+ pthreadMutexEnd(args);
+ }
+ else if (memcmp(E.xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_winMutexEnd_enum], sizeof(E.xMutexEnd_signature)) == 0) {
+ winMutexEnd(args);
+ }
+ else if (memcmp(E.xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_wrMutexEnd_enum], sizeof(E.xMutexEnd_signature)) == 0) {
+ wrMutexEnd(args);
+ }


// Transform E.xMutexEnter(args) to if-chain with 7 candidates
@transform_no_return_xMutexEnter@
expression E;
identifier FP_NAME = xMutexEnter;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_checkMutexEnter_enum], sizeof(E.xMutexEnter_signature)) == 0) {
+ checkMutexEnter(args);
+ }
+ else if (memcmp(E.xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_counterMutexEnter_enum], sizeof(E.xMutexEnter_signature)) == 0) {
+ counterMutexEnter(args);
+ }
+ else if (memcmp(E.xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_debugMutexEnter_enum], sizeof(E.xMutexEnter_signature)) == 0) {
+ debugMutexEnter(args);
+ }
+ else if (memcmp(E.xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_noopMutexEnter_enum], sizeof(E.xMutexEnter_signature)) == 0) {
+ noopMutexEnter(args);
+ }
+ else if (memcmp(E.xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_pthreadMutexEnter_enum], sizeof(E.xMutexEnter_signature)) == 0) {
+ pthreadMutexEnter(args);
+ }
+ else if (memcmp(E.xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_winMutexEnter_enum], sizeof(E.xMutexEnter_signature)) == 0) {
+ winMutexEnter(args);
+ }
+ else if (memcmp(E.xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_wrMutexEnter_enum], sizeof(E.xMutexEnter_signature)) == 0) {
+ wrMutexEnter(args);
+ }


// Transform E.xMutexFree(args) to if-chain with 7 candidates
@transform_no_return_xMutexFree@
expression E;
identifier FP_NAME = xMutexFree;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xMutexFree_signature, xMutexFree_signatures[xMutexFree_checkMutexFree_enum], sizeof(E.xMutexFree_signature)) == 0) {
+ checkMutexFree(args);
+ }
+ else if (memcmp(E.xMutexFree_signature, xMutexFree_signatures[xMutexFree_counterMutexFree_enum], sizeof(E.xMutexFree_signature)) == 0) {
+ counterMutexFree(args);
+ }
+ else if (memcmp(E.xMutexFree_signature, xMutexFree_signatures[xMutexFree_debugMutexFree_enum], sizeof(E.xMutexFree_signature)) == 0) {
+ debugMutexFree(args);
+ }
+ else if (memcmp(E.xMutexFree_signature, xMutexFree_signatures[xMutexFree_noopMutexFree_enum], sizeof(E.xMutexFree_signature)) == 0) {
+ noopMutexFree(args);
+ }
+ else if (memcmp(E.xMutexFree_signature, xMutexFree_signatures[xMutexFree_pthreadMutexFree_enum], sizeof(E.xMutexFree_signature)) == 0) {
+ pthreadMutexFree(args);
+ }
+ else if (memcmp(E.xMutexFree_signature, xMutexFree_signatures[xMutexFree_winMutexFree_enum], sizeof(E.xMutexFree_signature)) == 0) {
+ winMutexFree(args);
+ }
+ else if (memcmp(E.xMutexFree_signature, xMutexFree_signatures[xMutexFree_wrMutexFree_enum], sizeof(E.xMutexFree_signature)) == 0) {
+ wrMutexFree(args);
+ }


// Transform E.xMutexHeld(args) to if-chain with 3 candidates
@transform_no_return_xMutexHeld@
expression E;
identifier FP_NAME = xMutexHeld;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xMutexHeld_signature, xMutexHeld_signatures[xMutexHeld_0_enum], sizeof(E.xMutexHeld_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xMutexHeld_signature, xMutexHeld_signatures[xMutexHeld_counterMutexHeld_enum], sizeof(E.xMutexHeld_signature)) == 0) {
+ counterMutexHeld(args);
+ }
+ else if (memcmp(E.xMutexHeld_signature, xMutexHeld_signatures[xMutexHeld_debugMutexHeld_enum], sizeof(E.xMutexHeld_signature)) == 0) {
+ debugMutexHeld(args);
+ }
+ else if (memcmp(E.xMutexHeld_signature, xMutexHeld_signatures[xMutexHeld_wrMutexHeld_enum], sizeof(E.xMutexHeld_signature)) == 0) {
+ wrMutexHeld(args);
+ }


// Transform E.xMutexInit(args) to if-chain with 7 candidates
@transform_no_return_xMutexInit@
expression E;
identifier FP_NAME = xMutexInit;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xMutexInit_signature, xMutexInit_signatures[xMutexInit_checkMutexInit_enum], sizeof(E.xMutexInit_signature)) == 0) {
+ checkMutexInit(args);
+ }
+ else if (memcmp(E.xMutexInit_signature, xMutexInit_signatures[xMutexInit_counterMutexInit_enum], sizeof(E.xMutexInit_signature)) == 0) {
+ counterMutexInit(args);
+ }
+ else if (memcmp(E.xMutexInit_signature, xMutexInit_signatures[xMutexInit_debugMutexInit_enum], sizeof(E.xMutexInit_signature)) == 0) {
+ debugMutexInit(args);
+ }
+ else if (memcmp(E.xMutexInit_signature, xMutexInit_signatures[xMutexInit_noopMutexInit_enum], sizeof(E.xMutexInit_signature)) == 0) {
+ noopMutexInit(args);
+ }
+ else if (memcmp(E.xMutexInit_signature, xMutexInit_signatures[xMutexInit_pthreadMutexInit_enum], sizeof(E.xMutexInit_signature)) == 0) {
+ pthreadMutexInit(args);
+ }
+ else if (memcmp(E.xMutexInit_signature, xMutexInit_signatures[xMutexInit_winMutexInit_enum], sizeof(E.xMutexInit_signature)) == 0) {
+ winMutexInit(args);
+ }
+ else if (memcmp(E.xMutexInit_signature, xMutexInit_signatures[xMutexInit_wrMutexInit_enum], sizeof(E.xMutexInit_signature)) == 0) {
+ wrMutexInit(args);
+ }


// Transform E.xMutexLeave(args) to if-chain with 7 candidates
@transform_no_return_xMutexLeave@
expression E;
identifier FP_NAME = xMutexLeave;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_checkMutexLeave_enum], sizeof(E.xMutexLeave_signature)) == 0) {
+ checkMutexLeave(args);
+ }
+ else if (memcmp(E.xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_counterMutexLeave_enum], sizeof(E.xMutexLeave_signature)) == 0) {
+ counterMutexLeave(args);
+ }
+ else if (memcmp(E.xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_debugMutexLeave_enum], sizeof(E.xMutexLeave_signature)) == 0) {
+ debugMutexLeave(args);
+ }
+ else if (memcmp(E.xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_noopMutexLeave_enum], sizeof(E.xMutexLeave_signature)) == 0) {
+ noopMutexLeave(args);
+ }
+ else if (memcmp(E.xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_pthreadMutexLeave_enum], sizeof(E.xMutexLeave_signature)) == 0) {
+ pthreadMutexLeave(args);
+ }
+ else if (memcmp(E.xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_winMutexLeave_enum], sizeof(E.xMutexLeave_signature)) == 0) {
+ winMutexLeave(args);
+ }
+ else if (memcmp(E.xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_wrMutexLeave_enum], sizeof(E.xMutexLeave_signature)) == 0) {
+ wrMutexLeave(args);
+ }


// Transform E.xMutexNotheld(args) to if-chain with 3 candidates
@transform_no_return_xMutexNotheld@
expression E;
identifier FP_NAME = xMutexNotheld;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xMutexNotheld_signature, xMutexNotheld_signatures[xMutexNotheld_0_enum], sizeof(E.xMutexNotheld_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xMutexNotheld_signature, xMutexNotheld_signatures[xMutexNotheld_counterMutexNotheld_enum], sizeof(E.xMutexNotheld_signature)) == 0) {
+ counterMutexNotheld(args);
+ }
+ else if (memcmp(E.xMutexNotheld_signature, xMutexNotheld_signatures[xMutexNotheld_debugMutexNotheld_enum], sizeof(E.xMutexNotheld_signature)) == 0) {
+ debugMutexNotheld(args);
+ }
+ else if (memcmp(E.xMutexNotheld_signature, xMutexNotheld_signatures[xMutexNotheld_wrMutexNotheld_enum], sizeof(E.xMutexNotheld_signature)) == 0) {
+ wrMutexNotheld(args);
+ }


// Transform E.xMutexTry(args) to if-chain with 7 candidates
@transform_no_return_xMutexTry@
expression E;
identifier FP_NAME = xMutexTry;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xMutexTry_signature, xMutexTry_signatures[xMutexTry_checkMutexTry_enum], sizeof(E.xMutexTry_signature)) == 0) {
+ checkMutexTry(args);
+ }
+ else if (memcmp(E.xMutexTry_signature, xMutexTry_signatures[xMutexTry_counterMutexTry_enum], sizeof(E.xMutexTry_signature)) == 0) {
+ counterMutexTry(args);
+ }
+ else if (memcmp(E.xMutexTry_signature, xMutexTry_signatures[xMutexTry_debugMutexTry_enum], sizeof(E.xMutexTry_signature)) == 0) {
+ debugMutexTry(args);
+ }
+ else if (memcmp(E.xMutexTry_signature, xMutexTry_signatures[xMutexTry_noopMutexTry_enum], sizeof(E.xMutexTry_signature)) == 0) {
+ noopMutexTry(args);
+ }
+ else if (memcmp(E.xMutexTry_signature, xMutexTry_signatures[xMutexTry_pthreadMutexTry_enum], sizeof(E.xMutexTry_signature)) == 0) {
+ pthreadMutexTry(args);
+ }
+ else if (memcmp(E.xMutexTry_signature, xMutexTry_signatures[xMutexTry_winMutexTry_enum], sizeof(E.xMutexTry_signature)) == 0) {
+ winMutexTry(args);
+ }
+ else if (memcmp(E.xMutexTry_signature, xMutexTry_signatures[xMutexTry_wrMutexTry_enum], sizeof(E.xMutexTry_signature)) == 0) {
+ wrMutexTry(args);
+ }


// Transform E.xNew(args) to if-chain with 3 candidates
@transform_no_return_xNew@
expression E;
identifier FP_NAME = xNew;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xNew_signature, xNew_signatures[xNew_sessionDiffNew_enum], sizeof(E.xNew_signature)) == 0) {
+ sessionDiffNew(args);
+ }
+ else if (memcmp(E.xNew_signature, xNew_signatures[xNew_sessionPreupdateNew_enum], sizeof(E.xNew_signature)) == 0) {
+ sessionPreupdateNew(args);
+ }
+ else if (memcmp(E.xNew_signature, xNew_signatures[xNew_sessionStat1New_enum], sizeof(E.xNew_signature)) == 0) {
+ sessionStat1New(args);
+ }


// Transform E.xNext(args) to if-chain with 46 candidates
@transform_no_return_xNext@
expression E;
identifier FP_NAME = xNext;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xNext_signature, xNext_signatures[xNext_0_enum], sizeof(E.xNext_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_amatchNext_enum], sizeof(E.xNext_signature)) == 0) {
+ amatchNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_binfoNext_enum], sizeof(E.xNext_signature)) == 0) {
+ binfoNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_bytecodevtabNext_enum], sizeof(E.xNext_signature)) == 0) {
+ bytecodevtabNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_carrayNext_enum], sizeof(E.xNext_signature)) == 0) {
+ carrayNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_cidxNext_enum], sizeof(E.xNext_signature)) == 0) {
+ cidxNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_closureNext_enum], sizeof(E.xNext_signature)) == 0) {
+ closureNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_completionNext_enum], sizeof(E.xNext_signature)) == 0) {
+ completionNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_csvtabNext_enum], sizeof(E.xNext_signature)) == 0) {
+ csvtabNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_dbdataNext_enum], sizeof(E.xNext_signature)) == 0) {
+ dbdataNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_dbpageNext_enum], sizeof(E.xNext_signature)) == 0) {
+ dbpageNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_deltaparsevtabNext_enum], sizeof(E.xNext_signature)) == 0) {
+ deltaparsevtabNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_echoNext_enum], sizeof(E.xNext_signature)) == 0) {
+ echoNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_expertNext_enum], sizeof(E.xNext_signature)) == 0) {
+ expertNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_explainNext_enum], sizeof(E.xNext_signature)) == 0) {
+ explainNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_fsNext_enum], sizeof(E.xNext_signature)) == 0) {
+ fsNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_fsdirNext_enum], sizeof(E.xNext_signature)) == 0) {
+ fsdirNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_fstreeNext_enum], sizeof(E.xNext_signature)) == 0) {
+ fstreeNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_fts3NextMethod_enum], sizeof(E.xNext_signature)) == 0) {
+ fts3NextMethod(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_fts3auxNextMethod_enum], sizeof(E.xNext_signature)) == 0) {
+ fts3auxNextMethod(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_fts3termNextMethod_enum], sizeof(E.xNext_signature)) == 0) {
+ fts3termNextMethod(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_fts3tokNextMethod_enum], sizeof(E.xNext_signature)) == 0) {
+ fts3tokNextMethod(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_fuzzerNext_enum], sizeof(E.xNext_signature)) == 0) {
+ fuzzerNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_intarrayNext_enum], sizeof(E.xNext_signature)) == 0) {
+ intarrayNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_jsonEachNext_enum], sizeof(E.xNext_signature)) == 0) {
+ jsonEachNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_memstatNext_enum], sizeof(E.xNext_signature)) == 0) {
+ memstatNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_porterNext_enum], sizeof(E.xNext_signature)) == 0) {
+ porterNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_pragmaVtabNext_enum], sizeof(E.xNext_signature)) == 0) {
+ pragmaVtabNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_prefixesNext_enum], sizeof(E.xNext_signature)) == 0) {
+ prefixesNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_qpvtabNext_enum], sizeof(E.xNext_signature)) == 0) {
+ qpvtabNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_rtreeNext_enum], sizeof(E.xNext_signature)) == 0) {
+ rtreeNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_schemaNext_enum], sizeof(E.xNext_signature)) == 0) {
+ schemaNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_seriesNext_enum], sizeof(E.xNext_signature)) == 0) {
+ seriesNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_simpleNext_enum], sizeof(E.xNext_signature)) == 0) {
+ simpleNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_spellfix1Next_enum], sizeof(E.xNext_signature)) == 0) {
+ spellfix1Next(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_statNext_enum], sizeof(E.xNext_signature)) == 0) {
+ statNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_stmtNext_enum], sizeof(E.xNext_signature)) == 0) {
+ stmtNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_tclNext_enum], sizeof(E.xNext_signature)) == 0) {
+ tclNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_tclvarNext_enum], sizeof(E.xNext_signature)) == 0) {
+ tclvarNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_templatevtabNext_enum], sizeof(E.xNext_signature)) == 0) {
+ templatevtabNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_unicodeNext_enum], sizeof(E.xNext_signature)) == 0) {
+ unicodeNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_unionNext_enum], sizeof(E.xNext_signature)) == 0) {
+ unionNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_vlogNext_enum], sizeof(E.xNext_signature)) == 0) {
+ vlogNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_vstattabNext_enum], sizeof(E.xNext_signature)) == 0) {
+ vstattabNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_vtablogNext_enum], sizeof(E.xNext_signature)) == 0) {
+ vtablogNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_wholenumberNext_enum], sizeof(E.xNext_signature)) == 0) {
+ wholenumberNext(args);
+ }
+ else if (memcmp(E.xNext_signature, xNext_signatures[xNext_zipfileNext_enum], sizeof(E.xNext_signature)) == 0) {
+ zipfileNext(args);
+ }


// Transform E.xNextSystemCall(args) to if-chain with 3 candidates
@transform_no_return_xNextSystemCall@
expression E;
identifier FP_NAME = xNextSystemCall;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xNextSystemCall_signature, xNextSystemCall_signatures[xNextSystemCall_0_enum], sizeof(E.xNextSystemCall_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xNextSystemCall_signature, xNextSystemCall_signatures[xNextSystemCall_apndNextSystemCall_enum], sizeof(E.xNextSystemCall_signature)) == 0) {
+ apndNextSystemCall(args);
+ }
+ else if (memcmp(E.xNextSystemCall_signature, xNextSystemCall_signatures[xNextSystemCall_rbuVfsGetLastError_enum], sizeof(E.xNextSystemCall_signature)) == 0) {
+ rbuVfsGetLastError(args);
+ }
+ else if (memcmp(E.xNextSystemCall_signature, xNextSystemCall_signatures[xNextSystemCall_unixNextSystemCall_enum], sizeof(E.xNextSystemCall_signature)) == 0) {
+ unixNextSystemCall(args);
+ }


// Transform E.xOld(args) to if-chain with 3 candidates
@transform_no_return_xOld@
expression E;
identifier FP_NAME = xOld;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xOld_signature, xOld_signatures[xOld_sessionDiffOld_enum], sizeof(E.xOld_signature)) == 0) {
+ sessionDiffOld(args);
+ }
+ else if (memcmp(E.xOld_signature, xOld_signatures[xOld_sessionPreupdateOld_enum], sizeof(E.xOld_signature)) == 0) {
+ sessionPreupdateOld(args);
+ }
+ else if (memcmp(E.xOld_signature, xOld_signatures[xOld_sessionStat1Old_enum], sizeof(E.xOld_signature)) == 0) {
+ sessionStat1Old(args);
+ }


// Transform E.xOpen(args) to if-chain with 51 candidates
@transform_no_return_xOpen@
expression E;
identifier FP_NAME = xOpen;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_amatchOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ amatchOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_apndOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ apndOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_binfoOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ binfoOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_bytecodevtabOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ bytecodevtabOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_carrayOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ carrayOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_cidxOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ cidxOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_closureOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ closureOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_completionOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ completionOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_csvtabOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ csvtabOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_dbdataOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ dbdataOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_dbpageOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ dbpageOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_deltaparsevtabOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ deltaparsevtabOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_echoOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ echoOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_expertOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ expertOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_explainOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ explainOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_fsOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ fsOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_fsdirOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ fsdirOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_fstreeOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ fstreeOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_fts3OpenMethod_enum], sizeof(E.xOpen_signature)) == 0) {
+ fts3OpenMethod(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_fts3auxOpenMethod_enum], sizeof(E.xOpen_signature)) == 0) {
+ fts3auxOpenMethod(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_fts3termOpenMethod_enum], sizeof(E.xOpen_signature)) == 0) {
+ fts3termOpenMethod(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_fts3tokOpenMethod_enum], sizeof(E.xOpen_signature)) == 0) {
+ fts3tokOpenMethod(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_fuzzerOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ fuzzerOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_intarrayOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ intarrayOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_jsonEachOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ jsonEachOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_jsonEachOpenEach_enum], sizeof(E.xOpen_signature)) == 0) {
+ jsonEachOpenEach(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_jsonEachOpenTree_enum], sizeof(E.xOpen_signature)) == 0) {
+ jsonEachOpenTree(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_memdbOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ memdbOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_memstatOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ memstatOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_porterOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ porterOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_pragmaVtabOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ pragmaVtabOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_prefixesOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ prefixesOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_qpvtabOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ qpvtabOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_rtreeOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ rtreeOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_schemaOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ schemaOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_seriesOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ seriesOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_simpleOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ simpleOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_spellfix1Open_enum], sizeof(E.xOpen_signature)) == 0) {
+ spellfix1Open(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_statOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ statOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_stmtOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ stmtOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_tclOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ tclOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_tclvarOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ tclvarOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_templatevtabOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ templatevtabOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_unicodeOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ unicodeOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_unionOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ unionOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_vfstraceOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ vfstraceOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_vstattabOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ vstattabOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_vtablogOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ vtablogOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_wholenumberOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ wholenumberOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_zipfileOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ zipfileOpen(args);
+ }
+ else if (memcmp(E.xOpen_signature, xOpen_signatures[xOpen_unixOpen_enum], sizeof(E.xOpen_signature)) == 0) {
+ unixOpen(args);
+ }


// Transform E.xPagecount(args) to if-chain with 2 candidates
@transform_no_return_xPagecount@
expression E;
identifier FP_NAME = xPagecount;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xPagecount_signature, xPagecount_signatures[xPagecount_pcache1Pagecount_enum], sizeof(E.xPagecount_signature)) == 0) {
+ pcache1Pagecount(args);
+ }
+ else if (memcmp(E.xPagecount_signature, xPagecount_signatures[xPagecount_pcachetracePagecount_enum], sizeof(E.xPagecount_signature)) == 0) {
+ pcachetracePagecount(args);
+ }


// Transform E.xParseCell(args) to if-chain with 3 candidates
@transform_no_return_xParseCell@
expression E;
identifier FP_NAME = xParseCell;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xParseCell_signature, xParseCell_signatures[xParseCell_btreeParseCellPtr_enum], sizeof(E.xParseCell_signature)) == 0) {
+ btreeParseCellPtr(args);
+ }
+ else if (memcmp(E.xParseCell_signature, xParseCell_signatures[xParseCell_btreeParseCellPtrIndex_enum], sizeof(E.xParseCell_signature)) == 0) {
+ btreeParseCellPtrIndex(args);
+ }
+ else if (memcmp(E.xParseCell_signature, xParseCell_signatures[xParseCell_btreeParseCellPtrNoPayload_enum], sizeof(E.xParseCell_signature)) == 0) {
+ btreeParseCellPtrNoPayload(args);
+ }


// Transform E.xRandomness(args) to if-chain with 4 candidates
@transform_no_return_xRandomness@
expression E;
identifier FP_NAME = xRandomness;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xRandomness_signature, xRandomness_signatures[xRandomness_apndRandomness_enum], sizeof(E.xRandomness_signature)) == 0) {
+ apndRandomness(args);
+ }
+ else if (memcmp(E.xRandomness_signature, xRandomness_signatures[xRandomness_memdbRandomness_enum], sizeof(E.xRandomness_signature)) == 0) {
+ memdbRandomness(args);
+ }
+ else if (memcmp(E.xRandomness_signature, xRandomness_signatures[xRandomness_vfstraceRandomness_enum], sizeof(E.xRandomness_signature)) == 0) {
+ vfstraceRandomness(args);
+ }
+ else if (memcmp(E.xRandomness_signature, xRandomness_signatures[xRandomness_unixRandomness_enum], sizeof(E.xRandomness_signature)) == 0) {
+ unixRandomness(args);
+ }


// Transform E.xRead(args) to if-chain with 6 candidates
@transform_no_return_xRead@
expression E;
identifier FP_NAME = xRead;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xRead_signature, xRead_signatures[xRead_apndRead_enum], sizeof(E.xRead_signature)) == 0) {
+ apndRead(args);
+ }
+ else if (memcmp(E.xRead_signature, xRead_signatures[xRead_memdbRead_enum], sizeof(E.xRead_signature)) == 0) {
+ memdbRead(args);
+ }
+ else if (memcmp(E.xRead_signature, xRead_signatures[xRead_memjrnlRead_enum], sizeof(E.xRead_signature)) == 0) {
+ memjrnlRead(args);
+ }
+ else if (memcmp(E.xRead_signature, xRead_signatures[xRead_recoverVfsRead_enum], sizeof(E.xRead_signature)) == 0) {
+ recoverVfsRead(args);
+ }
+ else if (memcmp(E.xRead_signature, xRead_signatures[xRead_vfstraceRead_enum], sizeof(E.xRead_signature)) == 0) {
+ vfstraceRead(args);
+ }
+ else if (memcmp(E.xRead_signature, xRead_signatures[xRead_unixRead_enum], sizeof(E.xRead_signature)) == 0) {
+ unixRead(args);
+ }


// Transform E.xRealloc(args) to if-chain with 2 candidates
@transform_no_return_xRealloc@
expression E;
identifier FP_NAME = xRealloc;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xRealloc_signature, xRealloc_signatures[xRealloc_memtraceRealloc_enum], sizeof(E.xRealloc_signature)) == 0) {
+ memtraceRealloc(args);
+ }
+ else if (memcmp(E.xRealloc_signature, xRealloc_signatures[xRealloc_sqlite3MemRealloc_enum], sizeof(E.xRealloc_signature)) == 0) {
+ sqlite3MemRealloc(args);
+ }


// Transform E.xRekey(args) to if-chain with 3 candidates
@transform_no_return_xRekey@
expression E;
identifier FP_NAME = xRekey;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xRekey_signature, xRekey_signatures[xRekey_pcache1Rekey_enum], sizeof(E.xRekey_signature)) == 0) {
+ pcache1Rekey(args);
+ }
+ else if (memcmp(E.xRekey_signature, xRekey_signatures[xRekey_pcachetraceRekey_enum], sizeof(E.xRekey_signature)) == 0) {
+ pcachetraceRekey(args);
+ }
+ else if (memcmp(E.xRekey_signature, xRekey_signatures[xRekey_unixRandomness_enum], sizeof(E.xRekey_signature)) == 0) {
+ unixRandomness(args);
+ }


// Transform E.xRelease(args) to if-chain with 3 candidates
@transform_no_return_xRelease@
expression E;
identifier FP_NAME = xRelease;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xRelease_signature, xRelease_signatures[xRelease_0_enum], sizeof(E.xRelease_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xRelease_signature, xRelease_signatures[xRelease_echoRelease_enum], sizeof(E.xRelease_signature)) == 0) {
+ echoRelease(args);
+ }
+ else if (memcmp(E.xRelease_signature, xRelease_signatures[xRelease_fts3ReleaseMethod_enum], sizeof(E.xRelease_signature)) == 0) {
+ fts3ReleaseMethod(args);
+ }
+ else if (memcmp(E.xRelease_signature, xRelease_signatures[xRelease_vtablogRelease_enum], sizeof(E.xRelease_signature)) == 0) {
+ vtablogRelease(args);
+ }


// Transform E.xRename(args) to if-chain with 5 candidates
@transform_no_return_xRename@
expression E;
identifier FP_NAME = xRename;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xRename_signature, xRename_signatures[xRename_0_enum], sizeof(E.xRename_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xRename_signature, xRename_signatures[xRename_echoRename_enum], sizeof(E.xRename_signature)) == 0) {
+ echoRename(args);
+ }
+ else if (memcmp(E.xRename_signature, xRename_signatures[xRename_fts3RenameMethod_enum], sizeof(E.xRename_signature)) == 0) {
+ fts3RenameMethod(args);
+ }
+ else if (memcmp(E.xRename_signature, xRename_signatures[xRename_rtreeRename_enum], sizeof(E.xRename_signature)) == 0) {
+ rtreeRename(args);
+ }
+ else if (memcmp(E.xRename_signature, xRename_signatures[xRename_spellfix1Rename_enum], sizeof(E.xRename_signature)) == 0) {
+ spellfix1Rename(args);
+ }
+ else if (memcmp(E.xRename_signature, xRename_signatures[xRename_vtablogRename_enum], sizeof(E.xRename_signature)) == 0) {
+ vtablogRename(args);
+ }


// Transform E.xRollback(args) to if-chain with 6 candidates
@transform_no_return_xRollback@
expression E;
identifier FP_NAME = xRollback;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xRollback_signature, xRollback_signatures[xRollback_0_enum], sizeof(E.xRollback_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xRollback_signature, xRollback_signatures[xRollback_echoRollback_enum], sizeof(E.xRollback_signature)) == 0) {
+ echoRollback(args);
+ }
+ else if (memcmp(E.xRollback_signature, xRollback_signatures[xRollback_fts3RollbackMethod_enum], sizeof(E.xRollback_signature)) == 0) {
+ fts3RollbackMethod(args);
+ }
+ else if (memcmp(E.xRollback_signature, xRollback_signatures[xRollback_rtreeEndTransaction_enum], sizeof(E.xRollback_signature)) == 0) {
+ rtreeEndTransaction(args);
+ }
+ else if (memcmp(E.xRollback_signature, xRollback_signatures[xRollback_rtreeRollback_enum], sizeof(E.xRollback_signature)) == 0) {
+ rtreeRollback(args);
+ }
+ else if (memcmp(E.xRollback_signature, xRollback_signatures[xRollback_vtablogRollback_enum], sizeof(E.xRollback_signature)) == 0) {
+ vtablogRollback(args);
+ }
+ else if (memcmp(E.xRollback_signature, xRollback_signatures[xRollback_zipfileRollback_enum], sizeof(E.xRollback_signature)) == 0) {
+ zipfileRollback(args);
+ }


// Transform E.xRollbackTo(args) to if-chain with 4 candidates
@transform_no_return_xRollbackTo@
expression E;
identifier FP_NAME = xRollbackTo;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xRollbackTo_signature, xRollbackTo_signatures[xRollbackTo_0_enum], sizeof(E.xRollbackTo_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xRollbackTo_signature, xRollbackTo_signatures[xRollbackTo_dbpageRollbackTo_enum], sizeof(E.xRollbackTo_signature)) == 0) {
+ dbpageRollbackTo(args);
+ }
+ else if (memcmp(E.xRollbackTo_signature, xRollbackTo_signatures[xRollbackTo_echoRollbackTo_enum], sizeof(E.xRollbackTo_signature)) == 0) {
+ echoRollbackTo(args);
+ }
+ else if (memcmp(E.xRollbackTo_signature, xRollbackTo_signatures[xRollbackTo_fts3RollbackToMethod_enum], sizeof(E.xRollbackTo_signature)) == 0) {
+ fts3RollbackToMethod(args);
+ }
+ else if (memcmp(E.xRollbackTo_signature, xRollbackTo_signatures[xRollbackTo_vtablogRollbackTo_enum], sizeof(E.xRollbackTo_signature)) == 0) {
+ vtablogRollbackTo(args);
+ }


// Transform E.xRoundup(args) to if-chain with 2 candidates
@transform_no_return_xRoundup@
expression E;
identifier FP_NAME = xRoundup;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xRoundup_signature, xRoundup_signatures[xRoundup_memtraceRoundup_enum], sizeof(E.xRoundup_signature)) == 0) {
+ memtraceRoundup(args);
+ }
+ else if (memcmp(E.xRoundup_signature, xRoundup_signatures[xRoundup_sqlite3MemRoundup_enum], sizeof(E.xRoundup_signature)) == 0) {
+ sqlite3MemRoundup(args);
+ }


// Transform E.xRowid(args) to if-chain with 42 candidates
@transform_no_return_xRowid@
expression E;
identifier FP_NAME = xRowid;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_0_enum], sizeof(E.xRowid_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_amatchRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ amatchRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_binfoRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ binfoRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_bytecodevtabRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ bytecodevtabRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_carrayRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ carrayRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_cidxRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ cidxRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_closureRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ closureRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_completionRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ completionRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_csvtabRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ csvtabRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_dbdataRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ dbdataRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_dbpageRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ dbpageRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_deltaparsevtabRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ deltaparsevtabRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_echoRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ echoRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_expertRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ expertRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_explainRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ explainRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_fsRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ fsRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_fsdirRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ fsdirRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_fstreeRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ fstreeRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_fts3RowidMethod_enum], sizeof(E.xRowid_signature)) == 0) {
+ fts3RowidMethod(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_fts3auxRowidMethod_enum], sizeof(E.xRowid_signature)) == 0) {
+ fts3auxRowidMethod(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_fts3termRowidMethod_enum], sizeof(E.xRowid_signature)) == 0) {
+ fts3termRowidMethod(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_fts3tokRowidMethod_enum], sizeof(E.xRowid_signature)) == 0) {
+ fts3tokRowidMethod(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_fuzzerRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ fuzzerRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_intarrayRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ intarrayRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_jsonEachRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ jsonEachRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_memstatRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ memstatRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_pragmaVtabRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ pragmaVtabRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_prefixesRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ prefixesRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_qpvtabRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ qpvtabRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_rtreeRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ rtreeRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_schemaRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ schemaRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_seriesRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ seriesRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_spellfix1Rowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ spellfix1Rowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_statRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ statRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_stmtRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ stmtRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_tclRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ tclRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_tclvarRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ tclvarRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_templatevtabRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ templatevtabRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_unionRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ unionRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_vlogRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ vlogRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_vstattabRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ vstattabRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_vtablogRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ vtablogRowid(args);
+ }
+ else if (memcmp(E.xRowid_signature, xRowid_signatures[xRowid_wholenumberRowid_enum], sizeof(E.xRowid_signature)) == 0) {
+ wholenumberRowid(args);
+ }


// Transform E.xSFunc(args) to if-chain with 5 candidates
@transform_no_return_xSFunc@
expression E;
identifier FP_NAME = xSFunc;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_attachFunc_enum], sizeof(E.xSFunc_signature)) == 0) {
+ attachFunc(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_detachFunc_enum], sizeof(E.xSFunc_signature)) == 0) {
+ detachFunc(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_statGet_enum], sizeof(E.xSFunc_signature)) == 0) {
+ statGet(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_statInit_enum], sizeof(E.xSFunc_signature)) == 0) {
+ statInit(args);
+ }
+ else if (memcmp(E.xSFunc_signature, xSFunc_signatures[xSFunc_statPush_enum], sizeof(E.xSFunc_signature)) == 0) {
+ statPush(args);
+ }


// Transform E.xSavepoint(args) to if-chain with 2 candidates
@transform_no_return_xSavepoint@
expression E;
identifier FP_NAME = xSavepoint;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xSavepoint_signature, xSavepoint_signatures[xSavepoint_0_enum], sizeof(E.xSavepoint_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xSavepoint_signature, xSavepoint_signatures[xSavepoint_fts3SavepointMethod_enum], sizeof(E.xSavepoint_signature)) == 0) {
+ fts3SavepointMethod(args);
+ }
+ else if (memcmp(E.xSavepoint_signature, xSavepoint_signatures[xSavepoint_rtreeSavepoint_enum], sizeof(E.xSavepoint_signature)) == 0) {
+ rtreeSavepoint(args);
+ }


// Transform E.xSectorSize(args) to if-chain with 4 candidates
@transform_no_return_xSectorSize@
expression E;
identifier FP_NAME = xSectorSize;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xSectorSize_signature, xSectorSize_signatures[xSectorSize_0_enum], sizeof(E.xSectorSize_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xSectorSize_signature, xSectorSize_signatures[xSectorSize_apndSectorSize_enum], sizeof(E.xSectorSize_signature)) == 0) {
+ apndSectorSize(args);
+ }
+ else if (memcmp(E.xSectorSize_signature, xSectorSize_signatures[xSectorSize_recoverVfsSectorSize_enum], sizeof(E.xSectorSize_signature)) == 0) {
+ recoverVfsSectorSize(args);
+ }
+ else if (memcmp(E.xSectorSize_signature, xSectorSize_signatures[xSectorSize_vfstraceSectorSize_enum], sizeof(E.xSectorSize_signature)) == 0) {
+ vfstraceSectorSize(args);
+ }
+ else if (memcmp(E.xSectorSize_signature, xSectorSize_signatures[xSectorSize_unixSectorSize_enum], sizeof(E.xSectorSize_signature)) == 0) {
+ unixSectorSize(args);
+ }


// Transform E.xSelectCallback(args) to if-chain with 16 candidates
@transform_no_return_xSelectCallback@
expression E;
identifier FP_NAME = xSelectCallback;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_0_enum], sizeof(E.xSelectCallback_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_convertCompoundSelectToSubquery_enum], sizeof(E.xSelectCallback_signature)) == 0) {
+ convertCompoundSelectToSubquery(args);
+ }
+ else if (memcmp(E.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_exprSelectWalkTableConstant_enum], sizeof(E.xSelectCallback_signature)) == 0) {
+ exprSelectWalkTableConstant(args);
+ }
+ else if (memcmp(E.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_fixSelectCb_enum], sizeof(E.xSelectCallback_signature)) == 0) {
+ fixSelectCb(args);
+ }
+ else if (memcmp(E.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_gatherSelectWindowsSelectCallback_enum], sizeof(E.xSelectCallback_signature)) == 0) {
+ gatherSelectWindowsSelectCallback(args);
+ }
+ else if (memcmp(E.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_renameColumnSelectCb_enum], sizeof(E.xSelectCallback_signature)) == 0) {
+ renameColumnSelectCb(args);
+ }
+ else if (memcmp(E.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_renameTableSelectCb_enum], sizeof(E.xSelectCallback_signature)) == 0) {
+ renameTableSelectCb(args);
+ }
+ else if (memcmp(E.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_renameUnmapSelectCb_enum], sizeof(E.xSelectCallback_signature)) == 0) {
+ renameUnmapSelectCb(args);
+ }
+ else if (memcmp(E.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_resolveSelectStep_enum], sizeof(E.xSelectCallback_signature)) == 0) {
+ resolveSelectStep(args);
+ }
+ else if (memcmp(E.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_selectCheckOnClausesSelect_enum], sizeof(E.xSelectCallback_signature)) == 0) {
+ selectCheckOnClausesSelect(args);
+ }
+ else if (memcmp(E.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_selectExpander_enum], sizeof(E.xSelectCallback_signature)) == 0) {
+ selectExpander(args);
+ }
+ else if (memcmp(E.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_selectRefEnter_enum], sizeof(E.xSelectCallback_signature)) == 0) {
+ selectRefEnter(args);
+ }
+ else if (memcmp(E.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_selectWindowRewriteSelectCb_enum], sizeof(E.xSelectCallback_signature)) == 0) {
+ selectWindowRewriteSelectCb(args);
+ }
+ else if (memcmp(E.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_sqlite3ReturningSubqueryCorrelated_enum], sizeof(E.xSelectCallback_signature)) == 0) {
+ sqlite3ReturningSubqueryCorrelated(args);
+ }
+ else if (memcmp(E.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_sqlite3SelectWalkFail_enum], sizeof(E.xSelectCallback_signature)) == 0) {
+ sqlite3SelectWalkFail(args);
+ }
+ else if (memcmp(E.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_sqlite3SelectWalkNoop_enum], sizeof(E.xSelectCallback_signature)) == 0) {
+ sqlite3SelectWalkNoop(args);
+ }
+ else if (memcmp(E.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_sqlite3WalkerDepthIncrease_enum], sizeof(E.xSelectCallback_signature)) == 0) {
+ sqlite3WalkerDepthIncrease(args);
+ }


// Transform E.xSelectCallback2(args) to if-chain with 5 candidates
@transform_no_return_xSelectCallback2@
expression E;
identifier FP_NAME = xSelectCallback2;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_0_enum], sizeof(E.xSelectCallback2_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_selectAddSubqueryTypeInfo_enum], sizeof(E.xSelectCallback2_signature)) == 0) {
+ selectAddSubqueryTypeInfo(args);
+ }
+ else if (memcmp(E.xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_selectRefLeave_enum], sizeof(E.xSelectCallback2_signature)) == 0) {
+ selectRefLeave(args);
+ }
+ else if (memcmp(E.xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_sqlite3SelectPopWith_enum], sizeof(E.xSelectCallback2_signature)) == 0) {
+ sqlite3SelectPopWith(args);
+ }
+ else if (memcmp(E.xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_sqlite3WalkWinDefnDummyCallback_enum], sizeof(E.xSelectCallback2_signature)) == 0) {
+ sqlite3WalkWinDefnDummyCallback(args);
+ }
+ else if (memcmp(E.xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_sqlite3WalkerDepthDecrease_enum], sizeof(E.xSelectCallback2_signature)) == 0) {
+ sqlite3WalkerDepthDecrease(args);
+ }


// Transform E.xSetSystemCall(args) to if-chain with 5 candidates
@transform_no_return_xSetSystemCall@
expression E;
identifier FP_NAME = xSetSystemCall;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xSetSystemCall_signature, xSetSystemCall_signatures[xSetSystemCall_0_enum], sizeof(E.xSetSystemCall_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xSetSystemCall_signature, xSetSystemCall_signatures[xSetSystemCall_apndSetSystemCall_enum], sizeof(E.xSetSystemCall_signature)) == 0) {
+ apndSetSystemCall(args);
+ }
+ else if (memcmp(E.xSetSystemCall_signature, xSetSystemCall_signatures[xSetSystemCall_devsymSleep_enum], sizeof(E.xSetSystemCall_signature)) == 0) {
+ devsymSleep(args);
+ }
+ else if (memcmp(E.xSetSystemCall_signature, xSetSystemCall_signatures[xSetSystemCall_rbuVfsSleep_enum], sizeof(E.xSetSystemCall_signature)) == 0) {
+ rbuVfsSleep(args);
+ }
+ else if (memcmp(E.xSetSystemCall_signature, xSetSystemCall_signatures[xSetSystemCall_tvfsSleep_enum], sizeof(E.xSetSystemCall_signature)) == 0) {
+ tvfsSleep(args);
+ }
+ else if (memcmp(E.xSetSystemCall_signature, xSetSystemCall_signatures[xSetSystemCall_unixSetSystemCall_enum], sizeof(E.xSetSystemCall_signature)) == 0) {
+ unixSetSystemCall(args);
+ }


// Transform E.xShadowName(args) to if-chain with 2 candidates
@transform_no_return_xShadowName@
expression E;
identifier FP_NAME = xShadowName;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xShadowName_signature, xShadowName_signatures[xShadowName_0_enum], sizeof(E.xShadowName_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xShadowName_signature, xShadowName_signatures[xShadowName_fts3ShadowName_enum], sizeof(E.xShadowName_signature)) == 0) {
+ fts3ShadowName(args);
+ }
+ else if (memcmp(E.xShadowName_signature, xShadowName_signatures[xShadowName_rtreeShadowName_enum], sizeof(E.xShadowName_signature)) == 0) {
+ rtreeShadowName(args);
+ }


// Transform E.xShmBarrier(args) to if-chain with 3 candidates
@transform_no_return_xShmBarrier@
expression E;
identifier FP_NAME = xShmBarrier;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xShmBarrier_signature, xShmBarrier_signatures[xShmBarrier_0_enum], sizeof(E.xShmBarrier_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xShmBarrier_signature, xShmBarrier_signatures[xShmBarrier_apndShmBarrier_enum], sizeof(E.xShmBarrier_signature)) == 0) {
+ apndShmBarrier(args);
+ }
+ else if (memcmp(E.xShmBarrier_signature, xShmBarrier_signatures[xShmBarrier_recoverVfsShmBarrier_enum], sizeof(E.xShmBarrier_signature)) == 0) {
+ recoverVfsShmBarrier(args);
+ }
+ else if (memcmp(E.xShmBarrier_signature, xShmBarrier_signatures[xShmBarrier_unixShmBarrier_enum], sizeof(E.xShmBarrier_signature)) == 0) {
+ unixShmBarrier(args);
+ }


// Transform E.xShmLock(args) to if-chain with 3 candidates
@transform_no_return_xShmLock@
expression E;
identifier FP_NAME = xShmLock;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xShmLock_signature, xShmLock_signatures[xShmLock_0_enum], sizeof(E.xShmLock_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xShmLock_signature, xShmLock_signatures[xShmLock_apndShmLock_enum], sizeof(E.xShmLock_signature)) == 0) {
+ apndShmLock(args);
+ }
+ else if (memcmp(E.xShmLock_signature, xShmLock_signatures[xShmLock_recoverVfsShmLock_enum], sizeof(E.xShmLock_signature)) == 0) {
+ recoverVfsShmLock(args);
+ }
+ else if (memcmp(E.xShmLock_signature, xShmLock_signatures[xShmLock_unixShmLock_enum], sizeof(E.xShmLock_signature)) == 0) {
+ unixShmLock(args);
+ }


// Transform E.xShmMap(args) to if-chain with 3 candidates
@transform_no_return_xShmMap@
expression E;
identifier FP_NAME = xShmMap;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xShmMap_signature, xShmMap_signatures[xShmMap_0_enum], sizeof(E.xShmMap_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xShmMap_signature, xShmMap_signatures[xShmMap_apndShmMap_enum], sizeof(E.xShmMap_signature)) == 0) {
+ apndShmMap(args);
+ }
+ else if (memcmp(E.xShmMap_signature, xShmMap_signatures[xShmMap_recoverVfsShmMap_enum], sizeof(E.xShmMap_signature)) == 0) {
+ recoverVfsShmMap(args);
+ }
+ else if (memcmp(E.xShmMap_signature, xShmMap_signatures[xShmMap_unixShmMap_enum], sizeof(E.xShmMap_signature)) == 0) {
+ unixShmMap(args);
+ }


// Transform E.xShmUnmap(args) to if-chain with 3 candidates
@transform_no_return_xShmUnmap@
expression E;
identifier FP_NAME = xShmUnmap;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xShmUnmap_signature, xShmUnmap_signatures[xShmUnmap_0_enum], sizeof(E.xShmUnmap_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xShmUnmap_signature, xShmUnmap_signatures[xShmUnmap_apndShmUnmap_enum], sizeof(E.xShmUnmap_signature)) == 0) {
+ apndShmUnmap(args);
+ }
+ else if (memcmp(E.xShmUnmap_signature, xShmUnmap_signatures[xShmUnmap_recoverVfsShmUnmap_enum], sizeof(E.xShmUnmap_signature)) == 0) {
+ recoverVfsShmUnmap(args);
+ }
+ else if (memcmp(E.xShmUnmap_signature, xShmUnmap_signatures[xShmUnmap_unixShmUnmap_enum], sizeof(E.xShmUnmap_signature)) == 0) {
+ unixShmUnmap(args);
+ }


// Transform E.xShrink(args) to if-chain with 2 candidates
@transform_no_return_xShrink@
expression E;
identifier FP_NAME = xShrink;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xShrink_signature, xShrink_signatures[xShrink_pcache1Shrink_enum], sizeof(E.xShrink_signature)) == 0) {
+ pcache1Shrink(args);
+ }
+ else if (memcmp(E.xShrink_signature, xShrink_signatures[xShrink_pcachetraceShrink_enum], sizeof(E.xShrink_signature)) == 0) {
+ pcachetraceShrink(args);
+ }


// Transform E.xShutdown(args) to if-chain with 4 candidates
@transform_no_return_xShutdown@
expression E;
identifier FP_NAME = xShutdown;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xShutdown_signature, xShutdown_signatures[xShutdown_memtraceShutdown_enum], sizeof(E.xShutdown_signature)) == 0) {
+ memtraceShutdown(args);
+ }
+ else if (memcmp(E.xShutdown_signature, xShutdown_signatures[xShutdown_pcache1Shutdown_enum], sizeof(E.xShutdown_signature)) == 0) {
+ pcache1Shutdown(args);
+ }
+ else if (memcmp(E.xShutdown_signature, xShutdown_signatures[xShutdown_pcachetraceShutdown_enum], sizeof(E.xShutdown_signature)) == 0) {
+ pcachetraceShutdown(args);
+ }
+ else if (memcmp(E.xShutdown_signature, xShutdown_signatures[xShutdown_sqlite3MemShutdown_enum], sizeof(E.xShutdown_signature)) == 0) {
+ sqlite3MemShutdown(args);
+ }


// Transform E.xSize(args) to if-chain with 2 candidates
@transform_no_return_xSize@
expression E;
identifier FP_NAME = xSize;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xSize_signature, xSize_signatures[xSize_memtraceSize_enum], sizeof(E.xSize_signature)) == 0) {
+ memtraceSize(args);
+ }
+ else if (memcmp(E.xSize_signature, xSize_signatures[xSize_sqlite3MemSize_enum], sizeof(E.xSize_signature)) == 0) {
+ sqlite3MemSize(args);
+ }


// Transform E.xSleep(args) to if-chain with 4 candidates
@transform_no_return_xSleep@
expression E;
identifier FP_NAME = xSleep;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xSleep_signature, xSleep_signatures[xSleep_0_enum], sizeof(E.xSleep_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xSleep_signature, xSleep_signatures[xSleep_apndSleep_enum], sizeof(E.xSleep_signature)) == 0) {
+ apndSleep(args);
+ }
+ else if (memcmp(E.xSleep_signature, xSleep_signatures[xSleep_memdbSleep_enum], sizeof(E.xSleep_signature)) == 0) {
+ memdbSleep(args);
+ }
+ else if (memcmp(E.xSleep_signature, xSleep_signatures[xSleep_vfstraceSleep_enum], sizeof(E.xSleep_signature)) == 0) {
+ vfstraceSleep(args);
+ }
+ else if (memcmp(E.xSleep_signature, xSleep_signatures[xSleep_unixSleep_enum], sizeof(E.xSleep_signature)) == 0) {
+ unixSleep(args);
+ }


// Transform E.xSync(args) to if-chain with 11 candidates
@transform_no_return_xSync@
expression E;
identifier FP_NAME = xSync;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xSync_signature, xSync_signatures[xSync_0_enum], sizeof(E.xSync_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xSync_signature, xSync_signatures[xSync_apndSync_enum], sizeof(E.xSync_signature)) == 0) {
+ apndSync(args);
+ }
+ else if (memcmp(E.xSync_signature, xSync_signatures[xSync_dbpageSync_enum], sizeof(E.xSync_signature)) == 0) {
+ dbpageSync(args);
+ }
+ else if (memcmp(E.xSync_signature, xSync_signatures[xSync_echoSync_enum], sizeof(E.xSync_signature)) == 0) {
+ echoSync(args);
+ }
+ else if (memcmp(E.xSync_signature, xSync_signatures[xSync_fts3SyncMethod_enum], sizeof(E.xSync_signature)) == 0) {
+ fts3SyncMethod(args);
+ }
+ else if (memcmp(E.xSync_signature, xSync_signatures[xSync_memdbSync_enum], sizeof(E.xSync_signature)) == 0) {
+ memdbSync(args);
+ }
+ else if (memcmp(E.xSync_signature, xSync_signatures[xSync_memjrnlSync_enum], sizeof(E.xSync_signature)) == 0) {
+ memjrnlSync(args);
+ }
+ else if (memcmp(E.xSync_signature, xSync_signatures[xSync_recoverVfsSync_enum], sizeof(E.xSync_signature)) == 0) {
+ recoverVfsSync(args);
+ }
+ else if (memcmp(E.xSync_signature, xSync_signatures[xSync_rtreeEndTransaction_enum], sizeof(E.xSync_signature)) == 0) {
+ rtreeEndTransaction(args);
+ }
+ else if (memcmp(E.xSync_signature, xSync_signatures[xSync_vfstraceSync_enum], sizeof(E.xSync_signature)) == 0) {
+ vfstraceSync(args);
+ }
+ else if (memcmp(E.xSync_signature, xSync_signatures[xSync_vtablogSync_enum], sizeof(E.xSync_signature)) == 0) {
+ vtablogSync(args);
+ }
+ else if (memcmp(E.xSync_signature, xSync_signatures[xSync_unixSync_enum], sizeof(E.xSync_signature)) == 0) {
+ unixSync(args);
+ }


// Transform E.xTokenize(args) to if-chain with 3 candidates
@transform_no_return_xTokenize@
expression E;
identifier FP_NAME = xTokenize;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xTokenize_signature, xTokenize_signatures[xTokenize_0_enum], sizeof(E.xTokenize_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xTokenize_signature, xTokenize_signatures[xTokenize_f5tOrigintextTokenize_enum], sizeof(E.xTokenize_signature)) == 0) {
+ f5tOrigintextTokenize(args);
+ }
+ else if (memcmp(E.xTokenize_signature, xTokenize_signatures[xTokenize_f5tTokenizerTokenize_enum], sizeof(E.xTokenize_signature)) == 0) {
+ f5tTokenizerTokenize(args);
+ }
+ else if (memcmp(E.xTokenize_signature, xTokenize_signatures[xTokenize_f5tTokenizerTokenize_v2_enum], sizeof(E.xTokenize_signature)) == 0) {
+ f5tTokenizerTokenize_v2(args);
+ }


// Transform E.xTruncate(args) to if-chain with 8 candidates
@transform_no_return_xTruncate@
expression E;
identifier FP_NAME = xTruncate;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xTruncate_signature, xTruncate_signatures[xTruncate_apndTruncate_enum], sizeof(E.xTruncate_signature)) == 0) {
+ apndTruncate(args);
+ }
+ else if (memcmp(E.xTruncate_signature, xTruncate_signatures[xTruncate_memdbTruncate_enum], sizeof(E.xTruncate_signature)) == 0) {
+ memdbTruncate(args);
+ }
+ else if (memcmp(E.xTruncate_signature, xTruncate_signatures[xTruncate_memjrnlTruncate_enum], sizeof(E.xTruncate_signature)) == 0) {
+ memjrnlTruncate(args);
+ }
+ else if (memcmp(E.xTruncate_signature, xTruncate_signatures[xTruncate_pcache1Truncate_enum], sizeof(E.xTruncate_signature)) == 0) {
+ pcache1Truncate(args);
+ }
+ else if (memcmp(E.xTruncate_signature, xTruncate_signatures[xTruncate_pcachetraceTruncate_enum], sizeof(E.xTruncate_signature)) == 0) {
+ pcachetraceTruncate(args);
+ }
+ else if (memcmp(E.xTruncate_signature, xTruncate_signatures[xTruncate_recoverVfsTruncate_enum], sizeof(E.xTruncate_signature)) == 0) {
+ recoverVfsTruncate(args);
+ }
+ else if (memcmp(E.xTruncate_signature, xTruncate_signatures[xTruncate_vfstraceTruncate_enum], sizeof(E.xTruncate_signature)) == 0) {
+ vfstraceTruncate(args);
+ }
+ else if (memcmp(E.xTruncate_signature, xTruncate_signatures[xTruncate_unixTruncate_enum], sizeof(E.xTruncate_signature)) == 0) {
+ unixTruncate(args);
+ }


// Transform E.xUnfetch(args) to if-chain with 4 candidates
@transform_no_return_xUnfetch@
expression E;
identifier FP_NAME = xUnfetch;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xUnfetch_signature, xUnfetch_signatures[xUnfetch_0_enum], sizeof(E.xUnfetch_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xUnfetch_signature, xUnfetch_signatures[xUnfetch_apndUnfetch_enum], sizeof(E.xUnfetch_signature)) == 0) {
+ apndUnfetch(args);
+ }
+ else if (memcmp(E.xUnfetch_signature, xUnfetch_signatures[xUnfetch_memdbUnfetch_enum], sizeof(E.xUnfetch_signature)) == 0) {
+ memdbUnfetch(args);
+ }
+ else if (memcmp(E.xUnfetch_signature, xUnfetch_signatures[xUnfetch_recoverVfsUnfetch_enum], sizeof(E.xUnfetch_signature)) == 0) {
+ recoverVfsUnfetch(args);
+ }
+ else if (memcmp(E.xUnfetch_signature, xUnfetch_signatures[xUnfetch_unixUnfetch_enum], sizeof(E.xUnfetch_signature)) == 0) {
+ unixUnfetch(args);
+ }


// Transform E.xUnlock(args) to if-chain with 7 candidates
@transform_no_return_xUnlock@
expression E;
identifier FP_NAME = xUnlock;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xUnlock_signature, xUnlock_signatures[xUnlock_0_enum], sizeof(E.xUnlock_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xUnlock_signature, xUnlock_signatures[xUnlock_apndUnlock_enum], sizeof(E.xUnlock_signature)) == 0) {
+ apndUnlock(args);
+ }
+ else if (memcmp(E.xUnlock_signature, xUnlock_signatures[xUnlock_memdbUnlock_enum], sizeof(E.xUnlock_signature)) == 0) {
+ memdbUnlock(args);
+ }
+ else if (memcmp(E.xUnlock_signature, xUnlock_signatures[xUnlock_recoverVfsUnlock_enum], sizeof(E.xUnlock_signature)) == 0) {
+ recoverVfsUnlock(args);
+ }
+ else if (memcmp(E.xUnlock_signature, xUnlock_signatures[xUnlock_vfstraceUnlock_enum], sizeof(E.xUnlock_signature)) == 0) {
+ vfstraceUnlock(args);
+ }
+ else if (memcmp(E.xUnlock_signature, xUnlock_signatures[xUnlock_unixUnlock_enum], sizeof(E.xUnlock_signature)) == 0) {
+ unixUnlock(args);
+ }
+ else if (memcmp(E.xUnlock_signature, xUnlock_signatures[xUnlock_nolockUnlock_enum], sizeof(E.xUnlock_signature)) == 0) {
+ nolockUnlock(args);
+ }
+ else if (memcmp(E.xUnlock_signature, xUnlock_signatures[xUnlock_dotlockUnlock_enum], sizeof(E.xUnlock_signature)) == 0) {
+ dotlockUnlock(args);
+ }


// Transform E.xUnpin(args) to if-chain with 2 candidates
@transform_no_return_xUnpin@
expression E;
identifier FP_NAME = xUnpin;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xUnpin_signature, xUnpin_signatures[xUnpin_pcache1Unpin_enum], sizeof(E.xUnpin_signature)) == 0) {
+ pcache1Unpin(args);
+ }
+ else if (memcmp(E.xUnpin_signature, xUnpin_signatures[xUnpin_pcachetraceUnpin_enum], sizeof(E.xUnpin_signature)) == 0) {
+ pcachetraceUnpin(args);
+ }


// Transform E.xUpdate(args) to if-chain with 13 candidates
@transform_no_return_xUpdate@
expression E;
identifier FP_NAME = xUpdate;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xUpdate_signature, xUpdate_signatures[xUpdate_0_enum], sizeof(E.xUpdate_signature)) == 0) {
+ 0;
+ }
+ else if (memcmp(E.xUpdate_signature, xUpdate_signatures[xUpdate_amatchUpdate_enum], sizeof(E.xUpdate_signature)) == 0) {
+ amatchUpdate(args);
+ }
+ else if (memcmp(E.xUpdate_signature, xUpdate_signatures[xUpdate_csvtabUpdate_enum], sizeof(E.xUpdate_signature)) == 0) {
+ csvtabUpdate(args);
+ }
+ else if (memcmp(E.xUpdate_signature, xUpdate_signatures[xUpdate_dbpageUpdate_enum], sizeof(E.xUpdate_signature)) == 0) {
+ dbpageUpdate(args);
+ }
+ else if (memcmp(E.xUpdate_signature, xUpdate_signatures[xUpdate_echoUpdate_enum], sizeof(E.xUpdate_signature)) == 0) {
+ echoUpdate(args);
+ }
+ else if (memcmp(E.xUpdate_signature, xUpdate_signatures[xUpdate_expertUpdate_enum], sizeof(E.xUpdate_signature)) == 0) {
+ expertUpdate(args);
+ }
+ else if (memcmp(E.xUpdate_signature, xUpdate_signatures[xUpdate_fts3UpdateMethod_enum], sizeof(E.xUpdate_signature)) == 0) {
+ fts3UpdateMethod(args);
+ }
+ else if (memcmp(E.xUpdate_signature, xUpdate_signatures[xUpdate_geopolyUpdate_enum], sizeof(E.xUpdate_signature)) == 0) {
+ geopolyUpdate(args);
+ }
+ else if (memcmp(E.xUpdate_signature, xUpdate_signatures[xUpdate_rtreeUpdate_enum], sizeof(E.xUpdate_signature)) == 0) {
+ rtreeUpdate(args);
+ }
+ else if (memcmp(E.xUpdate_signature, xUpdate_signatures[xUpdate_spellfix1Update_enum], sizeof(E.xUpdate_signature)) == 0) {
+ spellfix1Update(args);
+ }
+ else if (memcmp(E.xUpdate_signature, xUpdate_signatures[xUpdate_tclvarUpdate_enum], sizeof(E.xUpdate_signature)) == 0) {
+ tclvarUpdate(args);
+ }
+ else if (memcmp(E.xUpdate_signature, xUpdate_signatures[xUpdate_vstattabUpdate_enum], sizeof(E.xUpdate_signature)) == 0) {
+ vstattabUpdate(args);
+ }
+ else if (memcmp(E.xUpdate_signature, xUpdate_signatures[xUpdate_vtablogUpdate_enum], sizeof(E.xUpdate_signature)) == 0) {
+ vtablogUpdate(args);
+ }
+ else if (memcmp(E.xUpdate_signature, xUpdate_signatures[xUpdate_zipfileUpdate_enum], sizeof(E.xUpdate_signature)) == 0) {
+ zipfileUpdate(args);
+ }


// Transform E.xWrite(args) to if-chain with 7 candidates
@transform_no_return_xWrite@
expression E;
identifier FP_NAME = xWrite;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xWrite_signature, xWrite_signatures[xWrite_apndWrite_enum], sizeof(E.xWrite_signature)) == 0) {
+ apndWrite(args);
+ }
+ else if (memcmp(E.xWrite_signature, xWrite_signatures[xWrite_kvstorageWrite_enum], sizeof(E.xWrite_signature)) == 0) {
+ kvstorageWrite(args);
+ }
+ else if (memcmp(E.xWrite_signature, xWrite_signatures[xWrite_memdbWrite_enum], sizeof(E.xWrite_signature)) == 0) {
+ memdbWrite(args);
+ }
+ else if (memcmp(E.xWrite_signature, xWrite_signatures[xWrite_memjrnlWrite_enum], sizeof(E.xWrite_signature)) == 0) {
+ memjrnlWrite(args);
+ }
+ else if (memcmp(E.xWrite_signature, xWrite_signatures[xWrite_recoverVfsWrite_enum], sizeof(E.xWrite_signature)) == 0) {
+ recoverVfsWrite(args);
+ }
+ else if (memcmp(E.xWrite_signature, xWrite_signatures[xWrite_vfstraceWrite_enum], sizeof(E.xWrite_signature)) == 0) {
+ vfstraceWrite(args);
+ }
+ else if (memcmp(E.xWrite_signature, xWrite_signatures[xWrite_unixWrite_enum], sizeof(E.xWrite_signature)) == 0) {
+ unixWrite(args);
+ }


// Transform E.xsnprintf(args) to if-chain with 1 candidates
@transform_no_return_xsnprintf@
expression E;
identifier FP_NAME = xsnprintf;
expression list args;
@@
- E.FP_NAME(args);
+ if (memcmp(E.xsnprintf_signature, xsnprintf_signatures[xsnprintf_sqlite3_set_authorizer_enum], sizeof(E.xsnprintf_signature)) == 0) {
+ sqlite3_set_authorizer(args);
+ }

// Total no return transformation rules generated: 321
// ===== ASSIGNMENT FUNCTION POINTER TRANSFORMATION RULES (ARROW) =====

// Transform E1 = E2->aggregate_context(args) to direct call (only 1 candidate)
@transform_assignment_aggregate_context_arrow@
expression E1, E2;
identifier FP_NAME = aggregate_context;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_aggregate_context(args);


// Transform E1 = E2->auto_extension(args) to direct call (only 1 candidate)
@transform_assignment_auto_extension_arrow@
expression E1, E2;
identifier FP_NAME = auto_extension;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_vtab_config(args);


// Transform E1 = E2->backup_finish(args) to direct call (only 1 candidate)
@transform_assignment_backup_finish_arrow@
expression E1, E2;
identifier FP_NAME = backup_finish;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_result_error_code(args);


// Transform E1 = E2->backup_init(args) to direct call (only 1 candidate)
@transform_assignment_backup_init_arrow@
expression E1, E2;
identifier FP_NAME = backup_init;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_test_control(args);


// Transform E1 = E2->backup_pagecount(args) to direct call (only 1 candidate)
@transform_assignment_backup_pagecount_arrow@
expression E1, E2;
identifier FP_NAME = backup_pagecount;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_randomness(args);


// Transform E1 = E2->backup_remaining(args) to direct call (only 1 candidate)
@transform_assignment_backup_remaining_arrow@
expression E1, E2;
identifier FP_NAME = backup_remaining;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_context_db_handle(args);


// Transform E1 = E2->backup_step(args) to direct call (only 1 candidate)
@transform_assignment_backup_step_arrow@
expression E1, E2;
identifier FP_NAME = backup_step;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_extended_result_codes(args);


// Transform E1 = E2->bind_blob64(args) to direct call (only 1 candidate)
@transform_assignment_bind_blob64_arrow@
expression E1, E2;
identifier FP_NAME = bind_blob64;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_vtab_on_conflict(args);


// Transform E1 = E2->bind_int(args) to direct call (only 1 candidate)
@transform_assignment_bind_int_arrow@
expression E1, E2;
identifier FP_NAME = bind_int;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_bind_double(args);


// Transform E1 = E2->bind_int64(args) to direct call (only 1 candidate)
@transform_assignment_bind_int64_arrow@
expression E1, E2;
identifier FP_NAME = bind_int64;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_bind_int(args);


// Transform E1 = E2->bind_null(args) to direct call (only 1 candidate)
@transform_assignment_bind_null_arrow@
expression E1, E2;
identifier FP_NAME = bind_null;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_bind_int64(args);


// Transform E1 = E2->bind_parameter_count(args) to direct call (only 1 candidate)
@transform_assignment_bind_parameter_count_arrow@
expression E1, E2;
identifier FP_NAME = bind_parameter_count;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_bind_null(args);


// Transform E1 = E2->bind_parameter_index(args) to direct call (only 1 candidate)
@transform_assignment_bind_parameter_index_arrow@
expression E1, E2;
identifier FP_NAME = bind_parameter_index;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_bind_parameter_count(args);


// Transform E1 = E2->bind_parameter_name(args) to direct call (only 1 candidate)
@transform_assignment_bind_parameter_name_arrow@
expression E1, E2;
identifier FP_NAME = bind_parameter_name;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_bind_parameter_index(args);


// Transform E1 = E2->bind_text(args) to direct call (only 1 candidate)
@transform_assignment_bind_text_arrow@
expression E1, E2;
identifier FP_NAME = bind_text;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_bind_parameter_name(args);


// Transform E1 = E2->bind_text16(args) to direct call (only 1 candidate)
@transform_assignment_bind_text16_arrow@
expression E1, E2;
identifier FP_NAME = bind_text16;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_bind_text(args);


// Transform E1 = E2->bind_text64(args) to direct call (only 1 candidate)
@transform_assignment_bind_text64_arrow@
expression E1, E2;
identifier FP_NAME = bind_text64;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_close_v2(args);


// Transform E1 = E2->bind_value(args) to direct call (only 1 candidate)
@transform_assignment_bind_value_arrow@
expression E1, E2;
identifier FP_NAME = bind_value;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_bind_text16(args);


// Transform E1 = E2->bind_zeroblob(args) to direct call (only 1 candidate)
@transform_assignment_bind_zeroblob_arrow@
expression E1, E2;
identifier FP_NAME = bind_zeroblob;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_prepare_v2(args);


// Transform E1 = E2->bind_zeroblob64(args) to direct call (only 1 candidate)
@transform_assignment_bind_zeroblob64_arrow@
expression E1, E2;
identifier FP_NAME = bind_zeroblob64;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_auto_extension(args);


// Transform E1 = E2->blob_bytes(args) to direct call (only 1 candidate)
@transform_assignment_blob_bytes_arrow@
expression E1, E2;
identifier FP_NAME = blob_bytes;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_prepare16_v2(args);


// Transform E1 = E2->blob_close(args) to direct call (only 1 candidate)
@transform_assignment_blob_close_arrow@
expression E1, E2;
identifier FP_NAME = blob_close;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_clear_bindings(args);


// Transform E1 = E2->blob_open(args) to direct call (only 1 candidate)
@transform_assignment_blob_open_arrow@
expression E1, E2;
identifier FP_NAME = blob_open;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_create_module_v2(args);


// Transform E1 = E2->blob_read(args) to direct call (only 1 candidate)
@transform_assignment_blob_read_arrow@
expression E1, E2;
identifier FP_NAME = blob_read;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_bind_zeroblob(args);


// Transform E1 = E2->blob_reopen(args) to direct call (only 1 candidate)
@transform_assignment_blob_reopen_arrow@
expression E1, E2;
identifier FP_NAME = blob_reopen;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_db_status(args);


// Transform E1 = E2->blob_write(args) to direct call (only 1 candidate)
@transform_assignment_blob_write_arrow@
expression E1, E2;
identifier FP_NAME = blob_write;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_blob_bytes(args);


// Transform E1 = E2->busy_handler(args) to direct call (only 1 candidate)
@transform_assignment_busy_handler_arrow@
expression E1, E2;
identifier FP_NAME = busy_handler;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_bind_value(args);


// Transform E1 = E2->busy_timeout(args) to direct call (only 1 candidate)
@transform_assignment_busy_timeout_arrow@
expression E1, E2;
identifier FP_NAME = busy_timeout;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_busy_handler(args);


// Transform E1 = E2->cancel_auto_extension(args) to direct call (only 1 candidate)
@transform_assignment_cancel_auto_extension_arrow@
expression E1, E2;
identifier FP_NAME = cancel_auto_extension;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_db_filename(args);


// Transform E1 = E2->changes(args) to direct call (only 1 candidate)
@transform_assignment_changes_arrow@
expression E1, E2;
identifier FP_NAME = changes;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_busy_timeout(args);


// Transform E1 = E2->changes64(args) to direct call (only 1 candidate)
@transform_assignment_changes64_arrow@
expression E1, E2;
identifier FP_NAME = changes64;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_str_value(args);


// Transform E1 = E2->clear_bindings(args) to direct call (only 1 candidate)
@transform_assignment_clear_bindings_arrow@
expression E1, E2;
identifier FP_NAME = clear_bindings;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_vmprintf(args);


// Transform E1 = E2->close(args) to direct call (only 1 candidate)
@transform_assignment_close_arrow@
expression E1, E2;
identifier FP_NAME = close;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_changes(args);


// Transform E1 = E2->close_v2(args) to direct call (only 1 candidate)
@transform_assignment_close_v2_arrow@
expression E1, E2;
identifier FP_NAME = close_v2;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_soft_heap_limit64(args);


// Transform E1 = E2->collation_needed(args) to direct call (only 1 candidate)
@transform_assignment_collation_needed_arrow@
expression E1, E2;
identifier FP_NAME = collation_needed;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_close(args);


// Transform E1 = E2->collation_needed16(args) to direct call (only 1 candidate)
@transform_assignment_collation_needed16_arrow@
expression E1, E2;
identifier FP_NAME = collation_needed16;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_collation_needed(args);


// Transform E1 = E2->column_blob(args) to direct call (only 1 candidate)
@transform_assignment_column_blob_arrow@
expression E1, E2;
identifier FP_NAME = column_blob;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_collation_needed16(args);


// Transform E1 = E2->column_bytes(args) to direct call (only 1 candidate)
@transform_assignment_column_bytes_arrow@
expression E1, E2;
identifier FP_NAME = column_bytes;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_column_blob(args);


// Transform E1 = E2->column_bytes16(args) to direct call (only 1 candidate)
@transform_assignment_column_bytes16_arrow@
expression E1, E2;
identifier FP_NAME = column_bytes16;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_column_bytes(args);


// Transform E1 = E2->column_count(args) to direct call (only 1 candidate)
@transform_assignment_column_count_arrow@
expression E1, E2;
identifier FP_NAME = column_count;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_column_bytes16(args);


// Transform E1 = E2->column_database_name(args) to direct call (only 1 candidate)
@transform_assignment_column_database_name_arrow@
expression E1, E2;
identifier FP_NAME = column_database_name;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_column_count(args);


// Transform E1 = E2->column_database_name16(args) to direct call (only 1 candidate)
@transform_assignment_column_database_name16_arrow@
expression E1, E2;
identifier FP_NAME = column_database_name16;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_column_database_name(args);


// Transform E1 = E2->column_decltype(args) to direct call (only 1 candidate)
@transform_assignment_column_decltype_arrow@
expression E1, E2;
identifier FP_NAME = column_decltype;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_column_database_name16(args);


// Transform E1 = E2->column_decltype16(args) to direct call (only 1 candidate)
@transform_assignment_column_decltype16_arrow@
expression E1, E2;
identifier FP_NAME = column_decltype16;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_column_decltype(args);


// Transform E1 = E2->column_double(args) to direct call (only 1 candidate)
@transform_assignment_column_double_arrow@
expression E1, E2;
identifier FP_NAME = column_double;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_column_decltype16(args);


// Transform E1 = E2->column_int(args) to direct call (only 1 candidate)
@transform_assignment_column_int_arrow@
expression E1, E2;
identifier FP_NAME = column_int;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_column_double(args);


// Transform E1 = E2->column_int64(args) to direct call (only 1 candidate)
@transform_assignment_column_int64_arrow@
expression E1, E2;
identifier FP_NAME = column_int64;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_column_int(args);


// Transform E1 = E2->column_name(args) to direct call (only 1 candidate)
@transform_assignment_column_name_arrow@
expression E1, E2;
identifier FP_NAME = column_name;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_column_int64(args);


// Transform E1 = E2->column_name16(args) to direct call (only 1 candidate)
@transform_assignment_column_name16_arrow@
expression E1, E2;
identifier FP_NAME = column_name16;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_column_name(args);


// Transform E1 = E2->column_origin_name(args) to direct call (only 1 candidate)
@transform_assignment_column_origin_name_arrow@
expression E1, E2;
identifier FP_NAME = column_origin_name;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_column_name16(args);


// Transform E1 = E2->column_origin_name16(args) to direct call (only 1 candidate)
@transform_assignment_column_origin_name16_arrow@
expression E1, E2;
identifier FP_NAME = column_origin_name16;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_column_origin_name(args);


// Transform E1 = E2->column_table_name(args) to direct call (only 1 candidate)
@transform_assignment_column_table_name_arrow@
expression E1, E2;
identifier FP_NAME = column_table_name;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_column_origin_name16(args);


// Transform E1 = E2->column_table_name16(args) to direct call (only 1 candidate)
@transform_assignment_column_table_name16_arrow@
expression E1, E2;
identifier FP_NAME = column_table_name16;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_column_table_name(args);


// Transform E1 = E2->column_text(args) to direct call (only 1 candidate)
@transform_assignment_column_text_arrow@
expression E1, E2;
identifier FP_NAME = column_text;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_column_table_name16(args);


// Transform E1 = E2->column_text16(args) to direct call (only 1 candidate)
@transform_assignment_column_text16_arrow@
expression E1, E2;
identifier FP_NAME = column_text16;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_column_text(args);


// Transform E1 = E2->column_type(args) to direct call (only 1 candidate)
@transform_assignment_column_type_arrow@
expression E1, E2;
identifier FP_NAME = column_type;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_column_text16(args);


// Transform E1 = E2->column_value(args) to direct call (only 1 candidate)
@transform_assignment_column_value_arrow@
expression E1, E2;
identifier FP_NAME = column_value;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_column_type(args);


// Transform E1 = E2->commit_hook(args) to direct call (only 1 candidate)
@transform_assignment_commit_hook_arrow@
expression E1, E2;
identifier FP_NAME = commit_hook;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_column_value(args);


// Transform E1 = E2->compileoption_get(args) to direct call (only 1 candidate)
@transform_assignment_compileoption_get_arrow@
expression E1, E2;
identifier FP_NAME = compileoption_get;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_limit(args);


// Transform E1 = E2->compileoption_used(args) to direct call (only 1 candidate)
@transform_assignment_compileoption_used_arrow@
expression E1, E2;
identifier FP_NAME = compileoption_used;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_next_stmt(args);


// Transform E1 = E2->complete(args) to direct call (only 1 candidate)
@transform_assignment_complete_arrow@
expression E1, E2;
identifier FP_NAME = complete;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_commit_hook(args);


// Transform E1 = E2->complete16(args) to direct call (only 1 candidate)
@transform_assignment_complete16_arrow@
expression E1, E2;
identifier FP_NAME = complete16;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_complete(args);


// Transform E1 = E2->context_db_handle(args) to direct call (only 1 candidate)
@transform_assignment_context_db_handle_arrow@
expression E1, E2;
identifier FP_NAME = context_db_handle;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_soft_heap_limit(args);


// Transform E1 = E2->create_collation(args) to direct call (only 1 candidate)
@transform_assignment_create_collation_arrow@
expression E1, E2;
identifier FP_NAME = create_collation;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_complete16(args);


// Transform E1 = E2->create_collation16(args) to direct call (only 1 candidate)
@transform_assignment_create_collation16_arrow@
expression E1, E2;
identifier FP_NAME = create_collation16;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_create_collation(args);


// Transform E1 = E2->create_collation_v2(args) to direct call (only 1 candidate)
@transform_assignment_create_collation_v2_arrow@
expression E1, E2;
identifier FP_NAME = create_collation_v2;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_blob_close(args);


// Transform E1 = E2->create_filename(args) to direct call (only 1 candidate)
@transform_assignment_create_filename_arrow@
expression E1, E2;
identifier FP_NAME = create_filename;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_str_appendchar(args);


// Transform E1 = E2->create_function(args) to direct call (only 1 candidate)
@transform_assignment_create_function_arrow@
expression E1, E2;
identifier FP_NAME = create_function;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_create_collation16(args);


// Transform E1 = E2->create_function16(args) to direct call (only 1 candidate)
@transform_assignment_create_function16_arrow@
expression E1, E2;
identifier FP_NAME = create_function16;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_create_function(args);


// Transform E1 = E2->create_function_v2(args) to direct call (only 1 candidate)
@transform_assignment_create_function_v2_arrow@
expression E1, E2;
identifier FP_NAME = create_function_v2;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_sql(args);


// Transform E1 = E2->create_module(args) to direct call (only 1 candidate)
@transform_assignment_create_module_arrow@
expression E1, E2;
identifier FP_NAME = create_module;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_create_function16(args);


// Transform E1 = E2->create_module_v2(args) to direct call (only 1 candidate)
@transform_assignment_create_module_v2_arrow@
expression E1, E2;
identifier FP_NAME = create_module_v2;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_overload_function(args);


// Transform E1 = E2->create_window_function(args) to direct call (only 1 candidate)
@transform_assignment_create_window_function_arrow@
expression E1, E2;
identifier FP_NAME = create_window_function;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_vtab_collation(args);


// Transform E1 = E2->data_count(args) to direct call (only 1 candidate)
@transform_assignment_data_count_arrow@
expression E1, E2;
identifier FP_NAME = data_count;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_create_module(args);


// Transform E1 = E2->database_file_object(args) to direct call (only 1 candidate)
@transform_assignment_database_file_object_arrow@
expression E1, E2;
identifier FP_NAME = database_file_object;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_str_errcode(args);


// Transform E1 = E2->db_cacheflush(args) to direct call (only 1 candidate)
@transform_assignment_db_cacheflush_arrow@
expression E1, E2;
identifier FP_NAME = db_cacheflush;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_malloc64(args);


// Transform E1 = E2->db_config(args) to direct call (only 1 candidate)
@transform_assignment_db_config_arrow@
expression E1, E2;
identifier FP_NAME = db_config;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_status(args);


// Transform E1 = E2->db_filename(args) to direct call (only 1 candidate)
@transform_assignment_db_filename_arrow@
expression E1, E2;
identifier FP_NAME = db_filename;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_sourceid(args);


// Transform E1 = E2->db_handle(args) to direct call (only 1 candidate)
@transform_assignment_db_handle_arrow@
expression E1, E2;
identifier FP_NAME = db_handle;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_data_count(args);


// Transform E1 = E2->db_mutex(args) to direct call (only 1 candidate)
@transform_assignment_db_mutex_arrow@
expression E1, E2;
identifier FP_NAME = db_mutex;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_backup_finish(args);


// Transform E1 = E2->db_name(args) to direct call (only 1 candidate)
@transform_assignment_db_name_arrow@
expression E1, E2;
identifier FP_NAME = db_name;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_filename_journal(args);


// Transform E1 = E2->db_readonly(args) to direct call (only 1 candidate)
@transform_assignment_db_readonly_arrow@
expression E1, E2;
identifier FP_NAME = db_readonly;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_stmt_status(args);


// Transform E1 = E2->db_release_memory(args) to direct call (only 1 candidate)
@transform_assignment_db_release_memory_arrow@
expression E1, E2;
identifier FP_NAME = db_release_memory;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_strnicmp(args);


// Transform E1 = E2->db_status(args) to direct call (only 1 candidate)
@transform_assignment_db_status_arrow@
expression E1, E2;
identifier FP_NAME = db_status;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_backup_init(args);


// Transform E1 = E2->declare_vtab(args) to direct call (only 1 candidate)
@transform_assignment_declare_vtab_arrow@
expression E1, E2;
identifier FP_NAME = declare_vtab;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_db_handle(args);


// Transform E1 = E2->deserialize(args) to direct call (only 1 candidate)
@transform_assignment_deserialize_arrow@
expression E1, E2;
identifier FP_NAME = deserialize;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_uri_key(args);


// Transform E1 = E2->drop_modules(args) to direct call (only 1 candidate)
@transform_assignment_drop_modules_arrow@
expression E1, E2;
identifier FP_NAME = drop_modules;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_str_new(args);


// Transform E1 = E2->enable_shared_cache(args) to direct call (only 1 candidate)
@transform_assignment_enable_shared_cache_arrow@
expression E1, E2;
identifier FP_NAME = enable_shared_cache;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_declare_vtab(args);


// Transform E1 = E2->errcode(args) to direct call (only 1 candidate)
@transform_assignment_errcode_arrow@
expression E1, E2;
identifier FP_NAME = errcode;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_enable_shared_cache(args);


// Transform E1 = E2->errmsg(args) to direct call (only 1 candidate)
@transform_assignment_errmsg_arrow@
expression E1, E2;
identifier FP_NAME = errmsg;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_errcode(args);


// Transform E1 = E2->errmsg16(args) to direct call (only 1 candidate)
@transform_assignment_errmsg16_arrow@
expression E1, E2;
identifier FP_NAME = errmsg16;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_errmsg(args);


// Transform E1 = E2->exec(args) to direct call (only 1 candidate)
@transform_assignment_exec_arrow@
expression E1, E2;
identifier FP_NAME = exec;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_errmsg16(args);


// Transform E1 = E2->expanded_sql(args) to direct call (only 1 candidate)
@transform_assignment_expanded_sql_arrow@
expression E1, E2;
identifier FP_NAME = expanded_sql;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_reset_auto_extension(args);


// Transform E1 = E2->expired(args) to direct call (only 1 candidate)
@transform_assignment_expired_arrow@
expression E1, E2;
identifier FP_NAME = expired;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_exec(args);


// Transform E1 = E2->extended_errcode(args) to direct call (only 1 candidate)
@transform_assignment_extended_errcode_arrow@
expression E1, E2;
identifier FP_NAME = extended_errcode;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_backup_pagecount(args);


// Transform E1 = E2->extended_result_codes(args) to direct call (only 1 candidate)
@transform_assignment_extended_result_codes_arrow@
expression E1, E2;
identifier FP_NAME = extended_result_codes;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_vfs_find(args);


// Transform E1 = E2->file_control(args) to direct call (only 1 candidate)
@transform_assignment_file_control_arrow@
expression E1, E2;
identifier FP_NAME = file_control;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_blob_open(args);


// Transform E1 = E2->filename_database(args) to direct call (only 1 candidate)
@transform_assignment_filename_database_arrow@
expression E1, E2;
identifier FP_NAME = filename_database;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_str_vappendf(args);


// Transform E1 = E2->filename_journal(args) to direct call (only 1 candidate)
@transform_assignment_filename_journal_arrow@
expression E1, E2;
identifier FP_NAME = filename_journal;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_str_append(args);


// Transform E1 = E2->filename_wal(args) to direct call (only 1 candidate)
@transform_assignment_filename_wal_arrow@
expression E1, E2;
identifier FP_NAME = filename_wal;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_str_appendall(args);


// Transform E1 = E2->free_filename(args) to direct call (only 1 candidate)
@transform_assignment_free_filename_arrow@
expression E1, E2;
identifier FP_NAME = free_filename;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_str_reset(args);


// Transform E1 = E2->get_autocommit(args) to direct call (only 1 candidate)
@transform_assignment_get_autocommit_arrow@
expression E1, E2;
identifier FP_NAME = get_autocommit;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_free(args);


// Transform E1 = E2->get_auxdata(args) to direct call (only 1 candidate)
@transform_assignment_get_auxdata_arrow@
expression E1, E2;
identifier FP_NAME = get_auxdata;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_free_table(args);


// Transform E1 = E2->get_clientdata(args) to direct call (only 1 candidate)
@transform_assignment_get_clientdata_arrow@
expression E1, E2;
identifier FP_NAME = get_clientdata;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_database_file_object(args);


// Transform E1 = E2->get_table(args) to direct call (only 1 candidate)
@transform_assignment_get_table_arrow@
expression E1, E2;
identifier FP_NAME = get_table;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_get_autocommit(args);


// Transform E1 = E2->global_recover(args) to direct call (only 1 candidate)
@transform_assignment_global_recover_arrow@
expression E1, E2;
identifier FP_NAME = global_recover;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_get_auxdata(args);


// Transform E1 = E2->hard_heap_limit64(args) to direct call (only 1 candidate)
@transform_assignment_hard_heap_limit64_arrow@
expression E1, E2;
identifier FP_NAME = hard_heap_limit64;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_str_finish(args);


// Transform E1 = E2->interruptx(args) to direct call (only 1 candidate)
@transform_assignment_interruptx_arrow@
expression E1, E2;
identifier FP_NAME = interruptx;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_get_table(args);


// Transform E1 = E2->is_interrupted(args) to direct call (only 1 candidate)
@transform_assignment_is_interrupted_arrow@
expression E1, E2;
identifier FP_NAME = is_interrupted;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_create_filename(args);


// Transform E1 = E2->keyword_check(args) to direct call (only 1 candidate)
@transform_assignment_keyword_check_arrow@
expression E1, E2;
identifier FP_NAME = keyword_check;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_db_cacheflush(args);


// Transform E1 = E2->keyword_count(args) to direct call (only 1 candidate)
@transform_assignment_keyword_count_arrow@
expression E1, E2;
identifier FP_NAME = keyword_count;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_status64(args);


// Transform E1 = E2->keyword_name(args) to direct call (only 1 candidate)
@transform_assignment_keyword_name_arrow@
expression E1, E2;
identifier FP_NAME = keyword_name;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_strlike(args);


// Transform E1 = E2->libversion(args) to direct call (only 1 candidate)
@transform_assignment_libversion_arrow@
expression E1, E2;
identifier FP_NAME = libversion;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_interrupt(args);


// Transform E1 = E2->libversion_number(args) to direct call (only 1 candidate)
@transform_assignment_libversion_number_arrow@
expression E1, E2;
identifier FP_NAME = libversion_number;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_last_insert_rowid(args);


// Transform E1 = E2->limit(args) to direct call (only 1 candidate)
@transform_assignment_limit_arrow@
expression E1, E2;
identifier FP_NAME = limit;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_vfs_register(args);


// Transform E1 = E2->load_extension(args) to direct call (only 1 candidate)
@transform_assignment_load_extension_arrow@
expression E1, E2;
identifier FP_NAME = load_extension;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_db_readonly(args);


// Transform E1 = E2->log(args) to direct call (only 1 candidate)
@transform_assignment_log_arrow@
expression E1, E2;
identifier FP_NAME = log;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_backup_remaining(args);


// Transform E1 = E2->malloc(args) to direct call (only 1 candidate)
@transform_assignment_malloc_arrow@
expression E1, E2;
identifier FP_NAME = malloc;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_libversion(args);


// Transform E1 = E2->malloc64(args) to direct call (only 1 candidate)
@transform_assignment_malloc64_arrow@
expression E1, E2;
identifier FP_NAME = malloc64;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_db_release_memory(args);


// Transform E1 = E2->memory_highwater(args) to direct call (only 1 candidate)
@transform_assignment_memory_highwater_arrow@
expression E1, E2;
identifier FP_NAME = memory_highwater;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_blob_read(args);


// Transform E1 = E2->memory_used(args) to direct call (only 1 candidate)
@transform_assignment_memory_used_arrow@
expression E1, E2;
identifier FP_NAME = memory_used;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_blob_write(args);


// Transform E1 = E2->mprintf(args) to direct call (only 1 candidate)
@transform_assignment_mprintf_arrow@
expression E1, E2;
identifier FP_NAME = mprintf;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_libversion_number(args);


// Transform E1 = E2->msize(args) to direct call (only 1 candidate)
@transform_assignment_msize_arrow@
expression E1, E2;
identifier FP_NAME = msize;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_errstr(args);


// Transform E1 = E2->mutex_alloc(args) to direct call (only 1 candidate)
@transform_assignment_mutex_alloc_arrow@
expression E1, E2;
identifier FP_NAME = mutex_alloc;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_create_collation_v2(args);


// Transform E1 = E2->mutex_enter(args) to direct call (only 1 candidate)
@transform_assignment_mutex_enter_arrow@
expression E1, E2;
identifier FP_NAME = mutex_enter;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_file_control(args);


// Transform E1 = E2->mutex_free(args) to direct call (only 1 candidate)
@transform_assignment_mutex_free_arrow@
expression E1, E2;
identifier FP_NAME = mutex_free;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_memory_highwater(args);


// Transform E1 = E2->mutex_leave(args) to direct call (only 1 candidate)
@transform_assignment_mutex_leave_arrow@
expression E1, E2;
identifier FP_NAME = mutex_leave;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_memory_used(args);


// Transform E1 = E2->next_stmt(args) to direct call (only 1 candidate)
@transform_assignment_next_stmt_arrow@
expression E1, E2;
identifier FP_NAME = next_stmt;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_vfs_unregister(args);


// Transform E1 = E2->normalized_sql(args) to direct call (only 1 candidate)
@transform_assignment_normalized_sql_arrow@
expression E1, E2;
identifier FP_NAME = normalized_sql;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_keyword_count(args);


// Transform E1 = E2->open(args) to direct call (only 1 candidate)
@transform_assignment_open_arrow@
expression E1, E2;
identifier FP_NAME = open;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_malloc(args);


// Transform E1 = E2->open16(args) to direct call (only 1 candidate)
@transform_assignment_open16_arrow@
expression E1, E2;
identifier FP_NAME = open16;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_mprintf(args);


// Transform E1 = E2->overload_function(args) to direct call (only 1 candidate)
@transform_assignment_overload_function_arrow@
expression E1, E2;
identifier FP_NAME = overload_function;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_value_text16be(args);


// Transform E1 = E2->prepare(args) to direct call (only 1 candidate)
@transform_assignment_prepare_arrow@
expression E1, E2;
identifier FP_NAME = prepare;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_open(args);


// Transform E1 = E2->prepare16(args) to direct call (only 1 candidate)
@transform_assignment_prepare16_arrow@
expression E1, E2;
identifier FP_NAME = prepare16;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_open16(args);


// Transform E1 = E2->prepare16_v2(args) to direct call (only 1 candidate)
@transform_assignment_prepare16_v2_arrow@
expression E1, E2;
identifier FP_NAME = prepare16_v2;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_value_type(args);


// Transform E1 = E2->prepare16_v3(args) to direct call (only 1 candidate)
@transform_assignment_prepare16_v3_arrow@
expression E1, E2;
identifier FP_NAME = prepare16_v3;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_strglob(args);


// Transform E1 = E2->prepare_v2(args) to direct call (only 1 candidate)
@transform_assignment_prepare_v2_arrow@
expression E1, E2;
identifier FP_NAME = prepare_v2;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_value_text16le(args);


// Transform E1 = E2->prepare_v3(args) to direct call (only 1 candidate)
@transform_assignment_prepare_v3_arrow@
expression E1, E2;
identifier FP_NAME = prepare_v3;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_result_text64(args);


// Transform E1 = E2->profile(args) to direct call (only 1 candidate)
@transform_assignment_profile_arrow@
expression E1, E2;
identifier FP_NAME = profile;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_prepare(args);


// Transform E1 = E2->progress_handler(args) to direct call (only 1 candidate)
@transform_assignment_progress_handler_arrow@
expression E1, E2;
identifier FP_NAME = progress_handler;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_prepare16(args);


// Transform E1 = E2->randomness(args) to direct call (only 1 candidate)
@transform_assignment_randomness_arrow@
expression E1, E2;
identifier FP_NAME = randomness;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_sleep(args);


// Transform E1 = E2->realloc(args) to direct call (only 1 candidate)
@transform_assignment_realloc_arrow@
expression E1, E2;
identifier FP_NAME = realloc;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_profile(args);


// Transform E1 = E2->realloc64(args) to direct call (only 1 candidate)
@transform_assignment_realloc64_arrow@
expression E1, E2;
identifier FP_NAME = realloc64;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_stmt_busy(args);


// Transform E1 = E2->reset(args) to direct call (only 1 candidate)
@transform_assignment_reset_arrow@
expression E1, E2;
identifier FP_NAME = reset;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_progress_handler(args);


// Transform E1 = E2->reset_auto_extension(args) to direct call (only 1 candidate)
@transform_assignment_reset_auto_extension_arrow@
expression E1, E2;
identifier FP_NAME = reset_auto_extension;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_stmt_readonly(args);


// Transform E1 = E2->result_blob(args) to direct call (only 1 candidate)
@transform_assignment_result_blob_arrow@
expression E1, E2;
identifier FP_NAME = result_blob;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_realloc(args);


// Transform E1 = E2->result_blob64(args) to direct call (only 1 candidate)
@transform_assignment_result_blob64_arrow@
expression E1, E2;
identifier FP_NAME = result_blob64;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_stricmp(args);


// Transform E1 = E2->result_double(args) to direct call (only 1 candidate)
@transform_assignment_result_double_arrow@
expression E1, E2;
identifier FP_NAME = result_double;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_reset(args);


// Transform E1 = E2->result_error(args) to direct call (only 1 candidate)
@transform_assignment_result_error_arrow@
expression E1, E2;
identifier FP_NAME = result_error;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_result_blob(args);


// Transform E1 = E2->result_error16(args) to direct call (only 1 candidate)
@transform_assignment_result_error16_arrow@
expression E1, E2;
identifier FP_NAME = result_error16;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_result_double(args);


// Transform E1 = E2->result_error_code(args) to direct call (only 1 candidate)
@transform_assignment_result_error_code_arrow@
expression E1, E2;
identifier FP_NAME = result_error_code;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_result_error_nomem(args);


// Transform E1 = E2->result_int(args) to direct call (only 1 candidate)
@transform_assignment_result_int_arrow@
expression E1, E2;
identifier FP_NAME = result_int;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_result_error(args);


// Transform E1 = E2->result_int64(args) to direct call (only 1 candidate)
@transform_assignment_result_int64_arrow@
expression E1, E2;
identifier FP_NAME = result_int64;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_result_error16(args);


// Transform E1 = E2->result_null(args) to direct call (only 1 candidate)
@transform_assignment_result_null_arrow@
expression E1, E2;
identifier FP_NAME = result_null;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_result_int(args);


// Transform E1 = E2->result_pointer(args) to direct call (only 1 candidate)
@transform_assignment_result_pointer_arrow@
expression E1, E2;
identifier FP_NAME = result_pointer;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_value_free(args);


// Transform E1 = E2->result_subtype(args) to direct call (only 1 candidate)
@transform_assignment_result_subtype_arrow@
expression E1, E2;
identifier FP_NAME = result_subtype;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_bind_text64(args);


// Transform E1 = E2->result_text(args) to direct call (only 1 candidate)
@transform_assignment_result_text_arrow@
expression E1, E2;
identifier FP_NAME = result_text;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_result_int64(args);


// Transform E1 = E2->result_text16(args) to direct call (only 1 candidate)
@transform_assignment_result_text16_arrow@
expression E1, E2;
identifier FP_NAME = result_text16;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_result_null(args);


// Transform E1 = E2->result_text16be(args) to direct call (only 1 candidate)
@transform_assignment_result_text16be_arrow@
expression E1, E2;
identifier FP_NAME = result_text16be;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_result_text(args);


// Transform E1 = E2->result_text16le(args) to direct call (only 1 candidate)
@transform_assignment_result_text16le_arrow@
expression E1, E2;
identifier FP_NAME = result_text16le;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_result_text16(args);


// Transform E1 = E2->result_text64(args) to direct call (only 1 candidate)
@transform_assignment_result_text64_arrow@
expression E1, E2;
identifier FP_NAME = result_text64;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_uri_boolean(args);


// Transform E1 = E2->result_value(args) to direct call (only 1 candidate)
@transform_assignment_result_value_arrow@
expression E1, E2;
identifier FP_NAME = result_value;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_result_text16be(args);


// Transform E1 = E2->result_zeroblob(args) to direct call (only 1 candidate)
@transform_assignment_result_zeroblob_arrow@
expression E1, E2;
identifier FP_NAME = result_zeroblob;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_release_memory(args);


// Transform E1 = E2->result_zeroblob64(args) to direct call (only 1 candidate)
@transform_assignment_result_zeroblob64_arrow@
expression E1, E2;
identifier FP_NAME = result_zeroblob64;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_wal_checkpoint_v2(args);


// Transform E1 = E2->rollback_hook(args) to direct call (only 1 candidate)
@transform_assignment_rollback_hook_arrow@
expression E1, E2;
identifier FP_NAME = rollback_hook;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_result_text16le(args);


// Transform E1 = E2->serialize(args) to direct call (only 1 candidate)
@transform_assignment_serialize_arrow@
expression E1, E2;
identifier FP_NAME = serialize;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_filename_database(args);


// Transform E1 = E2->set_authorizer(args) to direct call (only 1 candidate)
@transform_assignment_set_authorizer_arrow@
expression E1, E2;
identifier FP_NAME = set_authorizer;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_result_value(args);


// Transform E1 = E2->set_auxdata(args) to direct call (only 1 candidate)
@transform_assignment_set_auxdata_arrow@
expression E1, E2;
identifier FP_NAME = set_auxdata;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_rollback_hook(args);


// Transform E1 = E2->set_clientdata(args) to direct call (only 1 candidate)
@transform_assignment_set_clientdata_arrow@
expression E1, E2;
identifier FP_NAME = set_clientdata;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_txn_state(args);


// Transform E1 = E2->set_last_insert_rowid(args) to direct call (only 1 candidate)
@transform_assignment_set_last_insert_rowid_arrow@
expression E1, E2;
identifier FP_NAME = set_last_insert_rowid;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_result_blob64(args);


// Transform E1 = E2->setlk_timeout(args) to direct call (only 1 candidate)
@transform_assignment_setlk_timeout_arrow@
expression E1, E2;
identifier FP_NAME = setlk_timeout;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_changes64(args);


// Transform E1 = E2->soft_heap_limit(args) to direct call (only 1 candidate)
@transform_assignment_soft_heap_limit_arrow@
expression E1, E2;
identifier FP_NAME = soft_heap_limit;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_mutex_enter(args);


// Transform E1 = E2->soft_heap_limit64(args) to direct call (only 1 candidate)
@transform_assignment_soft_heap_limit64_arrow@
expression E1, E2;
identifier FP_NAME = soft_heap_limit64;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_backup_step(args);


// Transform E1 = E2->sql(args) to direct call (only 1 candidate)
@transform_assignment_sql_arrow@
expression E1, E2;
identifier FP_NAME = sql;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_threadsafe(args);


// Transform E1 = E2->status(args) to direct call (only 1 candidate)
@transform_assignment_status_arrow@
expression E1, E2;
identifier FP_NAME = status;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_result_zeroblob(args);


// Transform E1 = E2->status64(args) to direct call (only 1 candidate)
@transform_assignment_status64_arrow@
expression E1, E2;
identifier FP_NAME = status64;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_cancel_auto_extension(args);


// Transform E1 = E2->step(args) to direct call (only 1 candidate)
@transform_assignment_step_arrow@
expression E1, E2;
identifier FP_NAME = step;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_set_auxdata(args);


// Transform E1 = E2->stmt_explain(args) to direct call (only 1 candidate)
@transform_assignment_stmt_explain_arrow@
expression E1, E2;
identifier FP_NAME = stmt_explain;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_free_filename(args);


// Transform E1 = E2->stmt_isexplain(args) to direct call (only 1 candidate)
@transform_assignment_stmt_isexplain_arrow@
expression E1, E2;
identifier FP_NAME = stmt_isexplain;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_keyword_name(args);


// Transform E1 = E2->stmt_status(args) to direct call (only 1 candidate)
@transform_assignment_stmt_status_arrow@
expression E1, E2;
identifier FP_NAME = stmt_status;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_compileoption_used(args);


// Transform E1 = E2->str_append(args) to direct call (only 1 candidate)
@transform_assignment_str_append_arrow@
expression E1, E2;
identifier FP_NAME = str_append;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_prepare_v3(args);


// Transform E1 = E2->str_appendall(args) to direct call (only 1 candidate)
@transform_assignment_str_appendall_arrow@
expression E1, E2;
identifier FP_NAME = str_appendall;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_prepare16_v3(args);


// Transform E1 = E2->str_appendchar(args) to direct call (only 1 candidate)
@transform_assignment_str_appendchar_arrow@
expression E1, E2;
identifier FP_NAME = str_appendchar;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_bind_pointer(args);


// Transform E1 = E2->str_appendf(args) to direct call (only 1 candidate)
@transform_assignment_str_appendf_arrow@
expression E1, E2;
identifier FP_NAME = str_appendf;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_expanded_sql(args);


// Transform E1 = E2->str_errcode(args) to direct call (only 1 candidate)
@transform_assignment_str_errcode_arrow@
expression E1, E2;
identifier FP_NAME = str_errcode;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_value_pointer(args);


// Transform E1 = E2->str_finish(args) to direct call (only 1 candidate)
@transform_assignment_str_finish_arrow@
expression E1, E2;
identifier FP_NAME = str_finish;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_trace_v2(args);


// Transform E1 = E2->str_length(args) to direct call (only 1 candidate)
@transform_assignment_str_length_arrow@
expression E1, E2;
identifier FP_NAME = str_length;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_vtab_nochange(args);


// Transform E1 = E2->str_new(args) to direct call (only 1 candidate)
@transform_assignment_str_new_arrow@
expression E1, E2;
identifier FP_NAME = str_new;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_system_errno(args);


// Transform E1 = E2->str_reset(args) to direct call (only 1 candidate)
@transform_assignment_str_reset_arrow@
expression E1, E2;
identifier FP_NAME = str_reset;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_result_pointer(args);


// Transform E1 = E2->str_value(args) to direct call (only 1 candidate)
@transform_assignment_str_value_arrow@
expression E1, E2;
identifier FP_NAME = str_value;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_value_nochange(args);


// Transform E1 = E2->str_vappendf(args) to direct call (only 1 candidate)
@transform_assignment_str_vappendf_arrow@
expression E1, E2;
identifier FP_NAME = str_vappendf;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_set_last_insert_rowid(args);


// Transform E1 = E2->strglob(args) to direct call (only 1 candidate)
@transform_assignment_strglob_arrow@
expression E1, E2;
identifier FP_NAME = strglob;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_uri_int64(args);


// Transform E1 = E2->stricmp(args) to direct call (only 1 candidate)
@transform_assignment_stricmp_arrow@
expression E1, E2;
identifier FP_NAME = stricmp;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_wal_checkpoint(args);


// Transform E1 = E2->strlike(args) to direct call (only 1 candidate)
@transform_assignment_strlike_arrow@
expression E1, E2;
identifier FP_NAME = strlike;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_load_extension(args);


// Transform E1 = E2->system_errno(args) to direct call (only 1 candidate)
@transform_assignment_system_errno_arrow@
expression E1, E2;
identifier FP_NAME = system_errno;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_msize(args);


// Transform E1 = E2->table_column_metadata(args) to direct call (only 1 candidate)
@transform_assignment_table_column_metadata_arrow@
expression E1, E2;
identifier FP_NAME = table_column_metadata;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_snprintf(args);


// Transform E1 = E2->test_control(args) to direct call (only 1 candidate)
@transform_assignment_test_control_arrow@
expression E1, E2;
identifier FP_NAME = test_control;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_result_error_toobig(args);


// Transform E1 = E2->thread_cleanup(args) to direct call (only 1 candidate)
@transform_assignment_thread_cleanup_arrow@
expression E1, E2;
identifier FP_NAME = thread_cleanup;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_step(args);


// Transform E1 = E2->total_changes(args) to direct call (only 1 candidate)
@transform_assignment_total_changes_arrow@
expression E1, E2;
identifier FP_NAME = total_changes;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_table_column_metadata(args);


// Transform E1 = E2->total_changes64(args) to direct call (only 1 candidate)
@transform_assignment_total_changes64_arrow@
expression E1, E2;
identifier FP_NAME = total_changes64;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_create_window_function(args);


// Transform E1 = E2->trace_v2(args) to direct call (only 1 candidate)
@transform_assignment_trace_v2_arrow@
expression E1, E2;
identifier FP_NAME = trace_v2;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_realloc64(args);


// Transform E1 = E2->txn_state(args) to direct call (only 1 candidate)
@transform_assignment_txn_state_arrow@
expression E1, E2;
identifier FP_NAME = txn_state;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_str_length(args);


// Transform E1 = E2->uri_boolean(args) to direct call (only 1 candidate)
@transform_assignment_uri_boolean_arrow@
expression E1, E2;
identifier FP_NAME = uri_boolean;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_wal_hook(args);


// Transform E1 = E2->uri_key(args) to direct call (only 1 candidate)
@transform_assignment_uri_key_arrow@
expression E1, E2;
identifier FP_NAME = uri_key;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_str_appendf(args);


// Transform E1 = E2->user_data(args) to direct call (only 1 candidate)
@transform_assignment_user_data_arrow@
expression E1, E2;
identifier FP_NAME = user_data;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_trace(args);


// Transform E1 = E2->value_double(args) to direct call (only 1 candidate)
@transform_assignment_value_double_arrow@
expression E1, E2;
identifier FP_NAME = value_double;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_user_data(args);


// Transform E1 = E2->value_dup(args) to direct call (only 1 candidate)
@transform_assignment_value_dup_arrow@
expression E1, E2;
identifier FP_NAME = value_dup;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_uri_parameter(args);


// Transform E1 = E2->value_encoding(args) to direct call (only 1 candidate)
@transform_assignment_value_encoding_arrow@
expression E1, E2;
identifier FP_NAME = value_encoding;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_filename_wal(args);


// Transform E1 = E2->value_free(args) to direct call (only 1 candidate)
@transform_assignment_value_free_arrow@
expression E1, E2;
identifier FP_NAME = value_free;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_vsnprintf(args);


// Transform E1 = E2->value_frombind(args) to direct call (only 1 candidate)
@transform_assignment_value_frombind_arrow@
expression E1, E2;
identifier FP_NAME = value_frombind;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_keyword_check(args);


// Transform E1 = E2->value_int(args) to direct call (only 1 candidate)
@transform_assignment_value_int_arrow@
expression E1, E2;
identifier FP_NAME = value_int;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_value_blob(args);


// Transform E1 = E2->value_int64(args) to direct call (only 1 candidate)
@transform_assignment_value_int64_arrow@
expression E1, E2;
identifier FP_NAME = value_int64;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_value_bytes(args);


// Transform E1 = E2->value_nochange(args) to direct call (only 1 candidate)
@transform_assignment_value_nochange_arrow@
expression E1, E2;
identifier FP_NAME = value_nochange;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_value_subtype(args);


// Transform E1 = E2->value_numeric_type(args) to direct call (only 1 candidate)
@transform_assignment_value_numeric_type_arrow@
expression E1, E2;
identifier FP_NAME = value_numeric_type;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_value_bytes16(args);


// Transform E1 = E2->value_pointer(args) to direct call (only 1 candidate)
@transform_assignment_value_pointer_arrow@
expression E1, E2;
identifier FP_NAME = value_pointer;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_result_zeroblob64(args);


// Transform E1 = E2->value_subtype(args) to direct call (only 1 candidate)
@transform_assignment_value_subtype_arrow@
expression E1, E2;
identifier FP_NAME = value_subtype;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_bind_blob64(args);


// Transform E1 = E2->value_text(args) to direct call (only 1 candidate)
@transform_assignment_value_text_arrow@
expression E1, E2;
identifier FP_NAME = value_text;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_value_double(args);


// Transform E1 = E2->value_text16(args) to direct call (only 1 candidate)
@transform_assignment_value_text16_arrow@
expression E1, E2;
identifier FP_NAME = value_text16;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_value_int(args);


// Transform E1 = E2->value_text16be(args) to direct call (only 1 candidate)
@transform_assignment_value_text16be_arrow@
expression E1, E2;
identifier FP_NAME = value_text16be;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_value_int64(args);


// Transform E1 = E2->value_text16le(args) to direct call (only 1 candidate)
@transform_assignment_value_text16le_arrow@
expression E1, E2;
identifier FP_NAME = value_text16le;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_value_numeric_type(args);


// Transform E1 = E2->value_type(args) to direct call (only 1 candidate)
@transform_assignment_value_type_arrow@
expression E1, E2;
identifier FP_NAME = value_type;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_value_text(args);


// Transform E1 = E2->vfs_find(args) to direct call (only 1 candidate)
@transform_assignment_vfs_find_arrow@
expression E1, E2;
identifier FP_NAME = vfs_find;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_mutex_free(args);


// Transform E1 = E2->vfs_register(args) to direct call (only 1 candidate)
@transform_assignment_vfs_register_arrow@
expression E1, E2;
identifier FP_NAME = vfs_register;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_mutex_leave(args);


// Transform E1 = E2->vfs_unregister(args) to direct call (only 1 candidate)
@transform_assignment_vfs_unregister_arrow@
expression E1, E2;
identifier FP_NAME = vfs_unregister;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_mutex_try(args);


// Transform E1 = E2->vmprintf(args) to direct call (only 1 candidate)
@transform_assignment_vmprintf_arrow@
expression E1, E2;
identifier FP_NAME = vmprintf;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_value_text16(args);


// Transform E1 = E2->vtab_collation(args) to direct call (only 1 candidate)
@transform_assignment_vtab_collation_arrow@
expression E1, E2;
identifier FP_NAME = vtab_collation;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_result_subtype(args);


// Transform E1 = E2->vtab_config(args) to direct call (only 1 candidate)
@transform_assignment_vtab_config_arrow@
expression E1, E2;
identifier FP_NAME = vtab_config;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_extended_errcode(args);


// Transform E1 = E2->vtab_distinct(args) to direct call (only 1 candidate)
@transform_assignment_vtab_distinct_arrow@
expression E1, E2;
identifier FP_NAME = vtab_distinct;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_value_frombind(args);


// Transform E1 = E2->vtab_nochange(args) to direct call (only 1 candidate)
@transform_assignment_vtab_nochange_arrow@
expression E1, E2;
identifier FP_NAME = vtab_nochange;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_bind_zeroblob64(args);


// Transform E1 = E2->vtab_on_conflict(args) to direct call (only 1 candidate)
@transform_assignment_vtab_on_conflict_arrow@
expression E1, E2;
identifier FP_NAME = vtab_on_conflict;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_log(args);


// Transform E1 = E2->wal_checkpoint(args) to direct call (only 1 candidate)
@transform_assignment_wal_checkpoint_arrow@
expression E1, E2;
identifier FP_NAME = wal_checkpoint;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_db_config(args);


// Transform E1 = E2->wal_hook(args) to direct call (only 1 candidate)
@transform_assignment_wal_hook_arrow@
expression E1, E2;
identifier FP_NAME = wal_hook;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ E1 = sqlite3_db_mutex(args);


// Transform E1 = E2->xAccess(args) to if-chain with 4 candidates
@transform_assignment_xAccess_arrow@
expression E1, E2;
identifier FP_NAME = xAccess;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xAccess_signature, xAccess_signatures[xAccess_apndAccess_enum], sizeof(E2->xAccess_signature)) == 0) {
+ E1 = apndAccess(args);
+ }
+ else if (memcmp(E2->xAccess_signature, xAccess_signatures[xAccess_memdbAccess_enum], sizeof(E2->xAccess_signature)) == 0) {
+ E1 = memdbAccess(args);
+ }
+ else if (memcmp(E2->xAccess_signature, xAccess_signatures[xAccess_vfstraceAccess_enum], sizeof(E2->xAccess_signature)) == 0) {
+ E1 = vfstraceAccess(args);
+ }
+ else if (memcmp(E2->xAccess_signature, xAccess_signatures[xAccess_unixAccess_enum], sizeof(E2->xAccess_signature)) == 0) {
+ E1 = unixAccess(args);
+ }


// Transform E1 = E2->xBegin(args) to if-chain with 4 candidates
@transform_assignment_xBegin_arrow@
expression E1, E2;
identifier FP_NAME = xBegin;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xBegin_signature, xBegin_signatures[xBegin_0_enum], sizeof(E2->xBegin_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xBegin_signature, xBegin_signatures[xBegin_dbpageBegin_enum], sizeof(E2->xBegin_signature)) == 0) {
+ E1 = dbpageBegin(args);
+ }
+ else if (memcmp(E2->xBegin_signature, xBegin_signatures[xBegin_fts3BeginMethod_enum], sizeof(E2->xBegin_signature)) == 0) {
+ E1 = fts3BeginMethod(args);
+ }
+ else if (memcmp(E2->xBegin_signature, xBegin_signatures[xBegin_rtreeBeginTransaction_enum], sizeof(E2->xBegin_signature)) == 0) {
+ E1 = rtreeBeginTransaction(args);
+ }
+ else if (memcmp(E2->xBegin_signature, xBegin_signatures[xBegin_zipfileBegin_enum], sizeof(E2->xBegin_signature)) == 0) {
+ E1 = zipfileBegin(args);
+ }


// Transform E1 = E2->xBestIndex(args) to if-chain with 16 candidates
@transform_assignment_xBestIndex_arrow@
expression E1, E2;
identifier FP_NAME = xBestIndex;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xBestIndex_signature, xBestIndex_signatures[xBestIndex_bytecodevtabBestIndex_enum], sizeof(E2->xBestIndex_signature)) == 0) {
+ E1 = bytecodevtabBestIndex(args);
+ }
+ else if (memcmp(E2->xBestIndex_signature, xBestIndex_signatures[xBestIndex_completionBestIndex_enum], sizeof(E2->xBestIndex_signature)) == 0) {
+ E1 = completionBestIndex(args);
+ }
+ else if (memcmp(E2->xBestIndex_signature, xBestIndex_signatures[xBestIndex_dbdataBestIndex_enum], sizeof(E2->xBestIndex_signature)) == 0) {
+ E1 = dbdataBestIndex(args);
+ }
+ else if (memcmp(E2->xBestIndex_signature, xBestIndex_signatures[xBestIndex_dbpageBestIndex_enum], sizeof(E2->xBestIndex_signature)) == 0) {
+ E1 = dbpageBestIndex(args);
+ }
+ else if (memcmp(E2->xBestIndex_signature, xBestIndex_signatures[xBestIndex_expertBestIndex_enum], sizeof(E2->xBestIndex_signature)) == 0) {
+ E1 = expertBestIndex(args);
+ }
+ else if (memcmp(E2->xBestIndex_signature, xBestIndex_signatures[xBestIndex_fsdirBestIndex_enum], sizeof(E2->xBestIndex_signature)) == 0) {
+ E1 = fsdirBestIndex(args);
+ }
+ else if (memcmp(E2->xBestIndex_signature, xBestIndex_signatures[xBestIndex_fts3BestIndexMethod_enum], sizeof(E2->xBestIndex_signature)) == 0) {
+ E1 = fts3BestIndexMethod(args);
+ }
+ else if (memcmp(E2->xBestIndex_signature, xBestIndex_signatures[xBestIndex_fts3auxBestIndexMethod_enum], sizeof(E2->xBestIndex_signature)) == 0) {
+ E1 = fts3auxBestIndexMethod(args);
+ }
+ else if (memcmp(E2->xBestIndex_signature, xBestIndex_signatures[xBestIndex_fts3tokBestIndexMethod_enum], sizeof(E2->xBestIndex_signature)) == 0) {
+ E1 = fts3tokBestIndexMethod(args);
+ }
+ else if (memcmp(E2->xBestIndex_signature, xBestIndex_signatures[xBestIndex_jsonEachBestIndex_enum], sizeof(E2->xBestIndex_signature)) == 0) {
+ E1 = jsonEachBestIndex(args);
+ }
+ else if (memcmp(E2->xBestIndex_signature, xBestIndex_signatures[xBestIndex_pragmaVtabBestIndex_enum], sizeof(E2->xBestIndex_signature)) == 0) {
+ E1 = pragmaVtabBestIndex(args);
+ }
+ else if (memcmp(E2->xBestIndex_signature, xBestIndex_signatures[xBestIndex_rtreeBestIndex_enum], sizeof(E2->xBestIndex_signature)) == 0) {
+ E1 = rtreeBestIndex(args);
+ }
+ else if (memcmp(E2->xBestIndex_signature, xBestIndex_signatures[xBestIndex_seriesBestIndex_enum], sizeof(E2->xBestIndex_signature)) == 0) {
+ E1 = seriesBestIndex(args);
+ }
+ else if (memcmp(E2->xBestIndex_signature, xBestIndex_signatures[xBestIndex_statBestIndex_enum], sizeof(E2->xBestIndex_signature)) == 0) {
+ E1 = statBestIndex(args);
+ }
+ else if (memcmp(E2->xBestIndex_signature, xBestIndex_signatures[xBestIndex_stmtBestIndex_enum], sizeof(E2->xBestIndex_signature)) == 0) {
+ E1 = stmtBestIndex(args);
+ }
+ else if (memcmp(E2->xBestIndex_signature, xBestIndex_signatures[xBestIndex_zipfileBestIndex_enum], sizeof(E2->xBestIndex_signature)) == 0) {
+ E1 = zipfileBestIndex(args);
+ }


// Transform E1 = E2->xCachesize(args) to if-chain with 2 candidates
@transform_assignment_xCachesize_arrow@
expression E1, E2;
identifier FP_NAME = xCachesize;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xCachesize_signature, xCachesize_signatures[xCachesize_pcache1Cachesize_enum], sizeof(E2->xCachesize_signature)) == 0) {
+ E1 = pcache1Cachesize(args);
+ }
+ else if (memcmp(E2->xCachesize_signature, xCachesize_signatures[xCachesize_pcachetraceCachesize_enum], sizeof(E2->xCachesize_signature)) == 0) {
+ E1 = pcachetraceCachesize(args);
+ }


// Transform E1 = E2->xCellSize(args) to if-chain with 4 candidates
@transform_assignment_xCellSize_arrow@
expression E1, E2;
identifier FP_NAME = xCellSize;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xCellSize_signature, xCellSize_signatures[xCellSize_cellSizePtr_enum], sizeof(E2->xCellSize_signature)) == 0) {
+ E1 = cellSizePtr(args);
+ }
+ else if (memcmp(E2->xCellSize_signature, xCellSize_signatures[xCellSize_cellSizePtrIdxLeaf_enum], sizeof(E2->xCellSize_signature)) == 0) {
+ E1 = cellSizePtrIdxLeaf(args);
+ }
+ else if (memcmp(E2->xCellSize_signature, xCellSize_signatures[xCellSize_cellSizePtrNoPayload_enum], sizeof(E2->xCellSize_signature)) == 0) {
+ E1 = cellSizePtrNoPayload(args);
+ }
+ else if (memcmp(E2->xCellSize_signature, xCellSize_signatures[xCellSize_cellSizePtrTableLeaf_enum], sizeof(E2->xCellSize_signature)) == 0) {
+ E1 = cellSizePtrTableLeaf(args);
+ }


// Transform E1 = E2->xCheckReservedLock(args) to if-chain with 6 candidates
@transform_assignment_xCheckReservedLock_arrow@
expression E1, E2;
identifier FP_NAME = xCheckReservedLock;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xCheckReservedLock_signature, xCheckReservedLock_signatures[xCheckReservedLock_0_enum], sizeof(E2->xCheckReservedLock_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xCheckReservedLock_signature, xCheckReservedLock_signatures[xCheckReservedLock_apndCheckReservedLock_enum], sizeof(E2->xCheckReservedLock_signature)) == 0) {
+ E1 = apndCheckReservedLock(args);
+ }
+ else if (memcmp(E2->xCheckReservedLock_signature, xCheckReservedLock_signatures[xCheckReservedLock_recoverVfsCheckReservedLock_enum], sizeof(E2->xCheckReservedLock_signature)) == 0) {
+ E1 = recoverVfsCheckReservedLock(args);
+ }
+ else if (memcmp(E2->xCheckReservedLock_signature, xCheckReservedLock_signatures[xCheckReservedLock_vfstraceCheckReservedLock_enum], sizeof(E2->xCheckReservedLock_signature)) == 0) {
+ E1 = vfstraceCheckReservedLock(args);
+ }
+ else if (memcmp(E2->xCheckReservedLock_signature, xCheckReservedLock_signatures[xCheckReservedLock_unixCheckReservedLock_enum], sizeof(E2->xCheckReservedLock_signature)) == 0) {
+ E1 = unixCheckReservedLock(args);
+ }
+ else if (memcmp(E2->xCheckReservedLock_signature, xCheckReservedLock_signatures[xCheckReservedLock_nolockCheckReservedLock_enum], sizeof(E2->xCheckReservedLock_signature)) == 0) {
+ E1 = nolockCheckReservedLock(args);
+ }
+ else if (memcmp(E2->xCheckReservedLock_signature, xCheckReservedLock_signatures[xCheckReservedLock_dotlockCheckReservedLock_enum], sizeof(E2->xCheckReservedLock_signature)) == 0) {
+ E1 = dotlockCheckReservedLock(args);
+ }


// Transform E1 = E2->xClose(args) to if-chain with 27 candidates
@transform_assignment_xClose_arrow@
expression E1, E2;
identifier FP_NAME = xClose;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xClose_signature, xClose_signatures[xClose_apndClose_enum], sizeof(E2->xClose_signature)) == 0) {
+ E1 = apndClose(args);
+ }
+ else if (memcmp(E2->xClose_signature, xClose_signatures[xClose_bytecodevtabClose_enum], sizeof(E2->xClose_signature)) == 0) {
+ E1 = bytecodevtabClose(args);
+ }
+ else if (memcmp(E2->xClose_signature, xClose_signatures[xClose_completionClose_enum], sizeof(E2->xClose_signature)) == 0) {
+ E1 = completionClose(args);
+ }
+ else if (memcmp(E2->xClose_signature, xClose_signatures[xClose_dbdataClose_enum], sizeof(E2->xClose_signature)) == 0) {
+ E1 = dbdataClose(args);
+ }
+ else if (memcmp(E2->xClose_signature, xClose_signatures[xClose_dbpageClose_enum], sizeof(E2->xClose_signature)) == 0) {
+ E1 = dbpageClose(args);
+ }
+ else if (memcmp(E2->xClose_signature, xClose_signatures[xClose_expertClose_enum], sizeof(E2->xClose_signature)) == 0) {
+ E1 = expertClose(args);
+ }
+ else if (memcmp(E2->xClose_signature, xClose_signatures[xClose_fsdirClose_enum], sizeof(E2->xClose_signature)) == 0) {
+ E1 = fsdirClose(args);
+ }
+ else if (memcmp(E2->xClose_signature, xClose_signatures[xClose_fts3CloseMethod_enum], sizeof(E2->xClose_signature)) == 0) {
+ E1 = fts3CloseMethod(args);
+ }
+ else if (memcmp(E2->xClose_signature, xClose_signatures[xClose_fts3auxCloseMethod_enum], sizeof(E2->xClose_signature)) == 0) {
+ E1 = fts3auxCloseMethod(args);
+ }
+ else if (memcmp(E2->xClose_signature, xClose_signatures[xClose_fts3tokCloseMethod_enum], sizeof(E2->xClose_signature)) == 0) {
+ E1 = fts3tokCloseMethod(args);
+ }
+ else if (memcmp(E2->xClose_signature, xClose_signatures[xClose_jsonEachClose_enum], sizeof(E2->xClose_signature)) == 0) {
+ E1 = jsonEachClose(args);
+ }
+ else if (memcmp(E2->xClose_signature, xClose_signatures[xClose_memdbClose_enum], sizeof(E2->xClose_signature)) == 0) {
+ E1 = memdbClose(args);
+ }
+ else if (memcmp(E2->xClose_signature, xClose_signatures[xClose_memjrnlClose_enum], sizeof(E2->xClose_signature)) == 0) {
+ E1 = memjrnlClose(args);
+ }
+ else if (memcmp(E2->xClose_signature, xClose_signatures[xClose_porterClose_enum], sizeof(E2->xClose_signature)) == 0) {
+ E1 = porterClose(args);
+ }
+ else if (memcmp(E2->xClose_signature, xClose_signatures[xClose_pragmaVtabClose_enum], sizeof(E2->xClose_signature)) == 0) {
+ E1 = pragmaVtabClose(args);
+ }
+ else if (memcmp(E2->xClose_signature, xClose_signatures[xClose_recoverVfsClose_enum], sizeof(E2->xClose_signature)) == 0) {
+ E1 = recoverVfsClose(args);
+ }
+ else if (memcmp(E2->xClose_signature, xClose_signatures[xClose_rtreeClose_enum], sizeof(E2->xClose_signature)) == 0) {
+ E1 = rtreeClose(args);
+ }
+ else if (memcmp(E2->xClose_signature, xClose_signatures[xClose_seriesClose_enum], sizeof(E2->xClose_signature)) == 0) {
+ E1 = seriesClose(args);
+ }
+ else if (memcmp(E2->xClose_signature, xClose_signatures[xClose_simpleClose_enum], sizeof(E2->xClose_signature)) == 0) {
+ E1 = simpleClose(args);
+ }
+ else if (memcmp(E2->xClose_signature, xClose_signatures[xClose_statClose_enum], sizeof(E2->xClose_signature)) == 0) {
+ E1 = statClose(args);
+ }
+ else if (memcmp(E2->xClose_signature, xClose_signatures[xClose_stmtClose_enum], sizeof(E2->xClose_signature)) == 0) {
+ E1 = stmtClose(args);
+ }
+ else if (memcmp(E2->xClose_signature, xClose_signatures[xClose_unicodeClose_enum], sizeof(E2->xClose_signature)) == 0) {
+ E1 = unicodeClose(args);
+ }
+ else if (memcmp(E2->xClose_signature, xClose_signatures[xClose_vfstraceClose_enum], sizeof(E2->xClose_signature)) == 0) {
+ E1 = vfstraceClose(args);
+ }
+ else if (memcmp(E2->xClose_signature, xClose_signatures[xClose_zipfileClose_enum], sizeof(E2->xClose_signature)) == 0) {
+ E1 = zipfileClose(args);
+ }
+ else if (memcmp(E2->xClose_signature, xClose_signatures[xClose_unixClose_enum], sizeof(E2->xClose_signature)) == 0) {
+ E1 = unixClose(args);
+ }
+ else if (memcmp(E2->xClose_signature, xClose_signatures[xClose_nolockClose_enum], sizeof(E2->xClose_signature)) == 0) {
+ E1 = nolockClose(args);
+ }
+ else if (memcmp(E2->xClose_signature, xClose_signatures[xClose_dotlockClose_enum], sizeof(E2->xClose_signature)) == 0) {
+ E1 = dotlockClose(args);
+ }


// Transform E1 = E2->xColumn(args) to if-chain with 44 candidates
@transform_assignment_xColumn_arrow@
expression E1, E2;
identifier FP_NAME = xColumn;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xColumn_signature, xColumn_signatures[xColumn_amatchColumn_enum], sizeof(E2->xColumn_signature)) == 0) {
+ E1 = amatchColumn(args);
+ }
+ else if (memcmp(E2->xColumn_signature, xColumn_signatures[xColumn_binfoColumn_enum], sizeof(E2->xColumn_signature)) == 0) {
+ E1 = binfoColumn(args);
+ }
+ else if (memcmp(E2->xColumn_signature, xColumn_signatures[xColumn_bytecodevtabColumn_enum], sizeof(E2->xColumn_signature)) == 0) {
+ E1 = bytecodevtabColumn(args);
+ }
+ else if (memcmp(E2->xColumn_signature, xColumn_signatures[xColumn_carrayColumn_enum], sizeof(E2->xColumn_signature)) == 0) {
+ E1 = carrayColumn(args);
+ }
+ else if (memcmp(E2->xColumn_signature, xColumn_signatures[xColumn_cidxColumn_enum], sizeof(E2->xColumn_signature)) == 0) {
+ E1 = cidxColumn(args);
+ }
+ else if (memcmp(E2->xColumn_signature, xColumn_signatures[xColumn_closureColumn_enum], sizeof(E2->xColumn_signature)) == 0) {
+ E1 = closureColumn(args);
+ }
+ else if (memcmp(E2->xColumn_signature, xColumn_signatures[xColumn_completionColumn_enum], sizeof(E2->xColumn_signature)) == 0) {
+ E1 = completionColumn(args);
+ }
+ else if (memcmp(E2->xColumn_signature, xColumn_signatures[xColumn_csvtabColumn_enum], sizeof(E2->xColumn_signature)) == 0) {
+ E1 = csvtabColumn(args);
+ }
+ else if (memcmp(E2->xColumn_signature, xColumn_signatures[xColumn_dbdataColumn_enum], sizeof(E2->xColumn_signature)) == 0) {
+ E1 = dbdataColumn(args);
+ }
+ else if (memcmp(E2->xColumn_signature, xColumn_signatures[xColumn_dbpageColumn_enum], sizeof(E2->xColumn_signature)) == 0) {
+ E1 = dbpageColumn(args);
+ }
+ else if (memcmp(E2->xColumn_signature, xColumn_signatures[xColumn_deltaparsevtabColumn_enum], sizeof(E2->xColumn_signature)) == 0) {
+ E1 = deltaparsevtabColumn(args);
+ }
+ else if (memcmp(E2->xColumn_signature, xColumn_signatures[xColumn_echoColumn_enum], sizeof(E2->xColumn_signature)) == 0) {
+ E1 = echoColumn(args);
+ }
+ else if (memcmp(E2->xColumn_signature, xColumn_signatures[xColumn_expertColumn_enum], sizeof(E2->xColumn_signature)) == 0) {
+ E1 = expertColumn(args);
+ }
+ else if (memcmp(E2->xColumn_signature, xColumn_signatures[xColumn_explainColumn_enum], sizeof(E2->xColumn_signature)) == 0) {
+ E1 = explainColumn(args);
+ }
+ else if (memcmp(E2->xColumn_signature, xColumn_signatures[xColumn_fsColumn_enum], sizeof(E2->xColumn_signature)) == 0) {
+ E1 = fsColumn(args);
+ }
+ else if (memcmp(E2->xColumn_signature, xColumn_signatures[xColumn_fsdirColumn_enum], sizeof(E2->xColumn_signature)) == 0) {
+ E1 = fsdirColumn(args);
+ }
+ else if (memcmp(E2->xColumn_signature, xColumn_signatures[xColumn_fstreeColumn_enum], sizeof(E2->xColumn_signature)) == 0) {
+ E1 = fstreeColumn(args);
+ }
+ else if (memcmp(E2->xColumn_signature, xColumn_signatures[xColumn_fts3ColumnMethod_enum], sizeof(E2->xColumn_signature)) == 0) {
+ E1 = fts3ColumnMethod(args);
+ }
+ else if (memcmp(E2->xColumn_signature, xColumn_signatures[xColumn_fts3auxColumnMethod_enum], sizeof(E2->xColumn_signature)) == 0) {
+ E1 = fts3auxColumnMethod(args);
+ }
+ else if (memcmp(E2->xColumn_signature, xColumn_signatures[xColumn_fts3termColumnMethod_enum], sizeof(E2->xColumn_signature)) == 0) {
+ E1 = fts3termColumnMethod(args);
+ }
+ else if (memcmp(E2->xColumn_signature, xColumn_signatures[xColumn_fts3tokColumnMethod_enum], sizeof(E2->xColumn_signature)) == 0) {
+ E1 = fts3tokColumnMethod(args);
+ }
+ else if (memcmp(E2->xColumn_signature, xColumn_signatures[xColumn_fuzzerColumn_enum], sizeof(E2->xColumn_signature)) == 0) {
+ E1 = fuzzerColumn(args);
+ }
+ else if (memcmp(E2->xColumn_signature, xColumn_signatures[xColumn_geopolyColumn_enum], sizeof(E2->xColumn_signature)) == 0) {
+ E1 = geopolyColumn(args);
+ }
+ else if (memcmp(E2->xColumn_signature, xColumn_signatures[xColumn_intarrayColumn_enum], sizeof(E2->xColumn_signature)) == 0) {
+ E1 = intarrayColumn(args);
+ }
+ else if (memcmp(E2->xColumn_signature, xColumn_signatures[xColumn_jsonEachColumn_enum], sizeof(E2->xColumn_signature)) == 0) {
+ E1 = jsonEachColumn(args);
+ }
+ else if (memcmp(E2->xColumn_signature, xColumn_signatures[xColumn_memstatColumn_enum], sizeof(E2->xColumn_signature)) == 0) {
+ E1 = memstatColumn(args);
+ }
+ else if (memcmp(E2->xColumn_signature, xColumn_signatures[xColumn_pragmaVtabColumn_enum], sizeof(E2->xColumn_signature)) == 0) {
+ E1 = pragmaVtabColumn(args);
+ }
+ else if (memcmp(E2->xColumn_signature, xColumn_signatures[xColumn_prefixesColumn_enum], sizeof(E2->xColumn_signature)) == 0) {
+ E1 = prefixesColumn(args);
+ }
+ else if (memcmp(E2->xColumn_signature, xColumn_signatures[xColumn_qpvtabColumn_enum], sizeof(E2->xColumn_signature)) == 0) {
+ E1 = qpvtabColumn(args);
+ }
+ else if (memcmp(E2->xColumn_signature, xColumn_signatures[xColumn_rtreeColumn_enum], sizeof(E2->xColumn_signature)) == 0) {
+ E1 = rtreeColumn(args);
+ }
+ else if (memcmp(E2->xColumn_signature, xColumn_signatures[xColumn_schemaColumn_enum], sizeof(E2->xColumn_signature)) == 0) {
+ E1 = schemaColumn(args);
+ }
+ else if (memcmp(E2->xColumn_signature, xColumn_signatures[xColumn_seriesColumn_enum], sizeof(E2->xColumn_signature)) == 0) {
+ E1 = seriesColumn(args);
+ }
+ else if (memcmp(E2->xColumn_signature, xColumn_signatures[xColumn_spellfix1Column_enum], sizeof(E2->xColumn_signature)) == 0) {
+ E1 = spellfix1Column(args);
+ }
+ else if (memcmp(E2->xColumn_signature, xColumn_signatures[xColumn_statColumn_enum], sizeof(E2->xColumn_signature)) == 0) {
+ E1 = statColumn(args);
+ }
+ else if (memcmp(E2->xColumn_signature, xColumn_signatures[xColumn_stmtColumn_enum], sizeof(E2->xColumn_signature)) == 0) {
+ E1 = stmtColumn(args);
+ }
+ else if (memcmp(E2->xColumn_signature, xColumn_signatures[xColumn_tclColumn_enum], sizeof(E2->xColumn_signature)) == 0) {
+ E1 = tclColumn(args);
+ }
+ else if (memcmp(E2->xColumn_signature, xColumn_signatures[xColumn_tclvarColumn_enum], sizeof(E2->xColumn_signature)) == 0) {
+ E1 = tclvarColumn(args);
+ }
+ else if (memcmp(E2->xColumn_signature, xColumn_signatures[xColumn_templatevtabColumn_enum], sizeof(E2->xColumn_signature)) == 0) {
+ E1 = templatevtabColumn(args);
+ }
+ else if (memcmp(E2->xColumn_signature, xColumn_signatures[xColumn_unionColumn_enum], sizeof(E2->xColumn_signature)) == 0) {
+ E1 = unionColumn(args);
+ }
+ else if (memcmp(E2->xColumn_signature, xColumn_signatures[xColumn_vlogColumn_enum], sizeof(E2->xColumn_signature)) == 0) {
+ E1 = vlogColumn(args);
+ }
+ else if (memcmp(E2->xColumn_signature, xColumn_signatures[xColumn_vstattabColumn_enum], sizeof(E2->xColumn_signature)) == 0) {
+ E1 = vstattabColumn(args);
+ }
+ else if (memcmp(E2->xColumn_signature, xColumn_signatures[xColumn_vtablogColumn_enum], sizeof(E2->xColumn_signature)) == 0) {
+ E1 = vtablogColumn(args);
+ }
+ else if (memcmp(E2->xColumn_signature, xColumn_signatures[xColumn_wholenumberColumn_enum], sizeof(E2->xColumn_signature)) == 0) {
+ E1 = wholenumberColumn(args);
+ }
+ else if (memcmp(E2->xColumn_signature, xColumn_signatures[xColumn_zipfileColumn_enum], sizeof(E2->xColumn_signature)) == 0) {
+ E1 = zipfileColumn(args);
+ }


// Transform E1 = E2->xCommit(args) to if-chain with 5 candidates
@transform_assignment_xCommit_arrow@
expression E1, E2;
identifier FP_NAME = xCommit;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xCommit_signature, xCommit_signatures[xCommit_0_enum], sizeof(E2->xCommit_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xCommit_signature, xCommit_signatures[xCommit_echoCommit_enum], sizeof(E2->xCommit_signature)) == 0) {
+ E1 = echoCommit(args);
+ }
+ else if (memcmp(E2->xCommit_signature, xCommit_signatures[xCommit_fts3CommitMethod_enum], sizeof(E2->xCommit_signature)) == 0) {
+ E1 = fts3CommitMethod(args);
+ }
+ else if (memcmp(E2->xCommit_signature, xCommit_signatures[xCommit_rtreeEndTransaction_enum], sizeof(E2->xCommit_signature)) == 0) {
+ E1 = rtreeEndTransaction(args);
+ }
+ else if (memcmp(E2->xCommit_signature, xCommit_signatures[xCommit_vtablogCommit_enum], sizeof(E2->xCommit_signature)) == 0) {
+ E1 = vtablogCommit(args);
+ }
+ else if (memcmp(E2->xCommit_signature, xCommit_signatures[xCommit_zipfileCommit_enum], sizeof(E2->xCommit_signature)) == 0) {
+ E1 = zipfileCommit(args);
+ }


// Transform E1 = E2->xConnect(args) to if-chain with 44 candidates
@transform_assignment_xConnect_arrow@
expression E1, E2;
identifier FP_NAME = xConnect;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xConnect_signature, xConnect_signatures[xConnect_amatchConnect_enum], sizeof(E2->xConnect_signature)) == 0) {
+ E1 = amatchConnect(args);
+ }
+ else if (memcmp(E2->xConnect_signature, xConnect_signatures[xConnect_binfoConnect_enum], sizeof(E2->xConnect_signature)) == 0) {
+ E1 = binfoConnect(args);
+ }
+ else if (memcmp(E2->xConnect_signature, xConnect_signatures[xConnect_bytecodevtabConnect_enum], sizeof(E2->xConnect_signature)) == 0) {
+ E1 = bytecodevtabConnect(args);
+ }
+ else if (memcmp(E2->xConnect_signature, xConnect_signatures[xConnect_carrayConnect_enum], sizeof(E2->xConnect_signature)) == 0) {
+ E1 = carrayConnect(args);
+ }
+ else if (memcmp(E2->xConnect_signature, xConnect_signatures[xConnect_cidxConnect_enum], sizeof(E2->xConnect_signature)) == 0) {
+ E1 = cidxConnect(args);
+ }
+ else if (memcmp(E2->xConnect_signature, xConnect_signatures[xConnect_closureConnect_enum], sizeof(E2->xConnect_signature)) == 0) {
+ E1 = closureConnect(args);
+ }
+ else if (memcmp(E2->xConnect_signature, xConnect_signatures[xConnect_completionConnect_enum], sizeof(E2->xConnect_signature)) == 0) {
+ E1 = completionConnect(args);
+ }
+ else if (memcmp(E2->xConnect_signature, xConnect_signatures[xConnect_csvtabConnect_enum], sizeof(E2->xConnect_signature)) == 0) {
+ E1 = csvtabConnect(args);
+ }
+ else if (memcmp(E2->xConnect_signature, xConnect_signatures[xConnect_dbdataConnect_enum], sizeof(E2->xConnect_signature)) == 0) {
+ E1 = dbdataConnect(args);
+ }
+ else if (memcmp(E2->xConnect_signature, xConnect_signatures[xConnect_dbpageConnect_enum], sizeof(E2->xConnect_signature)) == 0) {
+ E1 = dbpageConnect(args);
+ }
+ else if (memcmp(E2->xConnect_signature, xConnect_signatures[xConnect_deltaparsevtabConnect_enum], sizeof(E2->xConnect_signature)) == 0) {
+ E1 = deltaparsevtabConnect(args);
+ }
+ else if (memcmp(E2->xConnect_signature, xConnect_signatures[xConnect_echoConnect_enum], sizeof(E2->xConnect_signature)) == 0) {
+ E1 = echoConnect(args);
+ }
+ else if (memcmp(E2->xConnect_signature, xConnect_signatures[xConnect_expertConnect_enum], sizeof(E2->xConnect_signature)) == 0) {
+ E1 = expertConnect(args);
+ }
+ else if (memcmp(E2->xConnect_signature, xConnect_signatures[xConnect_explainConnect_enum], sizeof(E2->xConnect_signature)) == 0) {
+ E1 = explainConnect(args);
+ }
+ else if (memcmp(E2->xConnect_signature, xConnect_signatures[xConnect_fsConnect_enum], sizeof(E2->xConnect_signature)) == 0) {
+ E1 = fsConnect(args);
+ }
+ else if (memcmp(E2->xConnect_signature, xConnect_signatures[xConnect_fsdirConnect_enum], sizeof(E2->xConnect_signature)) == 0) {
+ E1 = fsdirConnect(args);
+ }
+ else if (memcmp(E2->xConnect_signature, xConnect_signatures[xConnect_fstreeConnect_enum], sizeof(E2->xConnect_signature)) == 0) {
+ E1 = fstreeConnect(args);
+ }
+ else if (memcmp(E2->xConnect_signature, xConnect_signatures[xConnect_fts3ConnectMethod_enum], sizeof(E2->xConnect_signature)) == 0) {
+ E1 = fts3ConnectMethod(args);
+ }
+ else if (memcmp(E2->xConnect_signature, xConnect_signatures[xConnect_fts3auxConnectMethod_enum], sizeof(E2->xConnect_signature)) == 0) {
+ E1 = fts3auxConnectMethod(args);
+ }
+ else if (memcmp(E2->xConnect_signature, xConnect_signatures[xConnect_fts3termConnectMethod_enum], sizeof(E2->xConnect_signature)) == 0) {
+ E1 = fts3termConnectMethod(args);
+ }
+ else if (memcmp(E2->xConnect_signature, xConnect_signatures[xConnect_fts3tokConnectMethod_enum], sizeof(E2->xConnect_signature)) == 0) {
+ E1 = fts3tokConnectMethod(args);
+ }
+ else if (memcmp(E2->xConnect_signature, xConnect_signatures[xConnect_fuzzerConnect_enum], sizeof(E2->xConnect_signature)) == 0) {
+ E1 = fuzzerConnect(args);
+ }
+ else if (memcmp(E2->xConnect_signature, xConnect_signatures[xConnect_geopolyConnect_enum], sizeof(E2->xConnect_signature)) == 0) {
+ E1 = geopolyConnect(args);
+ }
+ else if (memcmp(E2->xConnect_signature, xConnect_signatures[xConnect_intarrayCreate_enum], sizeof(E2->xConnect_signature)) == 0) {
+ E1 = intarrayCreate(args);
+ }
+ else if (memcmp(E2->xConnect_signature, xConnect_signatures[xConnect_jsonEachConnect_enum], sizeof(E2->xConnect_signature)) == 0) {
+ E1 = jsonEachConnect(args);
+ }
+ else if (memcmp(E2->xConnect_signature, xConnect_signatures[xConnect_memstatConnect_enum], sizeof(E2->xConnect_signature)) == 0) {
+ E1 = memstatConnect(args);
+ }
+ else if (memcmp(E2->xConnect_signature, xConnect_signatures[xConnect_pragmaVtabConnect_enum], sizeof(E2->xConnect_signature)) == 0) {
+ E1 = pragmaVtabConnect(args);
+ }
+ else if (memcmp(E2->xConnect_signature, xConnect_signatures[xConnect_prefixesConnect_enum], sizeof(E2->xConnect_signature)) == 0) {
+ E1 = prefixesConnect(args);
+ }
+ else if (memcmp(E2->xConnect_signature, xConnect_signatures[xConnect_qpvtabConnect_enum], sizeof(E2->xConnect_signature)) == 0) {
+ E1 = qpvtabConnect(args);
+ }
+ else if (memcmp(E2->xConnect_signature, xConnect_signatures[xConnect_rtreeConnect_enum], sizeof(E2->xConnect_signature)) == 0) {
+ E1 = rtreeConnect(args);
+ }
+ else if (memcmp(E2->xConnect_signature, xConnect_signatures[xConnect_schemaCreate_enum], sizeof(E2->xConnect_signature)) == 0) {
+ E1 = schemaCreate(args);
+ }
+ else if (memcmp(E2->xConnect_signature, xConnect_signatures[xConnect_seriesConnect_enum], sizeof(E2->xConnect_signature)) == 0) {
+ E1 = seriesConnect(args);
+ }
+ else if (memcmp(E2->xConnect_signature, xConnect_signatures[xConnect_spellfix1Connect_enum], sizeof(E2->xConnect_signature)) == 0) {
+ E1 = spellfix1Connect(args);
+ }
+ else if (memcmp(E2->xConnect_signature, xConnect_signatures[xConnect_statConnect_enum], sizeof(E2->xConnect_signature)) == 0) {
+ E1 = statConnect(args);
+ }
+ else if (memcmp(E2->xConnect_signature, xConnect_signatures[xConnect_stmtConnect_enum], sizeof(E2->xConnect_signature)) == 0) {
+ E1 = stmtConnect(args);
+ }
+ else if (memcmp(E2->xConnect_signature, xConnect_signatures[xConnect_tclConnect_enum], sizeof(E2->xConnect_signature)) == 0) {
+ E1 = tclConnect(args);
+ }
+ else if (memcmp(E2->xConnect_signature, xConnect_signatures[xConnect_tclvarConnect_enum], sizeof(E2->xConnect_signature)) == 0) {
+ E1 = tclvarConnect(args);
+ }
+ else if (memcmp(E2->xConnect_signature, xConnect_signatures[xConnect_templatevtabConnect_enum], sizeof(E2->xConnect_signature)) == 0) {
+ E1 = templatevtabConnect(args);
+ }
+ else if (memcmp(E2->xConnect_signature, xConnect_signatures[xConnect_unionConnect_enum], sizeof(E2->xConnect_signature)) == 0) {
+ E1 = unionConnect(args);
+ }
+ else if (memcmp(E2->xConnect_signature, xConnect_signatures[xConnect_vlogConnect_enum], sizeof(E2->xConnect_signature)) == 0) {
+ E1 = vlogConnect(args);
+ }
+ else if (memcmp(E2->xConnect_signature, xConnect_signatures[xConnect_vstattabConnect_enum], sizeof(E2->xConnect_signature)) == 0) {
+ E1 = vstattabConnect(args);
+ }
+ else if (memcmp(E2->xConnect_signature, xConnect_signatures[xConnect_vtablogConnect_enum], sizeof(E2->xConnect_signature)) == 0) {
+ E1 = vtablogConnect(args);
+ }
+ else if (memcmp(E2->xConnect_signature, xConnect_signatures[xConnect_wholenumberConnect_enum], sizeof(E2->xConnect_signature)) == 0) {
+ E1 = wholenumberConnect(args);
+ }
+ else if (memcmp(E2->xConnect_signature, xConnect_signatures[xConnect_zipfileConnect_enum], sizeof(E2->xConnect_signature)) == 0) {
+ E1 = zipfileConnect(args);
+ }


// Transform E1 = E2->xCount(args) to if-chain with 3 candidates
@transform_assignment_xCount_arrow@
expression E1, E2;
identifier FP_NAME = xCount;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xCount_signature, xCount_signatures[xCount_sessionDiffCount_enum], sizeof(E2->xCount_signature)) == 0) {
+ E1 = sessionDiffCount(args);
+ }
+ else if (memcmp(E2->xCount_signature, xCount_signatures[xCount_sessionPreupdateCount_enum], sizeof(E2->xCount_signature)) == 0) {
+ E1 = sessionPreupdateCount(args);
+ }
+ else if (memcmp(E2->xCount_signature, xCount_signatures[xCount_sessionStat1Count_enum], sizeof(E2->xCount_signature)) == 0) {
+ E1 = sessionStat1Count(args);
+ }


// Transform E1 = E2->xCreate(args) to if-chain with 34 candidates
@transform_assignment_xCreate_arrow@
expression E1, E2;
identifier FP_NAME = xCreate;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xCreate_signature, xCreate_signatures[xCreate_0_enum], sizeof(E2->xCreate_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xCreate_signature, xCreate_signatures[xCreate_amatchConnect_enum], sizeof(E2->xCreate_signature)) == 0) {
+ E1 = amatchConnect(args);
+ }
+ else if (memcmp(E2->xCreate_signature, xCreate_signatures[xCreate_closureConnect_enum], sizeof(E2->xCreate_signature)) == 0) {
+ E1 = closureConnect(args);
+ }
+ else if (memcmp(E2->xCreate_signature, xCreate_signatures[xCreate_csvtabCreate_enum], sizeof(E2->xCreate_signature)) == 0) {
+ E1 = csvtabCreate(args);
+ }
+ else if (memcmp(E2->xCreate_signature, xCreate_signatures[xCreate_dbpageConnect_enum], sizeof(E2->xCreate_signature)) == 0) {
+ E1 = dbpageConnect(args);
+ }
+ else if (memcmp(E2->xCreate_signature, xCreate_signatures[xCreate_echoCreate_enum], sizeof(E2->xCreate_signature)) == 0) {
+ E1 = echoCreate(args);
+ }
+ else if (memcmp(E2->xCreate_signature, xCreate_signatures[xCreate_expertConnect_enum], sizeof(E2->xCreate_signature)) == 0) {
+ E1 = expertConnect(args);
+ }
+ else if (memcmp(E2->xCreate_signature, xCreate_signatures[xCreate_f5tOrigintextCreate_enum], sizeof(E2->xCreate_signature)) == 0) {
+ E1 = f5tOrigintextCreate(args);
+ }
+ else if (memcmp(E2->xCreate_signature, xCreate_signatures[xCreate_f5tTokenizerCreate_enum], sizeof(E2->xCreate_signature)) == 0) {
+ E1 = f5tTokenizerCreate(args);
+ }
+ else if (memcmp(E2->xCreate_signature, xCreate_signatures[xCreate_fsConnect_enum], sizeof(E2->xCreate_signature)) == 0) {
+ E1 = fsConnect(args);
+ }
+ else if (memcmp(E2->xCreate_signature, xCreate_signatures[xCreate_fsdirConnect_enum], sizeof(E2->xCreate_signature)) == 0) {
+ E1 = fsdirConnect(args);
+ }
+ else if (memcmp(E2->xCreate_signature, xCreate_signatures[xCreate_fstreeConnect_enum], sizeof(E2->xCreate_signature)) == 0) {
+ E1 = fstreeConnect(args);
+ }
+ else if (memcmp(E2->xCreate_signature, xCreate_signatures[xCreate_fts3CreateMethod_enum], sizeof(E2->xCreate_signature)) == 0) {
+ E1 = fts3CreateMethod(args);
+ }
+ else if (memcmp(E2->xCreate_signature, xCreate_signatures[xCreate_fts3auxConnectMethod_enum], sizeof(E2->xCreate_signature)) == 0) {
+ E1 = fts3auxConnectMethod(args);
+ }
+ else if (memcmp(E2->xCreate_signature, xCreate_signatures[xCreate_fts3termConnectMethod_enum], sizeof(E2->xCreate_signature)) == 0) {
+ E1 = fts3termConnectMethod(args);
+ }
+ else if (memcmp(E2->xCreate_signature, xCreate_signatures[xCreate_fts3tokConnectMethod_enum], sizeof(E2->xCreate_signature)) == 0) {
+ E1 = fts3tokConnectMethod(args);
+ }
+ else if (memcmp(E2->xCreate_signature, xCreate_signatures[xCreate_fuzzerConnect_enum], sizeof(E2->xCreate_signature)) == 0) {
+ E1 = fuzzerConnect(args);
+ }
+ else if (memcmp(E2->xCreate_signature, xCreate_signatures[xCreate_geopolyCreate_enum], sizeof(E2->xCreate_signature)) == 0) {
+ E1 = geopolyCreate(args);
+ }
+ else if (memcmp(E2->xCreate_signature, xCreate_signatures[xCreate_intarrayCreate_enum], sizeof(E2->xCreate_signature)) == 0) {
+ E1 = intarrayCreate(args);
+ }
+ else if (memcmp(E2->xCreate_signature, xCreate_signatures[xCreate_pcache1Create_enum], sizeof(E2->xCreate_signature)) == 0) {
+ E1 = pcache1Create(args);
+ }
+ else if (memcmp(E2->xCreate_signature, xCreate_signatures[xCreate_pcachetraceCreate_enum], sizeof(E2->xCreate_signature)) == 0) {
+ E1 = pcachetraceCreate(args);
+ }
+ else if (memcmp(E2->xCreate_signature, xCreate_signatures[xCreate_porterCreate_enum], sizeof(E2->xCreate_signature)) == 0) {
+ E1 = porterCreate(args);
+ }
+ else if (memcmp(E2->xCreate_signature, xCreate_signatures[xCreate_rtreeCreate_enum], sizeof(E2->xCreate_signature)) == 0) {
+ E1 = rtreeCreate(args);
+ }
+ else if (memcmp(E2->xCreate_signature, xCreate_signatures[xCreate_schemaCreate_enum], sizeof(E2->xCreate_signature)) == 0) {
+ E1 = schemaCreate(args);
+ }
+ else if (memcmp(E2->xCreate_signature, xCreate_signatures[xCreate_simpleCreate_enum], sizeof(E2->xCreate_signature)) == 0) {
+ E1 = simpleCreate(args);
+ }
+ else if (memcmp(E2->xCreate_signature, xCreate_signatures[xCreate_spellfix1Create_enum], sizeof(E2->xCreate_signature)) == 0) {
+ E1 = spellfix1Create(args);
+ }
+ else if (memcmp(E2->xCreate_signature, xCreate_signatures[xCreate_statConnect_enum], sizeof(E2->xCreate_signature)) == 0) {
+ E1 = statConnect(args);
+ }
+ else if (memcmp(E2->xCreate_signature, xCreate_signatures[xCreate_tclConnect_enum], sizeof(E2->xCreate_signature)) == 0) {
+ E1 = tclConnect(args);
+ }
+ else if (memcmp(E2->xCreate_signature, xCreate_signatures[xCreate_tclvarConnect_enum], sizeof(E2->xCreate_signature)) == 0) {
+ E1 = tclvarConnect(args);
+ }
+ else if (memcmp(E2->xCreate_signature, xCreate_signatures[xCreate_unicodeCreate_enum], sizeof(E2->xCreate_signature)) == 0) {
+ E1 = unicodeCreate(args);
+ }
+ else if (memcmp(E2->xCreate_signature, xCreate_signatures[xCreate_unionConnect_enum], sizeof(E2->xCreate_signature)) == 0) {
+ E1 = unionConnect(args);
+ }
+ else if (memcmp(E2->xCreate_signature, xCreate_signatures[xCreate_vlogConnect_enum], sizeof(E2->xCreate_signature)) == 0) {
+ E1 = vlogConnect(args);
+ }
+ else if (memcmp(E2->xCreate_signature, xCreate_signatures[xCreate_vtablogCreate_enum], sizeof(E2->xCreate_signature)) == 0) {
+ E1 = vtablogCreate(args);
+ }
+ else if (memcmp(E2->xCreate_signature, xCreate_signatures[xCreate_wholenumberConnect_enum], sizeof(E2->xCreate_signature)) == 0) {
+ E1 = wholenumberConnect(args);
+ }
+ else if (memcmp(E2->xCreate_signature, xCreate_signatures[xCreate_zipfileConnect_enum], sizeof(E2->xCreate_signature)) == 0) {
+ E1 = zipfileConnect(args);
+ }


// Transform E1 = E2->xCurrentTime(args) to if-chain with 3 candidates
@transform_assignment_xCurrentTime_arrow@
expression E1, E2;
identifier FP_NAME = xCurrentTime;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xCurrentTime_signature, xCurrentTime_signatures[xCurrentTime_0_enum], sizeof(E2->xCurrentTime_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xCurrentTime_signature, xCurrentTime_signatures[xCurrentTime_apndCurrentTime_enum], sizeof(E2->xCurrentTime_signature)) == 0) {
+ E1 = apndCurrentTime(args);
+ }
+ else if (memcmp(E2->xCurrentTime_signature, xCurrentTime_signatures[xCurrentTime_vfstraceCurrentTime_enum], sizeof(E2->xCurrentTime_signature)) == 0) {
+ E1 = vfstraceCurrentTime(args);
+ }
+ else if (memcmp(E2->xCurrentTime_signature, xCurrentTime_signatures[xCurrentTime_unixCurrentTime_enum], sizeof(E2->xCurrentTime_signature)) == 0) {
+ E1 = unixCurrentTime(args);
+ }


// Transform E1 = E2->xCurrentTimeInt64(args) to if-chain with 3 candidates
@transform_assignment_xCurrentTimeInt64_arrow@
expression E1, E2;
identifier FP_NAME = xCurrentTimeInt64;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xCurrentTimeInt64_signature, xCurrentTimeInt64_signatures[xCurrentTimeInt64_0_enum], sizeof(E2->xCurrentTimeInt64_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xCurrentTimeInt64_signature, xCurrentTimeInt64_signatures[xCurrentTimeInt64_apndCurrentTimeInt64_enum], sizeof(E2->xCurrentTimeInt64_signature)) == 0) {
+ E1 = apndCurrentTimeInt64(args);
+ }
+ else if (memcmp(E2->xCurrentTimeInt64_signature, xCurrentTimeInt64_signatures[xCurrentTimeInt64_memdbCurrentTimeInt64_enum], sizeof(E2->xCurrentTimeInt64_signature)) == 0) {
+ E1 = memdbCurrentTimeInt64(args);
+ }
+ else if (memcmp(E2->xCurrentTimeInt64_signature, xCurrentTimeInt64_signatures[xCurrentTimeInt64_unixCurrentTimeInt64_enum], sizeof(E2->xCurrentTimeInt64_signature)) == 0) {
+ E1 = unixCurrentTimeInt64(args);
+ }


// Transform E1 = E2->xDel(args) to if-chain with 3 candidates
@transform_assignment_xDel_arrow@
expression E1, E2;
identifier FP_NAME = xDel;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xDel_signature, xDel_signatures[xDel_0_enum], sizeof(E2->xDel_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xDel_signature, xDel_signatures[xDel_sqlite3RowSetDelete_enum], sizeof(E2->xDel_signature)) == 0) {
+ E1 = sqlite3RowSetDelete(args);
+ }
+ else if (memcmp(E2->xDel_signature, xDel_signatures[xDel_sqlite3VdbeFrameMemDel_enum], sizeof(E2->xDel_signature)) == 0) {
+ E1 = sqlite3VdbeFrameMemDel(args);
+ }
+ else if (memcmp(E2->xDel_signature, xDel_signatures[xDel_sqlite3_free_enum], sizeof(E2->xDel_signature)) == 0) {
+ E1 = sqlite3_free(args);
+ }


// Transform E1 = E2->xDelete(args) to if-chain with 6 candidates
@transform_assignment_xDelete_arrow@
expression E1, E2;
identifier FP_NAME = xDelete;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xDelete_signature, xDelete_signatures[xDelete_0_enum], sizeof(E2->xDelete_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xDelete_signature, xDelete_signatures[xDelete_apndDelete_enum], sizeof(E2->xDelete_signature)) == 0) {
+ E1 = apndDelete(args);
+ }
+ else if (memcmp(E2->xDelete_signature, xDelete_signatures[xDelete_f5tOrigintextDelete_enum], sizeof(E2->xDelete_signature)) == 0) {
+ E1 = f5tOrigintextDelete(args);
+ }
+ else if (memcmp(E2->xDelete_signature, xDelete_signatures[xDelete_f5tTokenizerDelete_enum], sizeof(E2->xDelete_signature)) == 0) {
+ E1 = f5tTokenizerDelete(args);
+ }
+ else if (memcmp(E2->xDelete_signature, xDelete_signatures[xDelete_kvstorageDelete_enum], sizeof(E2->xDelete_signature)) == 0) {
+ E1 = kvstorageDelete(args);
+ }
+ else if (memcmp(E2->xDelete_signature, xDelete_signatures[xDelete_vfstraceDelete_enum], sizeof(E2->xDelete_signature)) == 0) {
+ E1 = vfstraceDelete(args);
+ }
+ else if (memcmp(E2->xDelete_signature, xDelete_signatures[xDelete_unixDelete_enum], sizeof(E2->xDelete_signature)) == 0) {
+ E1 = unixDelete(args);
+ }


// Transform E1 = E2->xDepth(args) to if-chain with 3 candidates
@transform_assignment_xDepth_arrow@
expression E1, E2;
identifier FP_NAME = xDepth;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xDepth_signature, xDepth_signatures[xDepth_sessionDiffDepth_enum], sizeof(E2->xDepth_signature)) == 0) {
+ E1 = sessionDiffDepth(args);
+ }
+ else if (memcmp(E2->xDepth_signature, xDepth_signatures[xDepth_sessionPreupdateDepth_enum], sizeof(E2->xDepth_signature)) == 0) {
+ E1 = sessionPreupdateDepth(args);
+ }
+ else if (memcmp(E2->xDepth_signature, xDepth_signatures[xDepth_sessionStat1Depth_enum], sizeof(E2->xDepth_signature)) == 0) {
+ E1 = sessionStat1Depth(args);
+ }


// Transform E1 = E2->xDestroy(args) to if-chain with 14 candidates
@transform_assignment_xDestroy_arrow@
expression E1, E2;
identifier FP_NAME = xDestroy;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xDestroy_signature, xDestroy_signatures[xDestroy_0_enum], sizeof(E2->xDestroy_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xDestroy_signature, xDestroy_signatures[xDestroy_dbpageDisconnect_enum], sizeof(E2->xDestroy_signature)) == 0) {
+ E1 = dbpageDisconnect(args);
+ }
+ else if (memcmp(E2->xDestroy_signature, xDestroy_signatures[xDestroy_expertDisconnect_enum], sizeof(E2->xDestroy_signature)) == 0) {
+ E1 = expertDisconnect(args);
+ }
+ else if (memcmp(E2->xDestroy_signature, xDestroy_signatures[xDestroy_fsdirDisconnect_enum], sizeof(E2->xDestroy_signature)) == 0) {
+ E1 = fsdirDisconnect(args);
+ }
+ else if (memcmp(E2->xDestroy_signature, xDestroy_signatures[xDestroy_fts3DestroyMethod_enum], sizeof(E2->xDestroy_signature)) == 0) {
+ E1 = fts3DestroyMethod(args);
+ }
+ else if (memcmp(E2->xDestroy_signature, xDestroy_signatures[xDestroy_fts3auxDisconnectMethod_enum], sizeof(E2->xDestroy_signature)) == 0) {
+ E1 = fts3auxDisconnectMethod(args);
+ }
+ else if (memcmp(E2->xDestroy_signature, xDestroy_signatures[xDestroy_fts3tokDisconnectMethod_enum], sizeof(E2->xDestroy_signature)) == 0) {
+ E1 = fts3tokDisconnectMethod(args);
+ }
+ else if (memcmp(E2->xDestroy_signature, xDestroy_signatures[xDestroy_pcache1Destroy_enum], sizeof(E2->xDestroy_signature)) == 0) {
+ E1 = pcache1Destroy(args);
+ }
+ else if (memcmp(E2->xDestroy_signature, xDestroy_signatures[xDestroy_pcachetraceDestroy_enum], sizeof(E2->xDestroy_signature)) == 0) {
+ E1 = pcachetraceDestroy(args);
+ }
+ else if (memcmp(E2->xDestroy_signature, xDestroy_signatures[xDestroy_porterDestroy_enum], sizeof(E2->xDestroy_signature)) == 0) {
+ E1 = porterDestroy(args);
+ }
+ else if (memcmp(E2->xDestroy_signature, xDestroy_signatures[xDestroy_rtreeDestroy_enum], sizeof(E2->xDestroy_signature)) == 0) {
+ E1 = rtreeDestroy(args);
+ }
+ else if (memcmp(E2->xDestroy_signature, xDestroy_signatures[xDestroy_simpleDestroy_enum], sizeof(E2->xDestroy_signature)) == 0) {
+ E1 = simpleDestroy(args);
+ }
+ else if (memcmp(E2->xDestroy_signature, xDestroy_signatures[xDestroy_statDisconnect_enum], sizeof(E2->xDestroy_signature)) == 0) {
+ E1 = statDisconnect(args);
+ }
+ else if (memcmp(E2->xDestroy_signature, xDestroy_signatures[xDestroy_unicodeDestroy_enum], sizeof(E2->xDestroy_signature)) == 0) {
+ E1 = unicodeDestroy(args);
+ }
+ else if (memcmp(E2->xDestroy_signature, xDestroy_signatures[xDestroy_zipfileDisconnect_enum], sizeof(E2->xDestroy_signature)) == 0) {
+ E1 = zipfileDisconnect(args);
+ }


// Transform E1 = E2->xDeviceCharacteristics(args) to if-chain with 5 candidates
@transform_assignment_xDeviceCharacteristics_arrow@
expression E1, E2;
identifier FP_NAME = xDeviceCharacteristics;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xDeviceCharacteristics_signature, xDeviceCharacteristics_signatures[xDeviceCharacteristics_0_enum], sizeof(E2->xDeviceCharacteristics_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xDeviceCharacteristics_signature, xDeviceCharacteristics_signatures[xDeviceCharacteristics_apndDeviceCharacteristics_enum], sizeof(E2->xDeviceCharacteristics_signature)) == 0) {
+ E1 = apndDeviceCharacteristics(args);
+ }
+ else if (memcmp(E2->xDeviceCharacteristics_signature, xDeviceCharacteristics_signatures[xDeviceCharacteristics_memdbDeviceCharacteristics_enum], sizeof(E2->xDeviceCharacteristics_signature)) == 0) {
+ E1 = memdbDeviceCharacteristics(args);
+ }
+ else if (memcmp(E2->xDeviceCharacteristics_signature, xDeviceCharacteristics_signatures[xDeviceCharacteristics_recoverVfsDeviceCharacteristics_enum], sizeof(E2->xDeviceCharacteristics_signature)) == 0) {
+ E1 = recoverVfsDeviceCharacteristics(args);
+ }
+ else if (memcmp(E2->xDeviceCharacteristics_signature, xDeviceCharacteristics_signatures[xDeviceCharacteristics_vfstraceDeviceCharacteristics_enum], sizeof(E2->xDeviceCharacteristics_signature)) == 0) {
+ E1 = vfstraceDeviceCharacteristics(args);
+ }
+ else if (memcmp(E2->xDeviceCharacteristics_signature, xDeviceCharacteristics_signatures[xDeviceCharacteristics_unixDeviceCharacteristics_enum], sizeof(E2->xDeviceCharacteristics_signature)) == 0) {
+ E1 = unixDeviceCharacteristics(args);
+ }


// Transform E1 = E2->xDisconnect(args) to if-chain with 16 candidates
@transform_assignment_xDisconnect_arrow@
expression E1, E2;
identifier FP_NAME = xDisconnect;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xDisconnect_signature, xDisconnect_signatures[xDisconnect_bytecodevtabDisconnect_enum], sizeof(E2->xDisconnect_signature)) == 0) {
+ E1 = bytecodevtabDisconnect(args);
+ }
+ else if (memcmp(E2->xDisconnect_signature, xDisconnect_signatures[xDisconnect_completionDisconnect_enum], sizeof(E2->xDisconnect_signature)) == 0) {
+ E1 = completionDisconnect(args);
+ }
+ else if (memcmp(E2->xDisconnect_signature, xDisconnect_signatures[xDisconnect_dbdataDisconnect_enum], sizeof(E2->xDisconnect_signature)) == 0) {
+ E1 = dbdataDisconnect(args);
+ }
+ else if (memcmp(E2->xDisconnect_signature, xDisconnect_signatures[xDisconnect_dbpageDisconnect_enum], sizeof(E2->xDisconnect_signature)) == 0) {
+ E1 = dbpageDisconnect(args);
+ }
+ else if (memcmp(E2->xDisconnect_signature, xDisconnect_signatures[xDisconnect_expertDisconnect_enum], sizeof(E2->xDisconnect_signature)) == 0) {
+ E1 = expertDisconnect(args);
+ }
+ else if (memcmp(E2->xDisconnect_signature, xDisconnect_signatures[xDisconnect_fsdirDisconnect_enum], sizeof(E2->xDisconnect_signature)) == 0) {
+ E1 = fsdirDisconnect(args);
+ }
+ else if (memcmp(E2->xDisconnect_signature, xDisconnect_signatures[xDisconnect_fts3DisconnectMethod_enum], sizeof(E2->xDisconnect_signature)) == 0) {
+ E1 = fts3DisconnectMethod(args);
+ }
+ else if (memcmp(E2->xDisconnect_signature, xDisconnect_signatures[xDisconnect_fts3auxDisconnectMethod_enum], sizeof(E2->xDisconnect_signature)) == 0) {
+ E1 = fts3auxDisconnectMethod(args);
+ }
+ else if (memcmp(E2->xDisconnect_signature, xDisconnect_signatures[xDisconnect_fts3tokDisconnectMethod_enum], sizeof(E2->xDisconnect_signature)) == 0) {
+ E1 = fts3tokDisconnectMethod(args);
+ }
+ else if (memcmp(E2->xDisconnect_signature, xDisconnect_signatures[xDisconnect_jsonEachDisconnect_enum], sizeof(E2->xDisconnect_signature)) == 0) {
+ E1 = jsonEachDisconnect(args);
+ }
+ else if (memcmp(E2->xDisconnect_signature, xDisconnect_signatures[xDisconnect_pragmaVtabDisconnect_enum], sizeof(E2->xDisconnect_signature)) == 0) {
+ E1 = pragmaVtabDisconnect(args);
+ }
+ else if (memcmp(E2->xDisconnect_signature, xDisconnect_signatures[xDisconnect_rtreeDisconnect_enum], sizeof(E2->xDisconnect_signature)) == 0) {
+ E1 = rtreeDisconnect(args);
+ }
+ else if (memcmp(E2->xDisconnect_signature, xDisconnect_signatures[xDisconnect_seriesDisconnect_enum], sizeof(E2->xDisconnect_signature)) == 0) {
+ E1 = seriesDisconnect(args);
+ }
+ else if (memcmp(E2->xDisconnect_signature, xDisconnect_signatures[xDisconnect_statDisconnect_enum], sizeof(E2->xDisconnect_signature)) == 0) {
+ E1 = statDisconnect(args);
+ }
+ else if (memcmp(E2->xDisconnect_signature, xDisconnect_signatures[xDisconnect_stmtDisconnect_enum], sizeof(E2->xDisconnect_signature)) == 0) {
+ E1 = stmtDisconnect(args);
+ }
+ else if (memcmp(E2->xDisconnect_signature, xDisconnect_signatures[xDisconnect_zipfileDisconnect_enum], sizeof(E2->xDisconnect_signature)) == 0) {
+ E1 = zipfileDisconnect(args);
+ }


// Transform E1 = E2->xDlClose(args) to if-chain with 3 candidates
@transform_assignment_xDlClose_arrow@
expression E1, E2;
identifier FP_NAME = xDlClose;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xDlClose_signature, xDlClose_signatures[xDlClose_0_enum], sizeof(E2->xDlClose_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xDlClose_signature, xDlClose_signatures[xDlClose_apndDlClose_enum], sizeof(E2->xDlClose_signature)) == 0) {
+ E1 = apndDlClose(args);
+ }
+ else if (memcmp(E2->xDlClose_signature, xDlClose_signatures[xDlClose_memdbDlClose_enum], sizeof(E2->xDlClose_signature)) == 0) {
+ E1 = memdbDlClose(args);
+ }
+ else if (memcmp(E2->xDlClose_signature, xDlClose_signatures[xDlClose_unixDlClose_enum], sizeof(E2->xDlClose_signature)) == 0) {
+ E1 = unixDlClose(args);
+ }


// Transform E1 = E2->xDlError(args) to if-chain with 3 candidates
@transform_assignment_xDlError_arrow@
expression E1, E2;
identifier FP_NAME = xDlError;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xDlError_signature, xDlError_signatures[xDlError_0_enum], sizeof(E2->xDlError_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xDlError_signature, xDlError_signatures[xDlError_apndDlError_enum], sizeof(E2->xDlError_signature)) == 0) {
+ E1 = apndDlError(args);
+ }
+ else if (memcmp(E2->xDlError_signature, xDlError_signatures[xDlError_memdbDlError_enum], sizeof(E2->xDlError_signature)) == 0) {
+ E1 = memdbDlError(args);
+ }
+ else if (memcmp(E2->xDlError_signature, xDlError_signatures[xDlError_unixDlError_enum], sizeof(E2->xDlError_signature)) == 0) {
+ E1 = unixDlError(args);
+ }


// Transform E1 = E2->xDlOpen(args) to if-chain with 3 candidates
@transform_assignment_xDlOpen_arrow@
expression E1, E2;
identifier FP_NAME = xDlOpen;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xDlOpen_signature, xDlOpen_signatures[xDlOpen_apndDlOpen_enum], sizeof(E2->xDlOpen_signature)) == 0) {
+ E1 = apndDlOpen(args);
+ }
+ else if (memcmp(E2->xDlOpen_signature, xDlOpen_signatures[xDlOpen_memdbDlOpen_enum], sizeof(E2->xDlOpen_signature)) == 0) {
+ E1 = memdbDlOpen(args);
+ }
+ else if (memcmp(E2->xDlOpen_signature, xDlOpen_signatures[xDlOpen_unixDlOpen_enum], sizeof(E2->xDlOpen_signature)) == 0) {
+ E1 = unixDlOpen(args);
+ }


// Transform E1 = E2->xEof(args) to if-chain with 43 candidates
@transform_assignment_xEof_arrow@
expression E1, E2;
identifier FP_NAME = xEof;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xEof_signature, xEof_signatures[xEof_amatchEof_enum], sizeof(E2->xEof_signature)) == 0) {
+ E1 = amatchEof(args);
+ }
+ else if (memcmp(E2->xEof_signature, xEof_signatures[xEof_binfoEof_enum], sizeof(E2->xEof_signature)) == 0) {
+ E1 = binfoEof(args);
+ }
+ else if (memcmp(E2->xEof_signature, xEof_signatures[xEof_bytecodevtabEof_enum], sizeof(E2->xEof_signature)) == 0) {
+ E1 = bytecodevtabEof(args);
+ }
+ else if (memcmp(E2->xEof_signature, xEof_signatures[xEof_carrayEof_enum], sizeof(E2->xEof_signature)) == 0) {
+ E1 = carrayEof(args);
+ }
+ else if (memcmp(E2->xEof_signature, xEof_signatures[xEof_cidxEof_enum], sizeof(E2->xEof_signature)) == 0) {
+ E1 = cidxEof(args);
+ }
+ else if (memcmp(E2->xEof_signature, xEof_signatures[xEof_closureEof_enum], sizeof(E2->xEof_signature)) == 0) {
+ E1 = closureEof(args);
+ }
+ else if (memcmp(E2->xEof_signature, xEof_signatures[xEof_completionEof_enum], sizeof(E2->xEof_signature)) == 0) {
+ E1 = completionEof(args);
+ }
+ else if (memcmp(E2->xEof_signature, xEof_signatures[xEof_csvtabEof_enum], sizeof(E2->xEof_signature)) == 0) {
+ E1 = csvtabEof(args);
+ }
+ else if (memcmp(E2->xEof_signature, xEof_signatures[xEof_dbdataEof_enum], sizeof(E2->xEof_signature)) == 0) {
+ E1 = dbdataEof(args);
+ }
+ else if (memcmp(E2->xEof_signature, xEof_signatures[xEof_dbpageEof_enum], sizeof(E2->xEof_signature)) == 0) {
+ E1 = dbpageEof(args);
+ }
+ else if (memcmp(E2->xEof_signature, xEof_signatures[xEof_deltaparsevtabEof_enum], sizeof(E2->xEof_signature)) == 0) {
+ E1 = deltaparsevtabEof(args);
+ }
+ else if (memcmp(E2->xEof_signature, xEof_signatures[xEof_echoEof_enum], sizeof(E2->xEof_signature)) == 0) {
+ E1 = echoEof(args);
+ }
+ else if (memcmp(E2->xEof_signature, xEof_signatures[xEof_expertEof_enum], sizeof(E2->xEof_signature)) == 0) {
+ E1 = expertEof(args);
+ }
+ else if (memcmp(E2->xEof_signature, xEof_signatures[xEof_explainEof_enum], sizeof(E2->xEof_signature)) == 0) {
+ E1 = explainEof(args);
+ }
+ else if (memcmp(E2->xEof_signature, xEof_signatures[xEof_fsEof_enum], sizeof(E2->xEof_signature)) == 0) {
+ E1 = fsEof(args);
+ }
+ else if (memcmp(E2->xEof_signature, xEof_signatures[xEof_fsdirEof_enum], sizeof(E2->xEof_signature)) == 0) {
+ E1 = fsdirEof(args);
+ }
+ else if (memcmp(E2->xEof_signature, xEof_signatures[xEof_fstreeEof_enum], sizeof(E2->xEof_signature)) == 0) {
+ E1 = fstreeEof(args);
+ }
+ else if (memcmp(E2->xEof_signature, xEof_signatures[xEof_fts3EofMethod_enum], sizeof(E2->xEof_signature)) == 0) {
+ E1 = fts3EofMethod(args);
+ }
+ else if (memcmp(E2->xEof_signature, xEof_signatures[xEof_fts3auxEofMethod_enum], sizeof(E2->xEof_signature)) == 0) {
+ E1 = fts3auxEofMethod(args);
+ }
+ else if (memcmp(E2->xEof_signature, xEof_signatures[xEof_fts3termEofMethod_enum], sizeof(E2->xEof_signature)) == 0) {
+ E1 = fts3termEofMethod(args);
+ }
+ else if (memcmp(E2->xEof_signature, xEof_signatures[xEof_fts3tokEofMethod_enum], sizeof(E2->xEof_signature)) == 0) {
+ E1 = fts3tokEofMethod(args);
+ }
+ else if (memcmp(E2->xEof_signature, xEof_signatures[xEof_fuzzerEof_enum], sizeof(E2->xEof_signature)) == 0) {
+ E1 = fuzzerEof(args);
+ }
+ else if (memcmp(E2->xEof_signature, xEof_signatures[xEof_intarrayEof_enum], sizeof(E2->xEof_signature)) == 0) {
+ E1 = intarrayEof(args);
+ }
+ else if (memcmp(E2->xEof_signature, xEof_signatures[xEof_jsonEachEof_enum], sizeof(E2->xEof_signature)) == 0) {
+ E1 = jsonEachEof(args);
+ }
+ else if (memcmp(E2->xEof_signature, xEof_signatures[xEof_memstatEof_enum], sizeof(E2->xEof_signature)) == 0) {
+ E1 = memstatEof(args);
+ }
+ else if (memcmp(E2->xEof_signature, xEof_signatures[xEof_pragmaVtabEof_enum], sizeof(E2->xEof_signature)) == 0) {
+ E1 = pragmaVtabEof(args);
+ }
+ else if (memcmp(E2->xEof_signature, xEof_signatures[xEof_prefixesEof_enum], sizeof(E2->xEof_signature)) == 0) {
+ E1 = prefixesEof(args);
+ }
+ else if (memcmp(E2->xEof_signature, xEof_signatures[xEof_qpvtabEof_enum], sizeof(E2->xEof_signature)) == 0) {
+ E1 = qpvtabEof(args);
+ }
+ else if (memcmp(E2->xEof_signature, xEof_signatures[xEof_rtreeEof_enum], sizeof(E2->xEof_signature)) == 0) {
+ E1 = rtreeEof(args);
+ }
+ else if (memcmp(E2->xEof_signature, xEof_signatures[xEof_schemaEof_enum], sizeof(E2->xEof_signature)) == 0) {
+ E1 = schemaEof(args);
+ }
+ else if (memcmp(E2->xEof_signature, xEof_signatures[xEof_seriesEof_enum], sizeof(E2->xEof_signature)) == 0) {
+ E1 = seriesEof(args);
+ }
+ else if (memcmp(E2->xEof_signature, xEof_signatures[xEof_spellfix1Eof_enum], sizeof(E2->xEof_signature)) == 0) {
+ E1 = spellfix1Eof(args);
+ }
+ else if (memcmp(E2->xEof_signature, xEof_signatures[xEof_statEof_enum], sizeof(E2->xEof_signature)) == 0) {
+ E1 = statEof(args);
+ }
+ else if (memcmp(E2->xEof_signature, xEof_signatures[xEof_stmtEof_enum], sizeof(E2->xEof_signature)) == 0) {
+ E1 = stmtEof(args);
+ }
+ else if (memcmp(E2->xEof_signature, xEof_signatures[xEof_tclEof_enum], sizeof(E2->xEof_signature)) == 0) {
+ E1 = tclEof(args);
+ }
+ else if (memcmp(E2->xEof_signature, xEof_signatures[xEof_tclvarEof_enum], sizeof(E2->xEof_signature)) == 0) {
+ E1 = tclvarEof(args);
+ }
+ else if (memcmp(E2->xEof_signature, xEof_signatures[xEof_templatevtabEof_enum], sizeof(E2->xEof_signature)) == 0) {
+ E1 = templatevtabEof(args);
+ }
+ else if (memcmp(E2->xEof_signature, xEof_signatures[xEof_unionEof_enum], sizeof(E2->xEof_signature)) == 0) {
+ E1 = unionEof(args);
+ }
+ else if (memcmp(E2->xEof_signature, xEof_signatures[xEof_vlogEof_enum], sizeof(E2->xEof_signature)) == 0) {
+ E1 = vlogEof(args);
+ }
+ else if (memcmp(E2->xEof_signature, xEof_signatures[xEof_vstattabEof_enum], sizeof(E2->xEof_signature)) == 0) {
+ E1 = vstattabEof(args);
+ }
+ else if (memcmp(E2->xEof_signature, xEof_signatures[xEof_vtablogEof_enum], sizeof(E2->xEof_signature)) == 0) {
+ E1 = vtablogEof(args);
+ }
+ else if (memcmp(E2->xEof_signature, xEof_signatures[xEof_wholenumberEof_enum], sizeof(E2->xEof_signature)) == 0) {
+ E1 = wholenumberEof(args);
+ }
+ else if (memcmp(E2->xEof_signature, xEof_signatures[xEof_zipfileEof_enum], sizeof(E2->xEof_signature)) == 0) {
+ E1 = zipfileEof(args);
+ }


// Transform E1 = E2->xExprCallback(args) to if-chain with 37 candidates
@transform_assignment_xExprCallback_arrow@
expression E1, E2;
identifier FP_NAME = xExprCallback;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_agginfoPersistExprCb_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = agginfoPersistExprCb(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_aggregateIdxEprRefToColCallback_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = aggregateIdxEprRefToColCallback(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_analyzeAggregate_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = analyzeAggregate(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_checkConstraintExprNode_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = checkConstraintExprNode(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_codeCursorHintCheckExpr_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = codeCursorHintCheckExpr(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_codeCursorHintFixExpr_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = codeCursorHintFixExpr(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_codeCursorHintIsOrFunction_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = codeCursorHintIsOrFunction(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_disallowAggregatesInOrderByCb_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = disallowAggregatesInOrderByCb(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprColumnFlagUnion_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = exprColumnFlagUnion(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprIdxCover_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = exprIdxCover(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprNodeCanReturnSubtype_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = exprNodeCanReturnSubtype(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprNodeIsConstant_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = exprNodeIsConstant(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprNodeIsConstantOrGroupBy_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = exprNodeIsConstantOrGroupBy(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprNodeIsDeterministic_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = exprNodeIsDeterministic(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprRefToSrcList_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = exprRefToSrcList(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_fixExprCb_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = fixExprCb(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_gatherSelectWindowsCallback_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = gatherSelectWindowsCallback(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_havingToWhereExprCb_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = havingToWhereExprCb(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_impliesNotNullRow_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = impliesNotNullRow(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_incrAggDepth_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = incrAggDepth(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_markImmutableExprStep_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = markImmutableExprStep(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_propagateConstantExprRewrite_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = propagateConstantExprRewrite(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_recomputeColumnsUsedExpr_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = recomputeColumnsUsedExpr(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_renameColumnExprCb_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = renameColumnExprCb(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_renameQuotefixExprCb_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = renameQuotefixExprCb(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_renameTableExprCb_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = renameTableExprCb(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_renameUnmapExprCb_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = renameUnmapExprCb(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_renumberCursorsCb_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = renumberCursorsCb(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_resolveExprStep_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = resolveExprStep(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_resolveRemoveWindowsCb_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = resolveRemoveWindowsCb(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_selectCheckOnClausesExpr_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = selectCheckOnClausesExpr(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_selectWindowRewriteExprCb_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = selectWindowRewriteExprCb(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_sqlite3CursorRangeHintExprCheck_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = sqlite3CursorRangeHintExprCheck(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_sqlite3ExprWalkNoop_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = sqlite3ExprWalkNoop(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_sqlite3ReturningSubqueryVarSelect_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = sqlite3ReturningSubqueryVarSelect(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_sqlite3WindowExtraAggFuncDepth_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = sqlite3WindowExtraAggFuncDepth(args);
+ }
+ else if (memcmp(E2->xExprCallback_signature, xExprCallback_signatures[xExprCallback_whereIsCoveringIndexWalkCallback_enum], sizeof(E2->xExprCallback_signature)) == 0) {
+ E1 = whereIsCoveringIndexWalkCallback(args);
+ }


// Transform E1 = E2->xFetch(args) to if-chain with 6 candidates
@transform_assignment_xFetch_arrow@
expression E1, E2;
identifier FP_NAME = xFetch;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xFetch_signature, xFetch_signatures[xFetch_0_enum], sizeof(E2->xFetch_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xFetch_signature, xFetch_signatures[xFetch_apndFetch_enum], sizeof(E2->xFetch_signature)) == 0) {
+ E1 = apndFetch(args);
+ }
+ else if (memcmp(E2->xFetch_signature, xFetch_signatures[xFetch_memdbFetch_enum], sizeof(E2->xFetch_signature)) == 0) {
+ E1 = memdbFetch(args);
+ }
+ else if (memcmp(E2->xFetch_signature, xFetch_signatures[xFetch_pcache1Fetch_enum], sizeof(E2->xFetch_signature)) == 0) {
+ E1 = pcache1Fetch(args);
+ }
+ else if (memcmp(E2->xFetch_signature, xFetch_signatures[xFetch_pcachetraceFetch_enum], sizeof(E2->xFetch_signature)) == 0) {
+ E1 = pcachetraceFetch(args);
+ }
+ else if (memcmp(E2->xFetch_signature, xFetch_signatures[xFetch_recoverVfsFetch_enum], sizeof(E2->xFetch_signature)) == 0) {
+ E1 = recoverVfsFetch(args);
+ }
+ else if (memcmp(E2->xFetch_signature, xFetch_signatures[xFetch_unixFetch_enum], sizeof(E2->xFetch_signature)) == 0) {
+ E1 = unixFetch(args);
+ }


// Transform E1 = E2->xFileControl(args) to if-chain with 5 candidates
@transform_assignment_xFileControl_arrow@
expression E1, E2;
identifier FP_NAME = xFileControl;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xFileControl_signature, xFileControl_signatures[xFileControl_0_enum], sizeof(E2->xFileControl_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xFileControl_signature, xFileControl_signatures[xFileControl_apndFileControl_enum], sizeof(E2->xFileControl_signature)) == 0) {
+ E1 = apndFileControl(args);
+ }
+ else if (memcmp(E2->xFileControl_signature, xFileControl_signatures[xFileControl_memdbFileControl_enum], sizeof(E2->xFileControl_signature)) == 0) {
+ E1 = memdbFileControl(args);
+ }
+ else if (memcmp(E2->xFileControl_signature, xFileControl_signatures[xFileControl_recoverVfsFileControl_enum], sizeof(E2->xFileControl_signature)) == 0) {
+ E1 = recoverVfsFileControl(args);
+ }
+ else if (memcmp(E2->xFileControl_signature, xFileControl_signatures[xFileControl_vfstraceFileControl_enum], sizeof(E2->xFileControl_signature)) == 0) {
+ E1 = vfstraceFileControl(args);
+ }
+ else if (memcmp(E2->xFileControl_signature, xFileControl_signatures[xFileControl_unixFileControl_enum], sizeof(E2->xFileControl_signature)) == 0) {
+ E1 = unixFileControl(args);
+ }


// Transform E1 = E2->xFileSize(args) to if-chain with 6 candidates
@transform_assignment_xFileSize_arrow@
expression E1, E2;
identifier FP_NAME = xFileSize;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xFileSize_signature, xFileSize_signatures[xFileSize_apndFileSize_enum], sizeof(E2->xFileSize_signature)) == 0) {
+ E1 = apndFileSize(args);
+ }
+ else if (memcmp(E2->xFileSize_signature, xFileSize_signatures[xFileSize_memdbFileSize_enum], sizeof(E2->xFileSize_signature)) == 0) {
+ E1 = memdbFileSize(args);
+ }
+ else if (memcmp(E2->xFileSize_signature, xFileSize_signatures[xFileSize_memjrnlFileSize_enum], sizeof(E2->xFileSize_signature)) == 0) {
+ E1 = memjrnlFileSize(args);
+ }
+ else if (memcmp(E2->xFileSize_signature, xFileSize_signatures[xFileSize_recoverVfsFileSize_enum], sizeof(E2->xFileSize_signature)) == 0) {
+ E1 = recoverVfsFileSize(args);
+ }
+ else if (memcmp(E2->xFileSize_signature, xFileSize_signatures[xFileSize_vfstraceFileSize_enum], sizeof(E2->xFileSize_signature)) == 0) {
+ E1 = vfstraceFileSize(args);
+ }
+ else if (memcmp(E2->xFileSize_signature, xFileSize_signatures[xFileSize_unixFileSize_enum], sizeof(E2->xFileSize_signature)) == 0) {
+ E1 = unixFileSize(args);
+ }


// Transform E1 = E2->xFilter(args) to if-chain with 44 candidates
@transform_assignment_xFilter_arrow@
expression E1, E2;
identifier FP_NAME = xFilter;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xFilter_signature, xFilter_signatures[xFilter_amatchFilter_enum], sizeof(E2->xFilter_signature)) == 0) {
+ E1 = amatchFilter(args);
+ }
+ else if (memcmp(E2->xFilter_signature, xFilter_signatures[xFilter_binfoFilter_enum], sizeof(E2->xFilter_signature)) == 0) {
+ E1 = binfoFilter(args);
+ }
+ else if (memcmp(E2->xFilter_signature, xFilter_signatures[xFilter_bytecodevtabFilter_enum], sizeof(E2->xFilter_signature)) == 0) {
+ E1 = bytecodevtabFilter(args);
+ }
+ else if (memcmp(E2->xFilter_signature, xFilter_signatures[xFilter_carrayFilter_enum], sizeof(E2->xFilter_signature)) == 0) {
+ E1 = carrayFilter(args);
+ }
+ else if (memcmp(E2->xFilter_signature, xFilter_signatures[xFilter_cidxFilter_enum], sizeof(E2->xFilter_signature)) == 0) {
+ E1 = cidxFilter(args);
+ }
+ else if (memcmp(E2->xFilter_signature, xFilter_signatures[xFilter_closureFilter_enum], sizeof(E2->xFilter_signature)) == 0) {
+ E1 = closureFilter(args);
+ }
+ else if (memcmp(E2->xFilter_signature, xFilter_signatures[xFilter_completionFilter_enum], sizeof(E2->xFilter_signature)) == 0) {
+ E1 = completionFilter(args);
+ }
+ else if (memcmp(E2->xFilter_signature, xFilter_signatures[xFilter_csvtabFilter_enum], sizeof(E2->xFilter_signature)) == 0) {
+ E1 = csvtabFilter(args);
+ }
+ else if (memcmp(E2->xFilter_signature, xFilter_signatures[xFilter_dbdataFilter_enum], sizeof(E2->xFilter_signature)) == 0) {
+ E1 = dbdataFilter(args);
+ }
+ else if (memcmp(E2->xFilter_signature, xFilter_signatures[xFilter_dbpageFilter_enum], sizeof(E2->xFilter_signature)) == 0) {
+ E1 = dbpageFilter(args);
+ }
+ else if (memcmp(E2->xFilter_signature, xFilter_signatures[xFilter_deltaparsevtabFilter_enum], sizeof(E2->xFilter_signature)) == 0) {
+ E1 = deltaparsevtabFilter(args);
+ }
+ else if (memcmp(E2->xFilter_signature, xFilter_signatures[xFilter_echoFilter_enum], sizeof(E2->xFilter_signature)) == 0) {
+ E1 = echoFilter(args);
+ }
+ else if (memcmp(E2->xFilter_signature, xFilter_signatures[xFilter_expertFilter_enum], sizeof(E2->xFilter_signature)) == 0) {
+ E1 = expertFilter(args);
+ }
+ else if (memcmp(E2->xFilter_signature, xFilter_signatures[xFilter_explainFilter_enum], sizeof(E2->xFilter_signature)) == 0) {
+ E1 = explainFilter(args);
+ }
+ else if (memcmp(E2->xFilter_signature, xFilter_signatures[xFilter_fsFilter_enum], sizeof(E2->xFilter_signature)) == 0) {
+ E1 = fsFilter(args);
+ }
+ else if (memcmp(E2->xFilter_signature, xFilter_signatures[xFilter_fsdirFilter_enum], sizeof(E2->xFilter_signature)) == 0) {
+ E1 = fsdirFilter(args);
+ }
+ else if (memcmp(E2->xFilter_signature, xFilter_signatures[xFilter_fstreeFilter_enum], sizeof(E2->xFilter_signature)) == 0) {
+ E1 = fstreeFilter(args);
+ }
+ else if (memcmp(E2->xFilter_signature, xFilter_signatures[xFilter_fts3FilterMethod_enum], sizeof(E2->xFilter_signature)) == 0) {
+ E1 = fts3FilterMethod(args);
+ }
+ else if (memcmp(E2->xFilter_signature, xFilter_signatures[xFilter_fts3auxFilterMethod_enum], sizeof(E2->xFilter_signature)) == 0) {
+ E1 = fts3auxFilterMethod(args);
+ }
+ else if (memcmp(E2->xFilter_signature, xFilter_signatures[xFilter_fts3termFilterMethod_enum], sizeof(E2->xFilter_signature)) == 0) {
+ E1 = fts3termFilterMethod(args);
+ }
+ else if (memcmp(E2->xFilter_signature, xFilter_signatures[xFilter_fts3tokFilterMethod_enum], sizeof(E2->xFilter_signature)) == 0) {
+ E1 = fts3tokFilterMethod(args);
+ }
+ else if (memcmp(E2->xFilter_signature, xFilter_signatures[xFilter_fuzzerFilter_enum], sizeof(E2->xFilter_signature)) == 0) {
+ E1 = fuzzerFilter(args);
+ }
+ else if (memcmp(E2->xFilter_signature, xFilter_signatures[xFilter_geopolyFilter_enum], sizeof(E2->xFilter_signature)) == 0) {
+ E1 = geopolyFilter(args);
+ }
+ else if (memcmp(E2->xFilter_signature, xFilter_signatures[xFilter_intarrayFilter_enum], sizeof(E2->xFilter_signature)) == 0) {
+ E1 = intarrayFilter(args);
+ }
+ else if (memcmp(E2->xFilter_signature, xFilter_signatures[xFilter_jsonEachFilter_enum], sizeof(E2->xFilter_signature)) == 0) {
+ E1 = jsonEachFilter(args);
+ }
+ else if (memcmp(E2->xFilter_signature, xFilter_signatures[xFilter_memstatFilter_enum], sizeof(E2->xFilter_signature)) == 0) {
+ E1 = memstatFilter(args);
+ }
+ else if (memcmp(E2->xFilter_signature, xFilter_signatures[xFilter_pragmaVtabFilter_enum], sizeof(E2->xFilter_signature)) == 0) {
+ E1 = pragmaVtabFilter(args);
+ }
+ else if (memcmp(E2->xFilter_signature, xFilter_signatures[xFilter_prefixesFilter_enum], sizeof(E2->xFilter_signature)) == 0) {
+ E1 = prefixesFilter(args);
+ }
+ else if (memcmp(E2->xFilter_signature, xFilter_signatures[xFilter_qpvtabFilter_enum], sizeof(E2->xFilter_signature)) == 0) {
+ E1 = qpvtabFilter(args);
+ }
+ else if (memcmp(E2->xFilter_signature, xFilter_signatures[xFilter_rtreeFilter_enum], sizeof(E2->xFilter_signature)) == 0) {
+ E1 = rtreeFilter(args);
+ }
+ else if (memcmp(E2->xFilter_signature, xFilter_signatures[xFilter_schemaFilter_enum], sizeof(E2->xFilter_signature)) == 0) {
+ E1 = schemaFilter(args);
+ }
+ else if (memcmp(E2->xFilter_signature, xFilter_signatures[xFilter_seriesFilter_enum], sizeof(E2->xFilter_signature)) == 0) {
+ E1 = seriesFilter(args);
+ }
+ else if (memcmp(E2->xFilter_signature, xFilter_signatures[xFilter_spellfix1Filter_enum], sizeof(E2->xFilter_signature)) == 0) {
+ E1 = spellfix1Filter(args);
+ }
+ else if (memcmp(E2->xFilter_signature, xFilter_signatures[xFilter_statFilter_enum], sizeof(E2->xFilter_signature)) == 0) {
+ E1 = statFilter(args);
+ }
+ else if (memcmp(E2->xFilter_signature, xFilter_signatures[xFilter_stmtFilter_enum], sizeof(E2->xFilter_signature)) == 0) {
+ E1 = stmtFilter(args);
+ }
+ else if (memcmp(E2->xFilter_signature, xFilter_signatures[xFilter_tclFilter_enum], sizeof(E2->xFilter_signature)) == 0) {
+ E1 = tclFilter(args);
+ }
+ else if (memcmp(E2->xFilter_signature, xFilter_signatures[xFilter_tclvarFilter_enum], sizeof(E2->xFilter_signature)) == 0) {
+ E1 = tclvarFilter(args);
+ }
+ else if (memcmp(E2->xFilter_signature, xFilter_signatures[xFilter_templatevtabFilter_enum], sizeof(E2->xFilter_signature)) == 0) {
+ E1 = templatevtabFilter(args);
+ }
+ else if (memcmp(E2->xFilter_signature, xFilter_signatures[xFilter_unionFilter_enum], sizeof(E2->xFilter_signature)) == 0) {
+ E1 = unionFilter(args);
+ }
+ else if (memcmp(E2->xFilter_signature, xFilter_signatures[xFilter_vlogFilter_enum], sizeof(E2->xFilter_signature)) == 0) {
+ E1 = vlogFilter(args);
+ }
+ else if (memcmp(E2->xFilter_signature, xFilter_signatures[xFilter_vstattabFilter_enum], sizeof(E2->xFilter_signature)) == 0) {
+ E1 = vstattabFilter(args);
+ }
+ else if (memcmp(E2->xFilter_signature, xFilter_signatures[xFilter_vtablogFilter_enum], sizeof(E2->xFilter_signature)) == 0) {
+ E1 = vtablogFilter(args);
+ }
+ else if (memcmp(E2->xFilter_signature, xFilter_signatures[xFilter_wholenumberFilter_enum], sizeof(E2->xFilter_signature)) == 0) {
+ E1 = wholenumberFilter(args);
+ }
+ else if (memcmp(E2->xFilter_signature, xFilter_signatures[xFilter_zipfileFilter_enum], sizeof(E2->xFilter_signature)) == 0) {
+ E1 = zipfileFilter(args);
+ }


// Transform E1 = E2->xFindFunction(args) to if-chain with 2 candidates
@transform_assignment_xFindFunction_arrow@
expression E1, E2;
identifier FP_NAME = xFindFunction;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xFindFunction_signature, xFindFunction_signatures[xFindFunction_0_enum], sizeof(E2->xFindFunction_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xFindFunction_signature, xFindFunction_signatures[xFindFunction_fts3FindFunctionMethod_enum], sizeof(E2->xFindFunction_signature)) == 0) {
+ E1 = fts3FindFunctionMethod(args);
+ }
+ else if (memcmp(E2->xFindFunction_signature, xFindFunction_signatures[xFindFunction_zipfileFindFunction_enum], sizeof(E2->xFindFunction_signature)) == 0) {
+ E1 = zipfileFindFunction(args);
+ }


// Transform E1 = E2->xFree(args) to if-chain with 2 candidates
@transform_assignment_xFree_arrow@
expression E1, E2;
identifier FP_NAME = xFree;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xFree_signature, xFree_signatures[xFree_memtraceFree_enum], sizeof(E2->xFree_signature)) == 0) {
+ E1 = memtraceFree(args);
+ }
+ else if (memcmp(E2->xFree_signature, xFree_signatures[xFree_sqlite3MemFree_enum], sizeof(E2->xFree_signature)) == 0) {
+ E1 = sqlite3MemFree(args);
+ }


// Transform E1 = E2->xFullPathname(args) to if-chain with 4 candidates
@transform_assignment_xFullPathname_arrow@
expression E1, E2;
identifier FP_NAME = xFullPathname;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xFullPathname_signature, xFullPathname_signatures[xFullPathname_apndFullPathname_enum], sizeof(E2->xFullPathname_signature)) == 0) {
+ E1 = apndFullPathname(args);
+ }
+ else if (memcmp(E2->xFullPathname_signature, xFullPathname_signatures[xFullPathname_memdbFullPathname_enum], sizeof(E2->xFullPathname_signature)) == 0) {
+ E1 = memdbFullPathname(args);
+ }
+ else if (memcmp(E2->xFullPathname_signature, xFullPathname_signatures[xFullPathname_vfstraceFullPathname_enum], sizeof(E2->xFullPathname_signature)) == 0) {
+ E1 = vfstraceFullPathname(args);
+ }
+ else if (memcmp(E2->xFullPathname_signature, xFullPathname_signatures[xFullPathname_unixFullPathname_enum], sizeof(E2->xFullPathname_signature)) == 0) {
+ E1 = unixFullPathname(args);
+ }


// Transform E1 = E2->xGet(args) to if-chain with 3 candidates
@transform_assignment_xGet_arrow@
expression E1, E2;
identifier FP_NAME = xGet;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xGet_signature, xGet_signatures[xGet_getPageError_enum], sizeof(E2->xGet_signature)) == 0) {
+ E1 = getPageError(args);
+ }
+ else if (memcmp(E2->xGet_signature, xGet_signatures[xGet_getPageMMap_enum], sizeof(E2->xGet_signature)) == 0) {
+ E1 = getPageMMap(args);
+ }
+ else if (memcmp(E2->xGet_signature, xGet_signatures[xGet_getPageNormal_enum], sizeof(E2->xGet_signature)) == 0) {
+ E1 = getPageNormal(args);
+ }


// Transform E1 = E2->xGetLastError(args) to if-chain with 3 candidates
@transform_assignment_xGetLastError_arrow@
expression E1, E2;
identifier FP_NAME = xGetLastError;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xGetLastError_signature, xGetLastError_signatures[xGetLastError_0_enum], sizeof(E2->xGetLastError_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xGetLastError_signature, xGetLastError_signatures[xGetLastError_apndGetLastError_enum], sizeof(E2->xGetLastError_signature)) == 0) {
+ E1 = apndGetLastError(args);
+ }
+ else if (memcmp(E2->xGetLastError_signature, xGetLastError_signatures[xGetLastError_memdbGetLastError_enum], sizeof(E2->xGetLastError_signature)) == 0) {
+ E1 = memdbGetLastError(args);
+ }
+ else if (memcmp(E2->xGetLastError_signature, xGetLastError_signatures[xGetLastError_unixGetLastError_enum], sizeof(E2->xGetLastError_signature)) == 0) {
+ E1 = unixGetLastError(args);
+ }


// Transform E1 = E2->xGetSystemCall(args) to if-chain with 2 candidates
@transform_assignment_xGetSystemCall_arrow@
expression E1, E2;
identifier FP_NAME = xGetSystemCall;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xGetSystemCall_signature, xGetSystemCall_signatures[xGetSystemCall_0_enum], sizeof(E2->xGetSystemCall_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xGetSystemCall_signature, xGetSystemCall_signatures[xGetSystemCall_apndGetSystemCall_enum], sizeof(E2->xGetSystemCall_signature)) == 0) {
+ E1 = apndGetSystemCall(args);
+ }
+ else if (memcmp(E2->xGetSystemCall_signature, xGetSystemCall_signatures[xGetSystemCall_unixGetSystemCall_enum], sizeof(E2->xGetSystemCall_signature)) == 0) {
+ E1 = unixGetSystemCall(args);
+ }


// Transform E1 = E2->xInit(args) to if-chain with 4 candidates
@transform_assignment_xInit_arrow@
expression E1, E2;
identifier FP_NAME = xInit;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xInit_signature, xInit_signatures[xInit_memtraceInit_enum], sizeof(E2->xInit_signature)) == 0) {
+ E1 = memtraceInit(args);
+ }
+ else if (memcmp(E2->xInit_signature, xInit_signatures[xInit_pcache1Init_enum], sizeof(E2->xInit_signature)) == 0) {
+ E1 = pcache1Init(args);
+ }
+ else if (memcmp(E2->xInit_signature, xInit_signatures[xInit_pcachetraceInit_enum], sizeof(E2->xInit_signature)) == 0) {
+ E1 = pcachetraceInit(args);
+ }
+ else if (memcmp(E2->xInit_signature, xInit_signatures[xInit_sqlite3MemInit_enum], sizeof(E2->xInit_signature)) == 0) {
+ E1 = sqlite3MemInit(args);
+ }


// Transform E1 = E2->xIntegrity(args) to if-chain with 3 candidates
@transform_assignment_xIntegrity_arrow@
expression E1, E2;
identifier FP_NAME = xIntegrity;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xIntegrity_signature, xIntegrity_signatures[xIntegrity_0_enum], sizeof(E2->xIntegrity_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xIntegrity_signature, xIntegrity_signatures[xIntegrity_fts3IntegrityMethod_enum], sizeof(E2->xIntegrity_signature)) == 0) {
+ E1 = fts3IntegrityMethod(args);
+ }
+ else if (memcmp(E2->xIntegrity_signature, xIntegrity_signatures[xIntegrity_rtreeIntegrity_enum], sizeof(E2->xIntegrity_signature)) == 0) {
+ E1 = rtreeIntegrity(args);
+ }
+ else if (memcmp(E2->xIntegrity_signature, xIntegrity_signatures[xIntegrity_vtablogIntegrity_enum], sizeof(E2->xIntegrity_signature)) == 0) {
+ E1 = vtablogIntegrity(args);
+ }


// Transform E1 = E2->xLock(args) to if-chain with 7 candidates
@transform_assignment_xLock_arrow@
expression E1, E2;
identifier FP_NAME = xLock;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xLock_signature, xLock_signatures[xLock_0_enum], sizeof(E2->xLock_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xLock_signature, xLock_signatures[xLock_apndLock_enum], sizeof(E2->xLock_signature)) == 0) {
+ E1 = apndLock(args);
+ }
+ else if (memcmp(E2->xLock_signature, xLock_signatures[xLock_memdbLock_enum], sizeof(E2->xLock_signature)) == 0) {
+ E1 = memdbLock(args);
+ }
+ else if (memcmp(E2->xLock_signature, xLock_signatures[xLock_recoverVfsLock_enum], sizeof(E2->xLock_signature)) == 0) {
+ E1 = recoverVfsLock(args);
+ }
+ else if (memcmp(E2->xLock_signature, xLock_signatures[xLock_vfstraceLock_enum], sizeof(E2->xLock_signature)) == 0) {
+ E1 = vfstraceLock(args);
+ }
+ else if (memcmp(E2->xLock_signature, xLock_signatures[xLock_unixLock_enum], sizeof(E2->xLock_signature)) == 0) {
+ E1 = unixLock(args);
+ }
+ else if (memcmp(E2->xLock_signature, xLock_signatures[xLock_nolockLock_enum], sizeof(E2->xLock_signature)) == 0) {
+ E1 = nolockLock(args);
+ }
+ else if (memcmp(E2->xLock_signature, xLock_signatures[xLock_dotlockLock_enum], sizeof(E2->xLock_signature)) == 0) {
+ E1 = dotlockLock(args);
+ }


// Transform E1 = E2->xMalloc(args) to if-chain with 2 candidates
@transform_assignment_xMalloc_arrow@
expression E1, E2;
identifier FP_NAME = xMalloc;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xMalloc_signature, xMalloc_signatures[xMalloc_memtraceMalloc_enum], sizeof(E2->xMalloc_signature)) == 0) {
+ E1 = memtraceMalloc(args);
+ }
+ else if (memcmp(E2->xMalloc_signature, xMalloc_signatures[xMalloc_sqlite3MemMalloc_enum], sizeof(E2->xMalloc_signature)) == 0) {
+ E1 = sqlite3MemMalloc(args);
+ }


// Transform E1 = E2->xMutexAlloc(args) to if-chain with 7 candidates
@transform_assignment_xMutexAlloc_arrow@
expression E1, E2;
identifier FP_NAME = xMutexAlloc;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_checkMutexAlloc_enum], sizeof(E2->xMutexAlloc_signature)) == 0) {
+ E1 = checkMutexAlloc(args);
+ }
+ else if (memcmp(E2->xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_counterMutexAlloc_enum], sizeof(E2->xMutexAlloc_signature)) == 0) {
+ E1 = counterMutexAlloc(args);
+ }
+ else if (memcmp(E2->xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_debugMutexAlloc_enum], sizeof(E2->xMutexAlloc_signature)) == 0) {
+ E1 = debugMutexAlloc(args);
+ }
+ else if (memcmp(E2->xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_noopMutexAlloc_enum], sizeof(E2->xMutexAlloc_signature)) == 0) {
+ E1 = noopMutexAlloc(args);
+ }
+ else if (memcmp(E2->xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_pthreadMutexAlloc_enum], sizeof(E2->xMutexAlloc_signature)) == 0) {
+ E1 = pthreadMutexAlloc(args);
+ }
+ else if (memcmp(E2->xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_winMutexAlloc_enum], sizeof(E2->xMutexAlloc_signature)) == 0) {
+ E1 = winMutexAlloc(args);
+ }
+ else if (memcmp(E2->xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_wrMutexAlloc_enum], sizeof(E2->xMutexAlloc_signature)) == 0) {
+ E1 = wrMutexAlloc(args);
+ }


// Transform E1 = E2->xMutexEnd(args) to if-chain with 7 candidates
@transform_assignment_xMutexEnd_arrow@
expression E1, E2;
identifier FP_NAME = xMutexEnd;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_checkMutexEnd_enum], sizeof(E2->xMutexEnd_signature)) == 0) {
+ E1 = checkMutexEnd(args);
+ }
+ else if (memcmp(E2->xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_counterMutexEnd_enum], sizeof(E2->xMutexEnd_signature)) == 0) {
+ E1 = counterMutexEnd(args);
+ }
+ else if (memcmp(E2->xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_debugMutexEnd_enum], sizeof(E2->xMutexEnd_signature)) == 0) {
+ E1 = debugMutexEnd(args);
+ }
+ else if (memcmp(E2->xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_noopMutexEnd_enum], sizeof(E2->xMutexEnd_signature)) == 0) {
+ E1 = noopMutexEnd(args);
+ }
+ else if (memcmp(E2->xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_pthreadMutexEnd_enum], sizeof(E2->xMutexEnd_signature)) == 0) {
+ E1 = pthreadMutexEnd(args);
+ }
+ else if (memcmp(E2->xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_winMutexEnd_enum], sizeof(E2->xMutexEnd_signature)) == 0) {
+ E1 = winMutexEnd(args);
+ }
+ else if (memcmp(E2->xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_wrMutexEnd_enum], sizeof(E2->xMutexEnd_signature)) == 0) {
+ E1 = wrMutexEnd(args);
+ }


// Transform E1 = E2->xMutexEnter(args) to if-chain with 7 candidates
@transform_assignment_xMutexEnter_arrow@
expression E1, E2;
identifier FP_NAME = xMutexEnter;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_checkMutexEnter_enum], sizeof(E2->xMutexEnter_signature)) == 0) {
+ E1 = checkMutexEnter(args);
+ }
+ else if (memcmp(E2->xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_counterMutexEnter_enum], sizeof(E2->xMutexEnter_signature)) == 0) {
+ E1 = counterMutexEnter(args);
+ }
+ else if (memcmp(E2->xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_debugMutexEnter_enum], sizeof(E2->xMutexEnter_signature)) == 0) {
+ E1 = debugMutexEnter(args);
+ }
+ else if (memcmp(E2->xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_noopMutexEnter_enum], sizeof(E2->xMutexEnter_signature)) == 0) {
+ E1 = noopMutexEnter(args);
+ }
+ else if (memcmp(E2->xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_pthreadMutexEnter_enum], sizeof(E2->xMutexEnter_signature)) == 0) {
+ E1 = pthreadMutexEnter(args);
+ }
+ else if (memcmp(E2->xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_winMutexEnter_enum], sizeof(E2->xMutexEnter_signature)) == 0) {
+ E1 = winMutexEnter(args);
+ }
+ else if (memcmp(E2->xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_wrMutexEnter_enum], sizeof(E2->xMutexEnter_signature)) == 0) {
+ E1 = wrMutexEnter(args);
+ }


// Transform E1 = E2->xMutexFree(args) to if-chain with 7 candidates
@transform_assignment_xMutexFree_arrow@
expression E1, E2;
identifier FP_NAME = xMutexFree;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xMutexFree_signature, xMutexFree_signatures[xMutexFree_checkMutexFree_enum], sizeof(E2->xMutexFree_signature)) == 0) {
+ E1 = checkMutexFree(args);
+ }
+ else if (memcmp(E2->xMutexFree_signature, xMutexFree_signatures[xMutexFree_counterMutexFree_enum], sizeof(E2->xMutexFree_signature)) == 0) {
+ E1 = counterMutexFree(args);
+ }
+ else if (memcmp(E2->xMutexFree_signature, xMutexFree_signatures[xMutexFree_debugMutexFree_enum], sizeof(E2->xMutexFree_signature)) == 0) {
+ E1 = debugMutexFree(args);
+ }
+ else if (memcmp(E2->xMutexFree_signature, xMutexFree_signatures[xMutexFree_noopMutexFree_enum], sizeof(E2->xMutexFree_signature)) == 0) {
+ E1 = noopMutexFree(args);
+ }
+ else if (memcmp(E2->xMutexFree_signature, xMutexFree_signatures[xMutexFree_pthreadMutexFree_enum], sizeof(E2->xMutexFree_signature)) == 0) {
+ E1 = pthreadMutexFree(args);
+ }
+ else if (memcmp(E2->xMutexFree_signature, xMutexFree_signatures[xMutexFree_winMutexFree_enum], sizeof(E2->xMutexFree_signature)) == 0) {
+ E1 = winMutexFree(args);
+ }
+ else if (memcmp(E2->xMutexFree_signature, xMutexFree_signatures[xMutexFree_wrMutexFree_enum], sizeof(E2->xMutexFree_signature)) == 0) {
+ E1 = wrMutexFree(args);
+ }


// Transform E1 = E2->xMutexHeld(args) to if-chain with 3 candidates
@transform_assignment_xMutexHeld_arrow@
expression E1, E2;
identifier FP_NAME = xMutexHeld;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xMutexHeld_signature, xMutexHeld_signatures[xMutexHeld_0_enum], sizeof(E2->xMutexHeld_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xMutexHeld_signature, xMutexHeld_signatures[xMutexHeld_counterMutexHeld_enum], sizeof(E2->xMutexHeld_signature)) == 0) {
+ E1 = counterMutexHeld(args);
+ }
+ else if (memcmp(E2->xMutexHeld_signature, xMutexHeld_signatures[xMutexHeld_debugMutexHeld_enum], sizeof(E2->xMutexHeld_signature)) == 0) {
+ E1 = debugMutexHeld(args);
+ }
+ else if (memcmp(E2->xMutexHeld_signature, xMutexHeld_signatures[xMutexHeld_wrMutexHeld_enum], sizeof(E2->xMutexHeld_signature)) == 0) {
+ E1 = wrMutexHeld(args);
+ }


// Transform E1 = E2->xMutexInit(args) to if-chain with 7 candidates
@transform_assignment_xMutexInit_arrow@
expression E1, E2;
identifier FP_NAME = xMutexInit;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xMutexInit_signature, xMutexInit_signatures[xMutexInit_checkMutexInit_enum], sizeof(E2->xMutexInit_signature)) == 0) {
+ E1 = checkMutexInit(args);
+ }
+ else if (memcmp(E2->xMutexInit_signature, xMutexInit_signatures[xMutexInit_counterMutexInit_enum], sizeof(E2->xMutexInit_signature)) == 0) {
+ E1 = counterMutexInit(args);
+ }
+ else if (memcmp(E2->xMutexInit_signature, xMutexInit_signatures[xMutexInit_debugMutexInit_enum], sizeof(E2->xMutexInit_signature)) == 0) {
+ E1 = debugMutexInit(args);
+ }
+ else if (memcmp(E2->xMutexInit_signature, xMutexInit_signatures[xMutexInit_noopMutexInit_enum], sizeof(E2->xMutexInit_signature)) == 0) {
+ E1 = noopMutexInit(args);
+ }
+ else if (memcmp(E2->xMutexInit_signature, xMutexInit_signatures[xMutexInit_pthreadMutexInit_enum], sizeof(E2->xMutexInit_signature)) == 0) {
+ E1 = pthreadMutexInit(args);
+ }
+ else if (memcmp(E2->xMutexInit_signature, xMutexInit_signatures[xMutexInit_winMutexInit_enum], sizeof(E2->xMutexInit_signature)) == 0) {
+ E1 = winMutexInit(args);
+ }
+ else if (memcmp(E2->xMutexInit_signature, xMutexInit_signatures[xMutexInit_wrMutexInit_enum], sizeof(E2->xMutexInit_signature)) == 0) {
+ E1 = wrMutexInit(args);
+ }


// Transform E1 = E2->xMutexLeave(args) to if-chain with 7 candidates
@transform_assignment_xMutexLeave_arrow@
expression E1, E2;
identifier FP_NAME = xMutexLeave;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_checkMutexLeave_enum], sizeof(E2->xMutexLeave_signature)) == 0) {
+ E1 = checkMutexLeave(args);
+ }
+ else if (memcmp(E2->xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_counterMutexLeave_enum], sizeof(E2->xMutexLeave_signature)) == 0) {
+ E1 = counterMutexLeave(args);
+ }
+ else if (memcmp(E2->xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_debugMutexLeave_enum], sizeof(E2->xMutexLeave_signature)) == 0) {
+ E1 = debugMutexLeave(args);
+ }
+ else if (memcmp(E2->xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_noopMutexLeave_enum], sizeof(E2->xMutexLeave_signature)) == 0) {
+ E1 = noopMutexLeave(args);
+ }
+ else if (memcmp(E2->xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_pthreadMutexLeave_enum], sizeof(E2->xMutexLeave_signature)) == 0) {
+ E1 = pthreadMutexLeave(args);
+ }
+ else if (memcmp(E2->xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_winMutexLeave_enum], sizeof(E2->xMutexLeave_signature)) == 0) {
+ E1 = winMutexLeave(args);
+ }
+ else if (memcmp(E2->xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_wrMutexLeave_enum], sizeof(E2->xMutexLeave_signature)) == 0) {
+ E1 = wrMutexLeave(args);
+ }


// Transform E1 = E2->xMutexNotheld(args) to if-chain with 3 candidates
@transform_assignment_xMutexNotheld_arrow@
expression E1, E2;
identifier FP_NAME = xMutexNotheld;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xMutexNotheld_signature, xMutexNotheld_signatures[xMutexNotheld_0_enum], sizeof(E2->xMutexNotheld_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xMutexNotheld_signature, xMutexNotheld_signatures[xMutexNotheld_counterMutexNotheld_enum], sizeof(E2->xMutexNotheld_signature)) == 0) {
+ E1 = counterMutexNotheld(args);
+ }
+ else if (memcmp(E2->xMutexNotheld_signature, xMutexNotheld_signatures[xMutexNotheld_debugMutexNotheld_enum], sizeof(E2->xMutexNotheld_signature)) == 0) {
+ E1 = debugMutexNotheld(args);
+ }
+ else if (memcmp(E2->xMutexNotheld_signature, xMutexNotheld_signatures[xMutexNotheld_wrMutexNotheld_enum], sizeof(E2->xMutexNotheld_signature)) == 0) {
+ E1 = wrMutexNotheld(args);
+ }


// Transform E1 = E2->xMutexTry(args) to if-chain with 7 candidates
@transform_assignment_xMutexTry_arrow@
expression E1, E2;
identifier FP_NAME = xMutexTry;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xMutexTry_signature, xMutexTry_signatures[xMutexTry_checkMutexTry_enum], sizeof(E2->xMutexTry_signature)) == 0) {
+ E1 = checkMutexTry(args);
+ }
+ else if (memcmp(E2->xMutexTry_signature, xMutexTry_signatures[xMutexTry_counterMutexTry_enum], sizeof(E2->xMutexTry_signature)) == 0) {
+ E1 = counterMutexTry(args);
+ }
+ else if (memcmp(E2->xMutexTry_signature, xMutexTry_signatures[xMutexTry_debugMutexTry_enum], sizeof(E2->xMutexTry_signature)) == 0) {
+ E1 = debugMutexTry(args);
+ }
+ else if (memcmp(E2->xMutexTry_signature, xMutexTry_signatures[xMutexTry_noopMutexTry_enum], sizeof(E2->xMutexTry_signature)) == 0) {
+ E1 = noopMutexTry(args);
+ }
+ else if (memcmp(E2->xMutexTry_signature, xMutexTry_signatures[xMutexTry_pthreadMutexTry_enum], sizeof(E2->xMutexTry_signature)) == 0) {
+ E1 = pthreadMutexTry(args);
+ }
+ else if (memcmp(E2->xMutexTry_signature, xMutexTry_signatures[xMutexTry_winMutexTry_enum], sizeof(E2->xMutexTry_signature)) == 0) {
+ E1 = winMutexTry(args);
+ }
+ else if (memcmp(E2->xMutexTry_signature, xMutexTry_signatures[xMutexTry_wrMutexTry_enum], sizeof(E2->xMutexTry_signature)) == 0) {
+ E1 = wrMutexTry(args);
+ }


// Transform E1 = E2->xNew(args) to if-chain with 3 candidates
@transform_assignment_xNew_arrow@
expression E1, E2;
identifier FP_NAME = xNew;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xNew_signature, xNew_signatures[xNew_sessionDiffNew_enum], sizeof(E2->xNew_signature)) == 0) {
+ E1 = sessionDiffNew(args);
+ }
+ else if (memcmp(E2->xNew_signature, xNew_signatures[xNew_sessionPreupdateNew_enum], sizeof(E2->xNew_signature)) == 0) {
+ E1 = sessionPreupdateNew(args);
+ }
+ else if (memcmp(E2->xNew_signature, xNew_signatures[xNew_sessionStat1New_enum], sizeof(E2->xNew_signature)) == 0) {
+ E1 = sessionStat1New(args);
+ }


// Transform E1 = E2->xNext(args) to if-chain with 46 candidates
@transform_assignment_xNext_arrow@
expression E1, E2;
identifier FP_NAME = xNext;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xNext_signature, xNext_signatures[xNext_0_enum], sizeof(E2->xNext_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xNext_signature, xNext_signatures[xNext_amatchNext_enum], sizeof(E2->xNext_signature)) == 0) {
+ E1 = amatchNext(args);
+ }
+ else if (memcmp(E2->xNext_signature, xNext_signatures[xNext_binfoNext_enum], sizeof(E2->xNext_signature)) == 0) {
+ E1 = binfoNext(args);
+ }
+ else if (memcmp(E2->xNext_signature, xNext_signatures[xNext_bytecodevtabNext_enum], sizeof(E2->xNext_signature)) == 0) {
+ E1 = bytecodevtabNext(args);
+ }
+ else if (memcmp(E2->xNext_signature, xNext_signatures[xNext_carrayNext_enum], sizeof(E2->xNext_signature)) == 0) {
+ E1 = carrayNext(args);
+ }
+ else if (memcmp(E2->xNext_signature, xNext_signatures[xNext_cidxNext_enum], sizeof(E2->xNext_signature)) == 0) {
+ E1 = cidxNext(args);
+ }
+ else if (memcmp(E2->xNext_signature, xNext_signatures[xNext_closureNext_enum], sizeof(E2->xNext_signature)) == 0) {
+ E1 = closureNext(args);
+ }
+ else if (memcmp(E2->xNext_signature, xNext_signatures[xNext_completionNext_enum], sizeof(E2->xNext_signature)) == 0) {
+ E1 = completionNext(args);
+ }
+ else if (memcmp(E2->xNext_signature, xNext_signatures[xNext_csvtabNext_enum], sizeof(E2->xNext_signature)) == 0) {
+ E1 = csvtabNext(args);
+ }
+ else if (memcmp(E2->xNext_signature, xNext_signatures[xNext_dbdataNext_enum], sizeof(E2->xNext_signature)) == 0) {
+ E1 = dbdataNext(args);
+ }
+ else if (memcmp(E2->xNext_signature, xNext_signatures[xNext_dbpageNext_enum], sizeof(E2->xNext_signature)) == 0) {
+ E1 = dbpageNext(args);
+ }
+ else if (memcmp(E2->xNext_signature, xNext_signatures[xNext_deltaparsevtabNext_enum], sizeof(E2->xNext_signature)) == 0) {
+ E1 = deltaparsevtabNext(args);
+ }
+ else if (memcmp(E2->xNext_signature, xNext_signatures[xNext_echoNext_enum], sizeof(E2->xNext_signature)) == 0) {
+ E1 = echoNext(args);
+ }
+ else if (memcmp(E2->xNext_signature, xNext_signatures[xNext_expertNext_enum], sizeof(E2->xNext_signature)) == 0) {
+ E1 = expertNext(args);
+ }
+ else if (memcmp(E2->xNext_signature, xNext_signatures[xNext_explainNext_enum], sizeof(E2->xNext_signature)) == 0) {
+ E1 = explainNext(args);
+ }
+ else if (memcmp(E2->xNext_signature, xNext_signatures[xNext_fsNext_enum], sizeof(E2->xNext_signature)) == 0) {
+ E1 = fsNext(args);
+ }
+ else if (memcmp(E2->xNext_signature, xNext_signatures[xNext_fsdirNext_enum], sizeof(E2->xNext_signature)) == 0) {
+ E1 = fsdirNext(args);
+ }
+ else if (memcmp(E2->xNext_signature, xNext_signatures[xNext_fstreeNext_enum], sizeof(E2->xNext_signature)) == 0) {
+ E1 = fstreeNext(args);
+ }
+ else if (memcmp(E2->xNext_signature, xNext_signatures[xNext_fts3NextMethod_enum], sizeof(E2->xNext_signature)) == 0) {
+ E1 = fts3NextMethod(args);
+ }
+ else if (memcmp(E2->xNext_signature, xNext_signatures[xNext_fts3auxNextMethod_enum], sizeof(E2->xNext_signature)) == 0) {
+ E1 = fts3auxNextMethod(args);
+ }
+ else if (memcmp(E2->xNext_signature, xNext_signatures[xNext_fts3termNextMethod_enum], sizeof(E2->xNext_signature)) == 0) {
+ E1 = fts3termNextMethod(args);
+ }
+ else if (memcmp(E2->xNext_signature, xNext_signatures[xNext_fts3tokNextMethod_enum], sizeof(E2->xNext_signature)) == 0) {
+ E1 = fts3tokNextMethod(args);
+ }
+ else if (memcmp(E2->xNext_signature, xNext_signatures[xNext_fuzzerNext_enum], sizeof(E2->xNext_signature)) == 0) {
+ E1 = fuzzerNext(args);
+ }
+ else if (memcmp(E2->xNext_signature, xNext_signatures[xNext_intarrayNext_enum], sizeof(E2->xNext_signature)) == 0) {
+ E1 = intarrayNext(args);
+ }
+ else if (memcmp(E2->xNext_signature, xNext_signatures[xNext_jsonEachNext_enum], sizeof(E2->xNext_signature)) == 0) {
+ E1 = jsonEachNext(args);
+ }
+ else if (memcmp(E2->xNext_signature, xNext_signatures[xNext_memstatNext_enum], sizeof(E2->xNext_signature)) == 0) {
+ E1 = memstatNext(args);
+ }
+ else if (memcmp(E2->xNext_signature, xNext_signatures[xNext_porterNext_enum], sizeof(E2->xNext_signature)) == 0) {
+ E1 = porterNext(args);
+ }
+ else if (memcmp(E2->xNext_signature, xNext_signatures[xNext_pragmaVtabNext_enum], sizeof(E2->xNext_signature)) == 0) {
+ E1 = pragmaVtabNext(args);
+ }
+ else if (memcmp(E2->xNext_signature, xNext_signatures[xNext_prefixesNext_enum], sizeof(E2->xNext_signature)) == 0) {
+ E1 = prefixesNext(args);
+ }
+ else if (memcmp(E2->xNext_signature, xNext_signatures[xNext_qpvtabNext_enum], sizeof(E2->xNext_signature)) == 0) {
+ E1 = qpvtabNext(args);
+ }
+ else if (memcmp(E2->xNext_signature, xNext_signatures[xNext_rtreeNext_enum], sizeof(E2->xNext_signature)) == 0) {
+ E1 = rtreeNext(args);
+ }
+ else if (memcmp(E2->xNext_signature, xNext_signatures[xNext_schemaNext_enum], sizeof(E2->xNext_signature)) == 0) {
+ E1 = schemaNext(args);
+ }
+ else if (memcmp(E2->xNext_signature, xNext_signatures[xNext_seriesNext_enum], sizeof(E2->xNext_signature)) == 0) {
+ E1 = seriesNext(args);
+ }
+ else if (memcmp(E2->xNext_signature, xNext_signatures[xNext_simpleNext_enum], sizeof(E2->xNext_signature)) == 0) {
+ E1 = simpleNext(args);
+ }
+ else if (memcmp(E2->xNext_signature, xNext_signatures[xNext_spellfix1Next_enum], sizeof(E2->xNext_signature)) == 0) {
+ E1 = spellfix1Next(args);
+ }
+ else if (memcmp(E2->xNext_signature, xNext_signatures[xNext_statNext_enum], sizeof(E2->xNext_signature)) == 0) {
+ E1 = statNext(args);
+ }
+ else if (memcmp(E2->xNext_signature, xNext_signatures[xNext_stmtNext_enum], sizeof(E2->xNext_signature)) == 0) {
+ E1 = stmtNext(args);
+ }
+ else if (memcmp(E2->xNext_signature, xNext_signatures[xNext_tclNext_enum], sizeof(E2->xNext_signature)) == 0) {
+ E1 = tclNext(args);
+ }
+ else if (memcmp(E2->xNext_signature, xNext_signatures[xNext_tclvarNext_enum], sizeof(E2->xNext_signature)) == 0) {
+ E1 = tclvarNext(args);
+ }
+ else if (memcmp(E2->xNext_signature, xNext_signatures[xNext_templatevtabNext_enum], sizeof(E2->xNext_signature)) == 0) {
+ E1 = templatevtabNext(args);
+ }
+ else if (memcmp(E2->xNext_signature, xNext_signatures[xNext_unicodeNext_enum], sizeof(E2->xNext_signature)) == 0) {
+ E1 = unicodeNext(args);
+ }
+ else if (memcmp(E2->xNext_signature, xNext_signatures[xNext_unionNext_enum], sizeof(E2->xNext_signature)) == 0) {
+ E1 = unionNext(args);
+ }
+ else if (memcmp(E2->xNext_signature, xNext_signatures[xNext_vlogNext_enum], sizeof(E2->xNext_signature)) == 0) {
+ E1 = vlogNext(args);
+ }
+ else if (memcmp(E2->xNext_signature, xNext_signatures[xNext_vstattabNext_enum], sizeof(E2->xNext_signature)) == 0) {
+ E1 = vstattabNext(args);
+ }
+ else if (memcmp(E2->xNext_signature, xNext_signatures[xNext_vtablogNext_enum], sizeof(E2->xNext_signature)) == 0) {
+ E1 = vtablogNext(args);
+ }
+ else if (memcmp(E2->xNext_signature, xNext_signatures[xNext_wholenumberNext_enum], sizeof(E2->xNext_signature)) == 0) {
+ E1 = wholenumberNext(args);
+ }
+ else if (memcmp(E2->xNext_signature, xNext_signatures[xNext_zipfileNext_enum], sizeof(E2->xNext_signature)) == 0) {
+ E1 = zipfileNext(args);
+ }


// Transform E1 = E2->xNextSystemCall(args) to if-chain with 3 candidates
@transform_assignment_xNextSystemCall_arrow@
expression E1, E2;
identifier FP_NAME = xNextSystemCall;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xNextSystemCall_signature, xNextSystemCall_signatures[xNextSystemCall_0_enum], sizeof(E2->xNextSystemCall_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xNextSystemCall_signature, xNextSystemCall_signatures[xNextSystemCall_apndNextSystemCall_enum], sizeof(E2->xNextSystemCall_signature)) == 0) {
+ E1 = apndNextSystemCall(args);
+ }
+ else if (memcmp(E2->xNextSystemCall_signature, xNextSystemCall_signatures[xNextSystemCall_rbuVfsGetLastError_enum], sizeof(E2->xNextSystemCall_signature)) == 0) {
+ E1 = rbuVfsGetLastError(args);
+ }
+ else if (memcmp(E2->xNextSystemCall_signature, xNextSystemCall_signatures[xNextSystemCall_unixNextSystemCall_enum], sizeof(E2->xNextSystemCall_signature)) == 0) {
+ E1 = unixNextSystemCall(args);
+ }


// Transform E1 = E2->xOld(args) to if-chain with 3 candidates
@transform_assignment_xOld_arrow@
expression E1, E2;
identifier FP_NAME = xOld;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xOld_signature, xOld_signatures[xOld_sessionDiffOld_enum], sizeof(E2->xOld_signature)) == 0) {
+ E1 = sessionDiffOld(args);
+ }
+ else if (memcmp(E2->xOld_signature, xOld_signatures[xOld_sessionPreupdateOld_enum], sizeof(E2->xOld_signature)) == 0) {
+ E1 = sessionPreupdateOld(args);
+ }
+ else if (memcmp(E2->xOld_signature, xOld_signatures[xOld_sessionStat1Old_enum], sizeof(E2->xOld_signature)) == 0) {
+ E1 = sessionStat1Old(args);
+ }


// Transform E1 = E2->xOpen(args) to if-chain with 51 candidates
@transform_assignment_xOpen_arrow@
expression E1, E2;
identifier FP_NAME = xOpen;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_amatchOpen_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = amatchOpen(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_apndOpen_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = apndOpen(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_binfoOpen_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = binfoOpen(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_bytecodevtabOpen_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = bytecodevtabOpen(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_carrayOpen_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = carrayOpen(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_cidxOpen_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = cidxOpen(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_closureOpen_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = closureOpen(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_completionOpen_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = completionOpen(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_csvtabOpen_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = csvtabOpen(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_dbdataOpen_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = dbdataOpen(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_dbpageOpen_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = dbpageOpen(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_deltaparsevtabOpen_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = deltaparsevtabOpen(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_echoOpen_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = echoOpen(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_expertOpen_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = expertOpen(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_explainOpen_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = explainOpen(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_fsOpen_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = fsOpen(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_fsdirOpen_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = fsdirOpen(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_fstreeOpen_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = fstreeOpen(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_fts3OpenMethod_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = fts3OpenMethod(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_fts3auxOpenMethod_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = fts3auxOpenMethod(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_fts3termOpenMethod_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = fts3termOpenMethod(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_fts3tokOpenMethod_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = fts3tokOpenMethod(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_fuzzerOpen_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = fuzzerOpen(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_intarrayOpen_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = intarrayOpen(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_jsonEachOpen_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = jsonEachOpen(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_jsonEachOpenEach_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = jsonEachOpenEach(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_jsonEachOpenTree_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = jsonEachOpenTree(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_memdbOpen_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = memdbOpen(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_memstatOpen_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = memstatOpen(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_porterOpen_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = porterOpen(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_pragmaVtabOpen_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = pragmaVtabOpen(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_prefixesOpen_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = prefixesOpen(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_qpvtabOpen_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = qpvtabOpen(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_rtreeOpen_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = rtreeOpen(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_schemaOpen_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = schemaOpen(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_seriesOpen_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = seriesOpen(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_simpleOpen_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = simpleOpen(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_spellfix1Open_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = spellfix1Open(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_statOpen_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = statOpen(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_stmtOpen_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = stmtOpen(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_tclOpen_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = tclOpen(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_tclvarOpen_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = tclvarOpen(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_templatevtabOpen_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = templatevtabOpen(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_unicodeOpen_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = unicodeOpen(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_unionOpen_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = unionOpen(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_vfstraceOpen_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = vfstraceOpen(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_vstattabOpen_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = vstattabOpen(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_vtablogOpen_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = vtablogOpen(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_wholenumberOpen_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = wholenumberOpen(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_zipfileOpen_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = zipfileOpen(args);
+ }
+ else if (memcmp(E2->xOpen_signature, xOpen_signatures[xOpen_unixOpen_enum], sizeof(E2->xOpen_signature)) == 0) {
+ E1 = unixOpen(args);
+ }


// Transform E1 = E2->xPagecount(args) to if-chain with 2 candidates
@transform_assignment_xPagecount_arrow@
expression E1, E2;
identifier FP_NAME = xPagecount;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xPagecount_signature, xPagecount_signatures[xPagecount_pcache1Pagecount_enum], sizeof(E2->xPagecount_signature)) == 0) {
+ E1 = pcache1Pagecount(args);
+ }
+ else if (memcmp(E2->xPagecount_signature, xPagecount_signatures[xPagecount_pcachetracePagecount_enum], sizeof(E2->xPagecount_signature)) == 0) {
+ E1 = pcachetracePagecount(args);
+ }


// Transform E1 = E2->xParseCell(args) to if-chain with 3 candidates
@transform_assignment_xParseCell_arrow@
expression E1, E2;
identifier FP_NAME = xParseCell;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xParseCell_signature, xParseCell_signatures[xParseCell_btreeParseCellPtr_enum], sizeof(E2->xParseCell_signature)) == 0) {
+ E1 = btreeParseCellPtr(args);
+ }
+ else if (memcmp(E2->xParseCell_signature, xParseCell_signatures[xParseCell_btreeParseCellPtrIndex_enum], sizeof(E2->xParseCell_signature)) == 0) {
+ E1 = btreeParseCellPtrIndex(args);
+ }
+ else if (memcmp(E2->xParseCell_signature, xParseCell_signatures[xParseCell_btreeParseCellPtrNoPayload_enum], sizeof(E2->xParseCell_signature)) == 0) {
+ E1 = btreeParseCellPtrNoPayload(args);
+ }


// Transform E1 = E2->xRandomness(args) to if-chain with 4 candidates
@transform_assignment_xRandomness_arrow@
expression E1, E2;
identifier FP_NAME = xRandomness;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xRandomness_signature, xRandomness_signatures[xRandomness_apndRandomness_enum], sizeof(E2->xRandomness_signature)) == 0) {
+ E1 = apndRandomness(args);
+ }
+ else if (memcmp(E2->xRandomness_signature, xRandomness_signatures[xRandomness_memdbRandomness_enum], sizeof(E2->xRandomness_signature)) == 0) {
+ E1 = memdbRandomness(args);
+ }
+ else if (memcmp(E2->xRandomness_signature, xRandomness_signatures[xRandomness_vfstraceRandomness_enum], sizeof(E2->xRandomness_signature)) == 0) {
+ E1 = vfstraceRandomness(args);
+ }
+ else if (memcmp(E2->xRandomness_signature, xRandomness_signatures[xRandomness_unixRandomness_enum], sizeof(E2->xRandomness_signature)) == 0) {
+ E1 = unixRandomness(args);
+ }


// Transform E1 = E2->xRead(args) to if-chain with 6 candidates
@transform_assignment_xRead_arrow@
expression E1, E2;
identifier FP_NAME = xRead;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xRead_signature, xRead_signatures[xRead_apndRead_enum], sizeof(E2->xRead_signature)) == 0) {
+ E1 = apndRead(args);
+ }
+ else if (memcmp(E2->xRead_signature, xRead_signatures[xRead_memdbRead_enum], sizeof(E2->xRead_signature)) == 0) {
+ E1 = memdbRead(args);
+ }
+ else if (memcmp(E2->xRead_signature, xRead_signatures[xRead_memjrnlRead_enum], sizeof(E2->xRead_signature)) == 0) {
+ E1 = memjrnlRead(args);
+ }
+ else if (memcmp(E2->xRead_signature, xRead_signatures[xRead_recoverVfsRead_enum], sizeof(E2->xRead_signature)) == 0) {
+ E1 = recoverVfsRead(args);
+ }
+ else if (memcmp(E2->xRead_signature, xRead_signatures[xRead_vfstraceRead_enum], sizeof(E2->xRead_signature)) == 0) {
+ E1 = vfstraceRead(args);
+ }
+ else if (memcmp(E2->xRead_signature, xRead_signatures[xRead_unixRead_enum], sizeof(E2->xRead_signature)) == 0) {
+ E1 = unixRead(args);
+ }


// Transform E1 = E2->xRealloc(args) to if-chain with 2 candidates
@transform_assignment_xRealloc_arrow@
expression E1, E2;
identifier FP_NAME = xRealloc;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xRealloc_signature, xRealloc_signatures[xRealloc_memtraceRealloc_enum], sizeof(E2->xRealloc_signature)) == 0) {
+ E1 = memtraceRealloc(args);
+ }
+ else if (memcmp(E2->xRealloc_signature, xRealloc_signatures[xRealloc_sqlite3MemRealloc_enum], sizeof(E2->xRealloc_signature)) == 0) {
+ E1 = sqlite3MemRealloc(args);
+ }


// Transform E1 = E2->xRekey(args) to if-chain with 3 candidates
@transform_assignment_xRekey_arrow@
expression E1, E2;
identifier FP_NAME = xRekey;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xRekey_signature, xRekey_signatures[xRekey_pcache1Rekey_enum], sizeof(E2->xRekey_signature)) == 0) {
+ E1 = pcache1Rekey(args);
+ }
+ else if (memcmp(E2->xRekey_signature, xRekey_signatures[xRekey_pcachetraceRekey_enum], sizeof(E2->xRekey_signature)) == 0) {
+ E1 = pcachetraceRekey(args);
+ }
+ else if (memcmp(E2->xRekey_signature, xRekey_signatures[xRekey_unixRandomness_enum], sizeof(E2->xRekey_signature)) == 0) {
+ E1 = unixRandomness(args);
+ }


// Transform E1 = E2->xRelease(args) to if-chain with 3 candidates
@transform_assignment_xRelease_arrow@
expression E1, E2;
identifier FP_NAME = xRelease;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xRelease_signature, xRelease_signatures[xRelease_0_enum], sizeof(E2->xRelease_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xRelease_signature, xRelease_signatures[xRelease_echoRelease_enum], sizeof(E2->xRelease_signature)) == 0) {
+ E1 = echoRelease(args);
+ }
+ else if (memcmp(E2->xRelease_signature, xRelease_signatures[xRelease_fts3ReleaseMethod_enum], sizeof(E2->xRelease_signature)) == 0) {
+ E1 = fts3ReleaseMethod(args);
+ }
+ else if (memcmp(E2->xRelease_signature, xRelease_signatures[xRelease_vtablogRelease_enum], sizeof(E2->xRelease_signature)) == 0) {
+ E1 = vtablogRelease(args);
+ }


// Transform E1 = E2->xRename(args) to if-chain with 5 candidates
@transform_assignment_xRename_arrow@
expression E1, E2;
identifier FP_NAME = xRename;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xRename_signature, xRename_signatures[xRename_0_enum], sizeof(E2->xRename_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xRename_signature, xRename_signatures[xRename_echoRename_enum], sizeof(E2->xRename_signature)) == 0) {
+ E1 = echoRename(args);
+ }
+ else if (memcmp(E2->xRename_signature, xRename_signatures[xRename_fts3RenameMethod_enum], sizeof(E2->xRename_signature)) == 0) {
+ E1 = fts3RenameMethod(args);
+ }
+ else if (memcmp(E2->xRename_signature, xRename_signatures[xRename_rtreeRename_enum], sizeof(E2->xRename_signature)) == 0) {
+ E1 = rtreeRename(args);
+ }
+ else if (memcmp(E2->xRename_signature, xRename_signatures[xRename_spellfix1Rename_enum], sizeof(E2->xRename_signature)) == 0) {
+ E1 = spellfix1Rename(args);
+ }
+ else if (memcmp(E2->xRename_signature, xRename_signatures[xRename_vtablogRename_enum], sizeof(E2->xRename_signature)) == 0) {
+ E1 = vtablogRename(args);
+ }


// Transform E1 = E2->xRollback(args) to if-chain with 6 candidates
@transform_assignment_xRollback_arrow@
expression E1, E2;
identifier FP_NAME = xRollback;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xRollback_signature, xRollback_signatures[xRollback_0_enum], sizeof(E2->xRollback_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xRollback_signature, xRollback_signatures[xRollback_echoRollback_enum], sizeof(E2->xRollback_signature)) == 0) {
+ E1 = echoRollback(args);
+ }
+ else if (memcmp(E2->xRollback_signature, xRollback_signatures[xRollback_fts3RollbackMethod_enum], sizeof(E2->xRollback_signature)) == 0) {
+ E1 = fts3RollbackMethod(args);
+ }
+ else if (memcmp(E2->xRollback_signature, xRollback_signatures[xRollback_rtreeEndTransaction_enum], sizeof(E2->xRollback_signature)) == 0) {
+ E1 = rtreeEndTransaction(args);
+ }
+ else if (memcmp(E2->xRollback_signature, xRollback_signatures[xRollback_rtreeRollback_enum], sizeof(E2->xRollback_signature)) == 0) {
+ E1 = rtreeRollback(args);
+ }
+ else if (memcmp(E2->xRollback_signature, xRollback_signatures[xRollback_vtablogRollback_enum], sizeof(E2->xRollback_signature)) == 0) {
+ E1 = vtablogRollback(args);
+ }
+ else if (memcmp(E2->xRollback_signature, xRollback_signatures[xRollback_zipfileRollback_enum], sizeof(E2->xRollback_signature)) == 0) {
+ E1 = zipfileRollback(args);
+ }


// Transform E1 = E2->xRollbackTo(args) to if-chain with 4 candidates
@transform_assignment_xRollbackTo_arrow@
expression E1, E2;
identifier FP_NAME = xRollbackTo;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xRollbackTo_signature, xRollbackTo_signatures[xRollbackTo_0_enum], sizeof(E2->xRollbackTo_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xRollbackTo_signature, xRollbackTo_signatures[xRollbackTo_dbpageRollbackTo_enum], sizeof(E2->xRollbackTo_signature)) == 0) {
+ E1 = dbpageRollbackTo(args);
+ }
+ else if (memcmp(E2->xRollbackTo_signature, xRollbackTo_signatures[xRollbackTo_echoRollbackTo_enum], sizeof(E2->xRollbackTo_signature)) == 0) {
+ E1 = echoRollbackTo(args);
+ }
+ else if (memcmp(E2->xRollbackTo_signature, xRollbackTo_signatures[xRollbackTo_fts3RollbackToMethod_enum], sizeof(E2->xRollbackTo_signature)) == 0) {
+ E1 = fts3RollbackToMethod(args);
+ }
+ else if (memcmp(E2->xRollbackTo_signature, xRollbackTo_signatures[xRollbackTo_vtablogRollbackTo_enum], sizeof(E2->xRollbackTo_signature)) == 0) {
+ E1 = vtablogRollbackTo(args);
+ }


// Transform E1 = E2->xRoundup(args) to if-chain with 2 candidates
@transform_assignment_xRoundup_arrow@
expression E1, E2;
identifier FP_NAME = xRoundup;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xRoundup_signature, xRoundup_signatures[xRoundup_memtraceRoundup_enum], sizeof(E2->xRoundup_signature)) == 0) {
+ E1 = memtraceRoundup(args);
+ }
+ else if (memcmp(E2->xRoundup_signature, xRoundup_signatures[xRoundup_sqlite3MemRoundup_enum], sizeof(E2->xRoundup_signature)) == 0) {
+ E1 = sqlite3MemRoundup(args);
+ }


// Transform E1 = E2->xRowid(args) to if-chain with 42 candidates
@transform_assignment_xRowid_arrow@
expression E1, E2;
identifier FP_NAME = xRowid;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xRowid_signature, xRowid_signatures[xRowid_0_enum], sizeof(E2->xRowid_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xRowid_signature, xRowid_signatures[xRowid_amatchRowid_enum], sizeof(E2->xRowid_signature)) == 0) {
+ E1 = amatchRowid(args);
+ }
+ else if (memcmp(E2->xRowid_signature, xRowid_signatures[xRowid_binfoRowid_enum], sizeof(E2->xRowid_signature)) == 0) {
+ E1 = binfoRowid(args);
+ }
+ else if (memcmp(E2->xRowid_signature, xRowid_signatures[xRowid_bytecodevtabRowid_enum], sizeof(E2->xRowid_signature)) == 0) {
+ E1 = bytecodevtabRowid(args);
+ }
+ else if (memcmp(E2->xRowid_signature, xRowid_signatures[xRowid_carrayRowid_enum], sizeof(E2->xRowid_signature)) == 0) {
+ E1 = carrayRowid(args);
+ }
+ else if (memcmp(E2->xRowid_signature, xRowid_signatures[xRowid_cidxRowid_enum], sizeof(E2->xRowid_signature)) == 0) {
+ E1 = cidxRowid(args);
+ }
+ else if (memcmp(E2->xRowid_signature, xRowid_signatures[xRowid_closureRowid_enum], sizeof(E2->xRowid_signature)) == 0) {
+ E1 = closureRowid(args);
+ }
+ else if (memcmp(E2->xRowid_signature, xRowid_signatures[xRowid_completionRowid_enum], sizeof(E2->xRowid_signature)) == 0) {
+ E1 = completionRowid(args);
+ }
+ else if (memcmp(E2->xRowid_signature, xRowid_signatures[xRowid_csvtabRowid_enum], sizeof(E2->xRowid_signature)) == 0) {
+ E1 = csvtabRowid(args);
+ }
+ else if (memcmp(E2->xRowid_signature, xRowid_signatures[xRowid_dbdataRowid_enum], sizeof(E2->xRowid_signature)) == 0) {
+ E1 = dbdataRowid(args);
+ }
+ else if (memcmp(E2->xRowid_signature, xRowid_signatures[xRowid_dbpageRowid_enum], sizeof(E2->xRowid_signature)) == 0) {
+ E1 = dbpageRowid(args);
+ }
+ else if (memcmp(E2->xRowid_signature, xRowid_signatures[xRowid_deltaparsevtabRowid_enum], sizeof(E2->xRowid_signature)) == 0) {
+ E1 = deltaparsevtabRowid(args);
+ }
+ else if (memcmp(E2->xRowid_signature, xRowid_signatures[xRowid_echoRowid_enum], sizeof(E2->xRowid_signature)) == 0) {
+ E1 = echoRowid(args);
+ }
+ else if (memcmp(E2->xRowid_signature, xRowid_signatures[xRowid_expertRowid_enum], sizeof(E2->xRowid_signature)) == 0) {
+ E1 = expertRowid(args);
+ }
+ else if (memcmp(E2->xRowid_signature, xRowid_signatures[xRowid_explainRowid_enum], sizeof(E2->xRowid_signature)) == 0) {
+ E1 = explainRowid(args);
+ }
+ else if (memcmp(E2->xRowid_signature, xRowid_signatures[xRowid_fsRowid_enum], sizeof(E2->xRowid_signature)) == 0) {
+ E1 = fsRowid(args);
+ }
+ else if (memcmp(E2->xRowid_signature, xRowid_signatures[xRowid_fsdirRowid_enum], sizeof(E2->xRowid_signature)) == 0) {
+ E1 = fsdirRowid(args);
+ }
+ else if (memcmp(E2->xRowid_signature, xRowid_signatures[xRowid_fstreeRowid_enum], sizeof(E2->xRowid_signature)) == 0) {
+ E1 = fstreeRowid(args);
+ }
+ else if (memcmp(E2->xRowid_signature, xRowid_signatures[xRowid_fts3RowidMethod_enum], sizeof(E2->xRowid_signature)) == 0) {
+ E1 = fts3RowidMethod(args);
+ }
+ else if (memcmp(E2->xRowid_signature, xRowid_signatures[xRowid_fts3auxRowidMethod_enum], sizeof(E2->xRowid_signature)) == 0) {
+ E1 = fts3auxRowidMethod(args);
+ }
+ else if (memcmp(E2->xRowid_signature, xRowid_signatures[xRowid_fts3termRowidMethod_enum], sizeof(E2->xRowid_signature)) == 0) {
+ E1 = fts3termRowidMethod(args);
+ }
+ else if (memcmp(E2->xRowid_signature, xRowid_signatures[xRowid_fts3tokRowidMethod_enum], sizeof(E2->xRowid_signature)) == 0) {
+ E1 = fts3tokRowidMethod(args);
+ }
+ else if (memcmp(E2->xRowid_signature, xRowid_signatures[xRowid_fuzzerRowid_enum], sizeof(E2->xRowid_signature)) == 0) {
+ E1 = fuzzerRowid(args);
+ }
+ else if (memcmp(E2->xRowid_signature, xRowid_signatures[xRowid_intarrayRowid_enum], sizeof(E2->xRowid_signature)) == 0) {
+ E1 = intarrayRowid(args);
+ }
+ else if (memcmp(E2->xRowid_signature, xRowid_signatures[xRowid_jsonEachRowid_enum], sizeof(E2->xRowid_signature)) == 0) {
+ E1 = jsonEachRowid(args);
+ }
+ else if (memcmp(E2->xRowid_signature, xRowid_signatures[xRowid_memstatRowid_enum], sizeof(E2->xRowid_signature)) == 0) {
+ E1 = memstatRowid(args);
+ }
+ else if (memcmp(E2->xRowid_signature, xRowid_signatures[xRowid_pragmaVtabRowid_enum], sizeof(E2->xRowid_signature)) == 0) {
+ E1 = pragmaVtabRowid(args);
+ }
+ else if (memcmp(E2->xRowid_signature, xRowid_signatures[xRowid_prefixesRowid_enum], sizeof(E2->xRowid_signature)) == 0) {
+ E1 = prefixesRowid(args);
+ }
+ else if (memcmp(E2->xRowid_signature, xRowid_signatures[xRowid_qpvtabRowid_enum], sizeof(E2->xRowid_signature)) == 0) {
+ E1 = qpvtabRowid(args);
+ }
+ else if (memcmp(E2->xRowid_signature, xRowid_signatures[xRowid_rtreeRowid_enum], sizeof(E2->xRowid_signature)) == 0) {
+ E1 = rtreeRowid(args);
+ }
+ else if (memcmp(E2->xRowid_signature, xRowid_signatures[xRowid_schemaRowid_enum], sizeof(E2->xRowid_signature)) == 0) {
+ E1 = schemaRowid(args);
+ }
+ else if (memcmp(E2->xRowid_signature, xRowid_signatures[xRowid_seriesRowid_enum], sizeof(E2->xRowid_signature)) == 0) {
+ E1 = seriesRowid(args);
+ }
+ else if (memcmp(E2->xRowid_signature, xRowid_signatures[xRowid_spellfix1Rowid_enum], sizeof(E2->xRowid_signature)) == 0) {
+ E1 = spellfix1Rowid(args);
+ }
+ else if (memcmp(E2->xRowid_signature, xRowid_signatures[xRowid_statRowid_enum], sizeof(E2->xRowid_signature)) == 0) {
+ E1 = statRowid(args);
+ }
+ else if (memcmp(E2->xRowid_signature, xRowid_signatures[xRowid_stmtRowid_enum], sizeof(E2->xRowid_signature)) == 0) {
+ E1 = stmtRowid(args);
+ }
+ else if (memcmp(E2->xRowid_signature, xRowid_signatures[xRowid_tclRowid_enum], sizeof(E2->xRowid_signature)) == 0) {
+ E1 = tclRowid(args);
+ }
+ else if (memcmp(E2->xRowid_signature, xRowid_signatures[xRowid_tclvarRowid_enum], sizeof(E2->xRowid_signature)) == 0) {
+ E1 = tclvarRowid(args);
+ }
+ else if (memcmp(E2->xRowid_signature, xRowid_signatures[xRowid_templatevtabRowid_enum], sizeof(E2->xRowid_signature)) == 0) {
+ E1 = templatevtabRowid(args);
+ }
+ else if (memcmp(E2->xRowid_signature, xRowid_signatures[xRowid_unionRowid_enum], sizeof(E2->xRowid_signature)) == 0) {
+ E1 = unionRowid(args);
+ }
+ else if (memcmp(E2->xRowid_signature, xRowid_signatures[xRowid_vlogRowid_enum], sizeof(E2->xRowid_signature)) == 0) {
+ E1 = vlogRowid(args);
+ }
+ else if (memcmp(E2->xRowid_signature, xRowid_signatures[xRowid_vstattabRowid_enum], sizeof(E2->xRowid_signature)) == 0) {
+ E1 = vstattabRowid(args);
+ }
+ else if (memcmp(E2->xRowid_signature, xRowid_signatures[xRowid_vtablogRowid_enum], sizeof(E2->xRowid_signature)) == 0) {
+ E1 = vtablogRowid(args);
+ }
+ else if (memcmp(E2->xRowid_signature, xRowid_signatures[xRowid_wholenumberRowid_enum], sizeof(E2->xRowid_signature)) == 0) {
+ E1 = wholenumberRowid(args);
+ }


// Transform E1 = E2->xSFunc(args) to if-chain with 5 candidates
@transform_assignment_xSFunc_arrow@
expression E1, E2;
identifier FP_NAME = xSFunc;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xSFunc_signature, xSFunc_signatures[xSFunc_attachFunc_enum], sizeof(E2->xSFunc_signature)) == 0) {
+ E1 = attachFunc(args);
+ }
+ else if (memcmp(E2->xSFunc_signature, xSFunc_signatures[xSFunc_detachFunc_enum], sizeof(E2->xSFunc_signature)) == 0) {
+ E1 = detachFunc(args);
+ }
+ else if (memcmp(E2->xSFunc_signature, xSFunc_signatures[xSFunc_statGet_enum], sizeof(E2->xSFunc_signature)) == 0) {
+ E1 = statGet(args);
+ }
+ else if (memcmp(E2->xSFunc_signature, xSFunc_signatures[xSFunc_statInit_enum], sizeof(E2->xSFunc_signature)) == 0) {
+ E1 = statInit(args);
+ }
+ else if (memcmp(E2->xSFunc_signature, xSFunc_signatures[xSFunc_statPush_enum], sizeof(E2->xSFunc_signature)) == 0) {
+ E1 = statPush(args);
+ }


// Transform E1 = E2->xSavepoint(args) to if-chain with 2 candidates
@transform_assignment_xSavepoint_arrow@
expression E1, E2;
identifier FP_NAME = xSavepoint;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xSavepoint_signature, xSavepoint_signatures[xSavepoint_0_enum], sizeof(E2->xSavepoint_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xSavepoint_signature, xSavepoint_signatures[xSavepoint_fts3SavepointMethod_enum], sizeof(E2->xSavepoint_signature)) == 0) {
+ E1 = fts3SavepointMethod(args);
+ }
+ else if (memcmp(E2->xSavepoint_signature, xSavepoint_signatures[xSavepoint_rtreeSavepoint_enum], sizeof(E2->xSavepoint_signature)) == 0) {
+ E1 = rtreeSavepoint(args);
+ }


// Transform E1 = E2->xSectorSize(args) to if-chain with 4 candidates
@transform_assignment_xSectorSize_arrow@
expression E1, E2;
identifier FP_NAME = xSectorSize;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xSectorSize_signature, xSectorSize_signatures[xSectorSize_0_enum], sizeof(E2->xSectorSize_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xSectorSize_signature, xSectorSize_signatures[xSectorSize_apndSectorSize_enum], sizeof(E2->xSectorSize_signature)) == 0) {
+ E1 = apndSectorSize(args);
+ }
+ else if (memcmp(E2->xSectorSize_signature, xSectorSize_signatures[xSectorSize_recoverVfsSectorSize_enum], sizeof(E2->xSectorSize_signature)) == 0) {
+ E1 = recoverVfsSectorSize(args);
+ }
+ else if (memcmp(E2->xSectorSize_signature, xSectorSize_signatures[xSectorSize_vfstraceSectorSize_enum], sizeof(E2->xSectorSize_signature)) == 0) {
+ E1 = vfstraceSectorSize(args);
+ }
+ else if (memcmp(E2->xSectorSize_signature, xSectorSize_signatures[xSectorSize_unixSectorSize_enum], sizeof(E2->xSectorSize_signature)) == 0) {
+ E1 = unixSectorSize(args);
+ }


// Transform E1 = E2->xSelectCallback(args) to if-chain with 16 candidates
@transform_assignment_xSelectCallback_arrow@
expression E1, E2;
identifier FP_NAME = xSelectCallback;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_0_enum], sizeof(E2->xSelectCallback_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_convertCompoundSelectToSubquery_enum], sizeof(E2->xSelectCallback_signature)) == 0) {
+ E1 = convertCompoundSelectToSubquery(args);
+ }
+ else if (memcmp(E2->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_exprSelectWalkTableConstant_enum], sizeof(E2->xSelectCallback_signature)) == 0) {
+ E1 = exprSelectWalkTableConstant(args);
+ }
+ else if (memcmp(E2->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_fixSelectCb_enum], sizeof(E2->xSelectCallback_signature)) == 0) {
+ E1 = fixSelectCb(args);
+ }
+ else if (memcmp(E2->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_gatherSelectWindowsSelectCallback_enum], sizeof(E2->xSelectCallback_signature)) == 0) {
+ E1 = gatherSelectWindowsSelectCallback(args);
+ }
+ else if (memcmp(E2->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_renameColumnSelectCb_enum], sizeof(E2->xSelectCallback_signature)) == 0) {
+ E1 = renameColumnSelectCb(args);
+ }
+ else if (memcmp(E2->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_renameTableSelectCb_enum], sizeof(E2->xSelectCallback_signature)) == 0) {
+ E1 = renameTableSelectCb(args);
+ }
+ else if (memcmp(E2->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_renameUnmapSelectCb_enum], sizeof(E2->xSelectCallback_signature)) == 0) {
+ E1 = renameUnmapSelectCb(args);
+ }
+ else if (memcmp(E2->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_resolveSelectStep_enum], sizeof(E2->xSelectCallback_signature)) == 0) {
+ E1 = resolveSelectStep(args);
+ }
+ else if (memcmp(E2->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_selectCheckOnClausesSelect_enum], sizeof(E2->xSelectCallback_signature)) == 0) {
+ E1 = selectCheckOnClausesSelect(args);
+ }
+ else if (memcmp(E2->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_selectExpander_enum], sizeof(E2->xSelectCallback_signature)) == 0) {
+ E1 = selectExpander(args);
+ }
+ else if (memcmp(E2->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_selectRefEnter_enum], sizeof(E2->xSelectCallback_signature)) == 0) {
+ E1 = selectRefEnter(args);
+ }
+ else if (memcmp(E2->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_selectWindowRewriteSelectCb_enum], sizeof(E2->xSelectCallback_signature)) == 0) {
+ E1 = selectWindowRewriteSelectCb(args);
+ }
+ else if (memcmp(E2->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_sqlite3ReturningSubqueryCorrelated_enum], sizeof(E2->xSelectCallback_signature)) == 0) {
+ E1 = sqlite3ReturningSubqueryCorrelated(args);
+ }
+ else if (memcmp(E2->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_sqlite3SelectWalkFail_enum], sizeof(E2->xSelectCallback_signature)) == 0) {
+ E1 = sqlite3SelectWalkFail(args);
+ }
+ else if (memcmp(E2->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_sqlite3SelectWalkNoop_enum], sizeof(E2->xSelectCallback_signature)) == 0) {
+ E1 = sqlite3SelectWalkNoop(args);
+ }
+ else if (memcmp(E2->xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_sqlite3WalkerDepthIncrease_enum], sizeof(E2->xSelectCallback_signature)) == 0) {
+ E1 = sqlite3WalkerDepthIncrease(args);
+ }


// Transform E1 = E2->xSelectCallback2(args) to if-chain with 5 candidates
@transform_assignment_xSelectCallback2_arrow@
expression E1, E2;
identifier FP_NAME = xSelectCallback2;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_0_enum], sizeof(E2->xSelectCallback2_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_selectAddSubqueryTypeInfo_enum], sizeof(E2->xSelectCallback2_signature)) == 0) {
+ E1 = selectAddSubqueryTypeInfo(args);
+ }
+ else if (memcmp(E2->xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_selectRefLeave_enum], sizeof(E2->xSelectCallback2_signature)) == 0) {
+ E1 = selectRefLeave(args);
+ }
+ else if (memcmp(E2->xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_sqlite3SelectPopWith_enum], sizeof(E2->xSelectCallback2_signature)) == 0) {
+ E1 = sqlite3SelectPopWith(args);
+ }
+ else if (memcmp(E2->xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_sqlite3WalkWinDefnDummyCallback_enum], sizeof(E2->xSelectCallback2_signature)) == 0) {
+ E1 = sqlite3WalkWinDefnDummyCallback(args);
+ }
+ else if (memcmp(E2->xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_sqlite3WalkerDepthDecrease_enum], sizeof(E2->xSelectCallback2_signature)) == 0) {
+ E1 = sqlite3WalkerDepthDecrease(args);
+ }


// Transform E1 = E2->xSetSystemCall(args) to if-chain with 5 candidates
@transform_assignment_xSetSystemCall_arrow@
expression E1, E2;
identifier FP_NAME = xSetSystemCall;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xSetSystemCall_signature, xSetSystemCall_signatures[xSetSystemCall_0_enum], sizeof(E2->xSetSystemCall_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xSetSystemCall_signature, xSetSystemCall_signatures[xSetSystemCall_apndSetSystemCall_enum], sizeof(E2->xSetSystemCall_signature)) == 0) {
+ E1 = apndSetSystemCall(args);
+ }
+ else if (memcmp(E2->xSetSystemCall_signature, xSetSystemCall_signatures[xSetSystemCall_devsymSleep_enum], sizeof(E2->xSetSystemCall_signature)) == 0) {
+ E1 = devsymSleep(args);
+ }
+ else if (memcmp(E2->xSetSystemCall_signature, xSetSystemCall_signatures[xSetSystemCall_rbuVfsSleep_enum], sizeof(E2->xSetSystemCall_signature)) == 0) {
+ E1 = rbuVfsSleep(args);
+ }
+ else if (memcmp(E2->xSetSystemCall_signature, xSetSystemCall_signatures[xSetSystemCall_tvfsSleep_enum], sizeof(E2->xSetSystemCall_signature)) == 0) {
+ E1 = tvfsSleep(args);
+ }
+ else if (memcmp(E2->xSetSystemCall_signature, xSetSystemCall_signatures[xSetSystemCall_unixSetSystemCall_enum], sizeof(E2->xSetSystemCall_signature)) == 0) {
+ E1 = unixSetSystemCall(args);
+ }


// Transform E1 = E2->xShadowName(args) to if-chain with 2 candidates
@transform_assignment_xShadowName_arrow@
expression E1, E2;
identifier FP_NAME = xShadowName;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xShadowName_signature, xShadowName_signatures[xShadowName_0_enum], sizeof(E2->xShadowName_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xShadowName_signature, xShadowName_signatures[xShadowName_fts3ShadowName_enum], sizeof(E2->xShadowName_signature)) == 0) {
+ E1 = fts3ShadowName(args);
+ }
+ else if (memcmp(E2->xShadowName_signature, xShadowName_signatures[xShadowName_rtreeShadowName_enum], sizeof(E2->xShadowName_signature)) == 0) {
+ E1 = rtreeShadowName(args);
+ }


// Transform E1 = E2->xShmBarrier(args) to if-chain with 3 candidates
@transform_assignment_xShmBarrier_arrow@
expression E1, E2;
identifier FP_NAME = xShmBarrier;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xShmBarrier_signature, xShmBarrier_signatures[xShmBarrier_0_enum], sizeof(E2->xShmBarrier_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xShmBarrier_signature, xShmBarrier_signatures[xShmBarrier_apndShmBarrier_enum], sizeof(E2->xShmBarrier_signature)) == 0) {
+ E1 = apndShmBarrier(args);
+ }
+ else if (memcmp(E2->xShmBarrier_signature, xShmBarrier_signatures[xShmBarrier_recoverVfsShmBarrier_enum], sizeof(E2->xShmBarrier_signature)) == 0) {
+ E1 = recoverVfsShmBarrier(args);
+ }
+ else if (memcmp(E2->xShmBarrier_signature, xShmBarrier_signatures[xShmBarrier_unixShmBarrier_enum], sizeof(E2->xShmBarrier_signature)) == 0) {
+ E1 = unixShmBarrier(args);
+ }


// Transform E1 = E2->xShmLock(args) to if-chain with 3 candidates
@transform_assignment_xShmLock_arrow@
expression E1, E2;
identifier FP_NAME = xShmLock;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xShmLock_signature, xShmLock_signatures[xShmLock_0_enum], sizeof(E2->xShmLock_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xShmLock_signature, xShmLock_signatures[xShmLock_apndShmLock_enum], sizeof(E2->xShmLock_signature)) == 0) {
+ E1 = apndShmLock(args);
+ }
+ else if (memcmp(E2->xShmLock_signature, xShmLock_signatures[xShmLock_recoverVfsShmLock_enum], sizeof(E2->xShmLock_signature)) == 0) {
+ E1 = recoverVfsShmLock(args);
+ }
+ else if (memcmp(E2->xShmLock_signature, xShmLock_signatures[xShmLock_unixShmLock_enum], sizeof(E2->xShmLock_signature)) == 0) {
+ E1 = unixShmLock(args);
+ }


// Transform E1 = E2->xShmMap(args) to if-chain with 3 candidates
@transform_assignment_xShmMap_arrow@
expression E1, E2;
identifier FP_NAME = xShmMap;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xShmMap_signature, xShmMap_signatures[xShmMap_0_enum], sizeof(E2->xShmMap_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xShmMap_signature, xShmMap_signatures[xShmMap_apndShmMap_enum], sizeof(E2->xShmMap_signature)) == 0) {
+ E1 = apndShmMap(args);
+ }
+ else if (memcmp(E2->xShmMap_signature, xShmMap_signatures[xShmMap_recoverVfsShmMap_enum], sizeof(E2->xShmMap_signature)) == 0) {
+ E1 = recoverVfsShmMap(args);
+ }
+ else if (memcmp(E2->xShmMap_signature, xShmMap_signatures[xShmMap_unixShmMap_enum], sizeof(E2->xShmMap_signature)) == 0) {
+ E1 = unixShmMap(args);
+ }


// Transform E1 = E2->xShmUnmap(args) to if-chain with 3 candidates
@transform_assignment_xShmUnmap_arrow@
expression E1, E2;
identifier FP_NAME = xShmUnmap;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xShmUnmap_signature, xShmUnmap_signatures[xShmUnmap_0_enum], sizeof(E2->xShmUnmap_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xShmUnmap_signature, xShmUnmap_signatures[xShmUnmap_apndShmUnmap_enum], sizeof(E2->xShmUnmap_signature)) == 0) {
+ E1 = apndShmUnmap(args);
+ }
+ else if (memcmp(E2->xShmUnmap_signature, xShmUnmap_signatures[xShmUnmap_recoverVfsShmUnmap_enum], sizeof(E2->xShmUnmap_signature)) == 0) {
+ E1 = recoverVfsShmUnmap(args);
+ }
+ else if (memcmp(E2->xShmUnmap_signature, xShmUnmap_signatures[xShmUnmap_unixShmUnmap_enum], sizeof(E2->xShmUnmap_signature)) == 0) {
+ E1 = unixShmUnmap(args);
+ }


// Transform E1 = E2->xShrink(args) to if-chain with 2 candidates
@transform_assignment_xShrink_arrow@
expression E1, E2;
identifier FP_NAME = xShrink;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xShrink_signature, xShrink_signatures[xShrink_pcache1Shrink_enum], sizeof(E2->xShrink_signature)) == 0) {
+ E1 = pcache1Shrink(args);
+ }
+ else if (memcmp(E2->xShrink_signature, xShrink_signatures[xShrink_pcachetraceShrink_enum], sizeof(E2->xShrink_signature)) == 0) {
+ E1 = pcachetraceShrink(args);
+ }


// Transform E1 = E2->xShutdown(args) to if-chain with 4 candidates
@transform_assignment_xShutdown_arrow@
expression E1, E2;
identifier FP_NAME = xShutdown;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xShutdown_signature, xShutdown_signatures[xShutdown_memtraceShutdown_enum], sizeof(E2->xShutdown_signature)) == 0) {
+ E1 = memtraceShutdown(args);
+ }
+ else if (memcmp(E2->xShutdown_signature, xShutdown_signatures[xShutdown_pcache1Shutdown_enum], sizeof(E2->xShutdown_signature)) == 0) {
+ E1 = pcache1Shutdown(args);
+ }
+ else if (memcmp(E2->xShutdown_signature, xShutdown_signatures[xShutdown_pcachetraceShutdown_enum], sizeof(E2->xShutdown_signature)) == 0) {
+ E1 = pcachetraceShutdown(args);
+ }
+ else if (memcmp(E2->xShutdown_signature, xShutdown_signatures[xShutdown_sqlite3MemShutdown_enum], sizeof(E2->xShutdown_signature)) == 0) {
+ E1 = sqlite3MemShutdown(args);
+ }


// Transform E1 = E2->xSize(args) to if-chain with 2 candidates
@transform_assignment_xSize_arrow@
expression E1, E2;
identifier FP_NAME = xSize;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xSize_signature, xSize_signatures[xSize_memtraceSize_enum], sizeof(E2->xSize_signature)) == 0) {
+ E1 = memtraceSize(args);
+ }
+ else if (memcmp(E2->xSize_signature, xSize_signatures[xSize_sqlite3MemSize_enum], sizeof(E2->xSize_signature)) == 0) {
+ E1 = sqlite3MemSize(args);
+ }


// Transform E1 = E2->xSleep(args) to if-chain with 4 candidates
@transform_assignment_xSleep_arrow@
expression E1, E2;
identifier FP_NAME = xSleep;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xSleep_signature, xSleep_signatures[xSleep_0_enum], sizeof(E2->xSleep_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xSleep_signature, xSleep_signatures[xSleep_apndSleep_enum], sizeof(E2->xSleep_signature)) == 0) {
+ E1 = apndSleep(args);
+ }
+ else if (memcmp(E2->xSleep_signature, xSleep_signatures[xSleep_memdbSleep_enum], sizeof(E2->xSleep_signature)) == 0) {
+ E1 = memdbSleep(args);
+ }
+ else if (memcmp(E2->xSleep_signature, xSleep_signatures[xSleep_vfstraceSleep_enum], sizeof(E2->xSleep_signature)) == 0) {
+ E1 = vfstraceSleep(args);
+ }
+ else if (memcmp(E2->xSleep_signature, xSleep_signatures[xSleep_unixSleep_enum], sizeof(E2->xSleep_signature)) == 0) {
+ E1 = unixSleep(args);
+ }


// Transform E1 = E2->xSync(args) to if-chain with 11 candidates
@transform_assignment_xSync_arrow@
expression E1, E2;
identifier FP_NAME = xSync;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xSync_signature, xSync_signatures[xSync_0_enum], sizeof(E2->xSync_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xSync_signature, xSync_signatures[xSync_apndSync_enum], sizeof(E2->xSync_signature)) == 0) {
+ E1 = apndSync(args);
+ }
+ else if (memcmp(E2->xSync_signature, xSync_signatures[xSync_dbpageSync_enum], sizeof(E2->xSync_signature)) == 0) {
+ E1 = dbpageSync(args);
+ }
+ else if (memcmp(E2->xSync_signature, xSync_signatures[xSync_echoSync_enum], sizeof(E2->xSync_signature)) == 0) {
+ E1 = echoSync(args);
+ }
+ else if (memcmp(E2->xSync_signature, xSync_signatures[xSync_fts3SyncMethod_enum], sizeof(E2->xSync_signature)) == 0) {
+ E1 = fts3SyncMethod(args);
+ }
+ else if (memcmp(E2->xSync_signature, xSync_signatures[xSync_memdbSync_enum], sizeof(E2->xSync_signature)) == 0) {
+ E1 = memdbSync(args);
+ }
+ else if (memcmp(E2->xSync_signature, xSync_signatures[xSync_memjrnlSync_enum], sizeof(E2->xSync_signature)) == 0) {
+ E1 = memjrnlSync(args);
+ }
+ else if (memcmp(E2->xSync_signature, xSync_signatures[xSync_recoverVfsSync_enum], sizeof(E2->xSync_signature)) == 0) {
+ E1 = recoverVfsSync(args);
+ }
+ else if (memcmp(E2->xSync_signature, xSync_signatures[xSync_rtreeEndTransaction_enum], sizeof(E2->xSync_signature)) == 0) {
+ E1 = rtreeEndTransaction(args);
+ }
+ else if (memcmp(E2->xSync_signature, xSync_signatures[xSync_vfstraceSync_enum], sizeof(E2->xSync_signature)) == 0) {
+ E1 = vfstraceSync(args);
+ }
+ else if (memcmp(E2->xSync_signature, xSync_signatures[xSync_vtablogSync_enum], sizeof(E2->xSync_signature)) == 0) {
+ E1 = vtablogSync(args);
+ }
+ else if (memcmp(E2->xSync_signature, xSync_signatures[xSync_unixSync_enum], sizeof(E2->xSync_signature)) == 0) {
+ E1 = unixSync(args);
+ }


// Transform E1 = E2->xTokenize(args) to if-chain with 3 candidates
@transform_assignment_xTokenize_arrow@
expression E1, E2;
identifier FP_NAME = xTokenize;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xTokenize_signature, xTokenize_signatures[xTokenize_0_enum], sizeof(E2->xTokenize_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xTokenize_signature, xTokenize_signatures[xTokenize_f5tOrigintextTokenize_enum], sizeof(E2->xTokenize_signature)) == 0) {
+ E1 = f5tOrigintextTokenize(args);
+ }
+ else if (memcmp(E2->xTokenize_signature, xTokenize_signatures[xTokenize_f5tTokenizerTokenize_enum], sizeof(E2->xTokenize_signature)) == 0) {
+ E1 = f5tTokenizerTokenize(args);
+ }
+ else if (memcmp(E2->xTokenize_signature, xTokenize_signatures[xTokenize_f5tTokenizerTokenize_v2_enum], sizeof(E2->xTokenize_signature)) == 0) {
+ E1 = f5tTokenizerTokenize_v2(args);
+ }


// Transform E1 = E2->xTruncate(args) to if-chain with 8 candidates
@transform_assignment_xTruncate_arrow@
expression E1, E2;
identifier FP_NAME = xTruncate;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xTruncate_signature, xTruncate_signatures[xTruncate_apndTruncate_enum], sizeof(E2->xTruncate_signature)) == 0) {
+ E1 = apndTruncate(args);
+ }
+ else if (memcmp(E2->xTruncate_signature, xTruncate_signatures[xTruncate_memdbTruncate_enum], sizeof(E2->xTruncate_signature)) == 0) {
+ E1 = memdbTruncate(args);
+ }
+ else if (memcmp(E2->xTruncate_signature, xTruncate_signatures[xTruncate_memjrnlTruncate_enum], sizeof(E2->xTruncate_signature)) == 0) {
+ E1 = memjrnlTruncate(args);
+ }
+ else if (memcmp(E2->xTruncate_signature, xTruncate_signatures[xTruncate_pcache1Truncate_enum], sizeof(E2->xTruncate_signature)) == 0) {
+ E1 = pcache1Truncate(args);
+ }
+ else if (memcmp(E2->xTruncate_signature, xTruncate_signatures[xTruncate_pcachetraceTruncate_enum], sizeof(E2->xTruncate_signature)) == 0) {
+ E1 = pcachetraceTruncate(args);
+ }
+ else if (memcmp(E2->xTruncate_signature, xTruncate_signatures[xTruncate_recoverVfsTruncate_enum], sizeof(E2->xTruncate_signature)) == 0) {
+ E1 = recoverVfsTruncate(args);
+ }
+ else if (memcmp(E2->xTruncate_signature, xTruncate_signatures[xTruncate_vfstraceTruncate_enum], sizeof(E2->xTruncate_signature)) == 0) {
+ E1 = vfstraceTruncate(args);
+ }
+ else if (memcmp(E2->xTruncate_signature, xTruncate_signatures[xTruncate_unixTruncate_enum], sizeof(E2->xTruncate_signature)) == 0) {
+ E1 = unixTruncate(args);
+ }


// Transform E1 = E2->xUnfetch(args) to if-chain with 4 candidates
@transform_assignment_xUnfetch_arrow@
expression E1, E2;
identifier FP_NAME = xUnfetch;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xUnfetch_signature, xUnfetch_signatures[xUnfetch_0_enum], sizeof(E2->xUnfetch_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xUnfetch_signature, xUnfetch_signatures[xUnfetch_apndUnfetch_enum], sizeof(E2->xUnfetch_signature)) == 0) {
+ E1 = apndUnfetch(args);
+ }
+ else if (memcmp(E2->xUnfetch_signature, xUnfetch_signatures[xUnfetch_memdbUnfetch_enum], sizeof(E2->xUnfetch_signature)) == 0) {
+ E1 = memdbUnfetch(args);
+ }
+ else if (memcmp(E2->xUnfetch_signature, xUnfetch_signatures[xUnfetch_recoverVfsUnfetch_enum], sizeof(E2->xUnfetch_signature)) == 0) {
+ E1 = recoverVfsUnfetch(args);
+ }
+ else if (memcmp(E2->xUnfetch_signature, xUnfetch_signatures[xUnfetch_unixUnfetch_enum], sizeof(E2->xUnfetch_signature)) == 0) {
+ E1 = unixUnfetch(args);
+ }


// Transform E1 = E2->xUnlock(args) to if-chain with 7 candidates
@transform_assignment_xUnlock_arrow@
expression E1, E2;
identifier FP_NAME = xUnlock;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xUnlock_signature, xUnlock_signatures[xUnlock_0_enum], sizeof(E2->xUnlock_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xUnlock_signature, xUnlock_signatures[xUnlock_apndUnlock_enum], sizeof(E2->xUnlock_signature)) == 0) {
+ E1 = apndUnlock(args);
+ }
+ else if (memcmp(E2->xUnlock_signature, xUnlock_signatures[xUnlock_memdbUnlock_enum], sizeof(E2->xUnlock_signature)) == 0) {
+ E1 = memdbUnlock(args);
+ }
+ else if (memcmp(E2->xUnlock_signature, xUnlock_signatures[xUnlock_recoverVfsUnlock_enum], sizeof(E2->xUnlock_signature)) == 0) {
+ E1 = recoverVfsUnlock(args);
+ }
+ else if (memcmp(E2->xUnlock_signature, xUnlock_signatures[xUnlock_vfstraceUnlock_enum], sizeof(E2->xUnlock_signature)) == 0) {
+ E1 = vfstraceUnlock(args);
+ }
+ else if (memcmp(E2->xUnlock_signature, xUnlock_signatures[xUnlock_unixUnlock_enum], sizeof(E2->xUnlock_signature)) == 0) {
+ E1 = unixUnlock(args);
+ }
+ else if (memcmp(E2->xUnlock_signature, xUnlock_signatures[xUnlock_nolockUnlock_enum], sizeof(E2->xUnlock_signature)) == 0) {
+ E1 = nolockUnlock(args);
+ }
+ else if (memcmp(E2->xUnlock_signature, xUnlock_signatures[xUnlock_dotlockUnlock_enum], sizeof(E2->xUnlock_signature)) == 0) {
+ E1 = dotlockUnlock(args);
+ }


// Transform E1 = E2->xUnpin(args) to if-chain with 2 candidates
@transform_assignment_xUnpin_arrow@
expression E1, E2;
identifier FP_NAME = xUnpin;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xUnpin_signature, xUnpin_signatures[xUnpin_pcache1Unpin_enum], sizeof(E2->xUnpin_signature)) == 0) {
+ E1 = pcache1Unpin(args);
+ }
+ else if (memcmp(E2->xUnpin_signature, xUnpin_signatures[xUnpin_pcachetraceUnpin_enum], sizeof(E2->xUnpin_signature)) == 0) {
+ E1 = pcachetraceUnpin(args);
+ }


// Transform E1 = E2->xUpdate(args) to if-chain with 13 candidates
@transform_assignment_xUpdate_arrow@
expression E1, E2;
identifier FP_NAME = xUpdate;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xUpdate_signature, xUpdate_signatures[xUpdate_0_enum], sizeof(E2->xUpdate_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2->xUpdate_signature, xUpdate_signatures[xUpdate_amatchUpdate_enum], sizeof(E2->xUpdate_signature)) == 0) {
+ E1 = amatchUpdate(args);
+ }
+ else if (memcmp(E2->xUpdate_signature, xUpdate_signatures[xUpdate_csvtabUpdate_enum], sizeof(E2->xUpdate_signature)) == 0) {
+ E1 = csvtabUpdate(args);
+ }
+ else if (memcmp(E2->xUpdate_signature, xUpdate_signatures[xUpdate_dbpageUpdate_enum], sizeof(E2->xUpdate_signature)) == 0) {
+ E1 = dbpageUpdate(args);
+ }
+ else if (memcmp(E2->xUpdate_signature, xUpdate_signatures[xUpdate_echoUpdate_enum], sizeof(E2->xUpdate_signature)) == 0) {
+ E1 = echoUpdate(args);
+ }
+ else if (memcmp(E2->xUpdate_signature, xUpdate_signatures[xUpdate_expertUpdate_enum], sizeof(E2->xUpdate_signature)) == 0) {
+ E1 = expertUpdate(args);
+ }
+ else if (memcmp(E2->xUpdate_signature, xUpdate_signatures[xUpdate_fts3UpdateMethod_enum], sizeof(E2->xUpdate_signature)) == 0) {
+ E1 = fts3UpdateMethod(args);
+ }
+ else if (memcmp(E2->xUpdate_signature, xUpdate_signatures[xUpdate_geopolyUpdate_enum], sizeof(E2->xUpdate_signature)) == 0) {
+ E1 = geopolyUpdate(args);
+ }
+ else if (memcmp(E2->xUpdate_signature, xUpdate_signatures[xUpdate_rtreeUpdate_enum], sizeof(E2->xUpdate_signature)) == 0) {
+ E1 = rtreeUpdate(args);
+ }
+ else if (memcmp(E2->xUpdate_signature, xUpdate_signatures[xUpdate_spellfix1Update_enum], sizeof(E2->xUpdate_signature)) == 0) {
+ E1 = spellfix1Update(args);
+ }
+ else if (memcmp(E2->xUpdate_signature, xUpdate_signatures[xUpdate_tclvarUpdate_enum], sizeof(E2->xUpdate_signature)) == 0) {
+ E1 = tclvarUpdate(args);
+ }
+ else if (memcmp(E2->xUpdate_signature, xUpdate_signatures[xUpdate_vstattabUpdate_enum], sizeof(E2->xUpdate_signature)) == 0) {
+ E1 = vstattabUpdate(args);
+ }
+ else if (memcmp(E2->xUpdate_signature, xUpdate_signatures[xUpdate_vtablogUpdate_enum], sizeof(E2->xUpdate_signature)) == 0) {
+ E1 = vtablogUpdate(args);
+ }
+ else if (memcmp(E2->xUpdate_signature, xUpdate_signatures[xUpdate_zipfileUpdate_enum], sizeof(E2->xUpdate_signature)) == 0) {
+ E1 = zipfileUpdate(args);
+ }


// Transform E1 = E2->xWrite(args) to if-chain with 7 candidates
@transform_assignment_xWrite_arrow@
expression E1, E2;
identifier FP_NAME = xWrite;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xWrite_signature, xWrite_signatures[xWrite_apndWrite_enum], sizeof(E2->xWrite_signature)) == 0) {
+ E1 = apndWrite(args);
+ }
+ else if (memcmp(E2->xWrite_signature, xWrite_signatures[xWrite_kvstorageWrite_enum], sizeof(E2->xWrite_signature)) == 0) {
+ E1 = kvstorageWrite(args);
+ }
+ else if (memcmp(E2->xWrite_signature, xWrite_signatures[xWrite_memdbWrite_enum], sizeof(E2->xWrite_signature)) == 0) {
+ E1 = memdbWrite(args);
+ }
+ else if (memcmp(E2->xWrite_signature, xWrite_signatures[xWrite_memjrnlWrite_enum], sizeof(E2->xWrite_signature)) == 0) {
+ E1 = memjrnlWrite(args);
+ }
+ else if (memcmp(E2->xWrite_signature, xWrite_signatures[xWrite_recoverVfsWrite_enum], sizeof(E2->xWrite_signature)) == 0) {
+ E1 = recoverVfsWrite(args);
+ }
+ else if (memcmp(E2->xWrite_signature, xWrite_signatures[xWrite_vfstraceWrite_enum], sizeof(E2->xWrite_signature)) == 0) {
+ E1 = vfstraceWrite(args);
+ }
+ else if (memcmp(E2->xWrite_signature, xWrite_signatures[xWrite_unixWrite_enum], sizeof(E2->xWrite_signature)) == 0) {
+ E1 = unixWrite(args);
+ }


// Transform E1 = E2->xsnprintf(args) to if-chain with 1 candidates
@transform_assignment_xsnprintf_arrow@
expression E1, E2;
identifier FP_NAME = xsnprintf;
expression list args;
@@
- E1 = E2->FP_NAME(args);
+ if (memcmp(E2->xsnprintf_signature, xsnprintf_signatures[xsnprintf_sqlite3_set_authorizer_enum], sizeof(E2->xsnprintf_signature)) == 0) {
+ E1 = sqlite3_set_authorizer(args);
+ }

// Total assignment transformation rules generated: 321
// ===== ASSIGNMENT FUNCTION POINTER TRANSFORMATION RULES (DOT) =====

// Transform E1 = E2.aggregate_context(args) to direct call (only 1 candidate)
@transform_assignment_aggregate_context@
expression E1, E2;
identifier FP_NAME = aggregate_context;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_aggregate_context(args);


// Transform E1 = E2.auto_extension(args) to direct call (only 1 candidate)
@transform_assignment_auto_extension@
expression E1, E2;
identifier FP_NAME = auto_extension;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_vtab_config(args);


// Transform E1 = E2.backup_finish(args) to direct call (only 1 candidate)
@transform_assignment_backup_finish@
expression E1, E2;
identifier FP_NAME = backup_finish;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_result_error_code(args);


// Transform E1 = E2.backup_init(args) to direct call (only 1 candidate)
@transform_assignment_backup_init@
expression E1, E2;
identifier FP_NAME = backup_init;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_test_control(args);


// Transform E1 = E2.backup_pagecount(args) to direct call (only 1 candidate)
@transform_assignment_backup_pagecount@
expression E1, E2;
identifier FP_NAME = backup_pagecount;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_randomness(args);


// Transform E1 = E2.backup_remaining(args) to direct call (only 1 candidate)
@transform_assignment_backup_remaining@
expression E1, E2;
identifier FP_NAME = backup_remaining;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_context_db_handle(args);


// Transform E1 = E2.backup_step(args) to direct call (only 1 candidate)
@transform_assignment_backup_step@
expression E1, E2;
identifier FP_NAME = backup_step;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_extended_result_codes(args);


// Transform E1 = E2.bind_blob64(args) to direct call (only 1 candidate)
@transform_assignment_bind_blob64@
expression E1, E2;
identifier FP_NAME = bind_blob64;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_vtab_on_conflict(args);


// Transform E1 = E2.bind_int(args) to direct call (only 1 candidate)
@transform_assignment_bind_int@
expression E1, E2;
identifier FP_NAME = bind_int;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_bind_double(args);


// Transform E1 = E2.bind_int64(args) to direct call (only 1 candidate)
@transform_assignment_bind_int64@
expression E1, E2;
identifier FP_NAME = bind_int64;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_bind_int(args);


// Transform E1 = E2.bind_null(args) to direct call (only 1 candidate)
@transform_assignment_bind_null@
expression E1, E2;
identifier FP_NAME = bind_null;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_bind_int64(args);


// Transform E1 = E2.bind_parameter_count(args) to direct call (only 1 candidate)
@transform_assignment_bind_parameter_count@
expression E1, E2;
identifier FP_NAME = bind_parameter_count;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_bind_null(args);


// Transform E1 = E2.bind_parameter_index(args) to direct call (only 1 candidate)
@transform_assignment_bind_parameter_index@
expression E1, E2;
identifier FP_NAME = bind_parameter_index;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_bind_parameter_count(args);


// Transform E1 = E2.bind_parameter_name(args) to direct call (only 1 candidate)
@transform_assignment_bind_parameter_name@
expression E1, E2;
identifier FP_NAME = bind_parameter_name;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_bind_parameter_index(args);


// Transform E1 = E2.bind_text(args) to direct call (only 1 candidate)
@transform_assignment_bind_text@
expression E1, E2;
identifier FP_NAME = bind_text;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_bind_parameter_name(args);


// Transform E1 = E2.bind_text16(args) to direct call (only 1 candidate)
@transform_assignment_bind_text16@
expression E1, E2;
identifier FP_NAME = bind_text16;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_bind_text(args);


// Transform E1 = E2.bind_text64(args) to direct call (only 1 candidate)
@transform_assignment_bind_text64@
expression E1, E2;
identifier FP_NAME = bind_text64;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_close_v2(args);


// Transform E1 = E2.bind_value(args) to direct call (only 1 candidate)
@transform_assignment_bind_value@
expression E1, E2;
identifier FP_NAME = bind_value;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_bind_text16(args);


// Transform E1 = E2.bind_zeroblob(args) to direct call (only 1 candidate)
@transform_assignment_bind_zeroblob@
expression E1, E2;
identifier FP_NAME = bind_zeroblob;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_prepare_v2(args);


// Transform E1 = E2.bind_zeroblob64(args) to direct call (only 1 candidate)
@transform_assignment_bind_zeroblob64@
expression E1, E2;
identifier FP_NAME = bind_zeroblob64;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_auto_extension(args);


// Transform E1 = E2.blob_bytes(args) to direct call (only 1 candidate)
@transform_assignment_blob_bytes@
expression E1, E2;
identifier FP_NAME = blob_bytes;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_prepare16_v2(args);


// Transform E1 = E2.blob_close(args) to direct call (only 1 candidate)
@transform_assignment_blob_close@
expression E1, E2;
identifier FP_NAME = blob_close;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_clear_bindings(args);


// Transform E1 = E2.blob_open(args) to direct call (only 1 candidate)
@transform_assignment_blob_open@
expression E1, E2;
identifier FP_NAME = blob_open;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_create_module_v2(args);


// Transform E1 = E2.blob_read(args) to direct call (only 1 candidate)
@transform_assignment_blob_read@
expression E1, E2;
identifier FP_NAME = blob_read;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_bind_zeroblob(args);


// Transform E1 = E2.blob_reopen(args) to direct call (only 1 candidate)
@transform_assignment_blob_reopen@
expression E1, E2;
identifier FP_NAME = blob_reopen;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_db_status(args);


// Transform E1 = E2.blob_write(args) to direct call (only 1 candidate)
@transform_assignment_blob_write@
expression E1, E2;
identifier FP_NAME = blob_write;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_blob_bytes(args);


// Transform E1 = E2.busy_handler(args) to direct call (only 1 candidate)
@transform_assignment_busy_handler@
expression E1, E2;
identifier FP_NAME = busy_handler;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_bind_value(args);


// Transform E1 = E2.busy_timeout(args) to direct call (only 1 candidate)
@transform_assignment_busy_timeout@
expression E1, E2;
identifier FP_NAME = busy_timeout;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_busy_handler(args);


// Transform E1 = E2.cancel_auto_extension(args) to direct call (only 1 candidate)
@transform_assignment_cancel_auto_extension@
expression E1, E2;
identifier FP_NAME = cancel_auto_extension;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_db_filename(args);


// Transform E1 = E2.changes(args) to direct call (only 1 candidate)
@transform_assignment_changes@
expression E1, E2;
identifier FP_NAME = changes;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_busy_timeout(args);


// Transform E1 = E2.changes64(args) to direct call (only 1 candidate)
@transform_assignment_changes64@
expression E1, E2;
identifier FP_NAME = changes64;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_str_value(args);


// Transform E1 = E2.clear_bindings(args) to direct call (only 1 candidate)
@transform_assignment_clear_bindings@
expression E1, E2;
identifier FP_NAME = clear_bindings;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_vmprintf(args);


// Transform E1 = E2.close(args) to direct call (only 1 candidate)
@transform_assignment_close@
expression E1, E2;
identifier FP_NAME = close;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_changes(args);


// Transform E1 = E2.close_v2(args) to direct call (only 1 candidate)
@transform_assignment_close_v2@
expression E1, E2;
identifier FP_NAME = close_v2;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_soft_heap_limit64(args);


// Transform E1 = E2.collation_needed(args) to direct call (only 1 candidate)
@transform_assignment_collation_needed@
expression E1, E2;
identifier FP_NAME = collation_needed;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_close(args);


// Transform E1 = E2.collation_needed16(args) to direct call (only 1 candidate)
@transform_assignment_collation_needed16@
expression E1, E2;
identifier FP_NAME = collation_needed16;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_collation_needed(args);


// Transform E1 = E2.column_blob(args) to direct call (only 1 candidate)
@transform_assignment_column_blob@
expression E1, E2;
identifier FP_NAME = column_blob;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_collation_needed16(args);


// Transform E1 = E2.column_bytes(args) to direct call (only 1 candidate)
@transform_assignment_column_bytes@
expression E1, E2;
identifier FP_NAME = column_bytes;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_column_blob(args);


// Transform E1 = E2.column_bytes16(args) to direct call (only 1 candidate)
@transform_assignment_column_bytes16@
expression E1, E2;
identifier FP_NAME = column_bytes16;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_column_bytes(args);


// Transform E1 = E2.column_count(args) to direct call (only 1 candidate)
@transform_assignment_column_count@
expression E1, E2;
identifier FP_NAME = column_count;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_column_bytes16(args);


// Transform E1 = E2.column_database_name(args) to direct call (only 1 candidate)
@transform_assignment_column_database_name@
expression E1, E2;
identifier FP_NAME = column_database_name;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_column_count(args);


// Transform E1 = E2.column_database_name16(args) to direct call (only 1 candidate)
@transform_assignment_column_database_name16@
expression E1, E2;
identifier FP_NAME = column_database_name16;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_column_database_name(args);


// Transform E1 = E2.column_decltype(args) to direct call (only 1 candidate)
@transform_assignment_column_decltype@
expression E1, E2;
identifier FP_NAME = column_decltype;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_column_database_name16(args);


// Transform E1 = E2.column_decltype16(args) to direct call (only 1 candidate)
@transform_assignment_column_decltype16@
expression E1, E2;
identifier FP_NAME = column_decltype16;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_column_decltype(args);


// Transform E1 = E2.column_double(args) to direct call (only 1 candidate)
@transform_assignment_column_double@
expression E1, E2;
identifier FP_NAME = column_double;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_column_decltype16(args);


// Transform E1 = E2.column_int(args) to direct call (only 1 candidate)
@transform_assignment_column_int@
expression E1, E2;
identifier FP_NAME = column_int;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_column_double(args);


// Transform E1 = E2.column_int64(args) to direct call (only 1 candidate)
@transform_assignment_column_int64@
expression E1, E2;
identifier FP_NAME = column_int64;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_column_int(args);


// Transform E1 = E2.column_name(args) to direct call (only 1 candidate)
@transform_assignment_column_name@
expression E1, E2;
identifier FP_NAME = column_name;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_column_int64(args);


// Transform E1 = E2.column_name16(args) to direct call (only 1 candidate)
@transform_assignment_column_name16@
expression E1, E2;
identifier FP_NAME = column_name16;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_column_name(args);


// Transform E1 = E2.column_origin_name(args) to direct call (only 1 candidate)
@transform_assignment_column_origin_name@
expression E1, E2;
identifier FP_NAME = column_origin_name;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_column_name16(args);


// Transform E1 = E2.column_origin_name16(args) to direct call (only 1 candidate)
@transform_assignment_column_origin_name16@
expression E1, E2;
identifier FP_NAME = column_origin_name16;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_column_origin_name(args);


// Transform E1 = E2.column_table_name(args) to direct call (only 1 candidate)
@transform_assignment_column_table_name@
expression E1, E2;
identifier FP_NAME = column_table_name;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_column_origin_name16(args);


// Transform E1 = E2.column_table_name16(args) to direct call (only 1 candidate)
@transform_assignment_column_table_name16@
expression E1, E2;
identifier FP_NAME = column_table_name16;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_column_table_name(args);


// Transform E1 = E2.column_text(args) to direct call (only 1 candidate)
@transform_assignment_column_text@
expression E1, E2;
identifier FP_NAME = column_text;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_column_table_name16(args);


// Transform E1 = E2.column_text16(args) to direct call (only 1 candidate)
@transform_assignment_column_text16@
expression E1, E2;
identifier FP_NAME = column_text16;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_column_text(args);


// Transform E1 = E2.column_type(args) to direct call (only 1 candidate)
@transform_assignment_column_type@
expression E1, E2;
identifier FP_NAME = column_type;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_column_text16(args);


// Transform E1 = E2.column_value(args) to direct call (only 1 candidate)
@transform_assignment_column_value@
expression E1, E2;
identifier FP_NAME = column_value;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_column_type(args);


// Transform E1 = E2.commit_hook(args) to direct call (only 1 candidate)
@transform_assignment_commit_hook@
expression E1, E2;
identifier FP_NAME = commit_hook;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_column_value(args);


// Transform E1 = E2.compileoption_get(args) to direct call (only 1 candidate)
@transform_assignment_compileoption_get@
expression E1, E2;
identifier FP_NAME = compileoption_get;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_limit(args);


// Transform E1 = E2.compileoption_used(args) to direct call (only 1 candidate)
@transform_assignment_compileoption_used@
expression E1, E2;
identifier FP_NAME = compileoption_used;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_next_stmt(args);


// Transform E1 = E2.complete(args) to direct call (only 1 candidate)
@transform_assignment_complete@
expression E1, E2;
identifier FP_NAME = complete;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_commit_hook(args);


// Transform E1 = E2.complete16(args) to direct call (only 1 candidate)
@transform_assignment_complete16@
expression E1, E2;
identifier FP_NAME = complete16;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_complete(args);


// Transform E1 = E2.context_db_handle(args) to direct call (only 1 candidate)
@transform_assignment_context_db_handle@
expression E1, E2;
identifier FP_NAME = context_db_handle;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_soft_heap_limit(args);


// Transform E1 = E2.create_collation(args) to direct call (only 1 candidate)
@transform_assignment_create_collation@
expression E1, E2;
identifier FP_NAME = create_collation;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_complete16(args);


// Transform E1 = E2.create_collation16(args) to direct call (only 1 candidate)
@transform_assignment_create_collation16@
expression E1, E2;
identifier FP_NAME = create_collation16;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_create_collation(args);


// Transform E1 = E2.create_collation_v2(args) to direct call (only 1 candidate)
@transform_assignment_create_collation_v2@
expression E1, E2;
identifier FP_NAME = create_collation_v2;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_blob_close(args);


// Transform E1 = E2.create_filename(args) to direct call (only 1 candidate)
@transform_assignment_create_filename@
expression E1, E2;
identifier FP_NAME = create_filename;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_str_appendchar(args);


// Transform E1 = E2.create_function(args) to direct call (only 1 candidate)
@transform_assignment_create_function@
expression E1, E2;
identifier FP_NAME = create_function;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_create_collation16(args);


// Transform E1 = E2.create_function16(args) to direct call (only 1 candidate)
@transform_assignment_create_function16@
expression E1, E2;
identifier FP_NAME = create_function16;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_create_function(args);


// Transform E1 = E2.create_function_v2(args) to direct call (only 1 candidate)
@transform_assignment_create_function_v2@
expression E1, E2;
identifier FP_NAME = create_function_v2;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_sql(args);


// Transform E1 = E2.create_module(args) to direct call (only 1 candidate)
@transform_assignment_create_module@
expression E1, E2;
identifier FP_NAME = create_module;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_create_function16(args);


// Transform E1 = E2.create_module_v2(args) to direct call (only 1 candidate)
@transform_assignment_create_module_v2@
expression E1, E2;
identifier FP_NAME = create_module_v2;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_overload_function(args);


// Transform E1 = E2.create_window_function(args) to direct call (only 1 candidate)
@transform_assignment_create_window_function@
expression E1, E2;
identifier FP_NAME = create_window_function;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_vtab_collation(args);


// Transform E1 = E2.data_count(args) to direct call (only 1 candidate)
@transform_assignment_data_count@
expression E1, E2;
identifier FP_NAME = data_count;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_create_module(args);


// Transform E1 = E2.database_file_object(args) to direct call (only 1 candidate)
@transform_assignment_database_file_object@
expression E1, E2;
identifier FP_NAME = database_file_object;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_str_errcode(args);


// Transform E1 = E2.db_cacheflush(args) to direct call (only 1 candidate)
@transform_assignment_db_cacheflush@
expression E1, E2;
identifier FP_NAME = db_cacheflush;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_malloc64(args);


// Transform E1 = E2.db_config(args) to direct call (only 1 candidate)
@transform_assignment_db_config@
expression E1, E2;
identifier FP_NAME = db_config;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_status(args);


// Transform E1 = E2.db_filename(args) to direct call (only 1 candidate)
@transform_assignment_db_filename@
expression E1, E2;
identifier FP_NAME = db_filename;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_sourceid(args);


// Transform E1 = E2.db_handle(args) to direct call (only 1 candidate)
@transform_assignment_db_handle@
expression E1, E2;
identifier FP_NAME = db_handle;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_data_count(args);


// Transform E1 = E2.db_mutex(args) to direct call (only 1 candidate)
@transform_assignment_db_mutex@
expression E1, E2;
identifier FP_NAME = db_mutex;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_backup_finish(args);


// Transform E1 = E2.db_name(args) to direct call (only 1 candidate)
@transform_assignment_db_name@
expression E1, E2;
identifier FP_NAME = db_name;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_filename_journal(args);


// Transform E1 = E2.db_readonly(args) to direct call (only 1 candidate)
@transform_assignment_db_readonly@
expression E1, E2;
identifier FP_NAME = db_readonly;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_stmt_status(args);


// Transform E1 = E2.db_release_memory(args) to direct call (only 1 candidate)
@transform_assignment_db_release_memory@
expression E1, E2;
identifier FP_NAME = db_release_memory;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_strnicmp(args);


// Transform E1 = E2.db_status(args) to direct call (only 1 candidate)
@transform_assignment_db_status@
expression E1, E2;
identifier FP_NAME = db_status;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_backup_init(args);


// Transform E1 = E2.declare_vtab(args) to direct call (only 1 candidate)
@transform_assignment_declare_vtab@
expression E1, E2;
identifier FP_NAME = declare_vtab;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_db_handle(args);


// Transform E1 = E2.deserialize(args) to direct call (only 1 candidate)
@transform_assignment_deserialize@
expression E1, E2;
identifier FP_NAME = deserialize;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_uri_key(args);


// Transform E1 = E2.drop_modules(args) to direct call (only 1 candidate)
@transform_assignment_drop_modules@
expression E1, E2;
identifier FP_NAME = drop_modules;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_str_new(args);


// Transform E1 = E2.enable_shared_cache(args) to direct call (only 1 candidate)
@transform_assignment_enable_shared_cache@
expression E1, E2;
identifier FP_NAME = enable_shared_cache;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_declare_vtab(args);


// Transform E1 = E2.errcode(args) to direct call (only 1 candidate)
@transform_assignment_errcode@
expression E1, E2;
identifier FP_NAME = errcode;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_enable_shared_cache(args);


// Transform E1 = E2.errmsg(args) to direct call (only 1 candidate)
@transform_assignment_errmsg@
expression E1, E2;
identifier FP_NAME = errmsg;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_errcode(args);


// Transform E1 = E2.errmsg16(args) to direct call (only 1 candidate)
@transform_assignment_errmsg16@
expression E1, E2;
identifier FP_NAME = errmsg16;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_errmsg(args);


// Transform E1 = E2.exec(args) to direct call (only 1 candidate)
@transform_assignment_exec@
expression E1, E2;
identifier FP_NAME = exec;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_errmsg16(args);


// Transform E1 = E2.expanded_sql(args) to direct call (only 1 candidate)
@transform_assignment_expanded_sql@
expression E1, E2;
identifier FP_NAME = expanded_sql;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_reset_auto_extension(args);


// Transform E1 = E2.expired(args) to direct call (only 1 candidate)
@transform_assignment_expired@
expression E1, E2;
identifier FP_NAME = expired;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_exec(args);


// Transform E1 = E2.extended_errcode(args) to direct call (only 1 candidate)
@transform_assignment_extended_errcode@
expression E1, E2;
identifier FP_NAME = extended_errcode;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_backup_pagecount(args);


// Transform E1 = E2.extended_result_codes(args) to direct call (only 1 candidate)
@transform_assignment_extended_result_codes@
expression E1, E2;
identifier FP_NAME = extended_result_codes;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_vfs_find(args);


// Transform E1 = E2.file_control(args) to direct call (only 1 candidate)
@transform_assignment_file_control@
expression E1, E2;
identifier FP_NAME = file_control;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_blob_open(args);


// Transform E1 = E2.filename_database(args) to direct call (only 1 candidate)
@transform_assignment_filename_database@
expression E1, E2;
identifier FP_NAME = filename_database;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_str_vappendf(args);


// Transform E1 = E2.filename_journal(args) to direct call (only 1 candidate)
@transform_assignment_filename_journal@
expression E1, E2;
identifier FP_NAME = filename_journal;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_str_append(args);


// Transform E1 = E2.filename_wal(args) to direct call (only 1 candidate)
@transform_assignment_filename_wal@
expression E1, E2;
identifier FP_NAME = filename_wal;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_str_appendall(args);


// Transform E1 = E2.free_filename(args) to direct call (only 1 candidate)
@transform_assignment_free_filename@
expression E1, E2;
identifier FP_NAME = free_filename;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_str_reset(args);


// Transform E1 = E2.get_autocommit(args) to direct call (only 1 candidate)
@transform_assignment_get_autocommit@
expression E1, E2;
identifier FP_NAME = get_autocommit;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_free(args);


// Transform E1 = E2.get_auxdata(args) to direct call (only 1 candidate)
@transform_assignment_get_auxdata@
expression E1, E2;
identifier FP_NAME = get_auxdata;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_free_table(args);


// Transform E1 = E2.get_clientdata(args) to direct call (only 1 candidate)
@transform_assignment_get_clientdata@
expression E1, E2;
identifier FP_NAME = get_clientdata;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_database_file_object(args);


// Transform E1 = E2.get_table(args) to direct call (only 1 candidate)
@transform_assignment_get_table@
expression E1, E2;
identifier FP_NAME = get_table;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_get_autocommit(args);


// Transform E1 = E2.global_recover(args) to direct call (only 1 candidate)
@transform_assignment_global_recover@
expression E1, E2;
identifier FP_NAME = global_recover;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_get_auxdata(args);


// Transform E1 = E2.hard_heap_limit64(args) to direct call (only 1 candidate)
@transform_assignment_hard_heap_limit64@
expression E1, E2;
identifier FP_NAME = hard_heap_limit64;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_str_finish(args);


// Transform E1 = E2.interruptx(args) to direct call (only 1 candidate)
@transform_assignment_interruptx@
expression E1, E2;
identifier FP_NAME = interruptx;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_get_table(args);


// Transform E1 = E2.is_interrupted(args) to direct call (only 1 candidate)
@transform_assignment_is_interrupted@
expression E1, E2;
identifier FP_NAME = is_interrupted;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_create_filename(args);


// Transform E1 = E2.keyword_check(args) to direct call (only 1 candidate)
@transform_assignment_keyword_check@
expression E1, E2;
identifier FP_NAME = keyword_check;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_db_cacheflush(args);


// Transform E1 = E2.keyword_count(args) to direct call (only 1 candidate)
@transform_assignment_keyword_count@
expression E1, E2;
identifier FP_NAME = keyword_count;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_status64(args);


// Transform E1 = E2.keyword_name(args) to direct call (only 1 candidate)
@transform_assignment_keyword_name@
expression E1, E2;
identifier FP_NAME = keyword_name;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_strlike(args);


// Transform E1 = E2.libversion(args) to direct call (only 1 candidate)
@transform_assignment_libversion@
expression E1, E2;
identifier FP_NAME = libversion;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_interrupt(args);


// Transform E1 = E2.libversion_number(args) to direct call (only 1 candidate)
@transform_assignment_libversion_number@
expression E1, E2;
identifier FP_NAME = libversion_number;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_last_insert_rowid(args);


// Transform E1 = E2.limit(args) to direct call (only 1 candidate)
@transform_assignment_limit@
expression E1, E2;
identifier FP_NAME = limit;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_vfs_register(args);


// Transform E1 = E2.load_extension(args) to direct call (only 1 candidate)
@transform_assignment_load_extension@
expression E1, E2;
identifier FP_NAME = load_extension;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_db_readonly(args);


// Transform E1 = E2.log(args) to direct call (only 1 candidate)
@transform_assignment_log@
expression E1, E2;
identifier FP_NAME = log;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_backup_remaining(args);


// Transform E1 = E2.malloc(args) to direct call (only 1 candidate)
@transform_assignment_malloc@
expression E1, E2;
identifier FP_NAME = malloc;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_libversion(args);


// Transform E1 = E2.malloc64(args) to direct call (only 1 candidate)
@transform_assignment_malloc64@
expression E1, E2;
identifier FP_NAME = malloc64;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_db_release_memory(args);


// Transform E1 = E2.memory_highwater(args) to direct call (only 1 candidate)
@transform_assignment_memory_highwater@
expression E1, E2;
identifier FP_NAME = memory_highwater;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_blob_read(args);


// Transform E1 = E2.memory_used(args) to direct call (only 1 candidate)
@transform_assignment_memory_used@
expression E1, E2;
identifier FP_NAME = memory_used;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_blob_write(args);


// Transform E1 = E2.mprintf(args) to direct call (only 1 candidate)
@transform_assignment_mprintf@
expression E1, E2;
identifier FP_NAME = mprintf;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_libversion_number(args);


// Transform E1 = E2.msize(args) to direct call (only 1 candidate)
@transform_assignment_msize@
expression E1, E2;
identifier FP_NAME = msize;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_errstr(args);


// Transform E1 = E2.mutex_alloc(args) to direct call (only 1 candidate)
@transform_assignment_mutex_alloc@
expression E1, E2;
identifier FP_NAME = mutex_alloc;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_create_collation_v2(args);


// Transform E1 = E2.mutex_enter(args) to direct call (only 1 candidate)
@transform_assignment_mutex_enter@
expression E1, E2;
identifier FP_NAME = mutex_enter;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_file_control(args);


// Transform E1 = E2.mutex_free(args) to direct call (only 1 candidate)
@transform_assignment_mutex_free@
expression E1, E2;
identifier FP_NAME = mutex_free;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_memory_highwater(args);


// Transform E1 = E2.mutex_leave(args) to direct call (only 1 candidate)
@transform_assignment_mutex_leave@
expression E1, E2;
identifier FP_NAME = mutex_leave;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_memory_used(args);


// Transform E1 = E2.next_stmt(args) to direct call (only 1 candidate)
@transform_assignment_next_stmt@
expression E1, E2;
identifier FP_NAME = next_stmt;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_vfs_unregister(args);


// Transform E1 = E2.normalized_sql(args) to direct call (only 1 candidate)
@transform_assignment_normalized_sql@
expression E1, E2;
identifier FP_NAME = normalized_sql;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_keyword_count(args);


// Transform E1 = E2.open(args) to direct call (only 1 candidate)
@transform_assignment_open@
expression E1, E2;
identifier FP_NAME = open;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_malloc(args);


// Transform E1 = E2.open16(args) to direct call (only 1 candidate)
@transform_assignment_open16@
expression E1, E2;
identifier FP_NAME = open16;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_mprintf(args);


// Transform E1 = E2.overload_function(args) to direct call (only 1 candidate)
@transform_assignment_overload_function@
expression E1, E2;
identifier FP_NAME = overload_function;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_value_text16be(args);


// Transform E1 = E2.prepare(args) to direct call (only 1 candidate)
@transform_assignment_prepare@
expression E1, E2;
identifier FP_NAME = prepare;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_open(args);


// Transform E1 = E2.prepare16(args) to direct call (only 1 candidate)
@transform_assignment_prepare16@
expression E1, E2;
identifier FP_NAME = prepare16;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_open16(args);


// Transform E1 = E2.prepare16_v2(args) to direct call (only 1 candidate)
@transform_assignment_prepare16_v2@
expression E1, E2;
identifier FP_NAME = prepare16_v2;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_value_type(args);


// Transform E1 = E2.prepare16_v3(args) to direct call (only 1 candidate)
@transform_assignment_prepare16_v3@
expression E1, E2;
identifier FP_NAME = prepare16_v3;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_strglob(args);


// Transform E1 = E2.prepare_v2(args) to direct call (only 1 candidate)
@transform_assignment_prepare_v2@
expression E1, E2;
identifier FP_NAME = prepare_v2;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_value_text16le(args);


// Transform E1 = E2.prepare_v3(args) to direct call (only 1 candidate)
@transform_assignment_prepare_v3@
expression E1, E2;
identifier FP_NAME = prepare_v3;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_result_text64(args);


// Transform E1 = E2.profile(args) to direct call (only 1 candidate)
@transform_assignment_profile@
expression E1, E2;
identifier FP_NAME = profile;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_prepare(args);


// Transform E1 = E2.progress_handler(args) to direct call (only 1 candidate)
@transform_assignment_progress_handler@
expression E1, E2;
identifier FP_NAME = progress_handler;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_prepare16(args);


// Transform E1 = E2.randomness(args) to direct call (only 1 candidate)
@transform_assignment_randomness@
expression E1, E2;
identifier FP_NAME = randomness;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_sleep(args);


// Transform E1 = E2.realloc(args) to direct call (only 1 candidate)
@transform_assignment_realloc@
expression E1, E2;
identifier FP_NAME = realloc;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_profile(args);


// Transform E1 = E2.realloc64(args) to direct call (only 1 candidate)
@transform_assignment_realloc64@
expression E1, E2;
identifier FP_NAME = realloc64;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_stmt_busy(args);


// Transform E1 = E2.reset(args) to direct call (only 1 candidate)
@transform_assignment_reset@
expression E1, E2;
identifier FP_NAME = reset;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_progress_handler(args);


// Transform E1 = E2.reset_auto_extension(args) to direct call (only 1 candidate)
@transform_assignment_reset_auto_extension@
expression E1, E2;
identifier FP_NAME = reset_auto_extension;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_stmt_readonly(args);


// Transform E1 = E2.result_blob(args) to direct call (only 1 candidate)
@transform_assignment_result_blob@
expression E1, E2;
identifier FP_NAME = result_blob;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_realloc(args);


// Transform E1 = E2.result_blob64(args) to direct call (only 1 candidate)
@transform_assignment_result_blob64@
expression E1, E2;
identifier FP_NAME = result_blob64;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_stricmp(args);


// Transform E1 = E2.result_double(args) to direct call (only 1 candidate)
@transform_assignment_result_double@
expression E1, E2;
identifier FP_NAME = result_double;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_reset(args);


// Transform E1 = E2.result_error(args) to direct call (only 1 candidate)
@transform_assignment_result_error@
expression E1, E2;
identifier FP_NAME = result_error;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_result_blob(args);


// Transform E1 = E2.result_error16(args) to direct call (only 1 candidate)
@transform_assignment_result_error16@
expression E1, E2;
identifier FP_NAME = result_error16;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_result_double(args);


// Transform E1 = E2.result_error_code(args) to direct call (only 1 candidate)
@transform_assignment_result_error_code@
expression E1, E2;
identifier FP_NAME = result_error_code;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_result_error_nomem(args);


// Transform E1 = E2.result_int(args) to direct call (only 1 candidate)
@transform_assignment_result_int@
expression E1, E2;
identifier FP_NAME = result_int;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_result_error(args);


// Transform E1 = E2.result_int64(args) to direct call (only 1 candidate)
@transform_assignment_result_int64@
expression E1, E2;
identifier FP_NAME = result_int64;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_result_error16(args);


// Transform E1 = E2.result_null(args) to direct call (only 1 candidate)
@transform_assignment_result_null@
expression E1, E2;
identifier FP_NAME = result_null;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_result_int(args);


// Transform E1 = E2.result_pointer(args) to direct call (only 1 candidate)
@transform_assignment_result_pointer@
expression E1, E2;
identifier FP_NAME = result_pointer;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_value_free(args);


// Transform E1 = E2.result_subtype(args) to direct call (only 1 candidate)
@transform_assignment_result_subtype@
expression E1, E2;
identifier FP_NAME = result_subtype;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_bind_text64(args);


// Transform E1 = E2.result_text(args) to direct call (only 1 candidate)
@transform_assignment_result_text@
expression E1, E2;
identifier FP_NAME = result_text;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_result_int64(args);


// Transform E1 = E2.result_text16(args) to direct call (only 1 candidate)
@transform_assignment_result_text16@
expression E1, E2;
identifier FP_NAME = result_text16;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_result_null(args);


// Transform E1 = E2.result_text16be(args) to direct call (only 1 candidate)
@transform_assignment_result_text16be@
expression E1, E2;
identifier FP_NAME = result_text16be;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_result_text(args);


// Transform E1 = E2.result_text16le(args) to direct call (only 1 candidate)
@transform_assignment_result_text16le@
expression E1, E2;
identifier FP_NAME = result_text16le;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_result_text16(args);


// Transform E1 = E2.result_text64(args) to direct call (only 1 candidate)
@transform_assignment_result_text64@
expression E1, E2;
identifier FP_NAME = result_text64;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_uri_boolean(args);


// Transform E1 = E2.result_value(args) to direct call (only 1 candidate)
@transform_assignment_result_value@
expression E1, E2;
identifier FP_NAME = result_value;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_result_text16be(args);


// Transform E1 = E2.result_zeroblob(args) to direct call (only 1 candidate)
@transform_assignment_result_zeroblob@
expression E1, E2;
identifier FP_NAME = result_zeroblob;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_release_memory(args);


// Transform E1 = E2.result_zeroblob64(args) to direct call (only 1 candidate)
@transform_assignment_result_zeroblob64@
expression E1, E2;
identifier FP_NAME = result_zeroblob64;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_wal_checkpoint_v2(args);


// Transform E1 = E2.rollback_hook(args) to direct call (only 1 candidate)
@transform_assignment_rollback_hook@
expression E1, E2;
identifier FP_NAME = rollback_hook;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_result_text16le(args);


// Transform E1 = E2.serialize(args) to direct call (only 1 candidate)
@transform_assignment_serialize@
expression E1, E2;
identifier FP_NAME = serialize;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_filename_database(args);


// Transform E1 = E2.set_authorizer(args) to direct call (only 1 candidate)
@transform_assignment_set_authorizer@
expression E1, E2;
identifier FP_NAME = set_authorizer;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_result_value(args);


// Transform E1 = E2.set_auxdata(args) to direct call (only 1 candidate)
@transform_assignment_set_auxdata@
expression E1, E2;
identifier FP_NAME = set_auxdata;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_rollback_hook(args);


// Transform E1 = E2.set_clientdata(args) to direct call (only 1 candidate)
@transform_assignment_set_clientdata@
expression E1, E2;
identifier FP_NAME = set_clientdata;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_txn_state(args);


// Transform E1 = E2.set_last_insert_rowid(args) to direct call (only 1 candidate)
@transform_assignment_set_last_insert_rowid@
expression E1, E2;
identifier FP_NAME = set_last_insert_rowid;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_result_blob64(args);


// Transform E1 = E2.setlk_timeout(args) to direct call (only 1 candidate)
@transform_assignment_setlk_timeout@
expression E1, E2;
identifier FP_NAME = setlk_timeout;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_changes64(args);


// Transform E1 = E2.soft_heap_limit(args) to direct call (only 1 candidate)
@transform_assignment_soft_heap_limit@
expression E1, E2;
identifier FP_NAME = soft_heap_limit;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_mutex_enter(args);


// Transform E1 = E2.soft_heap_limit64(args) to direct call (only 1 candidate)
@transform_assignment_soft_heap_limit64@
expression E1, E2;
identifier FP_NAME = soft_heap_limit64;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_backup_step(args);


// Transform E1 = E2.sql(args) to direct call (only 1 candidate)
@transform_assignment_sql@
expression E1, E2;
identifier FP_NAME = sql;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_threadsafe(args);


// Transform E1 = E2.status(args) to direct call (only 1 candidate)
@transform_assignment_status@
expression E1, E2;
identifier FP_NAME = status;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_result_zeroblob(args);


// Transform E1 = E2.status64(args) to direct call (only 1 candidate)
@transform_assignment_status64@
expression E1, E2;
identifier FP_NAME = status64;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_cancel_auto_extension(args);


// Transform E1 = E2.step(args) to direct call (only 1 candidate)
@transform_assignment_step@
expression E1, E2;
identifier FP_NAME = step;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_set_auxdata(args);


// Transform E1 = E2.stmt_explain(args) to direct call (only 1 candidate)
@transform_assignment_stmt_explain@
expression E1, E2;
identifier FP_NAME = stmt_explain;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_free_filename(args);


// Transform E1 = E2.stmt_isexplain(args) to direct call (only 1 candidate)
@transform_assignment_stmt_isexplain@
expression E1, E2;
identifier FP_NAME = stmt_isexplain;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_keyword_name(args);


// Transform E1 = E2.stmt_status(args) to direct call (only 1 candidate)
@transform_assignment_stmt_status@
expression E1, E2;
identifier FP_NAME = stmt_status;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_compileoption_used(args);


// Transform E1 = E2.str_append(args) to direct call (only 1 candidate)
@transform_assignment_str_append@
expression E1, E2;
identifier FP_NAME = str_append;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_prepare_v3(args);


// Transform E1 = E2.str_appendall(args) to direct call (only 1 candidate)
@transform_assignment_str_appendall@
expression E1, E2;
identifier FP_NAME = str_appendall;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_prepare16_v3(args);


// Transform E1 = E2.str_appendchar(args) to direct call (only 1 candidate)
@transform_assignment_str_appendchar@
expression E1, E2;
identifier FP_NAME = str_appendchar;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_bind_pointer(args);


// Transform E1 = E2.str_appendf(args) to direct call (only 1 candidate)
@transform_assignment_str_appendf@
expression E1, E2;
identifier FP_NAME = str_appendf;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_expanded_sql(args);


// Transform E1 = E2.str_errcode(args) to direct call (only 1 candidate)
@transform_assignment_str_errcode@
expression E1, E2;
identifier FP_NAME = str_errcode;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_value_pointer(args);


// Transform E1 = E2.str_finish(args) to direct call (only 1 candidate)
@transform_assignment_str_finish@
expression E1, E2;
identifier FP_NAME = str_finish;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_trace_v2(args);


// Transform E1 = E2.str_length(args) to direct call (only 1 candidate)
@transform_assignment_str_length@
expression E1, E2;
identifier FP_NAME = str_length;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_vtab_nochange(args);


// Transform E1 = E2.str_new(args) to direct call (only 1 candidate)
@transform_assignment_str_new@
expression E1, E2;
identifier FP_NAME = str_new;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_system_errno(args);


// Transform E1 = E2.str_reset(args) to direct call (only 1 candidate)
@transform_assignment_str_reset@
expression E1, E2;
identifier FP_NAME = str_reset;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_result_pointer(args);


// Transform E1 = E2.str_value(args) to direct call (only 1 candidate)
@transform_assignment_str_value@
expression E1, E2;
identifier FP_NAME = str_value;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_value_nochange(args);


// Transform E1 = E2.str_vappendf(args) to direct call (only 1 candidate)
@transform_assignment_str_vappendf@
expression E1, E2;
identifier FP_NAME = str_vappendf;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_set_last_insert_rowid(args);


// Transform E1 = E2.strglob(args) to direct call (only 1 candidate)
@transform_assignment_strglob@
expression E1, E2;
identifier FP_NAME = strglob;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_uri_int64(args);


// Transform E1 = E2.stricmp(args) to direct call (only 1 candidate)
@transform_assignment_stricmp@
expression E1, E2;
identifier FP_NAME = stricmp;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_wal_checkpoint(args);


// Transform E1 = E2.strlike(args) to direct call (only 1 candidate)
@transform_assignment_strlike@
expression E1, E2;
identifier FP_NAME = strlike;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_load_extension(args);


// Transform E1 = E2.system_errno(args) to direct call (only 1 candidate)
@transform_assignment_system_errno@
expression E1, E2;
identifier FP_NAME = system_errno;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_msize(args);


// Transform E1 = E2.table_column_metadata(args) to direct call (only 1 candidate)
@transform_assignment_table_column_metadata@
expression E1, E2;
identifier FP_NAME = table_column_metadata;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_snprintf(args);


// Transform E1 = E2.test_control(args) to direct call (only 1 candidate)
@transform_assignment_test_control@
expression E1, E2;
identifier FP_NAME = test_control;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_result_error_toobig(args);


// Transform E1 = E2.thread_cleanup(args) to direct call (only 1 candidate)
@transform_assignment_thread_cleanup@
expression E1, E2;
identifier FP_NAME = thread_cleanup;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_step(args);


// Transform E1 = E2.total_changes(args) to direct call (only 1 candidate)
@transform_assignment_total_changes@
expression E1, E2;
identifier FP_NAME = total_changes;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_table_column_metadata(args);


// Transform E1 = E2.total_changes64(args) to direct call (only 1 candidate)
@transform_assignment_total_changes64@
expression E1, E2;
identifier FP_NAME = total_changes64;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_create_window_function(args);


// Transform E1 = E2.trace_v2(args) to direct call (only 1 candidate)
@transform_assignment_trace_v2@
expression E1, E2;
identifier FP_NAME = trace_v2;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_realloc64(args);


// Transform E1 = E2.txn_state(args) to direct call (only 1 candidate)
@transform_assignment_txn_state@
expression E1, E2;
identifier FP_NAME = txn_state;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_str_length(args);


// Transform E1 = E2.uri_boolean(args) to direct call (only 1 candidate)
@transform_assignment_uri_boolean@
expression E1, E2;
identifier FP_NAME = uri_boolean;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_wal_hook(args);


// Transform E1 = E2.uri_key(args) to direct call (only 1 candidate)
@transform_assignment_uri_key@
expression E1, E2;
identifier FP_NAME = uri_key;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_str_appendf(args);


// Transform E1 = E2.user_data(args) to direct call (only 1 candidate)
@transform_assignment_user_data@
expression E1, E2;
identifier FP_NAME = user_data;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_trace(args);


// Transform E1 = E2.value_double(args) to direct call (only 1 candidate)
@transform_assignment_value_double@
expression E1, E2;
identifier FP_NAME = value_double;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_user_data(args);


// Transform E1 = E2.value_dup(args) to direct call (only 1 candidate)
@transform_assignment_value_dup@
expression E1, E2;
identifier FP_NAME = value_dup;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_uri_parameter(args);


// Transform E1 = E2.value_encoding(args) to direct call (only 1 candidate)
@transform_assignment_value_encoding@
expression E1, E2;
identifier FP_NAME = value_encoding;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_filename_wal(args);


// Transform E1 = E2.value_free(args) to direct call (only 1 candidate)
@transform_assignment_value_free@
expression E1, E2;
identifier FP_NAME = value_free;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_vsnprintf(args);


// Transform E1 = E2.value_frombind(args) to direct call (only 1 candidate)
@transform_assignment_value_frombind@
expression E1, E2;
identifier FP_NAME = value_frombind;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_keyword_check(args);


// Transform E1 = E2.value_int(args) to direct call (only 1 candidate)
@transform_assignment_value_int@
expression E1, E2;
identifier FP_NAME = value_int;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_value_blob(args);


// Transform E1 = E2.value_int64(args) to direct call (only 1 candidate)
@transform_assignment_value_int64@
expression E1, E2;
identifier FP_NAME = value_int64;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_value_bytes(args);


// Transform E1 = E2.value_nochange(args) to direct call (only 1 candidate)
@transform_assignment_value_nochange@
expression E1, E2;
identifier FP_NAME = value_nochange;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_value_subtype(args);


// Transform E1 = E2.value_numeric_type(args) to direct call (only 1 candidate)
@transform_assignment_value_numeric_type@
expression E1, E2;
identifier FP_NAME = value_numeric_type;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_value_bytes16(args);


// Transform E1 = E2.value_pointer(args) to direct call (only 1 candidate)
@transform_assignment_value_pointer@
expression E1, E2;
identifier FP_NAME = value_pointer;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_result_zeroblob64(args);


// Transform E1 = E2.value_subtype(args) to direct call (only 1 candidate)
@transform_assignment_value_subtype@
expression E1, E2;
identifier FP_NAME = value_subtype;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_bind_blob64(args);


// Transform E1 = E2.value_text(args) to direct call (only 1 candidate)
@transform_assignment_value_text@
expression E1, E2;
identifier FP_NAME = value_text;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_value_double(args);


// Transform E1 = E2.value_text16(args) to direct call (only 1 candidate)
@transform_assignment_value_text16@
expression E1, E2;
identifier FP_NAME = value_text16;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_value_int(args);


// Transform E1 = E2.value_text16be(args) to direct call (only 1 candidate)
@transform_assignment_value_text16be@
expression E1, E2;
identifier FP_NAME = value_text16be;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_value_int64(args);


// Transform E1 = E2.value_text16le(args) to direct call (only 1 candidate)
@transform_assignment_value_text16le@
expression E1, E2;
identifier FP_NAME = value_text16le;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_value_numeric_type(args);


// Transform E1 = E2.value_type(args) to direct call (only 1 candidate)
@transform_assignment_value_type@
expression E1, E2;
identifier FP_NAME = value_type;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_value_text(args);


// Transform E1 = E2.vfs_find(args) to direct call (only 1 candidate)
@transform_assignment_vfs_find@
expression E1, E2;
identifier FP_NAME = vfs_find;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_mutex_free(args);


// Transform E1 = E2.vfs_register(args) to direct call (only 1 candidate)
@transform_assignment_vfs_register@
expression E1, E2;
identifier FP_NAME = vfs_register;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_mutex_leave(args);


// Transform E1 = E2.vfs_unregister(args) to direct call (only 1 candidate)
@transform_assignment_vfs_unregister@
expression E1, E2;
identifier FP_NAME = vfs_unregister;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_mutex_try(args);


// Transform E1 = E2.vmprintf(args) to direct call (only 1 candidate)
@transform_assignment_vmprintf@
expression E1, E2;
identifier FP_NAME = vmprintf;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_value_text16(args);


// Transform E1 = E2.vtab_collation(args) to direct call (only 1 candidate)
@transform_assignment_vtab_collation@
expression E1, E2;
identifier FP_NAME = vtab_collation;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_result_subtype(args);


// Transform E1 = E2.vtab_config(args) to direct call (only 1 candidate)
@transform_assignment_vtab_config@
expression E1, E2;
identifier FP_NAME = vtab_config;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_extended_errcode(args);


// Transform E1 = E2.vtab_distinct(args) to direct call (only 1 candidate)
@transform_assignment_vtab_distinct@
expression E1, E2;
identifier FP_NAME = vtab_distinct;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_value_frombind(args);


// Transform E1 = E2.vtab_nochange(args) to direct call (only 1 candidate)
@transform_assignment_vtab_nochange@
expression E1, E2;
identifier FP_NAME = vtab_nochange;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_bind_zeroblob64(args);


// Transform E1 = E2.vtab_on_conflict(args) to direct call (only 1 candidate)
@transform_assignment_vtab_on_conflict@
expression E1, E2;
identifier FP_NAME = vtab_on_conflict;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_log(args);


// Transform E1 = E2.wal_checkpoint(args) to direct call (only 1 candidate)
@transform_assignment_wal_checkpoint@
expression E1, E2;
identifier FP_NAME = wal_checkpoint;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_db_config(args);


// Transform E1 = E2.wal_hook(args) to direct call (only 1 candidate)
@transform_assignment_wal_hook@
expression E1, E2;
identifier FP_NAME = wal_hook;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ E1 = sqlite3_db_mutex(args);


// Transform E1 = E2.xAccess(args) to if-chain with 4 candidates
@transform_assignment_xAccess@
expression E1, E2;
identifier FP_NAME = xAccess;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xAccess_signature, xAccess_signatures[xAccess_apndAccess_enum], sizeof(E2.xAccess_signature)) == 0) {
+ E1 = apndAccess(args);
+ }
+ else if (memcmp(E2.xAccess_signature, xAccess_signatures[xAccess_memdbAccess_enum], sizeof(E2.xAccess_signature)) == 0) {
+ E1 = memdbAccess(args);
+ }
+ else if (memcmp(E2.xAccess_signature, xAccess_signatures[xAccess_vfstraceAccess_enum], sizeof(E2.xAccess_signature)) == 0) {
+ E1 = vfstraceAccess(args);
+ }
+ else if (memcmp(E2.xAccess_signature, xAccess_signatures[xAccess_unixAccess_enum], sizeof(E2.xAccess_signature)) == 0) {
+ E1 = unixAccess(args);
+ }


// Transform E1 = E2.xBegin(args) to if-chain with 4 candidates
@transform_assignment_xBegin@
expression E1, E2;
identifier FP_NAME = xBegin;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xBegin_signature, xBegin_signatures[xBegin_0_enum], sizeof(E2.xBegin_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xBegin_signature, xBegin_signatures[xBegin_dbpageBegin_enum], sizeof(E2.xBegin_signature)) == 0) {
+ E1 = dbpageBegin(args);
+ }
+ else if (memcmp(E2.xBegin_signature, xBegin_signatures[xBegin_fts3BeginMethod_enum], sizeof(E2.xBegin_signature)) == 0) {
+ E1 = fts3BeginMethod(args);
+ }
+ else if (memcmp(E2.xBegin_signature, xBegin_signatures[xBegin_rtreeBeginTransaction_enum], sizeof(E2.xBegin_signature)) == 0) {
+ E1 = rtreeBeginTransaction(args);
+ }
+ else if (memcmp(E2.xBegin_signature, xBegin_signatures[xBegin_zipfileBegin_enum], sizeof(E2.xBegin_signature)) == 0) {
+ E1 = zipfileBegin(args);
+ }


// Transform E1 = E2.xBestIndex(args) to if-chain with 16 candidates
@transform_assignment_xBestIndex@
expression E1, E2;
identifier FP_NAME = xBestIndex;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xBestIndex_signature, xBestIndex_signatures[xBestIndex_bytecodevtabBestIndex_enum], sizeof(E2.xBestIndex_signature)) == 0) {
+ E1 = bytecodevtabBestIndex(args);
+ }
+ else if (memcmp(E2.xBestIndex_signature, xBestIndex_signatures[xBestIndex_completionBestIndex_enum], sizeof(E2.xBestIndex_signature)) == 0) {
+ E1 = completionBestIndex(args);
+ }
+ else if (memcmp(E2.xBestIndex_signature, xBestIndex_signatures[xBestIndex_dbdataBestIndex_enum], sizeof(E2.xBestIndex_signature)) == 0) {
+ E1 = dbdataBestIndex(args);
+ }
+ else if (memcmp(E2.xBestIndex_signature, xBestIndex_signatures[xBestIndex_dbpageBestIndex_enum], sizeof(E2.xBestIndex_signature)) == 0) {
+ E1 = dbpageBestIndex(args);
+ }
+ else if (memcmp(E2.xBestIndex_signature, xBestIndex_signatures[xBestIndex_expertBestIndex_enum], sizeof(E2.xBestIndex_signature)) == 0) {
+ E1 = expertBestIndex(args);
+ }
+ else if (memcmp(E2.xBestIndex_signature, xBestIndex_signatures[xBestIndex_fsdirBestIndex_enum], sizeof(E2.xBestIndex_signature)) == 0) {
+ E1 = fsdirBestIndex(args);
+ }
+ else if (memcmp(E2.xBestIndex_signature, xBestIndex_signatures[xBestIndex_fts3BestIndexMethod_enum], sizeof(E2.xBestIndex_signature)) == 0) {
+ E1 = fts3BestIndexMethod(args);
+ }
+ else if (memcmp(E2.xBestIndex_signature, xBestIndex_signatures[xBestIndex_fts3auxBestIndexMethod_enum], sizeof(E2.xBestIndex_signature)) == 0) {
+ E1 = fts3auxBestIndexMethod(args);
+ }
+ else if (memcmp(E2.xBestIndex_signature, xBestIndex_signatures[xBestIndex_fts3tokBestIndexMethod_enum], sizeof(E2.xBestIndex_signature)) == 0) {
+ E1 = fts3tokBestIndexMethod(args);
+ }
+ else if (memcmp(E2.xBestIndex_signature, xBestIndex_signatures[xBestIndex_jsonEachBestIndex_enum], sizeof(E2.xBestIndex_signature)) == 0) {
+ E1 = jsonEachBestIndex(args);
+ }
+ else if (memcmp(E2.xBestIndex_signature, xBestIndex_signatures[xBestIndex_pragmaVtabBestIndex_enum], sizeof(E2.xBestIndex_signature)) == 0) {
+ E1 = pragmaVtabBestIndex(args);
+ }
+ else if (memcmp(E2.xBestIndex_signature, xBestIndex_signatures[xBestIndex_rtreeBestIndex_enum], sizeof(E2.xBestIndex_signature)) == 0) {
+ E1 = rtreeBestIndex(args);
+ }
+ else if (memcmp(E2.xBestIndex_signature, xBestIndex_signatures[xBestIndex_seriesBestIndex_enum], sizeof(E2.xBestIndex_signature)) == 0) {
+ E1 = seriesBestIndex(args);
+ }
+ else if (memcmp(E2.xBestIndex_signature, xBestIndex_signatures[xBestIndex_statBestIndex_enum], sizeof(E2.xBestIndex_signature)) == 0) {
+ E1 = statBestIndex(args);
+ }
+ else if (memcmp(E2.xBestIndex_signature, xBestIndex_signatures[xBestIndex_stmtBestIndex_enum], sizeof(E2.xBestIndex_signature)) == 0) {
+ E1 = stmtBestIndex(args);
+ }
+ else if (memcmp(E2.xBestIndex_signature, xBestIndex_signatures[xBestIndex_zipfileBestIndex_enum], sizeof(E2.xBestIndex_signature)) == 0) {
+ E1 = zipfileBestIndex(args);
+ }


// Transform E1 = E2.xCachesize(args) to if-chain with 2 candidates
@transform_assignment_xCachesize@
expression E1, E2;
identifier FP_NAME = xCachesize;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xCachesize_signature, xCachesize_signatures[xCachesize_pcache1Cachesize_enum], sizeof(E2.xCachesize_signature)) == 0) {
+ E1 = pcache1Cachesize(args);
+ }
+ else if (memcmp(E2.xCachesize_signature, xCachesize_signatures[xCachesize_pcachetraceCachesize_enum], sizeof(E2.xCachesize_signature)) == 0) {
+ E1 = pcachetraceCachesize(args);
+ }


// Transform E1 = E2.xCellSize(args) to if-chain with 4 candidates
@transform_assignment_xCellSize@
expression E1, E2;
identifier FP_NAME = xCellSize;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xCellSize_signature, xCellSize_signatures[xCellSize_cellSizePtr_enum], sizeof(E2.xCellSize_signature)) == 0) {
+ E1 = cellSizePtr(args);
+ }
+ else if (memcmp(E2.xCellSize_signature, xCellSize_signatures[xCellSize_cellSizePtrIdxLeaf_enum], sizeof(E2.xCellSize_signature)) == 0) {
+ E1 = cellSizePtrIdxLeaf(args);
+ }
+ else if (memcmp(E2.xCellSize_signature, xCellSize_signatures[xCellSize_cellSizePtrNoPayload_enum], sizeof(E2.xCellSize_signature)) == 0) {
+ E1 = cellSizePtrNoPayload(args);
+ }
+ else if (memcmp(E2.xCellSize_signature, xCellSize_signatures[xCellSize_cellSizePtrTableLeaf_enum], sizeof(E2.xCellSize_signature)) == 0) {
+ E1 = cellSizePtrTableLeaf(args);
+ }


// Transform E1 = E2.xCheckReservedLock(args) to if-chain with 6 candidates
@transform_assignment_xCheckReservedLock@
expression E1, E2;
identifier FP_NAME = xCheckReservedLock;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xCheckReservedLock_signature, xCheckReservedLock_signatures[xCheckReservedLock_0_enum], sizeof(E2.xCheckReservedLock_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xCheckReservedLock_signature, xCheckReservedLock_signatures[xCheckReservedLock_apndCheckReservedLock_enum], sizeof(E2.xCheckReservedLock_signature)) == 0) {
+ E1 = apndCheckReservedLock(args);
+ }
+ else if (memcmp(E2.xCheckReservedLock_signature, xCheckReservedLock_signatures[xCheckReservedLock_recoverVfsCheckReservedLock_enum], sizeof(E2.xCheckReservedLock_signature)) == 0) {
+ E1 = recoverVfsCheckReservedLock(args);
+ }
+ else if (memcmp(E2.xCheckReservedLock_signature, xCheckReservedLock_signatures[xCheckReservedLock_vfstraceCheckReservedLock_enum], sizeof(E2.xCheckReservedLock_signature)) == 0) {
+ E1 = vfstraceCheckReservedLock(args);
+ }
+ else if (memcmp(E2.xCheckReservedLock_signature, xCheckReservedLock_signatures[xCheckReservedLock_unixCheckReservedLock_enum], sizeof(E2.xCheckReservedLock_signature)) == 0) {
+ E1 = unixCheckReservedLock(args);
+ }
+ else if (memcmp(E2.xCheckReservedLock_signature, xCheckReservedLock_signatures[xCheckReservedLock_nolockCheckReservedLock_enum], sizeof(E2.xCheckReservedLock_signature)) == 0) {
+ E1 = nolockCheckReservedLock(args);
+ }
+ else if (memcmp(E2.xCheckReservedLock_signature, xCheckReservedLock_signatures[xCheckReservedLock_dotlockCheckReservedLock_enum], sizeof(E2.xCheckReservedLock_signature)) == 0) {
+ E1 = dotlockCheckReservedLock(args);
+ }


// Transform E1 = E2.xClose(args) to if-chain with 27 candidates
@transform_assignment_xClose@
expression E1, E2;
identifier FP_NAME = xClose;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xClose_signature, xClose_signatures[xClose_apndClose_enum], sizeof(E2.xClose_signature)) == 0) {
+ E1 = apndClose(args);
+ }
+ else if (memcmp(E2.xClose_signature, xClose_signatures[xClose_bytecodevtabClose_enum], sizeof(E2.xClose_signature)) == 0) {
+ E1 = bytecodevtabClose(args);
+ }
+ else if (memcmp(E2.xClose_signature, xClose_signatures[xClose_completionClose_enum], sizeof(E2.xClose_signature)) == 0) {
+ E1 = completionClose(args);
+ }
+ else if (memcmp(E2.xClose_signature, xClose_signatures[xClose_dbdataClose_enum], sizeof(E2.xClose_signature)) == 0) {
+ E1 = dbdataClose(args);
+ }
+ else if (memcmp(E2.xClose_signature, xClose_signatures[xClose_dbpageClose_enum], sizeof(E2.xClose_signature)) == 0) {
+ E1 = dbpageClose(args);
+ }
+ else if (memcmp(E2.xClose_signature, xClose_signatures[xClose_expertClose_enum], sizeof(E2.xClose_signature)) == 0) {
+ E1 = expertClose(args);
+ }
+ else if (memcmp(E2.xClose_signature, xClose_signatures[xClose_fsdirClose_enum], sizeof(E2.xClose_signature)) == 0) {
+ E1 = fsdirClose(args);
+ }
+ else if (memcmp(E2.xClose_signature, xClose_signatures[xClose_fts3CloseMethod_enum], sizeof(E2.xClose_signature)) == 0) {
+ E1 = fts3CloseMethod(args);
+ }
+ else if (memcmp(E2.xClose_signature, xClose_signatures[xClose_fts3auxCloseMethod_enum], sizeof(E2.xClose_signature)) == 0) {
+ E1 = fts3auxCloseMethod(args);
+ }
+ else if (memcmp(E2.xClose_signature, xClose_signatures[xClose_fts3tokCloseMethod_enum], sizeof(E2.xClose_signature)) == 0) {
+ E1 = fts3tokCloseMethod(args);
+ }
+ else if (memcmp(E2.xClose_signature, xClose_signatures[xClose_jsonEachClose_enum], sizeof(E2.xClose_signature)) == 0) {
+ E1 = jsonEachClose(args);
+ }
+ else if (memcmp(E2.xClose_signature, xClose_signatures[xClose_memdbClose_enum], sizeof(E2.xClose_signature)) == 0) {
+ E1 = memdbClose(args);
+ }
+ else if (memcmp(E2.xClose_signature, xClose_signatures[xClose_memjrnlClose_enum], sizeof(E2.xClose_signature)) == 0) {
+ E1 = memjrnlClose(args);
+ }
+ else if (memcmp(E2.xClose_signature, xClose_signatures[xClose_porterClose_enum], sizeof(E2.xClose_signature)) == 0) {
+ E1 = porterClose(args);
+ }
+ else if (memcmp(E2.xClose_signature, xClose_signatures[xClose_pragmaVtabClose_enum], sizeof(E2.xClose_signature)) == 0) {
+ E1 = pragmaVtabClose(args);
+ }
+ else if (memcmp(E2.xClose_signature, xClose_signatures[xClose_recoverVfsClose_enum], sizeof(E2.xClose_signature)) == 0) {
+ E1 = recoverVfsClose(args);
+ }
+ else if (memcmp(E2.xClose_signature, xClose_signatures[xClose_rtreeClose_enum], sizeof(E2.xClose_signature)) == 0) {
+ E1 = rtreeClose(args);
+ }
+ else if (memcmp(E2.xClose_signature, xClose_signatures[xClose_seriesClose_enum], sizeof(E2.xClose_signature)) == 0) {
+ E1 = seriesClose(args);
+ }
+ else if (memcmp(E2.xClose_signature, xClose_signatures[xClose_simpleClose_enum], sizeof(E2.xClose_signature)) == 0) {
+ E1 = simpleClose(args);
+ }
+ else if (memcmp(E2.xClose_signature, xClose_signatures[xClose_statClose_enum], sizeof(E2.xClose_signature)) == 0) {
+ E1 = statClose(args);
+ }
+ else if (memcmp(E2.xClose_signature, xClose_signatures[xClose_stmtClose_enum], sizeof(E2.xClose_signature)) == 0) {
+ E1 = stmtClose(args);
+ }
+ else if (memcmp(E2.xClose_signature, xClose_signatures[xClose_unicodeClose_enum], sizeof(E2.xClose_signature)) == 0) {
+ E1 = unicodeClose(args);
+ }
+ else if (memcmp(E2.xClose_signature, xClose_signatures[xClose_vfstraceClose_enum], sizeof(E2.xClose_signature)) == 0) {
+ E1 = vfstraceClose(args);
+ }
+ else if (memcmp(E2.xClose_signature, xClose_signatures[xClose_zipfileClose_enum], sizeof(E2.xClose_signature)) == 0) {
+ E1 = zipfileClose(args);
+ }
+ else if (memcmp(E2.xClose_signature, xClose_signatures[xClose_unixClose_enum], sizeof(E2.xClose_signature)) == 0) {
+ E1 = unixClose(args);
+ }
+ else if (memcmp(E2.xClose_signature, xClose_signatures[xClose_nolockClose_enum], sizeof(E2.xClose_signature)) == 0) {
+ E1 = nolockClose(args);
+ }
+ else if (memcmp(E2.xClose_signature, xClose_signatures[xClose_dotlockClose_enum], sizeof(E2.xClose_signature)) == 0) {
+ E1 = dotlockClose(args);
+ }


// Transform E1 = E2.xColumn(args) to if-chain with 44 candidates
@transform_assignment_xColumn@
expression E1, E2;
identifier FP_NAME = xColumn;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xColumn_signature, xColumn_signatures[xColumn_amatchColumn_enum], sizeof(E2.xColumn_signature)) == 0) {
+ E1 = amatchColumn(args);
+ }
+ else if (memcmp(E2.xColumn_signature, xColumn_signatures[xColumn_binfoColumn_enum], sizeof(E2.xColumn_signature)) == 0) {
+ E1 = binfoColumn(args);
+ }
+ else if (memcmp(E2.xColumn_signature, xColumn_signatures[xColumn_bytecodevtabColumn_enum], sizeof(E2.xColumn_signature)) == 0) {
+ E1 = bytecodevtabColumn(args);
+ }
+ else if (memcmp(E2.xColumn_signature, xColumn_signatures[xColumn_carrayColumn_enum], sizeof(E2.xColumn_signature)) == 0) {
+ E1 = carrayColumn(args);
+ }
+ else if (memcmp(E2.xColumn_signature, xColumn_signatures[xColumn_cidxColumn_enum], sizeof(E2.xColumn_signature)) == 0) {
+ E1 = cidxColumn(args);
+ }
+ else if (memcmp(E2.xColumn_signature, xColumn_signatures[xColumn_closureColumn_enum], sizeof(E2.xColumn_signature)) == 0) {
+ E1 = closureColumn(args);
+ }
+ else if (memcmp(E2.xColumn_signature, xColumn_signatures[xColumn_completionColumn_enum], sizeof(E2.xColumn_signature)) == 0) {
+ E1 = completionColumn(args);
+ }
+ else if (memcmp(E2.xColumn_signature, xColumn_signatures[xColumn_csvtabColumn_enum], sizeof(E2.xColumn_signature)) == 0) {
+ E1 = csvtabColumn(args);
+ }
+ else if (memcmp(E2.xColumn_signature, xColumn_signatures[xColumn_dbdataColumn_enum], sizeof(E2.xColumn_signature)) == 0) {
+ E1 = dbdataColumn(args);
+ }
+ else if (memcmp(E2.xColumn_signature, xColumn_signatures[xColumn_dbpageColumn_enum], sizeof(E2.xColumn_signature)) == 0) {
+ E1 = dbpageColumn(args);
+ }
+ else if (memcmp(E2.xColumn_signature, xColumn_signatures[xColumn_deltaparsevtabColumn_enum], sizeof(E2.xColumn_signature)) == 0) {
+ E1 = deltaparsevtabColumn(args);
+ }
+ else if (memcmp(E2.xColumn_signature, xColumn_signatures[xColumn_echoColumn_enum], sizeof(E2.xColumn_signature)) == 0) {
+ E1 = echoColumn(args);
+ }
+ else if (memcmp(E2.xColumn_signature, xColumn_signatures[xColumn_expertColumn_enum], sizeof(E2.xColumn_signature)) == 0) {
+ E1 = expertColumn(args);
+ }
+ else if (memcmp(E2.xColumn_signature, xColumn_signatures[xColumn_explainColumn_enum], sizeof(E2.xColumn_signature)) == 0) {
+ E1 = explainColumn(args);
+ }
+ else if (memcmp(E2.xColumn_signature, xColumn_signatures[xColumn_fsColumn_enum], sizeof(E2.xColumn_signature)) == 0) {
+ E1 = fsColumn(args);
+ }
+ else if (memcmp(E2.xColumn_signature, xColumn_signatures[xColumn_fsdirColumn_enum], sizeof(E2.xColumn_signature)) == 0) {
+ E1 = fsdirColumn(args);
+ }
+ else if (memcmp(E2.xColumn_signature, xColumn_signatures[xColumn_fstreeColumn_enum], sizeof(E2.xColumn_signature)) == 0) {
+ E1 = fstreeColumn(args);
+ }
+ else if (memcmp(E2.xColumn_signature, xColumn_signatures[xColumn_fts3ColumnMethod_enum], sizeof(E2.xColumn_signature)) == 0) {
+ E1 = fts3ColumnMethod(args);
+ }
+ else if (memcmp(E2.xColumn_signature, xColumn_signatures[xColumn_fts3auxColumnMethod_enum], sizeof(E2.xColumn_signature)) == 0) {
+ E1 = fts3auxColumnMethod(args);
+ }
+ else if (memcmp(E2.xColumn_signature, xColumn_signatures[xColumn_fts3termColumnMethod_enum], sizeof(E2.xColumn_signature)) == 0) {
+ E1 = fts3termColumnMethod(args);
+ }
+ else if (memcmp(E2.xColumn_signature, xColumn_signatures[xColumn_fts3tokColumnMethod_enum], sizeof(E2.xColumn_signature)) == 0) {
+ E1 = fts3tokColumnMethod(args);
+ }
+ else if (memcmp(E2.xColumn_signature, xColumn_signatures[xColumn_fuzzerColumn_enum], sizeof(E2.xColumn_signature)) == 0) {
+ E1 = fuzzerColumn(args);
+ }
+ else if (memcmp(E2.xColumn_signature, xColumn_signatures[xColumn_geopolyColumn_enum], sizeof(E2.xColumn_signature)) == 0) {
+ E1 = geopolyColumn(args);
+ }
+ else if (memcmp(E2.xColumn_signature, xColumn_signatures[xColumn_intarrayColumn_enum], sizeof(E2.xColumn_signature)) == 0) {
+ E1 = intarrayColumn(args);
+ }
+ else if (memcmp(E2.xColumn_signature, xColumn_signatures[xColumn_jsonEachColumn_enum], sizeof(E2.xColumn_signature)) == 0) {
+ E1 = jsonEachColumn(args);
+ }
+ else if (memcmp(E2.xColumn_signature, xColumn_signatures[xColumn_memstatColumn_enum], sizeof(E2.xColumn_signature)) == 0) {
+ E1 = memstatColumn(args);
+ }
+ else if (memcmp(E2.xColumn_signature, xColumn_signatures[xColumn_pragmaVtabColumn_enum], sizeof(E2.xColumn_signature)) == 0) {
+ E1 = pragmaVtabColumn(args);
+ }
+ else if (memcmp(E2.xColumn_signature, xColumn_signatures[xColumn_prefixesColumn_enum], sizeof(E2.xColumn_signature)) == 0) {
+ E1 = prefixesColumn(args);
+ }
+ else if (memcmp(E2.xColumn_signature, xColumn_signatures[xColumn_qpvtabColumn_enum], sizeof(E2.xColumn_signature)) == 0) {
+ E1 = qpvtabColumn(args);
+ }
+ else if (memcmp(E2.xColumn_signature, xColumn_signatures[xColumn_rtreeColumn_enum], sizeof(E2.xColumn_signature)) == 0) {
+ E1 = rtreeColumn(args);
+ }
+ else if (memcmp(E2.xColumn_signature, xColumn_signatures[xColumn_schemaColumn_enum], sizeof(E2.xColumn_signature)) == 0) {
+ E1 = schemaColumn(args);
+ }
+ else if (memcmp(E2.xColumn_signature, xColumn_signatures[xColumn_seriesColumn_enum], sizeof(E2.xColumn_signature)) == 0) {
+ E1 = seriesColumn(args);
+ }
+ else if (memcmp(E2.xColumn_signature, xColumn_signatures[xColumn_spellfix1Column_enum], sizeof(E2.xColumn_signature)) == 0) {
+ E1 = spellfix1Column(args);
+ }
+ else if (memcmp(E2.xColumn_signature, xColumn_signatures[xColumn_statColumn_enum], sizeof(E2.xColumn_signature)) == 0) {
+ E1 = statColumn(args);
+ }
+ else if (memcmp(E2.xColumn_signature, xColumn_signatures[xColumn_stmtColumn_enum], sizeof(E2.xColumn_signature)) == 0) {
+ E1 = stmtColumn(args);
+ }
+ else if (memcmp(E2.xColumn_signature, xColumn_signatures[xColumn_tclColumn_enum], sizeof(E2.xColumn_signature)) == 0) {
+ E1 = tclColumn(args);
+ }
+ else if (memcmp(E2.xColumn_signature, xColumn_signatures[xColumn_tclvarColumn_enum], sizeof(E2.xColumn_signature)) == 0) {
+ E1 = tclvarColumn(args);
+ }
+ else if (memcmp(E2.xColumn_signature, xColumn_signatures[xColumn_templatevtabColumn_enum], sizeof(E2.xColumn_signature)) == 0) {
+ E1 = templatevtabColumn(args);
+ }
+ else if (memcmp(E2.xColumn_signature, xColumn_signatures[xColumn_unionColumn_enum], sizeof(E2.xColumn_signature)) == 0) {
+ E1 = unionColumn(args);
+ }
+ else if (memcmp(E2.xColumn_signature, xColumn_signatures[xColumn_vlogColumn_enum], sizeof(E2.xColumn_signature)) == 0) {
+ E1 = vlogColumn(args);
+ }
+ else if (memcmp(E2.xColumn_signature, xColumn_signatures[xColumn_vstattabColumn_enum], sizeof(E2.xColumn_signature)) == 0) {
+ E1 = vstattabColumn(args);
+ }
+ else if (memcmp(E2.xColumn_signature, xColumn_signatures[xColumn_vtablogColumn_enum], sizeof(E2.xColumn_signature)) == 0) {
+ E1 = vtablogColumn(args);
+ }
+ else if (memcmp(E2.xColumn_signature, xColumn_signatures[xColumn_wholenumberColumn_enum], sizeof(E2.xColumn_signature)) == 0) {
+ E1 = wholenumberColumn(args);
+ }
+ else if (memcmp(E2.xColumn_signature, xColumn_signatures[xColumn_zipfileColumn_enum], sizeof(E2.xColumn_signature)) == 0) {
+ E1 = zipfileColumn(args);
+ }


// Transform E1 = E2.xCommit(args) to if-chain with 5 candidates
@transform_assignment_xCommit@
expression E1, E2;
identifier FP_NAME = xCommit;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xCommit_signature, xCommit_signatures[xCommit_0_enum], sizeof(E2.xCommit_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xCommit_signature, xCommit_signatures[xCommit_echoCommit_enum], sizeof(E2.xCommit_signature)) == 0) {
+ E1 = echoCommit(args);
+ }
+ else if (memcmp(E2.xCommit_signature, xCommit_signatures[xCommit_fts3CommitMethod_enum], sizeof(E2.xCommit_signature)) == 0) {
+ E1 = fts3CommitMethod(args);
+ }
+ else if (memcmp(E2.xCommit_signature, xCommit_signatures[xCommit_rtreeEndTransaction_enum], sizeof(E2.xCommit_signature)) == 0) {
+ E1 = rtreeEndTransaction(args);
+ }
+ else if (memcmp(E2.xCommit_signature, xCommit_signatures[xCommit_vtablogCommit_enum], sizeof(E2.xCommit_signature)) == 0) {
+ E1 = vtablogCommit(args);
+ }
+ else if (memcmp(E2.xCommit_signature, xCommit_signatures[xCommit_zipfileCommit_enum], sizeof(E2.xCommit_signature)) == 0) {
+ E1 = zipfileCommit(args);
+ }


// Transform E1 = E2.xConnect(args) to if-chain with 44 candidates
@transform_assignment_xConnect@
expression E1, E2;
identifier FP_NAME = xConnect;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xConnect_signature, xConnect_signatures[xConnect_amatchConnect_enum], sizeof(E2.xConnect_signature)) == 0) {
+ E1 = amatchConnect(args);
+ }
+ else if (memcmp(E2.xConnect_signature, xConnect_signatures[xConnect_binfoConnect_enum], sizeof(E2.xConnect_signature)) == 0) {
+ E1 = binfoConnect(args);
+ }
+ else if (memcmp(E2.xConnect_signature, xConnect_signatures[xConnect_bytecodevtabConnect_enum], sizeof(E2.xConnect_signature)) == 0) {
+ E1 = bytecodevtabConnect(args);
+ }
+ else if (memcmp(E2.xConnect_signature, xConnect_signatures[xConnect_carrayConnect_enum], sizeof(E2.xConnect_signature)) == 0) {
+ E1 = carrayConnect(args);
+ }
+ else if (memcmp(E2.xConnect_signature, xConnect_signatures[xConnect_cidxConnect_enum], sizeof(E2.xConnect_signature)) == 0) {
+ E1 = cidxConnect(args);
+ }
+ else if (memcmp(E2.xConnect_signature, xConnect_signatures[xConnect_closureConnect_enum], sizeof(E2.xConnect_signature)) == 0) {
+ E1 = closureConnect(args);
+ }
+ else if (memcmp(E2.xConnect_signature, xConnect_signatures[xConnect_completionConnect_enum], sizeof(E2.xConnect_signature)) == 0) {
+ E1 = completionConnect(args);
+ }
+ else if (memcmp(E2.xConnect_signature, xConnect_signatures[xConnect_csvtabConnect_enum], sizeof(E2.xConnect_signature)) == 0) {
+ E1 = csvtabConnect(args);
+ }
+ else if (memcmp(E2.xConnect_signature, xConnect_signatures[xConnect_dbdataConnect_enum], sizeof(E2.xConnect_signature)) == 0) {
+ E1 = dbdataConnect(args);
+ }
+ else if (memcmp(E2.xConnect_signature, xConnect_signatures[xConnect_dbpageConnect_enum], sizeof(E2.xConnect_signature)) == 0) {
+ E1 = dbpageConnect(args);
+ }
+ else if (memcmp(E2.xConnect_signature, xConnect_signatures[xConnect_deltaparsevtabConnect_enum], sizeof(E2.xConnect_signature)) == 0) {
+ E1 = deltaparsevtabConnect(args);
+ }
+ else if (memcmp(E2.xConnect_signature, xConnect_signatures[xConnect_echoConnect_enum], sizeof(E2.xConnect_signature)) == 0) {
+ E1 = echoConnect(args);
+ }
+ else if (memcmp(E2.xConnect_signature, xConnect_signatures[xConnect_expertConnect_enum], sizeof(E2.xConnect_signature)) == 0) {
+ E1 = expertConnect(args);
+ }
+ else if (memcmp(E2.xConnect_signature, xConnect_signatures[xConnect_explainConnect_enum], sizeof(E2.xConnect_signature)) == 0) {
+ E1 = explainConnect(args);
+ }
+ else if (memcmp(E2.xConnect_signature, xConnect_signatures[xConnect_fsConnect_enum], sizeof(E2.xConnect_signature)) == 0) {
+ E1 = fsConnect(args);
+ }
+ else if (memcmp(E2.xConnect_signature, xConnect_signatures[xConnect_fsdirConnect_enum], sizeof(E2.xConnect_signature)) == 0) {
+ E1 = fsdirConnect(args);
+ }
+ else if (memcmp(E2.xConnect_signature, xConnect_signatures[xConnect_fstreeConnect_enum], sizeof(E2.xConnect_signature)) == 0) {
+ E1 = fstreeConnect(args);
+ }
+ else if (memcmp(E2.xConnect_signature, xConnect_signatures[xConnect_fts3ConnectMethod_enum], sizeof(E2.xConnect_signature)) == 0) {
+ E1 = fts3ConnectMethod(args);
+ }
+ else if (memcmp(E2.xConnect_signature, xConnect_signatures[xConnect_fts3auxConnectMethod_enum], sizeof(E2.xConnect_signature)) == 0) {
+ E1 = fts3auxConnectMethod(args);
+ }
+ else if (memcmp(E2.xConnect_signature, xConnect_signatures[xConnect_fts3termConnectMethod_enum], sizeof(E2.xConnect_signature)) == 0) {
+ E1 = fts3termConnectMethod(args);
+ }
+ else if (memcmp(E2.xConnect_signature, xConnect_signatures[xConnect_fts3tokConnectMethod_enum], sizeof(E2.xConnect_signature)) == 0) {
+ E1 = fts3tokConnectMethod(args);
+ }
+ else if (memcmp(E2.xConnect_signature, xConnect_signatures[xConnect_fuzzerConnect_enum], sizeof(E2.xConnect_signature)) == 0) {
+ E1 = fuzzerConnect(args);
+ }
+ else if (memcmp(E2.xConnect_signature, xConnect_signatures[xConnect_geopolyConnect_enum], sizeof(E2.xConnect_signature)) == 0) {
+ E1 = geopolyConnect(args);
+ }
+ else if (memcmp(E2.xConnect_signature, xConnect_signatures[xConnect_intarrayCreate_enum], sizeof(E2.xConnect_signature)) == 0) {
+ E1 = intarrayCreate(args);
+ }
+ else if (memcmp(E2.xConnect_signature, xConnect_signatures[xConnect_jsonEachConnect_enum], sizeof(E2.xConnect_signature)) == 0) {
+ E1 = jsonEachConnect(args);
+ }
+ else if (memcmp(E2.xConnect_signature, xConnect_signatures[xConnect_memstatConnect_enum], sizeof(E2.xConnect_signature)) == 0) {
+ E1 = memstatConnect(args);
+ }
+ else if (memcmp(E2.xConnect_signature, xConnect_signatures[xConnect_pragmaVtabConnect_enum], sizeof(E2.xConnect_signature)) == 0) {
+ E1 = pragmaVtabConnect(args);
+ }
+ else if (memcmp(E2.xConnect_signature, xConnect_signatures[xConnect_prefixesConnect_enum], sizeof(E2.xConnect_signature)) == 0) {
+ E1 = prefixesConnect(args);
+ }
+ else if (memcmp(E2.xConnect_signature, xConnect_signatures[xConnect_qpvtabConnect_enum], sizeof(E2.xConnect_signature)) == 0) {
+ E1 = qpvtabConnect(args);
+ }
+ else if (memcmp(E2.xConnect_signature, xConnect_signatures[xConnect_rtreeConnect_enum], sizeof(E2.xConnect_signature)) == 0) {
+ E1 = rtreeConnect(args);
+ }
+ else if (memcmp(E2.xConnect_signature, xConnect_signatures[xConnect_schemaCreate_enum], sizeof(E2.xConnect_signature)) == 0) {
+ E1 = schemaCreate(args);
+ }
+ else if (memcmp(E2.xConnect_signature, xConnect_signatures[xConnect_seriesConnect_enum], sizeof(E2.xConnect_signature)) == 0) {
+ E1 = seriesConnect(args);
+ }
+ else if (memcmp(E2.xConnect_signature, xConnect_signatures[xConnect_spellfix1Connect_enum], sizeof(E2.xConnect_signature)) == 0) {
+ E1 = spellfix1Connect(args);
+ }
+ else if (memcmp(E2.xConnect_signature, xConnect_signatures[xConnect_statConnect_enum], sizeof(E2.xConnect_signature)) == 0) {
+ E1 = statConnect(args);
+ }
+ else if (memcmp(E2.xConnect_signature, xConnect_signatures[xConnect_stmtConnect_enum], sizeof(E2.xConnect_signature)) == 0) {
+ E1 = stmtConnect(args);
+ }
+ else if (memcmp(E2.xConnect_signature, xConnect_signatures[xConnect_tclConnect_enum], sizeof(E2.xConnect_signature)) == 0) {
+ E1 = tclConnect(args);
+ }
+ else if (memcmp(E2.xConnect_signature, xConnect_signatures[xConnect_tclvarConnect_enum], sizeof(E2.xConnect_signature)) == 0) {
+ E1 = tclvarConnect(args);
+ }
+ else if (memcmp(E2.xConnect_signature, xConnect_signatures[xConnect_templatevtabConnect_enum], sizeof(E2.xConnect_signature)) == 0) {
+ E1 = templatevtabConnect(args);
+ }
+ else if (memcmp(E2.xConnect_signature, xConnect_signatures[xConnect_unionConnect_enum], sizeof(E2.xConnect_signature)) == 0) {
+ E1 = unionConnect(args);
+ }
+ else if (memcmp(E2.xConnect_signature, xConnect_signatures[xConnect_vlogConnect_enum], sizeof(E2.xConnect_signature)) == 0) {
+ E1 = vlogConnect(args);
+ }
+ else if (memcmp(E2.xConnect_signature, xConnect_signatures[xConnect_vstattabConnect_enum], sizeof(E2.xConnect_signature)) == 0) {
+ E1 = vstattabConnect(args);
+ }
+ else if (memcmp(E2.xConnect_signature, xConnect_signatures[xConnect_vtablogConnect_enum], sizeof(E2.xConnect_signature)) == 0) {
+ E1 = vtablogConnect(args);
+ }
+ else if (memcmp(E2.xConnect_signature, xConnect_signatures[xConnect_wholenumberConnect_enum], sizeof(E2.xConnect_signature)) == 0) {
+ E1 = wholenumberConnect(args);
+ }
+ else if (memcmp(E2.xConnect_signature, xConnect_signatures[xConnect_zipfileConnect_enum], sizeof(E2.xConnect_signature)) == 0) {
+ E1 = zipfileConnect(args);
+ }


// Transform E1 = E2.xCount(args) to if-chain with 3 candidates
@transform_assignment_xCount@
expression E1, E2;
identifier FP_NAME = xCount;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xCount_signature, xCount_signatures[xCount_sessionDiffCount_enum], sizeof(E2.xCount_signature)) == 0) {
+ E1 = sessionDiffCount(args);
+ }
+ else if (memcmp(E2.xCount_signature, xCount_signatures[xCount_sessionPreupdateCount_enum], sizeof(E2.xCount_signature)) == 0) {
+ E1 = sessionPreupdateCount(args);
+ }
+ else if (memcmp(E2.xCount_signature, xCount_signatures[xCount_sessionStat1Count_enum], sizeof(E2.xCount_signature)) == 0) {
+ E1 = sessionStat1Count(args);
+ }


// Transform E1 = E2.xCreate(args) to if-chain with 34 candidates
@transform_assignment_xCreate@
expression E1, E2;
identifier FP_NAME = xCreate;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xCreate_signature, xCreate_signatures[xCreate_0_enum], sizeof(E2.xCreate_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xCreate_signature, xCreate_signatures[xCreate_amatchConnect_enum], sizeof(E2.xCreate_signature)) == 0) {
+ E1 = amatchConnect(args);
+ }
+ else if (memcmp(E2.xCreate_signature, xCreate_signatures[xCreate_closureConnect_enum], sizeof(E2.xCreate_signature)) == 0) {
+ E1 = closureConnect(args);
+ }
+ else if (memcmp(E2.xCreate_signature, xCreate_signatures[xCreate_csvtabCreate_enum], sizeof(E2.xCreate_signature)) == 0) {
+ E1 = csvtabCreate(args);
+ }
+ else if (memcmp(E2.xCreate_signature, xCreate_signatures[xCreate_dbpageConnect_enum], sizeof(E2.xCreate_signature)) == 0) {
+ E1 = dbpageConnect(args);
+ }
+ else if (memcmp(E2.xCreate_signature, xCreate_signatures[xCreate_echoCreate_enum], sizeof(E2.xCreate_signature)) == 0) {
+ E1 = echoCreate(args);
+ }
+ else if (memcmp(E2.xCreate_signature, xCreate_signatures[xCreate_expertConnect_enum], sizeof(E2.xCreate_signature)) == 0) {
+ E1 = expertConnect(args);
+ }
+ else if (memcmp(E2.xCreate_signature, xCreate_signatures[xCreate_f5tOrigintextCreate_enum], sizeof(E2.xCreate_signature)) == 0) {
+ E1 = f5tOrigintextCreate(args);
+ }
+ else if (memcmp(E2.xCreate_signature, xCreate_signatures[xCreate_f5tTokenizerCreate_enum], sizeof(E2.xCreate_signature)) == 0) {
+ E1 = f5tTokenizerCreate(args);
+ }
+ else if (memcmp(E2.xCreate_signature, xCreate_signatures[xCreate_fsConnect_enum], sizeof(E2.xCreate_signature)) == 0) {
+ E1 = fsConnect(args);
+ }
+ else if (memcmp(E2.xCreate_signature, xCreate_signatures[xCreate_fsdirConnect_enum], sizeof(E2.xCreate_signature)) == 0) {
+ E1 = fsdirConnect(args);
+ }
+ else if (memcmp(E2.xCreate_signature, xCreate_signatures[xCreate_fstreeConnect_enum], sizeof(E2.xCreate_signature)) == 0) {
+ E1 = fstreeConnect(args);
+ }
+ else if (memcmp(E2.xCreate_signature, xCreate_signatures[xCreate_fts3CreateMethod_enum], sizeof(E2.xCreate_signature)) == 0) {
+ E1 = fts3CreateMethod(args);
+ }
+ else if (memcmp(E2.xCreate_signature, xCreate_signatures[xCreate_fts3auxConnectMethod_enum], sizeof(E2.xCreate_signature)) == 0) {
+ E1 = fts3auxConnectMethod(args);
+ }
+ else if (memcmp(E2.xCreate_signature, xCreate_signatures[xCreate_fts3termConnectMethod_enum], sizeof(E2.xCreate_signature)) == 0) {
+ E1 = fts3termConnectMethod(args);
+ }
+ else if (memcmp(E2.xCreate_signature, xCreate_signatures[xCreate_fts3tokConnectMethod_enum], sizeof(E2.xCreate_signature)) == 0) {
+ E1 = fts3tokConnectMethod(args);
+ }
+ else if (memcmp(E2.xCreate_signature, xCreate_signatures[xCreate_fuzzerConnect_enum], sizeof(E2.xCreate_signature)) == 0) {
+ E1 = fuzzerConnect(args);
+ }
+ else if (memcmp(E2.xCreate_signature, xCreate_signatures[xCreate_geopolyCreate_enum], sizeof(E2.xCreate_signature)) == 0) {
+ E1 = geopolyCreate(args);
+ }
+ else if (memcmp(E2.xCreate_signature, xCreate_signatures[xCreate_intarrayCreate_enum], sizeof(E2.xCreate_signature)) == 0) {
+ E1 = intarrayCreate(args);
+ }
+ else if (memcmp(E2.xCreate_signature, xCreate_signatures[xCreate_pcache1Create_enum], sizeof(E2.xCreate_signature)) == 0) {
+ E1 = pcache1Create(args);
+ }
+ else if (memcmp(E2.xCreate_signature, xCreate_signatures[xCreate_pcachetraceCreate_enum], sizeof(E2.xCreate_signature)) == 0) {
+ E1 = pcachetraceCreate(args);
+ }
+ else if (memcmp(E2.xCreate_signature, xCreate_signatures[xCreate_porterCreate_enum], sizeof(E2.xCreate_signature)) == 0) {
+ E1 = porterCreate(args);
+ }
+ else if (memcmp(E2.xCreate_signature, xCreate_signatures[xCreate_rtreeCreate_enum], sizeof(E2.xCreate_signature)) == 0) {
+ E1 = rtreeCreate(args);
+ }
+ else if (memcmp(E2.xCreate_signature, xCreate_signatures[xCreate_schemaCreate_enum], sizeof(E2.xCreate_signature)) == 0) {
+ E1 = schemaCreate(args);
+ }
+ else if (memcmp(E2.xCreate_signature, xCreate_signatures[xCreate_simpleCreate_enum], sizeof(E2.xCreate_signature)) == 0) {
+ E1 = simpleCreate(args);
+ }
+ else if (memcmp(E2.xCreate_signature, xCreate_signatures[xCreate_spellfix1Create_enum], sizeof(E2.xCreate_signature)) == 0) {
+ E1 = spellfix1Create(args);
+ }
+ else if (memcmp(E2.xCreate_signature, xCreate_signatures[xCreate_statConnect_enum], sizeof(E2.xCreate_signature)) == 0) {
+ E1 = statConnect(args);
+ }
+ else if (memcmp(E2.xCreate_signature, xCreate_signatures[xCreate_tclConnect_enum], sizeof(E2.xCreate_signature)) == 0) {
+ E1 = tclConnect(args);
+ }
+ else if (memcmp(E2.xCreate_signature, xCreate_signatures[xCreate_tclvarConnect_enum], sizeof(E2.xCreate_signature)) == 0) {
+ E1 = tclvarConnect(args);
+ }
+ else if (memcmp(E2.xCreate_signature, xCreate_signatures[xCreate_unicodeCreate_enum], sizeof(E2.xCreate_signature)) == 0) {
+ E1 = unicodeCreate(args);
+ }
+ else if (memcmp(E2.xCreate_signature, xCreate_signatures[xCreate_unionConnect_enum], sizeof(E2.xCreate_signature)) == 0) {
+ E1 = unionConnect(args);
+ }
+ else if (memcmp(E2.xCreate_signature, xCreate_signatures[xCreate_vlogConnect_enum], sizeof(E2.xCreate_signature)) == 0) {
+ E1 = vlogConnect(args);
+ }
+ else if (memcmp(E2.xCreate_signature, xCreate_signatures[xCreate_vtablogCreate_enum], sizeof(E2.xCreate_signature)) == 0) {
+ E1 = vtablogCreate(args);
+ }
+ else if (memcmp(E2.xCreate_signature, xCreate_signatures[xCreate_wholenumberConnect_enum], sizeof(E2.xCreate_signature)) == 0) {
+ E1 = wholenumberConnect(args);
+ }
+ else if (memcmp(E2.xCreate_signature, xCreate_signatures[xCreate_zipfileConnect_enum], sizeof(E2.xCreate_signature)) == 0) {
+ E1 = zipfileConnect(args);
+ }


// Transform E1 = E2.xCurrentTime(args) to if-chain with 3 candidates
@transform_assignment_xCurrentTime@
expression E1, E2;
identifier FP_NAME = xCurrentTime;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xCurrentTime_signature, xCurrentTime_signatures[xCurrentTime_0_enum], sizeof(E2.xCurrentTime_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xCurrentTime_signature, xCurrentTime_signatures[xCurrentTime_apndCurrentTime_enum], sizeof(E2.xCurrentTime_signature)) == 0) {
+ E1 = apndCurrentTime(args);
+ }
+ else if (memcmp(E2.xCurrentTime_signature, xCurrentTime_signatures[xCurrentTime_vfstraceCurrentTime_enum], sizeof(E2.xCurrentTime_signature)) == 0) {
+ E1 = vfstraceCurrentTime(args);
+ }
+ else if (memcmp(E2.xCurrentTime_signature, xCurrentTime_signatures[xCurrentTime_unixCurrentTime_enum], sizeof(E2.xCurrentTime_signature)) == 0) {
+ E1 = unixCurrentTime(args);
+ }


// Transform E1 = E2.xCurrentTimeInt64(args) to if-chain with 3 candidates
@transform_assignment_xCurrentTimeInt64@
expression E1, E2;
identifier FP_NAME = xCurrentTimeInt64;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xCurrentTimeInt64_signature, xCurrentTimeInt64_signatures[xCurrentTimeInt64_0_enum], sizeof(E2.xCurrentTimeInt64_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xCurrentTimeInt64_signature, xCurrentTimeInt64_signatures[xCurrentTimeInt64_apndCurrentTimeInt64_enum], sizeof(E2.xCurrentTimeInt64_signature)) == 0) {
+ E1 = apndCurrentTimeInt64(args);
+ }
+ else if (memcmp(E2.xCurrentTimeInt64_signature, xCurrentTimeInt64_signatures[xCurrentTimeInt64_memdbCurrentTimeInt64_enum], sizeof(E2.xCurrentTimeInt64_signature)) == 0) {
+ E1 = memdbCurrentTimeInt64(args);
+ }
+ else if (memcmp(E2.xCurrentTimeInt64_signature, xCurrentTimeInt64_signatures[xCurrentTimeInt64_unixCurrentTimeInt64_enum], sizeof(E2.xCurrentTimeInt64_signature)) == 0) {
+ E1 = unixCurrentTimeInt64(args);
+ }


// Transform E1 = E2.xDel(args) to if-chain with 3 candidates
@transform_assignment_xDel@
expression E1, E2;
identifier FP_NAME = xDel;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xDel_signature, xDel_signatures[xDel_0_enum], sizeof(E2.xDel_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xDel_signature, xDel_signatures[xDel_sqlite3RowSetDelete_enum], sizeof(E2.xDel_signature)) == 0) {
+ E1 = sqlite3RowSetDelete(args);
+ }
+ else if (memcmp(E2.xDel_signature, xDel_signatures[xDel_sqlite3VdbeFrameMemDel_enum], sizeof(E2.xDel_signature)) == 0) {
+ E1 = sqlite3VdbeFrameMemDel(args);
+ }
+ else if (memcmp(E2.xDel_signature, xDel_signatures[xDel_sqlite3_free_enum], sizeof(E2.xDel_signature)) == 0) {
+ E1 = sqlite3_free(args);
+ }


// Transform E1 = E2.xDelete(args) to if-chain with 6 candidates
@transform_assignment_xDelete@
expression E1, E2;
identifier FP_NAME = xDelete;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xDelete_signature, xDelete_signatures[xDelete_0_enum], sizeof(E2.xDelete_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xDelete_signature, xDelete_signatures[xDelete_apndDelete_enum], sizeof(E2.xDelete_signature)) == 0) {
+ E1 = apndDelete(args);
+ }
+ else if (memcmp(E2.xDelete_signature, xDelete_signatures[xDelete_f5tOrigintextDelete_enum], sizeof(E2.xDelete_signature)) == 0) {
+ E1 = f5tOrigintextDelete(args);
+ }
+ else if (memcmp(E2.xDelete_signature, xDelete_signatures[xDelete_f5tTokenizerDelete_enum], sizeof(E2.xDelete_signature)) == 0) {
+ E1 = f5tTokenizerDelete(args);
+ }
+ else if (memcmp(E2.xDelete_signature, xDelete_signatures[xDelete_kvstorageDelete_enum], sizeof(E2.xDelete_signature)) == 0) {
+ E1 = kvstorageDelete(args);
+ }
+ else if (memcmp(E2.xDelete_signature, xDelete_signatures[xDelete_vfstraceDelete_enum], sizeof(E2.xDelete_signature)) == 0) {
+ E1 = vfstraceDelete(args);
+ }
+ else if (memcmp(E2.xDelete_signature, xDelete_signatures[xDelete_unixDelete_enum], sizeof(E2.xDelete_signature)) == 0) {
+ E1 = unixDelete(args);
+ }


// Transform E1 = E2.xDepth(args) to if-chain with 3 candidates
@transform_assignment_xDepth@
expression E1, E2;
identifier FP_NAME = xDepth;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xDepth_signature, xDepth_signatures[xDepth_sessionDiffDepth_enum], sizeof(E2.xDepth_signature)) == 0) {
+ E1 = sessionDiffDepth(args);
+ }
+ else if (memcmp(E2.xDepth_signature, xDepth_signatures[xDepth_sessionPreupdateDepth_enum], sizeof(E2.xDepth_signature)) == 0) {
+ E1 = sessionPreupdateDepth(args);
+ }
+ else if (memcmp(E2.xDepth_signature, xDepth_signatures[xDepth_sessionStat1Depth_enum], sizeof(E2.xDepth_signature)) == 0) {
+ E1 = sessionStat1Depth(args);
+ }


// Transform E1 = E2.xDestroy(args) to if-chain with 14 candidates
@transform_assignment_xDestroy@
expression E1, E2;
identifier FP_NAME = xDestroy;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xDestroy_signature, xDestroy_signatures[xDestroy_0_enum], sizeof(E2.xDestroy_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xDestroy_signature, xDestroy_signatures[xDestroy_dbpageDisconnect_enum], sizeof(E2.xDestroy_signature)) == 0) {
+ E1 = dbpageDisconnect(args);
+ }
+ else if (memcmp(E2.xDestroy_signature, xDestroy_signatures[xDestroy_expertDisconnect_enum], sizeof(E2.xDestroy_signature)) == 0) {
+ E1 = expertDisconnect(args);
+ }
+ else if (memcmp(E2.xDestroy_signature, xDestroy_signatures[xDestroy_fsdirDisconnect_enum], sizeof(E2.xDestroy_signature)) == 0) {
+ E1 = fsdirDisconnect(args);
+ }
+ else if (memcmp(E2.xDestroy_signature, xDestroy_signatures[xDestroy_fts3DestroyMethod_enum], sizeof(E2.xDestroy_signature)) == 0) {
+ E1 = fts3DestroyMethod(args);
+ }
+ else if (memcmp(E2.xDestroy_signature, xDestroy_signatures[xDestroy_fts3auxDisconnectMethod_enum], sizeof(E2.xDestroy_signature)) == 0) {
+ E1 = fts3auxDisconnectMethod(args);
+ }
+ else if (memcmp(E2.xDestroy_signature, xDestroy_signatures[xDestroy_fts3tokDisconnectMethod_enum], sizeof(E2.xDestroy_signature)) == 0) {
+ E1 = fts3tokDisconnectMethod(args);
+ }
+ else if (memcmp(E2.xDestroy_signature, xDestroy_signatures[xDestroy_pcache1Destroy_enum], sizeof(E2.xDestroy_signature)) == 0) {
+ E1 = pcache1Destroy(args);
+ }
+ else if (memcmp(E2.xDestroy_signature, xDestroy_signatures[xDestroy_pcachetraceDestroy_enum], sizeof(E2.xDestroy_signature)) == 0) {
+ E1 = pcachetraceDestroy(args);
+ }
+ else if (memcmp(E2.xDestroy_signature, xDestroy_signatures[xDestroy_porterDestroy_enum], sizeof(E2.xDestroy_signature)) == 0) {
+ E1 = porterDestroy(args);
+ }
+ else if (memcmp(E2.xDestroy_signature, xDestroy_signatures[xDestroy_rtreeDestroy_enum], sizeof(E2.xDestroy_signature)) == 0) {
+ E1 = rtreeDestroy(args);
+ }
+ else if (memcmp(E2.xDestroy_signature, xDestroy_signatures[xDestroy_simpleDestroy_enum], sizeof(E2.xDestroy_signature)) == 0) {
+ E1 = simpleDestroy(args);
+ }
+ else if (memcmp(E2.xDestroy_signature, xDestroy_signatures[xDestroy_statDisconnect_enum], sizeof(E2.xDestroy_signature)) == 0) {
+ E1 = statDisconnect(args);
+ }
+ else if (memcmp(E2.xDestroy_signature, xDestroy_signatures[xDestroy_unicodeDestroy_enum], sizeof(E2.xDestroy_signature)) == 0) {
+ E1 = unicodeDestroy(args);
+ }
+ else if (memcmp(E2.xDestroy_signature, xDestroy_signatures[xDestroy_zipfileDisconnect_enum], sizeof(E2.xDestroy_signature)) == 0) {
+ E1 = zipfileDisconnect(args);
+ }


// Transform E1 = E2.xDeviceCharacteristics(args) to if-chain with 5 candidates
@transform_assignment_xDeviceCharacteristics@
expression E1, E2;
identifier FP_NAME = xDeviceCharacteristics;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xDeviceCharacteristics_signature, xDeviceCharacteristics_signatures[xDeviceCharacteristics_0_enum], sizeof(E2.xDeviceCharacteristics_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xDeviceCharacteristics_signature, xDeviceCharacteristics_signatures[xDeviceCharacteristics_apndDeviceCharacteristics_enum], sizeof(E2.xDeviceCharacteristics_signature)) == 0) {
+ E1 = apndDeviceCharacteristics(args);
+ }
+ else if (memcmp(E2.xDeviceCharacteristics_signature, xDeviceCharacteristics_signatures[xDeviceCharacteristics_memdbDeviceCharacteristics_enum], sizeof(E2.xDeviceCharacteristics_signature)) == 0) {
+ E1 = memdbDeviceCharacteristics(args);
+ }
+ else if (memcmp(E2.xDeviceCharacteristics_signature, xDeviceCharacteristics_signatures[xDeviceCharacteristics_recoverVfsDeviceCharacteristics_enum], sizeof(E2.xDeviceCharacteristics_signature)) == 0) {
+ E1 = recoverVfsDeviceCharacteristics(args);
+ }
+ else if (memcmp(E2.xDeviceCharacteristics_signature, xDeviceCharacteristics_signatures[xDeviceCharacteristics_vfstraceDeviceCharacteristics_enum], sizeof(E2.xDeviceCharacteristics_signature)) == 0) {
+ E1 = vfstraceDeviceCharacteristics(args);
+ }
+ else if (memcmp(E2.xDeviceCharacteristics_signature, xDeviceCharacteristics_signatures[xDeviceCharacteristics_unixDeviceCharacteristics_enum], sizeof(E2.xDeviceCharacteristics_signature)) == 0) {
+ E1 = unixDeviceCharacteristics(args);
+ }


// Transform E1 = E2.xDisconnect(args) to if-chain with 16 candidates
@transform_assignment_xDisconnect@
expression E1, E2;
identifier FP_NAME = xDisconnect;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xDisconnect_signature, xDisconnect_signatures[xDisconnect_bytecodevtabDisconnect_enum], sizeof(E2.xDisconnect_signature)) == 0) {
+ E1 = bytecodevtabDisconnect(args);
+ }
+ else if (memcmp(E2.xDisconnect_signature, xDisconnect_signatures[xDisconnect_completionDisconnect_enum], sizeof(E2.xDisconnect_signature)) == 0) {
+ E1 = completionDisconnect(args);
+ }
+ else if (memcmp(E2.xDisconnect_signature, xDisconnect_signatures[xDisconnect_dbdataDisconnect_enum], sizeof(E2.xDisconnect_signature)) == 0) {
+ E1 = dbdataDisconnect(args);
+ }
+ else if (memcmp(E2.xDisconnect_signature, xDisconnect_signatures[xDisconnect_dbpageDisconnect_enum], sizeof(E2.xDisconnect_signature)) == 0) {
+ E1 = dbpageDisconnect(args);
+ }
+ else if (memcmp(E2.xDisconnect_signature, xDisconnect_signatures[xDisconnect_expertDisconnect_enum], sizeof(E2.xDisconnect_signature)) == 0) {
+ E1 = expertDisconnect(args);
+ }
+ else if (memcmp(E2.xDisconnect_signature, xDisconnect_signatures[xDisconnect_fsdirDisconnect_enum], sizeof(E2.xDisconnect_signature)) == 0) {
+ E1 = fsdirDisconnect(args);
+ }
+ else if (memcmp(E2.xDisconnect_signature, xDisconnect_signatures[xDisconnect_fts3DisconnectMethod_enum], sizeof(E2.xDisconnect_signature)) == 0) {
+ E1 = fts3DisconnectMethod(args);
+ }
+ else if (memcmp(E2.xDisconnect_signature, xDisconnect_signatures[xDisconnect_fts3auxDisconnectMethod_enum], sizeof(E2.xDisconnect_signature)) == 0) {
+ E1 = fts3auxDisconnectMethod(args);
+ }
+ else if (memcmp(E2.xDisconnect_signature, xDisconnect_signatures[xDisconnect_fts3tokDisconnectMethod_enum], sizeof(E2.xDisconnect_signature)) == 0) {
+ E1 = fts3tokDisconnectMethod(args);
+ }
+ else if (memcmp(E2.xDisconnect_signature, xDisconnect_signatures[xDisconnect_jsonEachDisconnect_enum], sizeof(E2.xDisconnect_signature)) == 0) {
+ E1 = jsonEachDisconnect(args);
+ }
+ else if (memcmp(E2.xDisconnect_signature, xDisconnect_signatures[xDisconnect_pragmaVtabDisconnect_enum], sizeof(E2.xDisconnect_signature)) == 0) {
+ E1 = pragmaVtabDisconnect(args);
+ }
+ else if (memcmp(E2.xDisconnect_signature, xDisconnect_signatures[xDisconnect_rtreeDisconnect_enum], sizeof(E2.xDisconnect_signature)) == 0) {
+ E1 = rtreeDisconnect(args);
+ }
+ else if (memcmp(E2.xDisconnect_signature, xDisconnect_signatures[xDisconnect_seriesDisconnect_enum], sizeof(E2.xDisconnect_signature)) == 0) {
+ E1 = seriesDisconnect(args);
+ }
+ else if (memcmp(E2.xDisconnect_signature, xDisconnect_signatures[xDisconnect_statDisconnect_enum], sizeof(E2.xDisconnect_signature)) == 0) {
+ E1 = statDisconnect(args);
+ }
+ else if (memcmp(E2.xDisconnect_signature, xDisconnect_signatures[xDisconnect_stmtDisconnect_enum], sizeof(E2.xDisconnect_signature)) == 0) {
+ E1 = stmtDisconnect(args);
+ }
+ else if (memcmp(E2.xDisconnect_signature, xDisconnect_signatures[xDisconnect_zipfileDisconnect_enum], sizeof(E2.xDisconnect_signature)) == 0) {
+ E1 = zipfileDisconnect(args);
+ }


// Transform E1 = E2.xDlClose(args) to if-chain with 3 candidates
@transform_assignment_xDlClose@
expression E1, E2;
identifier FP_NAME = xDlClose;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xDlClose_signature, xDlClose_signatures[xDlClose_0_enum], sizeof(E2.xDlClose_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xDlClose_signature, xDlClose_signatures[xDlClose_apndDlClose_enum], sizeof(E2.xDlClose_signature)) == 0) {
+ E1 = apndDlClose(args);
+ }
+ else if (memcmp(E2.xDlClose_signature, xDlClose_signatures[xDlClose_memdbDlClose_enum], sizeof(E2.xDlClose_signature)) == 0) {
+ E1 = memdbDlClose(args);
+ }
+ else if (memcmp(E2.xDlClose_signature, xDlClose_signatures[xDlClose_unixDlClose_enum], sizeof(E2.xDlClose_signature)) == 0) {
+ E1 = unixDlClose(args);
+ }


// Transform E1 = E2.xDlError(args) to if-chain with 3 candidates
@transform_assignment_xDlError@
expression E1, E2;
identifier FP_NAME = xDlError;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xDlError_signature, xDlError_signatures[xDlError_0_enum], sizeof(E2.xDlError_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xDlError_signature, xDlError_signatures[xDlError_apndDlError_enum], sizeof(E2.xDlError_signature)) == 0) {
+ E1 = apndDlError(args);
+ }
+ else if (memcmp(E2.xDlError_signature, xDlError_signatures[xDlError_memdbDlError_enum], sizeof(E2.xDlError_signature)) == 0) {
+ E1 = memdbDlError(args);
+ }
+ else if (memcmp(E2.xDlError_signature, xDlError_signatures[xDlError_unixDlError_enum], sizeof(E2.xDlError_signature)) == 0) {
+ E1 = unixDlError(args);
+ }


// Transform E1 = E2.xDlOpen(args) to if-chain with 3 candidates
@transform_assignment_xDlOpen@
expression E1, E2;
identifier FP_NAME = xDlOpen;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xDlOpen_signature, xDlOpen_signatures[xDlOpen_apndDlOpen_enum], sizeof(E2.xDlOpen_signature)) == 0) {
+ E1 = apndDlOpen(args);
+ }
+ else if (memcmp(E2.xDlOpen_signature, xDlOpen_signatures[xDlOpen_memdbDlOpen_enum], sizeof(E2.xDlOpen_signature)) == 0) {
+ E1 = memdbDlOpen(args);
+ }
+ else if (memcmp(E2.xDlOpen_signature, xDlOpen_signatures[xDlOpen_unixDlOpen_enum], sizeof(E2.xDlOpen_signature)) == 0) {
+ E1 = unixDlOpen(args);
+ }


// Transform E1 = E2.xEof(args) to if-chain with 43 candidates
@transform_assignment_xEof@
expression E1, E2;
identifier FP_NAME = xEof;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xEof_signature, xEof_signatures[xEof_amatchEof_enum], sizeof(E2.xEof_signature)) == 0) {
+ E1 = amatchEof(args);
+ }
+ else if (memcmp(E2.xEof_signature, xEof_signatures[xEof_binfoEof_enum], sizeof(E2.xEof_signature)) == 0) {
+ E1 = binfoEof(args);
+ }
+ else if (memcmp(E2.xEof_signature, xEof_signatures[xEof_bytecodevtabEof_enum], sizeof(E2.xEof_signature)) == 0) {
+ E1 = bytecodevtabEof(args);
+ }
+ else if (memcmp(E2.xEof_signature, xEof_signatures[xEof_carrayEof_enum], sizeof(E2.xEof_signature)) == 0) {
+ E1 = carrayEof(args);
+ }
+ else if (memcmp(E2.xEof_signature, xEof_signatures[xEof_cidxEof_enum], sizeof(E2.xEof_signature)) == 0) {
+ E1 = cidxEof(args);
+ }
+ else if (memcmp(E2.xEof_signature, xEof_signatures[xEof_closureEof_enum], sizeof(E2.xEof_signature)) == 0) {
+ E1 = closureEof(args);
+ }
+ else if (memcmp(E2.xEof_signature, xEof_signatures[xEof_completionEof_enum], sizeof(E2.xEof_signature)) == 0) {
+ E1 = completionEof(args);
+ }
+ else if (memcmp(E2.xEof_signature, xEof_signatures[xEof_csvtabEof_enum], sizeof(E2.xEof_signature)) == 0) {
+ E1 = csvtabEof(args);
+ }
+ else if (memcmp(E2.xEof_signature, xEof_signatures[xEof_dbdataEof_enum], sizeof(E2.xEof_signature)) == 0) {
+ E1 = dbdataEof(args);
+ }
+ else if (memcmp(E2.xEof_signature, xEof_signatures[xEof_dbpageEof_enum], sizeof(E2.xEof_signature)) == 0) {
+ E1 = dbpageEof(args);
+ }
+ else if (memcmp(E2.xEof_signature, xEof_signatures[xEof_deltaparsevtabEof_enum], sizeof(E2.xEof_signature)) == 0) {
+ E1 = deltaparsevtabEof(args);
+ }
+ else if (memcmp(E2.xEof_signature, xEof_signatures[xEof_echoEof_enum], sizeof(E2.xEof_signature)) == 0) {
+ E1 = echoEof(args);
+ }
+ else if (memcmp(E2.xEof_signature, xEof_signatures[xEof_expertEof_enum], sizeof(E2.xEof_signature)) == 0) {
+ E1 = expertEof(args);
+ }
+ else if (memcmp(E2.xEof_signature, xEof_signatures[xEof_explainEof_enum], sizeof(E2.xEof_signature)) == 0) {
+ E1 = explainEof(args);
+ }
+ else if (memcmp(E2.xEof_signature, xEof_signatures[xEof_fsEof_enum], sizeof(E2.xEof_signature)) == 0) {
+ E1 = fsEof(args);
+ }
+ else if (memcmp(E2.xEof_signature, xEof_signatures[xEof_fsdirEof_enum], sizeof(E2.xEof_signature)) == 0) {
+ E1 = fsdirEof(args);
+ }
+ else if (memcmp(E2.xEof_signature, xEof_signatures[xEof_fstreeEof_enum], sizeof(E2.xEof_signature)) == 0) {
+ E1 = fstreeEof(args);
+ }
+ else if (memcmp(E2.xEof_signature, xEof_signatures[xEof_fts3EofMethod_enum], sizeof(E2.xEof_signature)) == 0) {
+ E1 = fts3EofMethod(args);
+ }
+ else if (memcmp(E2.xEof_signature, xEof_signatures[xEof_fts3auxEofMethod_enum], sizeof(E2.xEof_signature)) == 0) {
+ E1 = fts3auxEofMethod(args);
+ }
+ else if (memcmp(E2.xEof_signature, xEof_signatures[xEof_fts3termEofMethod_enum], sizeof(E2.xEof_signature)) == 0) {
+ E1 = fts3termEofMethod(args);
+ }
+ else if (memcmp(E2.xEof_signature, xEof_signatures[xEof_fts3tokEofMethod_enum], sizeof(E2.xEof_signature)) == 0) {
+ E1 = fts3tokEofMethod(args);
+ }
+ else if (memcmp(E2.xEof_signature, xEof_signatures[xEof_fuzzerEof_enum], sizeof(E2.xEof_signature)) == 0) {
+ E1 = fuzzerEof(args);
+ }
+ else if (memcmp(E2.xEof_signature, xEof_signatures[xEof_intarrayEof_enum], sizeof(E2.xEof_signature)) == 0) {
+ E1 = intarrayEof(args);
+ }
+ else if (memcmp(E2.xEof_signature, xEof_signatures[xEof_jsonEachEof_enum], sizeof(E2.xEof_signature)) == 0) {
+ E1 = jsonEachEof(args);
+ }
+ else if (memcmp(E2.xEof_signature, xEof_signatures[xEof_memstatEof_enum], sizeof(E2.xEof_signature)) == 0) {
+ E1 = memstatEof(args);
+ }
+ else if (memcmp(E2.xEof_signature, xEof_signatures[xEof_pragmaVtabEof_enum], sizeof(E2.xEof_signature)) == 0) {
+ E1 = pragmaVtabEof(args);
+ }
+ else if (memcmp(E2.xEof_signature, xEof_signatures[xEof_prefixesEof_enum], sizeof(E2.xEof_signature)) == 0) {
+ E1 = prefixesEof(args);
+ }
+ else if (memcmp(E2.xEof_signature, xEof_signatures[xEof_qpvtabEof_enum], sizeof(E2.xEof_signature)) == 0) {
+ E1 = qpvtabEof(args);
+ }
+ else if (memcmp(E2.xEof_signature, xEof_signatures[xEof_rtreeEof_enum], sizeof(E2.xEof_signature)) == 0) {
+ E1 = rtreeEof(args);
+ }
+ else if (memcmp(E2.xEof_signature, xEof_signatures[xEof_schemaEof_enum], sizeof(E2.xEof_signature)) == 0) {
+ E1 = schemaEof(args);
+ }
+ else if (memcmp(E2.xEof_signature, xEof_signatures[xEof_seriesEof_enum], sizeof(E2.xEof_signature)) == 0) {
+ E1 = seriesEof(args);
+ }
+ else if (memcmp(E2.xEof_signature, xEof_signatures[xEof_spellfix1Eof_enum], sizeof(E2.xEof_signature)) == 0) {
+ E1 = spellfix1Eof(args);
+ }
+ else if (memcmp(E2.xEof_signature, xEof_signatures[xEof_statEof_enum], sizeof(E2.xEof_signature)) == 0) {
+ E1 = statEof(args);
+ }
+ else if (memcmp(E2.xEof_signature, xEof_signatures[xEof_stmtEof_enum], sizeof(E2.xEof_signature)) == 0) {
+ E1 = stmtEof(args);
+ }
+ else if (memcmp(E2.xEof_signature, xEof_signatures[xEof_tclEof_enum], sizeof(E2.xEof_signature)) == 0) {
+ E1 = tclEof(args);
+ }
+ else if (memcmp(E2.xEof_signature, xEof_signatures[xEof_tclvarEof_enum], sizeof(E2.xEof_signature)) == 0) {
+ E1 = tclvarEof(args);
+ }
+ else if (memcmp(E2.xEof_signature, xEof_signatures[xEof_templatevtabEof_enum], sizeof(E2.xEof_signature)) == 0) {
+ E1 = templatevtabEof(args);
+ }
+ else if (memcmp(E2.xEof_signature, xEof_signatures[xEof_unionEof_enum], sizeof(E2.xEof_signature)) == 0) {
+ E1 = unionEof(args);
+ }
+ else if (memcmp(E2.xEof_signature, xEof_signatures[xEof_vlogEof_enum], sizeof(E2.xEof_signature)) == 0) {
+ E1 = vlogEof(args);
+ }
+ else if (memcmp(E2.xEof_signature, xEof_signatures[xEof_vstattabEof_enum], sizeof(E2.xEof_signature)) == 0) {
+ E1 = vstattabEof(args);
+ }
+ else if (memcmp(E2.xEof_signature, xEof_signatures[xEof_vtablogEof_enum], sizeof(E2.xEof_signature)) == 0) {
+ E1 = vtablogEof(args);
+ }
+ else if (memcmp(E2.xEof_signature, xEof_signatures[xEof_wholenumberEof_enum], sizeof(E2.xEof_signature)) == 0) {
+ E1 = wholenumberEof(args);
+ }
+ else if (memcmp(E2.xEof_signature, xEof_signatures[xEof_zipfileEof_enum], sizeof(E2.xEof_signature)) == 0) {
+ E1 = zipfileEof(args);
+ }


// Transform E1 = E2.xExprCallback(args) to if-chain with 37 candidates
@transform_assignment_xExprCallback@
expression E1, E2;
identifier FP_NAME = xExprCallback;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_agginfoPersistExprCb_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = agginfoPersistExprCb(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_aggregateIdxEprRefToColCallback_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = aggregateIdxEprRefToColCallback(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_analyzeAggregate_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = analyzeAggregate(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_checkConstraintExprNode_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = checkConstraintExprNode(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_codeCursorHintCheckExpr_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = codeCursorHintCheckExpr(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_codeCursorHintFixExpr_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = codeCursorHintFixExpr(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_codeCursorHintIsOrFunction_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = codeCursorHintIsOrFunction(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_disallowAggregatesInOrderByCb_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = disallowAggregatesInOrderByCb(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprColumnFlagUnion_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = exprColumnFlagUnion(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprIdxCover_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = exprIdxCover(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprNodeCanReturnSubtype_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = exprNodeCanReturnSubtype(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprNodeIsConstant_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = exprNodeIsConstant(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprNodeIsConstantOrGroupBy_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = exprNodeIsConstantOrGroupBy(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprNodeIsDeterministic_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = exprNodeIsDeterministic(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_exprRefToSrcList_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = exprRefToSrcList(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_fixExprCb_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = fixExprCb(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_gatherSelectWindowsCallback_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = gatherSelectWindowsCallback(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_havingToWhereExprCb_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = havingToWhereExprCb(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_impliesNotNullRow_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = impliesNotNullRow(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_incrAggDepth_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = incrAggDepth(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_markImmutableExprStep_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = markImmutableExprStep(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_propagateConstantExprRewrite_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = propagateConstantExprRewrite(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_recomputeColumnsUsedExpr_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = recomputeColumnsUsedExpr(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_renameColumnExprCb_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = renameColumnExprCb(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_renameQuotefixExprCb_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = renameQuotefixExprCb(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_renameTableExprCb_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = renameTableExprCb(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_renameUnmapExprCb_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = renameUnmapExprCb(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_renumberCursorsCb_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = renumberCursorsCb(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_resolveExprStep_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = resolveExprStep(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_resolveRemoveWindowsCb_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = resolveRemoveWindowsCb(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_selectCheckOnClausesExpr_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = selectCheckOnClausesExpr(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_selectWindowRewriteExprCb_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = selectWindowRewriteExprCb(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_sqlite3CursorRangeHintExprCheck_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = sqlite3CursorRangeHintExprCheck(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_sqlite3ExprWalkNoop_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = sqlite3ExprWalkNoop(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_sqlite3ReturningSubqueryVarSelect_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = sqlite3ReturningSubqueryVarSelect(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_sqlite3WindowExtraAggFuncDepth_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = sqlite3WindowExtraAggFuncDepth(args);
+ }
+ else if (memcmp(E2.xExprCallback_signature, xExprCallback_signatures[xExprCallback_whereIsCoveringIndexWalkCallback_enum], sizeof(E2.xExprCallback_signature)) == 0) {
+ E1 = whereIsCoveringIndexWalkCallback(args);
+ }


// Transform E1 = E2.xFetch(args) to if-chain with 6 candidates
@transform_assignment_xFetch@
expression E1, E2;
identifier FP_NAME = xFetch;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xFetch_signature, xFetch_signatures[xFetch_0_enum], sizeof(E2.xFetch_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xFetch_signature, xFetch_signatures[xFetch_apndFetch_enum], sizeof(E2.xFetch_signature)) == 0) {
+ E1 = apndFetch(args);
+ }
+ else if (memcmp(E2.xFetch_signature, xFetch_signatures[xFetch_memdbFetch_enum], sizeof(E2.xFetch_signature)) == 0) {
+ E1 = memdbFetch(args);
+ }
+ else if (memcmp(E2.xFetch_signature, xFetch_signatures[xFetch_pcache1Fetch_enum], sizeof(E2.xFetch_signature)) == 0) {
+ E1 = pcache1Fetch(args);
+ }
+ else if (memcmp(E2.xFetch_signature, xFetch_signatures[xFetch_pcachetraceFetch_enum], sizeof(E2.xFetch_signature)) == 0) {
+ E1 = pcachetraceFetch(args);
+ }
+ else if (memcmp(E2.xFetch_signature, xFetch_signatures[xFetch_recoverVfsFetch_enum], sizeof(E2.xFetch_signature)) == 0) {
+ E1 = recoverVfsFetch(args);
+ }
+ else if (memcmp(E2.xFetch_signature, xFetch_signatures[xFetch_unixFetch_enum], sizeof(E2.xFetch_signature)) == 0) {
+ E1 = unixFetch(args);
+ }


// Transform E1 = E2.xFileControl(args) to if-chain with 5 candidates
@transform_assignment_xFileControl@
expression E1, E2;
identifier FP_NAME = xFileControl;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xFileControl_signature, xFileControl_signatures[xFileControl_0_enum], sizeof(E2.xFileControl_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xFileControl_signature, xFileControl_signatures[xFileControl_apndFileControl_enum], sizeof(E2.xFileControl_signature)) == 0) {
+ E1 = apndFileControl(args);
+ }
+ else if (memcmp(E2.xFileControl_signature, xFileControl_signatures[xFileControl_memdbFileControl_enum], sizeof(E2.xFileControl_signature)) == 0) {
+ E1 = memdbFileControl(args);
+ }
+ else if (memcmp(E2.xFileControl_signature, xFileControl_signatures[xFileControl_recoverVfsFileControl_enum], sizeof(E2.xFileControl_signature)) == 0) {
+ E1 = recoverVfsFileControl(args);
+ }
+ else if (memcmp(E2.xFileControl_signature, xFileControl_signatures[xFileControl_vfstraceFileControl_enum], sizeof(E2.xFileControl_signature)) == 0) {
+ E1 = vfstraceFileControl(args);
+ }
+ else if (memcmp(E2.xFileControl_signature, xFileControl_signatures[xFileControl_unixFileControl_enum], sizeof(E2.xFileControl_signature)) == 0) {
+ E1 = unixFileControl(args);
+ }


// Transform E1 = E2.xFileSize(args) to if-chain with 6 candidates
@transform_assignment_xFileSize@
expression E1, E2;
identifier FP_NAME = xFileSize;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xFileSize_signature, xFileSize_signatures[xFileSize_apndFileSize_enum], sizeof(E2.xFileSize_signature)) == 0) {
+ E1 = apndFileSize(args);
+ }
+ else if (memcmp(E2.xFileSize_signature, xFileSize_signatures[xFileSize_memdbFileSize_enum], sizeof(E2.xFileSize_signature)) == 0) {
+ E1 = memdbFileSize(args);
+ }
+ else if (memcmp(E2.xFileSize_signature, xFileSize_signatures[xFileSize_memjrnlFileSize_enum], sizeof(E2.xFileSize_signature)) == 0) {
+ E1 = memjrnlFileSize(args);
+ }
+ else if (memcmp(E2.xFileSize_signature, xFileSize_signatures[xFileSize_recoverVfsFileSize_enum], sizeof(E2.xFileSize_signature)) == 0) {
+ E1 = recoverVfsFileSize(args);
+ }
+ else if (memcmp(E2.xFileSize_signature, xFileSize_signatures[xFileSize_vfstraceFileSize_enum], sizeof(E2.xFileSize_signature)) == 0) {
+ E1 = vfstraceFileSize(args);
+ }
+ else if (memcmp(E2.xFileSize_signature, xFileSize_signatures[xFileSize_unixFileSize_enum], sizeof(E2.xFileSize_signature)) == 0) {
+ E1 = unixFileSize(args);
+ }


// Transform E1 = E2.xFilter(args) to if-chain with 44 candidates
@transform_assignment_xFilter@
expression E1, E2;
identifier FP_NAME = xFilter;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xFilter_signature, xFilter_signatures[xFilter_amatchFilter_enum], sizeof(E2.xFilter_signature)) == 0) {
+ E1 = amatchFilter(args);
+ }
+ else if (memcmp(E2.xFilter_signature, xFilter_signatures[xFilter_binfoFilter_enum], sizeof(E2.xFilter_signature)) == 0) {
+ E1 = binfoFilter(args);
+ }
+ else if (memcmp(E2.xFilter_signature, xFilter_signatures[xFilter_bytecodevtabFilter_enum], sizeof(E2.xFilter_signature)) == 0) {
+ E1 = bytecodevtabFilter(args);
+ }
+ else if (memcmp(E2.xFilter_signature, xFilter_signatures[xFilter_carrayFilter_enum], sizeof(E2.xFilter_signature)) == 0) {
+ E1 = carrayFilter(args);
+ }
+ else if (memcmp(E2.xFilter_signature, xFilter_signatures[xFilter_cidxFilter_enum], sizeof(E2.xFilter_signature)) == 0) {
+ E1 = cidxFilter(args);
+ }
+ else if (memcmp(E2.xFilter_signature, xFilter_signatures[xFilter_closureFilter_enum], sizeof(E2.xFilter_signature)) == 0) {
+ E1 = closureFilter(args);
+ }
+ else if (memcmp(E2.xFilter_signature, xFilter_signatures[xFilter_completionFilter_enum], sizeof(E2.xFilter_signature)) == 0) {
+ E1 = completionFilter(args);
+ }
+ else if (memcmp(E2.xFilter_signature, xFilter_signatures[xFilter_csvtabFilter_enum], sizeof(E2.xFilter_signature)) == 0) {
+ E1 = csvtabFilter(args);
+ }
+ else if (memcmp(E2.xFilter_signature, xFilter_signatures[xFilter_dbdataFilter_enum], sizeof(E2.xFilter_signature)) == 0) {
+ E1 = dbdataFilter(args);
+ }
+ else if (memcmp(E2.xFilter_signature, xFilter_signatures[xFilter_dbpageFilter_enum], sizeof(E2.xFilter_signature)) == 0) {
+ E1 = dbpageFilter(args);
+ }
+ else if (memcmp(E2.xFilter_signature, xFilter_signatures[xFilter_deltaparsevtabFilter_enum], sizeof(E2.xFilter_signature)) == 0) {
+ E1 = deltaparsevtabFilter(args);
+ }
+ else if (memcmp(E2.xFilter_signature, xFilter_signatures[xFilter_echoFilter_enum], sizeof(E2.xFilter_signature)) == 0) {
+ E1 = echoFilter(args);
+ }
+ else if (memcmp(E2.xFilter_signature, xFilter_signatures[xFilter_expertFilter_enum], sizeof(E2.xFilter_signature)) == 0) {
+ E1 = expertFilter(args);
+ }
+ else if (memcmp(E2.xFilter_signature, xFilter_signatures[xFilter_explainFilter_enum], sizeof(E2.xFilter_signature)) == 0) {
+ E1 = explainFilter(args);
+ }
+ else if (memcmp(E2.xFilter_signature, xFilter_signatures[xFilter_fsFilter_enum], sizeof(E2.xFilter_signature)) == 0) {
+ E1 = fsFilter(args);
+ }
+ else if (memcmp(E2.xFilter_signature, xFilter_signatures[xFilter_fsdirFilter_enum], sizeof(E2.xFilter_signature)) == 0) {
+ E1 = fsdirFilter(args);
+ }
+ else if (memcmp(E2.xFilter_signature, xFilter_signatures[xFilter_fstreeFilter_enum], sizeof(E2.xFilter_signature)) == 0) {
+ E1 = fstreeFilter(args);
+ }
+ else if (memcmp(E2.xFilter_signature, xFilter_signatures[xFilter_fts3FilterMethod_enum], sizeof(E2.xFilter_signature)) == 0) {
+ E1 = fts3FilterMethod(args);
+ }
+ else if (memcmp(E2.xFilter_signature, xFilter_signatures[xFilter_fts3auxFilterMethod_enum], sizeof(E2.xFilter_signature)) == 0) {
+ E1 = fts3auxFilterMethod(args);
+ }
+ else if (memcmp(E2.xFilter_signature, xFilter_signatures[xFilter_fts3termFilterMethod_enum], sizeof(E2.xFilter_signature)) == 0) {
+ E1 = fts3termFilterMethod(args);
+ }
+ else if (memcmp(E2.xFilter_signature, xFilter_signatures[xFilter_fts3tokFilterMethod_enum], sizeof(E2.xFilter_signature)) == 0) {
+ E1 = fts3tokFilterMethod(args);
+ }
+ else if (memcmp(E2.xFilter_signature, xFilter_signatures[xFilter_fuzzerFilter_enum], sizeof(E2.xFilter_signature)) == 0) {
+ E1 = fuzzerFilter(args);
+ }
+ else if (memcmp(E2.xFilter_signature, xFilter_signatures[xFilter_geopolyFilter_enum], sizeof(E2.xFilter_signature)) == 0) {
+ E1 = geopolyFilter(args);
+ }
+ else if (memcmp(E2.xFilter_signature, xFilter_signatures[xFilter_intarrayFilter_enum], sizeof(E2.xFilter_signature)) == 0) {
+ E1 = intarrayFilter(args);
+ }
+ else if (memcmp(E2.xFilter_signature, xFilter_signatures[xFilter_jsonEachFilter_enum], sizeof(E2.xFilter_signature)) == 0) {
+ E1 = jsonEachFilter(args);
+ }
+ else if (memcmp(E2.xFilter_signature, xFilter_signatures[xFilter_memstatFilter_enum], sizeof(E2.xFilter_signature)) == 0) {
+ E1 = memstatFilter(args);
+ }
+ else if (memcmp(E2.xFilter_signature, xFilter_signatures[xFilter_pragmaVtabFilter_enum], sizeof(E2.xFilter_signature)) == 0) {
+ E1 = pragmaVtabFilter(args);
+ }
+ else if (memcmp(E2.xFilter_signature, xFilter_signatures[xFilter_prefixesFilter_enum], sizeof(E2.xFilter_signature)) == 0) {
+ E1 = prefixesFilter(args);
+ }
+ else if (memcmp(E2.xFilter_signature, xFilter_signatures[xFilter_qpvtabFilter_enum], sizeof(E2.xFilter_signature)) == 0) {
+ E1 = qpvtabFilter(args);
+ }
+ else if (memcmp(E2.xFilter_signature, xFilter_signatures[xFilter_rtreeFilter_enum], sizeof(E2.xFilter_signature)) == 0) {
+ E1 = rtreeFilter(args);
+ }
+ else if (memcmp(E2.xFilter_signature, xFilter_signatures[xFilter_schemaFilter_enum], sizeof(E2.xFilter_signature)) == 0) {
+ E1 = schemaFilter(args);
+ }
+ else if (memcmp(E2.xFilter_signature, xFilter_signatures[xFilter_seriesFilter_enum], sizeof(E2.xFilter_signature)) == 0) {
+ E1 = seriesFilter(args);
+ }
+ else if (memcmp(E2.xFilter_signature, xFilter_signatures[xFilter_spellfix1Filter_enum], sizeof(E2.xFilter_signature)) == 0) {
+ E1 = spellfix1Filter(args);
+ }
+ else if (memcmp(E2.xFilter_signature, xFilter_signatures[xFilter_statFilter_enum], sizeof(E2.xFilter_signature)) == 0) {
+ E1 = statFilter(args);
+ }
+ else if (memcmp(E2.xFilter_signature, xFilter_signatures[xFilter_stmtFilter_enum], sizeof(E2.xFilter_signature)) == 0) {
+ E1 = stmtFilter(args);
+ }
+ else if (memcmp(E2.xFilter_signature, xFilter_signatures[xFilter_tclFilter_enum], sizeof(E2.xFilter_signature)) == 0) {
+ E1 = tclFilter(args);
+ }
+ else if (memcmp(E2.xFilter_signature, xFilter_signatures[xFilter_tclvarFilter_enum], sizeof(E2.xFilter_signature)) == 0) {
+ E1 = tclvarFilter(args);
+ }
+ else if (memcmp(E2.xFilter_signature, xFilter_signatures[xFilter_templatevtabFilter_enum], sizeof(E2.xFilter_signature)) == 0) {
+ E1 = templatevtabFilter(args);
+ }
+ else if (memcmp(E2.xFilter_signature, xFilter_signatures[xFilter_unionFilter_enum], sizeof(E2.xFilter_signature)) == 0) {
+ E1 = unionFilter(args);
+ }
+ else if (memcmp(E2.xFilter_signature, xFilter_signatures[xFilter_vlogFilter_enum], sizeof(E2.xFilter_signature)) == 0) {
+ E1 = vlogFilter(args);
+ }
+ else if (memcmp(E2.xFilter_signature, xFilter_signatures[xFilter_vstattabFilter_enum], sizeof(E2.xFilter_signature)) == 0) {
+ E1 = vstattabFilter(args);
+ }
+ else if (memcmp(E2.xFilter_signature, xFilter_signatures[xFilter_vtablogFilter_enum], sizeof(E2.xFilter_signature)) == 0) {
+ E1 = vtablogFilter(args);
+ }
+ else if (memcmp(E2.xFilter_signature, xFilter_signatures[xFilter_wholenumberFilter_enum], sizeof(E2.xFilter_signature)) == 0) {
+ E1 = wholenumberFilter(args);
+ }
+ else if (memcmp(E2.xFilter_signature, xFilter_signatures[xFilter_zipfileFilter_enum], sizeof(E2.xFilter_signature)) == 0) {
+ E1 = zipfileFilter(args);
+ }


// Transform E1 = E2.xFindFunction(args) to if-chain with 2 candidates
@transform_assignment_xFindFunction@
expression E1, E2;
identifier FP_NAME = xFindFunction;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xFindFunction_signature, xFindFunction_signatures[xFindFunction_0_enum], sizeof(E2.xFindFunction_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xFindFunction_signature, xFindFunction_signatures[xFindFunction_fts3FindFunctionMethod_enum], sizeof(E2.xFindFunction_signature)) == 0) {
+ E1 = fts3FindFunctionMethod(args);
+ }
+ else if (memcmp(E2.xFindFunction_signature, xFindFunction_signatures[xFindFunction_zipfileFindFunction_enum], sizeof(E2.xFindFunction_signature)) == 0) {
+ E1 = zipfileFindFunction(args);
+ }


// Transform E1 = E2.xFree(args) to if-chain with 2 candidates
@transform_assignment_xFree@
expression E1, E2;
identifier FP_NAME = xFree;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xFree_signature, xFree_signatures[xFree_memtraceFree_enum], sizeof(E2.xFree_signature)) == 0) {
+ E1 = memtraceFree(args);
+ }
+ else if (memcmp(E2.xFree_signature, xFree_signatures[xFree_sqlite3MemFree_enum], sizeof(E2.xFree_signature)) == 0) {
+ E1 = sqlite3MemFree(args);
+ }


// Transform E1 = E2.xFullPathname(args) to if-chain with 4 candidates
@transform_assignment_xFullPathname@
expression E1, E2;
identifier FP_NAME = xFullPathname;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xFullPathname_signature, xFullPathname_signatures[xFullPathname_apndFullPathname_enum], sizeof(E2.xFullPathname_signature)) == 0) {
+ E1 = apndFullPathname(args);
+ }
+ else if (memcmp(E2.xFullPathname_signature, xFullPathname_signatures[xFullPathname_memdbFullPathname_enum], sizeof(E2.xFullPathname_signature)) == 0) {
+ E1 = memdbFullPathname(args);
+ }
+ else if (memcmp(E2.xFullPathname_signature, xFullPathname_signatures[xFullPathname_vfstraceFullPathname_enum], sizeof(E2.xFullPathname_signature)) == 0) {
+ E1 = vfstraceFullPathname(args);
+ }
+ else if (memcmp(E2.xFullPathname_signature, xFullPathname_signatures[xFullPathname_unixFullPathname_enum], sizeof(E2.xFullPathname_signature)) == 0) {
+ E1 = unixFullPathname(args);
+ }


// Transform E1 = E2.xGet(args) to if-chain with 3 candidates
@transform_assignment_xGet@
expression E1, E2;
identifier FP_NAME = xGet;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xGet_signature, xGet_signatures[xGet_getPageError_enum], sizeof(E2.xGet_signature)) == 0) {
+ E1 = getPageError(args);
+ }
+ else if (memcmp(E2.xGet_signature, xGet_signatures[xGet_getPageMMap_enum], sizeof(E2.xGet_signature)) == 0) {
+ E1 = getPageMMap(args);
+ }
+ else if (memcmp(E2.xGet_signature, xGet_signatures[xGet_getPageNormal_enum], sizeof(E2.xGet_signature)) == 0) {
+ E1 = getPageNormal(args);
+ }


// Transform E1 = E2.xGetLastError(args) to if-chain with 3 candidates
@transform_assignment_xGetLastError@
expression E1, E2;
identifier FP_NAME = xGetLastError;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xGetLastError_signature, xGetLastError_signatures[xGetLastError_0_enum], sizeof(E2.xGetLastError_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xGetLastError_signature, xGetLastError_signatures[xGetLastError_apndGetLastError_enum], sizeof(E2.xGetLastError_signature)) == 0) {
+ E1 = apndGetLastError(args);
+ }
+ else if (memcmp(E2.xGetLastError_signature, xGetLastError_signatures[xGetLastError_memdbGetLastError_enum], sizeof(E2.xGetLastError_signature)) == 0) {
+ E1 = memdbGetLastError(args);
+ }
+ else if (memcmp(E2.xGetLastError_signature, xGetLastError_signatures[xGetLastError_unixGetLastError_enum], sizeof(E2.xGetLastError_signature)) == 0) {
+ E1 = unixGetLastError(args);
+ }


// Transform E1 = E2.xGetSystemCall(args) to if-chain with 2 candidates
@transform_assignment_xGetSystemCall@
expression E1, E2;
identifier FP_NAME = xGetSystemCall;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xGetSystemCall_signature, xGetSystemCall_signatures[xGetSystemCall_0_enum], sizeof(E2.xGetSystemCall_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xGetSystemCall_signature, xGetSystemCall_signatures[xGetSystemCall_apndGetSystemCall_enum], sizeof(E2.xGetSystemCall_signature)) == 0) {
+ E1 = apndGetSystemCall(args);
+ }
+ else if (memcmp(E2.xGetSystemCall_signature, xGetSystemCall_signatures[xGetSystemCall_unixGetSystemCall_enum], sizeof(E2.xGetSystemCall_signature)) == 0) {
+ E1 = unixGetSystemCall(args);
+ }


// Transform E1 = E2.xInit(args) to if-chain with 4 candidates
@transform_assignment_xInit@
expression E1, E2;
identifier FP_NAME = xInit;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xInit_signature, xInit_signatures[xInit_memtraceInit_enum], sizeof(E2.xInit_signature)) == 0) {
+ E1 = memtraceInit(args);
+ }
+ else if (memcmp(E2.xInit_signature, xInit_signatures[xInit_pcache1Init_enum], sizeof(E2.xInit_signature)) == 0) {
+ E1 = pcache1Init(args);
+ }
+ else if (memcmp(E2.xInit_signature, xInit_signatures[xInit_pcachetraceInit_enum], sizeof(E2.xInit_signature)) == 0) {
+ E1 = pcachetraceInit(args);
+ }
+ else if (memcmp(E2.xInit_signature, xInit_signatures[xInit_sqlite3MemInit_enum], sizeof(E2.xInit_signature)) == 0) {
+ E1 = sqlite3MemInit(args);
+ }


// Transform E1 = E2.xIntegrity(args) to if-chain with 3 candidates
@transform_assignment_xIntegrity@
expression E1, E2;
identifier FP_NAME = xIntegrity;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xIntegrity_signature, xIntegrity_signatures[xIntegrity_0_enum], sizeof(E2.xIntegrity_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xIntegrity_signature, xIntegrity_signatures[xIntegrity_fts3IntegrityMethod_enum], sizeof(E2.xIntegrity_signature)) == 0) {
+ E1 = fts3IntegrityMethod(args);
+ }
+ else if (memcmp(E2.xIntegrity_signature, xIntegrity_signatures[xIntegrity_rtreeIntegrity_enum], sizeof(E2.xIntegrity_signature)) == 0) {
+ E1 = rtreeIntegrity(args);
+ }
+ else if (memcmp(E2.xIntegrity_signature, xIntegrity_signatures[xIntegrity_vtablogIntegrity_enum], sizeof(E2.xIntegrity_signature)) == 0) {
+ E1 = vtablogIntegrity(args);
+ }


// Transform E1 = E2.xLock(args) to if-chain with 7 candidates
@transform_assignment_xLock@
expression E1, E2;
identifier FP_NAME = xLock;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xLock_signature, xLock_signatures[xLock_0_enum], sizeof(E2.xLock_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xLock_signature, xLock_signatures[xLock_apndLock_enum], sizeof(E2.xLock_signature)) == 0) {
+ E1 = apndLock(args);
+ }
+ else if (memcmp(E2.xLock_signature, xLock_signatures[xLock_memdbLock_enum], sizeof(E2.xLock_signature)) == 0) {
+ E1 = memdbLock(args);
+ }
+ else if (memcmp(E2.xLock_signature, xLock_signatures[xLock_recoverVfsLock_enum], sizeof(E2.xLock_signature)) == 0) {
+ E1 = recoverVfsLock(args);
+ }
+ else if (memcmp(E2.xLock_signature, xLock_signatures[xLock_vfstraceLock_enum], sizeof(E2.xLock_signature)) == 0) {
+ E1 = vfstraceLock(args);
+ }
+ else if (memcmp(E2.xLock_signature, xLock_signatures[xLock_unixLock_enum], sizeof(E2.xLock_signature)) == 0) {
+ E1 = unixLock(args);
+ }
+ else if (memcmp(E2.xLock_signature, xLock_signatures[xLock_nolockLock_enum], sizeof(E2.xLock_signature)) == 0) {
+ E1 = nolockLock(args);
+ }
+ else if (memcmp(E2.xLock_signature, xLock_signatures[xLock_dotlockLock_enum], sizeof(E2.xLock_signature)) == 0) {
+ E1 = dotlockLock(args);
+ }


// Transform E1 = E2.xMalloc(args) to if-chain with 2 candidates
@transform_assignment_xMalloc@
expression E1, E2;
identifier FP_NAME = xMalloc;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xMalloc_signature, xMalloc_signatures[xMalloc_memtraceMalloc_enum], sizeof(E2.xMalloc_signature)) == 0) {
+ E1 = memtraceMalloc(args);
+ }
+ else if (memcmp(E2.xMalloc_signature, xMalloc_signatures[xMalloc_sqlite3MemMalloc_enum], sizeof(E2.xMalloc_signature)) == 0) {
+ E1 = sqlite3MemMalloc(args);
+ }


// Transform E1 = E2.xMutexAlloc(args) to if-chain with 7 candidates
@transform_assignment_xMutexAlloc@
expression E1, E2;
identifier FP_NAME = xMutexAlloc;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_checkMutexAlloc_enum], sizeof(E2.xMutexAlloc_signature)) == 0) {
+ E1 = checkMutexAlloc(args);
+ }
+ else if (memcmp(E2.xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_counterMutexAlloc_enum], sizeof(E2.xMutexAlloc_signature)) == 0) {
+ E1 = counterMutexAlloc(args);
+ }
+ else if (memcmp(E2.xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_debugMutexAlloc_enum], sizeof(E2.xMutexAlloc_signature)) == 0) {
+ E1 = debugMutexAlloc(args);
+ }
+ else if (memcmp(E2.xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_noopMutexAlloc_enum], sizeof(E2.xMutexAlloc_signature)) == 0) {
+ E1 = noopMutexAlloc(args);
+ }
+ else if (memcmp(E2.xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_pthreadMutexAlloc_enum], sizeof(E2.xMutexAlloc_signature)) == 0) {
+ E1 = pthreadMutexAlloc(args);
+ }
+ else if (memcmp(E2.xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_winMutexAlloc_enum], sizeof(E2.xMutexAlloc_signature)) == 0) {
+ E1 = winMutexAlloc(args);
+ }
+ else if (memcmp(E2.xMutexAlloc_signature, xMutexAlloc_signatures[xMutexAlloc_wrMutexAlloc_enum], sizeof(E2.xMutexAlloc_signature)) == 0) {
+ E1 = wrMutexAlloc(args);
+ }


// Transform E1 = E2.xMutexEnd(args) to if-chain with 7 candidates
@transform_assignment_xMutexEnd@
expression E1, E2;
identifier FP_NAME = xMutexEnd;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_checkMutexEnd_enum], sizeof(E2.xMutexEnd_signature)) == 0) {
+ E1 = checkMutexEnd(args);
+ }
+ else if (memcmp(E2.xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_counterMutexEnd_enum], sizeof(E2.xMutexEnd_signature)) == 0) {
+ E1 = counterMutexEnd(args);
+ }
+ else if (memcmp(E2.xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_debugMutexEnd_enum], sizeof(E2.xMutexEnd_signature)) == 0) {
+ E1 = debugMutexEnd(args);
+ }
+ else if (memcmp(E2.xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_noopMutexEnd_enum], sizeof(E2.xMutexEnd_signature)) == 0) {
+ E1 = noopMutexEnd(args);
+ }
+ else if (memcmp(E2.xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_pthreadMutexEnd_enum], sizeof(E2.xMutexEnd_signature)) == 0) {
+ E1 = pthreadMutexEnd(args);
+ }
+ else if (memcmp(E2.xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_winMutexEnd_enum], sizeof(E2.xMutexEnd_signature)) == 0) {
+ E1 = winMutexEnd(args);
+ }
+ else if (memcmp(E2.xMutexEnd_signature, xMutexEnd_signatures[xMutexEnd_wrMutexEnd_enum], sizeof(E2.xMutexEnd_signature)) == 0) {
+ E1 = wrMutexEnd(args);
+ }


// Transform E1 = E2.xMutexEnter(args) to if-chain with 7 candidates
@transform_assignment_xMutexEnter@
expression E1, E2;
identifier FP_NAME = xMutexEnter;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_checkMutexEnter_enum], sizeof(E2.xMutexEnter_signature)) == 0) {
+ E1 = checkMutexEnter(args);
+ }
+ else if (memcmp(E2.xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_counterMutexEnter_enum], sizeof(E2.xMutexEnter_signature)) == 0) {
+ E1 = counterMutexEnter(args);
+ }
+ else if (memcmp(E2.xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_debugMutexEnter_enum], sizeof(E2.xMutexEnter_signature)) == 0) {
+ E1 = debugMutexEnter(args);
+ }
+ else if (memcmp(E2.xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_noopMutexEnter_enum], sizeof(E2.xMutexEnter_signature)) == 0) {
+ E1 = noopMutexEnter(args);
+ }
+ else if (memcmp(E2.xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_pthreadMutexEnter_enum], sizeof(E2.xMutexEnter_signature)) == 0) {
+ E1 = pthreadMutexEnter(args);
+ }
+ else if (memcmp(E2.xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_winMutexEnter_enum], sizeof(E2.xMutexEnter_signature)) == 0) {
+ E1 = winMutexEnter(args);
+ }
+ else if (memcmp(E2.xMutexEnter_signature, xMutexEnter_signatures[xMutexEnter_wrMutexEnter_enum], sizeof(E2.xMutexEnter_signature)) == 0) {
+ E1 = wrMutexEnter(args);
+ }


// Transform E1 = E2.xMutexFree(args) to if-chain with 7 candidates
@transform_assignment_xMutexFree@
expression E1, E2;
identifier FP_NAME = xMutexFree;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xMutexFree_signature, xMutexFree_signatures[xMutexFree_checkMutexFree_enum], sizeof(E2.xMutexFree_signature)) == 0) {
+ E1 = checkMutexFree(args);
+ }
+ else if (memcmp(E2.xMutexFree_signature, xMutexFree_signatures[xMutexFree_counterMutexFree_enum], sizeof(E2.xMutexFree_signature)) == 0) {
+ E1 = counterMutexFree(args);
+ }
+ else if (memcmp(E2.xMutexFree_signature, xMutexFree_signatures[xMutexFree_debugMutexFree_enum], sizeof(E2.xMutexFree_signature)) == 0) {
+ E1 = debugMutexFree(args);
+ }
+ else if (memcmp(E2.xMutexFree_signature, xMutexFree_signatures[xMutexFree_noopMutexFree_enum], sizeof(E2.xMutexFree_signature)) == 0) {
+ E1 = noopMutexFree(args);
+ }
+ else if (memcmp(E2.xMutexFree_signature, xMutexFree_signatures[xMutexFree_pthreadMutexFree_enum], sizeof(E2.xMutexFree_signature)) == 0) {
+ E1 = pthreadMutexFree(args);
+ }
+ else if (memcmp(E2.xMutexFree_signature, xMutexFree_signatures[xMutexFree_winMutexFree_enum], sizeof(E2.xMutexFree_signature)) == 0) {
+ E1 = winMutexFree(args);
+ }
+ else if (memcmp(E2.xMutexFree_signature, xMutexFree_signatures[xMutexFree_wrMutexFree_enum], sizeof(E2.xMutexFree_signature)) == 0) {
+ E1 = wrMutexFree(args);
+ }


// Transform E1 = E2.xMutexHeld(args) to if-chain with 3 candidates
@transform_assignment_xMutexHeld@
expression E1, E2;
identifier FP_NAME = xMutexHeld;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xMutexHeld_signature, xMutexHeld_signatures[xMutexHeld_0_enum], sizeof(E2.xMutexHeld_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xMutexHeld_signature, xMutexHeld_signatures[xMutexHeld_counterMutexHeld_enum], sizeof(E2.xMutexHeld_signature)) == 0) {
+ E1 = counterMutexHeld(args);
+ }
+ else if (memcmp(E2.xMutexHeld_signature, xMutexHeld_signatures[xMutexHeld_debugMutexHeld_enum], sizeof(E2.xMutexHeld_signature)) == 0) {
+ E1 = debugMutexHeld(args);
+ }
+ else if (memcmp(E2.xMutexHeld_signature, xMutexHeld_signatures[xMutexHeld_wrMutexHeld_enum], sizeof(E2.xMutexHeld_signature)) == 0) {
+ E1 = wrMutexHeld(args);
+ }


// Transform E1 = E2.xMutexInit(args) to if-chain with 7 candidates
@transform_assignment_xMutexInit@
expression E1, E2;
identifier FP_NAME = xMutexInit;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xMutexInit_signature, xMutexInit_signatures[xMutexInit_checkMutexInit_enum], sizeof(E2.xMutexInit_signature)) == 0) {
+ E1 = checkMutexInit(args);
+ }
+ else if (memcmp(E2.xMutexInit_signature, xMutexInit_signatures[xMutexInit_counterMutexInit_enum], sizeof(E2.xMutexInit_signature)) == 0) {
+ E1 = counterMutexInit(args);
+ }
+ else if (memcmp(E2.xMutexInit_signature, xMutexInit_signatures[xMutexInit_debugMutexInit_enum], sizeof(E2.xMutexInit_signature)) == 0) {
+ E1 = debugMutexInit(args);
+ }
+ else if (memcmp(E2.xMutexInit_signature, xMutexInit_signatures[xMutexInit_noopMutexInit_enum], sizeof(E2.xMutexInit_signature)) == 0) {
+ E1 = noopMutexInit(args);
+ }
+ else if (memcmp(E2.xMutexInit_signature, xMutexInit_signatures[xMutexInit_pthreadMutexInit_enum], sizeof(E2.xMutexInit_signature)) == 0) {
+ E1 = pthreadMutexInit(args);
+ }
+ else if (memcmp(E2.xMutexInit_signature, xMutexInit_signatures[xMutexInit_winMutexInit_enum], sizeof(E2.xMutexInit_signature)) == 0) {
+ E1 = winMutexInit(args);
+ }
+ else if (memcmp(E2.xMutexInit_signature, xMutexInit_signatures[xMutexInit_wrMutexInit_enum], sizeof(E2.xMutexInit_signature)) == 0) {
+ E1 = wrMutexInit(args);
+ }


// Transform E1 = E2.xMutexLeave(args) to if-chain with 7 candidates
@transform_assignment_xMutexLeave@
expression E1, E2;
identifier FP_NAME = xMutexLeave;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_checkMutexLeave_enum], sizeof(E2.xMutexLeave_signature)) == 0) {
+ E1 = checkMutexLeave(args);
+ }
+ else if (memcmp(E2.xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_counterMutexLeave_enum], sizeof(E2.xMutexLeave_signature)) == 0) {
+ E1 = counterMutexLeave(args);
+ }
+ else if (memcmp(E2.xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_debugMutexLeave_enum], sizeof(E2.xMutexLeave_signature)) == 0) {
+ E1 = debugMutexLeave(args);
+ }
+ else if (memcmp(E2.xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_noopMutexLeave_enum], sizeof(E2.xMutexLeave_signature)) == 0) {
+ E1 = noopMutexLeave(args);
+ }
+ else if (memcmp(E2.xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_pthreadMutexLeave_enum], sizeof(E2.xMutexLeave_signature)) == 0) {
+ E1 = pthreadMutexLeave(args);
+ }
+ else if (memcmp(E2.xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_winMutexLeave_enum], sizeof(E2.xMutexLeave_signature)) == 0) {
+ E1 = winMutexLeave(args);
+ }
+ else if (memcmp(E2.xMutexLeave_signature, xMutexLeave_signatures[xMutexLeave_wrMutexLeave_enum], sizeof(E2.xMutexLeave_signature)) == 0) {
+ E1 = wrMutexLeave(args);
+ }


// Transform E1 = E2.xMutexNotheld(args) to if-chain with 3 candidates
@transform_assignment_xMutexNotheld@
expression E1, E2;
identifier FP_NAME = xMutexNotheld;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xMutexNotheld_signature, xMutexNotheld_signatures[xMutexNotheld_0_enum], sizeof(E2.xMutexNotheld_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xMutexNotheld_signature, xMutexNotheld_signatures[xMutexNotheld_counterMutexNotheld_enum], sizeof(E2.xMutexNotheld_signature)) == 0) {
+ E1 = counterMutexNotheld(args);
+ }
+ else if (memcmp(E2.xMutexNotheld_signature, xMutexNotheld_signatures[xMutexNotheld_debugMutexNotheld_enum], sizeof(E2.xMutexNotheld_signature)) == 0) {
+ E1 = debugMutexNotheld(args);
+ }
+ else if (memcmp(E2.xMutexNotheld_signature, xMutexNotheld_signatures[xMutexNotheld_wrMutexNotheld_enum], sizeof(E2.xMutexNotheld_signature)) == 0) {
+ E1 = wrMutexNotheld(args);
+ }


// Transform E1 = E2.xMutexTry(args) to if-chain with 7 candidates
@transform_assignment_xMutexTry@
expression E1, E2;
identifier FP_NAME = xMutexTry;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xMutexTry_signature, xMutexTry_signatures[xMutexTry_checkMutexTry_enum], sizeof(E2.xMutexTry_signature)) == 0) {
+ E1 = checkMutexTry(args);
+ }
+ else if (memcmp(E2.xMutexTry_signature, xMutexTry_signatures[xMutexTry_counterMutexTry_enum], sizeof(E2.xMutexTry_signature)) == 0) {
+ E1 = counterMutexTry(args);
+ }
+ else if (memcmp(E2.xMutexTry_signature, xMutexTry_signatures[xMutexTry_debugMutexTry_enum], sizeof(E2.xMutexTry_signature)) == 0) {
+ E1 = debugMutexTry(args);
+ }
+ else if (memcmp(E2.xMutexTry_signature, xMutexTry_signatures[xMutexTry_noopMutexTry_enum], sizeof(E2.xMutexTry_signature)) == 0) {
+ E1 = noopMutexTry(args);
+ }
+ else if (memcmp(E2.xMutexTry_signature, xMutexTry_signatures[xMutexTry_pthreadMutexTry_enum], sizeof(E2.xMutexTry_signature)) == 0) {
+ E1 = pthreadMutexTry(args);
+ }
+ else if (memcmp(E2.xMutexTry_signature, xMutexTry_signatures[xMutexTry_winMutexTry_enum], sizeof(E2.xMutexTry_signature)) == 0) {
+ E1 = winMutexTry(args);
+ }
+ else if (memcmp(E2.xMutexTry_signature, xMutexTry_signatures[xMutexTry_wrMutexTry_enum], sizeof(E2.xMutexTry_signature)) == 0) {
+ E1 = wrMutexTry(args);
+ }


// Transform E1 = E2.xNew(args) to if-chain with 3 candidates
@transform_assignment_xNew@
expression E1, E2;
identifier FP_NAME = xNew;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xNew_signature, xNew_signatures[xNew_sessionDiffNew_enum], sizeof(E2.xNew_signature)) == 0) {
+ E1 = sessionDiffNew(args);
+ }
+ else if (memcmp(E2.xNew_signature, xNew_signatures[xNew_sessionPreupdateNew_enum], sizeof(E2.xNew_signature)) == 0) {
+ E1 = sessionPreupdateNew(args);
+ }
+ else if (memcmp(E2.xNew_signature, xNew_signatures[xNew_sessionStat1New_enum], sizeof(E2.xNew_signature)) == 0) {
+ E1 = sessionStat1New(args);
+ }


// Transform E1 = E2.xNext(args) to if-chain with 46 candidates
@transform_assignment_xNext@
expression E1, E2;
identifier FP_NAME = xNext;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xNext_signature, xNext_signatures[xNext_0_enum], sizeof(E2.xNext_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xNext_signature, xNext_signatures[xNext_amatchNext_enum], sizeof(E2.xNext_signature)) == 0) {
+ E1 = amatchNext(args);
+ }
+ else if (memcmp(E2.xNext_signature, xNext_signatures[xNext_binfoNext_enum], sizeof(E2.xNext_signature)) == 0) {
+ E1 = binfoNext(args);
+ }
+ else if (memcmp(E2.xNext_signature, xNext_signatures[xNext_bytecodevtabNext_enum], sizeof(E2.xNext_signature)) == 0) {
+ E1 = bytecodevtabNext(args);
+ }
+ else if (memcmp(E2.xNext_signature, xNext_signatures[xNext_carrayNext_enum], sizeof(E2.xNext_signature)) == 0) {
+ E1 = carrayNext(args);
+ }
+ else if (memcmp(E2.xNext_signature, xNext_signatures[xNext_cidxNext_enum], sizeof(E2.xNext_signature)) == 0) {
+ E1 = cidxNext(args);
+ }
+ else if (memcmp(E2.xNext_signature, xNext_signatures[xNext_closureNext_enum], sizeof(E2.xNext_signature)) == 0) {
+ E1 = closureNext(args);
+ }
+ else if (memcmp(E2.xNext_signature, xNext_signatures[xNext_completionNext_enum], sizeof(E2.xNext_signature)) == 0) {
+ E1 = completionNext(args);
+ }
+ else if (memcmp(E2.xNext_signature, xNext_signatures[xNext_csvtabNext_enum], sizeof(E2.xNext_signature)) == 0) {
+ E1 = csvtabNext(args);
+ }
+ else if (memcmp(E2.xNext_signature, xNext_signatures[xNext_dbdataNext_enum], sizeof(E2.xNext_signature)) == 0) {
+ E1 = dbdataNext(args);
+ }
+ else if (memcmp(E2.xNext_signature, xNext_signatures[xNext_dbpageNext_enum], sizeof(E2.xNext_signature)) == 0) {
+ E1 = dbpageNext(args);
+ }
+ else if (memcmp(E2.xNext_signature, xNext_signatures[xNext_deltaparsevtabNext_enum], sizeof(E2.xNext_signature)) == 0) {
+ E1 = deltaparsevtabNext(args);
+ }
+ else if (memcmp(E2.xNext_signature, xNext_signatures[xNext_echoNext_enum], sizeof(E2.xNext_signature)) == 0) {
+ E1 = echoNext(args);
+ }
+ else if (memcmp(E2.xNext_signature, xNext_signatures[xNext_expertNext_enum], sizeof(E2.xNext_signature)) == 0) {
+ E1 = expertNext(args);
+ }
+ else if (memcmp(E2.xNext_signature, xNext_signatures[xNext_explainNext_enum], sizeof(E2.xNext_signature)) == 0) {
+ E1 = explainNext(args);
+ }
+ else if (memcmp(E2.xNext_signature, xNext_signatures[xNext_fsNext_enum], sizeof(E2.xNext_signature)) == 0) {
+ E1 = fsNext(args);
+ }
+ else if (memcmp(E2.xNext_signature, xNext_signatures[xNext_fsdirNext_enum], sizeof(E2.xNext_signature)) == 0) {
+ E1 = fsdirNext(args);
+ }
+ else if (memcmp(E2.xNext_signature, xNext_signatures[xNext_fstreeNext_enum], sizeof(E2.xNext_signature)) == 0) {
+ E1 = fstreeNext(args);
+ }
+ else if (memcmp(E2.xNext_signature, xNext_signatures[xNext_fts3NextMethod_enum], sizeof(E2.xNext_signature)) == 0) {
+ E1 = fts3NextMethod(args);
+ }
+ else if (memcmp(E2.xNext_signature, xNext_signatures[xNext_fts3auxNextMethod_enum], sizeof(E2.xNext_signature)) == 0) {
+ E1 = fts3auxNextMethod(args);
+ }
+ else if (memcmp(E2.xNext_signature, xNext_signatures[xNext_fts3termNextMethod_enum], sizeof(E2.xNext_signature)) == 0) {
+ E1 = fts3termNextMethod(args);
+ }
+ else if (memcmp(E2.xNext_signature, xNext_signatures[xNext_fts3tokNextMethod_enum], sizeof(E2.xNext_signature)) == 0) {
+ E1 = fts3tokNextMethod(args);
+ }
+ else if (memcmp(E2.xNext_signature, xNext_signatures[xNext_fuzzerNext_enum], sizeof(E2.xNext_signature)) == 0) {
+ E1 = fuzzerNext(args);
+ }
+ else if (memcmp(E2.xNext_signature, xNext_signatures[xNext_intarrayNext_enum], sizeof(E2.xNext_signature)) == 0) {
+ E1 = intarrayNext(args);
+ }
+ else if (memcmp(E2.xNext_signature, xNext_signatures[xNext_jsonEachNext_enum], sizeof(E2.xNext_signature)) == 0) {
+ E1 = jsonEachNext(args);
+ }
+ else if (memcmp(E2.xNext_signature, xNext_signatures[xNext_memstatNext_enum], sizeof(E2.xNext_signature)) == 0) {
+ E1 = memstatNext(args);
+ }
+ else if (memcmp(E2.xNext_signature, xNext_signatures[xNext_porterNext_enum], sizeof(E2.xNext_signature)) == 0) {
+ E1 = porterNext(args);
+ }
+ else if (memcmp(E2.xNext_signature, xNext_signatures[xNext_pragmaVtabNext_enum], sizeof(E2.xNext_signature)) == 0) {
+ E1 = pragmaVtabNext(args);
+ }
+ else if (memcmp(E2.xNext_signature, xNext_signatures[xNext_prefixesNext_enum], sizeof(E2.xNext_signature)) == 0) {
+ E1 = prefixesNext(args);
+ }
+ else if (memcmp(E2.xNext_signature, xNext_signatures[xNext_qpvtabNext_enum], sizeof(E2.xNext_signature)) == 0) {
+ E1 = qpvtabNext(args);
+ }
+ else if (memcmp(E2.xNext_signature, xNext_signatures[xNext_rtreeNext_enum], sizeof(E2.xNext_signature)) == 0) {
+ E1 = rtreeNext(args);
+ }
+ else if (memcmp(E2.xNext_signature, xNext_signatures[xNext_schemaNext_enum], sizeof(E2.xNext_signature)) == 0) {
+ E1 = schemaNext(args);
+ }
+ else if (memcmp(E2.xNext_signature, xNext_signatures[xNext_seriesNext_enum], sizeof(E2.xNext_signature)) == 0) {
+ E1 = seriesNext(args);
+ }
+ else if (memcmp(E2.xNext_signature, xNext_signatures[xNext_simpleNext_enum], sizeof(E2.xNext_signature)) == 0) {
+ E1 = simpleNext(args);
+ }
+ else if (memcmp(E2.xNext_signature, xNext_signatures[xNext_spellfix1Next_enum], sizeof(E2.xNext_signature)) == 0) {
+ E1 = spellfix1Next(args);
+ }
+ else if (memcmp(E2.xNext_signature, xNext_signatures[xNext_statNext_enum], sizeof(E2.xNext_signature)) == 0) {
+ E1 = statNext(args);
+ }
+ else if (memcmp(E2.xNext_signature, xNext_signatures[xNext_stmtNext_enum], sizeof(E2.xNext_signature)) == 0) {
+ E1 = stmtNext(args);
+ }
+ else if (memcmp(E2.xNext_signature, xNext_signatures[xNext_tclNext_enum], sizeof(E2.xNext_signature)) == 0) {
+ E1 = tclNext(args);
+ }
+ else if (memcmp(E2.xNext_signature, xNext_signatures[xNext_tclvarNext_enum], sizeof(E2.xNext_signature)) == 0) {
+ E1 = tclvarNext(args);
+ }
+ else if (memcmp(E2.xNext_signature, xNext_signatures[xNext_templatevtabNext_enum], sizeof(E2.xNext_signature)) == 0) {
+ E1 = templatevtabNext(args);
+ }
+ else if (memcmp(E2.xNext_signature, xNext_signatures[xNext_unicodeNext_enum], sizeof(E2.xNext_signature)) == 0) {
+ E1 = unicodeNext(args);
+ }
+ else if (memcmp(E2.xNext_signature, xNext_signatures[xNext_unionNext_enum], sizeof(E2.xNext_signature)) == 0) {
+ E1 = unionNext(args);
+ }
+ else if (memcmp(E2.xNext_signature, xNext_signatures[xNext_vlogNext_enum], sizeof(E2.xNext_signature)) == 0) {
+ E1 = vlogNext(args);
+ }
+ else if (memcmp(E2.xNext_signature, xNext_signatures[xNext_vstattabNext_enum], sizeof(E2.xNext_signature)) == 0) {
+ E1 = vstattabNext(args);
+ }
+ else if (memcmp(E2.xNext_signature, xNext_signatures[xNext_vtablogNext_enum], sizeof(E2.xNext_signature)) == 0) {
+ E1 = vtablogNext(args);
+ }
+ else if (memcmp(E2.xNext_signature, xNext_signatures[xNext_wholenumberNext_enum], sizeof(E2.xNext_signature)) == 0) {
+ E1 = wholenumberNext(args);
+ }
+ else if (memcmp(E2.xNext_signature, xNext_signatures[xNext_zipfileNext_enum], sizeof(E2.xNext_signature)) == 0) {
+ E1 = zipfileNext(args);
+ }


// Transform E1 = E2.xNextSystemCall(args) to if-chain with 3 candidates
@transform_assignment_xNextSystemCall@
expression E1, E2;
identifier FP_NAME = xNextSystemCall;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xNextSystemCall_signature, xNextSystemCall_signatures[xNextSystemCall_0_enum], sizeof(E2.xNextSystemCall_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xNextSystemCall_signature, xNextSystemCall_signatures[xNextSystemCall_apndNextSystemCall_enum], sizeof(E2.xNextSystemCall_signature)) == 0) {
+ E1 = apndNextSystemCall(args);
+ }
+ else if (memcmp(E2.xNextSystemCall_signature, xNextSystemCall_signatures[xNextSystemCall_rbuVfsGetLastError_enum], sizeof(E2.xNextSystemCall_signature)) == 0) {
+ E1 = rbuVfsGetLastError(args);
+ }
+ else if (memcmp(E2.xNextSystemCall_signature, xNextSystemCall_signatures[xNextSystemCall_unixNextSystemCall_enum], sizeof(E2.xNextSystemCall_signature)) == 0) {
+ E1 = unixNextSystemCall(args);
+ }


// Transform E1 = E2.xOld(args) to if-chain with 3 candidates
@transform_assignment_xOld@
expression E1, E2;
identifier FP_NAME = xOld;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xOld_signature, xOld_signatures[xOld_sessionDiffOld_enum], sizeof(E2.xOld_signature)) == 0) {
+ E1 = sessionDiffOld(args);
+ }
+ else if (memcmp(E2.xOld_signature, xOld_signatures[xOld_sessionPreupdateOld_enum], sizeof(E2.xOld_signature)) == 0) {
+ E1 = sessionPreupdateOld(args);
+ }
+ else if (memcmp(E2.xOld_signature, xOld_signatures[xOld_sessionStat1Old_enum], sizeof(E2.xOld_signature)) == 0) {
+ E1 = sessionStat1Old(args);
+ }


// Transform E1 = E2.xOpen(args) to if-chain with 51 candidates
@transform_assignment_xOpen@
expression E1, E2;
identifier FP_NAME = xOpen;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_amatchOpen_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = amatchOpen(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_apndOpen_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = apndOpen(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_binfoOpen_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = binfoOpen(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_bytecodevtabOpen_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = bytecodevtabOpen(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_carrayOpen_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = carrayOpen(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_cidxOpen_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = cidxOpen(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_closureOpen_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = closureOpen(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_completionOpen_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = completionOpen(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_csvtabOpen_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = csvtabOpen(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_dbdataOpen_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = dbdataOpen(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_dbpageOpen_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = dbpageOpen(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_deltaparsevtabOpen_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = deltaparsevtabOpen(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_echoOpen_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = echoOpen(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_expertOpen_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = expertOpen(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_explainOpen_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = explainOpen(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_fsOpen_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = fsOpen(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_fsdirOpen_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = fsdirOpen(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_fstreeOpen_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = fstreeOpen(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_fts3OpenMethod_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = fts3OpenMethod(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_fts3auxOpenMethod_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = fts3auxOpenMethod(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_fts3termOpenMethod_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = fts3termOpenMethod(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_fts3tokOpenMethod_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = fts3tokOpenMethod(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_fuzzerOpen_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = fuzzerOpen(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_intarrayOpen_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = intarrayOpen(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_jsonEachOpen_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = jsonEachOpen(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_jsonEachOpenEach_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = jsonEachOpenEach(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_jsonEachOpenTree_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = jsonEachOpenTree(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_memdbOpen_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = memdbOpen(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_memstatOpen_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = memstatOpen(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_porterOpen_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = porterOpen(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_pragmaVtabOpen_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = pragmaVtabOpen(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_prefixesOpen_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = prefixesOpen(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_qpvtabOpen_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = qpvtabOpen(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_rtreeOpen_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = rtreeOpen(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_schemaOpen_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = schemaOpen(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_seriesOpen_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = seriesOpen(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_simpleOpen_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = simpleOpen(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_spellfix1Open_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = spellfix1Open(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_statOpen_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = statOpen(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_stmtOpen_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = stmtOpen(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_tclOpen_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = tclOpen(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_tclvarOpen_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = tclvarOpen(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_templatevtabOpen_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = templatevtabOpen(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_unicodeOpen_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = unicodeOpen(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_unionOpen_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = unionOpen(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_vfstraceOpen_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = vfstraceOpen(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_vstattabOpen_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = vstattabOpen(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_vtablogOpen_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = vtablogOpen(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_wholenumberOpen_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = wholenumberOpen(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_zipfileOpen_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = zipfileOpen(args);
+ }
+ else if (memcmp(E2.xOpen_signature, xOpen_signatures[xOpen_unixOpen_enum], sizeof(E2.xOpen_signature)) == 0) {
+ E1 = unixOpen(args);
+ }


// Transform E1 = E2.xPagecount(args) to if-chain with 2 candidates
@transform_assignment_xPagecount@
expression E1, E2;
identifier FP_NAME = xPagecount;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xPagecount_signature, xPagecount_signatures[xPagecount_pcache1Pagecount_enum], sizeof(E2.xPagecount_signature)) == 0) {
+ E1 = pcache1Pagecount(args);
+ }
+ else if (memcmp(E2.xPagecount_signature, xPagecount_signatures[xPagecount_pcachetracePagecount_enum], sizeof(E2.xPagecount_signature)) == 0) {
+ E1 = pcachetracePagecount(args);
+ }


// Transform E1 = E2.xParseCell(args) to if-chain with 3 candidates
@transform_assignment_xParseCell@
expression E1, E2;
identifier FP_NAME = xParseCell;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xParseCell_signature, xParseCell_signatures[xParseCell_btreeParseCellPtr_enum], sizeof(E2.xParseCell_signature)) == 0) {
+ E1 = btreeParseCellPtr(args);
+ }
+ else if (memcmp(E2.xParseCell_signature, xParseCell_signatures[xParseCell_btreeParseCellPtrIndex_enum], sizeof(E2.xParseCell_signature)) == 0) {
+ E1 = btreeParseCellPtrIndex(args);
+ }
+ else if (memcmp(E2.xParseCell_signature, xParseCell_signatures[xParseCell_btreeParseCellPtrNoPayload_enum], sizeof(E2.xParseCell_signature)) == 0) {
+ E1 = btreeParseCellPtrNoPayload(args);
+ }


// Transform E1 = E2.xRandomness(args) to if-chain with 4 candidates
@transform_assignment_xRandomness@
expression E1, E2;
identifier FP_NAME = xRandomness;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xRandomness_signature, xRandomness_signatures[xRandomness_apndRandomness_enum], sizeof(E2.xRandomness_signature)) == 0) {
+ E1 = apndRandomness(args);
+ }
+ else if (memcmp(E2.xRandomness_signature, xRandomness_signatures[xRandomness_memdbRandomness_enum], sizeof(E2.xRandomness_signature)) == 0) {
+ E1 = memdbRandomness(args);
+ }
+ else if (memcmp(E2.xRandomness_signature, xRandomness_signatures[xRandomness_vfstraceRandomness_enum], sizeof(E2.xRandomness_signature)) == 0) {
+ E1 = vfstraceRandomness(args);
+ }
+ else if (memcmp(E2.xRandomness_signature, xRandomness_signatures[xRandomness_unixRandomness_enum], sizeof(E2.xRandomness_signature)) == 0) {
+ E1 = unixRandomness(args);
+ }


// Transform E1 = E2.xRead(args) to if-chain with 6 candidates
@transform_assignment_xRead@
expression E1, E2;
identifier FP_NAME = xRead;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xRead_signature, xRead_signatures[xRead_apndRead_enum], sizeof(E2.xRead_signature)) == 0) {
+ E1 = apndRead(args);
+ }
+ else if (memcmp(E2.xRead_signature, xRead_signatures[xRead_memdbRead_enum], sizeof(E2.xRead_signature)) == 0) {
+ E1 = memdbRead(args);
+ }
+ else if (memcmp(E2.xRead_signature, xRead_signatures[xRead_memjrnlRead_enum], sizeof(E2.xRead_signature)) == 0) {
+ E1 = memjrnlRead(args);
+ }
+ else if (memcmp(E2.xRead_signature, xRead_signatures[xRead_recoverVfsRead_enum], sizeof(E2.xRead_signature)) == 0) {
+ E1 = recoverVfsRead(args);
+ }
+ else if (memcmp(E2.xRead_signature, xRead_signatures[xRead_vfstraceRead_enum], sizeof(E2.xRead_signature)) == 0) {
+ E1 = vfstraceRead(args);
+ }
+ else if (memcmp(E2.xRead_signature, xRead_signatures[xRead_unixRead_enum], sizeof(E2.xRead_signature)) == 0) {
+ E1 = unixRead(args);
+ }


// Transform E1 = E2.xRealloc(args) to if-chain with 2 candidates
@transform_assignment_xRealloc@
expression E1, E2;
identifier FP_NAME = xRealloc;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xRealloc_signature, xRealloc_signatures[xRealloc_memtraceRealloc_enum], sizeof(E2.xRealloc_signature)) == 0) {
+ E1 = memtraceRealloc(args);
+ }
+ else if (memcmp(E2.xRealloc_signature, xRealloc_signatures[xRealloc_sqlite3MemRealloc_enum], sizeof(E2.xRealloc_signature)) == 0) {
+ E1 = sqlite3MemRealloc(args);
+ }


// Transform E1 = E2.xRekey(args) to if-chain with 3 candidates
@transform_assignment_xRekey@
expression E1, E2;
identifier FP_NAME = xRekey;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xRekey_signature, xRekey_signatures[xRekey_pcache1Rekey_enum], sizeof(E2.xRekey_signature)) == 0) {
+ E1 = pcache1Rekey(args);
+ }
+ else if (memcmp(E2.xRekey_signature, xRekey_signatures[xRekey_pcachetraceRekey_enum], sizeof(E2.xRekey_signature)) == 0) {
+ E1 = pcachetraceRekey(args);
+ }
+ else if (memcmp(E2.xRekey_signature, xRekey_signatures[xRekey_unixRandomness_enum], sizeof(E2.xRekey_signature)) == 0) {
+ E1 = unixRandomness(args);
+ }


// Transform E1 = E2.xRelease(args) to if-chain with 3 candidates
@transform_assignment_xRelease@
expression E1, E2;
identifier FP_NAME = xRelease;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xRelease_signature, xRelease_signatures[xRelease_0_enum], sizeof(E2.xRelease_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xRelease_signature, xRelease_signatures[xRelease_echoRelease_enum], sizeof(E2.xRelease_signature)) == 0) {
+ E1 = echoRelease(args);
+ }
+ else if (memcmp(E2.xRelease_signature, xRelease_signatures[xRelease_fts3ReleaseMethod_enum], sizeof(E2.xRelease_signature)) == 0) {
+ E1 = fts3ReleaseMethod(args);
+ }
+ else if (memcmp(E2.xRelease_signature, xRelease_signatures[xRelease_vtablogRelease_enum], sizeof(E2.xRelease_signature)) == 0) {
+ E1 = vtablogRelease(args);
+ }


// Transform E1 = E2.xRename(args) to if-chain with 5 candidates
@transform_assignment_xRename@
expression E1, E2;
identifier FP_NAME = xRename;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xRename_signature, xRename_signatures[xRename_0_enum], sizeof(E2.xRename_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xRename_signature, xRename_signatures[xRename_echoRename_enum], sizeof(E2.xRename_signature)) == 0) {
+ E1 = echoRename(args);
+ }
+ else if (memcmp(E2.xRename_signature, xRename_signatures[xRename_fts3RenameMethod_enum], sizeof(E2.xRename_signature)) == 0) {
+ E1 = fts3RenameMethod(args);
+ }
+ else if (memcmp(E2.xRename_signature, xRename_signatures[xRename_rtreeRename_enum], sizeof(E2.xRename_signature)) == 0) {
+ E1 = rtreeRename(args);
+ }
+ else if (memcmp(E2.xRename_signature, xRename_signatures[xRename_spellfix1Rename_enum], sizeof(E2.xRename_signature)) == 0) {
+ E1 = spellfix1Rename(args);
+ }
+ else if (memcmp(E2.xRename_signature, xRename_signatures[xRename_vtablogRename_enum], sizeof(E2.xRename_signature)) == 0) {
+ E1 = vtablogRename(args);
+ }


// Transform E1 = E2.xRollback(args) to if-chain with 6 candidates
@transform_assignment_xRollback@
expression E1, E2;
identifier FP_NAME = xRollback;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xRollback_signature, xRollback_signatures[xRollback_0_enum], sizeof(E2.xRollback_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xRollback_signature, xRollback_signatures[xRollback_echoRollback_enum], sizeof(E2.xRollback_signature)) == 0) {
+ E1 = echoRollback(args);
+ }
+ else if (memcmp(E2.xRollback_signature, xRollback_signatures[xRollback_fts3RollbackMethod_enum], sizeof(E2.xRollback_signature)) == 0) {
+ E1 = fts3RollbackMethod(args);
+ }
+ else if (memcmp(E2.xRollback_signature, xRollback_signatures[xRollback_rtreeEndTransaction_enum], sizeof(E2.xRollback_signature)) == 0) {
+ E1 = rtreeEndTransaction(args);
+ }
+ else if (memcmp(E2.xRollback_signature, xRollback_signatures[xRollback_rtreeRollback_enum], sizeof(E2.xRollback_signature)) == 0) {
+ E1 = rtreeRollback(args);
+ }
+ else if (memcmp(E2.xRollback_signature, xRollback_signatures[xRollback_vtablogRollback_enum], sizeof(E2.xRollback_signature)) == 0) {
+ E1 = vtablogRollback(args);
+ }
+ else if (memcmp(E2.xRollback_signature, xRollback_signatures[xRollback_zipfileRollback_enum], sizeof(E2.xRollback_signature)) == 0) {
+ E1 = zipfileRollback(args);
+ }


// Transform E1 = E2.xRollbackTo(args) to if-chain with 4 candidates
@transform_assignment_xRollbackTo@
expression E1, E2;
identifier FP_NAME = xRollbackTo;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xRollbackTo_signature, xRollbackTo_signatures[xRollbackTo_0_enum], sizeof(E2.xRollbackTo_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xRollbackTo_signature, xRollbackTo_signatures[xRollbackTo_dbpageRollbackTo_enum], sizeof(E2.xRollbackTo_signature)) == 0) {
+ E1 = dbpageRollbackTo(args);
+ }
+ else if (memcmp(E2.xRollbackTo_signature, xRollbackTo_signatures[xRollbackTo_echoRollbackTo_enum], sizeof(E2.xRollbackTo_signature)) == 0) {
+ E1 = echoRollbackTo(args);
+ }
+ else if (memcmp(E2.xRollbackTo_signature, xRollbackTo_signatures[xRollbackTo_fts3RollbackToMethod_enum], sizeof(E2.xRollbackTo_signature)) == 0) {
+ E1 = fts3RollbackToMethod(args);
+ }
+ else if (memcmp(E2.xRollbackTo_signature, xRollbackTo_signatures[xRollbackTo_vtablogRollbackTo_enum], sizeof(E2.xRollbackTo_signature)) == 0) {
+ E1 = vtablogRollbackTo(args);
+ }


// Transform E1 = E2.xRoundup(args) to if-chain with 2 candidates
@transform_assignment_xRoundup@
expression E1, E2;
identifier FP_NAME = xRoundup;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xRoundup_signature, xRoundup_signatures[xRoundup_memtraceRoundup_enum], sizeof(E2.xRoundup_signature)) == 0) {
+ E1 = memtraceRoundup(args);
+ }
+ else if (memcmp(E2.xRoundup_signature, xRoundup_signatures[xRoundup_sqlite3MemRoundup_enum], sizeof(E2.xRoundup_signature)) == 0) {
+ E1 = sqlite3MemRoundup(args);
+ }


// Transform E1 = E2.xRowid(args) to if-chain with 42 candidates
@transform_assignment_xRowid@
expression E1, E2;
identifier FP_NAME = xRowid;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xRowid_signature, xRowid_signatures[xRowid_0_enum], sizeof(E2.xRowid_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xRowid_signature, xRowid_signatures[xRowid_amatchRowid_enum], sizeof(E2.xRowid_signature)) == 0) {
+ E1 = amatchRowid(args);
+ }
+ else if (memcmp(E2.xRowid_signature, xRowid_signatures[xRowid_binfoRowid_enum], sizeof(E2.xRowid_signature)) == 0) {
+ E1 = binfoRowid(args);
+ }
+ else if (memcmp(E2.xRowid_signature, xRowid_signatures[xRowid_bytecodevtabRowid_enum], sizeof(E2.xRowid_signature)) == 0) {
+ E1 = bytecodevtabRowid(args);
+ }
+ else if (memcmp(E2.xRowid_signature, xRowid_signatures[xRowid_carrayRowid_enum], sizeof(E2.xRowid_signature)) == 0) {
+ E1 = carrayRowid(args);
+ }
+ else if (memcmp(E2.xRowid_signature, xRowid_signatures[xRowid_cidxRowid_enum], sizeof(E2.xRowid_signature)) == 0) {
+ E1 = cidxRowid(args);
+ }
+ else if (memcmp(E2.xRowid_signature, xRowid_signatures[xRowid_closureRowid_enum], sizeof(E2.xRowid_signature)) == 0) {
+ E1 = closureRowid(args);
+ }
+ else if (memcmp(E2.xRowid_signature, xRowid_signatures[xRowid_completionRowid_enum], sizeof(E2.xRowid_signature)) == 0) {
+ E1 = completionRowid(args);
+ }
+ else if (memcmp(E2.xRowid_signature, xRowid_signatures[xRowid_csvtabRowid_enum], sizeof(E2.xRowid_signature)) == 0) {
+ E1 = csvtabRowid(args);
+ }
+ else if (memcmp(E2.xRowid_signature, xRowid_signatures[xRowid_dbdataRowid_enum], sizeof(E2.xRowid_signature)) == 0) {
+ E1 = dbdataRowid(args);
+ }
+ else if (memcmp(E2.xRowid_signature, xRowid_signatures[xRowid_dbpageRowid_enum], sizeof(E2.xRowid_signature)) == 0) {
+ E1 = dbpageRowid(args);
+ }
+ else if (memcmp(E2.xRowid_signature, xRowid_signatures[xRowid_deltaparsevtabRowid_enum], sizeof(E2.xRowid_signature)) == 0) {
+ E1 = deltaparsevtabRowid(args);
+ }
+ else if (memcmp(E2.xRowid_signature, xRowid_signatures[xRowid_echoRowid_enum], sizeof(E2.xRowid_signature)) == 0) {
+ E1 = echoRowid(args);
+ }
+ else if (memcmp(E2.xRowid_signature, xRowid_signatures[xRowid_expertRowid_enum], sizeof(E2.xRowid_signature)) == 0) {
+ E1 = expertRowid(args);
+ }
+ else if (memcmp(E2.xRowid_signature, xRowid_signatures[xRowid_explainRowid_enum], sizeof(E2.xRowid_signature)) == 0) {
+ E1 = explainRowid(args);
+ }
+ else if (memcmp(E2.xRowid_signature, xRowid_signatures[xRowid_fsRowid_enum], sizeof(E2.xRowid_signature)) == 0) {
+ E1 = fsRowid(args);
+ }
+ else if (memcmp(E2.xRowid_signature, xRowid_signatures[xRowid_fsdirRowid_enum], sizeof(E2.xRowid_signature)) == 0) {
+ E1 = fsdirRowid(args);
+ }
+ else if (memcmp(E2.xRowid_signature, xRowid_signatures[xRowid_fstreeRowid_enum], sizeof(E2.xRowid_signature)) == 0) {
+ E1 = fstreeRowid(args);
+ }
+ else if (memcmp(E2.xRowid_signature, xRowid_signatures[xRowid_fts3RowidMethod_enum], sizeof(E2.xRowid_signature)) == 0) {
+ E1 = fts3RowidMethod(args);
+ }
+ else if (memcmp(E2.xRowid_signature, xRowid_signatures[xRowid_fts3auxRowidMethod_enum], sizeof(E2.xRowid_signature)) == 0) {
+ E1 = fts3auxRowidMethod(args);
+ }
+ else if (memcmp(E2.xRowid_signature, xRowid_signatures[xRowid_fts3termRowidMethod_enum], sizeof(E2.xRowid_signature)) == 0) {
+ E1 = fts3termRowidMethod(args);
+ }
+ else if (memcmp(E2.xRowid_signature, xRowid_signatures[xRowid_fts3tokRowidMethod_enum], sizeof(E2.xRowid_signature)) == 0) {
+ E1 = fts3tokRowidMethod(args);
+ }
+ else if (memcmp(E2.xRowid_signature, xRowid_signatures[xRowid_fuzzerRowid_enum], sizeof(E2.xRowid_signature)) == 0) {
+ E1 = fuzzerRowid(args);
+ }
+ else if (memcmp(E2.xRowid_signature, xRowid_signatures[xRowid_intarrayRowid_enum], sizeof(E2.xRowid_signature)) == 0) {
+ E1 = intarrayRowid(args);
+ }
+ else if (memcmp(E2.xRowid_signature, xRowid_signatures[xRowid_jsonEachRowid_enum], sizeof(E2.xRowid_signature)) == 0) {
+ E1 = jsonEachRowid(args);
+ }
+ else if (memcmp(E2.xRowid_signature, xRowid_signatures[xRowid_memstatRowid_enum], sizeof(E2.xRowid_signature)) == 0) {
+ E1 = memstatRowid(args);
+ }
+ else if (memcmp(E2.xRowid_signature, xRowid_signatures[xRowid_pragmaVtabRowid_enum], sizeof(E2.xRowid_signature)) == 0) {
+ E1 = pragmaVtabRowid(args);
+ }
+ else if (memcmp(E2.xRowid_signature, xRowid_signatures[xRowid_prefixesRowid_enum], sizeof(E2.xRowid_signature)) == 0) {
+ E1 = prefixesRowid(args);
+ }
+ else if (memcmp(E2.xRowid_signature, xRowid_signatures[xRowid_qpvtabRowid_enum], sizeof(E2.xRowid_signature)) == 0) {
+ E1 = qpvtabRowid(args);
+ }
+ else if (memcmp(E2.xRowid_signature, xRowid_signatures[xRowid_rtreeRowid_enum], sizeof(E2.xRowid_signature)) == 0) {
+ E1 = rtreeRowid(args);
+ }
+ else if (memcmp(E2.xRowid_signature, xRowid_signatures[xRowid_schemaRowid_enum], sizeof(E2.xRowid_signature)) == 0) {
+ E1 = schemaRowid(args);
+ }
+ else if (memcmp(E2.xRowid_signature, xRowid_signatures[xRowid_seriesRowid_enum], sizeof(E2.xRowid_signature)) == 0) {
+ E1 = seriesRowid(args);
+ }
+ else if (memcmp(E2.xRowid_signature, xRowid_signatures[xRowid_spellfix1Rowid_enum], sizeof(E2.xRowid_signature)) == 0) {
+ E1 = spellfix1Rowid(args);
+ }
+ else if (memcmp(E2.xRowid_signature, xRowid_signatures[xRowid_statRowid_enum], sizeof(E2.xRowid_signature)) == 0) {
+ E1 = statRowid(args);
+ }
+ else if (memcmp(E2.xRowid_signature, xRowid_signatures[xRowid_stmtRowid_enum], sizeof(E2.xRowid_signature)) == 0) {
+ E1 = stmtRowid(args);
+ }
+ else if (memcmp(E2.xRowid_signature, xRowid_signatures[xRowid_tclRowid_enum], sizeof(E2.xRowid_signature)) == 0) {
+ E1 = tclRowid(args);
+ }
+ else if (memcmp(E2.xRowid_signature, xRowid_signatures[xRowid_tclvarRowid_enum], sizeof(E2.xRowid_signature)) == 0) {
+ E1 = tclvarRowid(args);
+ }
+ else if (memcmp(E2.xRowid_signature, xRowid_signatures[xRowid_templatevtabRowid_enum], sizeof(E2.xRowid_signature)) == 0) {
+ E1 = templatevtabRowid(args);
+ }
+ else if (memcmp(E2.xRowid_signature, xRowid_signatures[xRowid_unionRowid_enum], sizeof(E2.xRowid_signature)) == 0) {
+ E1 = unionRowid(args);
+ }
+ else if (memcmp(E2.xRowid_signature, xRowid_signatures[xRowid_vlogRowid_enum], sizeof(E2.xRowid_signature)) == 0) {
+ E1 = vlogRowid(args);
+ }
+ else if (memcmp(E2.xRowid_signature, xRowid_signatures[xRowid_vstattabRowid_enum], sizeof(E2.xRowid_signature)) == 0) {
+ E1 = vstattabRowid(args);
+ }
+ else if (memcmp(E2.xRowid_signature, xRowid_signatures[xRowid_vtablogRowid_enum], sizeof(E2.xRowid_signature)) == 0) {
+ E1 = vtablogRowid(args);
+ }
+ else if (memcmp(E2.xRowid_signature, xRowid_signatures[xRowid_wholenumberRowid_enum], sizeof(E2.xRowid_signature)) == 0) {
+ E1 = wholenumberRowid(args);
+ }


// Transform E1 = E2.xSFunc(args) to if-chain with 5 candidates
@transform_assignment_xSFunc@
expression E1, E2;
identifier FP_NAME = xSFunc;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xSFunc_signature, xSFunc_signatures[xSFunc_attachFunc_enum], sizeof(E2.xSFunc_signature)) == 0) {
+ E1 = attachFunc(args);
+ }
+ else if (memcmp(E2.xSFunc_signature, xSFunc_signatures[xSFunc_detachFunc_enum], sizeof(E2.xSFunc_signature)) == 0) {
+ E1 = detachFunc(args);
+ }
+ else if (memcmp(E2.xSFunc_signature, xSFunc_signatures[xSFunc_statGet_enum], sizeof(E2.xSFunc_signature)) == 0) {
+ E1 = statGet(args);
+ }
+ else if (memcmp(E2.xSFunc_signature, xSFunc_signatures[xSFunc_statInit_enum], sizeof(E2.xSFunc_signature)) == 0) {
+ E1 = statInit(args);
+ }
+ else if (memcmp(E2.xSFunc_signature, xSFunc_signatures[xSFunc_statPush_enum], sizeof(E2.xSFunc_signature)) == 0) {
+ E1 = statPush(args);
+ }


// Transform E1 = E2.xSavepoint(args) to if-chain with 2 candidates
@transform_assignment_xSavepoint@
expression E1, E2;
identifier FP_NAME = xSavepoint;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xSavepoint_signature, xSavepoint_signatures[xSavepoint_0_enum], sizeof(E2.xSavepoint_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xSavepoint_signature, xSavepoint_signatures[xSavepoint_fts3SavepointMethod_enum], sizeof(E2.xSavepoint_signature)) == 0) {
+ E1 = fts3SavepointMethod(args);
+ }
+ else if (memcmp(E2.xSavepoint_signature, xSavepoint_signatures[xSavepoint_rtreeSavepoint_enum], sizeof(E2.xSavepoint_signature)) == 0) {
+ E1 = rtreeSavepoint(args);
+ }


// Transform E1 = E2.xSectorSize(args) to if-chain with 4 candidates
@transform_assignment_xSectorSize@
expression E1, E2;
identifier FP_NAME = xSectorSize;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xSectorSize_signature, xSectorSize_signatures[xSectorSize_0_enum], sizeof(E2.xSectorSize_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xSectorSize_signature, xSectorSize_signatures[xSectorSize_apndSectorSize_enum], sizeof(E2.xSectorSize_signature)) == 0) {
+ E1 = apndSectorSize(args);
+ }
+ else if (memcmp(E2.xSectorSize_signature, xSectorSize_signatures[xSectorSize_recoverVfsSectorSize_enum], sizeof(E2.xSectorSize_signature)) == 0) {
+ E1 = recoverVfsSectorSize(args);
+ }
+ else if (memcmp(E2.xSectorSize_signature, xSectorSize_signatures[xSectorSize_vfstraceSectorSize_enum], sizeof(E2.xSectorSize_signature)) == 0) {
+ E1 = vfstraceSectorSize(args);
+ }
+ else if (memcmp(E2.xSectorSize_signature, xSectorSize_signatures[xSectorSize_unixSectorSize_enum], sizeof(E2.xSectorSize_signature)) == 0) {
+ E1 = unixSectorSize(args);
+ }


// Transform E1 = E2.xSelectCallback(args) to if-chain with 16 candidates
@transform_assignment_xSelectCallback@
expression E1, E2;
identifier FP_NAME = xSelectCallback;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_0_enum], sizeof(E2.xSelectCallback_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_convertCompoundSelectToSubquery_enum], sizeof(E2.xSelectCallback_signature)) == 0) {
+ E1 = convertCompoundSelectToSubquery(args);
+ }
+ else if (memcmp(E2.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_exprSelectWalkTableConstant_enum], sizeof(E2.xSelectCallback_signature)) == 0) {
+ E1 = exprSelectWalkTableConstant(args);
+ }
+ else if (memcmp(E2.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_fixSelectCb_enum], sizeof(E2.xSelectCallback_signature)) == 0) {
+ E1 = fixSelectCb(args);
+ }
+ else if (memcmp(E2.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_gatherSelectWindowsSelectCallback_enum], sizeof(E2.xSelectCallback_signature)) == 0) {
+ E1 = gatherSelectWindowsSelectCallback(args);
+ }
+ else if (memcmp(E2.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_renameColumnSelectCb_enum], sizeof(E2.xSelectCallback_signature)) == 0) {
+ E1 = renameColumnSelectCb(args);
+ }
+ else if (memcmp(E2.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_renameTableSelectCb_enum], sizeof(E2.xSelectCallback_signature)) == 0) {
+ E1 = renameTableSelectCb(args);
+ }
+ else if (memcmp(E2.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_renameUnmapSelectCb_enum], sizeof(E2.xSelectCallback_signature)) == 0) {
+ E1 = renameUnmapSelectCb(args);
+ }
+ else if (memcmp(E2.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_resolveSelectStep_enum], sizeof(E2.xSelectCallback_signature)) == 0) {
+ E1 = resolveSelectStep(args);
+ }
+ else if (memcmp(E2.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_selectCheckOnClausesSelect_enum], sizeof(E2.xSelectCallback_signature)) == 0) {
+ E1 = selectCheckOnClausesSelect(args);
+ }
+ else if (memcmp(E2.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_selectExpander_enum], sizeof(E2.xSelectCallback_signature)) == 0) {
+ E1 = selectExpander(args);
+ }
+ else if (memcmp(E2.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_selectRefEnter_enum], sizeof(E2.xSelectCallback_signature)) == 0) {
+ E1 = selectRefEnter(args);
+ }
+ else if (memcmp(E2.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_selectWindowRewriteSelectCb_enum], sizeof(E2.xSelectCallback_signature)) == 0) {
+ E1 = selectWindowRewriteSelectCb(args);
+ }
+ else if (memcmp(E2.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_sqlite3ReturningSubqueryCorrelated_enum], sizeof(E2.xSelectCallback_signature)) == 0) {
+ E1 = sqlite3ReturningSubqueryCorrelated(args);
+ }
+ else if (memcmp(E2.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_sqlite3SelectWalkFail_enum], sizeof(E2.xSelectCallback_signature)) == 0) {
+ E1 = sqlite3SelectWalkFail(args);
+ }
+ else if (memcmp(E2.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_sqlite3SelectWalkNoop_enum], sizeof(E2.xSelectCallback_signature)) == 0) {
+ E1 = sqlite3SelectWalkNoop(args);
+ }
+ else if (memcmp(E2.xSelectCallback_signature, xSelectCallback_signatures[xSelectCallback_sqlite3WalkerDepthIncrease_enum], sizeof(E2.xSelectCallback_signature)) == 0) {
+ E1 = sqlite3WalkerDepthIncrease(args);
+ }


// Transform E1 = E2.xSelectCallback2(args) to if-chain with 5 candidates
@transform_assignment_xSelectCallback2@
expression E1, E2;
identifier FP_NAME = xSelectCallback2;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_0_enum], sizeof(E2.xSelectCallback2_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_selectAddSubqueryTypeInfo_enum], sizeof(E2.xSelectCallback2_signature)) == 0) {
+ E1 = selectAddSubqueryTypeInfo(args);
+ }
+ else if (memcmp(E2.xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_selectRefLeave_enum], sizeof(E2.xSelectCallback2_signature)) == 0) {
+ E1 = selectRefLeave(args);
+ }
+ else if (memcmp(E2.xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_sqlite3SelectPopWith_enum], sizeof(E2.xSelectCallback2_signature)) == 0) {
+ E1 = sqlite3SelectPopWith(args);
+ }
+ else if (memcmp(E2.xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_sqlite3WalkWinDefnDummyCallback_enum], sizeof(E2.xSelectCallback2_signature)) == 0) {
+ E1 = sqlite3WalkWinDefnDummyCallback(args);
+ }
+ else if (memcmp(E2.xSelectCallback2_signature, xSelectCallback2_signatures[xSelectCallback2_sqlite3WalkerDepthDecrease_enum], sizeof(E2.xSelectCallback2_signature)) == 0) {
+ E1 = sqlite3WalkerDepthDecrease(args);
+ }


// Transform E1 = E2.xSetSystemCall(args) to if-chain with 5 candidates
@transform_assignment_xSetSystemCall@
expression E1, E2;
identifier FP_NAME = xSetSystemCall;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xSetSystemCall_signature, xSetSystemCall_signatures[xSetSystemCall_0_enum], sizeof(E2.xSetSystemCall_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xSetSystemCall_signature, xSetSystemCall_signatures[xSetSystemCall_apndSetSystemCall_enum], sizeof(E2.xSetSystemCall_signature)) == 0) {
+ E1 = apndSetSystemCall(args);
+ }
+ else if (memcmp(E2.xSetSystemCall_signature, xSetSystemCall_signatures[xSetSystemCall_devsymSleep_enum], sizeof(E2.xSetSystemCall_signature)) == 0) {
+ E1 = devsymSleep(args);
+ }
+ else if (memcmp(E2.xSetSystemCall_signature, xSetSystemCall_signatures[xSetSystemCall_rbuVfsSleep_enum], sizeof(E2.xSetSystemCall_signature)) == 0) {
+ E1 = rbuVfsSleep(args);
+ }
+ else if (memcmp(E2.xSetSystemCall_signature, xSetSystemCall_signatures[xSetSystemCall_tvfsSleep_enum], sizeof(E2.xSetSystemCall_signature)) == 0) {
+ E1 = tvfsSleep(args);
+ }
+ else if (memcmp(E2.xSetSystemCall_signature, xSetSystemCall_signatures[xSetSystemCall_unixSetSystemCall_enum], sizeof(E2.xSetSystemCall_signature)) == 0) {
+ E1 = unixSetSystemCall(args);
+ }


// Transform E1 = E2.xShadowName(args) to if-chain with 2 candidates
@transform_assignment_xShadowName@
expression E1, E2;
identifier FP_NAME = xShadowName;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xShadowName_signature, xShadowName_signatures[xShadowName_0_enum], sizeof(E2.xShadowName_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xShadowName_signature, xShadowName_signatures[xShadowName_fts3ShadowName_enum], sizeof(E2.xShadowName_signature)) == 0) {
+ E1 = fts3ShadowName(args);
+ }
+ else if (memcmp(E2.xShadowName_signature, xShadowName_signatures[xShadowName_rtreeShadowName_enum], sizeof(E2.xShadowName_signature)) == 0) {
+ E1 = rtreeShadowName(args);
+ }


// Transform E1 = E2.xShmBarrier(args) to if-chain with 3 candidates
@transform_assignment_xShmBarrier@
expression E1, E2;
identifier FP_NAME = xShmBarrier;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xShmBarrier_signature, xShmBarrier_signatures[xShmBarrier_0_enum], sizeof(E2.xShmBarrier_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xShmBarrier_signature, xShmBarrier_signatures[xShmBarrier_apndShmBarrier_enum], sizeof(E2.xShmBarrier_signature)) == 0) {
+ E1 = apndShmBarrier(args);
+ }
+ else if (memcmp(E2.xShmBarrier_signature, xShmBarrier_signatures[xShmBarrier_recoverVfsShmBarrier_enum], sizeof(E2.xShmBarrier_signature)) == 0) {
+ E1 = recoverVfsShmBarrier(args);
+ }
+ else if (memcmp(E2.xShmBarrier_signature, xShmBarrier_signatures[xShmBarrier_unixShmBarrier_enum], sizeof(E2.xShmBarrier_signature)) == 0) {
+ E1 = unixShmBarrier(args);
+ }


// Transform E1 = E2.xShmLock(args) to if-chain with 3 candidates
@transform_assignment_xShmLock@
expression E1, E2;
identifier FP_NAME = xShmLock;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xShmLock_signature, xShmLock_signatures[xShmLock_0_enum], sizeof(E2.xShmLock_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xShmLock_signature, xShmLock_signatures[xShmLock_apndShmLock_enum], sizeof(E2.xShmLock_signature)) == 0) {
+ E1 = apndShmLock(args);
+ }
+ else if (memcmp(E2.xShmLock_signature, xShmLock_signatures[xShmLock_recoverVfsShmLock_enum], sizeof(E2.xShmLock_signature)) == 0) {
+ E1 = recoverVfsShmLock(args);
+ }
+ else if (memcmp(E2.xShmLock_signature, xShmLock_signatures[xShmLock_unixShmLock_enum], sizeof(E2.xShmLock_signature)) == 0) {
+ E1 = unixShmLock(args);
+ }


// Transform E1 = E2.xShmMap(args) to if-chain with 3 candidates
@transform_assignment_xShmMap@
expression E1, E2;
identifier FP_NAME = xShmMap;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xShmMap_signature, xShmMap_signatures[xShmMap_0_enum], sizeof(E2.xShmMap_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xShmMap_signature, xShmMap_signatures[xShmMap_apndShmMap_enum], sizeof(E2.xShmMap_signature)) == 0) {
+ E1 = apndShmMap(args);
+ }
+ else if (memcmp(E2.xShmMap_signature, xShmMap_signatures[xShmMap_recoverVfsShmMap_enum], sizeof(E2.xShmMap_signature)) == 0) {
+ E1 = recoverVfsShmMap(args);
+ }
+ else if (memcmp(E2.xShmMap_signature, xShmMap_signatures[xShmMap_unixShmMap_enum], sizeof(E2.xShmMap_signature)) == 0) {
+ E1 = unixShmMap(args);
+ }


// Transform E1 = E2.xShmUnmap(args) to if-chain with 3 candidates
@transform_assignment_xShmUnmap@
expression E1, E2;
identifier FP_NAME = xShmUnmap;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xShmUnmap_signature, xShmUnmap_signatures[xShmUnmap_0_enum], sizeof(E2.xShmUnmap_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xShmUnmap_signature, xShmUnmap_signatures[xShmUnmap_apndShmUnmap_enum], sizeof(E2.xShmUnmap_signature)) == 0) {
+ E1 = apndShmUnmap(args);
+ }
+ else if (memcmp(E2.xShmUnmap_signature, xShmUnmap_signatures[xShmUnmap_recoverVfsShmUnmap_enum], sizeof(E2.xShmUnmap_signature)) == 0) {
+ E1 = recoverVfsShmUnmap(args);
+ }
+ else if (memcmp(E2.xShmUnmap_signature, xShmUnmap_signatures[xShmUnmap_unixShmUnmap_enum], sizeof(E2.xShmUnmap_signature)) == 0) {
+ E1 = unixShmUnmap(args);
+ }


// Transform E1 = E2.xShrink(args) to if-chain with 2 candidates
@transform_assignment_xShrink@
expression E1, E2;
identifier FP_NAME = xShrink;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xShrink_signature, xShrink_signatures[xShrink_pcache1Shrink_enum], sizeof(E2.xShrink_signature)) == 0) {
+ E1 = pcache1Shrink(args);
+ }
+ else if (memcmp(E2.xShrink_signature, xShrink_signatures[xShrink_pcachetraceShrink_enum], sizeof(E2.xShrink_signature)) == 0) {
+ E1 = pcachetraceShrink(args);
+ }


// Transform E1 = E2.xShutdown(args) to if-chain with 4 candidates
@transform_assignment_xShutdown@
expression E1, E2;
identifier FP_NAME = xShutdown;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xShutdown_signature, xShutdown_signatures[xShutdown_memtraceShutdown_enum], sizeof(E2.xShutdown_signature)) == 0) {
+ E1 = memtraceShutdown(args);
+ }
+ else if (memcmp(E2.xShutdown_signature, xShutdown_signatures[xShutdown_pcache1Shutdown_enum], sizeof(E2.xShutdown_signature)) == 0) {
+ E1 = pcache1Shutdown(args);
+ }
+ else if (memcmp(E2.xShutdown_signature, xShutdown_signatures[xShutdown_pcachetraceShutdown_enum], sizeof(E2.xShutdown_signature)) == 0) {
+ E1 = pcachetraceShutdown(args);
+ }
+ else if (memcmp(E2.xShutdown_signature, xShutdown_signatures[xShutdown_sqlite3MemShutdown_enum], sizeof(E2.xShutdown_signature)) == 0) {
+ E1 = sqlite3MemShutdown(args);
+ }


// Transform E1 = E2.xSize(args) to if-chain with 2 candidates
@transform_assignment_xSize@
expression E1, E2;
identifier FP_NAME = xSize;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xSize_signature, xSize_signatures[xSize_memtraceSize_enum], sizeof(E2.xSize_signature)) == 0) {
+ E1 = memtraceSize(args);
+ }
+ else if (memcmp(E2.xSize_signature, xSize_signatures[xSize_sqlite3MemSize_enum], sizeof(E2.xSize_signature)) == 0) {
+ E1 = sqlite3MemSize(args);
+ }


// Transform E1 = E2.xSleep(args) to if-chain with 4 candidates
@transform_assignment_xSleep@
expression E1, E2;
identifier FP_NAME = xSleep;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xSleep_signature, xSleep_signatures[xSleep_0_enum], sizeof(E2.xSleep_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xSleep_signature, xSleep_signatures[xSleep_apndSleep_enum], sizeof(E2.xSleep_signature)) == 0) {
+ E1 = apndSleep(args);
+ }
+ else if (memcmp(E2.xSleep_signature, xSleep_signatures[xSleep_memdbSleep_enum], sizeof(E2.xSleep_signature)) == 0) {
+ E1 = memdbSleep(args);
+ }
+ else if (memcmp(E2.xSleep_signature, xSleep_signatures[xSleep_vfstraceSleep_enum], sizeof(E2.xSleep_signature)) == 0) {
+ E1 = vfstraceSleep(args);
+ }
+ else if (memcmp(E2.xSleep_signature, xSleep_signatures[xSleep_unixSleep_enum], sizeof(E2.xSleep_signature)) == 0) {
+ E1 = unixSleep(args);
+ }


// Transform E1 = E2.xSync(args) to if-chain with 11 candidates
@transform_assignment_xSync@
expression E1, E2;
identifier FP_NAME = xSync;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xSync_signature, xSync_signatures[xSync_0_enum], sizeof(E2.xSync_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xSync_signature, xSync_signatures[xSync_apndSync_enum], sizeof(E2.xSync_signature)) == 0) {
+ E1 = apndSync(args);
+ }
+ else if (memcmp(E2.xSync_signature, xSync_signatures[xSync_dbpageSync_enum], sizeof(E2.xSync_signature)) == 0) {
+ E1 = dbpageSync(args);
+ }
+ else if (memcmp(E2.xSync_signature, xSync_signatures[xSync_echoSync_enum], sizeof(E2.xSync_signature)) == 0) {
+ E1 = echoSync(args);
+ }
+ else if (memcmp(E2.xSync_signature, xSync_signatures[xSync_fts3SyncMethod_enum], sizeof(E2.xSync_signature)) == 0) {
+ E1 = fts3SyncMethod(args);
+ }
+ else if (memcmp(E2.xSync_signature, xSync_signatures[xSync_memdbSync_enum], sizeof(E2.xSync_signature)) == 0) {
+ E1 = memdbSync(args);
+ }
+ else if (memcmp(E2.xSync_signature, xSync_signatures[xSync_memjrnlSync_enum], sizeof(E2.xSync_signature)) == 0) {
+ E1 = memjrnlSync(args);
+ }
+ else if (memcmp(E2.xSync_signature, xSync_signatures[xSync_recoverVfsSync_enum], sizeof(E2.xSync_signature)) == 0) {
+ E1 = recoverVfsSync(args);
+ }
+ else if (memcmp(E2.xSync_signature, xSync_signatures[xSync_rtreeEndTransaction_enum], sizeof(E2.xSync_signature)) == 0) {
+ E1 = rtreeEndTransaction(args);
+ }
+ else if (memcmp(E2.xSync_signature, xSync_signatures[xSync_vfstraceSync_enum], sizeof(E2.xSync_signature)) == 0) {
+ E1 = vfstraceSync(args);
+ }
+ else if (memcmp(E2.xSync_signature, xSync_signatures[xSync_vtablogSync_enum], sizeof(E2.xSync_signature)) == 0) {
+ E1 = vtablogSync(args);
+ }
+ else if (memcmp(E2.xSync_signature, xSync_signatures[xSync_unixSync_enum], sizeof(E2.xSync_signature)) == 0) {
+ E1 = unixSync(args);
+ }


// Transform E1 = E2.xTokenize(args) to if-chain with 3 candidates
@transform_assignment_xTokenize@
expression E1, E2;
identifier FP_NAME = xTokenize;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xTokenize_signature, xTokenize_signatures[xTokenize_0_enum], sizeof(E2.xTokenize_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xTokenize_signature, xTokenize_signatures[xTokenize_f5tOrigintextTokenize_enum], sizeof(E2.xTokenize_signature)) == 0) {
+ E1 = f5tOrigintextTokenize(args);
+ }
+ else if (memcmp(E2.xTokenize_signature, xTokenize_signatures[xTokenize_f5tTokenizerTokenize_enum], sizeof(E2.xTokenize_signature)) == 0) {
+ E1 = f5tTokenizerTokenize(args);
+ }
+ else if (memcmp(E2.xTokenize_signature, xTokenize_signatures[xTokenize_f5tTokenizerTokenize_v2_enum], sizeof(E2.xTokenize_signature)) == 0) {
+ E1 = f5tTokenizerTokenize_v2(args);
+ }


// Transform E1 = E2.xTruncate(args) to if-chain with 8 candidates
@transform_assignment_xTruncate@
expression E1, E2;
identifier FP_NAME = xTruncate;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xTruncate_signature, xTruncate_signatures[xTruncate_apndTruncate_enum], sizeof(E2.xTruncate_signature)) == 0) {
+ E1 = apndTruncate(args);
+ }
+ else if (memcmp(E2.xTruncate_signature, xTruncate_signatures[xTruncate_memdbTruncate_enum], sizeof(E2.xTruncate_signature)) == 0) {
+ E1 = memdbTruncate(args);
+ }
+ else if (memcmp(E2.xTruncate_signature, xTruncate_signatures[xTruncate_memjrnlTruncate_enum], sizeof(E2.xTruncate_signature)) == 0) {
+ E1 = memjrnlTruncate(args);
+ }
+ else if (memcmp(E2.xTruncate_signature, xTruncate_signatures[xTruncate_pcache1Truncate_enum], sizeof(E2.xTruncate_signature)) == 0) {
+ E1 = pcache1Truncate(args);
+ }
+ else if (memcmp(E2.xTruncate_signature, xTruncate_signatures[xTruncate_pcachetraceTruncate_enum], sizeof(E2.xTruncate_signature)) == 0) {
+ E1 = pcachetraceTruncate(args);
+ }
+ else if (memcmp(E2.xTruncate_signature, xTruncate_signatures[xTruncate_recoverVfsTruncate_enum], sizeof(E2.xTruncate_signature)) == 0) {
+ E1 = recoverVfsTruncate(args);
+ }
+ else if (memcmp(E2.xTruncate_signature, xTruncate_signatures[xTruncate_vfstraceTruncate_enum], sizeof(E2.xTruncate_signature)) == 0) {
+ E1 = vfstraceTruncate(args);
+ }
+ else if (memcmp(E2.xTruncate_signature, xTruncate_signatures[xTruncate_unixTruncate_enum], sizeof(E2.xTruncate_signature)) == 0) {
+ E1 = unixTruncate(args);
+ }


// Transform E1 = E2.xUnfetch(args) to if-chain with 4 candidates
@transform_assignment_xUnfetch@
expression E1, E2;
identifier FP_NAME = xUnfetch;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xUnfetch_signature, xUnfetch_signatures[xUnfetch_0_enum], sizeof(E2.xUnfetch_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xUnfetch_signature, xUnfetch_signatures[xUnfetch_apndUnfetch_enum], sizeof(E2.xUnfetch_signature)) == 0) {
+ E1 = apndUnfetch(args);
+ }
+ else if (memcmp(E2.xUnfetch_signature, xUnfetch_signatures[xUnfetch_memdbUnfetch_enum], sizeof(E2.xUnfetch_signature)) == 0) {
+ E1 = memdbUnfetch(args);
+ }
+ else if (memcmp(E2.xUnfetch_signature, xUnfetch_signatures[xUnfetch_recoverVfsUnfetch_enum], sizeof(E2.xUnfetch_signature)) == 0) {
+ E1 = recoverVfsUnfetch(args);
+ }
+ else if (memcmp(E2.xUnfetch_signature, xUnfetch_signatures[xUnfetch_unixUnfetch_enum], sizeof(E2.xUnfetch_signature)) == 0) {
+ E1 = unixUnfetch(args);
+ }


// Transform E1 = E2.xUnlock(args) to if-chain with 7 candidates
@transform_assignment_xUnlock@
expression E1, E2;
identifier FP_NAME = xUnlock;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xUnlock_signature, xUnlock_signatures[xUnlock_0_enum], sizeof(E2.xUnlock_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xUnlock_signature, xUnlock_signatures[xUnlock_apndUnlock_enum], sizeof(E2.xUnlock_signature)) == 0) {
+ E1 = apndUnlock(args);
+ }
+ else if (memcmp(E2.xUnlock_signature, xUnlock_signatures[xUnlock_memdbUnlock_enum], sizeof(E2.xUnlock_signature)) == 0) {
+ E1 = memdbUnlock(args);
+ }
+ else if (memcmp(E2.xUnlock_signature, xUnlock_signatures[xUnlock_recoverVfsUnlock_enum], sizeof(E2.xUnlock_signature)) == 0) {
+ E1 = recoverVfsUnlock(args);
+ }
+ else if (memcmp(E2.xUnlock_signature, xUnlock_signatures[xUnlock_vfstraceUnlock_enum], sizeof(E2.xUnlock_signature)) == 0) {
+ E1 = vfstraceUnlock(args);
+ }
+ else if (memcmp(E2.xUnlock_signature, xUnlock_signatures[xUnlock_unixUnlock_enum], sizeof(E2.xUnlock_signature)) == 0) {
+ E1 = unixUnlock(args);
+ }
+ else if (memcmp(E2.xUnlock_signature, xUnlock_signatures[xUnlock_nolockUnlock_enum], sizeof(E2.xUnlock_signature)) == 0) {
+ E1 = nolockUnlock(args);
+ }
+ else if (memcmp(E2.xUnlock_signature, xUnlock_signatures[xUnlock_dotlockUnlock_enum], sizeof(E2.xUnlock_signature)) == 0) {
+ E1 = dotlockUnlock(args);
+ }


// Transform E1 = E2.xUnpin(args) to if-chain with 2 candidates
@transform_assignment_xUnpin@
expression E1, E2;
identifier FP_NAME = xUnpin;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xUnpin_signature, xUnpin_signatures[xUnpin_pcache1Unpin_enum], sizeof(E2.xUnpin_signature)) == 0) {
+ E1 = pcache1Unpin(args);
+ }
+ else if (memcmp(E2.xUnpin_signature, xUnpin_signatures[xUnpin_pcachetraceUnpin_enum], sizeof(E2.xUnpin_signature)) == 0) {
+ E1 = pcachetraceUnpin(args);
+ }


// Transform E1 = E2.xUpdate(args) to if-chain with 13 candidates
@transform_assignment_xUpdate@
expression E1, E2;
identifier FP_NAME = xUpdate;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xUpdate_signature, xUpdate_signatures[xUpdate_0_enum], sizeof(E2.xUpdate_signature)) == 0) {
+ E1 = 0;
+ }
+ else if (memcmp(E2.xUpdate_signature, xUpdate_signatures[xUpdate_amatchUpdate_enum], sizeof(E2.xUpdate_signature)) == 0) {
+ E1 = amatchUpdate(args);
+ }
+ else if (memcmp(E2.xUpdate_signature, xUpdate_signatures[xUpdate_csvtabUpdate_enum], sizeof(E2.xUpdate_signature)) == 0) {
+ E1 = csvtabUpdate(args);
+ }
+ else if (memcmp(E2.xUpdate_signature, xUpdate_signatures[xUpdate_dbpageUpdate_enum], sizeof(E2.xUpdate_signature)) == 0) {
+ E1 = dbpageUpdate(args);
+ }
+ else if (memcmp(E2.xUpdate_signature, xUpdate_signatures[xUpdate_echoUpdate_enum], sizeof(E2.xUpdate_signature)) == 0) {
+ E1 = echoUpdate(args);
+ }
+ else if (memcmp(E2.xUpdate_signature, xUpdate_signatures[xUpdate_expertUpdate_enum], sizeof(E2.xUpdate_signature)) == 0) {
+ E1 = expertUpdate(args);
+ }
+ else if (memcmp(E2.xUpdate_signature, xUpdate_signatures[xUpdate_fts3UpdateMethod_enum], sizeof(E2.xUpdate_signature)) == 0) {
+ E1 = fts3UpdateMethod(args);
+ }
+ else if (memcmp(E2.xUpdate_signature, xUpdate_signatures[xUpdate_geopolyUpdate_enum], sizeof(E2.xUpdate_signature)) == 0) {
+ E1 = geopolyUpdate(args);
+ }
+ else if (memcmp(E2.xUpdate_signature, xUpdate_signatures[xUpdate_rtreeUpdate_enum], sizeof(E2.xUpdate_signature)) == 0) {
+ E1 = rtreeUpdate(args);
+ }
+ else if (memcmp(E2.xUpdate_signature, xUpdate_signatures[xUpdate_spellfix1Update_enum], sizeof(E2.xUpdate_signature)) == 0) {
+ E1 = spellfix1Update(args);
+ }
+ else if (memcmp(E2.xUpdate_signature, xUpdate_signatures[xUpdate_tclvarUpdate_enum], sizeof(E2.xUpdate_signature)) == 0) {
+ E1 = tclvarUpdate(args);
+ }
+ else if (memcmp(E2.xUpdate_signature, xUpdate_signatures[xUpdate_vstattabUpdate_enum], sizeof(E2.xUpdate_signature)) == 0) {
+ E1 = vstattabUpdate(args);
+ }
+ else if (memcmp(E2.xUpdate_signature, xUpdate_signatures[xUpdate_vtablogUpdate_enum], sizeof(E2.xUpdate_signature)) == 0) {
+ E1 = vtablogUpdate(args);
+ }
+ else if (memcmp(E2.xUpdate_signature, xUpdate_signatures[xUpdate_zipfileUpdate_enum], sizeof(E2.xUpdate_signature)) == 0) {
+ E1 = zipfileUpdate(args);
+ }


// Transform E1 = E2.xWrite(args) to if-chain with 7 candidates
@transform_assignment_xWrite@
expression E1, E2;
identifier FP_NAME = xWrite;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xWrite_signature, xWrite_signatures[xWrite_apndWrite_enum], sizeof(E2.xWrite_signature)) == 0) {
+ E1 = apndWrite(args);
+ }
+ else if (memcmp(E2.xWrite_signature, xWrite_signatures[xWrite_kvstorageWrite_enum], sizeof(E2.xWrite_signature)) == 0) {
+ E1 = kvstorageWrite(args);
+ }
+ else if (memcmp(E2.xWrite_signature, xWrite_signatures[xWrite_memdbWrite_enum], sizeof(E2.xWrite_signature)) == 0) {
+ E1 = memdbWrite(args);
+ }
+ else if (memcmp(E2.xWrite_signature, xWrite_signatures[xWrite_memjrnlWrite_enum], sizeof(E2.xWrite_signature)) == 0) {
+ E1 = memjrnlWrite(args);
+ }
+ else if (memcmp(E2.xWrite_signature, xWrite_signatures[xWrite_recoverVfsWrite_enum], sizeof(E2.xWrite_signature)) == 0) {
+ E1 = recoverVfsWrite(args);
+ }
+ else if (memcmp(E2.xWrite_signature, xWrite_signatures[xWrite_vfstraceWrite_enum], sizeof(E2.xWrite_signature)) == 0) {
+ E1 = vfstraceWrite(args);
+ }
+ else if (memcmp(E2.xWrite_signature, xWrite_signatures[xWrite_unixWrite_enum], sizeof(E2.xWrite_signature)) == 0) {
+ E1 = unixWrite(args);
+ }


// Transform E1 = E2.xsnprintf(args) to if-chain with 1 candidates
@transform_assignment_xsnprintf@
expression E1, E2;
identifier FP_NAME = xsnprintf;
expression list args;
@@
- E1 = E2.FP_NAME(args);
+ if (memcmp(E2.xsnprintf_signature, xsnprintf_signatures[xsnprintf_sqlite3_set_authorizer_enum], sizeof(E2.xsnprintf_signature)) == 0) {
+ E1 = sqlite3_set_authorizer(args);
+ }

// Total assignment transformation rules generated: 321
