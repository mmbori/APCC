//
// Coccinelle script to extract function declarations and remove 'static' keyword
//
// Generated by: 3_5_extract_fn_declarations.py
// Purpose: Extract function declarations from definitions, remove static keyword
//
// This script:
// 1. Finds function definitions and declarations
// 2. Removes static keyword if present
// 3. Extracts signatures as declaration form (with semicolon)
// 4. Saves to definitions/ folder and consolidates to header file
//
// Usage: spatch --sp-file extract_declarations.cocci --dir <source_directory> --in-place

// Shared Python functions
@initialize:python@
@@
import os
import re

# Track processed functions to avoid duplicates
processed_functions = set()

def clean_function_signature(signature):
    """Clean up function signature formatting"""
    if not signature:
        return signature
    
    # Normalize all whitespace
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Remove all spaces around asterisks first
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Add space before asterisk groups
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Clean up double spaces
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

def extract_and_save_signature(signature, func_name):
    """Extract and save function signature to file (skip if already processed)"""
    if func_name in processed_functions:
        return
    
    processed_functions.add(func_name)
    os.makedirs("definitions", exist_ok=True)
    clean_signature = clean_function_signature(signature)
    filepath = "definitions/" + func_name + ".txt"
    with open(filepath, "w") as f:
        f.write(clean_signature + "\n")
    print("[EXTRACTED] " + func_name)


// ============================================================
// Rules for function: XXH3_accumulate_512
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_XXH3_accumulate_512_def@
type T;
identifier F = XXH3_accumulate_512;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_XXH3_accumulate_512_def@
F << remove_static_XXH3_accumulate_512_def.F;
T << remove_static_XXH3_accumulate_512_def.T;
P << remove_static_XXH3_accumulate_512_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_XXH3_accumulate_512_def_void@
identifier F = XXH3_accumulate_512;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_XXH3_accumulate_512_def_void@
F << remove_static_XXH3_accumulate_512_def_void.F;
P << remove_static_XXH3_accumulate_512_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_XXH3_accumulate_512_decl@
type T;
identifier F = XXH3_accumulate_512;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_XXH3_accumulate_512_decl@
F << remove_static_XXH3_accumulate_512_decl.F;
T << remove_static_XXH3_accumulate_512_decl.T;
P << remove_static_XXH3_accumulate_512_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_XXH3_accumulate_512_decl_void@
identifier F = XXH3_accumulate_512;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_XXH3_accumulate_512_decl_void@
F << remove_static_XXH3_accumulate_512_decl_void.F;
P << remove_static_XXH3_accumulate_512_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_XXH3_accumulate_512_def@
type T;
identifier F = XXH3_accumulate_512;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_XXH3_accumulate_512_def@
F << extract_XXH3_accumulate_512_def.F;
T << extract_XXH3_accumulate_512_def.T;
P << extract_XXH3_accumulate_512_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_XXH3_accumulate_512_def_void@
identifier F = XXH3_accumulate_512;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_XXH3_accumulate_512_def_void@
F << extract_XXH3_accumulate_512_def_void.F;
P << extract_XXH3_accumulate_512_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_XXH3_accumulate_512_decl@
type T;
identifier F = XXH3_accumulate_512;
parameter list P;
@@
T F(P);

@script:python depends on extract_XXH3_accumulate_512_decl@
F << extract_XXH3_accumulate_512_decl.F;
T << extract_XXH3_accumulate_512_decl.T;
P << extract_XXH3_accumulate_512_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_XXH3_accumulate_512_decl_void@
identifier F = XXH3_accumulate_512;
parameter list P;
@@
void F(P);

@script:python depends on extract_XXH3_accumulate_512_decl_void@
F << extract_XXH3_accumulate_512_decl_void.F;
P << extract_XXH3_accumulate_512_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: XXH3_hashLong_128b_default
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_XXH3_hashLong_128b_default_def@
type T;
identifier F = XXH3_hashLong_128b_default;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_XXH3_hashLong_128b_default_def@
F << remove_static_XXH3_hashLong_128b_default_def.F;
T << remove_static_XXH3_hashLong_128b_default_def.T;
P << remove_static_XXH3_hashLong_128b_default_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_XXH3_hashLong_128b_default_def_void@
identifier F = XXH3_hashLong_128b_default;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_XXH3_hashLong_128b_default_def_void@
F << remove_static_XXH3_hashLong_128b_default_def_void.F;
P << remove_static_XXH3_hashLong_128b_default_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_XXH3_hashLong_128b_default_decl@
type T;
identifier F = XXH3_hashLong_128b_default;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_XXH3_hashLong_128b_default_decl@
F << remove_static_XXH3_hashLong_128b_default_decl.F;
T << remove_static_XXH3_hashLong_128b_default_decl.T;
P << remove_static_XXH3_hashLong_128b_default_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_XXH3_hashLong_128b_default_decl_void@
identifier F = XXH3_hashLong_128b_default;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_XXH3_hashLong_128b_default_decl_void@
F << remove_static_XXH3_hashLong_128b_default_decl_void.F;
P << remove_static_XXH3_hashLong_128b_default_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_XXH3_hashLong_128b_default_def@
type T;
identifier F = XXH3_hashLong_128b_default;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_XXH3_hashLong_128b_default_def@
F << extract_XXH3_hashLong_128b_default_def.F;
T << extract_XXH3_hashLong_128b_default_def.T;
P << extract_XXH3_hashLong_128b_default_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_XXH3_hashLong_128b_default_def_void@
identifier F = XXH3_hashLong_128b_default;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_XXH3_hashLong_128b_default_def_void@
F << extract_XXH3_hashLong_128b_default_def_void.F;
P << extract_XXH3_hashLong_128b_default_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_XXH3_hashLong_128b_default_decl@
type T;
identifier F = XXH3_hashLong_128b_default;
parameter list P;
@@
T F(P);

@script:python depends on extract_XXH3_hashLong_128b_default_decl@
F << extract_XXH3_hashLong_128b_default_decl.F;
T << extract_XXH3_hashLong_128b_default_decl.T;
P << extract_XXH3_hashLong_128b_default_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_XXH3_hashLong_128b_default_decl_void@
identifier F = XXH3_hashLong_128b_default;
parameter list P;
@@
void F(P);

@script:python depends on extract_XXH3_hashLong_128b_default_decl_void@
F << extract_XXH3_hashLong_128b_default_decl_void.F;
P << extract_XXH3_hashLong_128b_default_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: XXH3_hashLong_128b_withSecret
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_XXH3_hashLong_128b_withSecret_def@
type T;
identifier F = XXH3_hashLong_128b_withSecret;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_XXH3_hashLong_128b_withSecret_def@
F << remove_static_XXH3_hashLong_128b_withSecret_def.F;
T << remove_static_XXH3_hashLong_128b_withSecret_def.T;
P << remove_static_XXH3_hashLong_128b_withSecret_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_XXH3_hashLong_128b_withSecret_def_void@
identifier F = XXH3_hashLong_128b_withSecret;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_XXH3_hashLong_128b_withSecret_def_void@
F << remove_static_XXH3_hashLong_128b_withSecret_def_void.F;
P << remove_static_XXH3_hashLong_128b_withSecret_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_XXH3_hashLong_128b_withSecret_decl@
type T;
identifier F = XXH3_hashLong_128b_withSecret;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_XXH3_hashLong_128b_withSecret_decl@
F << remove_static_XXH3_hashLong_128b_withSecret_decl.F;
T << remove_static_XXH3_hashLong_128b_withSecret_decl.T;
P << remove_static_XXH3_hashLong_128b_withSecret_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_XXH3_hashLong_128b_withSecret_decl_void@
identifier F = XXH3_hashLong_128b_withSecret;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_XXH3_hashLong_128b_withSecret_decl_void@
F << remove_static_XXH3_hashLong_128b_withSecret_decl_void.F;
P << remove_static_XXH3_hashLong_128b_withSecret_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_XXH3_hashLong_128b_withSecret_def@
type T;
identifier F = XXH3_hashLong_128b_withSecret;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_XXH3_hashLong_128b_withSecret_def@
F << extract_XXH3_hashLong_128b_withSecret_def.F;
T << extract_XXH3_hashLong_128b_withSecret_def.T;
P << extract_XXH3_hashLong_128b_withSecret_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_XXH3_hashLong_128b_withSecret_def_void@
identifier F = XXH3_hashLong_128b_withSecret;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_XXH3_hashLong_128b_withSecret_def_void@
F << extract_XXH3_hashLong_128b_withSecret_def_void.F;
P << extract_XXH3_hashLong_128b_withSecret_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_XXH3_hashLong_128b_withSecret_decl@
type T;
identifier F = XXH3_hashLong_128b_withSecret;
parameter list P;
@@
T F(P);

@script:python depends on extract_XXH3_hashLong_128b_withSecret_decl@
F << extract_XXH3_hashLong_128b_withSecret_decl.F;
T << extract_XXH3_hashLong_128b_withSecret_decl.T;
P << extract_XXH3_hashLong_128b_withSecret_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_XXH3_hashLong_128b_withSecret_decl_void@
identifier F = XXH3_hashLong_128b_withSecret;
parameter list P;
@@
void F(P);

@script:python depends on extract_XXH3_hashLong_128b_withSecret_decl_void@
F << extract_XXH3_hashLong_128b_withSecret_decl_void.F;
P << extract_XXH3_hashLong_128b_withSecret_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: XXH3_hashLong_128b_withSeed
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_XXH3_hashLong_128b_withSeed_def@
type T;
identifier F = XXH3_hashLong_128b_withSeed;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_XXH3_hashLong_128b_withSeed_def@
F << remove_static_XXH3_hashLong_128b_withSeed_def.F;
T << remove_static_XXH3_hashLong_128b_withSeed_def.T;
P << remove_static_XXH3_hashLong_128b_withSeed_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_XXH3_hashLong_128b_withSeed_def_void@
identifier F = XXH3_hashLong_128b_withSeed;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_XXH3_hashLong_128b_withSeed_def_void@
F << remove_static_XXH3_hashLong_128b_withSeed_def_void.F;
P << remove_static_XXH3_hashLong_128b_withSeed_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_XXH3_hashLong_128b_withSeed_decl@
type T;
identifier F = XXH3_hashLong_128b_withSeed;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_XXH3_hashLong_128b_withSeed_decl@
F << remove_static_XXH3_hashLong_128b_withSeed_decl.F;
T << remove_static_XXH3_hashLong_128b_withSeed_decl.T;
P << remove_static_XXH3_hashLong_128b_withSeed_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_XXH3_hashLong_128b_withSeed_decl_void@
identifier F = XXH3_hashLong_128b_withSeed;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_XXH3_hashLong_128b_withSeed_decl_void@
F << remove_static_XXH3_hashLong_128b_withSeed_decl_void.F;
P << remove_static_XXH3_hashLong_128b_withSeed_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_XXH3_hashLong_128b_withSeed_def@
type T;
identifier F = XXH3_hashLong_128b_withSeed;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_XXH3_hashLong_128b_withSeed_def@
F << extract_XXH3_hashLong_128b_withSeed_def.F;
T << extract_XXH3_hashLong_128b_withSeed_def.T;
P << extract_XXH3_hashLong_128b_withSeed_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_XXH3_hashLong_128b_withSeed_def_void@
identifier F = XXH3_hashLong_128b_withSeed;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_XXH3_hashLong_128b_withSeed_def_void@
F << extract_XXH3_hashLong_128b_withSeed_def_void.F;
P << extract_XXH3_hashLong_128b_withSeed_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_XXH3_hashLong_128b_withSeed_decl@
type T;
identifier F = XXH3_hashLong_128b_withSeed;
parameter list P;
@@
T F(P);

@script:python depends on extract_XXH3_hashLong_128b_withSeed_decl@
F << extract_XXH3_hashLong_128b_withSeed_decl.F;
T << extract_XXH3_hashLong_128b_withSeed_decl.T;
P << extract_XXH3_hashLong_128b_withSeed_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_XXH3_hashLong_128b_withSeed_decl_void@
identifier F = XXH3_hashLong_128b_withSeed;
parameter list P;
@@
void F(P);

@script:python depends on extract_XXH3_hashLong_128b_withSeed_decl_void@
F << extract_XXH3_hashLong_128b_withSeed_decl_void.F;
P << extract_XXH3_hashLong_128b_withSeed_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: XXH3_hashLong_64b_default
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_XXH3_hashLong_64b_default_def@
type T;
identifier F = XXH3_hashLong_64b_default;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_XXH3_hashLong_64b_default_def@
F << remove_static_XXH3_hashLong_64b_default_def.F;
T << remove_static_XXH3_hashLong_64b_default_def.T;
P << remove_static_XXH3_hashLong_64b_default_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_XXH3_hashLong_64b_default_def_void@
identifier F = XXH3_hashLong_64b_default;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_XXH3_hashLong_64b_default_def_void@
F << remove_static_XXH3_hashLong_64b_default_def_void.F;
P << remove_static_XXH3_hashLong_64b_default_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_XXH3_hashLong_64b_default_decl@
type T;
identifier F = XXH3_hashLong_64b_default;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_XXH3_hashLong_64b_default_decl@
F << remove_static_XXH3_hashLong_64b_default_decl.F;
T << remove_static_XXH3_hashLong_64b_default_decl.T;
P << remove_static_XXH3_hashLong_64b_default_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_XXH3_hashLong_64b_default_decl_void@
identifier F = XXH3_hashLong_64b_default;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_XXH3_hashLong_64b_default_decl_void@
F << remove_static_XXH3_hashLong_64b_default_decl_void.F;
P << remove_static_XXH3_hashLong_64b_default_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_XXH3_hashLong_64b_default_def@
type T;
identifier F = XXH3_hashLong_64b_default;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_XXH3_hashLong_64b_default_def@
F << extract_XXH3_hashLong_64b_default_def.F;
T << extract_XXH3_hashLong_64b_default_def.T;
P << extract_XXH3_hashLong_64b_default_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_XXH3_hashLong_64b_default_def_void@
identifier F = XXH3_hashLong_64b_default;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_XXH3_hashLong_64b_default_def_void@
F << extract_XXH3_hashLong_64b_default_def_void.F;
P << extract_XXH3_hashLong_64b_default_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_XXH3_hashLong_64b_default_decl@
type T;
identifier F = XXH3_hashLong_64b_default;
parameter list P;
@@
T F(P);

@script:python depends on extract_XXH3_hashLong_64b_default_decl@
F << extract_XXH3_hashLong_64b_default_decl.F;
T << extract_XXH3_hashLong_64b_default_decl.T;
P << extract_XXH3_hashLong_64b_default_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_XXH3_hashLong_64b_default_decl_void@
identifier F = XXH3_hashLong_64b_default;
parameter list P;
@@
void F(P);

@script:python depends on extract_XXH3_hashLong_64b_default_decl_void@
F << extract_XXH3_hashLong_64b_default_decl_void.F;
P << extract_XXH3_hashLong_64b_default_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: XXH3_hashLong_64b_withSecret
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_XXH3_hashLong_64b_withSecret_def@
type T;
identifier F = XXH3_hashLong_64b_withSecret;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_XXH3_hashLong_64b_withSecret_def@
F << remove_static_XXH3_hashLong_64b_withSecret_def.F;
T << remove_static_XXH3_hashLong_64b_withSecret_def.T;
P << remove_static_XXH3_hashLong_64b_withSecret_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_XXH3_hashLong_64b_withSecret_def_void@
identifier F = XXH3_hashLong_64b_withSecret;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_XXH3_hashLong_64b_withSecret_def_void@
F << remove_static_XXH3_hashLong_64b_withSecret_def_void.F;
P << remove_static_XXH3_hashLong_64b_withSecret_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_XXH3_hashLong_64b_withSecret_decl@
type T;
identifier F = XXH3_hashLong_64b_withSecret;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_XXH3_hashLong_64b_withSecret_decl@
F << remove_static_XXH3_hashLong_64b_withSecret_decl.F;
T << remove_static_XXH3_hashLong_64b_withSecret_decl.T;
P << remove_static_XXH3_hashLong_64b_withSecret_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_XXH3_hashLong_64b_withSecret_decl_void@
identifier F = XXH3_hashLong_64b_withSecret;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_XXH3_hashLong_64b_withSecret_decl_void@
F << remove_static_XXH3_hashLong_64b_withSecret_decl_void.F;
P << remove_static_XXH3_hashLong_64b_withSecret_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_XXH3_hashLong_64b_withSecret_def@
type T;
identifier F = XXH3_hashLong_64b_withSecret;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_XXH3_hashLong_64b_withSecret_def@
F << extract_XXH3_hashLong_64b_withSecret_def.F;
T << extract_XXH3_hashLong_64b_withSecret_def.T;
P << extract_XXH3_hashLong_64b_withSecret_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_XXH3_hashLong_64b_withSecret_def_void@
identifier F = XXH3_hashLong_64b_withSecret;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_XXH3_hashLong_64b_withSecret_def_void@
F << extract_XXH3_hashLong_64b_withSecret_def_void.F;
P << extract_XXH3_hashLong_64b_withSecret_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_XXH3_hashLong_64b_withSecret_decl@
type T;
identifier F = XXH3_hashLong_64b_withSecret;
parameter list P;
@@
T F(P);

@script:python depends on extract_XXH3_hashLong_64b_withSecret_decl@
F << extract_XXH3_hashLong_64b_withSecret_decl.F;
T << extract_XXH3_hashLong_64b_withSecret_decl.T;
P << extract_XXH3_hashLong_64b_withSecret_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_XXH3_hashLong_64b_withSecret_decl_void@
identifier F = XXH3_hashLong_64b_withSecret;
parameter list P;
@@
void F(P);

@script:python depends on extract_XXH3_hashLong_64b_withSecret_decl_void@
F << extract_XXH3_hashLong_64b_withSecret_decl_void.F;
P << extract_XXH3_hashLong_64b_withSecret_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: XXH3_hashLong_64b_withSeed
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_XXH3_hashLong_64b_withSeed_def@
type T;
identifier F = XXH3_hashLong_64b_withSeed;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_XXH3_hashLong_64b_withSeed_def@
F << remove_static_XXH3_hashLong_64b_withSeed_def.F;
T << remove_static_XXH3_hashLong_64b_withSeed_def.T;
P << remove_static_XXH3_hashLong_64b_withSeed_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_XXH3_hashLong_64b_withSeed_def_void@
identifier F = XXH3_hashLong_64b_withSeed;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_XXH3_hashLong_64b_withSeed_def_void@
F << remove_static_XXH3_hashLong_64b_withSeed_def_void.F;
P << remove_static_XXH3_hashLong_64b_withSeed_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_XXH3_hashLong_64b_withSeed_decl@
type T;
identifier F = XXH3_hashLong_64b_withSeed;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_XXH3_hashLong_64b_withSeed_decl@
F << remove_static_XXH3_hashLong_64b_withSeed_decl.F;
T << remove_static_XXH3_hashLong_64b_withSeed_decl.T;
P << remove_static_XXH3_hashLong_64b_withSeed_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_XXH3_hashLong_64b_withSeed_decl_void@
identifier F = XXH3_hashLong_64b_withSeed;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_XXH3_hashLong_64b_withSeed_decl_void@
F << remove_static_XXH3_hashLong_64b_withSeed_decl_void.F;
P << remove_static_XXH3_hashLong_64b_withSeed_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_XXH3_hashLong_64b_withSeed_def@
type T;
identifier F = XXH3_hashLong_64b_withSeed;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_XXH3_hashLong_64b_withSeed_def@
F << extract_XXH3_hashLong_64b_withSeed_def.F;
T << extract_XXH3_hashLong_64b_withSeed_def.T;
P << extract_XXH3_hashLong_64b_withSeed_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_XXH3_hashLong_64b_withSeed_def_void@
identifier F = XXH3_hashLong_64b_withSeed;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_XXH3_hashLong_64b_withSeed_def_void@
F << extract_XXH3_hashLong_64b_withSeed_def_void.F;
P << extract_XXH3_hashLong_64b_withSeed_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_XXH3_hashLong_64b_withSeed_decl@
type T;
identifier F = XXH3_hashLong_64b_withSeed;
parameter list P;
@@
T F(P);

@script:python depends on extract_XXH3_hashLong_64b_withSeed_decl@
F << extract_XXH3_hashLong_64b_withSeed_decl.F;
T << extract_XXH3_hashLong_64b_withSeed_decl.T;
P << extract_XXH3_hashLong_64b_withSeed_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_XXH3_hashLong_64b_withSeed_decl_void@
identifier F = XXH3_hashLong_64b_withSeed;
parameter list P;
@@
void F(P);

@script:python depends on extract_XXH3_hashLong_64b_withSeed_decl_void@
F << extract_XXH3_hashLong_64b_withSeed_decl_void.F;
P << extract_XXH3_hashLong_64b_withSeed_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: XXH3_initCustomSecret
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_XXH3_initCustomSecret_def@
type T;
identifier F = XXH3_initCustomSecret;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_XXH3_initCustomSecret_def@
F << remove_static_XXH3_initCustomSecret_def.F;
T << remove_static_XXH3_initCustomSecret_def.T;
P << remove_static_XXH3_initCustomSecret_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_XXH3_initCustomSecret_def_void@
identifier F = XXH3_initCustomSecret;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_XXH3_initCustomSecret_def_void@
F << remove_static_XXH3_initCustomSecret_def_void.F;
P << remove_static_XXH3_initCustomSecret_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_XXH3_initCustomSecret_decl@
type T;
identifier F = XXH3_initCustomSecret;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_XXH3_initCustomSecret_decl@
F << remove_static_XXH3_initCustomSecret_decl.F;
T << remove_static_XXH3_initCustomSecret_decl.T;
P << remove_static_XXH3_initCustomSecret_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_XXH3_initCustomSecret_decl_void@
identifier F = XXH3_initCustomSecret;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_XXH3_initCustomSecret_decl_void@
F << remove_static_XXH3_initCustomSecret_decl_void.F;
P << remove_static_XXH3_initCustomSecret_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_XXH3_initCustomSecret_def@
type T;
identifier F = XXH3_initCustomSecret;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_XXH3_initCustomSecret_def@
F << extract_XXH3_initCustomSecret_def.F;
T << extract_XXH3_initCustomSecret_def.T;
P << extract_XXH3_initCustomSecret_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_XXH3_initCustomSecret_def_void@
identifier F = XXH3_initCustomSecret;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_XXH3_initCustomSecret_def_void@
F << extract_XXH3_initCustomSecret_def_void.F;
P << extract_XXH3_initCustomSecret_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_XXH3_initCustomSecret_decl@
type T;
identifier F = XXH3_initCustomSecret;
parameter list P;
@@
T F(P);

@script:python depends on extract_XXH3_initCustomSecret_decl@
F << extract_XXH3_initCustomSecret_decl.F;
T << extract_XXH3_initCustomSecret_decl.T;
P << extract_XXH3_initCustomSecret_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_XXH3_initCustomSecret_decl_void@
identifier F = XXH3_initCustomSecret;
parameter list P;
@@
void F(P);

@script:python depends on extract_XXH3_initCustomSecret_decl_void@
F << extract_XXH3_initCustomSecret_decl_void.F;
P << extract_XXH3_initCustomSecret_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: XXH3_scrambleAcc
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_XXH3_scrambleAcc_def@
type T;
identifier F = XXH3_scrambleAcc;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_XXH3_scrambleAcc_def@
F << remove_static_XXH3_scrambleAcc_def.F;
T << remove_static_XXH3_scrambleAcc_def.T;
P << remove_static_XXH3_scrambleAcc_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_XXH3_scrambleAcc_def_void@
identifier F = XXH3_scrambleAcc;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_XXH3_scrambleAcc_def_void@
F << remove_static_XXH3_scrambleAcc_def_void.F;
P << remove_static_XXH3_scrambleAcc_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_XXH3_scrambleAcc_decl@
type T;
identifier F = XXH3_scrambleAcc;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_XXH3_scrambleAcc_decl@
F << remove_static_XXH3_scrambleAcc_decl.F;
T << remove_static_XXH3_scrambleAcc_decl.T;
P << remove_static_XXH3_scrambleAcc_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_XXH3_scrambleAcc_decl_void@
identifier F = XXH3_scrambleAcc;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_XXH3_scrambleAcc_decl_void@
F << remove_static_XXH3_scrambleAcc_decl_void.F;
P << remove_static_XXH3_scrambleAcc_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_XXH3_scrambleAcc_def@
type T;
identifier F = XXH3_scrambleAcc;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_XXH3_scrambleAcc_def@
F << extract_XXH3_scrambleAcc_def.F;
T << extract_XXH3_scrambleAcc_def.T;
P << extract_XXH3_scrambleAcc_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_XXH3_scrambleAcc_def_void@
identifier F = XXH3_scrambleAcc;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_XXH3_scrambleAcc_def_void@
F << extract_XXH3_scrambleAcc_def_void.F;
P << extract_XXH3_scrambleAcc_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_XXH3_scrambleAcc_decl@
type T;
identifier F = XXH3_scrambleAcc;
parameter list P;
@@
T F(P);

@script:python depends on extract_XXH3_scrambleAcc_decl@
F << extract_XXH3_scrambleAcc_decl.F;
T << extract_XXH3_scrambleAcc_decl.T;
P << extract_XXH3_scrambleAcc_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_XXH3_scrambleAcc_decl_void@
identifier F = XXH3_scrambleAcc;
parameter list P;
@@
void F(P);

@script:python depends on extract_XXH3_scrambleAcc_decl_void@
F << extract_XXH3_scrambleAcc_decl_void.F;
P << extract_XXH3_scrambleAcc_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: _mc_meta_load_cb
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static__mc_meta_load_cb_def@
type T;
identifier F = _mc_meta_load_cb;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static__mc_meta_load_cb_def@
F << remove_static__mc_meta_load_cb_def.F;
T << remove_static__mc_meta_load_cb_def.T;
P << remove_static__mc_meta_load_cb_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static__mc_meta_load_cb_def_void@
identifier F = _mc_meta_load_cb;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static__mc_meta_load_cb_def_void@
F << remove_static__mc_meta_load_cb_def_void.F;
P << remove_static__mc_meta_load_cb_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static__mc_meta_load_cb_decl@
type T;
identifier F = _mc_meta_load_cb;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static__mc_meta_load_cb_decl@
F << remove_static__mc_meta_load_cb_decl.F;
T << remove_static__mc_meta_load_cb_decl.T;
P << remove_static__mc_meta_load_cb_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static__mc_meta_load_cb_decl_void@
identifier F = _mc_meta_load_cb;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static__mc_meta_load_cb_decl_void@
F << remove_static__mc_meta_load_cb_decl_void.F;
P << remove_static__mc_meta_load_cb_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract__mc_meta_load_cb_def@
type T;
identifier F = _mc_meta_load_cb;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract__mc_meta_load_cb_def@
F << extract__mc_meta_load_cb_def.F;
T << extract__mc_meta_load_cb_def.T;
P << extract__mc_meta_load_cb_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract__mc_meta_load_cb_def_void@
identifier F = _mc_meta_load_cb;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract__mc_meta_load_cb_def_void@
F << extract__mc_meta_load_cb_def_void.F;
P << extract__mc_meta_load_cb_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract__mc_meta_load_cb_decl@
type T;
identifier F = _mc_meta_load_cb;
parameter list P;
@@
T F(P);

@script:python depends on extract__mc_meta_load_cb_decl@
F << extract__mc_meta_load_cb_decl.F;
T << extract__mc_meta_load_cb_decl.T;
P << extract__mc_meta_load_cb_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract__mc_meta_load_cb_decl_void@
identifier F = _mc_meta_load_cb;
parameter list P;
@@
void F(P);

@script:python depends on extract__mc_meta_load_cb_decl_void@
F << extract__mc_meta_load_cb_decl_void.F;
P << extract__mc_meta_load_cb_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: _mc_meta_save_cb
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static__mc_meta_save_cb_def@
type T;
identifier F = _mc_meta_save_cb;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static__mc_meta_save_cb_def@
F << remove_static__mc_meta_save_cb_def.F;
T << remove_static__mc_meta_save_cb_def.T;
P << remove_static__mc_meta_save_cb_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static__mc_meta_save_cb_def_void@
identifier F = _mc_meta_save_cb;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static__mc_meta_save_cb_def_void@
F << remove_static__mc_meta_save_cb_def_void.F;
P << remove_static__mc_meta_save_cb_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static__mc_meta_save_cb_decl@
type T;
identifier F = _mc_meta_save_cb;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static__mc_meta_save_cb_decl@
F << remove_static__mc_meta_save_cb_decl.F;
T << remove_static__mc_meta_save_cb_decl.T;
P << remove_static__mc_meta_save_cb_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static__mc_meta_save_cb_decl_void@
identifier F = _mc_meta_save_cb;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static__mc_meta_save_cb_decl_void@
F << remove_static__mc_meta_save_cb_decl_void.F;
P << remove_static__mc_meta_save_cb_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract__mc_meta_save_cb_def@
type T;
identifier F = _mc_meta_save_cb;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract__mc_meta_save_cb_def@
F << extract__mc_meta_save_cb_def.F;
T << extract__mc_meta_save_cb_def.T;
P << extract__mc_meta_save_cb_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract__mc_meta_save_cb_def_void@
identifier F = _mc_meta_save_cb;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract__mc_meta_save_cb_def_void@
F << extract__mc_meta_save_cb_def_void.F;
P << extract__mc_meta_save_cb_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract__mc_meta_save_cb_decl@
type T;
identifier F = _mc_meta_save_cb;
parameter list P;
@@
T F(P);

@script:python depends on extract__mc_meta_save_cb_decl@
F << extract__mc_meta_save_cb_decl.F;
T << extract__mc_meta_save_cb_decl.T;
P << extract__mc_meta_save_cb_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract__mc_meta_save_cb_decl_void@
identifier F = _mc_meta_save_cb;
parameter list P;
@@
void F(P);

@script:python depends on extract__mc_meta_save_cb_decl_void@
F << extract__mc_meta_save_cb_decl_void.F;
P << extract__mc_meta_save_cb_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: _slabs_locked_cb
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static__slabs_locked_cb_def@
type T;
identifier F = _slabs_locked_cb;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static__slabs_locked_cb_def@
F << remove_static__slabs_locked_cb_def.F;
T << remove_static__slabs_locked_cb_def.T;
P << remove_static__slabs_locked_cb_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static__slabs_locked_cb_def_void@
identifier F = _slabs_locked_cb;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static__slabs_locked_cb_def_void@
F << remove_static__slabs_locked_cb_def_void.F;
P << remove_static__slabs_locked_cb_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static__slabs_locked_cb_decl@
type T;
identifier F = _slabs_locked_cb;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static__slabs_locked_cb_decl@
F << remove_static__slabs_locked_cb_decl.F;
T << remove_static__slabs_locked_cb_decl.T;
P << remove_static__slabs_locked_cb_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static__slabs_locked_cb_decl_void@
identifier F = _slabs_locked_cb;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static__slabs_locked_cb_decl_void@
F << remove_static__slabs_locked_cb_decl_void.F;
P << remove_static__slabs_locked_cb_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract__slabs_locked_cb_def@
type T;
identifier F = _slabs_locked_cb;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract__slabs_locked_cb_def@
F << extract__slabs_locked_cb_def.F;
T << extract__slabs_locked_cb_def.T;
P << extract__slabs_locked_cb_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract__slabs_locked_cb_def_void@
identifier F = _slabs_locked_cb;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract__slabs_locked_cb_def_void@
F << extract__slabs_locked_cb_def_void.F;
P << extract__slabs_locked_cb_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract__slabs_locked_cb_decl@
type T;
identifier F = _slabs_locked_cb;
parameter list P;
@@
T F(P);

@script:python depends on extract__slabs_locked_cb_decl@
F << extract__slabs_locked_cb_decl.F;
T << extract__slabs_locked_cb_decl.T;
P << extract__slabs_locked_cb_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract__slabs_locked_cb_decl_void@
identifier F = _slabs_locked_cb;
parameter list P;
@@
void F(P);

@script:python depends on extract__slabs_locked_cb_decl_void@
F << extract__slabs_locked_cb_decl_void.F;
P << extract__slabs_locked_cb_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: append_stats
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_append_stats_def@
type T;
identifier F = append_stats;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_append_stats_def@
F << remove_static_append_stats_def.F;
T << remove_static_append_stats_def.T;
P << remove_static_append_stats_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_append_stats_def_void@
identifier F = append_stats;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_append_stats_def_void@
F << remove_static_append_stats_def_void.F;
P << remove_static_append_stats_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_append_stats_decl@
type T;
identifier F = append_stats;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_append_stats_decl@
F << remove_static_append_stats_decl.F;
T << remove_static_append_stats_decl.T;
P << remove_static_append_stats_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_append_stats_decl_void@
identifier F = append_stats;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_append_stats_decl_void@
F << remove_static_append_stats_decl_void.F;
P << remove_static_append_stats_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_append_stats_def@
type T;
identifier F = append_stats;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_append_stats_def@
F << extract_append_stats_def.F;
T << extract_append_stats_def.T;
P << extract_append_stats_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_append_stats_def_void@
identifier F = append_stats;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_append_stats_def_void@
F << extract_append_stats_def_void.F;
P << extract_append_stats_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_append_stats_decl@
type T;
identifier F = append_stats;
parameter list P;
@@
T F(P);

@script:python depends on extract_append_stats_decl@
F << extract_append_stats_decl.F;
T << extract_append_stats_decl.T;
P << extract_append_stats_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_append_stats_decl_void@
identifier F = append_stats;
parameter list P;
@@
void F(P);

@script:python depends on extract_append_stats_decl_void@
F << extract_append_stats_decl_void.F;
P << extract_append_stats_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: crawler_expired_doneclass
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_crawler_expired_doneclass_def@
type T;
identifier F = crawler_expired_doneclass;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_crawler_expired_doneclass_def@
F << remove_static_crawler_expired_doneclass_def.F;
T << remove_static_crawler_expired_doneclass_def.T;
P << remove_static_crawler_expired_doneclass_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_crawler_expired_doneclass_def_void@
identifier F = crawler_expired_doneclass;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_crawler_expired_doneclass_def_void@
F << remove_static_crawler_expired_doneclass_def_void.F;
P << remove_static_crawler_expired_doneclass_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_crawler_expired_doneclass_decl@
type T;
identifier F = crawler_expired_doneclass;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_crawler_expired_doneclass_decl@
F << remove_static_crawler_expired_doneclass_decl.F;
T << remove_static_crawler_expired_doneclass_decl.T;
P << remove_static_crawler_expired_doneclass_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_crawler_expired_doneclass_decl_void@
identifier F = crawler_expired_doneclass;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_crawler_expired_doneclass_decl_void@
F << remove_static_crawler_expired_doneclass_decl_void.F;
P << remove_static_crawler_expired_doneclass_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_crawler_expired_doneclass_def@
type T;
identifier F = crawler_expired_doneclass;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_crawler_expired_doneclass_def@
F << extract_crawler_expired_doneclass_def.F;
T << extract_crawler_expired_doneclass_def.T;
P << extract_crawler_expired_doneclass_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_crawler_expired_doneclass_def_void@
identifier F = crawler_expired_doneclass;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_crawler_expired_doneclass_def_void@
F << extract_crawler_expired_doneclass_def_void.F;
P << extract_crawler_expired_doneclass_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_crawler_expired_doneclass_decl@
type T;
identifier F = crawler_expired_doneclass;
parameter list P;
@@
T F(P);

@script:python depends on extract_crawler_expired_doneclass_decl@
F << extract_crawler_expired_doneclass_decl.F;
T << extract_crawler_expired_doneclass_decl.T;
P << extract_crawler_expired_doneclass_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_crawler_expired_doneclass_decl_void@
identifier F = crawler_expired_doneclass;
parameter list P;
@@
void F(P);

@script:python depends on extract_crawler_expired_doneclass_decl_void@
F << extract_crawler_expired_doneclass_decl_void.F;
P << extract_crawler_expired_doneclass_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: crawler_expired_eval
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_crawler_expired_eval_def@
type T;
identifier F = crawler_expired_eval;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_crawler_expired_eval_def@
F << remove_static_crawler_expired_eval_def.F;
T << remove_static_crawler_expired_eval_def.T;
P << remove_static_crawler_expired_eval_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_crawler_expired_eval_def_void@
identifier F = crawler_expired_eval;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_crawler_expired_eval_def_void@
F << remove_static_crawler_expired_eval_def_void.F;
P << remove_static_crawler_expired_eval_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_crawler_expired_eval_decl@
type T;
identifier F = crawler_expired_eval;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_crawler_expired_eval_decl@
F << remove_static_crawler_expired_eval_decl.F;
T << remove_static_crawler_expired_eval_decl.T;
P << remove_static_crawler_expired_eval_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_crawler_expired_eval_decl_void@
identifier F = crawler_expired_eval;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_crawler_expired_eval_decl_void@
F << remove_static_crawler_expired_eval_decl_void.F;
P << remove_static_crawler_expired_eval_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_crawler_expired_eval_def@
type T;
identifier F = crawler_expired_eval;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_crawler_expired_eval_def@
F << extract_crawler_expired_eval_def.F;
T << extract_crawler_expired_eval_def.T;
P << extract_crawler_expired_eval_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_crawler_expired_eval_def_void@
identifier F = crawler_expired_eval;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_crawler_expired_eval_def_void@
F << extract_crawler_expired_eval_def_void.F;
P << extract_crawler_expired_eval_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_crawler_expired_eval_decl@
type T;
identifier F = crawler_expired_eval;
parameter list P;
@@
T F(P);

@script:python depends on extract_crawler_expired_eval_decl@
F << extract_crawler_expired_eval_decl.F;
T << extract_crawler_expired_eval_decl.T;
P << extract_crawler_expired_eval_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_crawler_expired_eval_decl_void@
identifier F = crawler_expired_eval;
parameter list P;
@@
void F(P);

@script:python depends on extract_crawler_expired_eval_decl_void@
F << extract_crawler_expired_eval_decl_void.F;
P << extract_crawler_expired_eval_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: crawler_expired_finalize
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_crawler_expired_finalize_def@
type T;
identifier F = crawler_expired_finalize;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_crawler_expired_finalize_def@
F << remove_static_crawler_expired_finalize_def.F;
T << remove_static_crawler_expired_finalize_def.T;
P << remove_static_crawler_expired_finalize_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_crawler_expired_finalize_def_void@
identifier F = crawler_expired_finalize;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_crawler_expired_finalize_def_void@
F << remove_static_crawler_expired_finalize_def_void.F;
P << remove_static_crawler_expired_finalize_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_crawler_expired_finalize_decl@
type T;
identifier F = crawler_expired_finalize;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_crawler_expired_finalize_decl@
F << remove_static_crawler_expired_finalize_decl.F;
T << remove_static_crawler_expired_finalize_decl.T;
P << remove_static_crawler_expired_finalize_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_crawler_expired_finalize_decl_void@
identifier F = crawler_expired_finalize;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_crawler_expired_finalize_decl_void@
F << remove_static_crawler_expired_finalize_decl_void.F;
P << remove_static_crawler_expired_finalize_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_crawler_expired_finalize_def@
type T;
identifier F = crawler_expired_finalize;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_crawler_expired_finalize_def@
F << extract_crawler_expired_finalize_def.F;
T << extract_crawler_expired_finalize_def.T;
P << extract_crawler_expired_finalize_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_crawler_expired_finalize_def_void@
identifier F = crawler_expired_finalize;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_crawler_expired_finalize_def_void@
F << extract_crawler_expired_finalize_def_void.F;
P << extract_crawler_expired_finalize_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_crawler_expired_finalize_decl@
type T;
identifier F = crawler_expired_finalize;
parameter list P;
@@
T F(P);

@script:python depends on extract_crawler_expired_finalize_decl@
F << extract_crawler_expired_finalize_decl.F;
T << extract_crawler_expired_finalize_decl.T;
P << extract_crawler_expired_finalize_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_crawler_expired_finalize_decl_void@
identifier F = crawler_expired_finalize;
parameter list P;
@@
void F(P);

@script:python depends on extract_crawler_expired_finalize_decl_void@
F << extract_crawler_expired_finalize_decl_void.F;
P << extract_crawler_expired_finalize_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: crawler_expired_init
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_crawler_expired_init_def@
type T;
identifier F = crawler_expired_init;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_crawler_expired_init_def@
F << remove_static_crawler_expired_init_def.F;
T << remove_static_crawler_expired_init_def.T;
P << remove_static_crawler_expired_init_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_crawler_expired_init_def_void@
identifier F = crawler_expired_init;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_crawler_expired_init_def_void@
F << remove_static_crawler_expired_init_def_void.F;
P << remove_static_crawler_expired_init_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_crawler_expired_init_decl@
type T;
identifier F = crawler_expired_init;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_crawler_expired_init_decl@
F << remove_static_crawler_expired_init_decl.F;
T << remove_static_crawler_expired_init_decl.T;
P << remove_static_crawler_expired_init_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_crawler_expired_init_decl_void@
identifier F = crawler_expired_init;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_crawler_expired_init_decl_void@
F << remove_static_crawler_expired_init_decl_void.F;
P << remove_static_crawler_expired_init_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_crawler_expired_init_def@
type T;
identifier F = crawler_expired_init;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_crawler_expired_init_def@
F << extract_crawler_expired_init_def.F;
T << extract_crawler_expired_init_def.T;
P << extract_crawler_expired_init_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_crawler_expired_init_def_void@
identifier F = crawler_expired_init;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_crawler_expired_init_def_void@
F << extract_crawler_expired_init_def_void.F;
P << extract_crawler_expired_init_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_crawler_expired_init_decl@
type T;
identifier F = crawler_expired_init;
parameter list P;
@@
T F(P);

@script:python depends on extract_crawler_expired_init_decl@
F << extract_crawler_expired_init_decl.F;
T << extract_crawler_expired_init_decl.T;
P << extract_crawler_expired_init_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_crawler_expired_init_decl_void@
identifier F = crawler_expired_init;
parameter list P;
@@
void F(P);

@script:python depends on extract_crawler_expired_init_decl_void@
F << extract_crawler_expired_init_decl_void.F;
P << extract_crawler_expired_init_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: crawler_metadump_eval
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_crawler_metadump_eval_def@
type T;
identifier F = crawler_metadump_eval;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_crawler_metadump_eval_def@
F << remove_static_crawler_metadump_eval_def.F;
T << remove_static_crawler_metadump_eval_def.T;
P << remove_static_crawler_metadump_eval_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_crawler_metadump_eval_def_void@
identifier F = crawler_metadump_eval;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_crawler_metadump_eval_def_void@
F << remove_static_crawler_metadump_eval_def_void.F;
P << remove_static_crawler_metadump_eval_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_crawler_metadump_eval_decl@
type T;
identifier F = crawler_metadump_eval;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_crawler_metadump_eval_decl@
F << remove_static_crawler_metadump_eval_decl.F;
T << remove_static_crawler_metadump_eval_decl.T;
P << remove_static_crawler_metadump_eval_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_crawler_metadump_eval_decl_void@
identifier F = crawler_metadump_eval;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_crawler_metadump_eval_decl_void@
F << remove_static_crawler_metadump_eval_decl_void.F;
P << remove_static_crawler_metadump_eval_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_crawler_metadump_eval_def@
type T;
identifier F = crawler_metadump_eval;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_crawler_metadump_eval_def@
F << extract_crawler_metadump_eval_def.F;
T << extract_crawler_metadump_eval_def.T;
P << extract_crawler_metadump_eval_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_crawler_metadump_eval_def_void@
identifier F = crawler_metadump_eval;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_crawler_metadump_eval_def_void@
F << extract_crawler_metadump_eval_def_void.F;
P << extract_crawler_metadump_eval_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_crawler_metadump_eval_decl@
type T;
identifier F = crawler_metadump_eval;
parameter list P;
@@
T F(P);

@script:python depends on extract_crawler_metadump_eval_decl@
F << extract_crawler_metadump_eval_decl.F;
T << extract_crawler_metadump_eval_decl.T;
P << extract_crawler_metadump_eval_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_crawler_metadump_eval_decl_void@
identifier F = crawler_metadump_eval;
parameter list P;
@@
void F(P);

@script:python depends on extract_crawler_metadump_eval_decl_void@
F << extract_crawler_metadump_eval_decl_void.F;
P << extract_crawler_metadump_eval_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: crawler_metadump_finalize
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_crawler_metadump_finalize_def@
type T;
identifier F = crawler_metadump_finalize;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_crawler_metadump_finalize_def@
F << remove_static_crawler_metadump_finalize_def.F;
T << remove_static_crawler_metadump_finalize_def.T;
P << remove_static_crawler_metadump_finalize_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_crawler_metadump_finalize_def_void@
identifier F = crawler_metadump_finalize;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_crawler_metadump_finalize_def_void@
F << remove_static_crawler_metadump_finalize_def_void.F;
P << remove_static_crawler_metadump_finalize_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_crawler_metadump_finalize_decl@
type T;
identifier F = crawler_metadump_finalize;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_crawler_metadump_finalize_decl@
F << remove_static_crawler_metadump_finalize_decl.F;
T << remove_static_crawler_metadump_finalize_decl.T;
P << remove_static_crawler_metadump_finalize_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_crawler_metadump_finalize_decl_void@
identifier F = crawler_metadump_finalize;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_crawler_metadump_finalize_decl_void@
F << remove_static_crawler_metadump_finalize_decl_void.F;
P << remove_static_crawler_metadump_finalize_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_crawler_metadump_finalize_def@
type T;
identifier F = crawler_metadump_finalize;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_crawler_metadump_finalize_def@
F << extract_crawler_metadump_finalize_def.F;
T << extract_crawler_metadump_finalize_def.T;
P << extract_crawler_metadump_finalize_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_crawler_metadump_finalize_def_void@
identifier F = crawler_metadump_finalize;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_crawler_metadump_finalize_def_void@
F << extract_crawler_metadump_finalize_def_void.F;
P << extract_crawler_metadump_finalize_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_crawler_metadump_finalize_decl@
type T;
identifier F = crawler_metadump_finalize;
parameter list P;
@@
T F(P);

@script:python depends on extract_crawler_metadump_finalize_decl@
F << extract_crawler_metadump_finalize_decl.F;
T << extract_crawler_metadump_finalize_decl.T;
P << extract_crawler_metadump_finalize_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_crawler_metadump_finalize_decl_void@
identifier F = crawler_metadump_finalize;
parameter list P;
@@
void F(P);

@script:python depends on extract_crawler_metadump_finalize_decl_void@
F << extract_crawler_metadump_finalize_decl_void.F;
P << extract_crawler_metadump_finalize_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: crawler_metadump_init
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_crawler_metadump_init_def@
type T;
identifier F = crawler_metadump_init;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_crawler_metadump_init_def@
F << remove_static_crawler_metadump_init_def.F;
T << remove_static_crawler_metadump_init_def.T;
P << remove_static_crawler_metadump_init_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_crawler_metadump_init_def_void@
identifier F = crawler_metadump_init;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_crawler_metadump_init_def_void@
F << remove_static_crawler_metadump_init_def_void.F;
P << remove_static_crawler_metadump_init_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_crawler_metadump_init_decl@
type T;
identifier F = crawler_metadump_init;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_crawler_metadump_init_decl@
F << remove_static_crawler_metadump_init_decl.F;
T << remove_static_crawler_metadump_init_decl.T;
P << remove_static_crawler_metadump_init_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_crawler_metadump_init_decl_void@
identifier F = crawler_metadump_init;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_crawler_metadump_init_decl_void@
F << remove_static_crawler_metadump_init_decl_void.F;
P << remove_static_crawler_metadump_init_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_crawler_metadump_init_def@
type T;
identifier F = crawler_metadump_init;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_crawler_metadump_init_def@
F << extract_crawler_metadump_init_def.F;
T << extract_crawler_metadump_init_def.T;
P << extract_crawler_metadump_init_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_crawler_metadump_init_def_void@
identifier F = crawler_metadump_init;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_crawler_metadump_init_def_void@
F << extract_crawler_metadump_init_def_void.F;
P << extract_crawler_metadump_init_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_crawler_metadump_init_decl@
type T;
identifier F = crawler_metadump_init;
parameter list P;
@@
T F(P);

@script:python depends on extract_crawler_metadump_init_decl@
F << extract_crawler_metadump_init_decl.F;
T << extract_crawler_metadump_init_decl.T;
P << extract_crawler_metadump_init_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_crawler_metadump_init_decl_void@
identifier F = crawler_metadump_init;
parameter list P;
@@
void F(P);

@script:python depends on extract_crawler_metadump_init_decl_void@
F << extract_crawler_metadump_init_decl_void.F;
P << extract_crawler_metadump_init_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: crawler_mgdump_eval
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_crawler_mgdump_eval_def@
type T;
identifier F = crawler_mgdump_eval;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_crawler_mgdump_eval_def@
F << remove_static_crawler_mgdump_eval_def.F;
T << remove_static_crawler_mgdump_eval_def.T;
P << remove_static_crawler_mgdump_eval_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_crawler_mgdump_eval_def_void@
identifier F = crawler_mgdump_eval;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_crawler_mgdump_eval_def_void@
F << remove_static_crawler_mgdump_eval_def_void.F;
P << remove_static_crawler_mgdump_eval_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_crawler_mgdump_eval_decl@
type T;
identifier F = crawler_mgdump_eval;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_crawler_mgdump_eval_decl@
F << remove_static_crawler_mgdump_eval_decl.F;
T << remove_static_crawler_mgdump_eval_decl.T;
P << remove_static_crawler_mgdump_eval_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_crawler_mgdump_eval_decl_void@
identifier F = crawler_mgdump_eval;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_crawler_mgdump_eval_decl_void@
F << remove_static_crawler_mgdump_eval_decl_void.F;
P << remove_static_crawler_mgdump_eval_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_crawler_mgdump_eval_def@
type T;
identifier F = crawler_mgdump_eval;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_crawler_mgdump_eval_def@
F << extract_crawler_mgdump_eval_def.F;
T << extract_crawler_mgdump_eval_def.T;
P << extract_crawler_mgdump_eval_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_crawler_mgdump_eval_def_void@
identifier F = crawler_mgdump_eval;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_crawler_mgdump_eval_def_void@
F << extract_crawler_mgdump_eval_def_void.F;
P << extract_crawler_mgdump_eval_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_crawler_mgdump_eval_decl@
type T;
identifier F = crawler_mgdump_eval;
parameter list P;
@@
T F(P);

@script:python depends on extract_crawler_mgdump_eval_decl@
F << extract_crawler_mgdump_eval_decl.F;
T << extract_crawler_mgdump_eval_decl.T;
P << extract_crawler_mgdump_eval_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_crawler_mgdump_eval_decl_void@
identifier F = crawler_mgdump_eval;
parameter list P;
@@
void F(P);

@script:python depends on extract_crawler_mgdump_eval_decl_void@
F << extract_crawler_mgdump_eval_decl_void.F;
P << extract_crawler_mgdump_eval_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: crawler_mgdump_finalize
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_crawler_mgdump_finalize_def@
type T;
identifier F = crawler_mgdump_finalize;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_crawler_mgdump_finalize_def@
F << remove_static_crawler_mgdump_finalize_def.F;
T << remove_static_crawler_mgdump_finalize_def.T;
P << remove_static_crawler_mgdump_finalize_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_crawler_mgdump_finalize_def_void@
identifier F = crawler_mgdump_finalize;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_crawler_mgdump_finalize_def_void@
F << remove_static_crawler_mgdump_finalize_def_void.F;
P << remove_static_crawler_mgdump_finalize_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_crawler_mgdump_finalize_decl@
type T;
identifier F = crawler_mgdump_finalize;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_crawler_mgdump_finalize_decl@
F << remove_static_crawler_mgdump_finalize_decl.F;
T << remove_static_crawler_mgdump_finalize_decl.T;
P << remove_static_crawler_mgdump_finalize_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_crawler_mgdump_finalize_decl_void@
identifier F = crawler_mgdump_finalize;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_crawler_mgdump_finalize_decl_void@
F << remove_static_crawler_mgdump_finalize_decl_void.F;
P << remove_static_crawler_mgdump_finalize_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_crawler_mgdump_finalize_def@
type T;
identifier F = crawler_mgdump_finalize;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_crawler_mgdump_finalize_def@
F << extract_crawler_mgdump_finalize_def.F;
T << extract_crawler_mgdump_finalize_def.T;
P << extract_crawler_mgdump_finalize_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_crawler_mgdump_finalize_def_void@
identifier F = crawler_mgdump_finalize;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_crawler_mgdump_finalize_def_void@
F << extract_crawler_mgdump_finalize_def_void.F;
P << extract_crawler_mgdump_finalize_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_crawler_mgdump_finalize_decl@
type T;
identifier F = crawler_mgdump_finalize;
parameter list P;
@@
T F(P);

@script:python depends on extract_crawler_mgdump_finalize_decl@
F << extract_crawler_mgdump_finalize_decl.F;
T << extract_crawler_mgdump_finalize_decl.T;
P << extract_crawler_mgdump_finalize_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_crawler_mgdump_finalize_decl_void@
identifier F = crawler_mgdump_finalize;
parameter list P;
@@
void F(P);

@script:python depends on extract_crawler_mgdump_finalize_decl_void@
F << extract_crawler_mgdump_finalize_decl_void.F;
P << extract_crawler_mgdump_finalize_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: crawler_mgdump_init
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_crawler_mgdump_init_def@
type T;
identifier F = crawler_mgdump_init;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_crawler_mgdump_init_def@
F << remove_static_crawler_mgdump_init_def.F;
T << remove_static_crawler_mgdump_init_def.T;
P << remove_static_crawler_mgdump_init_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_crawler_mgdump_init_def_void@
identifier F = crawler_mgdump_init;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_crawler_mgdump_init_def_void@
F << remove_static_crawler_mgdump_init_def_void.F;
P << remove_static_crawler_mgdump_init_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_crawler_mgdump_init_decl@
type T;
identifier F = crawler_mgdump_init;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_crawler_mgdump_init_decl@
F << remove_static_crawler_mgdump_init_decl.F;
T << remove_static_crawler_mgdump_init_decl.T;
P << remove_static_crawler_mgdump_init_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_crawler_mgdump_init_decl_void@
identifier F = crawler_mgdump_init;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_crawler_mgdump_init_decl_void@
F << remove_static_crawler_mgdump_init_decl_void.F;
P << remove_static_crawler_mgdump_init_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_crawler_mgdump_init_def@
type T;
identifier F = crawler_mgdump_init;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_crawler_mgdump_init_def@
F << extract_crawler_mgdump_init_def.F;
T << extract_crawler_mgdump_init_def.T;
P << extract_crawler_mgdump_init_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_crawler_mgdump_init_def_void@
identifier F = crawler_mgdump_init;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_crawler_mgdump_init_def_void@
F << extract_crawler_mgdump_init_def_void.F;
P << extract_crawler_mgdump_init_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_crawler_mgdump_init_decl@
type T;
identifier F = crawler_mgdump_init;
parameter list P;
@@
T F(P);

@script:python depends on extract_crawler_mgdump_init_decl@
F << extract_crawler_mgdump_init_decl.F;
T << extract_crawler_mgdump_init_decl.T;
P << extract_crawler_mgdump_init_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_crawler_mgdump_init_decl_void@
identifier F = crawler_mgdump_init;
parameter list P;
@@
void F(P);

@script:python depends on extract_crawler_mgdump_init_decl_void@
F << extract_crawler_mgdump_init_decl_void.F;
P << extract_crawler_mgdump_init_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: false
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_false_def@
type T;
identifier F = false;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_false_def@
F << remove_static_false_def.F;
T << remove_static_false_def.T;
P << remove_static_false_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_false_def_void@
identifier F = false;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_false_def_void@
F << remove_static_false_def_void.F;
P << remove_static_false_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_false_decl@
type T;
identifier F = false;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_false_decl@
F << remove_static_false_decl.F;
T << remove_static_false_decl.T;
P << remove_static_false_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_false_decl_void@
identifier F = false;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_false_decl_void@
F << remove_static_false_decl_void.F;
P << remove_static_false_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_false_def@
type T;
identifier F = false;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_false_def@
F << extract_false_def.F;
T << extract_false_def.T;
P << extract_false_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_false_def_void@
identifier F = false;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_false_def_void@
F << extract_false_def_void.F;
P << extract_false_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_false_decl@
type T;
identifier F = false;
parameter list P;
@@
T F(P);

@script:python depends on extract_false_decl@
F << extract_false_decl.F;
T << extract_false_decl.T;
P << extract_false_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_false_decl_void@
identifier F = false;
parameter list P;
@@
void F(P);

@script:python depends on extract_false_decl_void@
F << extract_false_decl_void.F;
P << extract_false_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: proxy_submit_cb
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_proxy_submit_cb_def@
type T;
identifier F = proxy_submit_cb;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_proxy_submit_cb_def@
F << remove_static_proxy_submit_cb_def.F;
T << remove_static_proxy_submit_cb_def.T;
P << remove_static_proxy_submit_cb_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_proxy_submit_cb_def_void@
identifier F = proxy_submit_cb;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_proxy_submit_cb_def_void@
F << remove_static_proxy_submit_cb_def_void.F;
P << remove_static_proxy_submit_cb_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_proxy_submit_cb_decl@
type T;
identifier F = proxy_submit_cb;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_proxy_submit_cb_decl@
F << remove_static_proxy_submit_cb_decl.F;
T << remove_static_proxy_submit_cb_decl.T;
P << remove_static_proxy_submit_cb_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_proxy_submit_cb_decl_void@
identifier F = proxy_submit_cb;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_proxy_submit_cb_decl_void@
F << remove_static_proxy_submit_cb_decl_void.F;
P << remove_static_proxy_submit_cb_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_proxy_submit_cb_def@
type T;
identifier F = proxy_submit_cb;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_proxy_submit_cb_def@
F << extract_proxy_submit_cb_def.F;
T << extract_proxy_submit_cb_def.T;
P << extract_proxy_submit_cb_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_proxy_submit_cb_def_void@
identifier F = proxy_submit_cb;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_proxy_submit_cb_def_void@
F << extract_proxy_submit_cb_def_void.F;
P << extract_proxy_submit_cb_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_proxy_submit_cb_decl@
type T;
identifier F = proxy_submit_cb;
parameter list P;
@@
T F(P);

@script:python depends on extract_proxy_submit_cb_decl@
F << extract_proxy_submit_cb_decl.F;
T << extract_proxy_submit_cb_decl.T;
P << extract_proxy_submit_cb_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_proxy_submit_cb_decl_void@
identifier F = proxy_submit_cb;
parameter list P;
@@
void F(P);

@script:python depends on extract_proxy_submit_cb_decl_void@
F << extract_proxy_submit_cb_decl_void.F;
P << extract_proxy_submit_cb_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: slab_automove_extstore_free
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_slab_automove_extstore_free_def@
type T;
identifier F = slab_automove_extstore_free;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_slab_automove_extstore_free_def@
F << remove_static_slab_automove_extstore_free_def.F;
T << remove_static_slab_automove_extstore_free_def.T;
P << remove_static_slab_automove_extstore_free_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_slab_automove_extstore_free_def_void@
identifier F = slab_automove_extstore_free;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_slab_automove_extstore_free_def_void@
F << remove_static_slab_automove_extstore_free_def_void.F;
P << remove_static_slab_automove_extstore_free_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_slab_automove_extstore_free_decl@
type T;
identifier F = slab_automove_extstore_free;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_slab_automove_extstore_free_decl@
F << remove_static_slab_automove_extstore_free_decl.F;
T << remove_static_slab_automove_extstore_free_decl.T;
P << remove_static_slab_automove_extstore_free_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_slab_automove_extstore_free_decl_void@
identifier F = slab_automove_extstore_free;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_slab_automove_extstore_free_decl_void@
F << remove_static_slab_automove_extstore_free_decl_void.F;
P << remove_static_slab_automove_extstore_free_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_slab_automove_extstore_free_def@
type T;
identifier F = slab_automove_extstore_free;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_slab_automove_extstore_free_def@
F << extract_slab_automove_extstore_free_def.F;
T << extract_slab_automove_extstore_free_def.T;
P << extract_slab_automove_extstore_free_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_slab_automove_extstore_free_def_void@
identifier F = slab_automove_extstore_free;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_slab_automove_extstore_free_def_void@
F << extract_slab_automove_extstore_free_def_void.F;
P << extract_slab_automove_extstore_free_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_slab_automove_extstore_free_decl@
type T;
identifier F = slab_automove_extstore_free;
parameter list P;
@@
T F(P);

@script:python depends on extract_slab_automove_extstore_free_decl@
F << extract_slab_automove_extstore_free_decl.F;
T << extract_slab_automove_extstore_free_decl.T;
P << extract_slab_automove_extstore_free_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_slab_automove_extstore_free_decl_void@
identifier F = slab_automove_extstore_free;
parameter list P;
@@
void F(P);

@script:python depends on extract_slab_automove_extstore_free_decl_void@
F << extract_slab_automove_extstore_free_decl_void.F;
P << extract_slab_automove_extstore_free_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: slab_automove_extstore_init
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_slab_automove_extstore_init_def@
type T;
identifier F = slab_automove_extstore_init;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_slab_automove_extstore_init_def@
F << remove_static_slab_automove_extstore_init_def.F;
T << remove_static_slab_automove_extstore_init_def.T;
P << remove_static_slab_automove_extstore_init_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_slab_automove_extstore_init_def_void@
identifier F = slab_automove_extstore_init;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_slab_automove_extstore_init_def_void@
F << remove_static_slab_automove_extstore_init_def_void.F;
P << remove_static_slab_automove_extstore_init_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_slab_automove_extstore_init_decl@
type T;
identifier F = slab_automove_extstore_init;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_slab_automove_extstore_init_decl@
F << remove_static_slab_automove_extstore_init_decl.F;
T << remove_static_slab_automove_extstore_init_decl.T;
P << remove_static_slab_automove_extstore_init_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_slab_automove_extstore_init_decl_void@
identifier F = slab_automove_extstore_init;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_slab_automove_extstore_init_decl_void@
F << remove_static_slab_automove_extstore_init_decl_void.F;
P << remove_static_slab_automove_extstore_init_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_slab_automove_extstore_init_def@
type T;
identifier F = slab_automove_extstore_init;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_slab_automove_extstore_init_def@
F << extract_slab_automove_extstore_init_def.F;
T << extract_slab_automove_extstore_init_def.T;
P << extract_slab_automove_extstore_init_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_slab_automove_extstore_init_def_void@
identifier F = slab_automove_extstore_init;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_slab_automove_extstore_init_def_void@
F << extract_slab_automove_extstore_init_def_void.F;
P << extract_slab_automove_extstore_init_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_slab_automove_extstore_init_decl@
type T;
identifier F = slab_automove_extstore_init;
parameter list P;
@@
T F(P);

@script:python depends on extract_slab_automove_extstore_init_decl@
F << extract_slab_automove_extstore_init_decl.F;
T << extract_slab_automove_extstore_init_decl.T;
P << extract_slab_automove_extstore_init_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_slab_automove_extstore_init_decl_void@
identifier F = slab_automove_extstore_init;
parameter list P;
@@
void F(P);

@script:python depends on extract_slab_automove_extstore_init_decl_void@
F << extract_slab_automove_extstore_init_decl_void.F;
P << extract_slab_automove_extstore_init_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: slab_automove_extstore_run
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_slab_automove_extstore_run_def@
type T;
identifier F = slab_automove_extstore_run;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_slab_automove_extstore_run_def@
F << remove_static_slab_automove_extstore_run_def.F;
T << remove_static_slab_automove_extstore_run_def.T;
P << remove_static_slab_automove_extstore_run_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_slab_automove_extstore_run_def_void@
identifier F = slab_automove_extstore_run;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_slab_automove_extstore_run_def_void@
F << remove_static_slab_automove_extstore_run_def_void.F;
P << remove_static_slab_automove_extstore_run_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_slab_automove_extstore_run_decl@
type T;
identifier F = slab_automove_extstore_run;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_slab_automove_extstore_run_decl@
F << remove_static_slab_automove_extstore_run_decl.F;
T << remove_static_slab_automove_extstore_run_decl.T;
P << remove_static_slab_automove_extstore_run_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_slab_automove_extstore_run_decl_void@
identifier F = slab_automove_extstore_run;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_slab_automove_extstore_run_decl_void@
F << remove_static_slab_automove_extstore_run_decl_void.F;
P << remove_static_slab_automove_extstore_run_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_slab_automove_extstore_run_def@
type T;
identifier F = slab_automove_extstore_run;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_slab_automove_extstore_run_def@
F << extract_slab_automove_extstore_run_def.F;
T << extract_slab_automove_extstore_run_def.T;
P << extract_slab_automove_extstore_run_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_slab_automove_extstore_run_def_void@
identifier F = slab_automove_extstore_run;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_slab_automove_extstore_run_def_void@
F << extract_slab_automove_extstore_run_def_void.F;
P << extract_slab_automove_extstore_run_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_slab_automove_extstore_run_decl@
type T;
identifier F = slab_automove_extstore_run;
parameter list P;
@@
T F(P);

@script:python depends on extract_slab_automove_extstore_run_decl@
F << extract_slab_automove_extstore_run_decl.F;
T << extract_slab_automove_extstore_run_decl.T;
P << extract_slab_automove_extstore_run_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_slab_automove_extstore_run_decl_void@
identifier F = slab_automove_extstore_run;
parameter list P;
@@
void F(P);

@script:python depends on extract_slab_automove_extstore_run_decl_void@
F << extract_slab_automove_extstore_run_decl_void.F;
P << extract_slab_automove_extstore_run_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: slab_automove_free
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_slab_automove_free_def@
type T;
identifier F = slab_automove_free;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_slab_automove_free_def@
F << remove_static_slab_automove_free_def.F;
T << remove_static_slab_automove_free_def.T;
P << remove_static_slab_automove_free_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_slab_automove_free_def_void@
identifier F = slab_automove_free;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_slab_automove_free_def_void@
F << remove_static_slab_automove_free_def_void.F;
P << remove_static_slab_automove_free_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_slab_automove_free_decl@
type T;
identifier F = slab_automove_free;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_slab_automove_free_decl@
F << remove_static_slab_automove_free_decl.F;
T << remove_static_slab_automove_free_decl.T;
P << remove_static_slab_automove_free_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_slab_automove_free_decl_void@
identifier F = slab_automove_free;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_slab_automove_free_decl_void@
F << remove_static_slab_automove_free_decl_void.F;
P << remove_static_slab_automove_free_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_slab_automove_free_def@
type T;
identifier F = slab_automove_free;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_slab_automove_free_def@
F << extract_slab_automove_free_def.F;
T << extract_slab_automove_free_def.T;
P << extract_slab_automove_free_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_slab_automove_free_def_void@
identifier F = slab_automove_free;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_slab_automove_free_def_void@
F << extract_slab_automove_free_def_void.F;
P << extract_slab_automove_free_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_slab_automove_free_decl@
type T;
identifier F = slab_automove_free;
parameter list P;
@@
T F(P);

@script:python depends on extract_slab_automove_free_decl@
F << extract_slab_automove_free_decl.F;
T << extract_slab_automove_free_decl.T;
P << extract_slab_automove_free_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_slab_automove_free_decl_void@
identifier F = slab_automove_free;
parameter list P;
@@
void F(P);

@script:python depends on extract_slab_automove_free_decl_void@
F << extract_slab_automove_free_decl_void.F;
P << extract_slab_automove_free_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: slab_automove_init
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_slab_automove_init_def@
type T;
identifier F = slab_automove_init;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_slab_automove_init_def@
F << remove_static_slab_automove_init_def.F;
T << remove_static_slab_automove_init_def.T;
P << remove_static_slab_automove_init_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_slab_automove_init_def_void@
identifier F = slab_automove_init;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_slab_automove_init_def_void@
F << remove_static_slab_automove_init_def_void.F;
P << remove_static_slab_automove_init_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_slab_automove_init_decl@
type T;
identifier F = slab_automove_init;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_slab_automove_init_decl@
F << remove_static_slab_automove_init_decl.F;
T << remove_static_slab_automove_init_decl.T;
P << remove_static_slab_automove_init_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_slab_automove_init_decl_void@
identifier F = slab_automove_init;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_slab_automove_init_decl_void@
F << remove_static_slab_automove_init_decl_void.F;
P << remove_static_slab_automove_init_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_slab_automove_init_def@
type T;
identifier F = slab_automove_init;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_slab_automove_init_def@
F << extract_slab_automove_init_def.F;
T << extract_slab_automove_init_def.T;
P << extract_slab_automove_init_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_slab_automove_init_def_void@
identifier F = slab_automove_init;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_slab_automove_init_def_void@
F << extract_slab_automove_init_def_void.F;
P << extract_slab_automove_init_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_slab_automove_init_decl@
type T;
identifier F = slab_automove_init;
parameter list P;
@@
T F(P);

@script:python depends on extract_slab_automove_init_decl@
F << extract_slab_automove_init_decl.F;
T << extract_slab_automove_init_decl.T;
P << extract_slab_automove_init_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_slab_automove_init_decl_void@
identifier F = slab_automove_init;
parameter list P;
@@
void F(P);

@script:python depends on extract_slab_automove_init_decl_void@
F << extract_slab_automove_init_decl_void.F;
P << extract_slab_automove_init_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: slab_automove_run
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_slab_automove_run_def@
type T;
identifier F = slab_automove_run;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_slab_automove_run_def@
F << remove_static_slab_automove_run_def.F;
T << remove_static_slab_automove_run_def.T;
P << remove_static_slab_automove_run_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_slab_automove_run_def_void@
identifier F = slab_automove_run;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_slab_automove_run_def_void@
F << remove_static_slab_automove_run_def_void.F;
P << remove_static_slab_automove_run_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_slab_automove_run_decl@
type T;
identifier F = slab_automove_run;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_slab_automove_run_decl@
F << remove_static_slab_automove_run_decl.F;
T << remove_static_slab_automove_run_decl.T;
P << remove_static_slab_automove_run_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_slab_automove_run_decl_void@
identifier F = slab_automove_run;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_slab_automove_run_decl_void@
F << remove_static_slab_automove_run_decl_void.F;
P << remove_static_slab_automove_run_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_slab_automove_run_def@
type T;
identifier F = slab_automove_run;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_slab_automove_run_def@
F << extract_slab_automove_run_def.F;
T << extract_slab_automove_run_def.T;
P << extract_slab_automove_run_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_slab_automove_run_def_void@
identifier F = slab_automove_run;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_slab_automove_run_def_void@
F << extract_slab_automove_run_def_void.F;
P << extract_slab_automove_run_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_slab_automove_run_decl@
type T;
identifier F = slab_automove_run;
parameter list P;
@@
T F(P);

@script:python depends on extract_slab_automove_run_decl@
F << extract_slab_automove_run_decl.F;
T << extract_slab_automove_run_decl.T;
P << extract_slab_automove_run_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_slab_automove_run_decl_void@
identifier F = slab_automove_run;
parameter list P;
@@
void F(P);

@script:python depends on extract_slab_automove_run_decl_void@
F << extract_slab_automove_run_decl_void.F;
P << extract_slab_automove_run_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: ssl_read
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_ssl_read_def@
type T;
identifier F = ssl_read;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_ssl_read_def@
F << remove_static_ssl_read_def.F;
T << remove_static_ssl_read_def.T;
P << remove_static_ssl_read_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_ssl_read_def_void@
identifier F = ssl_read;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_ssl_read_def_void@
F << remove_static_ssl_read_def_void.F;
P << remove_static_ssl_read_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_ssl_read_decl@
type T;
identifier F = ssl_read;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_ssl_read_decl@
F << remove_static_ssl_read_decl.F;
T << remove_static_ssl_read_decl.T;
P << remove_static_ssl_read_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_ssl_read_decl_void@
identifier F = ssl_read;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_ssl_read_decl_void@
F << remove_static_ssl_read_decl_void.F;
P << remove_static_ssl_read_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_ssl_read_def@
type T;
identifier F = ssl_read;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_ssl_read_def@
F << extract_ssl_read_def.F;
T << extract_ssl_read_def.T;
P << extract_ssl_read_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_ssl_read_def_void@
identifier F = ssl_read;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_ssl_read_def_void@
F << extract_ssl_read_def_void.F;
P << extract_ssl_read_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_ssl_read_decl@
type T;
identifier F = ssl_read;
parameter list P;
@@
T F(P);

@script:python depends on extract_ssl_read_decl@
F << extract_ssl_read_decl.F;
T << extract_ssl_read_decl.T;
P << extract_ssl_read_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_ssl_read_decl_void@
identifier F = ssl_read;
parameter list P;
@@
void F(P);

@script:python depends on extract_ssl_read_decl_void@
F << extract_ssl_read_decl_void.F;
P << extract_ssl_read_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: ssl_write
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_ssl_write_def@
type T;
identifier F = ssl_write;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_ssl_write_def@
F << remove_static_ssl_write_def.F;
T << remove_static_ssl_write_def.T;
P << remove_static_ssl_write_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_ssl_write_def_void@
identifier F = ssl_write;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_ssl_write_def_void@
F << remove_static_ssl_write_def_void.F;
P << remove_static_ssl_write_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_ssl_write_decl@
type T;
identifier F = ssl_write;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_ssl_write_decl@
F << remove_static_ssl_write_decl.F;
T << remove_static_ssl_write_decl.T;
P << remove_static_ssl_write_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_ssl_write_decl_void@
identifier F = ssl_write;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_ssl_write_decl_void@
F << remove_static_ssl_write_decl_void.F;
P << remove_static_ssl_write_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_ssl_write_def@
type T;
identifier F = ssl_write;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_ssl_write_def@
F << extract_ssl_write_def.F;
T << extract_ssl_write_def.T;
P << extract_ssl_write_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_ssl_write_def_void@
identifier F = ssl_write;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_ssl_write_def_void@
F << extract_ssl_write_def_void.F;
P << extract_ssl_write_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_ssl_write_decl@
type T;
identifier F = ssl_write;
parameter list P;
@@
T F(P);

@script:python depends on extract_ssl_write_decl@
F << extract_ssl_write_decl.F;
T << extract_ssl_write_decl.T;
P << extract_ssl_write_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_ssl_write_decl_void@
identifier F = ssl_write;
parameter list P;
@@
void F(P);

@script:python depends on extract_ssl_write_decl_void@
F << extract_ssl_write_decl_void.F;
P << extract_ssl_write_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: storage_submit_cb
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_storage_submit_cb_def@
type T;
identifier F = storage_submit_cb;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_storage_submit_cb_def@
F << remove_static_storage_submit_cb_def.F;
T << remove_static_storage_submit_cb_def.T;
P << remove_static_storage_submit_cb_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_storage_submit_cb_def_void@
identifier F = storage_submit_cb;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_storage_submit_cb_def_void@
F << remove_static_storage_submit_cb_def_void.F;
P << remove_static_storage_submit_cb_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_storage_submit_cb_decl@
type T;
identifier F = storage_submit_cb;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_storage_submit_cb_decl@
F << remove_static_storage_submit_cb_decl.F;
T << remove_static_storage_submit_cb_decl.T;
P << remove_static_storage_submit_cb_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_storage_submit_cb_decl_void@
identifier F = storage_submit_cb;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_storage_submit_cb_decl_void@
F << remove_static_storage_submit_cb_decl_void.F;
P << remove_static_storage_submit_cb_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_storage_submit_cb_def@
type T;
identifier F = storage_submit_cb;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_storage_submit_cb_def@
F << extract_storage_submit_cb_def.F;
T << extract_storage_submit_cb_def.T;
P << extract_storage_submit_cb_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_storage_submit_cb_def_void@
identifier F = storage_submit_cb;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_storage_submit_cb_def_void@
F << extract_storage_submit_cb_def_void.F;
P << extract_storage_submit_cb_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_storage_submit_cb_decl@
type T;
identifier F = storage_submit_cb;
parameter list P;
@@
T F(P);

@script:python depends on extract_storage_submit_cb_decl@
F << extract_storage_submit_cb_decl.F;
T << extract_storage_submit_cb_decl.T;
P << extract_storage_submit_cb_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_storage_submit_cb_decl_void@
identifier F = storage_submit_cb;
parameter list P;
@@
void F(P);

@script:python depends on extract_storage_submit_cb_decl_void@
F << extract_storage_submit_cb_decl_void.F;
P << extract_storage_submit_cb_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: tcp_read
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_tcp_read_def@
type T;
identifier F = tcp_read;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_tcp_read_def@
F << remove_static_tcp_read_def.F;
T << remove_static_tcp_read_def.T;
P << remove_static_tcp_read_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_tcp_read_def_void@
identifier F = tcp_read;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_tcp_read_def_void@
F << remove_static_tcp_read_def_void.F;
P << remove_static_tcp_read_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_tcp_read_decl@
type T;
identifier F = tcp_read;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_tcp_read_decl@
F << remove_static_tcp_read_decl.F;
T << remove_static_tcp_read_decl.T;
P << remove_static_tcp_read_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_tcp_read_decl_void@
identifier F = tcp_read;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_tcp_read_decl_void@
F << remove_static_tcp_read_decl_void.F;
P << remove_static_tcp_read_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_tcp_read_def@
type T;
identifier F = tcp_read;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_tcp_read_def@
F << extract_tcp_read_def.F;
T << extract_tcp_read_def.T;
P << extract_tcp_read_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_tcp_read_def_void@
identifier F = tcp_read;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_tcp_read_def_void@
F << extract_tcp_read_def_void.F;
P << extract_tcp_read_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_tcp_read_decl@
type T;
identifier F = tcp_read;
parameter list P;
@@
T F(P);

@script:python depends on extract_tcp_read_decl@
F << extract_tcp_read_decl.F;
T << extract_tcp_read_decl.T;
P << extract_tcp_read_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_tcp_read_decl_void@
identifier F = tcp_read;
parameter list P;
@@
void F(P);

@script:python depends on extract_tcp_read_decl_void@
F << extract_tcp_read_decl_void.F;
P << extract_tcp_read_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: tcp_sendmsg
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_tcp_sendmsg_def@
type T;
identifier F = tcp_sendmsg;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_tcp_sendmsg_def@
F << remove_static_tcp_sendmsg_def.F;
T << remove_static_tcp_sendmsg_def.T;
P << remove_static_tcp_sendmsg_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_tcp_sendmsg_def_void@
identifier F = tcp_sendmsg;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_tcp_sendmsg_def_void@
F << remove_static_tcp_sendmsg_def_void.F;
P << remove_static_tcp_sendmsg_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_tcp_sendmsg_decl@
type T;
identifier F = tcp_sendmsg;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_tcp_sendmsg_decl@
F << remove_static_tcp_sendmsg_decl.F;
T << remove_static_tcp_sendmsg_decl.T;
P << remove_static_tcp_sendmsg_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_tcp_sendmsg_decl_void@
identifier F = tcp_sendmsg;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_tcp_sendmsg_decl_void@
F << remove_static_tcp_sendmsg_decl_void.F;
P << remove_static_tcp_sendmsg_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_tcp_sendmsg_def@
type T;
identifier F = tcp_sendmsg;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_tcp_sendmsg_def@
F << extract_tcp_sendmsg_def.F;
T << extract_tcp_sendmsg_def.T;
P << extract_tcp_sendmsg_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_tcp_sendmsg_def_void@
identifier F = tcp_sendmsg;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_tcp_sendmsg_def_void@
F << extract_tcp_sendmsg_def_void.F;
P << extract_tcp_sendmsg_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_tcp_sendmsg_decl@
type T;
identifier F = tcp_sendmsg;
parameter list P;
@@
T F(P);

@script:python depends on extract_tcp_sendmsg_decl@
F << extract_tcp_sendmsg_decl.F;
T << extract_tcp_sendmsg_decl.T;
P << extract_tcp_sendmsg_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_tcp_sendmsg_decl_void@
identifier F = tcp_sendmsg;
parameter list P;
@@
void F(P);

@script:python depends on extract_tcp_sendmsg_decl_void@
F << extract_tcp_sendmsg_decl_void.F;
P << extract_tcp_sendmsg_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: tcp_write
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_tcp_write_def@
type T;
identifier F = tcp_write;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_tcp_write_def@
F << remove_static_tcp_write_def.F;
T << remove_static_tcp_write_def.T;
P << remove_static_tcp_write_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_tcp_write_def_void@
identifier F = tcp_write;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_tcp_write_def_void@
F << remove_static_tcp_write_def_void.F;
P << remove_static_tcp_write_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_tcp_write_decl@
type T;
identifier F = tcp_write;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_tcp_write_decl@
F << remove_static_tcp_write_decl.F;
T << remove_static_tcp_write_decl.T;
P << remove_static_tcp_write_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_tcp_write_decl_void@
identifier F = tcp_write;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_tcp_write_decl_void@
F << remove_static_tcp_write_decl_void.F;
P << remove_static_tcp_write_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_tcp_write_def@
type T;
identifier F = tcp_write;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_tcp_write_def@
F << extract_tcp_write_def.F;
T << extract_tcp_write_def.T;
P << extract_tcp_write_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_tcp_write_def_void@
identifier F = tcp_write;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_tcp_write_def_void@
F << extract_tcp_write_def_void.F;
P << extract_tcp_write_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_tcp_write_decl@
type T;
identifier F = tcp_write;
parameter list P;
@@
T F(P);

@script:python depends on extract_tcp_write_decl@
F << extract_tcp_write_decl.F;
T << extract_tcp_write_decl.T;
P << extract_tcp_write_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_tcp_write_decl_void@
identifier F = tcp_write;
parameter list P;
@@
void F(P);

@script:python depends on extract_tcp_write_decl_void@
F << extract_tcp_write_decl_void.F;
P << extract_tcp_write_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: thread_libevent_ionotify
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_thread_libevent_ionotify_def@
type T;
identifier F = thread_libevent_ionotify;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_thread_libevent_ionotify_def@
F << remove_static_thread_libevent_ionotify_def.F;
T << remove_static_thread_libevent_ionotify_def.T;
P << remove_static_thread_libevent_ionotify_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_thread_libevent_ionotify_def_void@
identifier F = thread_libevent_ionotify;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_thread_libevent_ionotify_def_void@
F << remove_static_thread_libevent_ionotify_def_void.F;
P << remove_static_thread_libevent_ionotify_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_thread_libevent_ionotify_decl@
type T;
identifier F = thread_libevent_ionotify;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_thread_libevent_ionotify_decl@
F << remove_static_thread_libevent_ionotify_decl.F;
T << remove_static_thread_libevent_ionotify_decl.T;
P << remove_static_thread_libevent_ionotify_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_thread_libevent_ionotify_decl_void@
identifier F = thread_libevent_ionotify;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_thread_libevent_ionotify_decl_void@
F << remove_static_thread_libevent_ionotify_decl_void.F;
P << remove_static_thread_libevent_ionotify_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_thread_libevent_ionotify_def@
type T;
identifier F = thread_libevent_ionotify;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_thread_libevent_ionotify_def@
F << extract_thread_libevent_ionotify_def.F;
T << extract_thread_libevent_ionotify_def.T;
P << extract_thread_libevent_ionotify_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_thread_libevent_ionotify_def_void@
identifier F = thread_libevent_ionotify;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_thread_libevent_ionotify_def_void@
F << extract_thread_libevent_ionotify_def_void.F;
P << extract_thread_libevent_ionotify_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_thread_libevent_ionotify_decl@
type T;
identifier F = thread_libevent_ionotify;
parameter list P;
@@
T F(P);

@script:python depends on extract_thread_libevent_ionotify_decl@
F << extract_thread_libevent_ionotify_decl.F;
T << extract_thread_libevent_ionotify_decl.T;
P << extract_thread_libevent_ionotify_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_thread_libevent_ionotify_decl_void@
identifier F = thread_libevent_ionotify;
parameter list P;
@@
void F(P);

@script:python depends on extract_thread_libevent_ionotify_decl_void@
F << extract_thread_libevent_ionotify_decl_void.F;
P << extract_thread_libevent_ionotify_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: thread_libevent_process
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_thread_libevent_process_def@
type T;
identifier F = thread_libevent_process;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_thread_libevent_process_def@
F << remove_static_thread_libevent_process_def.F;
T << remove_static_thread_libevent_process_def.T;
P << remove_static_thread_libevent_process_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_thread_libevent_process_def_void@
identifier F = thread_libevent_process;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_thread_libevent_process_def_void@
F << remove_static_thread_libevent_process_def_void.F;
P << remove_static_thread_libevent_process_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_thread_libevent_process_decl@
type T;
identifier F = thread_libevent_process;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_thread_libevent_process_decl@
F << remove_static_thread_libevent_process_decl.F;
T << remove_static_thread_libevent_process_decl.T;
P << remove_static_thread_libevent_process_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_thread_libevent_process_decl_void@
identifier F = thread_libevent_process;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_thread_libevent_process_decl_void@
F << remove_static_thread_libevent_process_decl_void.F;
P << remove_static_thread_libevent_process_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_thread_libevent_process_def@
type T;
identifier F = thread_libevent_process;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_thread_libevent_process_def@
F << extract_thread_libevent_process_def.F;
T << extract_thread_libevent_process_def.T;
P << extract_thread_libevent_process_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_thread_libevent_process_def_void@
identifier F = thread_libevent_process;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_thread_libevent_process_def_void@
F << extract_thread_libevent_process_def_void.F;
P << extract_thread_libevent_process_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_thread_libevent_process_decl@
type T;
identifier F = thread_libevent_process;
parameter list P;
@@
T F(P);

@script:python depends on extract_thread_libevent_process_decl@
F << extract_thread_libevent_process_decl.F;
T << extract_thread_libevent_process_decl.T;
P << extract_thread_libevent_process_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_thread_libevent_process_decl_void@
identifier F = thread_libevent_process;
parameter list P;
@@
void F(P);

@script:python depends on extract_thread_libevent_process_decl_void@
F << extract_thread_libevent_process_decl_void.F;
P << extract_thread_libevent_process_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: true
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_true_def@
type T;
identifier F = true;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_true_def@
F << remove_static_true_def.F;
T << remove_static_true_def.T;
P << remove_static_true_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_true_def_void@
identifier F = true;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_true_def_void@
F << remove_static_true_def_void.F;
P << remove_static_true_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_true_decl@
type T;
identifier F = true;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_true_decl@
F << remove_static_true_decl.F;
T << remove_static_true_decl.T;
P << remove_static_true_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_true_decl_void@
identifier F = true;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_true_decl_void@
F << remove_static_true_decl_void.F;
P << remove_static_true_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_true_def@
type T;
identifier F = true;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_true_def@
F << extract_true_def.F;
T << extract_true_def.T;
P << extract_true_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_true_def_void@
identifier F = true;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_true_def_void@
F << extract_true_def_void.F;
P << extract_true_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_true_decl@
type T;
identifier F = true;
parameter list P;
@@
T F(P);

@script:python depends on extract_true_decl@
F << extract_true_decl.F;
T << extract_true_decl.T;
P << extract_true_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_true_decl_void@
identifier F = true;
parameter list P;
@@
void F(P);

@script:python depends on extract_true_decl_void@
F << extract_true_decl_void.F;
P << extract_true_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: try_read_command_ascii
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_try_read_command_ascii_def@
type T;
identifier F = try_read_command_ascii;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_try_read_command_ascii_def@
F << remove_static_try_read_command_ascii_def.F;
T << remove_static_try_read_command_ascii_def.T;
P << remove_static_try_read_command_ascii_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_try_read_command_ascii_def_void@
identifier F = try_read_command_ascii;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_try_read_command_ascii_def_void@
F << remove_static_try_read_command_ascii_def_void.F;
P << remove_static_try_read_command_ascii_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_try_read_command_ascii_decl@
type T;
identifier F = try_read_command_ascii;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_try_read_command_ascii_decl@
F << remove_static_try_read_command_ascii_decl.F;
T << remove_static_try_read_command_ascii_decl.T;
P << remove_static_try_read_command_ascii_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_try_read_command_ascii_decl_void@
identifier F = try_read_command_ascii;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_try_read_command_ascii_decl_void@
F << remove_static_try_read_command_ascii_decl_void.F;
P << remove_static_try_read_command_ascii_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_try_read_command_ascii_def@
type T;
identifier F = try_read_command_ascii;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_try_read_command_ascii_def@
F << extract_try_read_command_ascii_def.F;
T << extract_try_read_command_ascii_def.T;
P << extract_try_read_command_ascii_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_try_read_command_ascii_def_void@
identifier F = try_read_command_ascii;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_try_read_command_ascii_def_void@
F << extract_try_read_command_ascii_def_void.F;
P << extract_try_read_command_ascii_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_try_read_command_ascii_decl@
type T;
identifier F = try_read_command_ascii;
parameter list P;
@@
T F(P);

@script:python depends on extract_try_read_command_ascii_decl@
F << extract_try_read_command_ascii_decl.F;
T << extract_try_read_command_ascii_decl.T;
P << extract_try_read_command_ascii_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_try_read_command_ascii_decl_void@
identifier F = try_read_command_ascii;
parameter list P;
@@
void F(P);

@script:python depends on extract_try_read_command_ascii_decl_void@
F << extract_try_read_command_ascii_decl_void.F;
P << extract_try_read_command_ascii_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: try_read_command_asciiauth
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_try_read_command_asciiauth_def@
type T;
identifier F = try_read_command_asciiauth;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_try_read_command_asciiauth_def@
F << remove_static_try_read_command_asciiauth_def.F;
T << remove_static_try_read_command_asciiauth_def.T;
P << remove_static_try_read_command_asciiauth_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_try_read_command_asciiauth_def_void@
identifier F = try_read_command_asciiauth;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_try_read_command_asciiauth_def_void@
F << remove_static_try_read_command_asciiauth_def_void.F;
P << remove_static_try_read_command_asciiauth_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_try_read_command_asciiauth_decl@
type T;
identifier F = try_read_command_asciiauth;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_try_read_command_asciiauth_decl@
F << remove_static_try_read_command_asciiauth_decl.F;
T << remove_static_try_read_command_asciiauth_decl.T;
P << remove_static_try_read_command_asciiauth_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_try_read_command_asciiauth_decl_void@
identifier F = try_read_command_asciiauth;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_try_read_command_asciiauth_decl_void@
F << remove_static_try_read_command_asciiauth_decl_void.F;
P << remove_static_try_read_command_asciiauth_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_try_read_command_asciiauth_def@
type T;
identifier F = try_read_command_asciiauth;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_try_read_command_asciiauth_def@
F << extract_try_read_command_asciiauth_def.F;
T << extract_try_read_command_asciiauth_def.T;
P << extract_try_read_command_asciiauth_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_try_read_command_asciiauth_def_void@
identifier F = try_read_command_asciiauth;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_try_read_command_asciiauth_def_void@
F << extract_try_read_command_asciiauth_def_void.F;
P << extract_try_read_command_asciiauth_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_try_read_command_asciiauth_decl@
type T;
identifier F = try_read_command_asciiauth;
parameter list P;
@@
T F(P);

@script:python depends on extract_try_read_command_asciiauth_decl@
F << extract_try_read_command_asciiauth_decl.F;
T << extract_try_read_command_asciiauth_decl.T;
P << extract_try_read_command_asciiauth_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_try_read_command_asciiauth_decl_void@
identifier F = try_read_command_asciiauth;
parameter list P;
@@
void F(P);

@script:python depends on extract_try_read_command_asciiauth_decl_void@
F << extract_try_read_command_asciiauth_decl_void.F;
P << extract_try_read_command_asciiauth_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: try_read_command_binary
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_try_read_command_binary_def@
type T;
identifier F = try_read_command_binary;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_try_read_command_binary_def@
F << remove_static_try_read_command_binary_def.F;
T << remove_static_try_read_command_binary_def.T;
P << remove_static_try_read_command_binary_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_try_read_command_binary_def_void@
identifier F = try_read_command_binary;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_try_read_command_binary_def_void@
F << remove_static_try_read_command_binary_def_void.F;
P << remove_static_try_read_command_binary_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_try_read_command_binary_decl@
type T;
identifier F = try_read_command_binary;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_try_read_command_binary_decl@
F << remove_static_try_read_command_binary_decl.F;
T << remove_static_try_read_command_binary_decl.T;
P << remove_static_try_read_command_binary_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_try_read_command_binary_decl_void@
identifier F = try_read_command_binary;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_try_read_command_binary_decl_void@
F << remove_static_try_read_command_binary_decl_void.F;
P << remove_static_try_read_command_binary_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_try_read_command_binary_def@
type T;
identifier F = try_read_command_binary;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_try_read_command_binary_def@
F << extract_try_read_command_binary_def.F;
T << extract_try_read_command_binary_def.T;
P << extract_try_read_command_binary_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_try_read_command_binary_def_void@
identifier F = try_read_command_binary;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_try_read_command_binary_def_void@
F << extract_try_read_command_binary_def_void.F;
P << extract_try_read_command_binary_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_try_read_command_binary_decl@
type T;
identifier F = try_read_command_binary;
parameter list P;
@@
T F(P);

@script:python depends on extract_try_read_command_binary_decl@
F << extract_try_read_command_binary_decl.F;
T << extract_try_read_command_binary_decl.T;
P << extract_try_read_command_binary_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_try_read_command_binary_decl_void@
identifier F = try_read_command_binary;
parameter list P;
@@
void F(P);

@script:python depends on extract_try_read_command_binary_decl_void@
F << extract_try_read_command_binary_decl_void.F;
P << extract_try_read_command_binary_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: try_read_command_negotiate
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_try_read_command_negotiate_def@
type T;
identifier F = try_read_command_negotiate;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_try_read_command_negotiate_def@
F << remove_static_try_read_command_negotiate_def.F;
T << remove_static_try_read_command_negotiate_def.T;
P << remove_static_try_read_command_negotiate_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_try_read_command_negotiate_def_void@
identifier F = try_read_command_negotiate;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_try_read_command_negotiate_def_void@
F << remove_static_try_read_command_negotiate_def_void.F;
P << remove_static_try_read_command_negotiate_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_try_read_command_negotiate_decl@
type T;
identifier F = try_read_command_negotiate;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_try_read_command_negotiate_decl@
F << remove_static_try_read_command_negotiate_decl.F;
T << remove_static_try_read_command_negotiate_decl.T;
P << remove_static_try_read_command_negotiate_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_try_read_command_negotiate_decl_void@
identifier F = try_read_command_negotiate;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_try_read_command_negotiate_decl_void@
F << remove_static_try_read_command_negotiate_decl_void.F;
P << remove_static_try_read_command_negotiate_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_try_read_command_negotiate_def@
type T;
identifier F = try_read_command_negotiate;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_try_read_command_negotiate_def@
F << extract_try_read_command_negotiate_def.F;
T << extract_try_read_command_negotiate_def.T;
P << extract_try_read_command_negotiate_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_try_read_command_negotiate_def_void@
identifier F = try_read_command_negotiate;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_try_read_command_negotiate_def_void@
F << extract_try_read_command_negotiate_def_void.F;
P << extract_try_read_command_negotiate_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_try_read_command_negotiate_decl@
type T;
identifier F = try_read_command_negotiate;
parameter list P;
@@
T F(P);

@script:python depends on extract_try_read_command_negotiate_decl@
F << extract_try_read_command_negotiate_decl.F;
T << extract_try_read_command_negotiate_decl.T;
P << extract_try_read_command_negotiate_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_try_read_command_negotiate_decl_void@
identifier F = try_read_command_negotiate;
parameter list P;
@@
void F(P);

@script:python depends on extract_try_read_command_negotiate_decl_void@
F << extract_try_read_command_negotiate_decl_void.F;
P << extract_try_read_command_negotiate_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: try_read_command_proxy
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_try_read_command_proxy_def@
type T;
identifier F = try_read_command_proxy;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_try_read_command_proxy_def@
F << remove_static_try_read_command_proxy_def.F;
T << remove_static_try_read_command_proxy_def.T;
P << remove_static_try_read_command_proxy_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_try_read_command_proxy_def_void@
identifier F = try_read_command_proxy;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_try_read_command_proxy_def_void@
F << remove_static_try_read_command_proxy_def_void.F;
P << remove_static_try_read_command_proxy_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_try_read_command_proxy_decl@
type T;
identifier F = try_read_command_proxy;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_try_read_command_proxy_decl@
F << remove_static_try_read_command_proxy_decl.F;
T << remove_static_try_read_command_proxy_decl.T;
P << remove_static_try_read_command_proxy_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_try_read_command_proxy_decl_void@
identifier F = try_read_command_proxy;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_try_read_command_proxy_decl_void@
F << remove_static_try_read_command_proxy_decl_void.F;
P << remove_static_try_read_command_proxy_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_try_read_command_proxy_def@
type T;
identifier F = try_read_command_proxy;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_try_read_command_proxy_def@
F << extract_try_read_command_proxy_def.F;
T << extract_try_read_command_proxy_def.T;
P << extract_try_read_command_proxy_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_try_read_command_proxy_def_void@
identifier F = try_read_command_proxy;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_try_read_command_proxy_def_void@
F << extract_try_read_command_proxy_def_void.F;
P << extract_try_read_command_proxy_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_try_read_command_proxy_decl@
type T;
identifier F = try_read_command_proxy;
parameter list P;
@@
T F(P);

@script:python depends on extract_try_read_command_proxy_decl@
F << extract_try_read_command_proxy_decl.F;
T << extract_try_read_command_proxy_decl.T;
P << extract_try_read_command_proxy_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_try_read_command_proxy_decl_void@
identifier F = try_read_command_proxy;
parameter list P;
@@
void F(P);

@script:python depends on extract_try_read_command_proxy_decl_void@
F << extract_try_read_command_proxy_decl_void.F;
P << extract_try_read_command_proxy_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: try_read_command_udp
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_try_read_command_udp_def@
type T;
identifier F = try_read_command_udp;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_try_read_command_udp_def@
F << remove_static_try_read_command_udp_def.F;
T << remove_static_try_read_command_udp_def.T;
P << remove_static_try_read_command_udp_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_try_read_command_udp_def_void@
identifier F = try_read_command_udp;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_try_read_command_udp_def_void@
F << remove_static_try_read_command_udp_def_void.F;
P << remove_static_try_read_command_udp_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_try_read_command_udp_decl@
type T;
identifier F = try_read_command_udp;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_try_read_command_udp_decl@
F << remove_static_try_read_command_udp_decl.F;
T << remove_static_try_read_command_udp_decl.T;
P << remove_static_try_read_command_udp_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_try_read_command_udp_decl_void@
identifier F = try_read_command_udp;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_try_read_command_udp_decl_void@
F << remove_static_try_read_command_udp_decl_void.F;
P << remove_static_try_read_command_udp_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_try_read_command_udp_def@
type T;
identifier F = try_read_command_udp;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_try_read_command_udp_def@
F << extract_try_read_command_udp_def.F;
T << extract_try_read_command_udp_def.T;
P << extract_try_read_command_udp_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_try_read_command_udp_def_void@
identifier F = try_read_command_udp;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_try_read_command_udp_def_void@
F << extract_try_read_command_udp_def_void.F;
P << extract_try_read_command_udp_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_try_read_command_udp_decl@
type T;
identifier F = try_read_command_udp;
parameter list P;
@@
T F(P);

@script:python depends on extract_try_read_command_udp_decl@
F << extract_try_read_command_udp_decl.F;
T << extract_try_read_command_udp_decl.T;
P << extract_try_read_command_udp_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_try_read_command_udp_decl_void@
identifier F = try_read_command_udp;
parameter list P;
@@
void F(P);

@script:python depends on extract_try_read_command_udp_decl_void@
F << extract_try_read_command_udp_decl_void.F;
P << extract_try_read_command_udp_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Consolidation Script
// ============================================================

@script:python@
@@
import os
import glob

print("\n>>> CONSOLIDATING FUNCTION DECLARATIONS")

target_functions = ["XXH3_accumulate_512", "XXH3_hashLong_128b_default", "XXH3_hashLong_128b_withSecret", "XXH3_hashLong_128b_withSeed", "XXH3_hashLong_64b_default", "XXH3_hashLong_64b_withSecret", "XXH3_hashLong_64b_withSeed", "XXH3_initCustomSecret", "XXH3_scrambleAcc", "_mc_meta_load_cb", "_mc_meta_save_cb", "_slabs_locked_cb", "append_stats", "crawler_expired_doneclass", "crawler_expired_eval", "crawler_expired_finalize", "crawler_expired_init", "crawler_metadump_eval", "crawler_metadump_finalize", "crawler_metadump_init", "crawler_mgdump_eval", "crawler_mgdump_finalize", "crawler_mgdump_init", "false", "proxy_submit_cb", "slab_automove_extstore_free", "slab_automove_extstore_init", "slab_automove_extstore_run", "slab_automove_free", "slab_automove_init", "slab_automove_run", "ssl_read", "ssl_write", "storage_submit_cb", "tcp_read", "tcp_sendmsg", "tcp_write", "thread_libevent_ionotify", "thread_libevent_process", "true", "try_read_command_ascii", "try_read_command_asciiauth", "try_read_command_binary", "try_read_command_negotiate", "try_read_command_proxy", "try_read_command_udp"]

def_files = glob.glob("definitions/*.txt")
if not def_files:
    print(">>> No function declarations found to consolidate")
else:
    print(">>> Found %d function declarations" % len(def_files))
    
    # Read all declarations
    declarations = {}
    for def_file in sorted(def_files):
        func_name = os.path.basename(def_file).replace('.txt', '')
        try:
            with open(def_file, 'r') as f:
                signature = f.read().strip()
            declarations[func_name] = signature
        except Exception as e:
            print(">>> [ERROR] Failed to read %s: %s" % (def_file, e))
    
    # Write consolidated header file
    header_path = "extracted_declarations.h"
    try:
        with open(header_path, 'w') as f:
            f.write("/* Extracted function declarations */\n")
            f.write("/* Generated by Coccinelle script */\n")
            f.write("/* Static keyword removed where applicable */\n\n")
            f.write("#ifndef EXTRACTED_DECLARATIONS_H\n")
            f.write("#define EXTRACTED_DECLARATIONS_H\n\n")
            
            # Write declarations in sorted order
            for func_name in sorted(declarations.keys()):
                f.write(declarations[func_name] + "\n")
            
            f.write("\n#endif /* EXTRACTED_DECLARATIONS_H */\n")
        
        print(">>> Successfully created header: %s" % header_path)
        print(">>> Total declarations extracted: %d" % len(declarations))
        
        # Report missing functions
        missing = [f for f in target_functions if f not in declarations]
        if missing:
            print(">>> Missing declarations: %d" % len(missing))
            for m in missing[:10]:
                print(">>>   - %s" % m)
            if len(missing) > 10:
                print(">>>   ... and %d more" % (len(missing) - 10))
            
    except Exception as e:
        print(">>> [ERROR] Failed to create header: %s" % e)

print(">>> Consolidation complete")

@finalize:python@
@@
print("\n>>> PROCESSING COMPLETE")
print(">>> Total target functions: 46")
print(">>> Successfully extracted: %d" % len(processed_functions))
print(">>> Individual declarations: definitions/*.txt")
print(">>> Consolidated header: extracted_declarations.h")
