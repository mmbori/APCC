//
// Coccinelle script to extract function declarations and remove 'static' keyword
//
// Generated by: 3_5_extract_fn_declarations.py
// Purpose: Extract function declarations from definitions, remove static keyword
//
// This script:
// 1. Finds function definitions and declarations
// 2. Removes static keyword if present
// 3. Extracts signatures as declaration form (with semicolon)
// 4. Saves to definitions/ folder and consolidates to header file
//
// Usage: spatch --sp-file extract_declarations.cocci --dir <source_directory> --in-place

// Shared Python functions
@initialize:python@
@@
import os
import re

# Track processed functions to avoid duplicates
processed_functions = set()

def clean_function_signature(signature):
    """Clean up function signature formatting"""
    if not signature:
        return signature
    
    # Normalize all whitespace
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Remove all spaces around asterisks first
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Add space before asterisk groups
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Clean up double spaces
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

def extract_and_save_signature(signature, func_name):
    """Extract and save function signature to file (skip if already processed)"""
    if func_name in processed_functions:
        return
    
    processed_functions.add(func_name)
    os.makedirs("definitions", exist_ok=True)
    clean_signature = clean_function_signature(signature)
    filepath = "definitions/" + func_name + ".txt"
    with open(filepath, "w") as f:
        f.write(clean_signature + "\n")
    print("[EXTRACTED] " + func_name)


// ============================================================
// Rules for function: aiff_close
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_aiff_close_def@
type T;
identifier F = aiff_close;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_aiff_close_def@
F << remove_static_aiff_close_def.F;
T << remove_static_aiff_close_def.T;
P << remove_static_aiff_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_aiff_close_def_void@
identifier F = aiff_close;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_aiff_close_def_void@
F << remove_static_aiff_close_def_void.F;
P << remove_static_aiff_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_aiff_close_decl@
type T;
identifier F = aiff_close;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_aiff_close_decl@
F << remove_static_aiff_close_decl.F;
T << remove_static_aiff_close_decl.T;
P << remove_static_aiff_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_aiff_close_decl_void@
identifier F = aiff_close;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_aiff_close_decl_void@
F << remove_static_aiff_close_decl_void.F;
P << remove_static_aiff_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_aiff_close_def@
type T;
identifier F = aiff_close;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_aiff_close_def@
F << extract_aiff_close_def.F;
T << extract_aiff_close_def.T;
P << extract_aiff_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_aiff_close_def_void@
identifier F = aiff_close;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_aiff_close_def_void@
F << extract_aiff_close_def_void.F;
P << extract_aiff_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_aiff_close_decl@
type T;
identifier F = aiff_close;
parameter list P;
@@
T F(P);

@script:python depends on extract_aiff_close_decl@
F << extract_aiff_close_decl.F;
T << extract_aiff_close_decl.T;
P << extract_aiff_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_aiff_close_decl_void@
identifier F = aiff_close;
parameter list P;
@@
void F(P);

@script:python depends on extract_aiff_close_decl_void@
F << extract_aiff_close_decl_void.F;
P << extract_aiff_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: aiff_command
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_aiff_command_def@
type T;
identifier F = aiff_command;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_aiff_command_def@
F << remove_static_aiff_command_def.F;
T << remove_static_aiff_command_def.T;
P << remove_static_aiff_command_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_aiff_command_def_void@
identifier F = aiff_command;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_aiff_command_def_void@
F << remove_static_aiff_command_def_void.F;
P << remove_static_aiff_command_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_aiff_command_decl@
type T;
identifier F = aiff_command;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_aiff_command_decl@
F << remove_static_aiff_command_decl.F;
T << remove_static_aiff_command_decl.T;
P << remove_static_aiff_command_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_aiff_command_decl_void@
identifier F = aiff_command;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_aiff_command_decl_void@
F << remove_static_aiff_command_decl_void.F;
P << remove_static_aiff_command_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_aiff_command_def@
type T;
identifier F = aiff_command;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_aiff_command_def@
F << extract_aiff_command_def.F;
T << extract_aiff_command_def.T;
P << extract_aiff_command_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_aiff_command_def_void@
identifier F = aiff_command;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_aiff_command_def_void@
F << extract_aiff_command_def_void.F;
P << extract_aiff_command_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_aiff_command_decl@
type T;
identifier F = aiff_command;
parameter list P;
@@
T F(P);

@script:python depends on extract_aiff_command_decl@
F << extract_aiff_command_decl.F;
T << extract_aiff_command_decl.T;
P << extract_aiff_command_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_aiff_command_decl_void@
identifier F = aiff_command;
parameter list P;
@@
void F(P);

@script:python depends on extract_aiff_command_decl_void@
F << extract_aiff_command_decl_void.F;
P << extract_aiff_command_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: aiff_get_chunk_data
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_aiff_get_chunk_data_def@
type T;
identifier F = aiff_get_chunk_data;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_aiff_get_chunk_data_def@
F << remove_static_aiff_get_chunk_data_def.F;
T << remove_static_aiff_get_chunk_data_def.T;
P << remove_static_aiff_get_chunk_data_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_aiff_get_chunk_data_def_void@
identifier F = aiff_get_chunk_data;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_aiff_get_chunk_data_def_void@
F << remove_static_aiff_get_chunk_data_def_void.F;
P << remove_static_aiff_get_chunk_data_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_aiff_get_chunk_data_decl@
type T;
identifier F = aiff_get_chunk_data;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_aiff_get_chunk_data_decl@
F << remove_static_aiff_get_chunk_data_decl.F;
T << remove_static_aiff_get_chunk_data_decl.T;
P << remove_static_aiff_get_chunk_data_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_aiff_get_chunk_data_decl_void@
identifier F = aiff_get_chunk_data;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_aiff_get_chunk_data_decl_void@
F << remove_static_aiff_get_chunk_data_decl_void.F;
P << remove_static_aiff_get_chunk_data_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_aiff_get_chunk_data_def@
type T;
identifier F = aiff_get_chunk_data;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_aiff_get_chunk_data_def@
F << extract_aiff_get_chunk_data_def.F;
T << extract_aiff_get_chunk_data_def.T;
P << extract_aiff_get_chunk_data_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_aiff_get_chunk_data_def_void@
identifier F = aiff_get_chunk_data;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_aiff_get_chunk_data_def_void@
F << extract_aiff_get_chunk_data_def_void.F;
P << extract_aiff_get_chunk_data_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_aiff_get_chunk_data_decl@
type T;
identifier F = aiff_get_chunk_data;
parameter list P;
@@
T F(P);

@script:python depends on extract_aiff_get_chunk_data_decl@
F << extract_aiff_get_chunk_data_decl.F;
T << extract_aiff_get_chunk_data_decl.T;
P << extract_aiff_get_chunk_data_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_aiff_get_chunk_data_decl_void@
identifier F = aiff_get_chunk_data;
parameter list P;
@@
void F(P);

@script:python depends on extract_aiff_get_chunk_data_decl_void@
F << extract_aiff_get_chunk_data_decl_void.F;
P << extract_aiff_get_chunk_data_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: aiff_get_chunk_size
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_aiff_get_chunk_size_def@
type T;
identifier F = aiff_get_chunk_size;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_aiff_get_chunk_size_def@
F << remove_static_aiff_get_chunk_size_def.F;
T << remove_static_aiff_get_chunk_size_def.T;
P << remove_static_aiff_get_chunk_size_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_aiff_get_chunk_size_def_void@
identifier F = aiff_get_chunk_size;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_aiff_get_chunk_size_def_void@
F << remove_static_aiff_get_chunk_size_def_void.F;
P << remove_static_aiff_get_chunk_size_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_aiff_get_chunk_size_decl@
type T;
identifier F = aiff_get_chunk_size;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_aiff_get_chunk_size_decl@
F << remove_static_aiff_get_chunk_size_decl.F;
T << remove_static_aiff_get_chunk_size_decl.T;
P << remove_static_aiff_get_chunk_size_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_aiff_get_chunk_size_decl_void@
identifier F = aiff_get_chunk_size;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_aiff_get_chunk_size_decl_void@
F << remove_static_aiff_get_chunk_size_decl_void.F;
P << remove_static_aiff_get_chunk_size_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_aiff_get_chunk_size_def@
type T;
identifier F = aiff_get_chunk_size;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_aiff_get_chunk_size_def@
F << extract_aiff_get_chunk_size_def.F;
T << extract_aiff_get_chunk_size_def.T;
P << extract_aiff_get_chunk_size_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_aiff_get_chunk_size_def_void@
identifier F = aiff_get_chunk_size;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_aiff_get_chunk_size_def_void@
F << extract_aiff_get_chunk_size_def_void.F;
P << extract_aiff_get_chunk_size_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_aiff_get_chunk_size_decl@
type T;
identifier F = aiff_get_chunk_size;
parameter list P;
@@
T F(P);

@script:python depends on extract_aiff_get_chunk_size_decl@
F << extract_aiff_get_chunk_size_decl.F;
T << extract_aiff_get_chunk_size_decl.T;
P << extract_aiff_get_chunk_size_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_aiff_get_chunk_size_decl_void@
identifier F = aiff_get_chunk_size;
parameter list P;
@@
void F(P);

@script:python depends on extract_aiff_get_chunk_size_decl_void@
F << extract_aiff_get_chunk_size_decl_void.F;
P << extract_aiff_get_chunk_size_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: aiff_ima_decode_block
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_aiff_ima_decode_block_def@
type T;
identifier F = aiff_ima_decode_block;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_aiff_ima_decode_block_def@
F << remove_static_aiff_ima_decode_block_def.F;
T << remove_static_aiff_ima_decode_block_def.T;
P << remove_static_aiff_ima_decode_block_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_aiff_ima_decode_block_def_void@
identifier F = aiff_ima_decode_block;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_aiff_ima_decode_block_def_void@
F << remove_static_aiff_ima_decode_block_def_void.F;
P << remove_static_aiff_ima_decode_block_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_aiff_ima_decode_block_decl@
type T;
identifier F = aiff_ima_decode_block;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_aiff_ima_decode_block_decl@
F << remove_static_aiff_ima_decode_block_decl.F;
T << remove_static_aiff_ima_decode_block_decl.T;
P << remove_static_aiff_ima_decode_block_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_aiff_ima_decode_block_decl_void@
identifier F = aiff_ima_decode_block;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_aiff_ima_decode_block_decl_void@
F << remove_static_aiff_ima_decode_block_decl_void.F;
P << remove_static_aiff_ima_decode_block_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_aiff_ima_decode_block_def@
type T;
identifier F = aiff_ima_decode_block;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_aiff_ima_decode_block_def@
F << extract_aiff_ima_decode_block_def.F;
T << extract_aiff_ima_decode_block_def.T;
P << extract_aiff_ima_decode_block_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_aiff_ima_decode_block_def_void@
identifier F = aiff_ima_decode_block;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_aiff_ima_decode_block_def_void@
F << extract_aiff_ima_decode_block_def_void.F;
P << extract_aiff_ima_decode_block_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_aiff_ima_decode_block_decl@
type T;
identifier F = aiff_ima_decode_block;
parameter list P;
@@
T F(P);

@script:python depends on extract_aiff_ima_decode_block_decl@
F << extract_aiff_ima_decode_block_decl.F;
T << extract_aiff_ima_decode_block_decl.T;
P << extract_aiff_ima_decode_block_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_aiff_ima_decode_block_decl_void@
identifier F = aiff_ima_decode_block;
parameter list P;
@@
void F(P);

@script:python depends on extract_aiff_ima_decode_block_decl_void@
F << extract_aiff_ima_decode_block_decl_void.F;
P << extract_aiff_ima_decode_block_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: aiff_ima_encode_block
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_aiff_ima_encode_block_def@
type T;
identifier F = aiff_ima_encode_block;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_aiff_ima_encode_block_def@
F << remove_static_aiff_ima_encode_block_def.F;
T << remove_static_aiff_ima_encode_block_def.T;
P << remove_static_aiff_ima_encode_block_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_aiff_ima_encode_block_def_void@
identifier F = aiff_ima_encode_block;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_aiff_ima_encode_block_def_void@
F << remove_static_aiff_ima_encode_block_def_void.F;
P << remove_static_aiff_ima_encode_block_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_aiff_ima_encode_block_decl@
type T;
identifier F = aiff_ima_encode_block;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_aiff_ima_encode_block_decl@
F << remove_static_aiff_ima_encode_block_decl.F;
T << remove_static_aiff_ima_encode_block_decl.T;
P << remove_static_aiff_ima_encode_block_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_aiff_ima_encode_block_decl_void@
identifier F = aiff_ima_encode_block;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_aiff_ima_encode_block_decl_void@
F << remove_static_aiff_ima_encode_block_decl_void.F;
P << remove_static_aiff_ima_encode_block_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_aiff_ima_encode_block_def@
type T;
identifier F = aiff_ima_encode_block;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_aiff_ima_encode_block_def@
F << extract_aiff_ima_encode_block_def.F;
T << extract_aiff_ima_encode_block_def.T;
P << extract_aiff_ima_encode_block_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_aiff_ima_encode_block_def_void@
identifier F = aiff_ima_encode_block;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_aiff_ima_encode_block_def_void@
F << extract_aiff_ima_encode_block_def_void.F;
P << extract_aiff_ima_encode_block_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_aiff_ima_encode_block_decl@
type T;
identifier F = aiff_ima_encode_block;
parameter list P;
@@
T F(P);

@script:python depends on extract_aiff_ima_encode_block_decl@
F << extract_aiff_ima_encode_block_decl.F;
T << extract_aiff_ima_encode_block_decl.T;
P << extract_aiff_ima_encode_block_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_aiff_ima_encode_block_decl_void@
identifier F = aiff_ima_encode_block;
parameter list P;
@@
void F(P);

@script:python depends on extract_aiff_ima_encode_block_decl_void@
F << extract_aiff_ima_encode_block_decl_void.F;
P << extract_aiff_ima_encode_block_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: aiff_ima_seek
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_aiff_ima_seek_def@
type T;
identifier F = aiff_ima_seek;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_aiff_ima_seek_def@
F << remove_static_aiff_ima_seek_def.F;
T << remove_static_aiff_ima_seek_def.T;
P << remove_static_aiff_ima_seek_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_aiff_ima_seek_def_void@
identifier F = aiff_ima_seek;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_aiff_ima_seek_def_void@
F << remove_static_aiff_ima_seek_def_void.F;
P << remove_static_aiff_ima_seek_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_aiff_ima_seek_decl@
type T;
identifier F = aiff_ima_seek;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_aiff_ima_seek_decl@
F << remove_static_aiff_ima_seek_decl.F;
T << remove_static_aiff_ima_seek_decl.T;
P << remove_static_aiff_ima_seek_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_aiff_ima_seek_decl_void@
identifier F = aiff_ima_seek;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_aiff_ima_seek_decl_void@
F << remove_static_aiff_ima_seek_decl_void.F;
P << remove_static_aiff_ima_seek_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_aiff_ima_seek_def@
type T;
identifier F = aiff_ima_seek;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_aiff_ima_seek_def@
F << extract_aiff_ima_seek_def.F;
T << extract_aiff_ima_seek_def.T;
P << extract_aiff_ima_seek_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_aiff_ima_seek_def_void@
identifier F = aiff_ima_seek;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_aiff_ima_seek_def_void@
F << extract_aiff_ima_seek_def_void.F;
P << extract_aiff_ima_seek_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_aiff_ima_seek_decl@
type T;
identifier F = aiff_ima_seek;
parameter list P;
@@
T F(P);

@script:python depends on extract_aiff_ima_seek_decl@
F << extract_aiff_ima_seek_decl.F;
T << extract_aiff_ima_seek_decl.T;
P << extract_aiff_ima_seek_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_aiff_ima_seek_decl_void@
identifier F = aiff_ima_seek;
parameter list P;
@@
void F(P);

@script:python depends on extract_aiff_ima_seek_decl_void@
F << extract_aiff_ima_seek_decl_void.F;
P << extract_aiff_ima_seek_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: aiff_next_chunk_iterator
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_aiff_next_chunk_iterator_def@
type T;
identifier F = aiff_next_chunk_iterator;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_aiff_next_chunk_iterator_def@
F << remove_static_aiff_next_chunk_iterator_def.F;
T << remove_static_aiff_next_chunk_iterator_def.T;
P << remove_static_aiff_next_chunk_iterator_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_aiff_next_chunk_iterator_def_void@
identifier F = aiff_next_chunk_iterator;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_aiff_next_chunk_iterator_def_void@
F << remove_static_aiff_next_chunk_iterator_def_void.F;
P << remove_static_aiff_next_chunk_iterator_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_aiff_next_chunk_iterator_decl@
type T;
identifier F = aiff_next_chunk_iterator;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_aiff_next_chunk_iterator_decl@
F << remove_static_aiff_next_chunk_iterator_decl.F;
T << remove_static_aiff_next_chunk_iterator_decl.T;
P << remove_static_aiff_next_chunk_iterator_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_aiff_next_chunk_iterator_decl_void@
identifier F = aiff_next_chunk_iterator;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_aiff_next_chunk_iterator_decl_void@
F << remove_static_aiff_next_chunk_iterator_decl_void.F;
P << remove_static_aiff_next_chunk_iterator_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_aiff_next_chunk_iterator_def@
type T;
identifier F = aiff_next_chunk_iterator;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_aiff_next_chunk_iterator_def@
F << extract_aiff_next_chunk_iterator_def.F;
T << extract_aiff_next_chunk_iterator_def.T;
P << extract_aiff_next_chunk_iterator_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_aiff_next_chunk_iterator_def_void@
identifier F = aiff_next_chunk_iterator;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_aiff_next_chunk_iterator_def_void@
F << extract_aiff_next_chunk_iterator_def_void.F;
P << extract_aiff_next_chunk_iterator_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_aiff_next_chunk_iterator_decl@
type T;
identifier F = aiff_next_chunk_iterator;
parameter list P;
@@
T F(P);

@script:python depends on extract_aiff_next_chunk_iterator_decl@
F << extract_aiff_next_chunk_iterator_decl.F;
T << extract_aiff_next_chunk_iterator_decl.T;
P << extract_aiff_next_chunk_iterator_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_aiff_next_chunk_iterator_decl_void@
identifier F = aiff_next_chunk_iterator;
parameter list P;
@@
void F(P);

@script:python depends on extract_aiff_next_chunk_iterator_decl_void@
F << extract_aiff_next_chunk_iterator_decl_void.F;
P << extract_aiff_next_chunk_iterator_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: aiff_set_chunk
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_aiff_set_chunk_def@
type T;
identifier F = aiff_set_chunk;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_aiff_set_chunk_def@
F << remove_static_aiff_set_chunk_def.F;
T << remove_static_aiff_set_chunk_def.T;
P << remove_static_aiff_set_chunk_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_aiff_set_chunk_def_void@
identifier F = aiff_set_chunk;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_aiff_set_chunk_def_void@
F << remove_static_aiff_set_chunk_def_void.F;
P << remove_static_aiff_set_chunk_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_aiff_set_chunk_decl@
type T;
identifier F = aiff_set_chunk;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_aiff_set_chunk_decl@
F << remove_static_aiff_set_chunk_decl.F;
T << remove_static_aiff_set_chunk_decl.T;
P << remove_static_aiff_set_chunk_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_aiff_set_chunk_decl_void@
identifier F = aiff_set_chunk;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_aiff_set_chunk_decl_void@
F << remove_static_aiff_set_chunk_decl_void.F;
P << remove_static_aiff_set_chunk_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_aiff_set_chunk_def@
type T;
identifier F = aiff_set_chunk;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_aiff_set_chunk_def@
F << extract_aiff_set_chunk_def.F;
T << extract_aiff_set_chunk_def.T;
P << extract_aiff_set_chunk_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_aiff_set_chunk_def_void@
identifier F = aiff_set_chunk;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_aiff_set_chunk_def_void@
F << extract_aiff_set_chunk_def_void.F;
P << extract_aiff_set_chunk_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_aiff_set_chunk_decl@
type T;
identifier F = aiff_set_chunk;
parameter list P;
@@
T F(P);

@script:python depends on extract_aiff_set_chunk_decl@
F << extract_aiff_set_chunk_decl.F;
T << extract_aiff_set_chunk_decl.T;
P << extract_aiff_set_chunk_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_aiff_set_chunk_decl_void@
identifier F = aiff_set_chunk;
parameter list P;
@@
void F(P);

@script:python depends on extract_aiff_set_chunk_decl_void@
F << extract_aiff_set_chunk_decl_void.F;
P << extract_aiff_set_chunk_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: aiff_write_header
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_aiff_write_header_def@
type T;
identifier F = aiff_write_header;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_aiff_write_header_def@
F << remove_static_aiff_write_header_def.F;
T << remove_static_aiff_write_header_def.T;
P << remove_static_aiff_write_header_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_aiff_write_header_def_void@
identifier F = aiff_write_header;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_aiff_write_header_def_void@
F << remove_static_aiff_write_header_def_void.F;
P << remove_static_aiff_write_header_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_aiff_write_header_decl@
type T;
identifier F = aiff_write_header;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_aiff_write_header_decl@
F << remove_static_aiff_write_header_decl.F;
T << remove_static_aiff_write_header_decl.T;
P << remove_static_aiff_write_header_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_aiff_write_header_decl_void@
identifier F = aiff_write_header;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_aiff_write_header_decl_void@
F << remove_static_aiff_write_header_decl_void.F;
P << remove_static_aiff_write_header_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_aiff_write_header_def@
type T;
identifier F = aiff_write_header;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_aiff_write_header_def@
F << extract_aiff_write_header_def.F;
T << extract_aiff_write_header_def.T;
P << extract_aiff_write_header_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_aiff_write_header_def_void@
identifier F = aiff_write_header;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_aiff_write_header_def_void@
F << extract_aiff_write_header_def_void.F;
P << extract_aiff_write_header_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_aiff_write_header_decl@
type T;
identifier F = aiff_write_header;
parameter list P;
@@
T F(P);

@script:python depends on extract_aiff_write_header_decl@
F << extract_aiff_write_header_decl.F;
T << extract_aiff_write_header_decl.T;
P << extract_aiff_write_header_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_aiff_write_header_decl_void@
identifier F = aiff_write_header;
parameter list P;
@@
void F(P);

@script:python depends on extract_aiff_write_header_decl_void@
F << extract_aiff_write_header_decl_void.F;
P << extract_aiff_write_header_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: alac_byterate
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_alac_byterate_def@
type T;
identifier F = alac_byterate;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_alac_byterate_def@
F << remove_static_alac_byterate_def.F;
T << remove_static_alac_byterate_def.T;
P << remove_static_alac_byterate_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_alac_byterate_def_void@
identifier F = alac_byterate;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_alac_byterate_def_void@
F << remove_static_alac_byterate_def_void.F;
P << remove_static_alac_byterate_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_alac_byterate_decl@
type T;
identifier F = alac_byterate;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_alac_byterate_decl@
F << remove_static_alac_byterate_decl.F;
T << remove_static_alac_byterate_decl.T;
P << remove_static_alac_byterate_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_alac_byterate_decl_void@
identifier F = alac_byterate;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_alac_byterate_decl_void@
F << remove_static_alac_byterate_decl_void.F;
P << remove_static_alac_byterate_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_alac_byterate_def@
type T;
identifier F = alac_byterate;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_alac_byterate_def@
F << extract_alac_byterate_def.F;
T << extract_alac_byterate_def.T;
P << extract_alac_byterate_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_alac_byterate_def_void@
identifier F = alac_byterate;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_alac_byterate_def_void@
F << extract_alac_byterate_def_void.F;
P << extract_alac_byterate_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_alac_byterate_decl@
type T;
identifier F = alac_byterate;
parameter list P;
@@
T F(P);

@script:python depends on extract_alac_byterate_decl@
F << extract_alac_byterate_decl.F;
T << extract_alac_byterate_decl.T;
P << extract_alac_byterate_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_alac_byterate_decl_void@
identifier F = alac_byterate;
parameter list P;
@@
void F(P);

@script:python depends on extract_alac_byterate_decl_void@
F << extract_alac_byterate_decl_void.F;
P << extract_alac_byterate_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: alac_close
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_alac_close_def@
type T;
identifier F = alac_close;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_alac_close_def@
F << remove_static_alac_close_def.F;
T << remove_static_alac_close_def.T;
P << remove_static_alac_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_alac_close_def_void@
identifier F = alac_close;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_alac_close_def_void@
F << remove_static_alac_close_def_void.F;
P << remove_static_alac_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_alac_close_decl@
type T;
identifier F = alac_close;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_alac_close_decl@
F << remove_static_alac_close_decl.F;
T << remove_static_alac_close_decl.T;
P << remove_static_alac_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_alac_close_decl_void@
identifier F = alac_close;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_alac_close_decl_void@
F << remove_static_alac_close_decl_void.F;
P << remove_static_alac_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_alac_close_def@
type T;
identifier F = alac_close;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_alac_close_def@
F << extract_alac_close_def.F;
T << extract_alac_close_def.T;
P << extract_alac_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_alac_close_def_void@
identifier F = alac_close;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_alac_close_def_void@
F << extract_alac_close_def_void.F;
P << extract_alac_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_alac_close_decl@
type T;
identifier F = alac_close;
parameter list P;
@@
T F(P);

@script:python depends on extract_alac_close_decl@
F << extract_alac_close_decl.F;
T << extract_alac_close_decl.T;
P << extract_alac_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_alac_close_decl_void@
identifier F = alac_close;
parameter list P;
@@
void F(P);

@script:python depends on extract_alac_close_decl_void@
F << extract_alac_close_decl_void.F;
P << extract_alac_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: alac_read_d
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_alac_read_d_def@
type T;
identifier F = alac_read_d;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_alac_read_d_def@
F << remove_static_alac_read_d_def.F;
T << remove_static_alac_read_d_def.T;
P << remove_static_alac_read_d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_alac_read_d_def_void@
identifier F = alac_read_d;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_alac_read_d_def_void@
F << remove_static_alac_read_d_def_void.F;
P << remove_static_alac_read_d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_alac_read_d_decl@
type T;
identifier F = alac_read_d;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_alac_read_d_decl@
F << remove_static_alac_read_d_decl.F;
T << remove_static_alac_read_d_decl.T;
P << remove_static_alac_read_d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_alac_read_d_decl_void@
identifier F = alac_read_d;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_alac_read_d_decl_void@
F << remove_static_alac_read_d_decl_void.F;
P << remove_static_alac_read_d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_alac_read_d_def@
type T;
identifier F = alac_read_d;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_alac_read_d_def@
F << extract_alac_read_d_def.F;
T << extract_alac_read_d_def.T;
P << extract_alac_read_d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_alac_read_d_def_void@
identifier F = alac_read_d;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_alac_read_d_def_void@
F << extract_alac_read_d_def_void.F;
P << extract_alac_read_d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_alac_read_d_decl@
type T;
identifier F = alac_read_d;
parameter list P;
@@
T F(P);

@script:python depends on extract_alac_read_d_decl@
F << extract_alac_read_d_decl.F;
T << extract_alac_read_d_decl.T;
P << extract_alac_read_d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_alac_read_d_decl_void@
identifier F = alac_read_d;
parameter list P;
@@
void F(P);

@script:python depends on extract_alac_read_d_decl_void@
F << extract_alac_read_d_decl_void.F;
P << extract_alac_read_d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: alac_read_f
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_alac_read_f_def@
type T;
identifier F = alac_read_f;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_alac_read_f_def@
F << remove_static_alac_read_f_def.F;
T << remove_static_alac_read_f_def.T;
P << remove_static_alac_read_f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_alac_read_f_def_void@
identifier F = alac_read_f;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_alac_read_f_def_void@
F << remove_static_alac_read_f_def_void.F;
P << remove_static_alac_read_f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_alac_read_f_decl@
type T;
identifier F = alac_read_f;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_alac_read_f_decl@
F << remove_static_alac_read_f_decl.F;
T << remove_static_alac_read_f_decl.T;
P << remove_static_alac_read_f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_alac_read_f_decl_void@
identifier F = alac_read_f;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_alac_read_f_decl_void@
F << remove_static_alac_read_f_decl_void.F;
P << remove_static_alac_read_f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_alac_read_f_def@
type T;
identifier F = alac_read_f;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_alac_read_f_def@
F << extract_alac_read_f_def.F;
T << extract_alac_read_f_def.T;
P << extract_alac_read_f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_alac_read_f_def_void@
identifier F = alac_read_f;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_alac_read_f_def_void@
F << extract_alac_read_f_def_void.F;
P << extract_alac_read_f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_alac_read_f_decl@
type T;
identifier F = alac_read_f;
parameter list P;
@@
T F(P);

@script:python depends on extract_alac_read_f_decl@
F << extract_alac_read_f_decl.F;
T << extract_alac_read_f_decl.T;
P << extract_alac_read_f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_alac_read_f_decl_void@
identifier F = alac_read_f;
parameter list P;
@@
void F(P);

@script:python depends on extract_alac_read_f_decl_void@
F << extract_alac_read_f_decl_void.F;
P << extract_alac_read_f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: alac_read_i
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_alac_read_i_def@
type T;
identifier F = alac_read_i;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_alac_read_i_def@
F << remove_static_alac_read_i_def.F;
T << remove_static_alac_read_i_def.T;
P << remove_static_alac_read_i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_alac_read_i_def_void@
identifier F = alac_read_i;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_alac_read_i_def_void@
F << remove_static_alac_read_i_def_void.F;
P << remove_static_alac_read_i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_alac_read_i_decl@
type T;
identifier F = alac_read_i;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_alac_read_i_decl@
F << remove_static_alac_read_i_decl.F;
T << remove_static_alac_read_i_decl.T;
P << remove_static_alac_read_i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_alac_read_i_decl_void@
identifier F = alac_read_i;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_alac_read_i_decl_void@
F << remove_static_alac_read_i_decl_void.F;
P << remove_static_alac_read_i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_alac_read_i_def@
type T;
identifier F = alac_read_i;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_alac_read_i_def@
F << extract_alac_read_i_def.F;
T << extract_alac_read_i_def.T;
P << extract_alac_read_i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_alac_read_i_def_void@
identifier F = alac_read_i;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_alac_read_i_def_void@
F << extract_alac_read_i_def_void.F;
P << extract_alac_read_i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_alac_read_i_decl@
type T;
identifier F = alac_read_i;
parameter list P;
@@
T F(P);

@script:python depends on extract_alac_read_i_decl@
F << extract_alac_read_i_decl.F;
T << extract_alac_read_i_decl.T;
P << extract_alac_read_i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_alac_read_i_decl_void@
identifier F = alac_read_i;
parameter list P;
@@
void F(P);

@script:python depends on extract_alac_read_i_decl_void@
F << extract_alac_read_i_decl_void.F;
P << extract_alac_read_i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: alac_read_s
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_alac_read_s_def@
type T;
identifier F = alac_read_s;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_alac_read_s_def@
F << remove_static_alac_read_s_def.F;
T << remove_static_alac_read_s_def.T;
P << remove_static_alac_read_s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_alac_read_s_def_void@
identifier F = alac_read_s;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_alac_read_s_def_void@
F << remove_static_alac_read_s_def_void.F;
P << remove_static_alac_read_s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_alac_read_s_decl@
type T;
identifier F = alac_read_s;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_alac_read_s_decl@
F << remove_static_alac_read_s_decl.F;
T << remove_static_alac_read_s_decl.T;
P << remove_static_alac_read_s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_alac_read_s_decl_void@
identifier F = alac_read_s;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_alac_read_s_decl_void@
F << remove_static_alac_read_s_decl_void.F;
P << remove_static_alac_read_s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_alac_read_s_def@
type T;
identifier F = alac_read_s;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_alac_read_s_def@
F << extract_alac_read_s_def.F;
T << extract_alac_read_s_def.T;
P << extract_alac_read_s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_alac_read_s_def_void@
identifier F = alac_read_s;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_alac_read_s_def_void@
F << extract_alac_read_s_def_void.F;
P << extract_alac_read_s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_alac_read_s_decl@
type T;
identifier F = alac_read_s;
parameter list P;
@@
T F(P);

@script:python depends on extract_alac_read_s_decl@
F << extract_alac_read_s_decl.F;
T << extract_alac_read_s_decl.T;
P << extract_alac_read_s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_alac_read_s_decl_void@
identifier F = alac_read_s;
parameter list P;
@@
void F(P);

@script:python depends on extract_alac_read_s_decl_void@
F << extract_alac_read_s_decl_void.F;
P << extract_alac_read_s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: alac_seek
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_alac_seek_def@
type T;
identifier F = alac_seek;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_alac_seek_def@
F << remove_static_alac_seek_def.F;
T << remove_static_alac_seek_def.T;
P << remove_static_alac_seek_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_alac_seek_def_void@
identifier F = alac_seek;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_alac_seek_def_void@
F << remove_static_alac_seek_def_void.F;
P << remove_static_alac_seek_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_alac_seek_decl@
type T;
identifier F = alac_seek;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_alac_seek_decl@
F << remove_static_alac_seek_decl.F;
T << remove_static_alac_seek_decl.T;
P << remove_static_alac_seek_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_alac_seek_decl_void@
identifier F = alac_seek;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_alac_seek_decl_void@
F << remove_static_alac_seek_decl_void.F;
P << remove_static_alac_seek_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_alac_seek_def@
type T;
identifier F = alac_seek;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_alac_seek_def@
F << extract_alac_seek_def.F;
T << extract_alac_seek_def.T;
P << extract_alac_seek_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_alac_seek_def_void@
identifier F = alac_seek;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_alac_seek_def_void@
F << extract_alac_seek_def_void.F;
P << extract_alac_seek_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_alac_seek_decl@
type T;
identifier F = alac_seek;
parameter list P;
@@
T F(P);

@script:python depends on extract_alac_seek_decl@
F << extract_alac_seek_decl.F;
T << extract_alac_seek_decl.T;
P << extract_alac_seek_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_alac_seek_decl_void@
identifier F = alac_seek;
parameter list P;
@@
void F(P);

@script:python depends on extract_alac_seek_decl_void@
F << extract_alac_seek_decl_void.F;
P << extract_alac_seek_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: alac_write_d
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_alac_write_d_def@
type T;
identifier F = alac_write_d;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_alac_write_d_def@
F << remove_static_alac_write_d_def.F;
T << remove_static_alac_write_d_def.T;
P << remove_static_alac_write_d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_alac_write_d_def_void@
identifier F = alac_write_d;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_alac_write_d_def_void@
F << remove_static_alac_write_d_def_void.F;
P << remove_static_alac_write_d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_alac_write_d_decl@
type T;
identifier F = alac_write_d;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_alac_write_d_decl@
F << remove_static_alac_write_d_decl.F;
T << remove_static_alac_write_d_decl.T;
P << remove_static_alac_write_d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_alac_write_d_decl_void@
identifier F = alac_write_d;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_alac_write_d_decl_void@
F << remove_static_alac_write_d_decl_void.F;
P << remove_static_alac_write_d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_alac_write_d_def@
type T;
identifier F = alac_write_d;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_alac_write_d_def@
F << extract_alac_write_d_def.F;
T << extract_alac_write_d_def.T;
P << extract_alac_write_d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_alac_write_d_def_void@
identifier F = alac_write_d;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_alac_write_d_def_void@
F << extract_alac_write_d_def_void.F;
P << extract_alac_write_d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_alac_write_d_decl@
type T;
identifier F = alac_write_d;
parameter list P;
@@
T F(P);

@script:python depends on extract_alac_write_d_decl@
F << extract_alac_write_d_decl.F;
T << extract_alac_write_d_decl.T;
P << extract_alac_write_d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_alac_write_d_decl_void@
identifier F = alac_write_d;
parameter list P;
@@
void F(P);

@script:python depends on extract_alac_write_d_decl_void@
F << extract_alac_write_d_decl_void.F;
P << extract_alac_write_d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: alac_write_f
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_alac_write_f_def@
type T;
identifier F = alac_write_f;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_alac_write_f_def@
F << remove_static_alac_write_f_def.F;
T << remove_static_alac_write_f_def.T;
P << remove_static_alac_write_f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_alac_write_f_def_void@
identifier F = alac_write_f;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_alac_write_f_def_void@
F << remove_static_alac_write_f_def_void.F;
P << remove_static_alac_write_f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_alac_write_f_decl@
type T;
identifier F = alac_write_f;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_alac_write_f_decl@
F << remove_static_alac_write_f_decl.F;
T << remove_static_alac_write_f_decl.T;
P << remove_static_alac_write_f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_alac_write_f_decl_void@
identifier F = alac_write_f;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_alac_write_f_decl_void@
F << remove_static_alac_write_f_decl_void.F;
P << remove_static_alac_write_f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_alac_write_f_def@
type T;
identifier F = alac_write_f;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_alac_write_f_def@
F << extract_alac_write_f_def.F;
T << extract_alac_write_f_def.T;
P << extract_alac_write_f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_alac_write_f_def_void@
identifier F = alac_write_f;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_alac_write_f_def_void@
F << extract_alac_write_f_def_void.F;
P << extract_alac_write_f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_alac_write_f_decl@
type T;
identifier F = alac_write_f;
parameter list P;
@@
T F(P);

@script:python depends on extract_alac_write_f_decl@
F << extract_alac_write_f_decl.F;
T << extract_alac_write_f_decl.T;
P << extract_alac_write_f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_alac_write_f_decl_void@
identifier F = alac_write_f;
parameter list P;
@@
void F(P);

@script:python depends on extract_alac_write_f_decl_void@
F << extract_alac_write_f_decl_void.F;
P << extract_alac_write_f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: alac_write_i
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_alac_write_i_def@
type T;
identifier F = alac_write_i;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_alac_write_i_def@
F << remove_static_alac_write_i_def.F;
T << remove_static_alac_write_i_def.T;
P << remove_static_alac_write_i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_alac_write_i_def_void@
identifier F = alac_write_i;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_alac_write_i_def_void@
F << remove_static_alac_write_i_def_void.F;
P << remove_static_alac_write_i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_alac_write_i_decl@
type T;
identifier F = alac_write_i;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_alac_write_i_decl@
F << remove_static_alac_write_i_decl.F;
T << remove_static_alac_write_i_decl.T;
P << remove_static_alac_write_i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_alac_write_i_decl_void@
identifier F = alac_write_i;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_alac_write_i_decl_void@
F << remove_static_alac_write_i_decl_void.F;
P << remove_static_alac_write_i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_alac_write_i_def@
type T;
identifier F = alac_write_i;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_alac_write_i_def@
F << extract_alac_write_i_def.F;
T << extract_alac_write_i_def.T;
P << extract_alac_write_i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_alac_write_i_def_void@
identifier F = alac_write_i;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_alac_write_i_def_void@
F << extract_alac_write_i_def_void.F;
P << extract_alac_write_i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_alac_write_i_decl@
type T;
identifier F = alac_write_i;
parameter list P;
@@
T F(P);

@script:python depends on extract_alac_write_i_decl@
F << extract_alac_write_i_decl.F;
T << extract_alac_write_i_decl.T;
P << extract_alac_write_i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_alac_write_i_decl_void@
identifier F = alac_write_i;
parameter list P;
@@
void F(P);

@script:python depends on extract_alac_write_i_decl_void@
F << extract_alac_write_i_decl_void.F;
P << extract_alac_write_i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: alac_write_s
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_alac_write_s_def@
type T;
identifier F = alac_write_s;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_alac_write_s_def@
F << remove_static_alac_write_s_def.F;
T << remove_static_alac_write_s_def.T;
P << remove_static_alac_write_s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_alac_write_s_def_void@
identifier F = alac_write_s;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_alac_write_s_def_void@
F << remove_static_alac_write_s_def_void.F;
P << remove_static_alac_write_s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_alac_write_s_decl@
type T;
identifier F = alac_write_s;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_alac_write_s_decl@
F << remove_static_alac_write_s_decl.F;
T << remove_static_alac_write_s_decl.T;
P << remove_static_alac_write_s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_alac_write_s_decl_void@
identifier F = alac_write_s;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_alac_write_s_decl_void@
F << remove_static_alac_write_s_decl_void.F;
P << remove_static_alac_write_s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_alac_write_s_def@
type T;
identifier F = alac_write_s;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_alac_write_s_def@
F << extract_alac_write_s_def.F;
T << extract_alac_write_s_def.T;
P << extract_alac_write_s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_alac_write_s_def_void@
identifier F = alac_write_s;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_alac_write_s_def_void@
F << extract_alac_write_s_def_void.F;
P << extract_alac_write_s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_alac_write_s_decl@
type T;
identifier F = alac_write_s;
parameter list P;
@@
T F(P);

@script:python depends on extract_alac_write_s_decl@
F << extract_alac_write_s_decl.F;
T << extract_alac_write_s_decl.T;
P << extract_alac_write_s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_alac_write_s_decl_void@
identifier F = alac_write_s;
parameter list P;
@@
void F(P);

@script:python depends on extract_alac_write_s_decl_void@
F << extract_alac_write_s_decl_void.F;
P << extract_alac_write_s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: alaw_read_alaw2d
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_alaw_read_alaw2d_def@
type T;
identifier F = alaw_read_alaw2d;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_alaw_read_alaw2d_def@
F << remove_static_alaw_read_alaw2d_def.F;
T << remove_static_alaw_read_alaw2d_def.T;
P << remove_static_alaw_read_alaw2d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_alaw_read_alaw2d_def_void@
identifier F = alaw_read_alaw2d;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_alaw_read_alaw2d_def_void@
F << remove_static_alaw_read_alaw2d_def_void.F;
P << remove_static_alaw_read_alaw2d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_alaw_read_alaw2d_decl@
type T;
identifier F = alaw_read_alaw2d;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_alaw_read_alaw2d_decl@
F << remove_static_alaw_read_alaw2d_decl.F;
T << remove_static_alaw_read_alaw2d_decl.T;
P << remove_static_alaw_read_alaw2d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_alaw_read_alaw2d_decl_void@
identifier F = alaw_read_alaw2d;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_alaw_read_alaw2d_decl_void@
F << remove_static_alaw_read_alaw2d_decl_void.F;
P << remove_static_alaw_read_alaw2d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_alaw_read_alaw2d_def@
type T;
identifier F = alaw_read_alaw2d;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_alaw_read_alaw2d_def@
F << extract_alaw_read_alaw2d_def.F;
T << extract_alaw_read_alaw2d_def.T;
P << extract_alaw_read_alaw2d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_alaw_read_alaw2d_def_void@
identifier F = alaw_read_alaw2d;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_alaw_read_alaw2d_def_void@
F << extract_alaw_read_alaw2d_def_void.F;
P << extract_alaw_read_alaw2d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_alaw_read_alaw2d_decl@
type T;
identifier F = alaw_read_alaw2d;
parameter list P;
@@
T F(P);

@script:python depends on extract_alaw_read_alaw2d_decl@
F << extract_alaw_read_alaw2d_decl.F;
T << extract_alaw_read_alaw2d_decl.T;
P << extract_alaw_read_alaw2d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_alaw_read_alaw2d_decl_void@
identifier F = alaw_read_alaw2d;
parameter list P;
@@
void F(P);

@script:python depends on extract_alaw_read_alaw2d_decl_void@
F << extract_alaw_read_alaw2d_decl_void.F;
P << extract_alaw_read_alaw2d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: alaw_read_alaw2f
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_alaw_read_alaw2f_def@
type T;
identifier F = alaw_read_alaw2f;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_alaw_read_alaw2f_def@
F << remove_static_alaw_read_alaw2f_def.F;
T << remove_static_alaw_read_alaw2f_def.T;
P << remove_static_alaw_read_alaw2f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_alaw_read_alaw2f_def_void@
identifier F = alaw_read_alaw2f;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_alaw_read_alaw2f_def_void@
F << remove_static_alaw_read_alaw2f_def_void.F;
P << remove_static_alaw_read_alaw2f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_alaw_read_alaw2f_decl@
type T;
identifier F = alaw_read_alaw2f;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_alaw_read_alaw2f_decl@
F << remove_static_alaw_read_alaw2f_decl.F;
T << remove_static_alaw_read_alaw2f_decl.T;
P << remove_static_alaw_read_alaw2f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_alaw_read_alaw2f_decl_void@
identifier F = alaw_read_alaw2f;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_alaw_read_alaw2f_decl_void@
F << remove_static_alaw_read_alaw2f_decl_void.F;
P << remove_static_alaw_read_alaw2f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_alaw_read_alaw2f_def@
type T;
identifier F = alaw_read_alaw2f;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_alaw_read_alaw2f_def@
F << extract_alaw_read_alaw2f_def.F;
T << extract_alaw_read_alaw2f_def.T;
P << extract_alaw_read_alaw2f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_alaw_read_alaw2f_def_void@
identifier F = alaw_read_alaw2f;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_alaw_read_alaw2f_def_void@
F << extract_alaw_read_alaw2f_def_void.F;
P << extract_alaw_read_alaw2f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_alaw_read_alaw2f_decl@
type T;
identifier F = alaw_read_alaw2f;
parameter list P;
@@
T F(P);

@script:python depends on extract_alaw_read_alaw2f_decl@
F << extract_alaw_read_alaw2f_decl.F;
T << extract_alaw_read_alaw2f_decl.T;
P << extract_alaw_read_alaw2f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_alaw_read_alaw2f_decl_void@
identifier F = alaw_read_alaw2f;
parameter list P;
@@
void F(P);

@script:python depends on extract_alaw_read_alaw2f_decl_void@
F << extract_alaw_read_alaw2f_decl_void.F;
P << extract_alaw_read_alaw2f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: alaw_read_alaw2i
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_alaw_read_alaw2i_def@
type T;
identifier F = alaw_read_alaw2i;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_alaw_read_alaw2i_def@
F << remove_static_alaw_read_alaw2i_def.F;
T << remove_static_alaw_read_alaw2i_def.T;
P << remove_static_alaw_read_alaw2i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_alaw_read_alaw2i_def_void@
identifier F = alaw_read_alaw2i;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_alaw_read_alaw2i_def_void@
F << remove_static_alaw_read_alaw2i_def_void.F;
P << remove_static_alaw_read_alaw2i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_alaw_read_alaw2i_decl@
type T;
identifier F = alaw_read_alaw2i;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_alaw_read_alaw2i_decl@
F << remove_static_alaw_read_alaw2i_decl.F;
T << remove_static_alaw_read_alaw2i_decl.T;
P << remove_static_alaw_read_alaw2i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_alaw_read_alaw2i_decl_void@
identifier F = alaw_read_alaw2i;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_alaw_read_alaw2i_decl_void@
F << remove_static_alaw_read_alaw2i_decl_void.F;
P << remove_static_alaw_read_alaw2i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_alaw_read_alaw2i_def@
type T;
identifier F = alaw_read_alaw2i;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_alaw_read_alaw2i_def@
F << extract_alaw_read_alaw2i_def.F;
T << extract_alaw_read_alaw2i_def.T;
P << extract_alaw_read_alaw2i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_alaw_read_alaw2i_def_void@
identifier F = alaw_read_alaw2i;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_alaw_read_alaw2i_def_void@
F << extract_alaw_read_alaw2i_def_void.F;
P << extract_alaw_read_alaw2i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_alaw_read_alaw2i_decl@
type T;
identifier F = alaw_read_alaw2i;
parameter list P;
@@
T F(P);

@script:python depends on extract_alaw_read_alaw2i_decl@
F << extract_alaw_read_alaw2i_decl.F;
T << extract_alaw_read_alaw2i_decl.T;
P << extract_alaw_read_alaw2i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_alaw_read_alaw2i_decl_void@
identifier F = alaw_read_alaw2i;
parameter list P;
@@
void F(P);

@script:python depends on extract_alaw_read_alaw2i_decl_void@
F << extract_alaw_read_alaw2i_decl_void.F;
P << extract_alaw_read_alaw2i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: alaw_read_alaw2s
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_alaw_read_alaw2s_def@
type T;
identifier F = alaw_read_alaw2s;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_alaw_read_alaw2s_def@
F << remove_static_alaw_read_alaw2s_def.F;
T << remove_static_alaw_read_alaw2s_def.T;
P << remove_static_alaw_read_alaw2s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_alaw_read_alaw2s_def_void@
identifier F = alaw_read_alaw2s;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_alaw_read_alaw2s_def_void@
F << remove_static_alaw_read_alaw2s_def_void.F;
P << remove_static_alaw_read_alaw2s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_alaw_read_alaw2s_decl@
type T;
identifier F = alaw_read_alaw2s;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_alaw_read_alaw2s_decl@
F << remove_static_alaw_read_alaw2s_decl.F;
T << remove_static_alaw_read_alaw2s_decl.T;
P << remove_static_alaw_read_alaw2s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_alaw_read_alaw2s_decl_void@
identifier F = alaw_read_alaw2s;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_alaw_read_alaw2s_decl_void@
F << remove_static_alaw_read_alaw2s_decl_void.F;
P << remove_static_alaw_read_alaw2s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_alaw_read_alaw2s_def@
type T;
identifier F = alaw_read_alaw2s;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_alaw_read_alaw2s_def@
F << extract_alaw_read_alaw2s_def.F;
T << extract_alaw_read_alaw2s_def.T;
P << extract_alaw_read_alaw2s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_alaw_read_alaw2s_def_void@
identifier F = alaw_read_alaw2s;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_alaw_read_alaw2s_def_void@
F << extract_alaw_read_alaw2s_def_void.F;
P << extract_alaw_read_alaw2s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_alaw_read_alaw2s_decl@
type T;
identifier F = alaw_read_alaw2s;
parameter list P;
@@
T F(P);

@script:python depends on extract_alaw_read_alaw2s_decl@
F << extract_alaw_read_alaw2s_decl.F;
T << extract_alaw_read_alaw2s_decl.T;
P << extract_alaw_read_alaw2s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_alaw_read_alaw2s_decl_void@
identifier F = alaw_read_alaw2s;
parameter list P;
@@
void F(P);

@script:python depends on extract_alaw_read_alaw2s_decl_void@
F << extract_alaw_read_alaw2s_decl_void.F;
P << extract_alaw_read_alaw2s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: alaw_write_d2alaw
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_alaw_write_d2alaw_def@
type T;
identifier F = alaw_write_d2alaw;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_alaw_write_d2alaw_def@
F << remove_static_alaw_write_d2alaw_def.F;
T << remove_static_alaw_write_d2alaw_def.T;
P << remove_static_alaw_write_d2alaw_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_alaw_write_d2alaw_def_void@
identifier F = alaw_write_d2alaw;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_alaw_write_d2alaw_def_void@
F << remove_static_alaw_write_d2alaw_def_void.F;
P << remove_static_alaw_write_d2alaw_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_alaw_write_d2alaw_decl@
type T;
identifier F = alaw_write_d2alaw;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_alaw_write_d2alaw_decl@
F << remove_static_alaw_write_d2alaw_decl.F;
T << remove_static_alaw_write_d2alaw_decl.T;
P << remove_static_alaw_write_d2alaw_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_alaw_write_d2alaw_decl_void@
identifier F = alaw_write_d2alaw;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_alaw_write_d2alaw_decl_void@
F << remove_static_alaw_write_d2alaw_decl_void.F;
P << remove_static_alaw_write_d2alaw_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_alaw_write_d2alaw_def@
type T;
identifier F = alaw_write_d2alaw;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_alaw_write_d2alaw_def@
F << extract_alaw_write_d2alaw_def.F;
T << extract_alaw_write_d2alaw_def.T;
P << extract_alaw_write_d2alaw_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_alaw_write_d2alaw_def_void@
identifier F = alaw_write_d2alaw;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_alaw_write_d2alaw_def_void@
F << extract_alaw_write_d2alaw_def_void.F;
P << extract_alaw_write_d2alaw_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_alaw_write_d2alaw_decl@
type T;
identifier F = alaw_write_d2alaw;
parameter list P;
@@
T F(P);

@script:python depends on extract_alaw_write_d2alaw_decl@
F << extract_alaw_write_d2alaw_decl.F;
T << extract_alaw_write_d2alaw_decl.T;
P << extract_alaw_write_d2alaw_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_alaw_write_d2alaw_decl_void@
identifier F = alaw_write_d2alaw;
parameter list P;
@@
void F(P);

@script:python depends on extract_alaw_write_d2alaw_decl_void@
F << extract_alaw_write_d2alaw_decl_void.F;
P << extract_alaw_write_d2alaw_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: alaw_write_f2alaw
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_alaw_write_f2alaw_def@
type T;
identifier F = alaw_write_f2alaw;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_alaw_write_f2alaw_def@
F << remove_static_alaw_write_f2alaw_def.F;
T << remove_static_alaw_write_f2alaw_def.T;
P << remove_static_alaw_write_f2alaw_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_alaw_write_f2alaw_def_void@
identifier F = alaw_write_f2alaw;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_alaw_write_f2alaw_def_void@
F << remove_static_alaw_write_f2alaw_def_void.F;
P << remove_static_alaw_write_f2alaw_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_alaw_write_f2alaw_decl@
type T;
identifier F = alaw_write_f2alaw;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_alaw_write_f2alaw_decl@
F << remove_static_alaw_write_f2alaw_decl.F;
T << remove_static_alaw_write_f2alaw_decl.T;
P << remove_static_alaw_write_f2alaw_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_alaw_write_f2alaw_decl_void@
identifier F = alaw_write_f2alaw;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_alaw_write_f2alaw_decl_void@
F << remove_static_alaw_write_f2alaw_decl_void.F;
P << remove_static_alaw_write_f2alaw_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_alaw_write_f2alaw_def@
type T;
identifier F = alaw_write_f2alaw;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_alaw_write_f2alaw_def@
F << extract_alaw_write_f2alaw_def.F;
T << extract_alaw_write_f2alaw_def.T;
P << extract_alaw_write_f2alaw_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_alaw_write_f2alaw_def_void@
identifier F = alaw_write_f2alaw;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_alaw_write_f2alaw_def_void@
F << extract_alaw_write_f2alaw_def_void.F;
P << extract_alaw_write_f2alaw_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_alaw_write_f2alaw_decl@
type T;
identifier F = alaw_write_f2alaw;
parameter list P;
@@
T F(P);

@script:python depends on extract_alaw_write_f2alaw_decl@
F << extract_alaw_write_f2alaw_decl.F;
T << extract_alaw_write_f2alaw_decl.T;
P << extract_alaw_write_f2alaw_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_alaw_write_f2alaw_decl_void@
identifier F = alaw_write_f2alaw;
parameter list P;
@@
void F(P);

@script:python depends on extract_alaw_write_f2alaw_decl_void@
F << extract_alaw_write_f2alaw_decl_void.F;
P << extract_alaw_write_f2alaw_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: alaw_write_i2alaw
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_alaw_write_i2alaw_def@
type T;
identifier F = alaw_write_i2alaw;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_alaw_write_i2alaw_def@
F << remove_static_alaw_write_i2alaw_def.F;
T << remove_static_alaw_write_i2alaw_def.T;
P << remove_static_alaw_write_i2alaw_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_alaw_write_i2alaw_def_void@
identifier F = alaw_write_i2alaw;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_alaw_write_i2alaw_def_void@
F << remove_static_alaw_write_i2alaw_def_void.F;
P << remove_static_alaw_write_i2alaw_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_alaw_write_i2alaw_decl@
type T;
identifier F = alaw_write_i2alaw;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_alaw_write_i2alaw_decl@
F << remove_static_alaw_write_i2alaw_decl.F;
T << remove_static_alaw_write_i2alaw_decl.T;
P << remove_static_alaw_write_i2alaw_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_alaw_write_i2alaw_decl_void@
identifier F = alaw_write_i2alaw;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_alaw_write_i2alaw_decl_void@
F << remove_static_alaw_write_i2alaw_decl_void.F;
P << remove_static_alaw_write_i2alaw_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_alaw_write_i2alaw_def@
type T;
identifier F = alaw_write_i2alaw;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_alaw_write_i2alaw_def@
F << extract_alaw_write_i2alaw_def.F;
T << extract_alaw_write_i2alaw_def.T;
P << extract_alaw_write_i2alaw_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_alaw_write_i2alaw_def_void@
identifier F = alaw_write_i2alaw;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_alaw_write_i2alaw_def_void@
F << extract_alaw_write_i2alaw_def_void.F;
P << extract_alaw_write_i2alaw_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_alaw_write_i2alaw_decl@
type T;
identifier F = alaw_write_i2alaw;
parameter list P;
@@
T F(P);

@script:python depends on extract_alaw_write_i2alaw_decl@
F << extract_alaw_write_i2alaw_decl.F;
T << extract_alaw_write_i2alaw_decl.T;
P << extract_alaw_write_i2alaw_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_alaw_write_i2alaw_decl_void@
identifier F = alaw_write_i2alaw;
parameter list P;
@@
void F(P);

@script:python depends on extract_alaw_write_i2alaw_decl_void@
F << extract_alaw_write_i2alaw_decl_void.F;
P << extract_alaw_write_i2alaw_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: alaw_write_s2alaw
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_alaw_write_s2alaw_def@
type T;
identifier F = alaw_write_s2alaw;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_alaw_write_s2alaw_def@
F << remove_static_alaw_write_s2alaw_def.F;
T << remove_static_alaw_write_s2alaw_def.T;
P << remove_static_alaw_write_s2alaw_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_alaw_write_s2alaw_def_void@
identifier F = alaw_write_s2alaw;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_alaw_write_s2alaw_def_void@
F << remove_static_alaw_write_s2alaw_def_void.F;
P << remove_static_alaw_write_s2alaw_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_alaw_write_s2alaw_decl@
type T;
identifier F = alaw_write_s2alaw;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_alaw_write_s2alaw_decl@
F << remove_static_alaw_write_s2alaw_decl.F;
T << remove_static_alaw_write_s2alaw_decl.T;
P << remove_static_alaw_write_s2alaw_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_alaw_write_s2alaw_decl_void@
identifier F = alaw_write_s2alaw;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_alaw_write_s2alaw_decl_void@
F << remove_static_alaw_write_s2alaw_decl_void.F;
P << remove_static_alaw_write_s2alaw_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_alaw_write_s2alaw_def@
type T;
identifier F = alaw_write_s2alaw;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_alaw_write_s2alaw_def@
F << extract_alaw_write_s2alaw_def.F;
T << extract_alaw_write_s2alaw_def.T;
P << extract_alaw_write_s2alaw_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_alaw_write_s2alaw_def_void@
identifier F = alaw_write_s2alaw;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_alaw_write_s2alaw_def_void@
F << extract_alaw_write_s2alaw_def_void.F;
P << extract_alaw_write_s2alaw_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_alaw_write_s2alaw_decl@
type T;
identifier F = alaw_write_s2alaw;
parameter list P;
@@
T F(P);

@script:python depends on extract_alaw_write_s2alaw_decl@
F << extract_alaw_write_s2alaw_decl.F;
T << extract_alaw_write_s2alaw_decl.T;
P << extract_alaw_write_s2alaw_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_alaw_write_s2alaw_decl_void@
identifier F = alaw_write_s2alaw;
parameter list P;
@@
void F(P);

@script:python depends on extract_alaw_write_s2alaw_decl_void@
F << extract_alaw_write_s2alaw_decl_void.F;
P << extract_alaw_write_s2alaw_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: au_close
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_au_close_def@
type T;
identifier F = au_close;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_au_close_def@
F << remove_static_au_close_def.F;
T << remove_static_au_close_def.T;
P << remove_static_au_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_au_close_def_void@
identifier F = au_close;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_au_close_def_void@
F << remove_static_au_close_def_void.F;
P << remove_static_au_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_au_close_decl@
type T;
identifier F = au_close;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_au_close_decl@
F << remove_static_au_close_decl.F;
T << remove_static_au_close_decl.T;
P << remove_static_au_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_au_close_decl_void@
identifier F = au_close;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_au_close_decl_void@
F << remove_static_au_close_decl_void.F;
P << remove_static_au_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_au_close_def@
type T;
identifier F = au_close;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_au_close_def@
F << extract_au_close_def.F;
T << extract_au_close_def.T;
P << extract_au_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_au_close_def_void@
identifier F = au_close;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_au_close_def_void@
F << extract_au_close_def_void.F;
P << extract_au_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_au_close_decl@
type T;
identifier F = au_close;
parameter list P;
@@
T F(P);

@script:python depends on extract_au_close_decl@
F << extract_au_close_decl.F;
T << extract_au_close_decl.T;
P << extract_au_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_au_close_decl_void@
identifier F = au_close;
parameter list P;
@@
void F(P);

@script:python depends on extract_au_close_decl_void@
F << extract_au_close_decl_void.F;
P << extract_au_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: au_write_header
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_au_write_header_def@
type T;
identifier F = au_write_header;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_au_write_header_def@
F << remove_static_au_write_header_def.F;
T << remove_static_au_write_header_def.T;
P << remove_static_au_write_header_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_au_write_header_def_void@
identifier F = au_write_header;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_au_write_header_def_void@
F << remove_static_au_write_header_def_void.F;
P << remove_static_au_write_header_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_au_write_header_decl@
type T;
identifier F = au_write_header;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_au_write_header_decl@
F << remove_static_au_write_header_decl.F;
T << remove_static_au_write_header_decl.T;
P << remove_static_au_write_header_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_au_write_header_decl_void@
identifier F = au_write_header;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_au_write_header_decl_void@
F << remove_static_au_write_header_decl_void.F;
P << remove_static_au_write_header_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_au_write_header_def@
type T;
identifier F = au_write_header;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_au_write_header_def@
F << extract_au_write_header_def.F;
T << extract_au_write_header_def.T;
P << extract_au_write_header_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_au_write_header_def_void@
identifier F = au_write_header;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_au_write_header_def_void@
F << extract_au_write_header_def_void.F;
P << extract_au_write_header_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_au_write_header_decl@
type T;
identifier F = au_write_header;
parameter list P;
@@
T F(P);

@script:python depends on extract_au_write_header_decl@
F << extract_au_write_header_decl.F;
T << extract_au_write_header_decl.T;
P << extract_au_write_header_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_au_write_header_decl_void@
identifier F = au_write_header;
parameter list P;
@@
void F(P);

@script:python depends on extract_au_write_header_decl_void@
F << extract_au_write_header_decl_void.F;
P << extract_au_write_header_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: avr_close
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_avr_close_def@
type T;
identifier F = avr_close;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_avr_close_def@
F << remove_static_avr_close_def.F;
T << remove_static_avr_close_def.T;
P << remove_static_avr_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_avr_close_def_void@
identifier F = avr_close;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_avr_close_def_void@
F << remove_static_avr_close_def_void.F;
P << remove_static_avr_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_avr_close_decl@
type T;
identifier F = avr_close;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_avr_close_decl@
F << remove_static_avr_close_decl.F;
T << remove_static_avr_close_decl.T;
P << remove_static_avr_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_avr_close_decl_void@
identifier F = avr_close;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_avr_close_decl_void@
F << remove_static_avr_close_decl_void.F;
P << remove_static_avr_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_avr_close_def@
type T;
identifier F = avr_close;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_avr_close_def@
F << extract_avr_close_def.F;
T << extract_avr_close_def.T;
P << extract_avr_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_avr_close_def_void@
identifier F = avr_close;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_avr_close_def_void@
F << extract_avr_close_def_void.F;
P << extract_avr_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_avr_close_decl@
type T;
identifier F = avr_close;
parameter list P;
@@
T F(P);

@script:python depends on extract_avr_close_decl@
F << extract_avr_close_decl.F;
T << extract_avr_close_decl.T;
P << extract_avr_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_avr_close_decl_void@
identifier F = avr_close;
parameter list P;
@@
void F(P);

@script:python depends on extract_avr_close_decl_void@
F << extract_avr_close_decl_void.F;
P << extract_avr_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: avr_write_header
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_avr_write_header_def@
type T;
identifier F = avr_write_header;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_avr_write_header_def@
F << remove_static_avr_write_header_def.F;
T << remove_static_avr_write_header_def.T;
P << remove_static_avr_write_header_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_avr_write_header_def_void@
identifier F = avr_write_header;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_avr_write_header_def_void@
F << remove_static_avr_write_header_def_void.F;
P << remove_static_avr_write_header_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_avr_write_header_decl@
type T;
identifier F = avr_write_header;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_avr_write_header_decl@
F << remove_static_avr_write_header_decl.F;
T << remove_static_avr_write_header_decl.T;
P << remove_static_avr_write_header_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_avr_write_header_decl_void@
identifier F = avr_write_header;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_avr_write_header_decl_void@
F << remove_static_avr_write_header_decl_void.F;
P << remove_static_avr_write_header_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_avr_write_header_def@
type T;
identifier F = avr_write_header;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_avr_write_header_def@
F << extract_avr_write_header_def.F;
T << extract_avr_write_header_def.T;
P << extract_avr_write_header_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_avr_write_header_def_void@
identifier F = avr_write_header;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_avr_write_header_def_void@
F << extract_avr_write_header_def_void.F;
P << extract_avr_write_header_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_avr_write_header_decl@
type T;
identifier F = avr_write_header;
parameter list P;
@@
T F(P);

@script:python depends on extract_avr_write_header_decl@
F << extract_avr_write_header_decl.F;
T << extract_avr_write_header_decl.T;
P << extract_avr_write_header_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_avr_write_header_decl_void@
identifier F = avr_write_header;
parameter list P;
@@
void F(P);

@script:python depends on extract_avr_write_header_decl_void@
F << extract_avr_write_header_decl_void.F;
P << extract_avr_write_header_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: caf_close
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_caf_close_def@
type T;
identifier F = caf_close;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_caf_close_def@
F << remove_static_caf_close_def.F;
T << remove_static_caf_close_def.T;
P << remove_static_caf_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_caf_close_def_void@
identifier F = caf_close;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_caf_close_def_void@
F << remove_static_caf_close_def_void.F;
P << remove_static_caf_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_caf_close_decl@
type T;
identifier F = caf_close;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_caf_close_decl@
F << remove_static_caf_close_decl.F;
T << remove_static_caf_close_decl.T;
P << remove_static_caf_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_caf_close_decl_void@
identifier F = caf_close;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_caf_close_decl_void@
F << remove_static_caf_close_decl_void.F;
P << remove_static_caf_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_caf_close_def@
type T;
identifier F = caf_close;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_caf_close_def@
F << extract_caf_close_def.F;
T << extract_caf_close_def.T;
P << extract_caf_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_caf_close_def_void@
identifier F = caf_close;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_caf_close_def_void@
F << extract_caf_close_def_void.F;
P << extract_caf_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_caf_close_decl@
type T;
identifier F = caf_close;
parameter list P;
@@
T F(P);

@script:python depends on extract_caf_close_decl@
F << extract_caf_close_decl.F;
T << extract_caf_close_decl.T;
P << extract_caf_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_caf_close_decl_void@
identifier F = caf_close;
parameter list P;
@@
void F(P);

@script:python depends on extract_caf_close_decl_void@
F << extract_caf_close_decl_void.F;
P << extract_caf_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: caf_command
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_caf_command_def@
type T;
identifier F = caf_command;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_caf_command_def@
F << remove_static_caf_command_def.F;
T << remove_static_caf_command_def.T;
P << remove_static_caf_command_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_caf_command_def_void@
identifier F = caf_command;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_caf_command_def_void@
F << remove_static_caf_command_def_void.F;
P << remove_static_caf_command_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_caf_command_decl@
type T;
identifier F = caf_command;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_caf_command_decl@
F << remove_static_caf_command_decl.F;
T << remove_static_caf_command_decl.T;
P << remove_static_caf_command_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_caf_command_decl_void@
identifier F = caf_command;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_caf_command_decl_void@
F << remove_static_caf_command_decl_void.F;
P << remove_static_caf_command_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_caf_command_def@
type T;
identifier F = caf_command;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_caf_command_def@
F << extract_caf_command_def.F;
T << extract_caf_command_def.T;
P << extract_caf_command_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_caf_command_def_void@
identifier F = caf_command;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_caf_command_def_void@
F << extract_caf_command_def_void.F;
P << extract_caf_command_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_caf_command_decl@
type T;
identifier F = caf_command;
parameter list P;
@@
T F(P);

@script:python depends on extract_caf_command_decl@
F << extract_caf_command_decl.F;
T << extract_caf_command_decl.T;
P << extract_caf_command_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_caf_command_decl_void@
identifier F = caf_command;
parameter list P;
@@
void F(P);

@script:python depends on extract_caf_command_decl_void@
F << extract_caf_command_decl_void.F;
P << extract_caf_command_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: caf_get_chunk_data
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_caf_get_chunk_data_def@
type T;
identifier F = caf_get_chunk_data;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_caf_get_chunk_data_def@
F << remove_static_caf_get_chunk_data_def.F;
T << remove_static_caf_get_chunk_data_def.T;
P << remove_static_caf_get_chunk_data_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_caf_get_chunk_data_def_void@
identifier F = caf_get_chunk_data;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_caf_get_chunk_data_def_void@
F << remove_static_caf_get_chunk_data_def_void.F;
P << remove_static_caf_get_chunk_data_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_caf_get_chunk_data_decl@
type T;
identifier F = caf_get_chunk_data;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_caf_get_chunk_data_decl@
F << remove_static_caf_get_chunk_data_decl.F;
T << remove_static_caf_get_chunk_data_decl.T;
P << remove_static_caf_get_chunk_data_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_caf_get_chunk_data_decl_void@
identifier F = caf_get_chunk_data;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_caf_get_chunk_data_decl_void@
F << remove_static_caf_get_chunk_data_decl_void.F;
P << remove_static_caf_get_chunk_data_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_caf_get_chunk_data_def@
type T;
identifier F = caf_get_chunk_data;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_caf_get_chunk_data_def@
F << extract_caf_get_chunk_data_def.F;
T << extract_caf_get_chunk_data_def.T;
P << extract_caf_get_chunk_data_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_caf_get_chunk_data_def_void@
identifier F = caf_get_chunk_data;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_caf_get_chunk_data_def_void@
F << extract_caf_get_chunk_data_def_void.F;
P << extract_caf_get_chunk_data_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_caf_get_chunk_data_decl@
type T;
identifier F = caf_get_chunk_data;
parameter list P;
@@
T F(P);

@script:python depends on extract_caf_get_chunk_data_decl@
F << extract_caf_get_chunk_data_decl.F;
T << extract_caf_get_chunk_data_decl.T;
P << extract_caf_get_chunk_data_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_caf_get_chunk_data_decl_void@
identifier F = caf_get_chunk_data;
parameter list P;
@@
void F(P);

@script:python depends on extract_caf_get_chunk_data_decl_void@
F << extract_caf_get_chunk_data_decl_void.F;
P << extract_caf_get_chunk_data_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: caf_get_chunk_size
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_caf_get_chunk_size_def@
type T;
identifier F = caf_get_chunk_size;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_caf_get_chunk_size_def@
F << remove_static_caf_get_chunk_size_def.F;
T << remove_static_caf_get_chunk_size_def.T;
P << remove_static_caf_get_chunk_size_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_caf_get_chunk_size_def_void@
identifier F = caf_get_chunk_size;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_caf_get_chunk_size_def_void@
F << remove_static_caf_get_chunk_size_def_void.F;
P << remove_static_caf_get_chunk_size_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_caf_get_chunk_size_decl@
type T;
identifier F = caf_get_chunk_size;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_caf_get_chunk_size_decl@
F << remove_static_caf_get_chunk_size_decl.F;
T << remove_static_caf_get_chunk_size_decl.T;
P << remove_static_caf_get_chunk_size_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_caf_get_chunk_size_decl_void@
identifier F = caf_get_chunk_size;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_caf_get_chunk_size_decl_void@
F << remove_static_caf_get_chunk_size_decl_void.F;
P << remove_static_caf_get_chunk_size_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_caf_get_chunk_size_def@
type T;
identifier F = caf_get_chunk_size;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_caf_get_chunk_size_def@
F << extract_caf_get_chunk_size_def.F;
T << extract_caf_get_chunk_size_def.T;
P << extract_caf_get_chunk_size_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_caf_get_chunk_size_def_void@
identifier F = caf_get_chunk_size;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_caf_get_chunk_size_def_void@
F << extract_caf_get_chunk_size_def_void.F;
P << extract_caf_get_chunk_size_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_caf_get_chunk_size_decl@
type T;
identifier F = caf_get_chunk_size;
parameter list P;
@@
T F(P);

@script:python depends on extract_caf_get_chunk_size_decl@
F << extract_caf_get_chunk_size_decl.F;
T << extract_caf_get_chunk_size_decl.T;
P << extract_caf_get_chunk_size_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_caf_get_chunk_size_decl_void@
identifier F = caf_get_chunk_size;
parameter list P;
@@
void F(P);

@script:python depends on extract_caf_get_chunk_size_decl_void@
F << extract_caf_get_chunk_size_decl_void.F;
P << extract_caf_get_chunk_size_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: caf_next_chunk_iterator
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_caf_next_chunk_iterator_def@
type T;
identifier F = caf_next_chunk_iterator;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_caf_next_chunk_iterator_def@
F << remove_static_caf_next_chunk_iterator_def.F;
T << remove_static_caf_next_chunk_iterator_def.T;
P << remove_static_caf_next_chunk_iterator_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_caf_next_chunk_iterator_def_void@
identifier F = caf_next_chunk_iterator;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_caf_next_chunk_iterator_def_void@
F << remove_static_caf_next_chunk_iterator_def_void.F;
P << remove_static_caf_next_chunk_iterator_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_caf_next_chunk_iterator_decl@
type T;
identifier F = caf_next_chunk_iterator;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_caf_next_chunk_iterator_decl@
F << remove_static_caf_next_chunk_iterator_decl.F;
T << remove_static_caf_next_chunk_iterator_decl.T;
P << remove_static_caf_next_chunk_iterator_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_caf_next_chunk_iterator_decl_void@
identifier F = caf_next_chunk_iterator;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_caf_next_chunk_iterator_decl_void@
F << remove_static_caf_next_chunk_iterator_decl_void.F;
P << remove_static_caf_next_chunk_iterator_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_caf_next_chunk_iterator_def@
type T;
identifier F = caf_next_chunk_iterator;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_caf_next_chunk_iterator_def@
F << extract_caf_next_chunk_iterator_def.F;
T << extract_caf_next_chunk_iterator_def.T;
P << extract_caf_next_chunk_iterator_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_caf_next_chunk_iterator_def_void@
identifier F = caf_next_chunk_iterator;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_caf_next_chunk_iterator_def_void@
F << extract_caf_next_chunk_iterator_def_void.F;
P << extract_caf_next_chunk_iterator_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_caf_next_chunk_iterator_decl@
type T;
identifier F = caf_next_chunk_iterator;
parameter list P;
@@
T F(P);

@script:python depends on extract_caf_next_chunk_iterator_decl@
F << extract_caf_next_chunk_iterator_decl.F;
T << extract_caf_next_chunk_iterator_decl.T;
P << extract_caf_next_chunk_iterator_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_caf_next_chunk_iterator_decl_void@
identifier F = caf_next_chunk_iterator;
parameter list P;
@@
void F(P);

@script:python depends on extract_caf_next_chunk_iterator_decl_void@
F << extract_caf_next_chunk_iterator_decl_void.F;
P << extract_caf_next_chunk_iterator_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: caf_set_chunk
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_caf_set_chunk_def@
type T;
identifier F = caf_set_chunk;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_caf_set_chunk_def@
F << remove_static_caf_set_chunk_def.F;
T << remove_static_caf_set_chunk_def.T;
P << remove_static_caf_set_chunk_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_caf_set_chunk_def_void@
identifier F = caf_set_chunk;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_caf_set_chunk_def_void@
F << remove_static_caf_set_chunk_def_void.F;
P << remove_static_caf_set_chunk_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_caf_set_chunk_decl@
type T;
identifier F = caf_set_chunk;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_caf_set_chunk_decl@
F << remove_static_caf_set_chunk_decl.F;
T << remove_static_caf_set_chunk_decl.T;
P << remove_static_caf_set_chunk_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_caf_set_chunk_decl_void@
identifier F = caf_set_chunk;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_caf_set_chunk_decl_void@
F << remove_static_caf_set_chunk_decl_void.F;
P << remove_static_caf_set_chunk_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_caf_set_chunk_def@
type T;
identifier F = caf_set_chunk;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_caf_set_chunk_def@
F << extract_caf_set_chunk_def.F;
T << extract_caf_set_chunk_def.T;
P << extract_caf_set_chunk_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_caf_set_chunk_def_void@
identifier F = caf_set_chunk;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_caf_set_chunk_def_void@
F << extract_caf_set_chunk_def_void.F;
P << extract_caf_set_chunk_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_caf_set_chunk_decl@
type T;
identifier F = caf_set_chunk;
parameter list P;
@@
T F(P);

@script:python depends on extract_caf_set_chunk_decl@
F << extract_caf_set_chunk_decl.F;
T << extract_caf_set_chunk_decl.T;
P << extract_caf_set_chunk_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_caf_set_chunk_decl_void@
identifier F = caf_set_chunk;
parameter list P;
@@
void F(P);

@script:python depends on extract_caf_set_chunk_decl_void@
F << extract_caf_set_chunk_decl_void.F;
P << extract_caf_set_chunk_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: caf_write_header
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_caf_write_header_def@
type T;
identifier F = caf_write_header;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_caf_write_header_def@
F << remove_static_caf_write_header_def.F;
T << remove_static_caf_write_header_def.T;
P << remove_static_caf_write_header_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_caf_write_header_def_void@
identifier F = caf_write_header;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_caf_write_header_def_void@
F << remove_static_caf_write_header_def_void.F;
P << remove_static_caf_write_header_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_caf_write_header_decl@
type T;
identifier F = caf_write_header;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_caf_write_header_decl@
F << remove_static_caf_write_header_decl.F;
T << remove_static_caf_write_header_decl.T;
P << remove_static_caf_write_header_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_caf_write_header_decl_void@
identifier F = caf_write_header;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_caf_write_header_decl_void@
F << remove_static_caf_write_header_decl_void.F;
P << remove_static_caf_write_header_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_caf_write_header_def@
type T;
identifier F = caf_write_header;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_caf_write_header_def@
F << extract_caf_write_header_def.F;
T << extract_caf_write_header_def.T;
P << extract_caf_write_header_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_caf_write_header_def_void@
identifier F = caf_write_header;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_caf_write_header_def_void@
F << extract_caf_write_header_def_void.F;
P << extract_caf_write_header_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_caf_write_header_decl@
type T;
identifier F = caf_write_header;
parameter list P;
@@
T F(P);

@script:python depends on extract_caf_write_header_decl@
F << extract_caf_write_header_decl.F;
T << extract_caf_write_header_decl.T;
P << extract_caf_write_header_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_caf_write_header_decl_void@
identifier F = caf_write_header;
parameter list P;
@@
void F(P);

@script:python depends on extract_caf_write_header_decl_void@
F << extract_caf_write_header_decl_void.F;
P << extract_caf_write_header_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: dither_read_int
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_dither_read_int_def@
type T;
identifier F = dither_read_int;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_dither_read_int_def@
F << remove_static_dither_read_int_def.F;
T << remove_static_dither_read_int_def.T;
P << remove_static_dither_read_int_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_dither_read_int_def_void@
identifier F = dither_read_int;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_dither_read_int_def_void@
F << remove_static_dither_read_int_def_void.F;
P << remove_static_dither_read_int_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_dither_read_int_decl@
type T;
identifier F = dither_read_int;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_dither_read_int_decl@
F << remove_static_dither_read_int_decl.F;
T << remove_static_dither_read_int_decl.T;
P << remove_static_dither_read_int_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_dither_read_int_decl_void@
identifier F = dither_read_int;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_dither_read_int_decl_void@
F << remove_static_dither_read_int_decl_void.F;
P << remove_static_dither_read_int_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_dither_read_int_def@
type T;
identifier F = dither_read_int;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_dither_read_int_def@
F << extract_dither_read_int_def.F;
T << extract_dither_read_int_def.T;
P << extract_dither_read_int_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_dither_read_int_def_void@
identifier F = dither_read_int;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_dither_read_int_def_void@
F << extract_dither_read_int_def_void.F;
P << extract_dither_read_int_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_dither_read_int_decl@
type T;
identifier F = dither_read_int;
parameter list P;
@@
T F(P);

@script:python depends on extract_dither_read_int_decl@
F << extract_dither_read_int_decl.F;
T << extract_dither_read_int_decl.T;
P << extract_dither_read_int_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_dither_read_int_decl_void@
identifier F = dither_read_int;
parameter list P;
@@
void F(P);

@script:python depends on extract_dither_read_int_decl_void@
F << extract_dither_read_int_decl_void.F;
P << extract_dither_read_int_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: dither_read_short
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_dither_read_short_def@
type T;
identifier F = dither_read_short;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_dither_read_short_def@
F << remove_static_dither_read_short_def.F;
T << remove_static_dither_read_short_def.T;
P << remove_static_dither_read_short_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_dither_read_short_def_void@
identifier F = dither_read_short;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_dither_read_short_def_void@
F << remove_static_dither_read_short_def_void.F;
P << remove_static_dither_read_short_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_dither_read_short_decl@
type T;
identifier F = dither_read_short;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_dither_read_short_decl@
F << remove_static_dither_read_short_decl.F;
T << remove_static_dither_read_short_decl.T;
P << remove_static_dither_read_short_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_dither_read_short_decl_void@
identifier F = dither_read_short;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_dither_read_short_decl_void@
F << remove_static_dither_read_short_decl_void.F;
P << remove_static_dither_read_short_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_dither_read_short_def@
type T;
identifier F = dither_read_short;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_dither_read_short_def@
F << extract_dither_read_short_def.F;
T << extract_dither_read_short_def.T;
P << extract_dither_read_short_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_dither_read_short_def_void@
identifier F = dither_read_short;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_dither_read_short_def_void@
F << extract_dither_read_short_def_void.F;
P << extract_dither_read_short_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_dither_read_short_decl@
type T;
identifier F = dither_read_short;
parameter list P;
@@
T F(P);

@script:python depends on extract_dither_read_short_decl@
F << extract_dither_read_short_decl.F;
T << extract_dither_read_short_decl.T;
P << extract_dither_read_short_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_dither_read_short_decl_void@
identifier F = dither_read_short;
parameter list P;
@@
void F(P);

@script:python depends on extract_dither_read_short_decl_void@
F << extract_dither_read_short_decl_void.F;
P << extract_dither_read_short_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: dither_write_double
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_dither_write_double_def@
type T;
identifier F = dither_write_double;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_dither_write_double_def@
F << remove_static_dither_write_double_def.F;
T << remove_static_dither_write_double_def.T;
P << remove_static_dither_write_double_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_dither_write_double_def_void@
identifier F = dither_write_double;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_dither_write_double_def_void@
F << remove_static_dither_write_double_def_void.F;
P << remove_static_dither_write_double_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_dither_write_double_decl@
type T;
identifier F = dither_write_double;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_dither_write_double_decl@
F << remove_static_dither_write_double_decl.F;
T << remove_static_dither_write_double_decl.T;
P << remove_static_dither_write_double_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_dither_write_double_decl_void@
identifier F = dither_write_double;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_dither_write_double_decl_void@
F << remove_static_dither_write_double_decl_void.F;
P << remove_static_dither_write_double_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_dither_write_double_def@
type T;
identifier F = dither_write_double;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_dither_write_double_def@
F << extract_dither_write_double_def.F;
T << extract_dither_write_double_def.T;
P << extract_dither_write_double_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_dither_write_double_def_void@
identifier F = dither_write_double;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_dither_write_double_def_void@
F << extract_dither_write_double_def_void.F;
P << extract_dither_write_double_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_dither_write_double_decl@
type T;
identifier F = dither_write_double;
parameter list P;
@@
T F(P);

@script:python depends on extract_dither_write_double_decl@
F << extract_dither_write_double_decl.F;
T << extract_dither_write_double_decl.T;
P << extract_dither_write_double_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_dither_write_double_decl_void@
identifier F = dither_write_double;
parameter list P;
@@
void F(P);

@script:python depends on extract_dither_write_double_decl_void@
F << extract_dither_write_double_decl_void.F;
P << extract_dither_write_double_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: dither_write_float
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_dither_write_float_def@
type T;
identifier F = dither_write_float;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_dither_write_float_def@
F << remove_static_dither_write_float_def.F;
T << remove_static_dither_write_float_def.T;
P << remove_static_dither_write_float_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_dither_write_float_def_void@
identifier F = dither_write_float;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_dither_write_float_def_void@
F << remove_static_dither_write_float_def_void.F;
P << remove_static_dither_write_float_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_dither_write_float_decl@
type T;
identifier F = dither_write_float;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_dither_write_float_decl@
F << remove_static_dither_write_float_decl.F;
T << remove_static_dither_write_float_decl.T;
P << remove_static_dither_write_float_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_dither_write_float_decl_void@
identifier F = dither_write_float;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_dither_write_float_decl_void@
F << remove_static_dither_write_float_decl_void.F;
P << remove_static_dither_write_float_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_dither_write_float_def@
type T;
identifier F = dither_write_float;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_dither_write_float_def@
F << extract_dither_write_float_def.F;
T << extract_dither_write_float_def.T;
P << extract_dither_write_float_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_dither_write_float_def_void@
identifier F = dither_write_float;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_dither_write_float_def_void@
F << extract_dither_write_float_def_void.F;
P << extract_dither_write_float_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_dither_write_float_decl@
type T;
identifier F = dither_write_float;
parameter list P;
@@
T F(P);

@script:python depends on extract_dither_write_float_decl@
F << extract_dither_write_float_decl.F;
T << extract_dither_write_float_decl.T;
P << extract_dither_write_float_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_dither_write_float_decl_void@
identifier F = dither_write_float;
parameter list P;
@@
void F(P);

@script:python depends on extract_dither_write_float_decl_void@
F << extract_dither_write_float_decl_void.F;
P << extract_dither_write_float_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: dither_write_int
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_dither_write_int_def@
type T;
identifier F = dither_write_int;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_dither_write_int_def@
F << remove_static_dither_write_int_def.F;
T << remove_static_dither_write_int_def.T;
P << remove_static_dither_write_int_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_dither_write_int_def_void@
identifier F = dither_write_int;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_dither_write_int_def_void@
F << remove_static_dither_write_int_def_void.F;
P << remove_static_dither_write_int_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_dither_write_int_decl@
type T;
identifier F = dither_write_int;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_dither_write_int_decl@
F << remove_static_dither_write_int_decl.F;
T << remove_static_dither_write_int_decl.T;
P << remove_static_dither_write_int_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_dither_write_int_decl_void@
identifier F = dither_write_int;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_dither_write_int_decl_void@
F << remove_static_dither_write_int_decl_void.F;
P << remove_static_dither_write_int_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_dither_write_int_def@
type T;
identifier F = dither_write_int;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_dither_write_int_def@
F << extract_dither_write_int_def.F;
T << extract_dither_write_int_def.T;
P << extract_dither_write_int_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_dither_write_int_def_void@
identifier F = dither_write_int;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_dither_write_int_def_void@
F << extract_dither_write_int_def_void.F;
P << extract_dither_write_int_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_dither_write_int_decl@
type T;
identifier F = dither_write_int;
parameter list P;
@@
T F(P);

@script:python depends on extract_dither_write_int_decl@
F << extract_dither_write_int_decl.F;
T << extract_dither_write_int_decl.T;
P << extract_dither_write_int_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_dither_write_int_decl_void@
identifier F = dither_write_int;
parameter list P;
@@
void F(P);

@script:python depends on extract_dither_write_int_decl_void@
F << extract_dither_write_int_decl_void.F;
P << extract_dither_write_int_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: dither_write_short
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_dither_write_short_def@
type T;
identifier F = dither_write_short;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_dither_write_short_def@
F << remove_static_dither_write_short_def.F;
T << remove_static_dither_write_short_def.T;
P << remove_static_dither_write_short_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_dither_write_short_def_void@
identifier F = dither_write_short;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_dither_write_short_def_void@
F << remove_static_dither_write_short_def_void.F;
P << remove_static_dither_write_short_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_dither_write_short_decl@
type T;
identifier F = dither_write_short;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_dither_write_short_decl@
F << remove_static_dither_write_short_decl.F;
T << remove_static_dither_write_short_decl.T;
P << remove_static_dither_write_short_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_dither_write_short_decl_void@
identifier F = dither_write_short;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_dither_write_short_decl_void@
F << remove_static_dither_write_short_decl_void.F;
P << remove_static_dither_write_short_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_dither_write_short_def@
type T;
identifier F = dither_write_short;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_dither_write_short_def@
F << extract_dither_write_short_def.F;
T << extract_dither_write_short_def.T;
P << extract_dither_write_short_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_dither_write_short_def_void@
identifier F = dither_write_short;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_dither_write_short_def_void@
F << extract_dither_write_short_def_void.F;
P << extract_dither_write_short_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_dither_write_short_decl@
type T;
identifier F = dither_write_short;
parameter list P;
@@
T F(P);

@script:python depends on extract_dither_write_short_decl@
F << extract_dither_write_short_decl.F;
T << extract_dither_write_short_decl.T;
P << extract_dither_write_short_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_dither_write_short_decl_void@
identifier F = dither_write_short;
parameter list P;
@@
void F(P);

@script:python depends on extract_dither_write_short_decl_void@
F << extract_dither_write_short_decl_void.F;
P << extract_dither_write_short_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: dpcm_read_dles2d
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_dpcm_read_dles2d_def@
type T;
identifier F = dpcm_read_dles2d;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_dpcm_read_dles2d_def@
F << remove_static_dpcm_read_dles2d_def.F;
T << remove_static_dpcm_read_dles2d_def.T;
P << remove_static_dpcm_read_dles2d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_dpcm_read_dles2d_def_void@
identifier F = dpcm_read_dles2d;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_dpcm_read_dles2d_def_void@
F << remove_static_dpcm_read_dles2d_def_void.F;
P << remove_static_dpcm_read_dles2d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_dpcm_read_dles2d_decl@
type T;
identifier F = dpcm_read_dles2d;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_dpcm_read_dles2d_decl@
F << remove_static_dpcm_read_dles2d_decl.F;
T << remove_static_dpcm_read_dles2d_decl.T;
P << remove_static_dpcm_read_dles2d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_dpcm_read_dles2d_decl_void@
identifier F = dpcm_read_dles2d;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_dpcm_read_dles2d_decl_void@
F << remove_static_dpcm_read_dles2d_decl_void.F;
P << remove_static_dpcm_read_dles2d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_dpcm_read_dles2d_def@
type T;
identifier F = dpcm_read_dles2d;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_dpcm_read_dles2d_def@
F << extract_dpcm_read_dles2d_def.F;
T << extract_dpcm_read_dles2d_def.T;
P << extract_dpcm_read_dles2d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_dpcm_read_dles2d_def_void@
identifier F = dpcm_read_dles2d;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_dpcm_read_dles2d_def_void@
F << extract_dpcm_read_dles2d_def_void.F;
P << extract_dpcm_read_dles2d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_dpcm_read_dles2d_decl@
type T;
identifier F = dpcm_read_dles2d;
parameter list P;
@@
T F(P);

@script:python depends on extract_dpcm_read_dles2d_decl@
F << extract_dpcm_read_dles2d_decl.F;
T << extract_dpcm_read_dles2d_decl.T;
P << extract_dpcm_read_dles2d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_dpcm_read_dles2d_decl_void@
identifier F = dpcm_read_dles2d;
parameter list P;
@@
void F(P);

@script:python depends on extract_dpcm_read_dles2d_decl_void@
F << extract_dpcm_read_dles2d_decl_void.F;
P << extract_dpcm_read_dles2d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: dpcm_read_dles2f
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_dpcm_read_dles2f_def@
type T;
identifier F = dpcm_read_dles2f;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_dpcm_read_dles2f_def@
F << remove_static_dpcm_read_dles2f_def.F;
T << remove_static_dpcm_read_dles2f_def.T;
P << remove_static_dpcm_read_dles2f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_dpcm_read_dles2f_def_void@
identifier F = dpcm_read_dles2f;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_dpcm_read_dles2f_def_void@
F << remove_static_dpcm_read_dles2f_def_void.F;
P << remove_static_dpcm_read_dles2f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_dpcm_read_dles2f_decl@
type T;
identifier F = dpcm_read_dles2f;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_dpcm_read_dles2f_decl@
F << remove_static_dpcm_read_dles2f_decl.F;
T << remove_static_dpcm_read_dles2f_decl.T;
P << remove_static_dpcm_read_dles2f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_dpcm_read_dles2f_decl_void@
identifier F = dpcm_read_dles2f;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_dpcm_read_dles2f_decl_void@
F << remove_static_dpcm_read_dles2f_decl_void.F;
P << remove_static_dpcm_read_dles2f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_dpcm_read_dles2f_def@
type T;
identifier F = dpcm_read_dles2f;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_dpcm_read_dles2f_def@
F << extract_dpcm_read_dles2f_def.F;
T << extract_dpcm_read_dles2f_def.T;
P << extract_dpcm_read_dles2f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_dpcm_read_dles2f_def_void@
identifier F = dpcm_read_dles2f;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_dpcm_read_dles2f_def_void@
F << extract_dpcm_read_dles2f_def_void.F;
P << extract_dpcm_read_dles2f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_dpcm_read_dles2f_decl@
type T;
identifier F = dpcm_read_dles2f;
parameter list P;
@@
T F(P);

@script:python depends on extract_dpcm_read_dles2f_decl@
F << extract_dpcm_read_dles2f_decl.F;
T << extract_dpcm_read_dles2f_decl.T;
P << extract_dpcm_read_dles2f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_dpcm_read_dles2f_decl_void@
identifier F = dpcm_read_dles2f;
parameter list P;
@@
void F(P);

@script:python depends on extract_dpcm_read_dles2f_decl_void@
F << extract_dpcm_read_dles2f_decl_void.F;
P << extract_dpcm_read_dles2f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: dpcm_read_dles2i
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_dpcm_read_dles2i_def@
type T;
identifier F = dpcm_read_dles2i;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_dpcm_read_dles2i_def@
F << remove_static_dpcm_read_dles2i_def.F;
T << remove_static_dpcm_read_dles2i_def.T;
P << remove_static_dpcm_read_dles2i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_dpcm_read_dles2i_def_void@
identifier F = dpcm_read_dles2i;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_dpcm_read_dles2i_def_void@
F << remove_static_dpcm_read_dles2i_def_void.F;
P << remove_static_dpcm_read_dles2i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_dpcm_read_dles2i_decl@
type T;
identifier F = dpcm_read_dles2i;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_dpcm_read_dles2i_decl@
F << remove_static_dpcm_read_dles2i_decl.F;
T << remove_static_dpcm_read_dles2i_decl.T;
P << remove_static_dpcm_read_dles2i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_dpcm_read_dles2i_decl_void@
identifier F = dpcm_read_dles2i;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_dpcm_read_dles2i_decl_void@
F << remove_static_dpcm_read_dles2i_decl_void.F;
P << remove_static_dpcm_read_dles2i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_dpcm_read_dles2i_def@
type T;
identifier F = dpcm_read_dles2i;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_dpcm_read_dles2i_def@
F << extract_dpcm_read_dles2i_def.F;
T << extract_dpcm_read_dles2i_def.T;
P << extract_dpcm_read_dles2i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_dpcm_read_dles2i_def_void@
identifier F = dpcm_read_dles2i;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_dpcm_read_dles2i_def_void@
F << extract_dpcm_read_dles2i_def_void.F;
P << extract_dpcm_read_dles2i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_dpcm_read_dles2i_decl@
type T;
identifier F = dpcm_read_dles2i;
parameter list P;
@@
T F(P);

@script:python depends on extract_dpcm_read_dles2i_decl@
F << extract_dpcm_read_dles2i_decl.F;
T << extract_dpcm_read_dles2i_decl.T;
P << extract_dpcm_read_dles2i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_dpcm_read_dles2i_decl_void@
identifier F = dpcm_read_dles2i;
parameter list P;
@@
void F(P);

@script:python depends on extract_dpcm_read_dles2i_decl_void@
F << extract_dpcm_read_dles2i_decl_void.F;
P << extract_dpcm_read_dles2i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: dpcm_read_dles2s
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_dpcm_read_dles2s_def@
type T;
identifier F = dpcm_read_dles2s;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_dpcm_read_dles2s_def@
F << remove_static_dpcm_read_dles2s_def.F;
T << remove_static_dpcm_read_dles2s_def.T;
P << remove_static_dpcm_read_dles2s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_dpcm_read_dles2s_def_void@
identifier F = dpcm_read_dles2s;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_dpcm_read_dles2s_def_void@
F << remove_static_dpcm_read_dles2s_def_void.F;
P << remove_static_dpcm_read_dles2s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_dpcm_read_dles2s_decl@
type T;
identifier F = dpcm_read_dles2s;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_dpcm_read_dles2s_decl@
F << remove_static_dpcm_read_dles2s_decl.F;
T << remove_static_dpcm_read_dles2s_decl.T;
P << remove_static_dpcm_read_dles2s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_dpcm_read_dles2s_decl_void@
identifier F = dpcm_read_dles2s;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_dpcm_read_dles2s_decl_void@
F << remove_static_dpcm_read_dles2s_decl_void.F;
P << remove_static_dpcm_read_dles2s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_dpcm_read_dles2s_def@
type T;
identifier F = dpcm_read_dles2s;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_dpcm_read_dles2s_def@
F << extract_dpcm_read_dles2s_def.F;
T << extract_dpcm_read_dles2s_def.T;
P << extract_dpcm_read_dles2s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_dpcm_read_dles2s_def_void@
identifier F = dpcm_read_dles2s;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_dpcm_read_dles2s_def_void@
F << extract_dpcm_read_dles2s_def_void.F;
P << extract_dpcm_read_dles2s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_dpcm_read_dles2s_decl@
type T;
identifier F = dpcm_read_dles2s;
parameter list P;
@@
T F(P);

@script:python depends on extract_dpcm_read_dles2s_decl@
F << extract_dpcm_read_dles2s_decl.F;
T << extract_dpcm_read_dles2s_decl.T;
P << extract_dpcm_read_dles2s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_dpcm_read_dles2s_decl_void@
identifier F = dpcm_read_dles2s;
parameter list P;
@@
void F(P);

@script:python depends on extract_dpcm_read_dles2s_decl_void@
F << extract_dpcm_read_dles2s_decl_void.F;
P << extract_dpcm_read_dles2s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: dpcm_read_dsc2d
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_dpcm_read_dsc2d_def@
type T;
identifier F = dpcm_read_dsc2d;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_dpcm_read_dsc2d_def@
F << remove_static_dpcm_read_dsc2d_def.F;
T << remove_static_dpcm_read_dsc2d_def.T;
P << remove_static_dpcm_read_dsc2d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_dpcm_read_dsc2d_def_void@
identifier F = dpcm_read_dsc2d;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_dpcm_read_dsc2d_def_void@
F << remove_static_dpcm_read_dsc2d_def_void.F;
P << remove_static_dpcm_read_dsc2d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_dpcm_read_dsc2d_decl@
type T;
identifier F = dpcm_read_dsc2d;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_dpcm_read_dsc2d_decl@
F << remove_static_dpcm_read_dsc2d_decl.F;
T << remove_static_dpcm_read_dsc2d_decl.T;
P << remove_static_dpcm_read_dsc2d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_dpcm_read_dsc2d_decl_void@
identifier F = dpcm_read_dsc2d;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_dpcm_read_dsc2d_decl_void@
F << remove_static_dpcm_read_dsc2d_decl_void.F;
P << remove_static_dpcm_read_dsc2d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_dpcm_read_dsc2d_def@
type T;
identifier F = dpcm_read_dsc2d;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_dpcm_read_dsc2d_def@
F << extract_dpcm_read_dsc2d_def.F;
T << extract_dpcm_read_dsc2d_def.T;
P << extract_dpcm_read_dsc2d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_dpcm_read_dsc2d_def_void@
identifier F = dpcm_read_dsc2d;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_dpcm_read_dsc2d_def_void@
F << extract_dpcm_read_dsc2d_def_void.F;
P << extract_dpcm_read_dsc2d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_dpcm_read_dsc2d_decl@
type T;
identifier F = dpcm_read_dsc2d;
parameter list P;
@@
T F(P);

@script:python depends on extract_dpcm_read_dsc2d_decl@
F << extract_dpcm_read_dsc2d_decl.F;
T << extract_dpcm_read_dsc2d_decl.T;
P << extract_dpcm_read_dsc2d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_dpcm_read_dsc2d_decl_void@
identifier F = dpcm_read_dsc2d;
parameter list P;
@@
void F(P);

@script:python depends on extract_dpcm_read_dsc2d_decl_void@
F << extract_dpcm_read_dsc2d_decl_void.F;
P << extract_dpcm_read_dsc2d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: dpcm_read_dsc2f
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_dpcm_read_dsc2f_def@
type T;
identifier F = dpcm_read_dsc2f;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_dpcm_read_dsc2f_def@
F << remove_static_dpcm_read_dsc2f_def.F;
T << remove_static_dpcm_read_dsc2f_def.T;
P << remove_static_dpcm_read_dsc2f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_dpcm_read_dsc2f_def_void@
identifier F = dpcm_read_dsc2f;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_dpcm_read_dsc2f_def_void@
F << remove_static_dpcm_read_dsc2f_def_void.F;
P << remove_static_dpcm_read_dsc2f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_dpcm_read_dsc2f_decl@
type T;
identifier F = dpcm_read_dsc2f;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_dpcm_read_dsc2f_decl@
F << remove_static_dpcm_read_dsc2f_decl.F;
T << remove_static_dpcm_read_dsc2f_decl.T;
P << remove_static_dpcm_read_dsc2f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_dpcm_read_dsc2f_decl_void@
identifier F = dpcm_read_dsc2f;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_dpcm_read_dsc2f_decl_void@
F << remove_static_dpcm_read_dsc2f_decl_void.F;
P << remove_static_dpcm_read_dsc2f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_dpcm_read_dsc2f_def@
type T;
identifier F = dpcm_read_dsc2f;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_dpcm_read_dsc2f_def@
F << extract_dpcm_read_dsc2f_def.F;
T << extract_dpcm_read_dsc2f_def.T;
P << extract_dpcm_read_dsc2f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_dpcm_read_dsc2f_def_void@
identifier F = dpcm_read_dsc2f;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_dpcm_read_dsc2f_def_void@
F << extract_dpcm_read_dsc2f_def_void.F;
P << extract_dpcm_read_dsc2f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_dpcm_read_dsc2f_decl@
type T;
identifier F = dpcm_read_dsc2f;
parameter list P;
@@
T F(P);

@script:python depends on extract_dpcm_read_dsc2f_decl@
F << extract_dpcm_read_dsc2f_decl.F;
T << extract_dpcm_read_dsc2f_decl.T;
P << extract_dpcm_read_dsc2f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_dpcm_read_dsc2f_decl_void@
identifier F = dpcm_read_dsc2f;
parameter list P;
@@
void F(P);

@script:python depends on extract_dpcm_read_dsc2f_decl_void@
F << extract_dpcm_read_dsc2f_decl_void.F;
P << extract_dpcm_read_dsc2f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: dpcm_read_dsc2i
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_dpcm_read_dsc2i_def@
type T;
identifier F = dpcm_read_dsc2i;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_dpcm_read_dsc2i_def@
F << remove_static_dpcm_read_dsc2i_def.F;
T << remove_static_dpcm_read_dsc2i_def.T;
P << remove_static_dpcm_read_dsc2i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_dpcm_read_dsc2i_def_void@
identifier F = dpcm_read_dsc2i;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_dpcm_read_dsc2i_def_void@
F << remove_static_dpcm_read_dsc2i_def_void.F;
P << remove_static_dpcm_read_dsc2i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_dpcm_read_dsc2i_decl@
type T;
identifier F = dpcm_read_dsc2i;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_dpcm_read_dsc2i_decl@
F << remove_static_dpcm_read_dsc2i_decl.F;
T << remove_static_dpcm_read_dsc2i_decl.T;
P << remove_static_dpcm_read_dsc2i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_dpcm_read_dsc2i_decl_void@
identifier F = dpcm_read_dsc2i;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_dpcm_read_dsc2i_decl_void@
F << remove_static_dpcm_read_dsc2i_decl_void.F;
P << remove_static_dpcm_read_dsc2i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_dpcm_read_dsc2i_def@
type T;
identifier F = dpcm_read_dsc2i;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_dpcm_read_dsc2i_def@
F << extract_dpcm_read_dsc2i_def.F;
T << extract_dpcm_read_dsc2i_def.T;
P << extract_dpcm_read_dsc2i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_dpcm_read_dsc2i_def_void@
identifier F = dpcm_read_dsc2i;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_dpcm_read_dsc2i_def_void@
F << extract_dpcm_read_dsc2i_def_void.F;
P << extract_dpcm_read_dsc2i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_dpcm_read_dsc2i_decl@
type T;
identifier F = dpcm_read_dsc2i;
parameter list P;
@@
T F(P);

@script:python depends on extract_dpcm_read_dsc2i_decl@
F << extract_dpcm_read_dsc2i_decl.F;
T << extract_dpcm_read_dsc2i_decl.T;
P << extract_dpcm_read_dsc2i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_dpcm_read_dsc2i_decl_void@
identifier F = dpcm_read_dsc2i;
parameter list P;
@@
void F(P);

@script:python depends on extract_dpcm_read_dsc2i_decl_void@
F << extract_dpcm_read_dsc2i_decl_void.F;
P << extract_dpcm_read_dsc2i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: dpcm_read_dsc2s
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_dpcm_read_dsc2s_def@
type T;
identifier F = dpcm_read_dsc2s;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_dpcm_read_dsc2s_def@
F << remove_static_dpcm_read_dsc2s_def.F;
T << remove_static_dpcm_read_dsc2s_def.T;
P << remove_static_dpcm_read_dsc2s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_dpcm_read_dsc2s_def_void@
identifier F = dpcm_read_dsc2s;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_dpcm_read_dsc2s_def_void@
F << remove_static_dpcm_read_dsc2s_def_void.F;
P << remove_static_dpcm_read_dsc2s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_dpcm_read_dsc2s_decl@
type T;
identifier F = dpcm_read_dsc2s;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_dpcm_read_dsc2s_decl@
F << remove_static_dpcm_read_dsc2s_decl.F;
T << remove_static_dpcm_read_dsc2s_decl.T;
P << remove_static_dpcm_read_dsc2s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_dpcm_read_dsc2s_decl_void@
identifier F = dpcm_read_dsc2s;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_dpcm_read_dsc2s_decl_void@
F << remove_static_dpcm_read_dsc2s_decl_void.F;
P << remove_static_dpcm_read_dsc2s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_dpcm_read_dsc2s_def@
type T;
identifier F = dpcm_read_dsc2s;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_dpcm_read_dsc2s_def@
F << extract_dpcm_read_dsc2s_def.F;
T << extract_dpcm_read_dsc2s_def.T;
P << extract_dpcm_read_dsc2s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_dpcm_read_dsc2s_def_void@
identifier F = dpcm_read_dsc2s;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_dpcm_read_dsc2s_def_void@
F << extract_dpcm_read_dsc2s_def_void.F;
P << extract_dpcm_read_dsc2s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_dpcm_read_dsc2s_decl@
type T;
identifier F = dpcm_read_dsc2s;
parameter list P;
@@
T F(P);

@script:python depends on extract_dpcm_read_dsc2s_decl@
F << extract_dpcm_read_dsc2s_decl.F;
T << extract_dpcm_read_dsc2s_decl.T;
P << extract_dpcm_read_dsc2s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_dpcm_read_dsc2s_decl_void@
identifier F = dpcm_read_dsc2s;
parameter list P;
@@
void F(P);

@script:python depends on extract_dpcm_read_dsc2s_decl_void@
F << extract_dpcm_read_dsc2s_decl_void.F;
P << extract_dpcm_read_dsc2s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: dpcm_seek
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_dpcm_seek_def@
type T;
identifier F = dpcm_seek;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_dpcm_seek_def@
F << remove_static_dpcm_seek_def.F;
T << remove_static_dpcm_seek_def.T;
P << remove_static_dpcm_seek_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_dpcm_seek_def_void@
identifier F = dpcm_seek;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_dpcm_seek_def_void@
F << remove_static_dpcm_seek_def_void.F;
P << remove_static_dpcm_seek_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_dpcm_seek_decl@
type T;
identifier F = dpcm_seek;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_dpcm_seek_decl@
F << remove_static_dpcm_seek_decl.F;
T << remove_static_dpcm_seek_decl.T;
P << remove_static_dpcm_seek_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_dpcm_seek_decl_void@
identifier F = dpcm_seek;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_dpcm_seek_decl_void@
F << remove_static_dpcm_seek_decl_void.F;
P << remove_static_dpcm_seek_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_dpcm_seek_def@
type T;
identifier F = dpcm_seek;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_dpcm_seek_def@
F << extract_dpcm_seek_def.F;
T << extract_dpcm_seek_def.T;
P << extract_dpcm_seek_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_dpcm_seek_def_void@
identifier F = dpcm_seek;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_dpcm_seek_def_void@
F << extract_dpcm_seek_def_void.F;
P << extract_dpcm_seek_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_dpcm_seek_decl@
type T;
identifier F = dpcm_seek;
parameter list P;
@@
T F(P);

@script:python depends on extract_dpcm_seek_decl@
F << extract_dpcm_seek_decl.F;
T << extract_dpcm_seek_decl.T;
P << extract_dpcm_seek_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_dpcm_seek_decl_void@
identifier F = dpcm_seek;
parameter list P;
@@
void F(P);

@script:python depends on extract_dpcm_seek_decl_void@
F << extract_dpcm_seek_decl_void.F;
P << extract_dpcm_seek_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: dpcm_write_d2dles
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_dpcm_write_d2dles_def@
type T;
identifier F = dpcm_write_d2dles;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_dpcm_write_d2dles_def@
F << remove_static_dpcm_write_d2dles_def.F;
T << remove_static_dpcm_write_d2dles_def.T;
P << remove_static_dpcm_write_d2dles_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_dpcm_write_d2dles_def_void@
identifier F = dpcm_write_d2dles;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_dpcm_write_d2dles_def_void@
F << remove_static_dpcm_write_d2dles_def_void.F;
P << remove_static_dpcm_write_d2dles_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_dpcm_write_d2dles_decl@
type T;
identifier F = dpcm_write_d2dles;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_dpcm_write_d2dles_decl@
F << remove_static_dpcm_write_d2dles_decl.F;
T << remove_static_dpcm_write_d2dles_decl.T;
P << remove_static_dpcm_write_d2dles_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_dpcm_write_d2dles_decl_void@
identifier F = dpcm_write_d2dles;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_dpcm_write_d2dles_decl_void@
F << remove_static_dpcm_write_d2dles_decl_void.F;
P << remove_static_dpcm_write_d2dles_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_dpcm_write_d2dles_def@
type T;
identifier F = dpcm_write_d2dles;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_dpcm_write_d2dles_def@
F << extract_dpcm_write_d2dles_def.F;
T << extract_dpcm_write_d2dles_def.T;
P << extract_dpcm_write_d2dles_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_dpcm_write_d2dles_def_void@
identifier F = dpcm_write_d2dles;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_dpcm_write_d2dles_def_void@
F << extract_dpcm_write_d2dles_def_void.F;
P << extract_dpcm_write_d2dles_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_dpcm_write_d2dles_decl@
type T;
identifier F = dpcm_write_d2dles;
parameter list P;
@@
T F(P);

@script:python depends on extract_dpcm_write_d2dles_decl@
F << extract_dpcm_write_d2dles_decl.F;
T << extract_dpcm_write_d2dles_decl.T;
P << extract_dpcm_write_d2dles_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_dpcm_write_d2dles_decl_void@
identifier F = dpcm_write_d2dles;
parameter list P;
@@
void F(P);

@script:python depends on extract_dpcm_write_d2dles_decl_void@
F << extract_dpcm_write_d2dles_decl_void.F;
P << extract_dpcm_write_d2dles_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: dpcm_write_d2dsc
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_dpcm_write_d2dsc_def@
type T;
identifier F = dpcm_write_d2dsc;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_dpcm_write_d2dsc_def@
F << remove_static_dpcm_write_d2dsc_def.F;
T << remove_static_dpcm_write_d2dsc_def.T;
P << remove_static_dpcm_write_d2dsc_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_dpcm_write_d2dsc_def_void@
identifier F = dpcm_write_d2dsc;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_dpcm_write_d2dsc_def_void@
F << remove_static_dpcm_write_d2dsc_def_void.F;
P << remove_static_dpcm_write_d2dsc_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_dpcm_write_d2dsc_decl@
type T;
identifier F = dpcm_write_d2dsc;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_dpcm_write_d2dsc_decl@
F << remove_static_dpcm_write_d2dsc_decl.F;
T << remove_static_dpcm_write_d2dsc_decl.T;
P << remove_static_dpcm_write_d2dsc_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_dpcm_write_d2dsc_decl_void@
identifier F = dpcm_write_d2dsc;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_dpcm_write_d2dsc_decl_void@
F << remove_static_dpcm_write_d2dsc_decl_void.F;
P << remove_static_dpcm_write_d2dsc_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_dpcm_write_d2dsc_def@
type T;
identifier F = dpcm_write_d2dsc;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_dpcm_write_d2dsc_def@
F << extract_dpcm_write_d2dsc_def.F;
T << extract_dpcm_write_d2dsc_def.T;
P << extract_dpcm_write_d2dsc_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_dpcm_write_d2dsc_def_void@
identifier F = dpcm_write_d2dsc;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_dpcm_write_d2dsc_def_void@
F << extract_dpcm_write_d2dsc_def_void.F;
P << extract_dpcm_write_d2dsc_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_dpcm_write_d2dsc_decl@
type T;
identifier F = dpcm_write_d2dsc;
parameter list P;
@@
T F(P);

@script:python depends on extract_dpcm_write_d2dsc_decl@
F << extract_dpcm_write_d2dsc_decl.F;
T << extract_dpcm_write_d2dsc_decl.T;
P << extract_dpcm_write_d2dsc_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_dpcm_write_d2dsc_decl_void@
identifier F = dpcm_write_d2dsc;
parameter list P;
@@
void F(P);

@script:python depends on extract_dpcm_write_d2dsc_decl_void@
F << extract_dpcm_write_d2dsc_decl_void.F;
P << extract_dpcm_write_d2dsc_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: dpcm_write_f2dles
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_dpcm_write_f2dles_def@
type T;
identifier F = dpcm_write_f2dles;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_dpcm_write_f2dles_def@
F << remove_static_dpcm_write_f2dles_def.F;
T << remove_static_dpcm_write_f2dles_def.T;
P << remove_static_dpcm_write_f2dles_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_dpcm_write_f2dles_def_void@
identifier F = dpcm_write_f2dles;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_dpcm_write_f2dles_def_void@
F << remove_static_dpcm_write_f2dles_def_void.F;
P << remove_static_dpcm_write_f2dles_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_dpcm_write_f2dles_decl@
type T;
identifier F = dpcm_write_f2dles;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_dpcm_write_f2dles_decl@
F << remove_static_dpcm_write_f2dles_decl.F;
T << remove_static_dpcm_write_f2dles_decl.T;
P << remove_static_dpcm_write_f2dles_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_dpcm_write_f2dles_decl_void@
identifier F = dpcm_write_f2dles;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_dpcm_write_f2dles_decl_void@
F << remove_static_dpcm_write_f2dles_decl_void.F;
P << remove_static_dpcm_write_f2dles_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_dpcm_write_f2dles_def@
type T;
identifier F = dpcm_write_f2dles;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_dpcm_write_f2dles_def@
F << extract_dpcm_write_f2dles_def.F;
T << extract_dpcm_write_f2dles_def.T;
P << extract_dpcm_write_f2dles_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_dpcm_write_f2dles_def_void@
identifier F = dpcm_write_f2dles;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_dpcm_write_f2dles_def_void@
F << extract_dpcm_write_f2dles_def_void.F;
P << extract_dpcm_write_f2dles_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_dpcm_write_f2dles_decl@
type T;
identifier F = dpcm_write_f2dles;
parameter list P;
@@
T F(P);

@script:python depends on extract_dpcm_write_f2dles_decl@
F << extract_dpcm_write_f2dles_decl.F;
T << extract_dpcm_write_f2dles_decl.T;
P << extract_dpcm_write_f2dles_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_dpcm_write_f2dles_decl_void@
identifier F = dpcm_write_f2dles;
parameter list P;
@@
void F(P);

@script:python depends on extract_dpcm_write_f2dles_decl_void@
F << extract_dpcm_write_f2dles_decl_void.F;
P << extract_dpcm_write_f2dles_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: dpcm_write_f2dsc
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_dpcm_write_f2dsc_def@
type T;
identifier F = dpcm_write_f2dsc;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_dpcm_write_f2dsc_def@
F << remove_static_dpcm_write_f2dsc_def.F;
T << remove_static_dpcm_write_f2dsc_def.T;
P << remove_static_dpcm_write_f2dsc_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_dpcm_write_f2dsc_def_void@
identifier F = dpcm_write_f2dsc;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_dpcm_write_f2dsc_def_void@
F << remove_static_dpcm_write_f2dsc_def_void.F;
P << remove_static_dpcm_write_f2dsc_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_dpcm_write_f2dsc_decl@
type T;
identifier F = dpcm_write_f2dsc;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_dpcm_write_f2dsc_decl@
F << remove_static_dpcm_write_f2dsc_decl.F;
T << remove_static_dpcm_write_f2dsc_decl.T;
P << remove_static_dpcm_write_f2dsc_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_dpcm_write_f2dsc_decl_void@
identifier F = dpcm_write_f2dsc;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_dpcm_write_f2dsc_decl_void@
F << remove_static_dpcm_write_f2dsc_decl_void.F;
P << remove_static_dpcm_write_f2dsc_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_dpcm_write_f2dsc_def@
type T;
identifier F = dpcm_write_f2dsc;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_dpcm_write_f2dsc_def@
F << extract_dpcm_write_f2dsc_def.F;
T << extract_dpcm_write_f2dsc_def.T;
P << extract_dpcm_write_f2dsc_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_dpcm_write_f2dsc_def_void@
identifier F = dpcm_write_f2dsc;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_dpcm_write_f2dsc_def_void@
F << extract_dpcm_write_f2dsc_def_void.F;
P << extract_dpcm_write_f2dsc_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_dpcm_write_f2dsc_decl@
type T;
identifier F = dpcm_write_f2dsc;
parameter list P;
@@
T F(P);

@script:python depends on extract_dpcm_write_f2dsc_decl@
F << extract_dpcm_write_f2dsc_decl.F;
T << extract_dpcm_write_f2dsc_decl.T;
P << extract_dpcm_write_f2dsc_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_dpcm_write_f2dsc_decl_void@
identifier F = dpcm_write_f2dsc;
parameter list P;
@@
void F(P);

@script:python depends on extract_dpcm_write_f2dsc_decl_void@
F << extract_dpcm_write_f2dsc_decl_void.F;
P << extract_dpcm_write_f2dsc_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: dpcm_write_i2dles
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_dpcm_write_i2dles_def@
type T;
identifier F = dpcm_write_i2dles;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_dpcm_write_i2dles_def@
F << remove_static_dpcm_write_i2dles_def.F;
T << remove_static_dpcm_write_i2dles_def.T;
P << remove_static_dpcm_write_i2dles_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_dpcm_write_i2dles_def_void@
identifier F = dpcm_write_i2dles;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_dpcm_write_i2dles_def_void@
F << remove_static_dpcm_write_i2dles_def_void.F;
P << remove_static_dpcm_write_i2dles_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_dpcm_write_i2dles_decl@
type T;
identifier F = dpcm_write_i2dles;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_dpcm_write_i2dles_decl@
F << remove_static_dpcm_write_i2dles_decl.F;
T << remove_static_dpcm_write_i2dles_decl.T;
P << remove_static_dpcm_write_i2dles_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_dpcm_write_i2dles_decl_void@
identifier F = dpcm_write_i2dles;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_dpcm_write_i2dles_decl_void@
F << remove_static_dpcm_write_i2dles_decl_void.F;
P << remove_static_dpcm_write_i2dles_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_dpcm_write_i2dles_def@
type T;
identifier F = dpcm_write_i2dles;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_dpcm_write_i2dles_def@
F << extract_dpcm_write_i2dles_def.F;
T << extract_dpcm_write_i2dles_def.T;
P << extract_dpcm_write_i2dles_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_dpcm_write_i2dles_def_void@
identifier F = dpcm_write_i2dles;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_dpcm_write_i2dles_def_void@
F << extract_dpcm_write_i2dles_def_void.F;
P << extract_dpcm_write_i2dles_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_dpcm_write_i2dles_decl@
type T;
identifier F = dpcm_write_i2dles;
parameter list P;
@@
T F(P);

@script:python depends on extract_dpcm_write_i2dles_decl@
F << extract_dpcm_write_i2dles_decl.F;
T << extract_dpcm_write_i2dles_decl.T;
P << extract_dpcm_write_i2dles_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_dpcm_write_i2dles_decl_void@
identifier F = dpcm_write_i2dles;
parameter list P;
@@
void F(P);

@script:python depends on extract_dpcm_write_i2dles_decl_void@
F << extract_dpcm_write_i2dles_decl_void.F;
P << extract_dpcm_write_i2dles_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: dpcm_write_i2dsc
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_dpcm_write_i2dsc_def@
type T;
identifier F = dpcm_write_i2dsc;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_dpcm_write_i2dsc_def@
F << remove_static_dpcm_write_i2dsc_def.F;
T << remove_static_dpcm_write_i2dsc_def.T;
P << remove_static_dpcm_write_i2dsc_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_dpcm_write_i2dsc_def_void@
identifier F = dpcm_write_i2dsc;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_dpcm_write_i2dsc_def_void@
F << remove_static_dpcm_write_i2dsc_def_void.F;
P << remove_static_dpcm_write_i2dsc_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_dpcm_write_i2dsc_decl@
type T;
identifier F = dpcm_write_i2dsc;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_dpcm_write_i2dsc_decl@
F << remove_static_dpcm_write_i2dsc_decl.F;
T << remove_static_dpcm_write_i2dsc_decl.T;
P << remove_static_dpcm_write_i2dsc_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_dpcm_write_i2dsc_decl_void@
identifier F = dpcm_write_i2dsc;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_dpcm_write_i2dsc_decl_void@
F << remove_static_dpcm_write_i2dsc_decl_void.F;
P << remove_static_dpcm_write_i2dsc_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_dpcm_write_i2dsc_def@
type T;
identifier F = dpcm_write_i2dsc;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_dpcm_write_i2dsc_def@
F << extract_dpcm_write_i2dsc_def.F;
T << extract_dpcm_write_i2dsc_def.T;
P << extract_dpcm_write_i2dsc_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_dpcm_write_i2dsc_def_void@
identifier F = dpcm_write_i2dsc;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_dpcm_write_i2dsc_def_void@
F << extract_dpcm_write_i2dsc_def_void.F;
P << extract_dpcm_write_i2dsc_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_dpcm_write_i2dsc_decl@
type T;
identifier F = dpcm_write_i2dsc;
parameter list P;
@@
T F(P);

@script:python depends on extract_dpcm_write_i2dsc_decl@
F << extract_dpcm_write_i2dsc_decl.F;
T << extract_dpcm_write_i2dsc_decl.T;
P << extract_dpcm_write_i2dsc_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_dpcm_write_i2dsc_decl_void@
identifier F = dpcm_write_i2dsc;
parameter list P;
@@
void F(P);

@script:python depends on extract_dpcm_write_i2dsc_decl_void@
F << extract_dpcm_write_i2dsc_decl_void.F;
P << extract_dpcm_write_i2dsc_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: dpcm_write_s2dles
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_dpcm_write_s2dles_def@
type T;
identifier F = dpcm_write_s2dles;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_dpcm_write_s2dles_def@
F << remove_static_dpcm_write_s2dles_def.F;
T << remove_static_dpcm_write_s2dles_def.T;
P << remove_static_dpcm_write_s2dles_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_dpcm_write_s2dles_def_void@
identifier F = dpcm_write_s2dles;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_dpcm_write_s2dles_def_void@
F << remove_static_dpcm_write_s2dles_def_void.F;
P << remove_static_dpcm_write_s2dles_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_dpcm_write_s2dles_decl@
type T;
identifier F = dpcm_write_s2dles;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_dpcm_write_s2dles_decl@
F << remove_static_dpcm_write_s2dles_decl.F;
T << remove_static_dpcm_write_s2dles_decl.T;
P << remove_static_dpcm_write_s2dles_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_dpcm_write_s2dles_decl_void@
identifier F = dpcm_write_s2dles;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_dpcm_write_s2dles_decl_void@
F << remove_static_dpcm_write_s2dles_decl_void.F;
P << remove_static_dpcm_write_s2dles_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_dpcm_write_s2dles_def@
type T;
identifier F = dpcm_write_s2dles;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_dpcm_write_s2dles_def@
F << extract_dpcm_write_s2dles_def.F;
T << extract_dpcm_write_s2dles_def.T;
P << extract_dpcm_write_s2dles_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_dpcm_write_s2dles_def_void@
identifier F = dpcm_write_s2dles;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_dpcm_write_s2dles_def_void@
F << extract_dpcm_write_s2dles_def_void.F;
P << extract_dpcm_write_s2dles_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_dpcm_write_s2dles_decl@
type T;
identifier F = dpcm_write_s2dles;
parameter list P;
@@
T F(P);

@script:python depends on extract_dpcm_write_s2dles_decl@
F << extract_dpcm_write_s2dles_decl.F;
T << extract_dpcm_write_s2dles_decl.T;
P << extract_dpcm_write_s2dles_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_dpcm_write_s2dles_decl_void@
identifier F = dpcm_write_s2dles;
parameter list P;
@@
void F(P);

@script:python depends on extract_dpcm_write_s2dles_decl_void@
F << extract_dpcm_write_s2dles_decl_void.F;
P << extract_dpcm_write_s2dles_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: dpcm_write_s2dsc
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_dpcm_write_s2dsc_def@
type T;
identifier F = dpcm_write_s2dsc;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_dpcm_write_s2dsc_def@
F << remove_static_dpcm_write_s2dsc_def.F;
T << remove_static_dpcm_write_s2dsc_def.T;
P << remove_static_dpcm_write_s2dsc_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_dpcm_write_s2dsc_def_void@
identifier F = dpcm_write_s2dsc;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_dpcm_write_s2dsc_def_void@
F << remove_static_dpcm_write_s2dsc_def_void.F;
P << remove_static_dpcm_write_s2dsc_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_dpcm_write_s2dsc_decl@
type T;
identifier F = dpcm_write_s2dsc;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_dpcm_write_s2dsc_decl@
F << remove_static_dpcm_write_s2dsc_decl.F;
T << remove_static_dpcm_write_s2dsc_decl.T;
P << remove_static_dpcm_write_s2dsc_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_dpcm_write_s2dsc_decl_void@
identifier F = dpcm_write_s2dsc;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_dpcm_write_s2dsc_decl_void@
F << remove_static_dpcm_write_s2dsc_decl_void.F;
P << remove_static_dpcm_write_s2dsc_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_dpcm_write_s2dsc_def@
type T;
identifier F = dpcm_write_s2dsc;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_dpcm_write_s2dsc_def@
F << extract_dpcm_write_s2dsc_def.F;
T << extract_dpcm_write_s2dsc_def.T;
P << extract_dpcm_write_s2dsc_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_dpcm_write_s2dsc_def_void@
identifier F = dpcm_write_s2dsc;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_dpcm_write_s2dsc_def_void@
F << extract_dpcm_write_s2dsc_def_void.F;
P << extract_dpcm_write_s2dsc_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_dpcm_write_s2dsc_decl@
type T;
identifier F = dpcm_write_s2dsc;
parameter list P;
@@
T F(P);

@script:python depends on extract_dpcm_write_s2dsc_decl@
F << extract_dpcm_write_s2dsc_decl.F;
T << extract_dpcm_write_s2dsc_decl.T;
P << extract_dpcm_write_s2dsc_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_dpcm_write_s2dsc_decl_void@
identifier F = dpcm_write_s2dsc;
parameter list P;
@@
void F(P);

@script:python depends on extract_dpcm_write_s2dsc_decl_void@
F << extract_dpcm_write_s2dsc_decl_void.F;
P << extract_dpcm_write_s2dsc_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: dwd_close
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_dwd_close_def@
type T;
identifier F = dwd_close;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_dwd_close_def@
F << remove_static_dwd_close_def.F;
T << remove_static_dwd_close_def.T;
P << remove_static_dwd_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_dwd_close_def_void@
identifier F = dwd_close;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_dwd_close_def_void@
F << remove_static_dwd_close_def_void.F;
P << remove_static_dwd_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_dwd_close_decl@
type T;
identifier F = dwd_close;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_dwd_close_decl@
F << remove_static_dwd_close_decl.F;
T << remove_static_dwd_close_decl.T;
P << remove_static_dwd_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_dwd_close_decl_void@
identifier F = dwd_close;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_dwd_close_decl_void@
F << remove_static_dwd_close_decl_void.F;
P << remove_static_dwd_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_dwd_close_def@
type T;
identifier F = dwd_close;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_dwd_close_def@
F << extract_dwd_close_def.F;
T << extract_dwd_close_def.T;
P << extract_dwd_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_dwd_close_def_void@
identifier F = dwd_close;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_dwd_close_def_void@
F << extract_dwd_close_def_void.F;
P << extract_dwd_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_dwd_close_decl@
type T;
identifier F = dwd_close;
parameter list P;
@@
T F(P);

@script:python depends on extract_dwd_close_decl@
F << extract_dwd_close_decl.F;
T << extract_dwd_close_decl.T;
P << extract_dwd_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_dwd_close_decl_void@
identifier F = dwd_close;
parameter list P;
@@
void F(P);

@script:python depends on extract_dwd_close_decl_void@
F << extract_dwd_close_decl_void.F;
P << extract_dwd_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: dwvw_byterate
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_dwvw_byterate_def@
type T;
identifier F = dwvw_byterate;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_dwvw_byterate_def@
F << remove_static_dwvw_byterate_def.F;
T << remove_static_dwvw_byterate_def.T;
P << remove_static_dwvw_byterate_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_dwvw_byterate_def_void@
identifier F = dwvw_byterate;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_dwvw_byterate_def_void@
F << remove_static_dwvw_byterate_def_void.F;
P << remove_static_dwvw_byterate_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_dwvw_byterate_decl@
type T;
identifier F = dwvw_byterate;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_dwvw_byterate_decl@
F << remove_static_dwvw_byterate_decl.F;
T << remove_static_dwvw_byterate_decl.T;
P << remove_static_dwvw_byterate_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_dwvw_byterate_decl_void@
identifier F = dwvw_byterate;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_dwvw_byterate_decl_void@
F << remove_static_dwvw_byterate_decl_void.F;
P << remove_static_dwvw_byterate_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_dwvw_byterate_def@
type T;
identifier F = dwvw_byterate;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_dwvw_byterate_def@
F << extract_dwvw_byterate_def.F;
T << extract_dwvw_byterate_def.T;
P << extract_dwvw_byterate_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_dwvw_byterate_def_void@
identifier F = dwvw_byterate;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_dwvw_byterate_def_void@
F << extract_dwvw_byterate_def_void.F;
P << extract_dwvw_byterate_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_dwvw_byterate_decl@
type T;
identifier F = dwvw_byterate;
parameter list P;
@@
T F(P);

@script:python depends on extract_dwvw_byterate_decl@
F << extract_dwvw_byterate_decl.F;
T << extract_dwvw_byterate_decl.T;
P << extract_dwvw_byterate_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_dwvw_byterate_decl_void@
identifier F = dwvw_byterate;
parameter list P;
@@
void F(P);

@script:python depends on extract_dwvw_byterate_decl_void@
F << extract_dwvw_byterate_decl_void.F;
P << extract_dwvw_byterate_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: dwvw_close
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_dwvw_close_def@
type T;
identifier F = dwvw_close;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_dwvw_close_def@
F << remove_static_dwvw_close_def.F;
T << remove_static_dwvw_close_def.T;
P << remove_static_dwvw_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_dwvw_close_def_void@
identifier F = dwvw_close;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_dwvw_close_def_void@
F << remove_static_dwvw_close_def_void.F;
P << remove_static_dwvw_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_dwvw_close_decl@
type T;
identifier F = dwvw_close;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_dwvw_close_decl@
F << remove_static_dwvw_close_decl.F;
T << remove_static_dwvw_close_decl.T;
P << remove_static_dwvw_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_dwvw_close_decl_void@
identifier F = dwvw_close;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_dwvw_close_decl_void@
F << remove_static_dwvw_close_decl_void.F;
P << remove_static_dwvw_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_dwvw_close_def@
type T;
identifier F = dwvw_close;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_dwvw_close_def@
F << extract_dwvw_close_def.F;
T << extract_dwvw_close_def.T;
P << extract_dwvw_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_dwvw_close_def_void@
identifier F = dwvw_close;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_dwvw_close_def_void@
F << extract_dwvw_close_def_void.F;
P << extract_dwvw_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_dwvw_close_decl@
type T;
identifier F = dwvw_close;
parameter list P;
@@
T F(P);

@script:python depends on extract_dwvw_close_decl@
F << extract_dwvw_close_decl.F;
T << extract_dwvw_close_decl.T;
P << extract_dwvw_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_dwvw_close_decl_void@
identifier F = dwvw_close;
parameter list P;
@@
void F(P);

@script:python depends on extract_dwvw_close_decl_void@
F << extract_dwvw_close_decl_void.F;
P << extract_dwvw_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: dwvw_read_d
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_dwvw_read_d_def@
type T;
identifier F = dwvw_read_d;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_dwvw_read_d_def@
F << remove_static_dwvw_read_d_def.F;
T << remove_static_dwvw_read_d_def.T;
P << remove_static_dwvw_read_d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_dwvw_read_d_def_void@
identifier F = dwvw_read_d;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_dwvw_read_d_def_void@
F << remove_static_dwvw_read_d_def_void.F;
P << remove_static_dwvw_read_d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_dwvw_read_d_decl@
type T;
identifier F = dwvw_read_d;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_dwvw_read_d_decl@
F << remove_static_dwvw_read_d_decl.F;
T << remove_static_dwvw_read_d_decl.T;
P << remove_static_dwvw_read_d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_dwvw_read_d_decl_void@
identifier F = dwvw_read_d;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_dwvw_read_d_decl_void@
F << remove_static_dwvw_read_d_decl_void.F;
P << remove_static_dwvw_read_d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_dwvw_read_d_def@
type T;
identifier F = dwvw_read_d;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_dwvw_read_d_def@
F << extract_dwvw_read_d_def.F;
T << extract_dwvw_read_d_def.T;
P << extract_dwvw_read_d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_dwvw_read_d_def_void@
identifier F = dwvw_read_d;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_dwvw_read_d_def_void@
F << extract_dwvw_read_d_def_void.F;
P << extract_dwvw_read_d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_dwvw_read_d_decl@
type T;
identifier F = dwvw_read_d;
parameter list P;
@@
T F(P);

@script:python depends on extract_dwvw_read_d_decl@
F << extract_dwvw_read_d_decl.F;
T << extract_dwvw_read_d_decl.T;
P << extract_dwvw_read_d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_dwvw_read_d_decl_void@
identifier F = dwvw_read_d;
parameter list P;
@@
void F(P);

@script:python depends on extract_dwvw_read_d_decl_void@
F << extract_dwvw_read_d_decl_void.F;
P << extract_dwvw_read_d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: dwvw_read_f
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_dwvw_read_f_def@
type T;
identifier F = dwvw_read_f;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_dwvw_read_f_def@
F << remove_static_dwvw_read_f_def.F;
T << remove_static_dwvw_read_f_def.T;
P << remove_static_dwvw_read_f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_dwvw_read_f_def_void@
identifier F = dwvw_read_f;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_dwvw_read_f_def_void@
F << remove_static_dwvw_read_f_def_void.F;
P << remove_static_dwvw_read_f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_dwvw_read_f_decl@
type T;
identifier F = dwvw_read_f;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_dwvw_read_f_decl@
F << remove_static_dwvw_read_f_decl.F;
T << remove_static_dwvw_read_f_decl.T;
P << remove_static_dwvw_read_f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_dwvw_read_f_decl_void@
identifier F = dwvw_read_f;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_dwvw_read_f_decl_void@
F << remove_static_dwvw_read_f_decl_void.F;
P << remove_static_dwvw_read_f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_dwvw_read_f_def@
type T;
identifier F = dwvw_read_f;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_dwvw_read_f_def@
F << extract_dwvw_read_f_def.F;
T << extract_dwvw_read_f_def.T;
P << extract_dwvw_read_f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_dwvw_read_f_def_void@
identifier F = dwvw_read_f;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_dwvw_read_f_def_void@
F << extract_dwvw_read_f_def_void.F;
P << extract_dwvw_read_f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_dwvw_read_f_decl@
type T;
identifier F = dwvw_read_f;
parameter list P;
@@
T F(P);

@script:python depends on extract_dwvw_read_f_decl@
F << extract_dwvw_read_f_decl.F;
T << extract_dwvw_read_f_decl.T;
P << extract_dwvw_read_f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_dwvw_read_f_decl_void@
identifier F = dwvw_read_f;
parameter list P;
@@
void F(P);

@script:python depends on extract_dwvw_read_f_decl_void@
F << extract_dwvw_read_f_decl_void.F;
P << extract_dwvw_read_f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: dwvw_read_i
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_dwvw_read_i_def@
type T;
identifier F = dwvw_read_i;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_dwvw_read_i_def@
F << remove_static_dwvw_read_i_def.F;
T << remove_static_dwvw_read_i_def.T;
P << remove_static_dwvw_read_i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_dwvw_read_i_def_void@
identifier F = dwvw_read_i;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_dwvw_read_i_def_void@
F << remove_static_dwvw_read_i_def_void.F;
P << remove_static_dwvw_read_i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_dwvw_read_i_decl@
type T;
identifier F = dwvw_read_i;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_dwvw_read_i_decl@
F << remove_static_dwvw_read_i_decl.F;
T << remove_static_dwvw_read_i_decl.T;
P << remove_static_dwvw_read_i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_dwvw_read_i_decl_void@
identifier F = dwvw_read_i;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_dwvw_read_i_decl_void@
F << remove_static_dwvw_read_i_decl_void.F;
P << remove_static_dwvw_read_i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_dwvw_read_i_def@
type T;
identifier F = dwvw_read_i;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_dwvw_read_i_def@
F << extract_dwvw_read_i_def.F;
T << extract_dwvw_read_i_def.T;
P << extract_dwvw_read_i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_dwvw_read_i_def_void@
identifier F = dwvw_read_i;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_dwvw_read_i_def_void@
F << extract_dwvw_read_i_def_void.F;
P << extract_dwvw_read_i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_dwvw_read_i_decl@
type T;
identifier F = dwvw_read_i;
parameter list P;
@@
T F(P);

@script:python depends on extract_dwvw_read_i_decl@
F << extract_dwvw_read_i_decl.F;
T << extract_dwvw_read_i_decl.T;
P << extract_dwvw_read_i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_dwvw_read_i_decl_void@
identifier F = dwvw_read_i;
parameter list P;
@@
void F(P);

@script:python depends on extract_dwvw_read_i_decl_void@
F << extract_dwvw_read_i_decl_void.F;
P << extract_dwvw_read_i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: dwvw_read_s
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_dwvw_read_s_def@
type T;
identifier F = dwvw_read_s;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_dwvw_read_s_def@
F << remove_static_dwvw_read_s_def.F;
T << remove_static_dwvw_read_s_def.T;
P << remove_static_dwvw_read_s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_dwvw_read_s_def_void@
identifier F = dwvw_read_s;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_dwvw_read_s_def_void@
F << remove_static_dwvw_read_s_def_void.F;
P << remove_static_dwvw_read_s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_dwvw_read_s_decl@
type T;
identifier F = dwvw_read_s;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_dwvw_read_s_decl@
F << remove_static_dwvw_read_s_decl.F;
T << remove_static_dwvw_read_s_decl.T;
P << remove_static_dwvw_read_s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_dwvw_read_s_decl_void@
identifier F = dwvw_read_s;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_dwvw_read_s_decl_void@
F << remove_static_dwvw_read_s_decl_void.F;
P << remove_static_dwvw_read_s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_dwvw_read_s_def@
type T;
identifier F = dwvw_read_s;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_dwvw_read_s_def@
F << extract_dwvw_read_s_def.F;
T << extract_dwvw_read_s_def.T;
P << extract_dwvw_read_s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_dwvw_read_s_def_void@
identifier F = dwvw_read_s;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_dwvw_read_s_def_void@
F << extract_dwvw_read_s_def_void.F;
P << extract_dwvw_read_s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_dwvw_read_s_decl@
type T;
identifier F = dwvw_read_s;
parameter list P;
@@
T F(P);

@script:python depends on extract_dwvw_read_s_decl@
F << extract_dwvw_read_s_decl.F;
T << extract_dwvw_read_s_decl.T;
P << extract_dwvw_read_s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_dwvw_read_s_decl_void@
identifier F = dwvw_read_s;
parameter list P;
@@
void F(P);

@script:python depends on extract_dwvw_read_s_decl_void@
F << extract_dwvw_read_s_decl_void.F;
P << extract_dwvw_read_s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: dwvw_seek
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_dwvw_seek_def@
type T;
identifier F = dwvw_seek;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_dwvw_seek_def@
F << remove_static_dwvw_seek_def.F;
T << remove_static_dwvw_seek_def.T;
P << remove_static_dwvw_seek_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_dwvw_seek_def_void@
identifier F = dwvw_seek;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_dwvw_seek_def_void@
F << remove_static_dwvw_seek_def_void.F;
P << remove_static_dwvw_seek_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_dwvw_seek_decl@
type T;
identifier F = dwvw_seek;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_dwvw_seek_decl@
F << remove_static_dwvw_seek_decl.F;
T << remove_static_dwvw_seek_decl.T;
P << remove_static_dwvw_seek_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_dwvw_seek_decl_void@
identifier F = dwvw_seek;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_dwvw_seek_decl_void@
F << remove_static_dwvw_seek_decl_void.F;
P << remove_static_dwvw_seek_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_dwvw_seek_def@
type T;
identifier F = dwvw_seek;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_dwvw_seek_def@
F << extract_dwvw_seek_def.F;
T << extract_dwvw_seek_def.T;
P << extract_dwvw_seek_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_dwvw_seek_def_void@
identifier F = dwvw_seek;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_dwvw_seek_def_void@
F << extract_dwvw_seek_def_void.F;
P << extract_dwvw_seek_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_dwvw_seek_decl@
type T;
identifier F = dwvw_seek;
parameter list P;
@@
T F(P);

@script:python depends on extract_dwvw_seek_decl@
F << extract_dwvw_seek_decl.F;
T << extract_dwvw_seek_decl.T;
P << extract_dwvw_seek_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_dwvw_seek_decl_void@
identifier F = dwvw_seek;
parameter list P;
@@
void F(P);

@script:python depends on extract_dwvw_seek_decl_void@
F << extract_dwvw_seek_decl_void.F;
P << extract_dwvw_seek_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: dwvw_write_d
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_dwvw_write_d_def@
type T;
identifier F = dwvw_write_d;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_dwvw_write_d_def@
F << remove_static_dwvw_write_d_def.F;
T << remove_static_dwvw_write_d_def.T;
P << remove_static_dwvw_write_d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_dwvw_write_d_def_void@
identifier F = dwvw_write_d;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_dwvw_write_d_def_void@
F << remove_static_dwvw_write_d_def_void.F;
P << remove_static_dwvw_write_d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_dwvw_write_d_decl@
type T;
identifier F = dwvw_write_d;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_dwvw_write_d_decl@
F << remove_static_dwvw_write_d_decl.F;
T << remove_static_dwvw_write_d_decl.T;
P << remove_static_dwvw_write_d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_dwvw_write_d_decl_void@
identifier F = dwvw_write_d;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_dwvw_write_d_decl_void@
F << remove_static_dwvw_write_d_decl_void.F;
P << remove_static_dwvw_write_d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_dwvw_write_d_def@
type T;
identifier F = dwvw_write_d;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_dwvw_write_d_def@
F << extract_dwvw_write_d_def.F;
T << extract_dwvw_write_d_def.T;
P << extract_dwvw_write_d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_dwvw_write_d_def_void@
identifier F = dwvw_write_d;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_dwvw_write_d_def_void@
F << extract_dwvw_write_d_def_void.F;
P << extract_dwvw_write_d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_dwvw_write_d_decl@
type T;
identifier F = dwvw_write_d;
parameter list P;
@@
T F(P);

@script:python depends on extract_dwvw_write_d_decl@
F << extract_dwvw_write_d_decl.F;
T << extract_dwvw_write_d_decl.T;
P << extract_dwvw_write_d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_dwvw_write_d_decl_void@
identifier F = dwvw_write_d;
parameter list P;
@@
void F(P);

@script:python depends on extract_dwvw_write_d_decl_void@
F << extract_dwvw_write_d_decl_void.F;
P << extract_dwvw_write_d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: dwvw_write_f
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_dwvw_write_f_def@
type T;
identifier F = dwvw_write_f;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_dwvw_write_f_def@
F << remove_static_dwvw_write_f_def.F;
T << remove_static_dwvw_write_f_def.T;
P << remove_static_dwvw_write_f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_dwvw_write_f_def_void@
identifier F = dwvw_write_f;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_dwvw_write_f_def_void@
F << remove_static_dwvw_write_f_def_void.F;
P << remove_static_dwvw_write_f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_dwvw_write_f_decl@
type T;
identifier F = dwvw_write_f;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_dwvw_write_f_decl@
F << remove_static_dwvw_write_f_decl.F;
T << remove_static_dwvw_write_f_decl.T;
P << remove_static_dwvw_write_f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_dwvw_write_f_decl_void@
identifier F = dwvw_write_f;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_dwvw_write_f_decl_void@
F << remove_static_dwvw_write_f_decl_void.F;
P << remove_static_dwvw_write_f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_dwvw_write_f_def@
type T;
identifier F = dwvw_write_f;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_dwvw_write_f_def@
F << extract_dwvw_write_f_def.F;
T << extract_dwvw_write_f_def.T;
P << extract_dwvw_write_f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_dwvw_write_f_def_void@
identifier F = dwvw_write_f;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_dwvw_write_f_def_void@
F << extract_dwvw_write_f_def_void.F;
P << extract_dwvw_write_f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_dwvw_write_f_decl@
type T;
identifier F = dwvw_write_f;
parameter list P;
@@
T F(P);

@script:python depends on extract_dwvw_write_f_decl@
F << extract_dwvw_write_f_decl.F;
T << extract_dwvw_write_f_decl.T;
P << extract_dwvw_write_f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_dwvw_write_f_decl_void@
identifier F = dwvw_write_f;
parameter list P;
@@
void F(P);

@script:python depends on extract_dwvw_write_f_decl_void@
F << extract_dwvw_write_f_decl_void.F;
P << extract_dwvw_write_f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: dwvw_write_i
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_dwvw_write_i_def@
type T;
identifier F = dwvw_write_i;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_dwvw_write_i_def@
F << remove_static_dwvw_write_i_def.F;
T << remove_static_dwvw_write_i_def.T;
P << remove_static_dwvw_write_i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_dwvw_write_i_def_void@
identifier F = dwvw_write_i;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_dwvw_write_i_def_void@
F << remove_static_dwvw_write_i_def_void.F;
P << remove_static_dwvw_write_i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_dwvw_write_i_decl@
type T;
identifier F = dwvw_write_i;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_dwvw_write_i_decl@
F << remove_static_dwvw_write_i_decl.F;
T << remove_static_dwvw_write_i_decl.T;
P << remove_static_dwvw_write_i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_dwvw_write_i_decl_void@
identifier F = dwvw_write_i;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_dwvw_write_i_decl_void@
F << remove_static_dwvw_write_i_decl_void.F;
P << remove_static_dwvw_write_i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_dwvw_write_i_def@
type T;
identifier F = dwvw_write_i;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_dwvw_write_i_def@
F << extract_dwvw_write_i_def.F;
T << extract_dwvw_write_i_def.T;
P << extract_dwvw_write_i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_dwvw_write_i_def_void@
identifier F = dwvw_write_i;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_dwvw_write_i_def_void@
F << extract_dwvw_write_i_def_void.F;
P << extract_dwvw_write_i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_dwvw_write_i_decl@
type T;
identifier F = dwvw_write_i;
parameter list P;
@@
T F(P);

@script:python depends on extract_dwvw_write_i_decl@
F << extract_dwvw_write_i_decl.F;
T << extract_dwvw_write_i_decl.T;
P << extract_dwvw_write_i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_dwvw_write_i_decl_void@
identifier F = dwvw_write_i;
parameter list P;
@@
void F(P);

@script:python depends on extract_dwvw_write_i_decl_void@
F << extract_dwvw_write_i_decl_void.F;
P << extract_dwvw_write_i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: dwvw_write_s
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_dwvw_write_s_def@
type T;
identifier F = dwvw_write_s;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_dwvw_write_s_def@
F << remove_static_dwvw_write_s_def.F;
T << remove_static_dwvw_write_s_def.T;
P << remove_static_dwvw_write_s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_dwvw_write_s_def_void@
identifier F = dwvw_write_s;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_dwvw_write_s_def_void@
F << remove_static_dwvw_write_s_def_void.F;
P << remove_static_dwvw_write_s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_dwvw_write_s_decl@
type T;
identifier F = dwvw_write_s;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_dwvw_write_s_decl@
F << remove_static_dwvw_write_s_decl.F;
T << remove_static_dwvw_write_s_decl.T;
P << remove_static_dwvw_write_s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_dwvw_write_s_decl_void@
identifier F = dwvw_write_s;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_dwvw_write_s_decl_void@
F << remove_static_dwvw_write_s_decl_void.F;
P << remove_static_dwvw_write_s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_dwvw_write_s_def@
type T;
identifier F = dwvw_write_s;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_dwvw_write_s_def@
F << extract_dwvw_write_s_def.F;
T << extract_dwvw_write_s_def.T;
P << extract_dwvw_write_s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_dwvw_write_s_def_void@
identifier F = dwvw_write_s;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_dwvw_write_s_def_void@
F << extract_dwvw_write_s_def_void.F;
P << extract_dwvw_write_s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_dwvw_write_s_decl@
type T;
identifier F = dwvw_write_s;
parameter list P;
@@
T F(P);

@script:python depends on extract_dwvw_write_s_decl@
F << extract_dwvw_write_s_decl.F;
T << extract_dwvw_write_s_decl.T;
P << extract_dwvw_write_s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_dwvw_write_s_decl_void@
identifier F = dwvw_write_s;
parameter list P;
@@
void F(P);

@script:python depends on extract_dwvw_write_s_decl_void@
F << extract_dwvw_write_s_decl_void.F;
P << extract_dwvw_write_s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: flac_byterate
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_flac_byterate_def@
type T;
identifier F = flac_byterate;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_flac_byterate_def@
F << remove_static_flac_byterate_def.F;
T << remove_static_flac_byterate_def.T;
P << remove_static_flac_byterate_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_flac_byterate_def_void@
identifier F = flac_byterate;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_flac_byterate_def_void@
F << remove_static_flac_byterate_def_void.F;
P << remove_static_flac_byterate_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_flac_byterate_decl@
type T;
identifier F = flac_byterate;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_flac_byterate_decl@
F << remove_static_flac_byterate_decl.F;
T << remove_static_flac_byterate_decl.T;
P << remove_static_flac_byterate_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_flac_byterate_decl_void@
identifier F = flac_byterate;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_flac_byterate_decl_void@
F << remove_static_flac_byterate_decl_void.F;
P << remove_static_flac_byterate_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_flac_byterate_def@
type T;
identifier F = flac_byterate;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_flac_byterate_def@
F << extract_flac_byterate_def.F;
T << extract_flac_byterate_def.T;
P << extract_flac_byterate_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_flac_byterate_def_void@
identifier F = flac_byterate;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_flac_byterate_def_void@
F << extract_flac_byterate_def_void.F;
P << extract_flac_byterate_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_flac_byterate_decl@
type T;
identifier F = flac_byterate;
parameter list P;
@@
T F(P);

@script:python depends on extract_flac_byterate_decl@
F << extract_flac_byterate_decl.F;
T << extract_flac_byterate_decl.T;
P << extract_flac_byterate_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_flac_byterate_decl_void@
identifier F = flac_byterate;
parameter list P;
@@
void F(P);

@script:python depends on extract_flac_byterate_decl_void@
F << extract_flac_byterate_decl_void.F;
P << extract_flac_byterate_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: flac_close
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_flac_close_def@
type T;
identifier F = flac_close;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_flac_close_def@
F << remove_static_flac_close_def.F;
T << remove_static_flac_close_def.T;
P << remove_static_flac_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_flac_close_def_void@
identifier F = flac_close;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_flac_close_def_void@
F << remove_static_flac_close_def_void.F;
P << remove_static_flac_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_flac_close_decl@
type T;
identifier F = flac_close;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_flac_close_decl@
F << remove_static_flac_close_decl.F;
T << remove_static_flac_close_decl.T;
P << remove_static_flac_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_flac_close_decl_void@
identifier F = flac_close;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_flac_close_decl_void@
F << remove_static_flac_close_decl_void.F;
P << remove_static_flac_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_flac_close_def@
type T;
identifier F = flac_close;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_flac_close_def@
F << extract_flac_close_def.F;
T << extract_flac_close_def.T;
P << extract_flac_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_flac_close_def_void@
identifier F = flac_close;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_flac_close_def_void@
F << extract_flac_close_def_void.F;
P << extract_flac_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_flac_close_decl@
type T;
identifier F = flac_close;
parameter list P;
@@
T F(P);

@script:python depends on extract_flac_close_decl@
F << extract_flac_close_decl.F;
T << extract_flac_close_decl.T;
P << extract_flac_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_flac_close_decl_void@
identifier F = flac_close;
parameter list P;
@@
void F(P);

@script:python depends on extract_flac_close_decl_void@
F << extract_flac_close_decl_void.F;
P << extract_flac_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: flac_command
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_flac_command_def@
type T;
identifier F = flac_command;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_flac_command_def@
F << remove_static_flac_command_def.F;
T << remove_static_flac_command_def.T;
P << remove_static_flac_command_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_flac_command_def_void@
identifier F = flac_command;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_flac_command_def_void@
F << remove_static_flac_command_def_void.F;
P << remove_static_flac_command_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_flac_command_decl@
type T;
identifier F = flac_command;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_flac_command_decl@
F << remove_static_flac_command_decl.F;
T << remove_static_flac_command_decl.T;
P << remove_static_flac_command_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_flac_command_decl_void@
identifier F = flac_command;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_flac_command_decl_void@
F << remove_static_flac_command_decl_void.F;
P << remove_static_flac_command_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_flac_command_def@
type T;
identifier F = flac_command;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_flac_command_def@
F << extract_flac_command_def.F;
T << extract_flac_command_def.T;
P << extract_flac_command_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_flac_command_def_void@
identifier F = flac_command;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_flac_command_def_void@
F << extract_flac_command_def_void.F;
P << extract_flac_command_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_flac_command_decl@
type T;
identifier F = flac_command;
parameter list P;
@@
T F(P);

@script:python depends on extract_flac_command_decl@
F << extract_flac_command_decl.F;
T << extract_flac_command_decl.T;
P << extract_flac_command_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_flac_command_decl_void@
identifier F = flac_command;
parameter list P;
@@
void F(P);

@script:python depends on extract_flac_command_decl_void@
F << extract_flac_command_decl_void.F;
P << extract_flac_command_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: flac_read_flac2d
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_flac_read_flac2d_def@
type T;
identifier F = flac_read_flac2d;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_flac_read_flac2d_def@
F << remove_static_flac_read_flac2d_def.F;
T << remove_static_flac_read_flac2d_def.T;
P << remove_static_flac_read_flac2d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_flac_read_flac2d_def_void@
identifier F = flac_read_flac2d;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_flac_read_flac2d_def_void@
F << remove_static_flac_read_flac2d_def_void.F;
P << remove_static_flac_read_flac2d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_flac_read_flac2d_decl@
type T;
identifier F = flac_read_flac2d;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_flac_read_flac2d_decl@
F << remove_static_flac_read_flac2d_decl.F;
T << remove_static_flac_read_flac2d_decl.T;
P << remove_static_flac_read_flac2d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_flac_read_flac2d_decl_void@
identifier F = flac_read_flac2d;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_flac_read_flac2d_decl_void@
F << remove_static_flac_read_flac2d_decl_void.F;
P << remove_static_flac_read_flac2d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_flac_read_flac2d_def@
type T;
identifier F = flac_read_flac2d;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_flac_read_flac2d_def@
F << extract_flac_read_flac2d_def.F;
T << extract_flac_read_flac2d_def.T;
P << extract_flac_read_flac2d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_flac_read_flac2d_def_void@
identifier F = flac_read_flac2d;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_flac_read_flac2d_def_void@
F << extract_flac_read_flac2d_def_void.F;
P << extract_flac_read_flac2d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_flac_read_flac2d_decl@
type T;
identifier F = flac_read_flac2d;
parameter list P;
@@
T F(P);

@script:python depends on extract_flac_read_flac2d_decl@
F << extract_flac_read_flac2d_decl.F;
T << extract_flac_read_flac2d_decl.T;
P << extract_flac_read_flac2d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_flac_read_flac2d_decl_void@
identifier F = flac_read_flac2d;
parameter list P;
@@
void F(P);

@script:python depends on extract_flac_read_flac2d_decl_void@
F << extract_flac_read_flac2d_decl_void.F;
P << extract_flac_read_flac2d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: flac_read_flac2f
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_flac_read_flac2f_def@
type T;
identifier F = flac_read_flac2f;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_flac_read_flac2f_def@
F << remove_static_flac_read_flac2f_def.F;
T << remove_static_flac_read_flac2f_def.T;
P << remove_static_flac_read_flac2f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_flac_read_flac2f_def_void@
identifier F = flac_read_flac2f;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_flac_read_flac2f_def_void@
F << remove_static_flac_read_flac2f_def_void.F;
P << remove_static_flac_read_flac2f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_flac_read_flac2f_decl@
type T;
identifier F = flac_read_flac2f;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_flac_read_flac2f_decl@
F << remove_static_flac_read_flac2f_decl.F;
T << remove_static_flac_read_flac2f_decl.T;
P << remove_static_flac_read_flac2f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_flac_read_flac2f_decl_void@
identifier F = flac_read_flac2f;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_flac_read_flac2f_decl_void@
F << remove_static_flac_read_flac2f_decl_void.F;
P << remove_static_flac_read_flac2f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_flac_read_flac2f_def@
type T;
identifier F = flac_read_flac2f;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_flac_read_flac2f_def@
F << extract_flac_read_flac2f_def.F;
T << extract_flac_read_flac2f_def.T;
P << extract_flac_read_flac2f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_flac_read_flac2f_def_void@
identifier F = flac_read_flac2f;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_flac_read_flac2f_def_void@
F << extract_flac_read_flac2f_def_void.F;
P << extract_flac_read_flac2f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_flac_read_flac2f_decl@
type T;
identifier F = flac_read_flac2f;
parameter list P;
@@
T F(P);

@script:python depends on extract_flac_read_flac2f_decl@
F << extract_flac_read_flac2f_decl.F;
T << extract_flac_read_flac2f_decl.T;
P << extract_flac_read_flac2f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_flac_read_flac2f_decl_void@
identifier F = flac_read_flac2f;
parameter list P;
@@
void F(P);

@script:python depends on extract_flac_read_flac2f_decl_void@
F << extract_flac_read_flac2f_decl_void.F;
P << extract_flac_read_flac2f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: flac_read_flac2i
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_flac_read_flac2i_def@
type T;
identifier F = flac_read_flac2i;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_flac_read_flac2i_def@
F << remove_static_flac_read_flac2i_def.F;
T << remove_static_flac_read_flac2i_def.T;
P << remove_static_flac_read_flac2i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_flac_read_flac2i_def_void@
identifier F = flac_read_flac2i;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_flac_read_flac2i_def_void@
F << remove_static_flac_read_flac2i_def_void.F;
P << remove_static_flac_read_flac2i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_flac_read_flac2i_decl@
type T;
identifier F = flac_read_flac2i;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_flac_read_flac2i_decl@
F << remove_static_flac_read_flac2i_decl.F;
T << remove_static_flac_read_flac2i_decl.T;
P << remove_static_flac_read_flac2i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_flac_read_flac2i_decl_void@
identifier F = flac_read_flac2i;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_flac_read_flac2i_decl_void@
F << remove_static_flac_read_flac2i_decl_void.F;
P << remove_static_flac_read_flac2i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_flac_read_flac2i_def@
type T;
identifier F = flac_read_flac2i;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_flac_read_flac2i_def@
F << extract_flac_read_flac2i_def.F;
T << extract_flac_read_flac2i_def.T;
P << extract_flac_read_flac2i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_flac_read_flac2i_def_void@
identifier F = flac_read_flac2i;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_flac_read_flac2i_def_void@
F << extract_flac_read_flac2i_def_void.F;
P << extract_flac_read_flac2i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_flac_read_flac2i_decl@
type T;
identifier F = flac_read_flac2i;
parameter list P;
@@
T F(P);

@script:python depends on extract_flac_read_flac2i_decl@
F << extract_flac_read_flac2i_decl.F;
T << extract_flac_read_flac2i_decl.T;
P << extract_flac_read_flac2i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_flac_read_flac2i_decl_void@
identifier F = flac_read_flac2i;
parameter list P;
@@
void F(P);

@script:python depends on extract_flac_read_flac2i_decl_void@
F << extract_flac_read_flac2i_decl_void.F;
P << extract_flac_read_flac2i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: flac_read_flac2s
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_flac_read_flac2s_def@
type T;
identifier F = flac_read_flac2s;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_flac_read_flac2s_def@
F << remove_static_flac_read_flac2s_def.F;
T << remove_static_flac_read_flac2s_def.T;
P << remove_static_flac_read_flac2s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_flac_read_flac2s_def_void@
identifier F = flac_read_flac2s;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_flac_read_flac2s_def_void@
F << remove_static_flac_read_flac2s_def_void.F;
P << remove_static_flac_read_flac2s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_flac_read_flac2s_decl@
type T;
identifier F = flac_read_flac2s;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_flac_read_flac2s_decl@
F << remove_static_flac_read_flac2s_decl.F;
T << remove_static_flac_read_flac2s_decl.T;
P << remove_static_flac_read_flac2s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_flac_read_flac2s_decl_void@
identifier F = flac_read_flac2s;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_flac_read_flac2s_decl_void@
F << remove_static_flac_read_flac2s_decl_void.F;
P << remove_static_flac_read_flac2s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_flac_read_flac2s_def@
type T;
identifier F = flac_read_flac2s;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_flac_read_flac2s_def@
F << extract_flac_read_flac2s_def.F;
T << extract_flac_read_flac2s_def.T;
P << extract_flac_read_flac2s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_flac_read_flac2s_def_void@
identifier F = flac_read_flac2s;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_flac_read_flac2s_def_void@
F << extract_flac_read_flac2s_def_void.F;
P << extract_flac_read_flac2s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_flac_read_flac2s_decl@
type T;
identifier F = flac_read_flac2s;
parameter list P;
@@
T F(P);

@script:python depends on extract_flac_read_flac2s_decl@
F << extract_flac_read_flac2s_decl.F;
T << extract_flac_read_flac2s_decl.T;
P << extract_flac_read_flac2s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_flac_read_flac2s_decl_void@
identifier F = flac_read_flac2s;
parameter list P;
@@
void F(P);

@script:python depends on extract_flac_read_flac2s_decl_void@
F << extract_flac_read_flac2s_decl_void.F;
P << extract_flac_read_flac2s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: flac_seek
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_flac_seek_def@
type T;
identifier F = flac_seek;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_flac_seek_def@
F << remove_static_flac_seek_def.F;
T << remove_static_flac_seek_def.T;
P << remove_static_flac_seek_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_flac_seek_def_void@
identifier F = flac_seek;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_flac_seek_def_void@
F << remove_static_flac_seek_def_void.F;
P << remove_static_flac_seek_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_flac_seek_decl@
type T;
identifier F = flac_seek;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_flac_seek_decl@
F << remove_static_flac_seek_decl.F;
T << remove_static_flac_seek_decl.T;
P << remove_static_flac_seek_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_flac_seek_decl_void@
identifier F = flac_seek;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_flac_seek_decl_void@
F << remove_static_flac_seek_decl_void.F;
P << remove_static_flac_seek_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_flac_seek_def@
type T;
identifier F = flac_seek;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_flac_seek_def@
F << extract_flac_seek_def.F;
T << extract_flac_seek_def.T;
P << extract_flac_seek_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_flac_seek_def_void@
identifier F = flac_seek;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_flac_seek_def_void@
F << extract_flac_seek_def_void.F;
P << extract_flac_seek_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_flac_seek_decl@
type T;
identifier F = flac_seek;
parameter list P;
@@
T F(P);

@script:python depends on extract_flac_seek_decl@
F << extract_flac_seek_decl.F;
T << extract_flac_seek_decl.T;
P << extract_flac_seek_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_flac_seek_decl_void@
identifier F = flac_seek;
parameter list P;
@@
void F(P);

@script:python depends on extract_flac_seek_decl_void@
F << extract_flac_seek_decl_void.F;
P << extract_flac_seek_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: flac_write_d2flac
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_flac_write_d2flac_def@
type T;
identifier F = flac_write_d2flac;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_flac_write_d2flac_def@
F << remove_static_flac_write_d2flac_def.F;
T << remove_static_flac_write_d2flac_def.T;
P << remove_static_flac_write_d2flac_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_flac_write_d2flac_def_void@
identifier F = flac_write_d2flac;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_flac_write_d2flac_def_void@
F << remove_static_flac_write_d2flac_def_void.F;
P << remove_static_flac_write_d2flac_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_flac_write_d2flac_decl@
type T;
identifier F = flac_write_d2flac;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_flac_write_d2flac_decl@
F << remove_static_flac_write_d2flac_decl.F;
T << remove_static_flac_write_d2flac_decl.T;
P << remove_static_flac_write_d2flac_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_flac_write_d2flac_decl_void@
identifier F = flac_write_d2flac;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_flac_write_d2flac_decl_void@
F << remove_static_flac_write_d2flac_decl_void.F;
P << remove_static_flac_write_d2flac_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_flac_write_d2flac_def@
type T;
identifier F = flac_write_d2flac;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_flac_write_d2flac_def@
F << extract_flac_write_d2flac_def.F;
T << extract_flac_write_d2flac_def.T;
P << extract_flac_write_d2flac_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_flac_write_d2flac_def_void@
identifier F = flac_write_d2flac;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_flac_write_d2flac_def_void@
F << extract_flac_write_d2flac_def_void.F;
P << extract_flac_write_d2flac_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_flac_write_d2flac_decl@
type T;
identifier F = flac_write_d2flac;
parameter list P;
@@
T F(P);

@script:python depends on extract_flac_write_d2flac_decl@
F << extract_flac_write_d2flac_decl.F;
T << extract_flac_write_d2flac_decl.T;
P << extract_flac_write_d2flac_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_flac_write_d2flac_decl_void@
identifier F = flac_write_d2flac;
parameter list P;
@@
void F(P);

@script:python depends on extract_flac_write_d2flac_decl_void@
F << extract_flac_write_d2flac_decl_void.F;
P << extract_flac_write_d2flac_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: flac_write_f2flac
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_flac_write_f2flac_def@
type T;
identifier F = flac_write_f2flac;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_flac_write_f2flac_def@
F << remove_static_flac_write_f2flac_def.F;
T << remove_static_flac_write_f2flac_def.T;
P << remove_static_flac_write_f2flac_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_flac_write_f2flac_def_void@
identifier F = flac_write_f2flac;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_flac_write_f2flac_def_void@
F << remove_static_flac_write_f2flac_def_void.F;
P << remove_static_flac_write_f2flac_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_flac_write_f2flac_decl@
type T;
identifier F = flac_write_f2flac;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_flac_write_f2flac_decl@
F << remove_static_flac_write_f2flac_decl.F;
T << remove_static_flac_write_f2flac_decl.T;
P << remove_static_flac_write_f2flac_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_flac_write_f2flac_decl_void@
identifier F = flac_write_f2flac;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_flac_write_f2flac_decl_void@
F << remove_static_flac_write_f2flac_decl_void.F;
P << remove_static_flac_write_f2flac_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_flac_write_f2flac_def@
type T;
identifier F = flac_write_f2flac;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_flac_write_f2flac_def@
F << extract_flac_write_f2flac_def.F;
T << extract_flac_write_f2flac_def.T;
P << extract_flac_write_f2flac_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_flac_write_f2flac_def_void@
identifier F = flac_write_f2flac;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_flac_write_f2flac_def_void@
F << extract_flac_write_f2flac_def_void.F;
P << extract_flac_write_f2flac_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_flac_write_f2flac_decl@
type T;
identifier F = flac_write_f2flac;
parameter list P;
@@
T F(P);

@script:python depends on extract_flac_write_f2flac_decl@
F << extract_flac_write_f2flac_decl.F;
T << extract_flac_write_f2flac_decl.T;
P << extract_flac_write_f2flac_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_flac_write_f2flac_decl_void@
identifier F = flac_write_f2flac;
parameter list P;
@@
void F(P);

@script:python depends on extract_flac_write_f2flac_decl_void@
F << extract_flac_write_f2flac_decl_void.F;
P << extract_flac_write_f2flac_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: flac_write_header
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_flac_write_header_def@
type T;
identifier F = flac_write_header;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_flac_write_header_def@
F << remove_static_flac_write_header_def.F;
T << remove_static_flac_write_header_def.T;
P << remove_static_flac_write_header_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_flac_write_header_def_void@
identifier F = flac_write_header;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_flac_write_header_def_void@
F << remove_static_flac_write_header_def_void.F;
P << remove_static_flac_write_header_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_flac_write_header_decl@
type T;
identifier F = flac_write_header;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_flac_write_header_decl@
F << remove_static_flac_write_header_decl.F;
T << remove_static_flac_write_header_decl.T;
P << remove_static_flac_write_header_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_flac_write_header_decl_void@
identifier F = flac_write_header;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_flac_write_header_decl_void@
F << remove_static_flac_write_header_decl_void.F;
P << remove_static_flac_write_header_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_flac_write_header_def@
type T;
identifier F = flac_write_header;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_flac_write_header_def@
F << extract_flac_write_header_def.F;
T << extract_flac_write_header_def.T;
P << extract_flac_write_header_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_flac_write_header_def_void@
identifier F = flac_write_header;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_flac_write_header_def_void@
F << extract_flac_write_header_def_void.F;
P << extract_flac_write_header_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_flac_write_header_decl@
type T;
identifier F = flac_write_header;
parameter list P;
@@
T F(P);

@script:python depends on extract_flac_write_header_decl@
F << extract_flac_write_header_decl.F;
T << extract_flac_write_header_decl.T;
P << extract_flac_write_header_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_flac_write_header_decl_void@
identifier F = flac_write_header;
parameter list P;
@@
void F(P);

@script:python depends on extract_flac_write_header_decl_void@
F << extract_flac_write_header_decl_void.F;
P << extract_flac_write_header_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: flac_write_i2flac
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_flac_write_i2flac_def@
type T;
identifier F = flac_write_i2flac;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_flac_write_i2flac_def@
F << remove_static_flac_write_i2flac_def.F;
T << remove_static_flac_write_i2flac_def.T;
P << remove_static_flac_write_i2flac_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_flac_write_i2flac_def_void@
identifier F = flac_write_i2flac;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_flac_write_i2flac_def_void@
F << remove_static_flac_write_i2flac_def_void.F;
P << remove_static_flac_write_i2flac_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_flac_write_i2flac_decl@
type T;
identifier F = flac_write_i2flac;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_flac_write_i2flac_decl@
F << remove_static_flac_write_i2flac_decl.F;
T << remove_static_flac_write_i2flac_decl.T;
P << remove_static_flac_write_i2flac_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_flac_write_i2flac_decl_void@
identifier F = flac_write_i2flac;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_flac_write_i2flac_decl_void@
F << remove_static_flac_write_i2flac_decl_void.F;
P << remove_static_flac_write_i2flac_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_flac_write_i2flac_def@
type T;
identifier F = flac_write_i2flac;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_flac_write_i2flac_def@
F << extract_flac_write_i2flac_def.F;
T << extract_flac_write_i2flac_def.T;
P << extract_flac_write_i2flac_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_flac_write_i2flac_def_void@
identifier F = flac_write_i2flac;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_flac_write_i2flac_def_void@
F << extract_flac_write_i2flac_def_void.F;
P << extract_flac_write_i2flac_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_flac_write_i2flac_decl@
type T;
identifier F = flac_write_i2flac;
parameter list P;
@@
T F(P);

@script:python depends on extract_flac_write_i2flac_decl@
F << extract_flac_write_i2flac_decl.F;
T << extract_flac_write_i2flac_decl.T;
P << extract_flac_write_i2flac_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_flac_write_i2flac_decl_void@
identifier F = flac_write_i2flac;
parameter list P;
@@
void F(P);

@script:python depends on extract_flac_write_i2flac_decl_void@
F << extract_flac_write_i2flac_decl_void.F;
P << extract_flac_write_i2flac_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: flac_write_s2flac
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_flac_write_s2flac_def@
type T;
identifier F = flac_write_s2flac;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_flac_write_s2flac_def@
F << remove_static_flac_write_s2flac_def.F;
T << remove_static_flac_write_s2flac_def.T;
P << remove_static_flac_write_s2flac_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_flac_write_s2flac_def_void@
identifier F = flac_write_s2flac;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_flac_write_s2flac_def_void@
F << remove_static_flac_write_s2flac_def_void.F;
P << remove_static_flac_write_s2flac_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_flac_write_s2flac_decl@
type T;
identifier F = flac_write_s2flac;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_flac_write_s2flac_decl@
F << remove_static_flac_write_s2flac_decl.F;
T << remove_static_flac_write_s2flac_decl.T;
P << remove_static_flac_write_s2flac_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_flac_write_s2flac_decl_void@
identifier F = flac_write_s2flac;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_flac_write_s2flac_decl_void@
F << remove_static_flac_write_s2flac_decl_void.F;
P << remove_static_flac_write_s2flac_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_flac_write_s2flac_def@
type T;
identifier F = flac_write_s2flac;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_flac_write_s2flac_def@
F << extract_flac_write_s2flac_def.F;
T << extract_flac_write_s2flac_def.T;
P << extract_flac_write_s2flac_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_flac_write_s2flac_def_void@
identifier F = flac_write_s2flac;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_flac_write_s2flac_def_void@
F << extract_flac_write_s2flac_def_void.F;
P << extract_flac_write_s2flac_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_flac_write_s2flac_decl@
type T;
identifier F = flac_write_s2flac;
parameter list P;
@@
T F(P);

@script:python depends on extract_flac_write_s2flac_decl@
F << extract_flac_write_s2flac_decl.F;
T << extract_flac_write_s2flac_decl.T;
P << extract_flac_write_s2flac_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_flac_write_s2flac_decl_void@
identifier F = flac_write_s2flac;
parameter list P;
@@
void F(P);

@script:python depends on extract_flac_write_s2flac_decl_void@
F << extract_flac_write_s2flac_decl_void.F;
P << extract_flac_write_s2flac_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: g721_decoder
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_g721_decoder_def@
type T;
identifier F = g721_decoder;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_g721_decoder_def@
F << remove_static_g721_decoder_def.F;
T << remove_static_g721_decoder_def.T;
P << remove_static_g721_decoder_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_g721_decoder_def_void@
identifier F = g721_decoder;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_g721_decoder_def_void@
F << remove_static_g721_decoder_def_void.F;
P << remove_static_g721_decoder_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_g721_decoder_decl@
type T;
identifier F = g721_decoder;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_g721_decoder_decl@
F << remove_static_g721_decoder_decl.F;
T << remove_static_g721_decoder_decl.T;
P << remove_static_g721_decoder_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_g721_decoder_decl_void@
identifier F = g721_decoder;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_g721_decoder_decl_void@
F << remove_static_g721_decoder_decl_void.F;
P << remove_static_g721_decoder_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_g721_decoder_def@
type T;
identifier F = g721_decoder;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_g721_decoder_def@
F << extract_g721_decoder_def.F;
T << extract_g721_decoder_def.T;
P << extract_g721_decoder_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_g721_decoder_def_void@
identifier F = g721_decoder;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_g721_decoder_def_void@
F << extract_g721_decoder_def_void.F;
P << extract_g721_decoder_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_g721_decoder_decl@
type T;
identifier F = g721_decoder;
parameter list P;
@@
T F(P);

@script:python depends on extract_g721_decoder_decl@
F << extract_g721_decoder_decl.F;
T << extract_g721_decoder_decl.T;
P << extract_g721_decoder_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_g721_decoder_decl_void@
identifier F = g721_decoder;
parameter list P;
@@
void F(P);

@script:python depends on extract_g721_decoder_decl_void@
F << extract_g721_decoder_decl_void.F;
P << extract_g721_decoder_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: g721_encoder
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_g721_encoder_def@
type T;
identifier F = g721_encoder;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_g721_encoder_def@
F << remove_static_g721_encoder_def.F;
T << remove_static_g721_encoder_def.T;
P << remove_static_g721_encoder_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_g721_encoder_def_void@
identifier F = g721_encoder;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_g721_encoder_def_void@
F << remove_static_g721_encoder_def_void.F;
P << remove_static_g721_encoder_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_g721_encoder_decl@
type T;
identifier F = g721_encoder;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_g721_encoder_decl@
F << remove_static_g721_encoder_decl.F;
T << remove_static_g721_encoder_decl.T;
P << remove_static_g721_encoder_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_g721_encoder_decl_void@
identifier F = g721_encoder;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_g721_encoder_decl_void@
F << remove_static_g721_encoder_decl_void.F;
P << remove_static_g721_encoder_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_g721_encoder_def@
type T;
identifier F = g721_encoder;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_g721_encoder_def@
F << extract_g721_encoder_def.F;
T << extract_g721_encoder_def.T;
P << extract_g721_encoder_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_g721_encoder_def_void@
identifier F = g721_encoder;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_g721_encoder_def_void@
F << extract_g721_encoder_def_void.F;
P << extract_g721_encoder_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_g721_encoder_decl@
type T;
identifier F = g721_encoder;
parameter list P;
@@
T F(P);

@script:python depends on extract_g721_encoder_decl@
F << extract_g721_encoder_decl.F;
T << extract_g721_encoder_decl.T;
P << extract_g721_encoder_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_g721_encoder_decl_void@
identifier F = g721_encoder;
parameter list P;
@@
void F(P);

@script:python depends on extract_g721_encoder_decl_void@
F << extract_g721_encoder_decl_void.F;
P << extract_g721_encoder_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: g723_16_decoder
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_g723_16_decoder_def@
type T;
identifier F = g723_16_decoder;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_g723_16_decoder_def@
F << remove_static_g723_16_decoder_def.F;
T << remove_static_g723_16_decoder_def.T;
P << remove_static_g723_16_decoder_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_g723_16_decoder_def_void@
identifier F = g723_16_decoder;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_g723_16_decoder_def_void@
F << remove_static_g723_16_decoder_def_void.F;
P << remove_static_g723_16_decoder_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_g723_16_decoder_decl@
type T;
identifier F = g723_16_decoder;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_g723_16_decoder_decl@
F << remove_static_g723_16_decoder_decl.F;
T << remove_static_g723_16_decoder_decl.T;
P << remove_static_g723_16_decoder_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_g723_16_decoder_decl_void@
identifier F = g723_16_decoder;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_g723_16_decoder_decl_void@
F << remove_static_g723_16_decoder_decl_void.F;
P << remove_static_g723_16_decoder_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_g723_16_decoder_def@
type T;
identifier F = g723_16_decoder;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_g723_16_decoder_def@
F << extract_g723_16_decoder_def.F;
T << extract_g723_16_decoder_def.T;
P << extract_g723_16_decoder_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_g723_16_decoder_def_void@
identifier F = g723_16_decoder;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_g723_16_decoder_def_void@
F << extract_g723_16_decoder_def_void.F;
P << extract_g723_16_decoder_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_g723_16_decoder_decl@
type T;
identifier F = g723_16_decoder;
parameter list P;
@@
T F(P);

@script:python depends on extract_g723_16_decoder_decl@
F << extract_g723_16_decoder_decl.F;
T << extract_g723_16_decoder_decl.T;
P << extract_g723_16_decoder_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_g723_16_decoder_decl_void@
identifier F = g723_16_decoder;
parameter list P;
@@
void F(P);

@script:python depends on extract_g723_16_decoder_decl_void@
F << extract_g723_16_decoder_decl_void.F;
P << extract_g723_16_decoder_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: g723_16_encoder
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_g723_16_encoder_def@
type T;
identifier F = g723_16_encoder;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_g723_16_encoder_def@
F << remove_static_g723_16_encoder_def.F;
T << remove_static_g723_16_encoder_def.T;
P << remove_static_g723_16_encoder_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_g723_16_encoder_def_void@
identifier F = g723_16_encoder;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_g723_16_encoder_def_void@
F << remove_static_g723_16_encoder_def_void.F;
P << remove_static_g723_16_encoder_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_g723_16_encoder_decl@
type T;
identifier F = g723_16_encoder;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_g723_16_encoder_decl@
F << remove_static_g723_16_encoder_decl.F;
T << remove_static_g723_16_encoder_decl.T;
P << remove_static_g723_16_encoder_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_g723_16_encoder_decl_void@
identifier F = g723_16_encoder;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_g723_16_encoder_decl_void@
F << remove_static_g723_16_encoder_decl_void.F;
P << remove_static_g723_16_encoder_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_g723_16_encoder_def@
type T;
identifier F = g723_16_encoder;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_g723_16_encoder_def@
F << extract_g723_16_encoder_def.F;
T << extract_g723_16_encoder_def.T;
P << extract_g723_16_encoder_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_g723_16_encoder_def_void@
identifier F = g723_16_encoder;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_g723_16_encoder_def_void@
F << extract_g723_16_encoder_def_void.F;
P << extract_g723_16_encoder_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_g723_16_encoder_decl@
type T;
identifier F = g723_16_encoder;
parameter list P;
@@
T F(P);

@script:python depends on extract_g723_16_encoder_decl@
F << extract_g723_16_encoder_decl.F;
T << extract_g723_16_encoder_decl.T;
P << extract_g723_16_encoder_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_g723_16_encoder_decl_void@
identifier F = g723_16_encoder;
parameter list P;
@@
void F(P);

@script:python depends on extract_g723_16_encoder_decl_void@
F << extract_g723_16_encoder_decl_void.F;
P << extract_g723_16_encoder_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: g723_24_decoder
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_g723_24_decoder_def@
type T;
identifier F = g723_24_decoder;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_g723_24_decoder_def@
F << remove_static_g723_24_decoder_def.F;
T << remove_static_g723_24_decoder_def.T;
P << remove_static_g723_24_decoder_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_g723_24_decoder_def_void@
identifier F = g723_24_decoder;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_g723_24_decoder_def_void@
F << remove_static_g723_24_decoder_def_void.F;
P << remove_static_g723_24_decoder_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_g723_24_decoder_decl@
type T;
identifier F = g723_24_decoder;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_g723_24_decoder_decl@
F << remove_static_g723_24_decoder_decl.F;
T << remove_static_g723_24_decoder_decl.T;
P << remove_static_g723_24_decoder_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_g723_24_decoder_decl_void@
identifier F = g723_24_decoder;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_g723_24_decoder_decl_void@
F << remove_static_g723_24_decoder_decl_void.F;
P << remove_static_g723_24_decoder_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_g723_24_decoder_def@
type T;
identifier F = g723_24_decoder;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_g723_24_decoder_def@
F << extract_g723_24_decoder_def.F;
T << extract_g723_24_decoder_def.T;
P << extract_g723_24_decoder_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_g723_24_decoder_def_void@
identifier F = g723_24_decoder;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_g723_24_decoder_def_void@
F << extract_g723_24_decoder_def_void.F;
P << extract_g723_24_decoder_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_g723_24_decoder_decl@
type T;
identifier F = g723_24_decoder;
parameter list P;
@@
T F(P);

@script:python depends on extract_g723_24_decoder_decl@
F << extract_g723_24_decoder_decl.F;
T << extract_g723_24_decoder_decl.T;
P << extract_g723_24_decoder_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_g723_24_decoder_decl_void@
identifier F = g723_24_decoder;
parameter list P;
@@
void F(P);

@script:python depends on extract_g723_24_decoder_decl_void@
F << extract_g723_24_decoder_decl_void.F;
P << extract_g723_24_decoder_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: g723_24_encoder
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_g723_24_encoder_def@
type T;
identifier F = g723_24_encoder;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_g723_24_encoder_def@
F << remove_static_g723_24_encoder_def.F;
T << remove_static_g723_24_encoder_def.T;
P << remove_static_g723_24_encoder_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_g723_24_encoder_def_void@
identifier F = g723_24_encoder;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_g723_24_encoder_def_void@
F << remove_static_g723_24_encoder_def_void.F;
P << remove_static_g723_24_encoder_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_g723_24_encoder_decl@
type T;
identifier F = g723_24_encoder;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_g723_24_encoder_decl@
F << remove_static_g723_24_encoder_decl.F;
T << remove_static_g723_24_encoder_decl.T;
P << remove_static_g723_24_encoder_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_g723_24_encoder_decl_void@
identifier F = g723_24_encoder;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_g723_24_encoder_decl_void@
F << remove_static_g723_24_encoder_decl_void.F;
P << remove_static_g723_24_encoder_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_g723_24_encoder_def@
type T;
identifier F = g723_24_encoder;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_g723_24_encoder_def@
F << extract_g723_24_encoder_def.F;
T << extract_g723_24_encoder_def.T;
P << extract_g723_24_encoder_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_g723_24_encoder_def_void@
identifier F = g723_24_encoder;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_g723_24_encoder_def_void@
F << extract_g723_24_encoder_def_void.F;
P << extract_g723_24_encoder_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_g723_24_encoder_decl@
type T;
identifier F = g723_24_encoder;
parameter list P;
@@
T F(P);

@script:python depends on extract_g723_24_encoder_decl@
F << extract_g723_24_encoder_decl.F;
T << extract_g723_24_encoder_decl.T;
P << extract_g723_24_encoder_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_g723_24_encoder_decl_void@
identifier F = g723_24_encoder;
parameter list P;
@@
void F(P);

@script:python depends on extract_g723_24_encoder_decl_void@
F << extract_g723_24_encoder_decl_void.F;
P << extract_g723_24_encoder_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: g723_40_decoder
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_g723_40_decoder_def@
type T;
identifier F = g723_40_decoder;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_g723_40_decoder_def@
F << remove_static_g723_40_decoder_def.F;
T << remove_static_g723_40_decoder_def.T;
P << remove_static_g723_40_decoder_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_g723_40_decoder_def_void@
identifier F = g723_40_decoder;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_g723_40_decoder_def_void@
F << remove_static_g723_40_decoder_def_void.F;
P << remove_static_g723_40_decoder_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_g723_40_decoder_decl@
type T;
identifier F = g723_40_decoder;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_g723_40_decoder_decl@
F << remove_static_g723_40_decoder_decl.F;
T << remove_static_g723_40_decoder_decl.T;
P << remove_static_g723_40_decoder_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_g723_40_decoder_decl_void@
identifier F = g723_40_decoder;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_g723_40_decoder_decl_void@
F << remove_static_g723_40_decoder_decl_void.F;
P << remove_static_g723_40_decoder_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_g723_40_decoder_def@
type T;
identifier F = g723_40_decoder;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_g723_40_decoder_def@
F << extract_g723_40_decoder_def.F;
T << extract_g723_40_decoder_def.T;
P << extract_g723_40_decoder_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_g723_40_decoder_def_void@
identifier F = g723_40_decoder;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_g723_40_decoder_def_void@
F << extract_g723_40_decoder_def_void.F;
P << extract_g723_40_decoder_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_g723_40_decoder_decl@
type T;
identifier F = g723_40_decoder;
parameter list P;
@@
T F(P);

@script:python depends on extract_g723_40_decoder_decl@
F << extract_g723_40_decoder_decl.F;
T << extract_g723_40_decoder_decl.T;
P << extract_g723_40_decoder_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_g723_40_decoder_decl_void@
identifier F = g723_40_decoder;
parameter list P;
@@
void F(P);

@script:python depends on extract_g723_40_decoder_decl_void@
F << extract_g723_40_decoder_decl_void.F;
P << extract_g723_40_decoder_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: g723_40_encoder
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_g723_40_encoder_def@
type T;
identifier F = g723_40_encoder;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_g723_40_encoder_def@
F << remove_static_g723_40_encoder_def.F;
T << remove_static_g723_40_encoder_def.T;
P << remove_static_g723_40_encoder_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_g723_40_encoder_def_void@
identifier F = g723_40_encoder;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_g723_40_encoder_def_void@
F << remove_static_g723_40_encoder_def_void.F;
P << remove_static_g723_40_encoder_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_g723_40_encoder_decl@
type T;
identifier F = g723_40_encoder;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_g723_40_encoder_decl@
F << remove_static_g723_40_encoder_decl.F;
T << remove_static_g723_40_encoder_decl.T;
P << remove_static_g723_40_encoder_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_g723_40_encoder_decl_void@
identifier F = g723_40_encoder;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_g723_40_encoder_decl_void@
F << remove_static_g723_40_encoder_decl_void.F;
P << remove_static_g723_40_encoder_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_g723_40_encoder_def@
type T;
identifier F = g723_40_encoder;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_g723_40_encoder_def@
F << extract_g723_40_encoder_def.F;
T << extract_g723_40_encoder_def.T;
P << extract_g723_40_encoder_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_g723_40_encoder_def_void@
identifier F = g723_40_encoder;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_g723_40_encoder_def_void@
F << extract_g723_40_encoder_def_void.F;
P << extract_g723_40_encoder_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_g723_40_encoder_decl@
type T;
identifier F = g723_40_encoder;
parameter list P;
@@
T F(P);

@script:python depends on extract_g723_40_encoder_decl@
F << extract_g723_40_encoder_decl.F;
T << extract_g723_40_encoder_decl.T;
P << extract_g723_40_encoder_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_g723_40_encoder_decl_void@
identifier F = g723_40_encoder;
parameter list P;
@@
void F(P);

@script:python depends on extract_g723_40_encoder_decl_void@
F << extract_g723_40_encoder_decl_void.F;
P << extract_g723_40_encoder_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: g72x_close
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_g72x_close_def@
type T;
identifier F = g72x_close;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_g72x_close_def@
F << remove_static_g72x_close_def.F;
T << remove_static_g72x_close_def.T;
P << remove_static_g72x_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_g72x_close_def_void@
identifier F = g72x_close;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_g72x_close_def_void@
F << remove_static_g72x_close_def_void.F;
P << remove_static_g72x_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_g72x_close_decl@
type T;
identifier F = g72x_close;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_g72x_close_decl@
F << remove_static_g72x_close_decl.F;
T << remove_static_g72x_close_decl.T;
P << remove_static_g72x_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_g72x_close_decl_void@
identifier F = g72x_close;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_g72x_close_decl_void@
F << remove_static_g72x_close_decl_void.F;
P << remove_static_g72x_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_g72x_close_def@
type T;
identifier F = g72x_close;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_g72x_close_def@
F << extract_g72x_close_def.F;
T << extract_g72x_close_def.T;
P << extract_g72x_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_g72x_close_def_void@
identifier F = g72x_close;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_g72x_close_def_void@
F << extract_g72x_close_def_void.F;
P << extract_g72x_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_g72x_close_decl@
type T;
identifier F = g72x_close;
parameter list P;
@@
T F(P);

@script:python depends on extract_g72x_close_decl@
F << extract_g72x_close_decl.F;
T << extract_g72x_close_decl.T;
P << extract_g72x_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_g72x_close_decl_void@
identifier F = g72x_close;
parameter list P;
@@
void F(P);

@script:python depends on extract_g72x_close_decl_void@
F << extract_g72x_close_decl_void.F;
P << extract_g72x_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: g72x_read_d
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_g72x_read_d_def@
type T;
identifier F = g72x_read_d;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_g72x_read_d_def@
F << remove_static_g72x_read_d_def.F;
T << remove_static_g72x_read_d_def.T;
P << remove_static_g72x_read_d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_g72x_read_d_def_void@
identifier F = g72x_read_d;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_g72x_read_d_def_void@
F << remove_static_g72x_read_d_def_void.F;
P << remove_static_g72x_read_d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_g72x_read_d_decl@
type T;
identifier F = g72x_read_d;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_g72x_read_d_decl@
F << remove_static_g72x_read_d_decl.F;
T << remove_static_g72x_read_d_decl.T;
P << remove_static_g72x_read_d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_g72x_read_d_decl_void@
identifier F = g72x_read_d;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_g72x_read_d_decl_void@
F << remove_static_g72x_read_d_decl_void.F;
P << remove_static_g72x_read_d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_g72x_read_d_def@
type T;
identifier F = g72x_read_d;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_g72x_read_d_def@
F << extract_g72x_read_d_def.F;
T << extract_g72x_read_d_def.T;
P << extract_g72x_read_d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_g72x_read_d_def_void@
identifier F = g72x_read_d;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_g72x_read_d_def_void@
F << extract_g72x_read_d_def_void.F;
P << extract_g72x_read_d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_g72x_read_d_decl@
type T;
identifier F = g72x_read_d;
parameter list P;
@@
T F(P);

@script:python depends on extract_g72x_read_d_decl@
F << extract_g72x_read_d_decl.F;
T << extract_g72x_read_d_decl.T;
P << extract_g72x_read_d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_g72x_read_d_decl_void@
identifier F = g72x_read_d;
parameter list P;
@@
void F(P);

@script:python depends on extract_g72x_read_d_decl_void@
F << extract_g72x_read_d_decl_void.F;
P << extract_g72x_read_d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: g72x_read_f
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_g72x_read_f_def@
type T;
identifier F = g72x_read_f;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_g72x_read_f_def@
F << remove_static_g72x_read_f_def.F;
T << remove_static_g72x_read_f_def.T;
P << remove_static_g72x_read_f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_g72x_read_f_def_void@
identifier F = g72x_read_f;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_g72x_read_f_def_void@
F << remove_static_g72x_read_f_def_void.F;
P << remove_static_g72x_read_f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_g72x_read_f_decl@
type T;
identifier F = g72x_read_f;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_g72x_read_f_decl@
F << remove_static_g72x_read_f_decl.F;
T << remove_static_g72x_read_f_decl.T;
P << remove_static_g72x_read_f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_g72x_read_f_decl_void@
identifier F = g72x_read_f;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_g72x_read_f_decl_void@
F << remove_static_g72x_read_f_decl_void.F;
P << remove_static_g72x_read_f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_g72x_read_f_def@
type T;
identifier F = g72x_read_f;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_g72x_read_f_def@
F << extract_g72x_read_f_def.F;
T << extract_g72x_read_f_def.T;
P << extract_g72x_read_f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_g72x_read_f_def_void@
identifier F = g72x_read_f;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_g72x_read_f_def_void@
F << extract_g72x_read_f_def_void.F;
P << extract_g72x_read_f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_g72x_read_f_decl@
type T;
identifier F = g72x_read_f;
parameter list P;
@@
T F(P);

@script:python depends on extract_g72x_read_f_decl@
F << extract_g72x_read_f_decl.F;
T << extract_g72x_read_f_decl.T;
P << extract_g72x_read_f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_g72x_read_f_decl_void@
identifier F = g72x_read_f;
parameter list P;
@@
void F(P);

@script:python depends on extract_g72x_read_f_decl_void@
F << extract_g72x_read_f_decl_void.F;
P << extract_g72x_read_f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: g72x_read_i
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_g72x_read_i_def@
type T;
identifier F = g72x_read_i;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_g72x_read_i_def@
F << remove_static_g72x_read_i_def.F;
T << remove_static_g72x_read_i_def.T;
P << remove_static_g72x_read_i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_g72x_read_i_def_void@
identifier F = g72x_read_i;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_g72x_read_i_def_void@
F << remove_static_g72x_read_i_def_void.F;
P << remove_static_g72x_read_i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_g72x_read_i_decl@
type T;
identifier F = g72x_read_i;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_g72x_read_i_decl@
F << remove_static_g72x_read_i_decl.F;
T << remove_static_g72x_read_i_decl.T;
P << remove_static_g72x_read_i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_g72x_read_i_decl_void@
identifier F = g72x_read_i;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_g72x_read_i_decl_void@
F << remove_static_g72x_read_i_decl_void.F;
P << remove_static_g72x_read_i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_g72x_read_i_def@
type T;
identifier F = g72x_read_i;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_g72x_read_i_def@
F << extract_g72x_read_i_def.F;
T << extract_g72x_read_i_def.T;
P << extract_g72x_read_i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_g72x_read_i_def_void@
identifier F = g72x_read_i;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_g72x_read_i_def_void@
F << extract_g72x_read_i_def_void.F;
P << extract_g72x_read_i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_g72x_read_i_decl@
type T;
identifier F = g72x_read_i;
parameter list P;
@@
T F(P);

@script:python depends on extract_g72x_read_i_decl@
F << extract_g72x_read_i_decl.F;
T << extract_g72x_read_i_decl.T;
P << extract_g72x_read_i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_g72x_read_i_decl_void@
identifier F = g72x_read_i;
parameter list P;
@@
void F(P);

@script:python depends on extract_g72x_read_i_decl_void@
F << extract_g72x_read_i_decl_void.F;
P << extract_g72x_read_i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: g72x_read_s
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_g72x_read_s_def@
type T;
identifier F = g72x_read_s;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_g72x_read_s_def@
F << remove_static_g72x_read_s_def.F;
T << remove_static_g72x_read_s_def.T;
P << remove_static_g72x_read_s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_g72x_read_s_def_void@
identifier F = g72x_read_s;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_g72x_read_s_def_void@
F << remove_static_g72x_read_s_def_void.F;
P << remove_static_g72x_read_s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_g72x_read_s_decl@
type T;
identifier F = g72x_read_s;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_g72x_read_s_decl@
F << remove_static_g72x_read_s_decl.F;
T << remove_static_g72x_read_s_decl.T;
P << remove_static_g72x_read_s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_g72x_read_s_decl_void@
identifier F = g72x_read_s;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_g72x_read_s_decl_void@
F << remove_static_g72x_read_s_decl_void.F;
P << remove_static_g72x_read_s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_g72x_read_s_def@
type T;
identifier F = g72x_read_s;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_g72x_read_s_def@
F << extract_g72x_read_s_def.F;
T << extract_g72x_read_s_def.T;
P << extract_g72x_read_s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_g72x_read_s_def_void@
identifier F = g72x_read_s;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_g72x_read_s_def_void@
F << extract_g72x_read_s_def_void.F;
P << extract_g72x_read_s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_g72x_read_s_decl@
type T;
identifier F = g72x_read_s;
parameter list P;
@@
T F(P);

@script:python depends on extract_g72x_read_s_decl@
F << extract_g72x_read_s_decl.F;
T << extract_g72x_read_s_decl.T;
P << extract_g72x_read_s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_g72x_read_s_decl_void@
identifier F = g72x_read_s;
parameter list P;
@@
void F(P);

@script:python depends on extract_g72x_read_s_decl_void@
F << extract_g72x_read_s_decl_void.F;
P << extract_g72x_read_s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: g72x_seek
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_g72x_seek_def@
type T;
identifier F = g72x_seek;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_g72x_seek_def@
F << remove_static_g72x_seek_def.F;
T << remove_static_g72x_seek_def.T;
P << remove_static_g72x_seek_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_g72x_seek_def_void@
identifier F = g72x_seek;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_g72x_seek_def_void@
F << remove_static_g72x_seek_def_void.F;
P << remove_static_g72x_seek_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_g72x_seek_decl@
type T;
identifier F = g72x_seek;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_g72x_seek_decl@
F << remove_static_g72x_seek_decl.F;
T << remove_static_g72x_seek_decl.T;
P << remove_static_g72x_seek_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_g72x_seek_decl_void@
identifier F = g72x_seek;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_g72x_seek_decl_void@
F << remove_static_g72x_seek_decl_void.F;
P << remove_static_g72x_seek_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_g72x_seek_def@
type T;
identifier F = g72x_seek;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_g72x_seek_def@
F << extract_g72x_seek_def.F;
T << extract_g72x_seek_def.T;
P << extract_g72x_seek_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_g72x_seek_def_void@
identifier F = g72x_seek;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_g72x_seek_def_void@
F << extract_g72x_seek_def_void.F;
P << extract_g72x_seek_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_g72x_seek_decl@
type T;
identifier F = g72x_seek;
parameter list P;
@@
T F(P);

@script:python depends on extract_g72x_seek_decl@
F << extract_g72x_seek_decl.F;
T << extract_g72x_seek_decl.T;
P << extract_g72x_seek_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_g72x_seek_decl_void@
identifier F = g72x_seek;
parameter list P;
@@
void F(P);

@script:python depends on extract_g72x_seek_decl_void@
F << extract_g72x_seek_decl_void.F;
P << extract_g72x_seek_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: g72x_write_d
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_g72x_write_d_def@
type T;
identifier F = g72x_write_d;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_g72x_write_d_def@
F << remove_static_g72x_write_d_def.F;
T << remove_static_g72x_write_d_def.T;
P << remove_static_g72x_write_d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_g72x_write_d_def_void@
identifier F = g72x_write_d;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_g72x_write_d_def_void@
F << remove_static_g72x_write_d_def_void.F;
P << remove_static_g72x_write_d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_g72x_write_d_decl@
type T;
identifier F = g72x_write_d;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_g72x_write_d_decl@
F << remove_static_g72x_write_d_decl.F;
T << remove_static_g72x_write_d_decl.T;
P << remove_static_g72x_write_d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_g72x_write_d_decl_void@
identifier F = g72x_write_d;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_g72x_write_d_decl_void@
F << remove_static_g72x_write_d_decl_void.F;
P << remove_static_g72x_write_d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_g72x_write_d_def@
type T;
identifier F = g72x_write_d;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_g72x_write_d_def@
F << extract_g72x_write_d_def.F;
T << extract_g72x_write_d_def.T;
P << extract_g72x_write_d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_g72x_write_d_def_void@
identifier F = g72x_write_d;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_g72x_write_d_def_void@
F << extract_g72x_write_d_def_void.F;
P << extract_g72x_write_d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_g72x_write_d_decl@
type T;
identifier F = g72x_write_d;
parameter list P;
@@
T F(P);

@script:python depends on extract_g72x_write_d_decl@
F << extract_g72x_write_d_decl.F;
T << extract_g72x_write_d_decl.T;
P << extract_g72x_write_d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_g72x_write_d_decl_void@
identifier F = g72x_write_d;
parameter list P;
@@
void F(P);

@script:python depends on extract_g72x_write_d_decl_void@
F << extract_g72x_write_d_decl_void.F;
P << extract_g72x_write_d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: g72x_write_f
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_g72x_write_f_def@
type T;
identifier F = g72x_write_f;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_g72x_write_f_def@
F << remove_static_g72x_write_f_def.F;
T << remove_static_g72x_write_f_def.T;
P << remove_static_g72x_write_f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_g72x_write_f_def_void@
identifier F = g72x_write_f;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_g72x_write_f_def_void@
F << remove_static_g72x_write_f_def_void.F;
P << remove_static_g72x_write_f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_g72x_write_f_decl@
type T;
identifier F = g72x_write_f;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_g72x_write_f_decl@
F << remove_static_g72x_write_f_decl.F;
T << remove_static_g72x_write_f_decl.T;
P << remove_static_g72x_write_f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_g72x_write_f_decl_void@
identifier F = g72x_write_f;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_g72x_write_f_decl_void@
F << remove_static_g72x_write_f_decl_void.F;
P << remove_static_g72x_write_f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_g72x_write_f_def@
type T;
identifier F = g72x_write_f;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_g72x_write_f_def@
F << extract_g72x_write_f_def.F;
T << extract_g72x_write_f_def.T;
P << extract_g72x_write_f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_g72x_write_f_def_void@
identifier F = g72x_write_f;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_g72x_write_f_def_void@
F << extract_g72x_write_f_def_void.F;
P << extract_g72x_write_f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_g72x_write_f_decl@
type T;
identifier F = g72x_write_f;
parameter list P;
@@
T F(P);

@script:python depends on extract_g72x_write_f_decl@
F << extract_g72x_write_f_decl.F;
T << extract_g72x_write_f_decl.T;
P << extract_g72x_write_f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_g72x_write_f_decl_void@
identifier F = g72x_write_f;
parameter list P;
@@
void F(P);

@script:python depends on extract_g72x_write_f_decl_void@
F << extract_g72x_write_f_decl_void.F;
P << extract_g72x_write_f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: g72x_write_i
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_g72x_write_i_def@
type T;
identifier F = g72x_write_i;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_g72x_write_i_def@
F << remove_static_g72x_write_i_def.F;
T << remove_static_g72x_write_i_def.T;
P << remove_static_g72x_write_i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_g72x_write_i_def_void@
identifier F = g72x_write_i;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_g72x_write_i_def_void@
F << remove_static_g72x_write_i_def_void.F;
P << remove_static_g72x_write_i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_g72x_write_i_decl@
type T;
identifier F = g72x_write_i;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_g72x_write_i_decl@
F << remove_static_g72x_write_i_decl.F;
T << remove_static_g72x_write_i_decl.T;
P << remove_static_g72x_write_i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_g72x_write_i_decl_void@
identifier F = g72x_write_i;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_g72x_write_i_decl_void@
F << remove_static_g72x_write_i_decl_void.F;
P << remove_static_g72x_write_i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_g72x_write_i_def@
type T;
identifier F = g72x_write_i;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_g72x_write_i_def@
F << extract_g72x_write_i_def.F;
T << extract_g72x_write_i_def.T;
P << extract_g72x_write_i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_g72x_write_i_def_void@
identifier F = g72x_write_i;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_g72x_write_i_def_void@
F << extract_g72x_write_i_def_void.F;
P << extract_g72x_write_i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_g72x_write_i_decl@
type T;
identifier F = g72x_write_i;
parameter list P;
@@
T F(P);

@script:python depends on extract_g72x_write_i_decl@
F << extract_g72x_write_i_decl.F;
T << extract_g72x_write_i_decl.T;
P << extract_g72x_write_i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_g72x_write_i_decl_void@
identifier F = g72x_write_i;
parameter list P;
@@
void F(P);

@script:python depends on extract_g72x_write_i_decl_void@
F << extract_g72x_write_i_decl_void.F;
P << extract_g72x_write_i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: g72x_write_s
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_g72x_write_s_def@
type T;
identifier F = g72x_write_s;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_g72x_write_s_def@
F << remove_static_g72x_write_s_def.F;
T << remove_static_g72x_write_s_def.T;
P << remove_static_g72x_write_s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_g72x_write_s_def_void@
identifier F = g72x_write_s;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_g72x_write_s_def_void@
F << remove_static_g72x_write_s_def_void.F;
P << remove_static_g72x_write_s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_g72x_write_s_decl@
type T;
identifier F = g72x_write_s;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_g72x_write_s_decl@
F << remove_static_g72x_write_s_decl.F;
T << remove_static_g72x_write_s_decl.T;
P << remove_static_g72x_write_s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_g72x_write_s_decl_void@
identifier F = g72x_write_s;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_g72x_write_s_decl_void@
F << remove_static_g72x_write_s_decl_void.F;
P << remove_static_g72x_write_s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_g72x_write_s_def@
type T;
identifier F = g72x_write_s;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_g72x_write_s_def@
F << extract_g72x_write_s_def.F;
T << extract_g72x_write_s_def.T;
P << extract_g72x_write_s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_g72x_write_s_def_void@
identifier F = g72x_write_s;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_g72x_write_s_def_void@
F << extract_g72x_write_s_def_void.F;
P << extract_g72x_write_s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_g72x_write_s_decl@
type T;
identifier F = g72x_write_s;
parameter list P;
@@
T F(P);

@script:python depends on extract_g72x_write_s_decl@
F << extract_g72x_write_s_decl.F;
T << extract_g72x_write_s_decl.T;
P << extract_g72x_write_s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_g72x_write_s_decl_void@
identifier F = g72x_write_s;
parameter list P;
@@
void F(P);

@script:python depends on extract_g72x_write_s_decl_void@
F << extract_g72x_write_s_decl_void.F;
P << extract_g72x_write_s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: gsm610_close
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_gsm610_close_def@
type T;
identifier F = gsm610_close;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_gsm610_close_def@
F << remove_static_gsm610_close_def.F;
T << remove_static_gsm610_close_def.T;
P << remove_static_gsm610_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_gsm610_close_def_void@
identifier F = gsm610_close;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_gsm610_close_def_void@
F << remove_static_gsm610_close_def_void.F;
P << remove_static_gsm610_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_gsm610_close_decl@
type T;
identifier F = gsm610_close;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_gsm610_close_decl@
F << remove_static_gsm610_close_decl.F;
T << remove_static_gsm610_close_decl.T;
P << remove_static_gsm610_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_gsm610_close_decl_void@
identifier F = gsm610_close;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_gsm610_close_decl_void@
F << remove_static_gsm610_close_decl_void.F;
P << remove_static_gsm610_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_gsm610_close_def@
type T;
identifier F = gsm610_close;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_gsm610_close_def@
F << extract_gsm610_close_def.F;
T << extract_gsm610_close_def.T;
P << extract_gsm610_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_gsm610_close_def_void@
identifier F = gsm610_close;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_gsm610_close_def_void@
F << extract_gsm610_close_def_void.F;
P << extract_gsm610_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_gsm610_close_decl@
type T;
identifier F = gsm610_close;
parameter list P;
@@
T F(P);

@script:python depends on extract_gsm610_close_decl@
F << extract_gsm610_close_decl.F;
T << extract_gsm610_close_decl.T;
P << extract_gsm610_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_gsm610_close_decl_void@
identifier F = gsm610_close;
parameter list P;
@@
void F(P);

@script:python depends on extract_gsm610_close_decl_void@
F << extract_gsm610_close_decl_void.F;
P << extract_gsm610_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: gsm610_decode_block
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_gsm610_decode_block_def@
type T;
identifier F = gsm610_decode_block;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_gsm610_decode_block_def@
F << remove_static_gsm610_decode_block_def.F;
T << remove_static_gsm610_decode_block_def.T;
P << remove_static_gsm610_decode_block_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_gsm610_decode_block_def_void@
identifier F = gsm610_decode_block;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_gsm610_decode_block_def_void@
F << remove_static_gsm610_decode_block_def_void.F;
P << remove_static_gsm610_decode_block_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_gsm610_decode_block_decl@
type T;
identifier F = gsm610_decode_block;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_gsm610_decode_block_decl@
F << remove_static_gsm610_decode_block_decl.F;
T << remove_static_gsm610_decode_block_decl.T;
P << remove_static_gsm610_decode_block_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_gsm610_decode_block_decl_void@
identifier F = gsm610_decode_block;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_gsm610_decode_block_decl_void@
F << remove_static_gsm610_decode_block_decl_void.F;
P << remove_static_gsm610_decode_block_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_gsm610_decode_block_def@
type T;
identifier F = gsm610_decode_block;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_gsm610_decode_block_def@
F << extract_gsm610_decode_block_def.F;
T << extract_gsm610_decode_block_def.T;
P << extract_gsm610_decode_block_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_gsm610_decode_block_def_void@
identifier F = gsm610_decode_block;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_gsm610_decode_block_def_void@
F << extract_gsm610_decode_block_def_void.F;
P << extract_gsm610_decode_block_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_gsm610_decode_block_decl@
type T;
identifier F = gsm610_decode_block;
parameter list P;
@@
T F(P);

@script:python depends on extract_gsm610_decode_block_decl@
F << extract_gsm610_decode_block_decl.F;
T << extract_gsm610_decode_block_decl.T;
P << extract_gsm610_decode_block_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_gsm610_decode_block_decl_void@
identifier F = gsm610_decode_block;
parameter list P;
@@
void F(P);

@script:python depends on extract_gsm610_decode_block_decl_void@
F << extract_gsm610_decode_block_decl_void.F;
P << extract_gsm610_decode_block_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: gsm610_encode_block
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_gsm610_encode_block_def@
type T;
identifier F = gsm610_encode_block;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_gsm610_encode_block_def@
F << remove_static_gsm610_encode_block_def.F;
T << remove_static_gsm610_encode_block_def.T;
P << remove_static_gsm610_encode_block_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_gsm610_encode_block_def_void@
identifier F = gsm610_encode_block;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_gsm610_encode_block_def_void@
F << remove_static_gsm610_encode_block_def_void.F;
P << remove_static_gsm610_encode_block_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_gsm610_encode_block_decl@
type T;
identifier F = gsm610_encode_block;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_gsm610_encode_block_decl@
F << remove_static_gsm610_encode_block_decl.F;
T << remove_static_gsm610_encode_block_decl.T;
P << remove_static_gsm610_encode_block_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_gsm610_encode_block_decl_void@
identifier F = gsm610_encode_block;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_gsm610_encode_block_decl_void@
F << remove_static_gsm610_encode_block_decl_void.F;
P << remove_static_gsm610_encode_block_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_gsm610_encode_block_def@
type T;
identifier F = gsm610_encode_block;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_gsm610_encode_block_def@
F << extract_gsm610_encode_block_def.F;
T << extract_gsm610_encode_block_def.T;
P << extract_gsm610_encode_block_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_gsm610_encode_block_def_void@
identifier F = gsm610_encode_block;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_gsm610_encode_block_def_void@
F << extract_gsm610_encode_block_def_void.F;
P << extract_gsm610_encode_block_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_gsm610_encode_block_decl@
type T;
identifier F = gsm610_encode_block;
parameter list P;
@@
T F(P);

@script:python depends on extract_gsm610_encode_block_decl@
F << extract_gsm610_encode_block_decl.F;
T << extract_gsm610_encode_block_decl.T;
P << extract_gsm610_encode_block_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_gsm610_encode_block_decl_void@
identifier F = gsm610_encode_block;
parameter list P;
@@
void F(P);

@script:python depends on extract_gsm610_encode_block_decl_void@
F << extract_gsm610_encode_block_decl_void.F;
P << extract_gsm610_encode_block_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: gsm610_read_d
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_gsm610_read_d_def@
type T;
identifier F = gsm610_read_d;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_gsm610_read_d_def@
F << remove_static_gsm610_read_d_def.F;
T << remove_static_gsm610_read_d_def.T;
P << remove_static_gsm610_read_d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_gsm610_read_d_def_void@
identifier F = gsm610_read_d;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_gsm610_read_d_def_void@
F << remove_static_gsm610_read_d_def_void.F;
P << remove_static_gsm610_read_d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_gsm610_read_d_decl@
type T;
identifier F = gsm610_read_d;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_gsm610_read_d_decl@
F << remove_static_gsm610_read_d_decl.F;
T << remove_static_gsm610_read_d_decl.T;
P << remove_static_gsm610_read_d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_gsm610_read_d_decl_void@
identifier F = gsm610_read_d;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_gsm610_read_d_decl_void@
F << remove_static_gsm610_read_d_decl_void.F;
P << remove_static_gsm610_read_d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_gsm610_read_d_def@
type T;
identifier F = gsm610_read_d;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_gsm610_read_d_def@
F << extract_gsm610_read_d_def.F;
T << extract_gsm610_read_d_def.T;
P << extract_gsm610_read_d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_gsm610_read_d_def_void@
identifier F = gsm610_read_d;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_gsm610_read_d_def_void@
F << extract_gsm610_read_d_def_void.F;
P << extract_gsm610_read_d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_gsm610_read_d_decl@
type T;
identifier F = gsm610_read_d;
parameter list P;
@@
T F(P);

@script:python depends on extract_gsm610_read_d_decl@
F << extract_gsm610_read_d_decl.F;
T << extract_gsm610_read_d_decl.T;
P << extract_gsm610_read_d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_gsm610_read_d_decl_void@
identifier F = gsm610_read_d;
parameter list P;
@@
void F(P);

@script:python depends on extract_gsm610_read_d_decl_void@
F << extract_gsm610_read_d_decl_void.F;
P << extract_gsm610_read_d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: gsm610_read_f
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_gsm610_read_f_def@
type T;
identifier F = gsm610_read_f;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_gsm610_read_f_def@
F << remove_static_gsm610_read_f_def.F;
T << remove_static_gsm610_read_f_def.T;
P << remove_static_gsm610_read_f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_gsm610_read_f_def_void@
identifier F = gsm610_read_f;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_gsm610_read_f_def_void@
F << remove_static_gsm610_read_f_def_void.F;
P << remove_static_gsm610_read_f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_gsm610_read_f_decl@
type T;
identifier F = gsm610_read_f;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_gsm610_read_f_decl@
F << remove_static_gsm610_read_f_decl.F;
T << remove_static_gsm610_read_f_decl.T;
P << remove_static_gsm610_read_f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_gsm610_read_f_decl_void@
identifier F = gsm610_read_f;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_gsm610_read_f_decl_void@
F << remove_static_gsm610_read_f_decl_void.F;
P << remove_static_gsm610_read_f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_gsm610_read_f_def@
type T;
identifier F = gsm610_read_f;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_gsm610_read_f_def@
F << extract_gsm610_read_f_def.F;
T << extract_gsm610_read_f_def.T;
P << extract_gsm610_read_f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_gsm610_read_f_def_void@
identifier F = gsm610_read_f;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_gsm610_read_f_def_void@
F << extract_gsm610_read_f_def_void.F;
P << extract_gsm610_read_f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_gsm610_read_f_decl@
type T;
identifier F = gsm610_read_f;
parameter list P;
@@
T F(P);

@script:python depends on extract_gsm610_read_f_decl@
F << extract_gsm610_read_f_decl.F;
T << extract_gsm610_read_f_decl.T;
P << extract_gsm610_read_f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_gsm610_read_f_decl_void@
identifier F = gsm610_read_f;
parameter list P;
@@
void F(P);

@script:python depends on extract_gsm610_read_f_decl_void@
F << extract_gsm610_read_f_decl_void.F;
P << extract_gsm610_read_f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: gsm610_read_i
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_gsm610_read_i_def@
type T;
identifier F = gsm610_read_i;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_gsm610_read_i_def@
F << remove_static_gsm610_read_i_def.F;
T << remove_static_gsm610_read_i_def.T;
P << remove_static_gsm610_read_i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_gsm610_read_i_def_void@
identifier F = gsm610_read_i;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_gsm610_read_i_def_void@
F << remove_static_gsm610_read_i_def_void.F;
P << remove_static_gsm610_read_i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_gsm610_read_i_decl@
type T;
identifier F = gsm610_read_i;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_gsm610_read_i_decl@
F << remove_static_gsm610_read_i_decl.F;
T << remove_static_gsm610_read_i_decl.T;
P << remove_static_gsm610_read_i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_gsm610_read_i_decl_void@
identifier F = gsm610_read_i;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_gsm610_read_i_decl_void@
F << remove_static_gsm610_read_i_decl_void.F;
P << remove_static_gsm610_read_i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_gsm610_read_i_def@
type T;
identifier F = gsm610_read_i;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_gsm610_read_i_def@
F << extract_gsm610_read_i_def.F;
T << extract_gsm610_read_i_def.T;
P << extract_gsm610_read_i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_gsm610_read_i_def_void@
identifier F = gsm610_read_i;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_gsm610_read_i_def_void@
F << extract_gsm610_read_i_def_void.F;
P << extract_gsm610_read_i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_gsm610_read_i_decl@
type T;
identifier F = gsm610_read_i;
parameter list P;
@@
T F(P);

@script:python depends on extract_gsm610_read_i_decl@
F << extract_gsm610_read_i_decl.F;
T << extract_gsm610_read_i_decl.T;
P << extract_gsm610_read_i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_gsm610_read_i_decl_void@
identifier F = gsm610_read_i;
parameter list P;
@@
void F(P);

@script:python depends on extract_gsm610_read_i_decl_void@
F << extract_gsm610_read_i_decl_void.F;
P << extract_gsm610_read_i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: gsm610_read_s
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_gsm610_read_s_def@
type T;
identifier F = gsm610_read_s;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_gsm610_read_s_def@
F << remove_static_gsm610_read_s_def.F;
T << remove_static_gsm610_read_s_def.T;
P << remove_static_gsm610_read_s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_gsm610_read_s_def_void@
identifier F = gsm610_read_s;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_gsm610_read_s_def_void@
F << remove_static_gsm610_read_s_def_void.F;
P << remove_static_gsm610_read_s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_gsm610_read_s_decl@
type T;
identifier F = gsm610_read_s;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_gsm610_read_s_decl@
F << remove_static_gsm610_read_s_decl.F;
T << remove_static_gsm610_read_s_decl.T;
P << remove_static_gsm610_read_s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_gsm610_read_s_decl_void@
identifier F = gsm610_read_s;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_gsm610_read_s_decl_void@
F << remove_static_gsm610_read_s_decl_void.F;
P << remove_static_gsm610_read_s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_gsm610_read_s_def@
type T;
identifier F = gsm610_read_s;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_gsm610_read_s_def@
F << extract_gsm610_read_s_def.F;
T << extract_gsm610_read_s_def.T;
P << extract_gsm610_read_s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_gsm610_read_s_def_void@
identifier F = gsm610_read_s;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_gsm610_read_s_def_void@
F << extract_gsm610_read_s_def_void.F;
P << extract_gsm610_read_s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_gsm610_read_s_decl@
type T;
identifier F = gsm610_read_s;
parameter list P;
@@
T F(P);

@script:python depends on extract_gsm610_read_s_decl@
F << extract_gsm610_read_s_decl.F;
T << extract_gsm610_read_s_decl.T;
P << extract_gsm610_read_s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_gsm610_read_s_decl_void@
identifier F = gsm610_read_s;
parameter list P;
@@
void F(P);

@script:python depends on extract_gsm610_read_s_decl_void@
F << extract_gsm610_read_s_decl_void.F;
P << extract_gsm610_read_s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: gsm610_seek
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_gsm610_seek_def@
type T;
identifier F = gsm610_seek;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_gsm610_seek_def@
F << remove_static_gsm610_seek_def.F;
T << remove_static_gsm610_seek_def.T;
P << remove_static_gsm610_seek_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_gsm610_seek_def_void@
identifier F = gsm610_seek;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_gsm610_seek_def_void@
F << remove_static_gsm610_seek_def_void.F;
P << remove_static_gsm610_seek_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_gsm610_seek_decl@
type T;
identifier F = gsm610_seek;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_gsm610_seek_decl@
F << remove_static_gsm610_seek_decl.F;
T << remove_static_gsm610_seek_decl.T;
P << remove_static_gsm610_seek_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_gsm610_seek_decl_void@
identifier F = gsm610_seek;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_gsm610_seek_decl_void@
F << remove_static_gsm610_seek_decl_void.F;
P << remove_static_gsm610_seek_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_gsm610_seek_def@
type T;
identifier F = gsm610_seek;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_gsm610_seek_def@
F << extract_gsm610_seek_def.F;
T << extract_gsm610_seek_def.T;
P << extract_gsm610_seek_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_gsm610_seek_def_void@
identifier F = gsm610_seek;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_gsm610_seek_def_void@
F << extract_gsm610_seek_def_void.F;
P << extract_gsm610_seek_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_gsm610_seek_decl@
type T;
identifier F = gsm610_seek;
parameter list P;
@@
T F(P);

@script:python depends on extract_gsm610_seek_decl@
F << extract_gsm610_seek_decl.F;
T << extract_gsm610_seek_decl.T;
P << extract_gsm610_seek_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_gsm610_seek_decl_void@
identifier F = gsm610_seek;
parameter list P;
@@
void F(P);

@script:python depends on extract_gsm610_seek_decl_void@
F << extract_gsm610_seek_decl_void.F;
P << extract_gsm610_seek_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: gsm610_wav_decode_block
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_gsm610_wav_decode_block_def@
type T;
identifier F = gsm610_wav_decode_block;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_gsm610_wav_decode_block_def@
F << remove_static_gsm610_wav_decode_block_def.F;
T << remove_static_gsm610_wav_decode_block_def.T;
P << remove_static_gsm610_wav_decode_block_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_gsm610_wav_decode_block_def_void@
identifier F = gsm610_wav_decode_block;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_gsm610_wav_decode_block_def_void@
F << remove_static_gsm610_wav_decode_block_def_void.F;
P << remove_static_gsm610_wav_decode_block_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_gsm610_wav_decode_block_decl@
type T;
identifier F = gsm610_wav_decode_block;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_gsm610_wav_decode_block_decl@
F << remove_static_gsm610_wav_decode_block_decl.F;
T << remove_static_gsm610_wav_decode_block_decl.T;
P << remove_static_gsm610_wav_decode_block_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_gsm610_wav_decode_block_decl_void@
identifier F = gsm610_wav_decode_block;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_gsm610_wav_decode_block_decl_void@
F << remove_static_gsm610_wav_decode_block_decl_void.F;
P << remove_static_gsm610_wav_decode_block_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_gsm610_wav_decode_block_def@
type T;
identifier F = gsm610_wav_decode_block;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_gsm610_wav_decode_block_def@
F << extract_gsm610_wav_decode_block_def.F;
T << extract_gsm610_wav_decode_block_def.T;
P << extract_gsm610_wav_decode_block_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_gsm610_wav_decode_block_def_void@
identifier F = gsm610_wav_decode_block;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_gsm610_wav_decode_block_def_void@
F << extract_gsm610_wav_decode_block_def_void.F;
P << extract_gsm610_wav_decode_block_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_gsm610_wav_decode_block_decl@
type T;
identifier F = gsm610_wav_decode_block;
parameter list P;
@@
T F(P);

@script:python depends on extract_gsm610_wav_decode_block_decl@
F << extract_gsm610_wav_decode_block_decl.F;
T << extract_gsm610_wav_decode_block_decl.T;
P << extract_gsm610_wav_decode_block_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_gsm610_wav_decode_block_decl_void@
identifier F = gsm610_wav_decode_block;
parameter list P;
@@
void F(P);

@script:python depends on extract_gsm610_wav_decode_block_decl_void@
F << extract_gsm610_wav_decode_block_decl_void.F;
P << extract_gsm610_wav_decode_block_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: gsm610_wav_encode_block
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_gsm610_wav_encode_block_def@
type T;
identifier F = gsm610_wav_encode_block;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_gsm610_wav_encode_block_def@
F << remove_static_gsm610_wav_encode_block_def.F;
T << remove_static_gsm610_wav_encode_block_def.T;
P << remove_static_gsm610_wav_encode_block_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_gsm610_wav_encode_block_def_void@
identifier F = gsm610_wav_encode_block;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_gsm610_wav_encode_block_def_void@
F << remove_static_gsm610_wav_encode_block_def_void.F;
P << remove_static_gsm610_wav_encode_block_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_gsm610_wav_encode_block_decl@
type T;
identifier F = gsm610_wav_encode_block;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_gsm610_wav_encode_block_decl@
F << remove_static_gsm610_wav_encode_block_decl.F;
T << remove_static_gsm610_wav_encode_block_decl.T;
P << remove_static_gsm610_wav_encode_block_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_gsm610_wav_encode_block_decl_void@
identifier F = gsm610_wav_encode_block;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_gsm610_wav_encode_block_decl_void@
F << remove_static_gsm610_wav_encode_block_decl_void.F;
P << remove_static_gsm610_wav_encode_block_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_gsm610_wav_encode_block_def@
type T;
identifier F = gsm610_wav_encode_block;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_gsm610_wav_encode_block_def@
F << extract_gsm610_wav_encode_block_def.F;
T << extract_gsm610_wav_encode_block_def.T;
P << extract_gsm610_wav_encode_block_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_gsm610_wav_encode_block_def_void@
identifier F = gsm610_wav_encode_block;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_gsm610_wav_encode_block_def_void@
F << extract_gsm610_wav_encode_block_def_void.F;
P << extract_gsm610_wav_encode_block_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_gsm610_wav_encode_block_decl@
type T;
identifier F = gsm610_wav_encode_block;
parameter list P;
@@
T F(P);

@script:python depends on extract_gsm610_wav_encode_block_decl@
F << extract_gsm610_wav_encode_block_decl.F;
T << extract_gsm610_wav_encode_block_decl.T;
P << extract_gsm610_wav_encode_block_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_gsm610_wav_encode_block_decl_void@
identifier F = gsm610_wav_encode_block;
parameter list P;
@@
void F(P);

@script:python depends on extract_gsm610_wav_encode_block_decl_void@
F << extract_gsm610_wav_encode_block_decl_void.F;
P << extract_gsm610_wav_encode_block_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: gsm610_write_d
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_gsm610_write_d_def@
type T;
identifier F = gsm610_write_d;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_gsm610_write_d_def@
F << remove_static_gsm610_write_d_def.F;
T << remove_static_gsm610_write_d_def.T;
P << remove_static_gsm610_write_d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_gsm610_write_d_def_void@
identifier F = gsm610_write_d;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_gsm610_write_d_def_void@
F << remove_static_gsm610_write_d_def_void.F;
P << remove_static_gsm610_write_d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_gsm610_write_d_decl@
type T;
identifier F = gsm610_write_d;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_gsm610_write_d_decl@
F << remove_static_gsm610_write_d_decl.F;
T << remove_static_gsm610_write_d_decl.T;
P << remove_static_gsm610_write_d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_gsm610_write_d_decl_void@
identifier F = gsm610_write_d;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_gsm610_write_d_decl_void@
F << remove_static_gsm610_write_d_decl_void.F;
P << remove_static_gsm610_write_d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_gsm610_write_d_def@
type T;
identifier F = gsm610_write_d;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_gsm610_write_d_def@
F << extract_gsm610_write_d_def.F;
T << extract_gsm610_write_d_def.T;
P << extract_gsm610_write_d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_gsm610_write_d_def_void@
identifier F = gsm610_write_d;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_gsm610_write_d_def_void@
F << extract_gsm610_write_d_def_void.F;
P << extract_gsm610_write_d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_gsm610_write_d_decl@
type T;
identifier F = gsm610_write_d;
parameter list P;
@@
T F(P);

@script:python depends on extract_gsm610_write_d_decl@
F << extract_gsm610_write_d_decl.F;
T << extract_gsm610_write_d_decl.T;
P << extract_gsm610_write_d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_gsm610_write_d_decl_void@
identifier F = gsm610_write_d;
parameter list P;
@@
void F(P);

@script:python depends on extract_gsm610_write_d_decl_void@
F << extract_gsm610_write_d_decl_void.F;
P << extract_gsm610_write_d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: gsm610_write_f
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_gsm610_write_f_def@
type T;
identifier F = gsm610_write_f;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_gsm610_write_f_def@
F << remove_static_gsm610_write_f_def.F;
T << remove_static_gsm610_write_f_def.T;
P << remove_static_gsm610_write_f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_gsm610_write_f_def_void@
identifier F = gsm610_write_f;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_gsm610_write_f_def_void@
F << remove_static_gsm610_write_f_def_void.F;
P << remove_static_gsm610_write_f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_gsm610_write_f_decl@
type T;
identifier F = gsm610_write_f;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_gsm610_write_f_decl@
F << remove_static_gsm610_write_f_decl.F;
T << remove_static_gsm610_write_f_decl.T;
P << remove_static_gsm610_write_f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_gsm610_write_f_decl_void@
identifier F = gsm610_write_f;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_gsm610_write_f_decl_void@
F << remove_static_gsm610_write_f_decl_void.F;
P << remove_static_gsm610_write_f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_gsm610_write_f_def@
type T;
identifier F = gsm610_write_f;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_gsm610_write_f_def@
F << extract_gsm610_write_f_def.F;
T << extract_gsm610_write_f_def.T;
P << extract_gsm610_write_f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_gsm610_write_f_def_void@
identifier F = gsm610_write_f;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_gsm610_write_f_def_void@
F << extract_gsm610_write_f_def_void.F;
P << extract_gsm610_write_f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_gsm610_write_f_decl@
type T;
identifier F = gsm610_write_f;
parameter list P;
@@
T F(P);

@script:python depends on extract_gsm610_write_f_decl@
F << extract_gsm610_write_f_decl.F;
T << extract_gsm610_write_f_decl.T;
P << extract_gsm610_write_f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_gsm610_write_f_decl_void@
identifier F = gsm610_write_f;
parameter list P;
@@
void F(P);

@script:python depends on extract_gsm610_write_f_decl_void@
F << extract_gsm610_write_f_decl_void.F;
P << extract_gsm610_write_f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: gsm610_write_i
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_gsm610_write_i_def@
type T;
identifier F = gsm610_write_i;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_gsm610_write_i_def@
F << remove_static_gsm610_write_i_def.F;
T << remove_static_gsm610_write_i_def.T;
P << remove_static_gsm610_write_i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_gsm610_write_i_def_void@
identifier F = gsm610_write_i;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_gsm610_write_i_def_void@
F << remove_static_gsm610_write_i_def_void.F;
P << remove_static_gsm610_write_i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_gsm610_write_i_decl@
type T;
identifier F = gsm610_write_i;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_gsm610_write_i_decl@
F << remove_static_gsm610_write_i_decl.F;
T << remove_static_gsm610_write_i_decl.T;
P << remove_static_gsm610_write_i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_gsm610_write_i_decl_void@
identifier F = gsm610_write_i;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_gsm610_write_i_decl_void@
F << remove_static_gsm610_write_i_decl_void.F;
P << remove_static_gsm610_write_i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_gsm610_write_i_def@
type T;
identifier F = gsm610_write_i;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_gsm610_write_i_def@
F << extract_gsm610_write_i_def.F;
T << extract_gsm610_write_i_def.T;
P << extract_gsm610_write_i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_gsm610_write_i_def_void@
identifier F = gsm610_write_i;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_gsm610_write_i_def_void@
F << extract_gsm610_write_i_def_void.F;
P << extract_gsm610_write_i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_gsm610_write_i_decl@
type T;
identifier F = gsm610_write_i;
parameter list P;
@@
T F(P);

@script:python depends on extract_gsm610_write_i_decl@
F << extract_gsm610_write_i_decl.F;
T << extract_gsm610_write_i_decl.T;
P << extract_gsm610_write_i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_gsm610_write_i_decl_void@
identifier F = gsm610_write_i;
parameter list P;
@@
void F(P);

@script:python depends on extract_gsm610_write_i_decl_void@
F << extract_gsm610_write_i_decl_void.F;
P << extract_gsm610_write_i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: gsm610_write_s
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_gsm610_write_s_def@
type T;
identifier F = gsm610_write_s;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_gsm610_write_s_def@
F << remove_static_gsm610_write_s_def.F;
T << remove_static_gsm610_write_s_def.T;
P << remove_static_gsm610_write_s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_gsm610_write_s_def_void@
identifier F = gsm610_write_s;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_gsm610_write_s_def_void@
F << remove_static_gsm610_write_s_def_void.F;
P << remove_static_gsm610_write_s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_gsm610_write_s_decl@
type T;
identifier F = gsm610_write_s;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_gsm610_write_s_decl@
F << remove_static_gsm610_write_s_decl.F;
T << remove_static_gsm610_write_s_decl.T;
P << remove_static_gsm610_write_s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_gsm610_write_s_decl_void@
identifier F = gsm610_write_s;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_gsm610_write_s_decl_void@
F << remove_static_gsm610_write_s_decl_void.F;
P << remove_static_gsm610_write_s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_gsm610_write_s_def@
type T;
identifier F = gsm610_write_s;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_gsm610_write_s_def@
F << extract_gsm610_write_s_def.F;
T << extract_gsm610_write_s_def.T;
P << extract_gsm610_write_s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_gsm610_write_s_def_void@
identifier F = gsm610_write_s;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_gsm610_write_s_def_void@
F << extract_gsm610_write_s_def_void.F;
P << extract_gsm610_write_s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_gsm610_write_s_decl@
type T;
identifier F = gsm610_write_s;
parameter list P;
@@
T F(P);

@script:python depends on extract_gsm610_write_s_decl@
F << extract_gsm610_write_s_decl.F;
T << extract_gsm610_write_s_decl.T;
P << extract_gsm610_write_s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_gsm610_write_s_decl_void@
identifier F = gsm610_write_s;
parameter list P;
@@
void F(P);

@script:python depends on extract_gsm610_write_s_decl_void@
F << extract_gsm610_write_s_decl_void.F;
P << extract_gsm610_write_s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: host_read_d
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_host_read_d_def@
type T;
identifier F = host_read_d;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_host_read_d_def@
F << remove_static_host_read_d_def.F;
T << remove_static_host_read_d_def.T;
P << remove_static_host_read_d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_host_read_d_def_void@
identifier F = host_read_d;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_host_read_d_def_void@
F << remove_static_host_read_d_def_void.F;
P << remove_static_host_read_d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_host_read_d_decl@
type T;
identifier F = host_read_d;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_host_read_d_decl@
F << remove_static_host_read_d_decl.F;
T << remove_static_host_read_d_decl.T;
P << remove_static_host_read_d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_host_read_d_decl_void@
identifier F = host_read_d;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_host_read_d_decl_void@
F << remove_static_host_read_d_decl_void.F;
P << remove_static_host_read_d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_host_read_d_def@
type T;
identifier F = host_read_d;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_host_read_d_def@
F << extract_host_read_d_def.F;
T << extract_host_read_d_def.T;
P << extract_host_read_d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_host_read_d_def_void@
identifier F = host_read_d;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_host_read_d_def_void@
F << extract_host_read_d_def_void.F;
P << extract_host_read_d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_host_read_d_decl@
type T;
identifier F = host_read_d;
parameter list P;
@@
T F(P);

@script:python depends on extract_host_read_d_decl@
F << extract_host_read_d_decl.F;
T << extract_host_read_d_decl.T;
P << extract_host_read_d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_host_read_d_decl_void@
identifier F = host_read_d;
parameter list P;
@@
void F(P);

@script:python depends on extract_host_read_d_decl_void@
F << extract_host_read_d_decl_void.F;
P << extract_host_read_d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: host_read_d2f
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_host_read_d2f_def@
type T;
identifier F = host_read_d2f;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_host_read_d2f_def@
F << remove_static_host_read_d2f_def.F;
T << remove_static_host_read_d2f_def.T;
P << remove_static_host_read_d2f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_host_read_d2f_def_void@
identifier F = host_read_d2f;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_host_read_d2f_def_void@
F << remove_static_host_read_d2f_def_void.F;
P << remove_static_host_read_d2f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_host_read_d2f_decl@
type T;
identifier F = host_read_d2f;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_host_read_d2f_decl@
F << remove_static_host_read_d2f_decl.F;
T << remove_static_host_read_d2f_decl.T;
P << remove_static_host_read_d2f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_host_read_d2f_decl_void@
identifier F = host_read_d2f;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_host_read_d2f_decl_void@
F << remove_static_host_read_d2f_decl_void.F;
P << remove_static_host_read_d2f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_host_read_d2f_def@
type T;
identifier F = host_read_d2f;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_host_read_d2f_def@
F << extract_host_read_d2f_def.F;
T << extract_host_read_d2f_def.T;
P << extract_host_read_d2f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_host_read_d2f_def_void@
identifier F = host_read_d2f;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_host_read_d2f_def_void@
F << extract_host_read_d2f_def_void.F;
P << extract_host_read_d2f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_host_read_d2f_decl@
type T;
identifier F = host_read_d2f;
parameter list P;
@@
T F(P);

@script:python depends on extract_host_read_d2f_decl@
F << extract_host_read_d2f_decl.F;
T << extract_host_read_d2f_decl.T;
P << extract_host_read_d2f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_host_read_d2f_decl_void@
identifier F = host_read_d2f;
parameter list P;
@@
void F(P);

@script:python depends on extract_host_read_d2f_decl_void@
F << extract_host_read_d2f_decl_void.F;
P << extract_host_read_d2f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: host_read_d2i
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_host_read_d2i_def@
type T;
identifier F = host_read_d2i;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_host_read_d2i_def@
F << remove_static_host_read_d2i_def.F;
T << remove_static_host_read_d2i_def.T;
P << remove_static_host_read_d2i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_host_read_d2i_def_void@
identifier F = host_read_d2i;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_host_read_d2i_def_void@
F << remove_static_host_read_d2i_def_void.F;
P << remove_static_host_read_d2i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_host_read_d2i_decl@
type T;
identifier F = host_read_d2i;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_host_read_d2i_decl@
F << remove_static_host_read_d2i_decl.F;
T << remove_static_host_read_d2i_decl.T;
P << remove_static_host_read_d2i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_host_read_d2i_decl_void@
identifier F = host_read_d2i;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_host_read_d2i_decl_void@
F << remove_static_host_read_d2i_decl_void.F;
P << remove_static_host_read_d2i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_host_read_d2i_def@
type T;
identifier F = host_read_d2i;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_host_read_d2i_def@
F << extract_host_read_d2i_def.F;
T << extract_host_read_d2i_def.T;
P << extract_host_read_d2i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_host_read_d2i_def_void@
identifier F = host_read_d2i;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_host_read_d2i_def_void@
F << extract_host_read_d2i_def_void.F;
P << extract_host_read_d2i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_host_read_d2i_decl@
type T;
identifier F = host_read_d2i;
parameter list P;
@@
T F(P);

@script:python depends on extract_host_read_d2i_decl@
F << extract_host_read_d2i_decl.F;
T << extract_host_read_d2i_decl.T;
P << extract_host_read_d2i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_host_read_d2i_decl_void@
identifier F = host_read_d2i;
parameter list P;
@@
void F(P);

@script:python depends on extract_host_read_d2i_decl_void@
F << extract_host_read_d2i_decl_void.F;
P << extract_host_read_d2i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: host_read_d2s
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_host_read_d2s_def@
type T;
identifier F = host_read_d2s;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_host_read_d2s_def@
F << remove_static_host_read_d2s_def.F;
T << remove_static_host_read_d2s_def.T;
P << remove_static_host_read_d2s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_host_read_d2s_def_void@
identifier F = host_read_d2s;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_host_read_d2s_def_void@
F << remove_static_host_read_d2s_def_void.F;
P << remove_static_host_read_d2s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_host_read_d2s_decl@
type T;
identifier F = host_read_d2s;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_host_read_d2s_decl@
F << remove_static_host_read_d2s_decl.F;
T << remove_static_host_read_d2s_decl.T;
P << remove_static_host_read_d2s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_host_read_d2s_decl_void@
identifier F = host_read_d2s;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_host_read_d2s_decl_void@
F << remove_static_host_read_d2s_decl_void.F;
P << remove_static_host_read_d2s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_host_read_d2s_def@
type T;
identifier F = host_read_d2s;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_host_read_d2s_def@
F << extract_host_read_d2s_def.F;
T << extract_host_read_d2s_def.T;
P << extract_host_read_d2s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_host_read_d2s_def_void@
identifier F = host_read_d2s;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_host_read_d2s_def_void@
F << extract_host_read_d2s_def_void.F;
P << extract_host_read_d2s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_host_read_d2s_decl@
type T;
identifier F = host_read_d2s;
parameter list P;
@@
T F(P);

@script:python depends on extract_host_read_d2s_decl@
F << extract_host_read_d2s_decl.F;
T << extract_host_read_d2s_decl.T;
P << extract_host_read_d2s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_host_read_d2s_decl_void@
identifier F = host_read_d2s;
parameter list P;
@@
void F(P);

@script:python depends on extract_host_read_d2s_decl_void@
F << extract_host_read_d2s_decl_void.F;
P << extract_host_read_d2s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: host_read_f
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_host_read_f_def@
type T;
identifier F = host_read_f;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_host_read_f_def@
F << remove_static_host_read_f_def.F;
T << remove_static_host_read_f_def.T;
P << remove_static_host_read_f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_host_read_f_def_void@
identifier F = host_read_f;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_host_read_f_def_void@
F << remove_static_host_read_f_def_void.F;
P << remove_static_host_read_f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_host_read_f_decl@
type T;
identifier F = host_read_f;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_host_read_f_decl@
F << remove_static_host_read_f_decl.F;
T << remove_static_host_read_f_decl.T;
P << remove_static_host_read_f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_host_read_f_decl_void@
identifier F = host_read_f;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_host_read_f_decl_void@
F << remove_static_host_read_f_decl_void.F;
P << remove_static_host_read_f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_host_read_f_def@
type T;
identifier F = host_read_f;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_host_read_f_def@
F << extract_host_read_f_def.F;
T << extract_host_read_f_def.T;
P << extract_host_read_f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_host_read_f_def_void@
identifier F = host_read_f;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_host_read_f_def_void@
F << extract_host_read_f_def_void.F;
P << extract_host_read_f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_host_read_f_decl@
type T;
identifier F = host_read_f;
parameter list P;
@@
T F(P);

@script:python depends on extract_host_read_f_decl@
F << extract_host_read_f_decl.F;
T << extract_host_read_f_decl.T;
P << extract_host_read_f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_host_read_f_decl_void@
identifier F = host_read_f;
parameter list P;
@@
void F(P);

@script:python depends on extract_host_read_f_decl_void@
F << extract_host_read_f_decl_void.F;
P << extract_host_read_f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: host_read_f2d
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_host_read_f2d_def@
type T;
identifier F = host_read_f2d;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_host_read_f2d_def@
F << remove_static_host_read_f2d_def.F;
T << remove_static_host_read_f2d_def.T;
P << remove_static_host_read_f2d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_host_read_f2d_def_void@
identifier F = host_read_f2d;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_host_read_f2d_def_void@
F << remove_static_host_read_f2d_def_void.F;
P << remove_static_host_read_f2d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_host_read_f2d_decl@
type T;
identifier F = host_read_f2d;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_host_read_f2d_decl@
F << remove_static_host_read_f2d_decl.F;
T << remove_static_host_read_f2d_decl.T;
P << remove_static_host_read_f2d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_host_read_f2d_decl_void@
identifier F = host_read_f2d;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_host_read_f2d_decl_void@
F << remove_static_host_read_f2d_decl_void.F;
P << remove_static_host_read_f2d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_host_read_f2d_def@
type T;
identifier F = host_read_f2d;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_host_read_f2d_def@
F << extract_host_read_f2d_def.F;
T << extract_host_read_f2d_def.T;
P << extract_host_read_f2d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_host_read_f2d_def_void@
identifier F = host_read_f2d;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_host_read_f2d_def_void@
F << extract_host_read_f2d_def_void.F;
P << extract_host_read_f2d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_host_read_f2d_decl@
type T;
identifier F = host_read_f2d;
parameter list P;
@@
T F(P);

@script:python depends on extract_host_read_f2d_decl@
F << extract_host_read_f2d_decl.F;
T << extract_host_read_f2d_decl.T;
P << extract_host_read_f2d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_host_read_f2d_decl_void@
identifier F = host_read_f2d;
parameter list P;
@@
void F(P);

@script:python depends on extract_host_read_f2d_decl_void@
F << extract_host_read_f2d_decl_void.F;
P << extract_host_read_f2d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: host_read_f2i
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_host_read_f2i_def@
type T;
identifier F = host_read_f2i;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_host_read_f2i_def@
F << remove_static_host_read_f2i_def.F;
T << remove_static_host_read_f2i_def.T;
P << remove_static_host_read_f2i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_host_read_f2i_def_void@
identifier F = host_read_f2i;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_host_read_f2i_def_void@
F << remove_static_host_read_f2i_def_void.F;
P << remove_static_host_read_f2i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_host_read_f2i_decl@
type T;
identifier F = host_read_f2i;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_host_read_f2i_decl@
F << remove_static_host_read_f2i_decl.F;
T << remove_static_host_read_f2i_decl.T;
P << remove_static_host_read_f2i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_host_read_f2i_decl_void@
identifier F = host_read_f2i;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_host_read_f2i_decl_void@
F << remove_static_host_read_f2i_decl_void.F;
P << remove_static_host_read_f2i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_host_read_f2i_def@
type T;
identifier F = host_read_f2i;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_host_read_f2i_def@
F << extract_host_read_f2i_def.F;
T << extract_host_read_f2i_def.T;
P << extract_host_read_f2i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_host_read_f2i_def_void@
identifier F = host_read_f2i;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_host_read_f2i_def_void@
F << extract_host_read_f2i_def_void.F;
P << extract_host_read_f2i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_host_read_f2i_decl@
type T;
identifier F = host_read_f2i;
parameter list P;
@@
T F(P);

@script:python depends on extract_host_read_f2i_decl@
F << extract_host_read_f2i_decl.F;
T << extract_host_read_f2i_decl.T;
P << extract_host_read_f2i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_host_read_f2i_decl_void@
identifier F = host_read_f2i;
parameter list P;
@@
void F(P);

@script:python depends on extract_host_read_f2i_decl_void@
F << extract_host_read_f2i_decl_void.F;
P << extract_host_read_f2i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: host_read_f2s
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_host_read_f2s_def@
type T;
identifier F = host_read_f2s;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_host_read_f2s_def@
F << remove_static_host_read_f2s_def.F;
T << remove_static_host_read_f2s_def.T;
P << remove_static_host_read_f2s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_host_read_f2s_def_void@
identifier F = host_read_f2s;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_host_read_f2s_def_void@
F << remove_static_host_read_f2s_def_void.F;
P << remove_static_host_read_f2s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_host_read_f2s_decl@
type T;
identifier F = host_read_f2s;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_host_read_f2s_decl@
F << remove_static_host_read_f2s_decl.F;
T << remove_static_host_read_f2s_decl.T;
P << remove_static_host_read_f2s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_host_read_f2s_decl_void@
identifier F = host_read_f2s;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_host_read_f2s_decl_void@
F << remove_static_host_read_f2s_decl_void.F;
P << remove_static_host_read_f2s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_host_read_f2s_def@
type T;
identifier F = host_read_f2s;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_host_read_f2s_def@
F << extract_host_read_f2s_def.F;
T << extract_host_read_f2s_def.T;
P << extract_host_read_f2s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_host_read_f2s_def_void@
identifier F = host_read_f2s;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_host_read_f2s_def_void@
F << extract_host_read_f2s_def_void.F;
P << extract_host_read_f2s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_host_read_f2s_decl@
type T;
identifier F = host_read_f2s;
parameter list P;
@@
T F(P);

@script:python depends on extract_host_read_f2s_decl@
F << extract_host_read_f2s_decl.F;
T << extract_host_read_f2s_decl.T;
P << extract_host_read_f2s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_host_read_f2s_decl_void@
identifier F = host_read_f2s;
parameter list P;
@@
void F(P);

@script:python depends on extract_host_read_f2s_decl_void@
F << extract_host_read_f2s_decl_void.F;
P << extract_host_read_f2s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: host_write_d
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_host_write_d_def@
type T;
identifier F = host_write_d;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_host_write_d_def@
F << remove_static_host_write_d_def.F;
T << remove_static_host_write_d_def.T;
P << remove_static_host_write_d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_host_write_d_def_void@
identifier F = host_write_d;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_host_write_d_def_void@
F << remove_static_host_write_d_def_void.F;
P << remove_static_host_write_d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_host_write_d_decl@
type T;
identifier F = host_write_d;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_host_write_d_decl@
F << remove_static_host_write_d_decl.F;
T << remove_static_host_write_d_decl.T;
P << remove_static_host_write_d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_host_write_d_decl_void@
identifier F = host_write_d;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_host_write_d_decl_void@
F << remove_static_host_write_d_decl_void.F;
P << remove_static_host_write_d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_host_write_d_def@
type T;
identifier F = host_write_d;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_host_write_d_def@
F << extract_host_write_d_def.F;
T << extract_host_write_d_def.T;
P << extract_host_write_d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_host_write_d_def_void@
identifier F = host_write_d;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_host_write_d_def_void@
F << extract_host_write_d_def_void.F;
P << extract_host_write_d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_host_write_d_decl@
type T;
identifier F = host_write_d;
parameter list P;
@@
T F(P);

@script:python depends on extract_host_write_d_decl@
F << extract_host_write_d_decl.F;
T << extract_host_write_d_decl.T;
P << extract_host_write_d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_host_write_d_decl_void@
identifier F = host_write_d;
parameter list P;
@@
void F(P);

@script:python depends on extract_host_write_d_decl_void@
F << extract_host_write_d_decl_void.F;
P << extract_host_write_d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: host_write_d2f
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_host_write_d2f_def@
type T;
identifier F = host_write_d2f;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_host_write_d2f_def@
F << remove_static_host_write_d2f_def.F;
T << remove_static_host_write_d2f_def.T;
P << remove_static_host_write_d2f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_host_write_d2f_def_void@
identifier F = host_write_d2f;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_host_write_d2f_def_void@
F << remove_static_host_write_d2f_def_void.F;
P << remove_static_host_write_d2f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_host_write_d2f_decl@
type T;
identifier F = host_write_d2f;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_host_write_d2f_decl@
F << remove_static_host_write_d2f_decl.F;
T << remove_static_host_write_d2f_decl.T;
P << remove_static_host_write_d2f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_host_write_d2f_decl_void@
identifier F = host_write_d2f;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_host_write_d2f_decl_void@
F << remove_static_host_write_d2f_decl_void.F;
P << remove_static_host_write_d2f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_host_write_d2f_def@
type T;
identifier F = host_write_d2f;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_host_write_d2f_def@
F << extract_host_write_d2f_def.F;
T << extract_host_write_d2f_def.T;
P << extract_host_write_d2f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_host_write_d2f_def_void@
identifier F = host_write_d2f;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_host_write_d2f_def_void@
F << extract_host_write_d2f_def_void.F;
P << extract_host_write_d2f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_host_write_d2f_decl@
type T;
identifier F = host_write_d2f;
parameter list P;
@@
T F(P);

@script:python depends on extract_host_write_d2f_decl@
F << extract_host_write_d2f_decl.F;
T << extract_host_write_d2f_decl.T;
P << extract_host_write_d2f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_host_write_d2f_decl_void@
identifier F = host_write_d2f;
parameter list P;
@@
void F(P);

@script:python depends on extract_host_write_d2f_decl_void@
F << extract_host_write_d2f_decl_void.F;
P << extract_host_write_d2f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: host_write_f
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_host_write_f_def@
type T;
identifier F = host_write_f;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_host_write_f_def@
F << remove_static_host_write_f_def.F;
T << remove_static_host_write_f_def.T;
P << remove_static_host_write_f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_host_write_f_def_void@
identifier F = host_write_f;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_host_write_f_def_void@
F << remove_static_host_write_f_def_void.F;
P << remove_static_host_write_f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_host_write_f_decl@
type T;
identifier F = host_write_f;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_host_write_f_decl@
F << remove_static_host_write_f_decl.F;
T << remove_static_host_write_f_decl.T;
P << remove_static_host_write_f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_host_write_f_decl_void@
identifier F = host_write_f;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_host_write_f_decl_void@
F << remove_static_host_write_f_decl_void.F;
P << remove_static_host_write_f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_host_write_f_def@
type T;
identifier F = host_write_f;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_host_write_f_def@
F << extract_host_write_f_def.F;
T << extract_host_write_f_def.T;
P << extract_host_write_f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_host_write_f_def_void@
identifier F = host_write_f;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_host_write_f_def_void@
F << extract_host_write_f_def_void.F;
P << extract_host_write_f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_host_write_f_decl@
type T;
identifier F = host_write_f;
parameter list P;
@@
T F(P);

@script:python depends on extract_host_write_f_decl@
F << extract_host_write_f_decl.F;
T << extract_host_write_f_decl.T;
P << extract_host_write_f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_host_write_f_decl_void@
identifier F = host_write_f;
parameter list P;
@@
void F(P);

@script:python depends on extract_host_write_f_decl_void@
F << extract_host_write_f_decl_void.F;
P << extract_host_write_f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: host_write_f2d
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_host_write_f2d_def@
type T;
identifier F = host_write_f2d;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_host_write_f2d_def@
F << remove_static_host_write_f2d_def.F;
T << remove_static_host_write_f2d_def.T;
P << remove_static_host_write_f2d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_host_write_f2d_def_void@
identifier F = host_write_f2d;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_host_write_f2d_def_void@
F << remove_static_host_write_f2d_def_void.F;
P << remove_static_host_write_f2d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_host_write_f2d_decl@
type T;
identifier F = host_write_f2d;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_host_write_f2d_decl@
F << remove_static_host_write_f2d_decl.F;
T << remove_static_host_write_f2d_decl.T;
P << remove_static_host_write_f2d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_host_write_f2d_decl_void@
identifier F = host_write_f2d;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_host_write_f2d_decl_void@
F << remove_static_host_write_f2d_decl_void.F;
P << remove_static_host_write_f2d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_host_write_f2d_def@
type T;
identifier F = host_write_f2d;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_host_write_f2d_def@
F << extract_host_write_f2d_def.F;
T << extract_host_write_f2d_def.T;
P << extract_host_write_f2d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_host_write_f2d_def_void@
identifier F = host_write_f2d;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_host_write_f2d_def_void@
F << extract_host_write_f2d_def_void.F;
P << extract_host_write_f2d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_host_write_f2d_decl@
type T;
identifier F = host_write_f2d;
parameter list P;
@@
T F(P);

@script:python depends on extract_host_write_f2d_decl@
F << extract_host_write_f2d_decl.F;
T << extract_host_write_f2d_decl.T;
P << extract_host_write_f2d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_host_write_f2d_decl_void@
identifier F = host_write_f2d;
parameter list P;
@@
void F(P);

@script:python depends on extract_host_write_f2d_decl_void@
F << extract_host_write_f2d_decl_void.F;
P << extract_host_write_f2d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: host_write_i2d
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_host_write_i2d_def@
type T;
identifier F = host_write_i2d;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_host_write_i2d_def@
F << remove_static_host_write_i2d_def.F;
T << remove_static_host_write_i2d_def.T;
P << remove_static_host_write_i2d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_host_write_i2d_def_void@
identifier F = host_write_i2d;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_host_write_i2d_def_void@
F << remove_static_host_write_i2d_def_void.F;
P << remove_static_host_write_i2d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_host_write_i2d_decl@
type T;
identifier F = host_write_i2d;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_host_write_i2d_decl@
F << remove_static_host_write_i2d_decl.F;
T << remove_static_host_write_i2d_decl.T;
P << remove_static_host_write_i2d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_host_write_i2d_decl_void@
identifier F = host_write_i2d;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_host_write_i2d_decl_void@
F << remove_static_host_write_i2d_decl_void.F;
P << remove_static_host_write_i2d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_host_write_i2d_def@
type T;
identifier F = host_write_i2d;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_host_write_i2d_def@
F << extract_host_write_i2d_def.F;
T << extract_host_write_i2d_def.T;
P << extract_host_write_i2d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_host_write_i2d_def_void@
identifier F = host_write_i2d;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_host_write_i2d_def_void@
F << extract_host_write_i2d_def_void.F;
P << extract_host_write_i2d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_host_write_i2d_decl@
type T;
identifier F = host_write_i2d;
parameter list P;
@@
T F(P);

@script:python depends on extract_host_write_i2d_decl@
F << extract_host_write_i2d_decl.F;
T << extract_host_write_i2d_decl.T;
P << extract_host_write_i2d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_host_write_i2d_decl_void@
identifier F = host_write_i2d;
parameter list P;
@@
void F(P);

@script:python depends on extract_host_write_i2d_decl_void@
F << extract_host_write_i2d_decl_void.F;
P << extract_host_write_i2d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: host_write_i2f
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_host_write_i2f_def@
type T;
identifier F = host_write_i2f;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_host_write_i2f_def@
F << remove_static_host_write_i2f_def.F;
T << remove_static_host_write_i2f_def.T;
P << remove_static_host_write_i2f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_host_write_i2f_def_void@
identifier F = host_write_i2f;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_host_write_i2f_def_void@
F << remove_static_host_write_i2f_def_void.F;
P << remove_static_host_write_i2f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_host_write_i2f_decl@
type T;
identifier F = host_write_i2f;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_host_write_i2f_decl@
F << remove_static_host_write_i2f_decl.F;
T << remove_static_host_write_i2f_decl.T;
P << remove_static_host_write_i2f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_host_write_i2f_decl_void@
identifier F = host_write_i2f;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_host_write_i2f_decl_void@
F << remove_static_host_write_i2f_decl_void.F;
P << remove_static_host_write_i2f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_host_write_i2f_def@
type T;
identifier F = host_write_i2f;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_host_write_i2f_def@
F << extract_host_write_i2f_def.F;
T << extract_host_write_i2f_def.T;
P << extract_host_write_i2f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_host_write_i2f_def_void@
identifier F = host_write_i2f;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_host_write_i2f_def_void@
F << extract_host_write_i2f_def_void.F;
P << extract_host_write_i2f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_host_write_i2f_decl@
type T;
identifier F = host_write_i2f;
parameter list P;
@@
T F(P);

@script:python depends on extract_host_write_i2f_decl@
F << extract_host_write_i2f_decl.F;
T << extract_host_write_i2f_decl.T;
P << extract_host_write_i2f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_host_write_i2f_decl_void@
identifier F = host_write_i2f;
parameter list P;
@@
void F(P);

@script:python depends on extract_host_write_i2f_decl_void@
F << extract_host_write_i2f_decl_void.F;
P << extract_host_write_i2f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: host_write_s2d
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_host_write_s2d_def@
type T;
identifier F = host_write_s2d;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_host_write_s2d_def@
F << remove_static_host_write_s2d_def.F;
T << remove_static_host_write_s2d_def.T;
P << remove_static_host_write_s2d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_host_write_s2d_def_void@
identifier F = host_write_s2d;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_host_write_s2d_def_void@
F << remove_static_host_write_s2d_def_void.F;
P << remove_static_host_write_s2d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_host_write_s2d_decl@
type T;
identifier F = host_write_s2d;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_host_write_s2d_decl@
F << remove_static_host_write_s2d_decl.F;
T << remove_static_host_write_s2d_decl.T;
P << remove_static_host_write_s2d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_host_write_s2d_decl_void@
identifier F = host_write_s2d;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_host_write_s2d_decl_void@
F << remove_static_host_write_s2d_decl_void.F;
P << remove_static_host_write_s2d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_host_write_s2d_def@
type T;
identifier F = host_write_s2d;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_host_write_s2d_def@
F << extract_host_write_s2d_def.F;
T << extract_host_write_s2d_def.T;
P << extract_host_write_s2d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_host_write_s2d_def_void@
identifier F = host_write_s2d;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_host_write_s2d_def_void@
F << extract_host_write_s2d_def_void.F;
P << extract_host_write_s2d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_host_write_s2d_decl@
type T;
identifier F = host_write_s2d;
parameter list P;
@@
T F(P);

@script:python depends on extract_host_write_s2d_decl@
F << extract_host_write_s2d_decl.F;
T << extract_host_write_s2d_decl.T;
P << extract_host_write_s2d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_host_write_s2d_decl_void@
identifier F = host_write_s2d;
parameter list P;
@@
void F(P);

@script:python depends on extract_host_write_s2d_decl_void@
F << extract_host_write_s2d_decl_void.F;
P << extract_host_write_s2d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: host_write_s2f
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_host_write_s2f_def@
type T;
identifier F = host_write_s2f;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_host_write_s2f_def@
F << remove_static_host_write_s2f_def.F;
T << remove_static_host_write_s2f_def.T;
P << remove_static_host_write_s2f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_host_write_s2f_def_void@
identifier F = host_write_s2f;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_host_write_s2f_def_void@
F << remove_static_host_write_s2f_def_void.F;
P << remove_static_host_write_s2f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_host_write_s2f_decl@
type T;
identifier F = host_write_s2f;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_host_write_s2f_decl@
F << remove_static_host_write_s2f_decl.F;
T << remove_static_host_write_s2f_decl.T;
P << remove_static_host_write_s2f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_host_write_s2f_decl_void@
identifier F = host_write_s2f;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_host_write_s2f_decl_void@
F << remove_static_host_write_s2f_decl_void.F;
P << remove_static_host_write_s2f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_host_write_s2f_def@
type T;
identifier F = host_write_s2f;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_host_write_s2f_def@
F << extract_host_write_s2f_def.F;
T << extract_host_write_s2f_def.T;
P << extract_host_write_s2f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_host_write_s2f_def_void@
identifier F = host_write_s2f;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_host_write_s2f_def_void@
F << extract_host_write_s2f_def_void.F;
P << extract_host_write_s2f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_host_write_s2f_decl@
type T;
identifier F = host_write_s2f;
parameter list P;
@@
T F(P);

@script:python depends on extract_host_write_s2f_decl@
F << extract_host_write_s2f_decl.F;
T << extract_host_write_s2f_decl.T;
P << extract_host_write_s2f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_host_write_s2f_decl_void@
identifier F = host_write_s2f;
parameter list P;
@@
void F(P);

@script:python depends on extract_host_write_s2f_decl_void@
F << extract_host_write_s2f_decl_void.F;
P << extract_host_write_s2f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: htk_close
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_htk_close_def@
type T;
identifier F = htk_close;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_htk_close_def@
F << remove_static_htk_close_def.F;
T << remove_static_htk_close_def.T;
P << remove_static_htk_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_htk_close_def_void@
identifier F = htk_close;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_htk_close_def_void@
F << remove_static_htk_close_def_void.F;
P << remove_static_htk_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_htk_close_decl@
type T;
identifier F = htk_close;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_htk_close_decl@
F << remove_static_htk_close_decl.F;
T << remove_static_htk_close_decl.T;
P << remove_static_htk_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_htk_close_decl_void@
identifier F = htk_close;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_htk_close_decl_void@
F << remove_static_htk_close_decl_void.F;
P << remove_static_htk_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_htk_close_def@
type T;
identifier F = htk_close;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_htk_close_def@
F << extract_htk_close_def.F;
T << extract_htk_close_def.T;
P << extract_htk_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_htk_close_def_void@
identifier F = htk_close;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_htk_close_def_void@
F << extract_htk_close_def_void.F;
P << extract_htk_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_htk_close_decl@
type T;
identifier F = htk_close;
parameter list P;
@@
T F(P);

@script:python depends on extract_htk_close_decl@
F << extract_htk_close_decl.F;
T << extract_htk_close_decl.T;
P << extract_htk_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_htk_close_decl_void@
identifier F = htk_close;
parameter list P;
@@
void F(P);

@script:python depends on extract_htk_close_decl_void@
F << extract_htk_close_decl_void.F;
P << extract_htk_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: htk_write_header
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_htk_write_header_def@
type T;
identifier F = htk_write_header;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_htk_write_header_def@
F << remove_static_htk_write_header_def.F;
T << remove_static_htk_write_header_def.T;
P << remove_static_htk_write_header_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_htk_write_header_def_void@
identifier F = htk_write_header;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_htk_write_header_def_void@
F << remove_static_htk_write_header_def_void.F;
P << remove_static_htk_write_header_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_htk_write_header_decl@
type T;
identifier F = htk_write_header;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_htk_write_header_decl@
F << remove_static_htk_write_header_decl.F;
T << remove_static_htk_write_header_decl.T;
P << remove_static_htk_write_header_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_htk_write_header_decl_void@
identifier F = htk_write_header;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_htk_write_header_decl_void@
F << remove_static_htk_write_header_decl_void.F;
P << remove_static_htk_write_header_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_htk_write_header_def@
type T;
identifier F = htk_write_header;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_htk_write_header_def@
F << extract_htk_write_header_def.F;
T << extract_htk_write_header_def.T;
P << extract_htk_write_header_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_htk_write_header_def_void@
identifier F = htk_write_header;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_htk_write_header_def_void@
F << extract_htk_write_header_def_void.F;
P << extract_htk_write_header_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_htk_write_header_decl@
type T;
identifier F = htk_write_header;
parameter list P;
@@
T F(P);

@script:python depends on extract_htk_write_header_decl@
F << extract_htk_write_header_decl.F;
T << extract_htk_write_header_decl.T;
P << extract_htk_write_header_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_htk_write_header_decl_void@
identifier F = htk_write_header;
parameter list P;
@@
void F(P);

@script:python depends on extract_htk_write_header_decl_void@
F << extract_htk_write_header_decl_void.F;
P << extract_htk_write_header_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: ima_close
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_ima_close_def@
type T;
identifier F = ima_close;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_ima_close_def@
F << remove_static_ima_close_def.F;
T << remove_static_ima_close_def.T;
P << remove_static_ima_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_ima_close_def_void@
identifier F = ima_close;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_ima_close_def_void@
F << remove_static_ima_close_def_void.F;
P << remove_static_ima_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_ima_close_decl@
type T;
identifier F = ima_close;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_ima_close_decl@
F << remove_static_ima_close_decl.F;
T << remove_static_ima_close_decl.T;
P << remove_static_ima_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_ima_close_decl_void@
identifier F = ima_close;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_ima_close_decl_void@
F << remove_static_ima_close_decl_void.F;
P << remove_static_ima_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_ima_close_def@
type T;
identifier F = ima_close;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_ima_close_def@
F << extract_ima_close_def.F;
T << extract_ima_close_def.T;
P << extract_ima_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_ima_close_def_void@
identifier F = ima_close;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_ima_close_def_void@
F << extract_ima_close_def_void.F;
P << extract_ima_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_ima_close_decl@
type T;
identifier F = ima_close;
parameter list P;
@@
T F(P);

@script:python depends on extract_ima_close_decl@
F << extract_ima_close_decl.F;
T << extract_ima_close_decl.T;
P << extract_ima_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_ima_close_decl_void@
identifier F = ima_close;
parameter list P;
@@
void F(P);

@script:python depends on extract_ima_close_decl_void@
F << extract_ima_close_decl_void.F;
P << extract_ima_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: ima_read_d
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_ima_read_d_def@
type T;
identifier F = ima_read_d;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_ima_read_d_def@
F << remove_static_ima_read_d_def.F;
T << remove_static_ima_read_d_def.T;
P << remove_static_ima_read_d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_ima_read_d_def_void@
identifier F = ima_read_d;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_ima_read_d_def_void@
F << remove_static_ima_read_d_def_void.F;
P << remove_static_ima_read_d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_ima_read_d_decl@
type T;
identifier F = ima_read_d;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_ima_read_d_decl@
F << remove_static_ima_read_d_decl.F;
T << remove_static_ima_read_d_decl.T;
P << remove_static_ima_read_d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_ima_read_d_decl_void@
identifier F = ima_read_d;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_ima_read_d_decl_void@
F << remove_static_ima_read_d_decl_void.F;
P << remove_static_ima_read_d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_ima_read_d_def@
type T;
identifier F = ima_read_d;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_ima_read_d_def@
F << extract_ima_read_d_def.F;
T << extract_ima_read_d_def.T;
P << extract_ima_read_d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_ima_read_d_def_void@
identifier F = ima_read_d;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_ima_read_d_def_void@
F << extract_ima_read_d_def_void.F;
P << extract_ima_read_d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_ima_read_d_decl@
type T;
identifier F = ima_read_d;
parameter list P;
@@
T F(P);

@script:python depends on extract_ima_read_d_decl@
F << extract_ima_read_d_decl.F;
T << extract_ima_read_d_decl.T;
P << extract_ima_read_d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_ima_read_d_decl_void@
identifier F = ima_read_d;
parameter list P;
@@
void F(P);

@script:python depends on extract_ima_read_d_decl_void@
F << extract_ima_read_d_decl_void.F;
P << extract_ima_read_d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: ima_read_f
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_ima_read_f_def@
type T;
identifier F = ima_read_f;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_ima_read_f_def@
F << remove_static_ima_read_f_def.F;
T << remove_static_ima_read_f_def.T;
P << remove_static_ima_read_f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_ima_read_f_def_void@
identifier F = ima_read_f;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_ima_read_f_def_void@
F << remove_static_ima_read_f_def_void.F;
P << remove_static_ima_read_f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_ima_read_f_decl@
type T;
identifier F = ima_read_f;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_ima_read_f_decl@
F << remove_static_ima_read_f_decl.F;
T << remove_static_ima_read_f_decl.T;
P << remove_static_ima_read_f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_ima_read_f_decl_void@
identifier F = ima_read_f;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_ima_read_f_decl_void@
F << remove_static_ima_read_f_decl_void.F;
P << remove_static_ima_read_f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_ima_read_f_def@
type T;
identifier F = ima_read_f;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_ima_read_f_def@
F << extract_ima_read_f_def.F;
T << extract_ima_read_f_def.T;
P << extract_ima_read_f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_ima_read_f_def_void@
identifier F = ima_read_f;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_ima_read_f_def_void@
F << extract_ima_read_f_def_void.F;
P << extract_ima_read_f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_ima_read_f_decl@
type T;
identifier F = ima_read_f;
parameter list P;
@@
T F(P);

@script:python depends on extract_ima_read_f_decl@
F << extract_ima_read_f_decl.F;
T << extract_ima_read_f_decl.T;
P << extract_ima_read_f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_ima_read_f_decl_void@
identifier F = ima_read_f;
parameter list P;
@@
void F(P);

@script:python depends on extract_ima_read_f_decl_void@
F << extract_ima_read_f_decl_void.F;
P << extract_ima_read_f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: ima_read_i
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_ima_read_i_def@
type T;
identifier F = ima_read_i;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_ima_read_i_def@
F << remove_static_ima_read_i_def.F;
T << remove_static_ima_read_i_def.T;
P << remove_static_ima_read_i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_ima_read_i_def_void@
identifier F = ima_read_i;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_ima_read_i_def_void@
F << remove_static_ima_read_i_def_void.F;
P << remove_static_ima_read_i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_ima_read_i_decl@
type T;
identifier F = ima_read_i;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_ima_read_i_decl@
F << remove_static_ima_read_i_decl.F;
T << remove_static_ima_read_i_decl.T;
P << remove_static_ima_read_i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_ima_read_i_decl_void@
identifier F = ima_read_i;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_ima_read_i_decl_void@
F << remove_static_ima_read_i_decl_void.F;
P << remove_static_ima_read_i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_ima_read_i_def@
type T;
identifier F = ima_read_i;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_ima_read_i_def@
F << extract_ima_read_i_def.F;
T << extract_ima_read_i_def.T;
P << extract_ima_read_i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_ima_read_i_def_void@
identifier F = ima_read_i;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_ima_read_i_def_void@
F << extract_ima_read_i_def_void.F;
P << extract_ima_read_i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_ima_read_i_decl@
type T;
identifier F = ima_read_i;
parameter list P;
@@
T F(P);

@script:python depends on extract_ima_read_i_decl@
F << extract_ima_read_i_decl.F;
T << extract_ima_read_i_decl.T;
P << extract_ima_read_i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_ima_read_i_decl_void@
identifier F = ima_read_i;
parameter list P;
@@
void F(P);

@script:python depends on extract_ima_read_i_decl_void@
F << extract_ima_read_i_decl_void.F;
P << extract_ima_read_i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: ima_read_s
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_ima_read_s_def@
type T;
identifier F = ima_read_s;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_ima_read_s_def@
F << remove_static_ima_read_s_def.F;
T << remove_static_ima_read_s_def.T;
P << remove_static_ima_read_s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_ima_read_s_def_void@
identifier F = ima_read_s;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_ima_read_s_def_void@
F << remove_static_ima_read_s_def_void.F;
P << remove_static_ima_read_s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_ima_read_s_decl@
type T;
identifier F = ima_read_s;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_ima_read_s_decl@
F << remove_static_ima_read_s_decl.F;
T << remove_static_ima_read_s_decl.T;
P << remove_static_ima_read_s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_ima_read_s_decl_void@
identifier F = ima_read_s;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_ima_read_s_decl_void@
F << remove_static_ima_read_s_decl_void.F;
P << remove_static_ima_read_s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_ima_read_s_def@
type T;
identifier F = ima_read_s;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_ima_read_s_def@
F << extract_ima_read_s_def.F;
T << extract_ima_read_s_def.T;
P << extract_ima_read_s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_ima_read_s_def_void@
identifier F = ima_read_s;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_ima_read_s_def_void@
F << extract_ima_read_s_def_void.F;
P << extract_ima_read_s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_ima_read_s_decl@
type T;
identifier F = ima_read_s;
parameter list P;
@@
T F(P);

@script:python depends on extract_ima_read_s_decl@
F << extract_ima_read_s_decl.F;
T << extract_ima_read_s_decl.T;
P << extract_ima_read_s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_ima_read_s_decl_void@
identifier F = ima_read_s;
parameter list P;
@@
void F(P);

@script:python depends on extract_ima_read_s_decl_void@
F << extract_ima_read_s_decl_void.F;
P << extract_ima_read_s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: ima_write_d
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_ima_write_d_def@
type T;
identifier F = ima_write_d;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_ima_write_d_def@
F << remove_static_ima_write_d_def.F;
T << remove_static_ima_write_d_def.T;
P << remove_static_ima_write_d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_ima_write_d_def_void@
identifier F = ima_write_d;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_ima_write_d_def_void@
F << remove_static_ima_write_d_def_void.F;
P << remove_static_ima_write_d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_ima_write_d_decl@
type T;
identifier F = ima_write_d;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_ima_write_d_decl@
F << remove_static_ima_write_d_decl.F;
T << remove_static_ima_write_d_decl.T;
P << remove_static_ima_write_d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_ima_write_d_decl_void@
identifier F = ima_write_d;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_ima_write_d_decl_void@
F << remove_static_ima_write_d_decl_void.F;
P << remove_static_ima_write_d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_ima_write_d_def@
type T;
identifier F = ima_write_d;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_ima_write_d_def@
F << extract_ima_write_d_def.F;
T << extract_ima_write_d_def.T;
P << extract_ima_write_d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_ima_write_d_def_void@
identifier F = ima_write_d;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_ima_write_d_def_void@
F << extract_ima_write_d_def_void.F;
P << extract_ima_write_d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_ima_write_d_decl@
type T;
identifier F = ima_write_d;
parameter list P;
@@
T F(P);

@script:python depends on extract_ima_write_d_decl@
F << extract_ima_write_d_decl.F;
T << extract_ima_write_d_decl.T;
P << extract_ima_write_d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_ima_write_d_decl_void@
identifier F = ima_write_d;
parameter list P;
@@
void F(P);

@script:python depends on extract_ima_write_d_decl_void@
F << extract_ima_write_d_decl_void.F;
P << extract_ima_write_d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: ima_write_f
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_ima_write_f_def@
type T;
identifier F = ima_write_f;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_ima_write_f_def@
F << remove_static_ima_write_f_def.F;
T << remove_static_ima_write_f_def.T;
P << remove_static_ima_write_f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_ima_write_f_def_void@
identifier F = ima_write_f;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_ima_write_f_def_void@
F << remove_static_ima_write_f_def_void.F;
P << remove_static_ima_write_f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_ima_write_f_decl@
type T;
identifier F = ima_write_f;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_ima_write_f_decl@
F << remove_static_ima_write_f_decl.F;
T << remove_static_ima_write_f_decl.T;
P << remove_static_ima_write_f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_ima_write_f_decl_void@
identifier F = ima_write_f;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_ima_write_f_decl_void@
F << remove_static_ima_write_f_decl_void.F;
P << remove_static_ima_write_f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_ima_write_f_def@
type T;
identifier F = ima_write_f;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_ima_write_f_def@
F << extract_ima_write_f_def.F;
T << extract_ima_write_f_def.T;
P << extract_ima_write_f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_ima_write_f_def_void@
identifier F = ima_write_f;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_ima_write_f_def_void@
F << extract_ima_write_f_def_void.F;
P << extract_ima_write_f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_ima_write_f_decl@
type T;
identifier F = ima_write_f;
parameter list P;
@@
T F(P);

@script:python depends on extract_ima_write_f_decl@
F << extract_ima_write_f_decl.F;
T << extract_ima_write_f_decl.T;
P << extract_ima_write_f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_ima_write_f_decl_void@
identifier F = ima_write_f;
parameter list P;
@@
void F(P);

@script:python depends on extract_ima_write_f_decl_void@
F << extract_ima_write_f_decl_void.F;
P << extract_ima_write_f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: ima_write_i
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_ima_write_i_def@
type T;
identifier F = ima_write_i;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_ima_write_i_def@
F << remove_static_ima_write_i_def.F;
T << remove_static_ima_write_i_def.T;
P << remove_static_ima_write_i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_ima_write_i_def_void@
identifier F = ima_write_i;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_ima_write_i_def_void@
F << remove_static_ima_write_i_def_void.F;
P << remove_static_ima_write_i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_ima_write_i_decl@
type T;
identifier F = ima_write_i;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_ima_write_i_decl@
F << remove_static_ima_write_i_decl.F;
T << remove_static_ima_write_i_decl.T;
P << remove_static_ima_write_i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_ima_write_i_decl_void@
identifier F = ima_write_i;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_ima_write_i_decl_void@
F << remove_static_ima_write_i_decl_void.F;
P << remove_static_ima_write_i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_ima_write_i_def@
type T;
identifier F = ima_write_i;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_ima_write_i_def@
F << extract_ima_write_i_def.F;
T << extract_ima_write_i_def.T;
P << extract_ima_write_i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_ima_write_i_def_void@
identifier F = ima_write_i;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_ima_write_i_def_void@
F << extract_ima_write_i_def_void.F;
P << extract_ima_write_i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_ima_write_i_decl@
type T;
identifier F = ima_write_i;
parameter list P;
@@
T F(P);

@script:python depends on extract_ima_write_i_decl@
F << extract_ima_write_i_decl.F;
T << extract_ima_write_i_decl.T;
P << extract_ima_write_i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_ima_write_i_decl_void@
identifier F = ima_write_i;
parameter list P;
@@
void F(P);

@script:python depends on extract_ima_write_i_decl_void@
F << extract_ima_write_i_decl_void.F;
P << extract_ima_write_i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: ima_write_s
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_ima_write_s_def@
type T;
identifier F = ima_write_s;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_ima_write_s_def@
F << remove_static_ima_write_s_def.F;
T << remove_static_ima_write_s_def.T;
P << remove_static_ima_write_s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_ima_write_s_def_void@
identifier F = ima_write_s;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_ima_write_s_def_void@
F << remove_static_ima_write_s_def_void.F;
P << remove_static_ima_write_s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_ima_write_s_decl@
type T;
identifier F = ima_write_s;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_ima_write_s_decl@
F << remove_static_ima_write_s_decl.F;
T << remove_static_ima_write_s_decl.T;
P << remove_static_ima_write_s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_ima_write_s_decl_void@
identifier F = ima_write_s;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_ima_write_s_decl_void@
F << remove_static_ima_write_s_decl_void.F;
P << remove_static_ima_write_s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_ima_write_s_def@
type T;
identifier F = ima_write_s;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_ima_write_s_def@
F << extract_ima_write_s_def.F;
T << extract_ima_write_s_def.T;
P << extract_ima_write_s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_ima_write_s_def_void@
identifier F = ima_write_s;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_ima_write_s_def_void@
F << extract_ima_write_s_def_void.F;
P << extract_ima_write_s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_ima_write_s_decl@
type T;
identifier F = ima_write_s;
parameter list P;
@@
T F(P);

@script:python depends on extract_ima_write_s_decl@
F << extract_ima_write_s_decl.F;
T << extract_ima_write_s_decl.T;
P << extract_ima_write_s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_ima_write_s_decl_void@
identifier F = ima_write_s;
parameter list P;
@@
void F(P);

@script:python depends on extract_ima_write_s_decl_void@
F << extract_ima_write_s_decl_void.F;
P << extract_ima_write_s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: interleave_read_double
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_interleave_read_double_def@
type T;
identifier F = interleave_read_double;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_interleave_read_double_def@
F << remove_static_interleave_read_double_def.F;
T << remove_static_interleave_read_double_def.T;
P << remove_static_interleave_read_double_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_interleave_read_double_def_void@
identifier F = interleave_read_double;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_interleave_read_double_def_void@
F << remove_static_interleave_read_double_def_void.F;
P << remove_static_interleave_read_double_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_interleave_read_double_decl@
type T;
identifier F = interleave_read_double;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_interleave_read_double_decl@
F << remove_static_interleave_read_double_decl.F;
T << remove_static_interleave_read_double_decl.T;
P << remove_static_interleave_read_double_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_interleave_read_double_decl_void@
identifier F = interleave_read_double;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_interleave_read_double_decl_void@
F << remove_static_interleave_read_double_decl_void.F;
P << remove_static_interleave_read_double_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_interleave_read_double_def@
type T;
identifier F = interleave_read_double;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_interleave_read_double_def@
F << extract_interleave_read_double_def.F;
T << extract_interleave_read_double_def.T;
P << extract_interleave_read_double_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_interleave_read_double_def_void@
identifier F = interleave_read_double;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_interleave_read_double_def_void@
F << extract_interleave_read_double_def_void.F;
P << extract_interleave_read_double_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_interleave_read_double_decl@
type T;
identifier F = interleave_read_double;
parameter list P;
@@
T F(P);

@script:python depends on extract_interleave_read_double_decl@
F << extract_interleave_read_double_decl.F;
T << extract_interleave_read_double_decl.T;
P << extract_interleave_read_double_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_interleave_read_double_decl_void@
identifier F = interleave_read_double;
parameter list P;
@@
void F(P);

@script:python depends on extract_interleave_read_double_decl_void@
F << extract_interleave_read_double_decl_void.F;
P << extract_interleave_read_double_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: interleave_read_float
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_interleave_read_float_def@
type T;
identifier F = interleave_read_float;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_interleave_read_float_def@
F << remove_static_interleave_read_float_def.F;
T << remove_static_interleave_read_float_def.T;
P << remove_static_interleave_read_float_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_interleave_read_float_def_void@
identifier F = interleave_read_float;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_interleave_read_float_def_void@
F << remove_static_interleave_read_float_def_void.F;
P << remove_static_interleave_read_float_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_interleave_read_float_decl@
type T;
identifier F = interleave_read_float;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_interleave_read_float_decl@
F << remove_static_interleave_read_float_decl.F;
T << remove_static_interleave_read_float_decl.T;
P << remove_static_interleave_read_float_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_interleave_read_float_decl_void@
identifier F = interleave_read_float;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_interleave_read_float_decl_void@
F << remove_static_interleave_read_float_decl_void.F;
P << remove_static_interleave_read_float_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_interleave_read_float_def@
type T;
identifier F = interleave_read_float;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_interleave_read_float_def@
F << extract_interleave_read_float_def.F;
T << extract_interleave_read_float_def.T;
P << extract_interleave_read_float_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_interleave_read_float_def_void@
identifier F = interleave_read_float;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_interleave_read_float_def_void@
F << extract_interleave_read_float_def_void.F;
P << extract_interleave_read_float_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_interleave_read_float_decl@
type T;
identifier F = interleave_read_float;
parameter list P;
@@
T F(P);

@script:python depends on extract_interleave_read_float_decl@
F << extract_interleave_read_float_decl.F;
T << extract_interleave_read_float_decl.T;
P << extract_interleave_read_float_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_interleave_read_float_decl_void@
identifier F = interleave_read_float;
parameter list P;
@@
void F(P);

@script:python depends on extract_interleave_read_float_decl_void@
F << extract_interleave_read_float_decl_void.F;
P << extract_interleave_read_float_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: interleave_read_int
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_interleave_read_int_def@
type T;
identifier F = interleave_read_int;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_interleave_read_int_def@
F << remove_static_interleave_read_int_def.F;
T << remove_static_interleave_read_int_def.T;
P << remove_static_interleave_read_int_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_interleave_read_int_def_void@
identifier F = interleave_read_int;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_interleave_read_int_def_void@
F << remove_static_interleave_read_int_def_void.F;
P << remove_static_interleave_read_int_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_interleave_read_int_decl@
type T;
identifier F = interleave_read_int;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_interleave_read_int_decl@
F << remove_static_interleave_read_int_decl.F;
T << remove_static_interleave_read_int_decl.T;
P << remove_static_interleave_read_int_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_interleave_read_int_decl_void@
identifier F = interleave_read_int;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_interleave_read_int_decl_void@
F << remove_static_interleave_read_int_decl_void.F;
P << remove_static_interleave_read_int_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_interleave_read_int_def@
type T;
identifier F = interleave_read_int;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_interleave_read_int_def@
F << extract_interleave_read_int_def.F;
T << extract_interleave_read_int_def.T;
P << extract_interleave_read_int_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_interleave_read_int_def_void@
identifier F = interleave_read_int;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_interleave_read_int_def_void@
F << extract_interleave_read_int_def_void.F;
P << extract_interleave_read_int_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_interleave_read_int_decl@
type T;
identifier F = interleave_read_int;
parameter list P;
@@
T F(P);

@script:python depends on extract_interleave_read_int_decl@
F << extract_interleave_read_int_decl.F;
T << extract_interleave_read_int_decl.T;
P << extract_interleave_read_int_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_interleave_read_int_decl_void@
identifier F = interleave_read_int;
parameter list P;
@@
void F(P);

@script:python depends on extract_interleave_read_int_decl_void@
F << extract_interleave_read_int_decl_void.F;
P << extract_interleave_read_int_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: interleave_read_short
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_interleave_read_short_def@
type T;
identifier F = interleave_read_short;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_interleave_read_short_def@
F << remove_static_interleave_read_short_def.F;
T << remove_static_interleave_read_short_def.T;
P << remove_static_interleave_read_short_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_interleave_read_short_def_void@
identifier F = interleave_read_short;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_interleave_read_short_def_void@
F << remove_static_interleave_read_short_def_void.F;
P << remove_static_interleave_read_short_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_interleave_read_short_decl@
type T;
identifier F = interleave_read_short;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_interleave_read_short_decl@
F << remove_static_interleave_read_short_decl.F;
T << remove_static_interleave_read_short_decl.T;
P << remove_static_interleave_read_short_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_interleave_read_short_decl_void@
identifier F = interleave_read_short;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_interleave_read_short_decl_void@
F << remove_static_interleave_read_short_decl_void.F;
P << remove_static_interleave_read_short_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_interleave_read_short_def@
type T;
identifier F = interleave_read_short;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_interleave_read_short_def@
F << extract_interleave_read_short_def.F;
T << extract_interleave_read_short_def.T;
P << extract_interleave_read_short_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_interleave_read_short_def_void@
identifier F = interleave_read_short;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_interleave_read_short_def_void@
F << extract_interleave_read_short_def_void.F;
P << extract_interleave_read_short_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_interleave_read_short_decl@
type T;
identifier F = interleave_read_short;
parameter list P;
@@
T F(P);

@script:python depends on extract_interleave_read_short_decl@
F << extract_interleave_read_short_decl.F;
T << extract_interleave_read_short_decl.T;
P << extract_interleave_read_short_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_interleave_read_short_decl_void@
identifier F = interleave_read_short;
parameter list P;
@@
void F(P);

@script:python depends on extract_interleave_read_short_decl_void@
F << extract_interleave_read_short_decl_void.F;
P << extract_interleave_read_short_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: interleave_seek
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_interleave_seek_def@
type T;
identifier F = interleave_seek;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_interleave_seek_def@
F << remove_static_interleave_seek_def.F;
T << remove_static_interleave_seek_def.T;
P << remove_static_interleave_seek_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_interleave_seek_def_void@
identifier F = interleave_seek;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_interleave_seek_def_void@
F << remove_static_interleave_seek_def_void.F;
P << remove_static_interleave_seek_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_interleave_seek_decl@
type T;
identifier F = interleave_seek;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_interleave_seek_decl@
F << remove_static_interleave_seek_decl.F;
T << remove_static_interleave_seek_decl.T;
P << remove_static_interleave_seek_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_interleave_seek_decl_void@
identifier F = interleave_seek;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_interleave_seek_decl_void@
F << remove_static_interleave_seek_decl_void.F;
P << remove_static_interleave_seek_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_interleave_seek_def@
type T;
identifier F = interleave_seek;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_interleave_seek_def@
F << extract_interleave_seek_def.F;
T << extract_interleave_seek_def.T;
P << extract_interleave_seek_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_interleave_seek_def_void@
identifier F = interleave_seek;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_interleave_seek_def_void@
F << extract_interleave_seek_def_void.F;
P << extract_interleave_seek_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_interleave_seek_decl@
type T;
identifier F = interleave_seek;
parameter list P;
@@
T F(P);

@script:python depends on extract_interleave_seek_decl@
F << extract_interleave_seek_decl.F;
T << extract_interleave_seek_decl.T;
P << extract_interleave_seek_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_interleave_seek_decl_void@
identifier F = interleave_seek;
parameter list P;
@@
void F(P);

@script:python depends on extract_interleave_seek_decl_void@
F << extract_interleave_seek_decl_void.F;
P << extract_interleave_seek_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: ircam_close
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_ircam_close_def@
type T;
identifier F = ircam_close;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_ircam_close_def@
F << remove_static_ircam_close_def.F;
T << remove_static_ircam_close_def.T;
P << remove_static_ircam_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_ircam_close_def_void@
identifier F = ircam_close;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_ircam_close_def_void@
F << remove_static_ircam_close_def_void.F;
P << remove_static_ircam_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_ircam_close_decl@
type T;
identifier F = ircam_close;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_ircam_close_decl@
F << remove_static_ircam_close_decl.F;
T << remove_static_ircam_close_decl.T;
P << remove_static_ircam_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_ircam_close_decl_void@
identifier F = ircam_close;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_ircam_close_decl_void@
F << remove_static_ircam_close_decl_void.F;
P << remove_static_ircam_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_ircam_close_def@
type T;
identifier F = ircam_close;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_ircam_close_def@
F << extract_ircam_close_def.F;
T << extract_ircam_close_def.T;
P << extract_ircam_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_ircam_close_def_void@
identifier F = ircam_close;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_ircam_close_def_void@
F << extract_ircam_close_def_void.F;
P << extract_ircam_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_ircam_close_decl@
type T;
identifier F = ircam_close;
parameter list P;
@@
T F(P);

@script:python depends on extract_ircam_close_decl@
F << extract_ircam_close_decl.F;
T << extract_ircam_close_decl.T;
P << extract_ircam_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_ircam_close_decl_void@
identifier F = ircam_close;
parameter list P;
@@
void F(P);

@script:python depends on extract_ircam_close_decl_void@
F << extract_ircam_close_decl_void.F;
P << extract_ircam_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: ircam_write_header
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_ircam_write_header_def@
type T;
identifier F = ircam_write_header;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_ircam_write_header_def@
F << remove_static_ircam_write_header_def.F;
T << remove_static_ircam_write_header_def.T;
P << remove_static_ircam_write_header_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_ircam_write_header_def_void@
identifier F = ircam_write_header;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_ircam_write_header_def_void@
F << remove_static_ircam_write_header_def_void.F;
P << remove_static_ircam_write_header_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_ircam_write_header_decl@
type T;
identifier F = ircam_write_header;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_ircam_write_header_decl@
F << remove_static_ircam_write_header_decl.F;
T << remove_static_ircam_write_header_decl.T;
P << remove_static_ircam_write_header_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_ircam_write_header_decl_void@
identifier F = ircam_write_header;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_ircam_write_header_decl_void@
F << remove_static_ircam_write_header_decl_void.F;
P << remove_static_ircam_write_header_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_ircam_write_header_def@
type T;
identifier F = ircam_write_header;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_ircam_write_header_def@
F << extract_ircam_write_header_def.F;
T << extract_ircam_write_header_def.T;
P << extract_ircam_write_header_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_ircam_write_header_def_void@
identifier F = ircam_write_header;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_ircam_write_header_def_void@
F << extract_ircam_write_header_def_void.F;
P << extract_ircam_write_header_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_ircam_write_header_decl@
type T;
identifier F = ircam_write_header;
parameter list P;
@@
T F(P);

@script:python depends on extract_ircam_write_header_decl@
F << extract_ircam_write_header_decl.F;
T << extract_ircam_write_header_decl.T;
P << extract_ircam_write_header_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_ircam_write_header_decl_void@
identifier F = ircam_write_header;
parameter list P;
@@
void F(P);

@script:python depends on extract_ircam_write_header_decl_void@
F << extract_ircam_write_header_decl_void.F;
P << extract_ircam_write_header_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: mat4_close
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_mat4_close_def@
type T;
identifier F = mat4_close;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_mat4_close_def@
F << remove_static_mat4_close_def.F;
T << remove_static_mat4_close_def.T;
P << remove_static_mat4_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_mat4_close_def_void@
identifier F = mat4_close;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_mat4_close_def_void@
F << remove_static_mat4_close_def_void.F;
P << remove_static_mat4_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_mat4_close_decl@
type T;
identifier F = mat4_close;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_mat4_close_decl@
F << remove_static_mat4_close_decl.F;
T << remove_static_mat4_close_decl.T;
P << remove_static_mat4_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_mat4_close_decl_void@
identifier F = mat4_close;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_mat4_close_decl_void@
F << remove_static_mat4_close_decl_void.F;
P << remove_static_mat4_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_mat4_close_def@
type T;
identifier F = mat4_close;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_mat4_close_def@
F << extract_mat4_close_def.F;
T << extract_mat4_close_def.T;
P << extract_mat4_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_mat4_close_def_void@
identifier F = mat4_close;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_mat4_close_def_void@
F << extract_mat4_close_def_void.F;
P << extract_mat4_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_mat4_close_decl@
type T;
identifier F = mat4_close;
parameter list P;
@@
T F(P);

@script:python depends on extract_mat4_close_decl@
F << extract_mat4_close_decl.F;
T << extract_mat4_close_decl.T;
P << extract_mat4_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_mat4_close_decl_void@
identifier F = mat4_close;
parameter list P;
@@
void F(P);

@script:python depends on extract_mat4_close_decl_void@
F << extract_mat4_close_decl_void.F;
P << extract_mat4_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: mat4_write_header
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_mat4_write_header_def@
type T;
identifier F = mat4_write_header;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_mat4_write_header_def@
F << remove_static_mat4_write_header_def.F;
T << remove_static_mat4_write_header_def.T;
P << remove_static_mat4_write_header_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_mat4_write_header_def_void@
identifier F = mat4_write_header;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_mat4_write_header_def_void@
F << remove_static_mat4_write_header_def_void.F;
P << remove_static_mat4_write_header_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_mat4_write_header_decl@
type T;
identifier F = mat4_write_header;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_mat4_write_header_decl@
F << remove_static_mat4_write_header_decl.F;
T << remove_static_mat4_write_header_decl.T;
P << remove_static_mat4_write_header_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_mat4_write_header_decl_void@
identifier F = mat4_write_header;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_mat4_write_header_decl_void@
F << remove_static_mat4_write_header_decl_void.F;
P << remove_static_mat4_write_header_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_mat4_write_header_def@
type T;
identifier F = mat4_write_header;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_mat4_write_header_def@
F << extract_mat4_write_header_def.F;
T << extract_mat4_write_header_def.T;
P << extract_mat4_write_header_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_mat4_write_header_def_void@
identifier F = mat4_write_header;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_mat4_write_header_def_void@
F << extract_mat4_write_header_def_void.F;
P << extract_mat4_write_header_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_mat4_write_header_decl@
type T;
identifier F = mat4_write_header;
parameter list P;
@@
T F(P);

@script:python depends on extract_mat4_write_header_decl@
F << extract_mat4_write_header_decl.F;
T << extract_mat4_write_header_decl.T;
P << extract_mat4_write_header_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_mat4_write_header_decl_void@
identifier F = mat4_write_header;
parameter list P;
@@
void F(P);

@script:python depends on extract_mat4_write_header_decl_void@
F << extract_mat4_write_header_decl_void.F;
P << extract_mat4_write_header_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: mat5_close
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_mat5_close_def@
type T;
identifier F = mat5_close;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_mat5_close_def@
F << remove_static_mat5_close_def.F;
T << remove_static_mat5_close_def.T;
P << remove_static_mat5_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_mat5_close_def_void@
identifier F = mat5_close;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_mat5_close_def_void@
F << remove_static_mat5_close_def_void.F;
P << remove_static_mat5_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_mat5_close_decl@
type T;
identifier F = mat5_close;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_mat5_close_decl@
F << remove_static_mat5_close_decl.F;
T << remove_static_mat5_close_decl.T;
P << remove_static_mat5_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_mat5_close_decl_void@
identifier F = mat5_close;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_mat5_close_decl_void@
F << remove_static_mat5_close_decl_void.F;
P << remove_static_mat5_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_mat5_close_def@
type T;
identifier F = mat5_close;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_mat5_close_def@
F << extract_mat5_close_def.F;
T << extract_mat5_close_def.T;
P << extract_mat5_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_mat5_close_def_void@
identifier F = mat5_close;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_mat5_close_def_void@
F << extract_mat5_close_def_void.F;
P << extract_mat5_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_mat5_close_decl@
type T;
identifier F = mat5_close;
parameter list P;
@@
T F(P);

@script:python depends on extract_mat5_close_decl@
F << extract_mat5_close_decl.F;
T << extract_mat5_close_decl.T;
P << extract_mat5_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_mat5_close_decl_void@
identifier F = mat5_close;
parameter list P;
@@
void F(P);

@script:python depends on extract_mat5_close_decl_void@
F << extract_mat5_close_decl_void.F;
P << extract_mat5_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: mat5_write_header
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_mat5_write_header_def@
type T;
identifier F = mat5_write_header;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_mat5_write_header_def@
F << remove_static_mat5_write_header_def.F;
T << remove_static_mat5_write_header_def.T;
P << remove_static_mat5_write_header_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_mat5_write_header_def_void@
identifier F = mat5_write_header;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_mat5_write_header_def_void@
F << remove_static_mat5_write_header_def_void.F;
P << remove_static_mat5_write_header_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_mat5_write_header_decl@
type T;
identifier F = mat5_write_header;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_mat5_write_header_decl@
F << remove_static_mat5_write_header_decl.F;
T << remove_static_mat5_write_header_decl.T;
P << remove_static_mat5_write_header_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_mat5_write_header_decl_void@
identifier F = mat5_write_header;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_mat5_write_header_decl_void@
F << remove_static_mat5_write_header_decl_void.F;
P << remove_static_mat5_write_header_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_mat5_write_header_def@
type T;
identifier F = mat5_write_header;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_mat5_write_header_def@
F << extract_mat5_write_header_def.F;
T << extract_mat5_write_header_def.T;
P << extract_mat5_write_header_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_mat5_write_header_def_void@
identifier F = mat5_write_header;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_mat5_write_header_def_void@
F << extract_mat5_write_header_def_void.F;
P << extract_mat5_write_header_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_mat5_write_header_decl@
type T;
identifier F = mat5_write_header;
parameter list P;
@@
T F(P);

@script:python depends on extract_mat5_write_header_decl@
F << extract_mat5_write_header_decl.F;
T << extract_mat5_write_header_decl.T;
P << extract_mat5_write_header_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_mat5_write_header_decl_void@
identifier F = mat5_write_header;
parameter list P;
@@
void F(P);

@script:python depends on extract_mat5_write_header_decl_void@
F << extract_mat5_write_header_decl_void.F;
P << extract_mat5_write_header_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: mpc2k_close
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_mpc2k_close_def@
type T;
identifier F = mpc2k_close;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_mpc2k_close_def@
F << remove_static_mpc2k_close_def.F;
T << remove_static_mpc2k_close_def.T;
P << remove_static_mpc2k_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_mpc2k_close_def_void@
identifier F = mpc2k_close;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_mpc2k_close_def_void@
F << remove_static_mpc2k_close_def_void.F;
P << remove_static_mpc2k_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_mpc2k_close_decl@
type T;
identifier F = mpc2k_close;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_mpc2k_close_decl@
F << remove_static_mpc2k_close_decl.F;
T << remove_static_mpc2k_close_decl.T;
P << remove_static_mpc2k_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_mpc2k_close_decl_void@
identifier F = mpc2k_close;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_mpc2k_close_decl_void@
F << remove_static_mpc2k_close_decl_void.F;
P << remove_static_mpc2k_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_mpc2k_close_def@
type T;
identifier F = mpc2k_close;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_mpc2k_close_def@
F << extract_mpc2k_close_def.F;
T << extract_mpc2k_close_def.T;
P << extract_mpc2k_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_mpc2k_close_def_void@
identifier F = mpc2k_close;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_mpc2k_close_def_void@
F << extract_mpc2k_close_def_void.F;
P << extract_mpc2k_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_mpc2k_close_decl@
type T;
identifier F = mpc2k_close;
parameter list P;
@@
T F(P);

@script:python depends on extract_mpc2k_close_decl@
F << extract_mpc2k_close_decl.F;
T << extract_mpc2k_close_decl.T;
P << extract_mpc2k_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_mpc2k_close_decl_void@
identifier F = mpc2k_close;
parameter list P;
@@
void F(P);

@script:python depends on extract_mpc2k_close_decl_void@
F << extract_mpc2k_close_decl_void.F;
P << extract_mpc2k_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: mpc2k_write_header
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_mpc2k_write_header_def@
type T;
identifier F = mpc2k_write_header;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_mpc2k_write_header_def@
F << remove_static_mpc2k_write_header_def.F;
T << remove_static_mpc2k_write_header_def.T;
P << remove_static_mpc2k_write_header_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_mpc2k_write_header_def_void@
identifier F = mpc2k_write_header;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_mpc2k_write_header_def_void@
F << remove_static_mpc2k_write_header_def_void.F;
P << remove_static_mpc2k_write_header_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_mpc2k_write_header_decl@
type T;
identifier F = mpc2k_write_header;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_mpc2k_write_header_decl@
F << remove_static_mpc2k_write_header_decl.F;
T << remove_static_mpc2k_write_header_decl.T;
P << remove_static_mpc2k_write_header_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_mpc2k_write_header_decl_void@
identifier F = mpc2k_write_header;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_mpc2k_write_header_decl_void@
F << remove_static_mpc2k_write_header_decl_void.F;
P << remove_static_mpc2k_write_header_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_mpc2k_write_header_def@
type T;
identifier F = mpc2k_write_header;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_mpc2k_write_header_def@
F << extract_mpc2k_write_header_def.F;
T << extract_mpc2k_write_header_def.T;
P << extract_mpc2k_write_header_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_mpc2k_write_header_def_void@
identifier F = mpc2k_write_header;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_mpc2k_write_header_def_void@
F << extract_mpc2k_write_header_def_void.F;
P << extract_mpc2k_write_header_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_mpc2k_write_header_decl@
type T;
identifier F = mpc2k_write_header;
parameter list P;
@@
T F(P);

@script:python depends on extract_mpc2k_write_header_decl@
F << extract_mpc2k_write_header_decl.F;
T << extract_mpc2k_write_header_decl.T;
P << extract_mpc2k_write_header_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_mpc2k_write_header_decl_void@
identifier F = mpc2k_write_header;
parameter list P;
@@
void F(P);

@script:python depends on extract_mpc2k_write_header_decl_void@
F << extract_mpc2k_write_header_decl_void.F;
P << extract_mpc2k_write_header_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: mpeg_command
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_mpeg_command_def@
type T;
identifier F = mpeg_command;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_mpeg_command_def@
F << remove_static_mpeg_command_def.F;
T << remove_static_mpeg_command_def.T;
P << remove_static_mpeg_command_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_mpeg_command_def_void@
identifier F = mpeg_command;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_mpeg_command_def_void@
F << remove_static_mpeg_command_def_void.F;
P << remove_static_mpeg_command_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_mpeg_command_decl@
type T;
identifier F = mpeg_command;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_mpeg_command_decl@
F << remove_static_mpeg_command_decl.F;
T << remove_static_mpeg_command_decl.T;
P << remove_static_mpeg_command_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_mpeg_command_decl_void@
identifier F = mpeg_command;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_mpeg_command_decl_void@
F << remove_static_mpeg_command_decl_void.F;
P << remove_static_mpeg_command_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_mpeg_command_def@
type T;
identifier F = mpeg_command;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_mpeg_command_def@
F << extract_mpeg_command_def.F;
T << extract_mpeg_command_def.T;
P << extract_mpeg_command_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_mpeg_command_def_void@
identifier F = mpeg_command;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_mpeg_command_def_void@
F << extract_mpeg_command_def_void.F;
P << extract_mpeg_command_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_mpeg_command_decl@
type T;
identifier F = mpeg_command;
parameter list P;
@@
T F(P);

@script:python depends on extract_mpeg_command_decl@
F << extract_mpeg_command_decl.F;
T << extract_mpeg_command_decl.T;
P << extract_mpeg_command_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_mpeg_command_decl_void@
identifier F = mpeg_command;
parameter list P;
@@
void F(P);

@script:python depends on extract_mpeg_command_decl_void@
F << extract_mpeg_command_decl_void.F;
P << extract_mpeg_command_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: mpeg_dec_byterate
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_mpeg_dec_byterate_def@
type T;
identifier F = mpeg_dec_byterate;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_mpeg_dec_byterate_def@
F << remove_static_mpeg_dec_byterate_def.F;
T << remove_static_mpeg_dec_byterate_def.T;
P << remove_static_mpeg_dec_byterate_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_mpeg_dec_byterate_def_void@
identifier F = mpeg_dec_byterate;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_mpeg_dec_byterate_def_void@
F << remove_static_mpeg_dec_byterate_def_void.F;
P << remove_static_mpeg_dec_byterate_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_mpeg_dec_byterate_decl@
type T;
identifier F = mpeg_dec_byterate;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_mpeg_dec_byterate_decl@
F << remove_static_mpeg_dec_byterate_decl.F;
T << remove_static_mpeg_dec_byterate_decl.T;
P << remove_static_mpeg_dec_byterate_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_mpeg_dec_byterate_decl_void@
identifier F = mpeg_dec_byterate;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_mpeg_dec_byterate_decl_void@
F << remove_static_mpeg_dec_byterate_decl_void.F;
P << remove_static_mpeg_dec_byterate_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_mpeg_dec_byterate_def@
type T;
identifier F = mpeg_dec_byterate;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_mpeg_dec_byterate_def@
F << extract_mpeg_dec_byterate_def.F;
T << extract_mpeg_dec_byterate_def.T;
P << extract_mpeg_dec_byterate_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_mpeg_dec_byterate_def_void@
identifier F = mpeg_dec_byterate;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_mpeg_dec_byterate_def_void@
F << extract_mpeg_dec_byterate_def_void.F;
P << extract_mpeg_dec_byterate_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_mpeg_dec_byterate_decl@
type T;
identifier F = mpeg_dec_byterate;
parameter list P;
@@
T F(P);

@script:python depends on extract_mpeg_dec_byterate_decl@
F << extract_mpeg_dec_byterate_decl.F;
T << extract_mpeg_dec_byterate_decl.T;
P << extract_mpeg_dec_byterate_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_mpeg_dec_byterate_decl_void@
identifier F = mpeg_dec_byterate;
parameter list P;
@@
void F(P);

@script:python depends on extract_mpeg_dec_byterate_decl_void@
F << extract_mpeg_dec_byterate_decl_void.F;
P << extract_mpeg_dec_byterate_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: mpeg_dec_close
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_mpeg_dec_close_def@
type T;
identifier F = mpeg_dec_close;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_mpeg_dec_close_def@
F << remove_static_mpeg_dec_close_def.F;
T << remove_static_mpeg_dec_close_def.T;
P << remove_static_mpeg_dec_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_mpeg_dec_close_def_void@
identifier F = mpeg_dec_close;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_mpeg_dec_close_def_void@
F << remove_static_mpeg_dec_close_def_void.F;
P << remove_static_mpeg_dec_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_mpeg_dec_close_decl@
type T;
identifier F = mpeg_dec_close;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_mpeg_dec_close_decl@
F << remove_static_mpeg_dec_close_decl.F;
T << remove_static_mpeg_dec_close_decl.T;
P << remove_static_mpeg_dec_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_mpeg_dec_close_decl_void@
identifier F = mpeg_dec_close;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_mpeg_dec_close_decl_void@
F << remove_static_mpeg_dec_close_decl_void.F;
P << remove_static_mpeg_dec_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_mpeg_dec_close_def@
type T;
identifier F = mpeg_dec_close;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_mpeg_dec_close_def@
F << extract_mpeg_dec_close_def.F;
T << extract_mpeg_dec_close_def.T;
P << extract_mpeg_dec_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_mpeg_dec_close_def_void@
identifier F = mpeg_dec_close;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_mpeg_dec_close_def_void@
F << extract_mpeg_dec_close_def_void.F;
P << extract_mpeg_dec_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_mpeg_dec_close_decl@
type T;
identifier F = mpeg_dec_close;
parameter list P;
@@
T F(P);

@script:python depends on extract_mpeg_dec_close_decl@
F << extract_mpeg_dec_close_decl.F;
T << extract_mpeg_dec_close_decl.T;
P << extract_mpeg_dec_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_mpeg_dec_close_decl_void@
identifier F = mpeg_dec_close;
parameter list P;
@@
void F(P);

@script:python depends on extract_mpeg_dec_close_decl_void@
F << extract_mpeg_dec_close_decl_void.F;
P << extract_mpeg_dec_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: mpeg_dec_read_d
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_mpeg_dec_read_d_def@
type T;
identifier F = mpeg_dec_read_d;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_mpeg_dec_read_d_def@
F << remove_static_mpeg_dec_read_d_def.F;
T << remove_static_mpeg_dec_read_d_def.T;
P << remove_static_mpeg_dec_read_d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_mpeg_dec_read_d_def_void@
identifier F = mpeg_dec_read_d;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_mpeg_dec_read_d_def_void@
F << remove_static_mpeg_dec_read_d_def_void.F;
P << remove_static_mpeg_dec_read_d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_mpeg_dec_read_d_decl@
type T;
identifier F = mpeg_dec_read_d;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_mpeg_dec_read_d_decl@
F << remove_static_mpeg_dec_read_d_decl.F;
T << remove_static_mpeg_dec_read_d_decl.T;
P << remove_static_mpeg_dec_read_d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_mpeg_dec_read_d_decl_void@
identifier F = mpeg_dec_read_d;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_mpeg_dec_read_d_decl_void@
F << remove_static_mpeg_dec_read_d_decl_void.F;
P << remove_static_mpeg_dec_read_d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_mpeg_dec_read_d_def@
type T;
identifier F = mpeg_dec_read_d;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_mpeg_dec_read_d_def@
F << extract_mpeg_dec_read_d_def.F;
T << extract_mpeg_dec_read_d_def.T;
P << extract_mpeg_dec_read_d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_mpeg_dec_read_d_def_void@
identifier F = mpeg_dec_read_d;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_mpeg_dec_read_d_def_void@
F << extract_mpeg_dec_read_d_def_void.F;
P << extract_mpeg_dec_read_d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_mpeg_dec_read_d_decl@
type T;
identifier F = mpeg_dec_read_d;
parameter list P;
@@
T F(P);

@script:python depends on extract_mpeg_dec_read_d_decl@
F << extract_mpeg_dec_read_d_decl.F;
T << extract_mpeg_dec_read_d_decl.T;
P << extract_mpeg_dec_read_d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_mpeg_dec_read_d_decl_void@
identifier F = mpeg_dec_read_d;
parameter list P;
@@
void F(P);

@script:python depends on extract_mpeg_dec_read_d_decl_void@
F << extract_mpeg_dec_read_d_decl_void.F;
P << extract_mpeg_dec_read_d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: mpeg_dec_read_f
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_mpeg_dec_read_f_def@
type T;
identifier F = mpeg_dec_read_f;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_mpeg_dec_read_f_def@
F << remove_static_mpeg_dec_read_f_def.F;
T << remove_static_mpeg_dec_read_f_def.T;
P << remove_static_mpeg_dec_read_f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_mpeg_dec_read_f_def_void@
identifier F = mpeg_dec_read_f;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_mpeg_dec_read_f_def_void@
F << remove_static_mpeg_dec_read_f_def_void.F;
P << remove_static_mpeg_dec_read_f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_mpeg_dec_read_f_decl@
type T;
identifier F = mpeg_dec_read_f;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_mpeg_dec_read_f_decl@
F << remove_static_mpeg_dec_read_f_decl.F;
T << remove_static_mpeg_dec_read_f_decl.T;
P << remove_static_mpeg_dec_read_f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_mpeg_dec_read_f_decl_void@
identifier F = mpeg_dec_read_f;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_mpeg_dec_read_f_decl_void@
F << remove_static_mpeg_dec_read_f_decl_void.F;
P << remove_static_mpeg_dec_read_f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_mpeg_dec_read_f_def@
type T;
identifier F = mpeg_dec_read_f;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_mpeg_dec_read_f_def@
F << extract_mpeg_dec_read_f_def.F;
T << extract_mpeg_dec_read_f_def.T;
P << extract_mpeg_dec_read_f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_mpeg_dec_read_f_def_void@
identifier F = mpeg_dec_read_f;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_mpeg_dec_read_f_def_void@
F << extract_mpeg_dec_read_f_def_void.F;
P << extract_mpeg_dec_read_f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_mpeg_dec_read_f_decl@
type T;
identifier F = mpeg_dec_read_f;
parameter list P;
@@
T F(P);

@script:python depends on extract_mpeg_dec_read_f_decl@
F << extract_mpeg_dec_read_f_decl.F;
T << extract_mpeg_dec_read_f_decl.T;
P << extract_mpeg_dec_read_f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_mpeg_dec_read_f_decl_void@
identifier F = mpeg_dec_read_f;
parameter list P;
@@
void F(P);

@script:python depends on extract_mpeg_dec_read_f_decl_void@
F << extract_mpeg_dec_read_f_decl_void.F;
P << extract_mpeg_dec_read_f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: mpeg_dec_read_i
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_mpeg_dec_read_i_def@
type T;
identifier F = mpeg_dec_read_i;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_mpeg_dec_read_i_def@
F << remove_static_mpeg_dec_read_i_def.F;
T << remove_static_mpeg_dec_read_i_def.T;
P << remove_static_mpeg_dec_read_i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_mpeg_dec_read_i_def_void@
identifier F = mpeg_dec_read_i;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_mpeg_dec_read_i_def_void@
F << remove_static_mpeg_dec_read_i_def_void.F;
P << remove_static_mpeg_dec_read_i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_mpeg_dec_read_i_decl@
type T;
identifier F = mpeg_dec_read_i;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_mpeg_dec_read_i_decl@
F << remove_static_mpeg_dec_read_i_decl.F;
T << remove_static_mpeg_dec_read_i_decl.T;
P << remove_static_mpeg_dec_read_i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_mpeg_dec_read_i_decl_void@
identifier F = mpeg_dec_read_i;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_mpeg_dec_read_i_decl_void@
F << remove_static_mpeg_dec_read_i_decl_void.F;
P << remove_static_mpeg_dec_read_i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_mpeg_dec_read_i_def@
type T;
identifier F = mpeg_dec_read_i;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_mpeg_dec_read_i_def@
F << extract_mpeg_dec_read_i_def.F;
T << extract_mpeg_dec_read_i_def.T;
P << extract_mpeg_dec_read_i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_mpeg_dec_read_i_def_void@
identifier F = mpeg_dec_read_i;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_mpeg_dec_read_i_def_void@
F << extract_mpeg_dec_read_i_def_void.F;
P << extract_mpeg_dec_read_i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_mpeg_dec_read_i_decl@
type T;
identifier F = mpeg_dec_read_i;
parameter list P;
@@
T F(P);

@script:python depends on extract_mpeg_dec_read_i_decl@
F << extract_mpeg_dec_read_i_decl.F;
T << extract_mpeg_dec_read_i_decl.T;
P << extract_mpeg_dec_read_i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_mpeg_dec_read_i_decl_void@
identifier F = mpeg_dec_read_i;
parameter list P;
@@
void F(P);

@script:python depends on extract_mpeg_dec_read_i_decl_void@
F << extract_mpeg_dec_read_i_decl_void.F;
P << extract_mpeg_dec_read_i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: mpeg_dec_read_s
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_mpeg_dec_read_s_def@
type T;
identifier F = mpeg_dec_read_s;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_mpeg_dec_read_s_def@
F << remove_static_mpeg_dec_read_s_def.F;
T << remove_static_mpeg_dec_read_s_def.T;
P << remove_static_mpeg_dec_read_s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_mpeg_dec_read_s_def_void@
identifier F = mpeg_dec_read_s;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_mpeg_dec_read_s_def_void@
F << remove_static_mpeg_dec_read_s_def_void.F;
P << remove_static_mpeg_dec_read_s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_mpeg_dec_read_s_decl@
type T;
identifier F = mpeg_dec_read_s;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_mpeg_dec_read_s_decl@
F << remove_static_mpeg_dec_read_s_decl.F;
T << remove_static_mpeg_dec_read_s_decl.T;
P << remove_static_mpeg_dec_read_s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_mpeg_dec_read_s_decl_void@
identifier F = mpeg_dec_read_s;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_mpeg_dec_read_s_decl_void@
F << remove_static_mpeg_dec_read_s_decl_void.F;
P << remove_static_mpeg_dec_read_s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_mpeg_dec_read_s_def@
type T;
identifier F = mpeg_dec_read_s;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_mpeg_dec_read_s_def@
F << extract_mpeg_dec_read_s_def.F;
T << extract_mpeg_dec_read_s_def.T;
P << extract_mpeg_dec_read_s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_mpeg_dec_read_s_def_void@
identifier F = mpeg_dec_read_s;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_mpeg_dec_read_s_def_void@
F << extract_mpeg_dec_read_s_def_void.F;
P << extract_mpeg_dec_read_s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_mpeg_dec_read_s_decl@
type T;
identifier F = mpeg_dec_read_s;
parameter list P;
@@
T F(P);

@script:python depends on extract_mpeg_dec_read_s_decl@
F << extract_mpeg_dec_read_s_decl.F;
T << extract_mpeg_dec_read_s_decl.T;
P << extract_mpeg_dec_read_s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_mpeg_dec_read_s_decl_void@
identifier F = mpeg_dec_read_s;
parameter list P;
@@
void F(P);

@script:python depends on extract_mpeg_dec_read_s_decl_void@
F << extract_mpeg_dec_read_s_decl_void.F;
P << extract_mpeg_dec_read_s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: mpeg_dec_seek
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_mpeg_dec_seek_def@
type T;
identifier F = mpeg_dec_seek;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_mpeg_dec_seek_def@
F << remove_static_mpeg_dec_seek_def.F;
T << remove_static_mpeg_dec_seek_def.T;
P << remove_static_mpeg_dec_seek_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_mpeg_dec_seek_def_void@
identifier F = mpeg_dec_seek;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_mpeg_dec_seek_def_void@
F << remove_static_mpeg_dec_seek_def_void.F;
P << remove_static_mpeg_dec_seek_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_mpeg_dec_seek_decl@
type T;
identifier F = mpeg_dec_seek;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_mpeg_dec_seek_decl@
F << remove_static_mpeg_dec_seek_decl.F;
T << remove_static_mpeg_dec_seek_decl.T;
P << remove_static_mpeg_dec_seek_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_mpeg_dec_seek_decl_void@
identifier F = mpeg_dec_seek;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_mpeg_dec_seek_decl_void@
F << remove_static_mpeg_dec_seek_decl_void.F;
P << remove_static_mpeg_dec_seek_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_mpeg_dec_seek_def@
type T;
identifier F = mpeg_dec_seek;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_mpeg_dec_seek_def@
F << extract_mpeg_dec_seek_def.F;
T << extract_mpeg_dec_seek_def.T;
P << extract_mpeg_dec_seek_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_mpeg_dec_seek_def_void@
identifier F = mpeg_dec_seek;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_mpeg_dec_seek_def_void@
F << extract_mpeg_dec_seek_def_void.F;
P << extract_mpeg_dec_seek_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_mpeg_dec_seek_decl@
type T;
identifier F = mpeg_dec_seek;
parameter list P;
@@
T F(P);

@script:python depends on extract_mpeg_dec_seek_decl@
F << extract_mpeg_dec_seek_decl.F;
T << extract_mpeg_dec_seek_decl.T;
P << extract_mpeg_dec_seek_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_mpeg_dec_seek_decl_void@
identifier F = mpeg_dec_seek;
parameter list P;
@@
void F(P);

@script:python depends on extract_mpeg_dec_seek_decl_void@
F << extract_mpeg_dec_seek_decl_void.F;
P << extract_mpeg_dec_seek_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: mpeg_l3_encode_write_double_mono
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_mpeg_l3_encode_write_double_mono_def@
type T;
identifier F = mpeg_l3_encode_write_double_mono;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_mpeg_l3_encode_write_double_mono_def@
F << remove_static_mpeg_l3_encode_write_double_mono_def.F;
T << remove_static_mpeg_l3_encode_write_double_mono_def.T;
P << remove_static_mpeg_l3_encode_write_double_mono_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_mpeg_l3_encode_write_double_mono_def_void@
identifier F = mpeg_l3_encode_write_double_mono;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_mpeg_l3_encode_write_double_mono_def_void@
F << remove_static_mpeg_l3_encode_write_double_mono_def_void.F;
P << remove_static_mpeg_l3_encode_write_double_mono_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_mpeg_l3_encode_write_double_mono_decl@
type T;
identifier F = mpeg_l3_encode_write_double_mono;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_mpeg_l3_encode_write_double_mono_decl@
F << remove_static_mpeg_l3_encode_write_double_mono_decl.F;
T << remove_static_mpeg_l3_encode_write_double_mono_decl.T;
P << remove_static_mpeg_l3_encode_write_double_mono_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_mpeg_l3_encode_write_double_mono_decl_void@
identifier F = mpeg_l3_encode_write_double_mono;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_mpeg_l3_encode_write_double_mono_decl_void@
F << remove_static_mpeg_l3_encode_write_double_mono_decl_void.F;
P << remove_static_mpeg_l3_encode_write_double_mono_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_mpeg_l3_encode_write_double_mono_def@
type T;
identifier F = mpeg_l3_encode_write_double_mono;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_mpeg_l3_encode_write_double_mono_def@
F << extract_mpeg_l3_encode_write_double_mono_def.F;
T << extract_mpeg_l3_encode_write_double_mono_def.T;
P << extract_mpeg_l3_encode_write_double_mono_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_mpeg_l3_encode_write_double_mono_def_void@
identifier F = mpeg_l3_encode_write_double_mono;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_mpeg_l3_encode_write_double_mono_def_void@
F << extract_mpeg_l3_encode_write_double_mono_def_void.F;
P << extract_mpeg_l3_encode_write_double_mono_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_mpeg_l3_encode_write_double_mono_decl@
type T;
identifier F = mpeg_l3_encode_write_double_mono;
parameter list P;
@@
T F(P);

@script:python depends on extract_mpeg_l3_encode_write_double_mono_decl@
F << extract_mpeg_l3_encode_write_double_mono_decl.F;
T << extract_mpeg_l3_encode_write_double_mono_decl.T;
P << extract_mpeg_l3_encode_write_double_mono_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_mpeg_l3_encode_write_double_mono_decl_void@
identifier F = mpeg_l3_encode_write_double_mono;
parameter list P;
@@
void F(P);

@script:python depends on extract_mpeg_l3_encode_write_double_mono_decl_void@
F << extract_mpeg_l3_encode_write_double_mono_decl_void.F;
P << extract_mpeg_l3_encode_write_double_mono_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: mpeg_l3_encode_write_double_stereo
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_mpeg_l3_encode_write_double_stereo_def@
type T;
identifier F = mpeg_l3_encode_write_double_stereo;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_mpeg_l3_encode_write_double_stereo_def@
F << remove_static_mpeg_l3_encode_write_double_stereo_def.F;
T << remove_static_mpeg_l3_encode_write_double_stereo_def.T;
P << remove_static_mpeg_l3_encode_write_double_stereo_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_mpeg_l3_encode_write_double_stereo_def_void@
identifier F = mpeg_l3_encode_write_double_stereo;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_mpeg_l3_encode_write_double_stereo_def_void@
F << remove_static_mpeg_l3_encode_write_double_stereo_def_void.F;
P << remove_static_mpeg_l3_encode_write_double_stereo_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_mpeg_l3_encode_write_double_stereo_decl@
type T;
identifier F = mpeg_l3_encode_write_double_stereo;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_mpeg_l3_encode_write_double_stereo_decl@
F << remove_static_mpeg_l3_encode_write_double_stereo_decl.F;
T << remove_static_mpeg_l3_encode_write_double_stereo_decl.T;
P << remove_static_mpeg_l3_encode_write_double_stereo_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_mpeg_l3_encode_write_double_stereo_decl_void@
identifier F = mpeg_l3_encode_write_double_stereo;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_mpeg_l3_encode_write_double_stereo_decl_void@
F << remove_static_mpeg_l3_encode_write_double_stereo_decl_void.F;
P << remove_static_mpeg_l3_encode_write_double_stereo_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_mpeg_l3_encode_write_double_stereo_def@
type T;
identifier F = mpeg_l3_encode_write_double_stereo;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_mpeg_l3_encode_write_double_stereo_def@
F << extract_mpeg_l3_encode_write_double_stereo_def.F;
T << extract_mpeg_l3_encode_write_double_stereo_def.T;
P << extract_mpeg_l3_encode_write_double_stereo_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_mpeg_l3_encode_write_double_stereo_def_void@
identifier F = mpeg_l3_encode_write_double_stereo;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_mpeg_l3_encode_write_double_stereo_def_void@
F << extract_mpeg_l3_encode_write_double_stereo_def_void.F;
P << extract_mpeg_l3_encode_write_double_stereo_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_mpeg_l3_encode_write_double_stereo_decl@
type T;
identifier F = mpeg_l3_encode_write_double_stereo;
parameter list P;
@@
T F(P);

@script:python depends on extract_mpeg_l3_encode_write_double_stereo_decl@
F << extract_mpeg_l3_encode_write_double_stereo_decl.F;
T << extract_mpeg_l3_encode_write_double_stereo_decl.T;
P << extract_mpeg_l3_encode_write_double_stereo_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_mpeg_l3_encode_write_double_stereo_decl_void@
identifier F = mpeg_l3_encode_write_double_stereo;
parameter list P;
@@
void F(P);

@script:python depends on extract_mpeg_l3_encode_write_double_stereo_decl_void@
F << extract_mpeg_l3_encode_write_double_stereo_decl_void.F;
P << extract_mpeg_l3_encode_write_double_stereo_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: mpeg_l3_encode_write_float_mono
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_mpeg_l3_encode_write_float_mono_def@
type T;
identifier F = mpeg_l3_encode_write_float_mono;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_mpeg_l3_encode_write_float_mono_def@
F << remove_static_mpeg_l3_encode_write_float_mono_def.F;
T << remove_static_mpeg_l3_encode_write_float_mono_def.T;
P << remove_static_mpeg_l3_encode_write_float_mono_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_mpeg_l3_encode_write_float_mono_def_void@
identifier F = mpeg_l3_encode_write_float_mono;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_mpeg_l3_encode_write_float_mono_def_void@
F << remove_static_mpeg_l3_encode_write_float_mono_def_void.F;
P << remove_static_mpeg_l3_encode_write_float_mono_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_mpeg_l3_encode_write_float_mono_decl@
type T;
identifier F = mpeg_l3_encode_write_float_mono;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_mpeg_l3_encode_write_float_mono_decl@
F << remove_static_mpeg_l3_encode_write_float_mono_decl.F;
T << remove_static_mpeg_l3_encode_write_float_mono_decl.T;
P << remove_static_mpeg_l3_encode_write_float_mono_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_mpeg_l3_encode_write_float_mono_decl_void@
identifier F = mpeg_l3_encode_write_float_mono;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_mpeg_l3_encode_write_float_mono_decl_void@
F << remove_static_mpeg_l3_encode_write_float_mono_decl_void.F;
P << remove_static_mpeg_l3_encode_write_float_mono_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_mpeg_l3_encode_write_float_mono_def@
type T;
identifier F = mpeg_l3_encode_write_float_mono;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_mpeg_l3_encode_write_float_mono_def@
F << extract_mpeg_l3_encode_write_float_mono_def.F;
T << extract_mpeg_l3_encode_write_float_mono_def.T;
P << extract_mpeg_l3_encode_write_float_mono_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_mpeg_l3_encode_write_float_mono_def_void@
identifier F = mpeg_l3_encode_write_float_mono;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_mpeg_l3_encode_write_float_mono_def_void@
F << extract_mpeg_l3_encode_write_float_mono_def_void.F;
P << extract_mpeg_l3_encode_write_float_mono_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_mpeg_l3_encode_write_float_mono_decl@
type T;
identifier F = mpeg_l3_encode_write_float_mono;
parameter list P;
@@
T F(P);

@script:python depends on extract_mpeg_l3_encode_write_float_mono_decl@
F << extract_mpeg_l3_encode_write_float_mono_decl.F;
T << extract_mpeg_l3_encode_write_float_mono_decl.T;
P << extract_mpeg_l3_encode_write_float_mono_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_mpeg_l3_encode_write_float_mono_decl_void@
identifier F = mpeg_l3_encode_write_float_mono;
parameter list P;
@@
void F(P);

@script:python depends on extract_mpeg_l3_encode_write_float_mono_decl_void@
F << extract_mpeg_l3_encode_write_float_mono_decl_void.F;
P << extract_mpeg_l3_encode_write_float_mono_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: mpeg_l3_encode_write_float_stereo
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_mpeg_l3_encode_write_float_stereo_def@
type T;
identifier F = mpeg_l3_encode_write_float_stereo;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_mpeg_l3_encode_write_float_stereo_def@
F << remove_static_mpeg_l3_encode_write_float_stereo_def.F;
T << remove_static_mpeg_l3_encode_write_float_stereo_def.T;
P << remove_static_mpeg_l3_encode_write_float_stereo_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_mpeg_l3_encode_write_float_stereo_def_void@
identifier F = mpeg_l3_encode_write_float_stereo;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_mpeg_l3_encode_write_float_stereo_def_void@
F << remove_static_mpeg_l3_encode_write_float_stereo_def_void.F;
P << remove_static_mpeg_l3_encode_write_float_stereo_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_mpeg_l3_encode_write_float_stereo_decl@
type T;
identifier F = mpeg_l3_encode_write_float_stereo;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_mpeg_l3_encode_write_float_stereo_decl@
F << remove_static_mpeg_l3_encode_write_float_stereo_decl.F;
T << remove_static_mpeg_l3_encode_write_float_stereo_decl.T;
P << remove_static_mpeg_l3_encode_write_float_stereo_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_mpeg_l3_encode_write_float_stereo_decl_void@
identifier F = mpeg_l3_encode_write_float_stereo;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_mpeg_l3_encode_write_float_stereo_decl_void@
F << remove_static_mpeg_l3_encode_write_float_stereo_decl_void.F;
P << remove_static_mpeg_l3_encode_write_float_stereo_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_mpeg_l3_encode_write_float_stereo_def@
type T;
identifier F = mpeg_l3_encode_write_float_stereo;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_mpeg_l3_encode_write_float_stereo_def@
F << extract_mpeg_l3_encode_write_float_stereo_def.F;
T << extract_mpeg_l3_encode_write_float_stereo_def.T;
P << extract_mpeg_l3_encode_write_float_stereo_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_mpeg_l3_encode_write_float_stereo_def_void@
identifier F = mpeg_l3_encode_write_float_stereo;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_mpeg_l3_encode_write_float_stereo_def_void@
F << extract_mpeg_l3_encode_write_float_stereo_def_void.F;
P << extract_mpeg_l3_encode_write_float_stereo_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_mpeg_l3_encode_write_float_stereo_decl@
type T;
identifier F = mpeg_l3_encode_write_float_stereo;
parameter list P;
@@
T F(P);

@script:python depends on extract_mpeg_l3_encode_write_float_stereo_decl@
F << extract_mpeg_l3_encode_write_float_stereo_decl.F;
T << extract_mpeg_l3_encode_write_float_stereo_decl.T;
P << extract_mpeg_l3_encode_write_float_stereo_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_mpeg_l3_encode_write_float_stereo_decl_void@
identifier F = mpeg_l3_encode_write_float_stereo;
parameter list P;
@@
void F(P);

@script:python depends on extract_mpeg_l3_encode_write_float_stereo_decl_void@
F << extract_mpeg_l3_encode_write_float_stereo_decl_void.F;
P << extract_mpeg_l3_encode_write_float_stereo_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: mpeg_l3_encode_write_int_mono
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_mpeg_l3_encode_write_int_mono_def@
type T;
identifier F = mpeg_l3_encode_write_int_mono;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_mpeg_l3_encode_write_int_mono_def@
F << remove_static_mpeg_l3_encode_write_int_mono_def.F;
T << remove_static_mpeg_l3_encode_write_int_mono_def.T;
P << remove_static_mpeg_l3_encode_write_int_mono_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_mpeg_l3_encode_write_int_mono_def_void@
identifier F = mpeg_l3_encode_write_int_mono;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_mpeg_l3_encode_write_int_mono_def_void@
F << remove_static_mpeg_l3_encode_write_int_mono_def_void.F;
P << remove_static_mpeg_l3_encode_write_int_mono_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_mpeg_l3_encode_write_int_mono_decl@
type T;
identifier F = mpeg_l3_encode_write_int_mono;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_mpeg_l3_encode_write_int_mono_decl@
F << remove_static_mpeg_l3_encode_write_int_mono_decl.F;
T << remove_static_mpeg_l3_encode_write_int_mono_decl.T;
P << remove_static_mpeg_l3_encode_write_int_mono_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_mpeg_l3_encode_write_int_mono_decl_void@
identifier F = mpeg_l3_encode_write_int_mono;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_mpeg_l3_encode_write_int_mono_decl_void@
F << remove_static_mpeg_l3_encode_write_int_mono_decl_void.F;
P << remove_static_mpeg_l3_encode_write_int_mono_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_mpeg_l3_encode_write_int_mono_def@
type T;
identifier F = mpeg_l3_encode_write_int_mono;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_mpeg_l3_encode_write_int_mono_def@
F << extract_mpeg_l3_encode_write_int_mono_def.F;
T << extract_mpeg_l3_encode_write_int_mono_def.T;
P << extract_mpeg_l3_encode_write_int_mono_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_mpeg_l3_encode_write_int_mono_def_void@
identifier F = mpeg_l3_encode_write_int_mono;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_mpeg_l3_encode_write_int_mono_def_void@
F << extract_mpeg_l3_encode_write_int_mono_def_void.F;
P << extract_mpeg_l3_encode_write_int_mono_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_mpeg_l3_encode_write_int_mono_decl@
type T;
identifier F = mpeg_l3_encode_write_int_mono;
parameter list P;
@@
T F(P);

@script:python depends on extract_mpeg_l3_encode_write_int_mono_decl@
F << extract_mpeg_l3_encode_write_int_mono_decl.F;
T << extract_mpeg_l3_encode_write_int_mono_decl.T;
P << extract_mpeg_l3_encode_write_int_mono_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_mpeg_l3_encode_write_int_mono_decl_void@
identifier F = mpeg_l3_encode_write_int_mono;
parameter list P;
@@
void F(P);

@script:python depends on extract_mpeg_l3_encode_write_int_mono_decl_void@
F << extract_mpeg_l3_encode_write_int_mono_decl_void.F;
P << extract_mpeg_l3_encode_write_int_mono_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: mpeg_l3_encode_write_int_stereo
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_mpeg_l3_encode_write_int_stereo_def@
type T;
identifier F = mpeg_l3_encode_write_int_stereo;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_mpeg_l3_encode_write_int_stereo_def@
F << remove_static_mpeg_l3_encode_write_int_stereo_def.F;
T << remove_static_mpeg_l3_encode_write_int_stereo_def.T;
P << remove_static_mpeg_l3_encode_write_int_stereo_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_mpeg_l3_encode_write_int_stereo_def_void@
identifier F = mpeg_l3_encode_write_int_stereo;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_mpeg_l3_encode_write_int_stereo_def_void@
F << remove_static_mpeg_l3_encode_write_int_stereo_def_void.F;
P << remove_static_mpeg_l3_encode_write_int_stereo_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_mpeg_l3_encode_write_int_stereo_decl@
type T;
identifier F = mpeg_l3_encode_write_int_stereo;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_mpeg_l3_encode_write_int_stereo_decl@
F << remove_static_mpeg_l3_encode_write_int_stereo_decl.F;
T << remove_static_mpeg_l3_encode_write_int_stereo_decl.T;
P << remove_static_mpeg_l3_encode_write_int_stereo_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_mpeg_l3_encode_write_int_stereo_decl_void@
identifier F = mpeg_l3_encode_write_int_stereo;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_mpeg_l3_encode_write_int_stereo_decl_void@
F << remove_static_mpeg_l3_encode_write_int_stereo_decl_void.F;
P << remove_static_mpeg_l3_encode_write_int_stereo_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_mpeg_l3_encode_write_int_stereo_def@
type T;
identifier F = mpeg_l3_encode_write_int_stereo;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_mpeg_l3_encode_write_int_stereo_def@
F << extract_mpeg_l3_encode_write_int_stereo_def.F;
T << extract_mpeg_l3_encode_write_int_stereo_def.T;
P << extract_mpeg_l3_encode_write_int_stereo_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_mpeg_l3_encode_write_int_stereo_def_void@
identifier F = mpeg_l3_encode_write_int_stereo;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_mpeg_l3_encode_write_int_stereo_def_void@
F << extract_mpeg_l3_encode_write_int_stereo_def_void.F;
P << extract_mpeg_l3_encode_write_int_stereo_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_mpeg_l3_encode_write_int_stereo_decl@
type T;
identifier F = mpeg_l3_encode_write_int_stereo;
parameter list P;
@@
T F(P);

@script:python depends on extract_mpeg_l3_encode_write_int_stereo_decl@
F << extract_mpeg_l3_encode_write_int_stereo_decl.F;
T << extract_mpeg_l3_encode_write_int_stereo_decl.T;
P << extract_mpeg_l3_encode_write_int_stereo_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_mpeg_l3_encode_write_int_stereo_decl_void@
identifier F = mpeg_l3_encode_write_int_stereo;
parameter list P;
@@
void F(P);

@script:python depends on extract_mpeg_l3_encode_write_int_stereo_decl_void@
F << extract_mpeg_l3_encode_write_int_stereo_decl_void.F;
P << extract_mpeg_l3_encode_write_int_stereo_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: mpeg_l3_encode_write_short_mono
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_mpeg_l3_encode_write_short_mono_def@
type T;
identifier F = mpeg_l3_encode_write_short_mono;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_mpeg_l3_encode_write_short_mono_def@
F << remove_static_mpeg_l3_encode_write_short_mono_def.F;
T << remove_static_mpeg_l3_encode_write_short_mono_def.T;
P << remove_static_mpeg_l3_encode_write_short_mono_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_mpeg_l3_encode_write_short_mono_def_void@
identifier F = mpeg_l3_encode_write_short_mono;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_mpeg_l3_encode_write_short_mono_def_void@
F << remove_static_mpeg_l3_encode_write_short_mono_def_void.F;
P << remove_static_mpeg_l3_encode_write_short_mono_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_mpeg_l3_encode_write_short_mono_decl@
type T;
identifier F = mpeg_l3_encode_write_short_mono;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_mpeg_l3_encode_write_short_mono_decl@
F << remove_static_mpeg_l3_encode_write_short_mono_decl.F;
T << remove_static_mpeg_l3_encode_write_short_mono_decl.T;
P << remove_static_mpeg_l3_encode_write_short_mono_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_mpeg_l3_encode_write_short_mono_decl_void@
identifier F = mpeg_l3_encode_write_short_mono;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_mpeg_l3_encode_write_short_mono_decl_void@
F << remove_static_mpeg_l3_encode_write_short_mono_decl_void.F;
P << remove_static_mpeg_l3_encode_write_short_mono_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_mpeg_l3_encode_write_short_mono_def@
type T;
identifier F = mpeg_l3_encode_write_short_mono;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_mpeg_l3_encode_write_short_mono_def@
F << extract_mpeg_l3_encode_write_short_mono_def.F;
T << extract_mpeg_l3_encode_write_short_mono_def.T;
P << extract_mpeg_l3_encode_write_short_mono_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_mpeg_l3_encode_write_short_mono_def_void@
identifier F = mpeg_l3_encode_write_short_mono;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_mpeg_l3_encode_write_short_mono_def_void@
F << extract_mpeg_l3_encode_write_short_mono_def_void.F;
P << extract_mpeg_l3_encode_write_short_mono_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_mpeg_l3_encode_write_short_mono_decl@
type T;
identifier F = mpeg_l3_encode_write_short_mono;
parameter list P;
@@
T F(P);

@script:python depends on extract_mpeg_l3_encode_write_short_mono_decl@
F << extract_mpeg_l3_encode_write_short_mono_decl.F;
T << extract_mpeg_l3_encode_write_short_mono_decl.T;
P << extract_mpeg_l3_encode_write_short_mono_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_mpeg_l3_encode_write_short_mono_decl_void@
identifier F = mpeg_l3_encode_write_short_mono;
parameter list P;
@@
void F(P);

@script:python depends on extract_mpeg_l3_encode_write_short_mono_decl_void@
F << extract_mpeg_l3_encode_write_short_mono_decl_void.F;
P << extract_mpeg_l3_encode_write_short_mono_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: mpeg_l3_encode_write_short_stereo
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_mpeg_l3_encode_write_short_stereo_def@
type T;
identifier F = mpeg_l3_encode_write_short_stereo;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_mpeg_l3_encode_write_short_stereo_def@
F << remove_static_mpeg_l3_encode_write_short_stereo_def.F;
T << remove_static_mpeg_l3_encode_write_short_stereo_def.T;
P << remove_static_mpeg_l3_encode_write_short_stereo_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_mpeg_l3_encode_write_short_stereo_def_void@
identifier F = mpeg_l3_encode_write_short_stereo;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_mpeg_l3_encode_write_short_stereo_def_void@
F << remove_static_mpeg_l3_encode_write_short_stereo_def_void.F;
P << remove_static_mpeg_l3_encode_write_short_stereo_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_mpeg_l3_encode_write_short_stereo_decl@
type T;
identifier F = mpeg_l3_encode_write_short_stereo;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_mpeg_l3_encode_write_short_stereo_decl@
F << remove_static_mpeg_l3_encode_write_short_stereo_decl.F;
T << remove_static_mpeg_l3_encode_write_short_stereo_decl.T;
P << remove_static_mpeg_l3_encode_write_short_stereo_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_mpeg_l3_encode_write_short_stereo_decl_void@
identifier F = mpeg_l3_encode_write_short_stereo;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_mpeg_l3_encode_write_short_stereo_decl_void@
F << remove_static_mpeg_l3_encode_write_short_stereo_decl_void.F;
P << remove_static_mpeg_l3_encode_write_short_stereo_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_mpeg_l3_encode_write_short_stereo_def@
type T;
identifier F = mpeg_l3_encode_write_short_stereo;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_mpeg_l3_encode_write_short_stereo_def@
F << extract_mpeg_l3_encode_write_short_stereo_def.F;
T << extract_mpeg_l3_encode_write_short_stereo_def.T;
P << extract_mpeg_l3_encode_write_short_stereo_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_mpeg_l3_encode_write_short_stereo_def_void@
identifier F = mpeg_l3_encode_write_short_stereo;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_mpeg_l3_encode_write_short_stereo_def_void@
F << extract_mpeg_l3_encode_write_short_stereo_def_void.F;
P << extract_mpeg_l3_encode_write_short_stereo_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_mpeg_l3_encode_write_short_stereo_decl@
type T;
identifier F = mpeg_l3_encode_write_short_stereo;
parameter list P;
@@
T F(P);

@script:python depends on extract_mpeg_l3_encode_write_short_stereo_decl@
F << extract_mpeg_l3_encode_write_short_stereo_decl.F;
T << extract_mpeg_l3_encode_write_short_stereo_decl.T;
P << extract_mpeg_l3_encode_write_short_stereo_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_mpeg_l3_encode_write_short_stereo_decl_void@
identifier F = mpeg_l3_encode_write_short_stereo;
parameter list P;
@@
void F(P);

@script:python depends on extract_mpeg_l3_encode_write_short_stereo_decl_void@
F << extract_mpeg_l3_encode_write_short_stereo_decl_void.F;
P << extract_mpeg_l3_encode_write_short_stereo_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: mpeg_l3_encoder_byterate
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_mpeg_l3_encoder_byterate_def@
type T;
identifier F = mpeg_l3_encoder_byterate;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_mpeg_l3_encoder_byterate_def@
F << remove_static_mpeg_l3_encoder_byterate_def.F;
T << remove_static_mpeg_l3_encoder_byterate_def.T;
P << remove_static_mpeg_l3_encoder_byterate_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_mpeg_l3_encoder_byterate_def_void@
identifier F = mpeg_l3_encoder_byterate;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_mpeg_l3_encoder_byterate_def_void@
F << remove_static_mpeg_l3_encoder_byterate_def_void.F;
P << remove_static_mpeg_l3_encoder_byterate_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_mpeg_l3_encoder_byterate_decl@
type T;
identifier F = mpeg_l3_encoder_byterate;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_mpeg_l3_encoder_byterate_decl@
F << remove_static_mpeg_l3_encoder_byterate_decl.F;
T << remove_static_mpeg_l3_encoder_byterate_decl.T;
P << remove_static_mpeg_l3_encoder_byterate_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_mpeg_l3_encoder_byterate_decl_void@
identifier F = mpeg_l3_encoder_byterate;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_mpeg_l3_encoder_byterate_decl_void@
F << remove_static_mpeg_l3_encoder_byterate_decl_void.F;
P << remove_static_mpeg_l3_encoder_byterate_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_mpeg_l3_encoder_byterate_def@
type T;
identifier F = mpeg_l3_encoder_byterate;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_mpeg_l3_encoder_byterate_def@
F << extract_mpeg_l3_encoder_byterate_def.F;
T << extract_mpeg_l3_encoder_byterate_def.T;
P << extract_mpeg_l3_encoder_byterate_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_mpeg_l3_encoder_byterate_def_void@
identifier F = mpeg_l3_encoder_byterate;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_mpeg_l3_encoder_byterate_def_void@
F << extract_mpeg_l3_encoder_byterate_def_void.F;
P << extract_mpeg_l3_encoder_byterate_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_mpeg_l3_encoder_byterate_decl@
type T;
identifier F = mpeg_l3_encoder_byterate;
parameter list P;
@@
T F(P);

@script:python depends on extract_mpeg_l3_encoder_byterate_decl@
F << extract_mpeg_l3_encoder_byterate_decl.F;
T << extract_mpeg_l3_encoder_byterate_decl.T;
P << extract_mpeg_l3_encoder_byterate_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_mpeg_l3_encoder_byterate_decl_void@
identifier F = mpeg_l3_encoder_byterate;
parameter list P;
@@
void F(P);

@script:python depends on extract_mpeg_l3_encoder_byterate_decl_void@
F << extract_mpeg_l3_encoder_byterate_decl_void.F;
P << extract_mpeg_l3_encoder_byterate_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: mpeg_l3_encoder_close
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_mpeg_l3_encoder_close_def@
type T;
identifier F = mpeg_l3_encoder_close;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_mpeg_l3_encoder_close_def@
F << remove_static_mpeg_l3_encoder_close_def.F;
T << remove_static_mpeg_l3_encoder_close_def.T;
P << remove_static_mpeg_l3_encoder_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_mpeg_l3_encoder_close_def_void@
identifier F = mpeg_l3_encoder_close;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_mpeg_l3_encoder_close_def_void@
F << remove_static_mpeg_l3_encoder_close_def_void.F;
P << remove_static_mpeg_l3_encoder_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_mpeg_l3_encoder_close_decl@
type T;
identifier F = mpeg_l3_encoder_close;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_mpeg_l3_encoder_close_decl@
F << remove_static_mpeg_l3_encoder_close_decl.F;
T << remove_static_mpeg_l3_encoder_close_decl.T;
P << remove_static_mpeg_l3_encoder_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_mpeg_l3_encoder_close_decl_void@
identifier F = mpeg_l3_encoder_close;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_mpeg_l3_encoder_close_decl_void@
F << remove_static_mpeg_l3_encoder_close_decl_void.F;
P << remove_static_mpeg_l3_encoder_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_mpeg_l3_encoder_close_def@
type T;
identifier F = mpeg_l3_encoder_close;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_mpeg_l3_encoder_close_def@
F << extract_mpeg_l3_encoder_close_def.F;
T << extract_mpeg_l3_encoder_close_def.T;
P << extract_mpeg_l3_encoder_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_mpeg_l3_encoder_close_def_void@
identifier F = mpeg_l3_encoder_close;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_mpeg_l3_encoder_close_def_void@
F << extract_mpeg_l3_encoder_close_def_void.F;
P << extract_mpeg_l3_encoder_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_mpeg_l3_encoder_close_decl@
type T;
identifier F = mpeg_l3_encoder_close;
parameter list P;
@@
T F(P);

@script:python depends on extract_mpeg_l3_encoder_close_decl@
F << extract_mpeg_l3_encoder_close_decl.F;
T << extract_mpeg_l3_encoder_close_decl.T;
P << extract_mpeg_l3_encoder_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_mpeg_l3_encoder_close_decl_void@
identifier F = mpeg_l3_encoder_close;
parameter list P;
@@
void F(P);

@script:python depends on extract_mpeg_l3_encoder_close_decl_void@
F << extract_mpeg_l3_encoder_close_decl_void.F;
P << extract_mpeg_l3_encoder_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: mpeg_write_header
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_mpeg_write_header_def@
type T;
identifier F = mpeg_write_header;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_mpeg_write_header_def@
F << remove_static_mpeg_write_header_def.F;
T << remove_static_mpeg_write_header_def.T;
P << remove_static_mpeg_write_header_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_mpeg_write_header_def_void@
identifier F = mpeg_write_header;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_mpeg_write_header_def_void@
F << remove_static_mpeg_write_header_def_void.F;
P << remove_static_mpeg_write_header_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_mpeg_write_header_decl@
type T;
identifier F = mpeg_write_header;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_mpeg_write_header_decl@
F << remove_static_mpeg_write_header_decl.F;
T << remove_static_mpeg_write_header_decl.T;
P << remove_static_mpeg_write_header_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_mpeg_write_header_decl_void@
identifier F = mpeg_write_header;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_mpeg_write_header_decl_void@
F << remove_static_mpeg_write_header_decl_void.F;
P << remove_static_mpeg_write_header_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_mpeg_write_header_def@
type T;
identifier F = mpeg_write_header;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_mpeg_write_header_def@
F << extract_mpeg_write_header_def.F;
T << extract_mpeg_write_header_def.T;
P << extract_mpeg_write_header_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_mpeg_write_header_def_void@
identifier F = mpeg_write_header;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_mpeg_write_header_def_void@
F << extract_mpeg_write_header_def_void.F;
P << extract_mpeg_write_header_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_mpeg_write_header_decl@
type T;
identifier F = mpeg_write_header;
parameter list P;
@@
T F(P);

@script:python depends on extract_mpeg_write_header_decl@
F << extract_mpeg_write_header_decl.F;
T << extract_mpeg_write_header_decl.T;
P << extract_mpeg_write_header_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_mpeg_write_header_decl_void@
identifier F = mpeg_write_header;
parameter list P;
@@
void F(P);

@script:python depends on extract_mpeg_write_header_decl_void@
F << extract_mpeg_write_header_decl_void.F;
P << extract_mpeg_write_header_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: msadpcm_close
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_msadpcm_close_def@
type T;
identifier F = msadpcm_close;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_msadpcm_close_def@
F << remove_static_msadpcm_close_def.F;
T << remove_static_msadpcm_close_def.T;
P << remove_static_msadpcm_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_msadpcm_close_def_void@
identifier F = msadpcm_close;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_msadpcm_close_def_void@
F << remove_static_msadpcm_close_def_void.F;
P << remove_static_msadpcm_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_msadpcm_close_decl@
type T;
identifier F = msadpcm_close;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_msadpcm_close_decl@
F << remove_static_msadpcm_close_decl.F;
T << remove_static_msadpcm_close_decl.T;
P << remove_static_msadpcm_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_msadpcm_close_decl_void@
identifier F = msadpcm_close;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_msadpcm_close_decl_void@
F << remove_static_msadpcm_close_decl_void.F;
P << remove_static_msadpcm_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_msadpcm_close_def@
type T;
identifier F = msadpcm_close;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_msadpcm_close_def@
F << extract_msadpcm_close_def.F;
T << extract_msadpcm_close_def.T;
P << extract_msadpcm_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_msadpcm_close_def_void@
identifier F = msadpcm_close;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_msadpcm_close_def_void@
F << extract_msadpcm_close_def_void.F;
P << extract_msadpcm_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_msadpcm_close_decl@
type T;
identifier F = msadpcm_close;
parameter list P;
@@
T F(P);

@script:python depends on extract_msadpcm_close_decl@
F << extract_msadpcm_close_decl.F;
T << extract_msadpcm_close_decl.T;
P << extract_msadpcm_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_msadpcm_close_decl_void@
identifier F = msadpcm_close;
parameter list P;
@@
void F(P);

@script:python depends on extract_msadpcm_close_decl_void@
F << extract_msadpcm_close_decl_void.F;
P << extract_msadpcm_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: msadpcm_read_d
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_msadpcm_read_d_def@
type T;
identifier F = msadpcm_read_d;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_msadpcm_read_d_def@
F << remove_static_msadpcm_read_d_def.F;
T << remove_static_msadpcm_read_d_def.T;
P << remove_static_msadpcm_read_d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_msadpcm_read_d_def_void@
identifier F = msadpcm_read_d;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_msadpcm_read_d_def_void@
F << remove_static_msadpcm_read_d_def_void.F;
P << remove_static_msadpcm_read_d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_msadpcm_read_d_decl@
type T;
identifier F = msadpcm_read_d;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_msadpcm_read_d_decl@
F << remove_static_msadpcm_read_d_decl.F;
T << remove_static_msadpcm_read_d_decl.T;
P << remove_static_msadpcm_read_d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_msadpcm_read_d_decl_void@
identifier F = msadpcm_read_d;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_msadpcm_read_d_decl_void@
F << remove_static_msadpcm_read_d_decl_void.F;
P << remove_static_msadpcm_read_d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_msadpcm_read_d_def@
type T;
identifier F = msadpcm_read_d;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_msadpcm_read_d_def@
F << extract_msadpcm_read_d_def.F;
T << extract_msadpcm_read_d_def.T;
P << extract_msadpcm_read_d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_msadpcm_read_d_def_void@
identifier F = msadpcm_read_d;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_msadpcm_read_d_def_void@
F << extract_msadpcm_read_d_def_void.F;
P << extract_msadpcm_read_d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_msadpcm_read_d_decl@
type T;
identifier F = msadpcm_read_d;
parameter list P;
@@
T F(P);

@script:python depends on extract_msadpcm_read_d_decl@
F << extract_msadpcm_read_d_decl.F;
T << extract_msadpcm_read_d_decl.T;
P << extract_msadpcm_read_d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_msadpcm_read_d_decl_void@
identifier F = msadpcm_read_d;
parameter list P;
@@
void F(P);

@script:python depends on extract_msadpcm_read_d_decl_void@
F << extract_msadpcm_read_d_decl_void.F;
P << extract_msadpcm_read_d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: msadpcm_read_f
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_msadpcm_read_f_def@
type T;
identifier F = msadpcm_read_f;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_msadpcm_read_f_def@
F << remove_static_msadpcm_read_f_def.F;
T << remove_static_msadpcm_read_f_def.T;
P << remove_static_msadpcm_read_f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_msadpcm_read_f_def_void@
identifier F = msadpcm_read_f;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_msadpcm_read_f_def_void@
F << remove_static_msadpcm_read_f_def_void.F;
P << remove_static_msadpcm_read_f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_msadpcm_read_f_decl@
type T;
identifier F = msadpcm_read_f;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_msadpcm_read_f_decl@
F << remove_static_msadpcm_read_f_decl.F;
T << remove_static_msadpcm_read_f_decl.T;
P << remove_static_msadpcm_read_f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_msadpcm_read_f_decl_void@
identifier F = msadpcm_read_f;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_msadpcm_read_f_decl_void@
F << remove_static_msadpcm_read_f_decl_void.F;
P << remove_static_msadpcm_read_f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_msadpcm_read_f_def@
type T;
identifier F = msadpcm_read_f;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_msadpcm_read_f_def@
F << extract_msadpcm_read_f_def.F;
T << extract_msadpcm_read_f_def.T;
P << extract_msadpcm_read_f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_msadpcm_read_f_def_void@
identifier F = msadpcm_read_f;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_msadpcm_read_f_def_void@
F << extract_msadpcm_read_f_def_void.F;
P << extract_msadpcm_read_f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_msadpcm_read_f_decl@
type T;
identifier F = msadpcm_read_f;
parameter list P;
@@
T F(P);

@script:python depends on extract_msadpcm_read_f_decl@
F << extract_msadpcm_read_f_decl.F;
T << extract_msadpcm_read_f_decl.T;
P << extract_msadpcm_read_f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_msadpcm_read_f_decl_void@
identifier F = msadpcm_read_f;
parameter list P;
@@
void F(P);

@script:python depends on extract_msadpcm_read_f_decl_void@
F << extract_msadpcm_read_f_decl_void.F;
P << extract_msadpcm_read_f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: msadpcm_read_i
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_msadpcm_read_i_def@
type T;
identifier F = msadpcm_read_i;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_msadpcm_read_i_def@
F << remove_static_msadpcm_read_i_def.F;
T << remove_static_msadpcm_read_i_def.T;
P << remove_static_msadpcm_read_i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_msadpcm_read_i_def_void@
identifier F = msadpcm_read_i;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_msadpcm_read_i_def_void@
F << remove_static_msadpcm_read_i_def_void.F;
P << remove_static_msadpcm_read_i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_msadpcm_read_i_decl@
type T;
identifier F = msadpcm_read_i;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_msadpcm_read_i_decl@
F << remove_static_msadpcm_read_i_decl.F;
T << remove_static_msadpcm_read_i_decl.T;
P << remove_static_msadpcm_read_i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_msadpcm_read_i_decl_void@
identifier F = msadpcm_read_i;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_msadpcm_read_i_decl_void@
F << remove_static_msadpcm_read_i_decl_void.F;
P << remove_static_msadpcm_read_i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_msadpcm_read_i_def@
type T;
identifier F = msadpcm_read_i;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_msadpcm_read_i_def@
F << extract_msadpcm_read_i_def.F;
T << extract_msadpcm_read_i_def.T;
P << extract_msadpcm_read_i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_msadpcm_read_i_def_void@
identifier F = msadpcm_read_i;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_msadpcm_read_i_def_void@
F << extract_msadpcm_read_i_def_void.F;
P << extract_msadpcm_read_i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_msadpcm_read_i_decl@
type T;
identifier F = msadpcm_read_i;
parameter list P;
@@
T F(P);

@script:python depends on extract_msadpcm_read_i_decl@
F << extract_msadpcm_read_i_decl.F;
T << extract_msadpcm_read_i_decl.T;
P << extract_msadpcm_read_i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_msadpcm_read_i_decl_void@
identifier F = msadpcm_read_i;
parameter list P;
@@
void F(P);

@script:python depends on extract_msadpcm_read_i_decl_void@
F << extract_msadpcm_read_i_decl_void.F;
P << extract_msadpcm_read_i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: msadpcm_read_s
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_msadpcm_read_s_def@
type T;
identifier F = msadpcm_read_s;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_msadpcm_read_s_def@
F << remove_static_msadpcm_read_s_def.F;
T << remove_static_msadpcm_read_s_def.T;
P << remove_static_msadpcm_read_s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_msadpcm_read_s_def_void@
identifier F = msadpcm_read_s;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_msadpcm_read_s_def_void@
F << remove_static_msadpcm_read_s_def_void.F;
P << remove_static_msadpcm_read_s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_msadpcm_read_s_decl@
type T;
identifier F = msadpcm_read_s;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_msadpcm_read_s_decl@
F << remove_static_msadpcm_read_s_decl.F;
T << remove_static_msadpcm_read_s_decl.T;
P << remove_static_msadpcm_read_s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_msadpcm_read_s_decl_void@
identifier F = msadpcm_read_s;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_msadpcm_read_s_decl_void@
F << remove_static_msadpcm_read_s_decl_void.F;
P << remove_static_msadpcm_read_s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_msadpcm_read_s_def@
type T;
identifier F = msadpcm_read_s;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_msadpcm_read_s_def@
F << extract_msadpcm_read_s_def.F;
T << extract_msadpcm_read_s_def.T;
P << extract_msadpcm_read_s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_msadpcm_read_s_def_void@
identifier F = msadpcm_read_s;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_msadpcm_read_s_def_void@
F << extract_msadpcm_read_s_def_void.F;
P << extract_msadpcm_read_s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_msadpcm_read_s_decl@
type T;
identifier F = msadpcm_read_s;
parameter list P;
@@
T F(P);

@script:python depends on extract_msadpcm_read_s_decl@
F << extract_msadpcm_read_s_decl.F;
T << extract_msadpcm_read_s_decl.T;
P << extract_msadpcm_read_s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_msadpcm_read_s_decl_void@
identifier F = msadpcm_read_s;
parameter list P;
@@
void F(P);

@script:python depends on extract_msadpcm_read_s_decl_void@
F << extract_msadpcm_read_s_decl_void.F;
P << extract_msadpcm_read_s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: msadpcm_seek
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_msadpcm_seek_def@
type T;
identifier F = msadpcm_seek;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_msadpcm_seek_def@
F << remove_static_msadpcm_seek_def.F;
T << remove_static_msadpcm_seek_def.T;
P << remove_static_msadpcm_seek_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_msadpcm_seek_def_void@
identifier F = msadpcm_seek;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_msadpcm_seek_def_void@
F << remove_static_msadpcm_seek_def_void.F;
P << remove_static_msadpcm_seek_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_msadpcm_seek_decl@
type T;
identifier F = msadpcm_seek;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_msadpcm_seek_decl@
F << remove_static_msadpcm_seek_decl.F;
T << remove_static_msadpcm_seek_decl.T;
P << remove_static_msadpcm_seek_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_msadpcm_seek_decl_void@
identifier F = msadpcm_seek;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_msadpcm_seek_decl_void@
F << remove_static_msadpcm_seek_decl_void.F;
P << remove_static_msadpcm_seek_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_msadpcm_seek_def@
type T;
identifier F = msadpcm_seek;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_msadpcm_seek_def@
F << extract_msadpcm_seek_def.F;
T << extract_msadpcm_seek_def.T;
P << extract_msadpcm_seek_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_msadpcm_seek_def_void@
identifier F = msadpcm_seek;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_msadpcm_seek_def_void@
F << extract_msadpcm_seek_def_void.F;
P << extract_msadpcm_seek_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_msadpcm_seek_decl@
type T;
identifier F = msadpcm_seek;
parameter list P;
@@
T F(P);

@script:python depends on extract_msadpcm_seek_decl@
F << extract_msadpcm_seek_decl.F;
T << extract_msadpcm_seek_decl.T;
P << extract_msadpcm_seek_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_msadpcm_seek_decl_void@
identifier F = msadpcm_seek;
parameter list P;
@@
void F(P);

@script:python depends on extract_msadpcm_seek_decl_void@
F << extract_msadpcm_seek_decl_void.F;
P << extract_msadpcm_seek_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: msadpcm_write_d
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_msadpcm_write_d_def@
type T;
identifier F = msadpcm_write_d;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_msadpcm_write_d_def@
F << remove_static_msadpcm_write_d_def.F;
T << remove_static_msadpcm_write_d_def.T;
P << remove_static_msadpcm_write_d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_msadpcm_write_d_def_void@
identifier F = msadpcm_write_d;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_msadpcm_write_d_def_void@
F << remove_static_msadpcm_write_d_def_void.F;
P << remove_static_msadpcm_write_d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_msadpcm_write_d_decl@
type T;
identifier F = msadpcm_write_d;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_msadpcm_write_d_decl@
F << remove_static_msadpcm_write_d_decl.F;
T << remove_static_msadpcm_write_d_decl.T;
P << remove_static_msadpcm_write_d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_msadpcm_write_d_decl_void@
identifier F = msadpcm_write_d;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_msadpcm_write_d_decl_void@
F << remove_static_msadpcm_write_d_decl_void.F;
P << remove_static_msadpcm_write_d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_msadpcm_write_d_def@
type T;
identifier F = msadpcm_write_d;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_msadpcm_write_d_def@
F << extract_msadpcm_write_d_def.F;
T << extract_msadpcm_write_d_def.T;
P << extract_msadpcm_write_d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_msadpcm_write_d_def_void@
identifier F = msadpcm_write_d;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_msadpcm_write_d_def_void@
F << extract_msadpcm_write_d_def_void.F;
P << extract_msadpcm_write_d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_msadpcm_write_d_decl@
type T;
identifier F = msadpcm_write_d;
parameter list P;
@@
T F(P);

@script:python depends on extract_msadpcm_write_d_decl@
F << extract_msadpcm_write_d_decl.F;
T << extract_msadpcm_write_d_decl.T;
P << extract_msadpcm_write_d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_msadpcm_write_d_decl_void@
identifier F = msadpcm_write_d;
parameter list P;
@@
void F(P);

@script:python depends on extract_msadpcm_write_d_decl_void@
F << extract_msadpcm_write_d_decl_void.F;
P << extract_msadpcm_write_d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: msadpcm_write_f
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_msadpcm_write_f_def@
type T;
identifier F = msadpcm_write_f;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_msadpcm_write_f_def@
F << remove_static_msadpcm_write_f_def.F;
T << remove_static_msadpcm_write_f_def.T;
P << remove_static_msadpcm_write_f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_msadpcm_write_f_def_void@
identifier F = msadpcm_write_f;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_msadpcm_write_f_def_void@
F << remove_static_msadpcm_write_f_def_void.F;
P << remove_static_msadpcm_write_f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_msadpcm_write_f_decl@
type T;
identifier F = msadpcm_write_f;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_msadpcm_write_f_decl@
F << remove_static_msadpcm_write_f_decl.F;
T << remove_static_msadpcm_write_f_decl.T;
P << remove_static_msadpcm_write_f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_msadpcm_write_f_decl_void@
identifier F = msadpcm_write_f;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_msadpcm_write_f_decl_void@
F << remove_static_msadpcm_write_f_decl_void.F;
P << remove_static_msadpcm_write_f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_msadpcm_write_f_def@
type T;
identifier F = msadpcm_write_f;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_msadpcm_write_f_def@
F << extract_msadpcm_write_f_def.F;
T << extract_msadpcm_write_f_def.T;
P << extract_msadpcm_write_f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_msadpcm_write_f_def_void@
identifier F = msadpcm_write_f;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_msadpcm_write_f_def_void@
F << extract_msadpcm_write_f_def_void.F;
P << extract_msadpcm_write_f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_msadpcm_write_f_decl@
type T;
identifier F = msadpcm_write_f;
parameter list P;
@@
T F(P);

@script:python depends on extract_msadpcm_write_f_decl@
F << extract_msadpcm_write_f_decl.F;
T << extract_msadpcm_write_f_decl.T;
P << extract_msadpcm_write_f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_msadpcm_write_f_decl_void@
identifier F = msadpcm_write_f;
parameter list P;
@@
void F(P);

@script:python depends on extract_msadpcm_write_f_decl_void@
F << extract_msadpcm_write_f_decl_void.F;
P << extract_msadpcm_write_f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: msadpcm_write_i
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_msadpcm_write_i_def@
type T;
identifier F = msadpcm_write_i;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_msadpcm_write_i_def@
F << remove_static_msadpcm_write_i_def.F;
T << remove_static_msadpcm_write_i_def.T;
P << remove_static_msadpcm_write_i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_msadpcm_write_i_def_void@
identifier F = msadpcm_write_i;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_msadpcm_write_i_def_void@
F << remove_static_msadpcm_write_i_def_void.F;
P << remove_static_msadpcm_write_i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_msadpcm_write_i_decl@
type T;
identifier F = msadpcm_write_i;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_msadpcm_write_i_decl@
F << remove_static_msadpcm_write_i_decl.F;
T << remove_static_msadpcm_write_i_decl.T;
P << remove_static_msadpcm_write_i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_msadpcm_write_i_decl_void@
identifier F = msadpcm_write_i;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_msadpcm_write_i_decl_void@
F << remove_static_msadpcm_write_i_decl_void.F;
P << remove_static_msadpcm_write_i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_msadpcm_write_i_def@
type T;
identifier F = msadpcm_write_i;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_msadpcm_write_i_def@
F << extract_msadpcm_write_i_def.F;
T << extract_msadpcm_write_i_def.T;
P << extract_msadpcm_write_i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_msadpcm_write_i_def_void@
identifier F = msadpcm_write_i;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_msadpcm_write_i_def_void@
F << extract_msadpcm_write_i_def_void.F;
P << extract_msadpcm_write_i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_msadpcm_write_i_decl@
type T;
identifier F = msadpcm_write_i;
parameter list P;
@@
T F(P);

@script:python depends on extract_msadpcm_write_i_decl@
F << extract_msadpcm_write_i_decl.F;
T << extract_msadpcm_write_i_decl.T;
P << extract_msadpcm_write_i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_msadpcm_write_i_decl_void@
identifier F = msadpcm_write_i;
parameter list P;
@@
void F(P);

@script:python depends on extract_msadpcm_write_i_decl_void@
F << extract_msadpcm_write_i_decl_void.F;
P << extract_msadpcm_write_i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: msadpcm_write_s
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_msadpcm_write_s_def@
type T;
identifier F = msadpcm_write_s;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_msadpcm_write_s_def@
F << remove_static_msadpcm_write_s_def.F;
T << remove_static_msadpcm_write_s_def.T;
P << remove_static_msadpcm_write_s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_msadpcm_write_s_def_void@
identifier F = msadpcm_write_s;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_msadpcm_write_s_def_void@
F << remove_static_msadpcm_write_s_def_void.F;
P << remove_static_msadpcm_write_s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_msadpcm_write_s_decl@
type T;
identifier F = msadpcm_write_s;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_msadpcm_write_s_decl@
F << remove_static_msadpcm_write_s_decl.F;
T << remove_static_msadpcm_write_s_decl.T;
P << remove_static_msadpcm_write_s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_msadpcm_write_s_decl_void@
identifier F = msadpcm_write_s;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_msadpcm_write_s_decl_void@
F << remove_static_msadpcm_write_s_decl_void.F;
P << remove_static_msadpcm_write_s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_msadpcm_write_s_def@
type T;
identifier F = msadpcm_write_s;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_msadpcm_write_s_def@
F << extract_msadpcm_write_s_def.F;
T << extract_msadpcm_write_s_def.T;
P << extract_msadpcm_write_s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_msadpcm_write_s_def_void@
identifier F = msadpcm_write_s;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_msadpcm_write_s_def_void@
F << extract_msadpcm_write_s_def_void.F;
P << extract_msadpcm_write_s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_msadpcm_write_s_decl@
type T;
identifier F = msadpcm_write_s;
parameter list P;
@@
T F(P);

@script:python depends on extract_msadpcm_write_s_decl@
F << extract_msadpcm_write_s_decl.F;
T << extract_msadpcm_write_s_decl.T;
P << extract_msadpcm_write_s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_msadpcm_write_s_decl_void@
identifier F = msadpcm_write_s;
parameter list P;
@@
void F(P);

@script:python depends on extract_msadpcm_write_s_decl_void@
F << extract_msadpcm_write_s_decl_void.F;
P << extract_msadpcm_write_s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: nist_close
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_nist_close_def@
type T;
identifier F = nist_close;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_nist_close_def@
F << remove_static_nist_close_def.F;
T << remove_static_nist_close_def.T;
P << remove_static_nist_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_nist_close_def_void@
identifier F = nist_close;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_nist_close_def_void@
F << remove_static_nist_close_def_void.F;
P << remove_static_nist_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_nist_close_decl@
type T;
identifier F = nist_close;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_nist_close_decl@
F << remove_static_nist_close_decl.F;
T << remove_static_nist_close_decl.T;
P << remove_static_nist_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_nist_close_decl_void@
identifier F = nist_close;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_nist_close_decl_void@
F << remove_static_nist_close_decl_void.F;
P << remove_static_nist_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_nist_close_def@
type T;
identifier F = nist_close;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_nist_close_def@
F << extract_nist_close_def.F;
T << extract_nist_close_def.T;
P << extract_nist_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_nist_close_def_void@
identifier F = nist_close;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_nist_close_def_void@
F << extract_nist_close_def_void.F;
P << extract_nist_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_nist_close_decl@
type T;
identifier F = nist_close;
parameter list P;
@@
T F(P);

@script:python depends on extract_nist_close_decl@
F << extract_nist_close_decl.F;
T << extract_nist_close_decl.T;
P << extract_nist_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_nist_close_decl_void@
identifier F = nist_close;
parameter list P;
@@
void F(P);

@script:python depends on extract_nist_close_decl_void@
F << extract_nist_close_decl_void.F;
P << extract_nist_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: nist_write_header
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_nist_write_header_def@
type T;
identifier F = nist_write_header;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_nist_write_header_def@
F << remove_static_nist_write_header_def.F;
T << remove_static_nist_write_header_def.T;
P << remove_static_nist_write_header_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_nist_write_header_def_void@
identifier F = nist_write_header;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_nist_write_header_def_void@
F << remove_static_nist_write_header_def_void.F;
P << remove_static_nist_write_header_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_nist_write_header_decl@
type T;
identifier F = nist_write_header;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_nist_write_header_decl@
F << remove_static_nist_write_header_decl.F;
T << remove_static_nist_write_header_decl.T;
P << remove_static_nist_write_header_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_nist_write_header_decl_void@
identifier F = nist_write_header;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_nist_write_header_decl_void@
F << remove_static_nist_write_header_decl_void.F;
P << remove_static_nist_write_header_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_nist_write_header_def@
type T;
identifier F = nist_write_header;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_nist_write_header_def@
F << extract_nist_write_header_def.F;
T << extract_nist_write_header_def.T;
P << extract_nist_write_header_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_nist_write_header_def_void@
identifier F = nist_write_header;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_nist_write_header_def_void@
F << extract_nist_write_header_def_void.F;
P << extract_nist_write_header_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_nist_write_header_decl@
type T;
identifier F = nist_write_header;
parameter list P;
@@
T F(P);

@script:python depends on extract_nist_write_header_decl@
F << extract_nist_write_header_decl.F;
T << extract_nist_write_header_decl.T;
P << extract_nist_write_header_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_nist_write_header_decl_void@
identifier F = nist_write_header;
parameter list P;
@@
void F(P);

@script:python depends on extract_nist_write_header_decl_void@
F << extract_nist_write_header_decl_void.F;
P << extract_nist_write_header_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: nms_adpcm_close
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_nms_adpcm_close_def@
type T;
identifier F = nms_adpcm_close;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_nms_adpcm_close_def@
F << remove_static_nms_adpcm_close_def.F;
T << remove_static_nms_adpcm_close_def.T;
P << remove_static_nms_adpcm_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_nms_adpcm_close_def_void@
identifier F = nms_adpcm_close;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_nms_adpcm_close_def_void@
F << remove_static_nms_adpcm_close_def_void.F;
P << remove_static_nms_adpcm_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_nms_adpcm_close_decl@
type T;
identifier F = nms_adpcm_close;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_nms_adpcm_close_decl@
F << remove_static_nms_adpcm_close_decl.F;
T << remove_static_nms_adpcm_close_decl.T;
P << remove_static_nms_adpcm_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_nms_adpcm_close_decl_void@
identifier F = nms_adpcm_close;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_nms_adpcm_close_decl_void@
F << remove_static_nms_adpcm_close_decl_void.F;
P << remove_static_nms_adpcm_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_nms_adpcm_close_def@
type T;
identifier F = nms_adpcm_close;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_nms_adpcm_close_def@
F << extract_nms_adpcm_close_def.F;
T << extract_nms_adpcm_close_def.T;
P << extract_nms_adpcm_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_nms_adpcm_close_def_void@
identifier F = nms_adpcm_close;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_nms_adpcm_close_def_void@
F << extract_nms_adpcm_close_def_void.F;
P << extract_nms_adpcm_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_nms_adpcm_close_decl@
type T;
identifier F = nms_adpcm_close;
parameter list P;
@@
T F(P);

@script:python depends on extract_nms_adpcm_close_decl@
F << extract_nms_adpcm_close_decl.F;
T << extract_nms_adpcm_close_decl.T;
P << extract_nms_adpcm_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_nms_adpcm_close_decl_void@
identifier F = nms_adpcm_close;
parameter list P;
@@
void F(P);

@script:python depends on extract_nms_adpcm_close_decl_void@
F << extract_nms_adpcm_close_decl_void.F;
P << extract_nms_adpcm_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: nms_adpcm_read_d
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_nms_adpcm_read_d_def@
type T;
identifier F = nms_adpcm_read_d;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_nms_adpcm_read_d_def@
F << remove_static_nms_adpcm_read_d_def.F;
T << remove_static_nms_adpcm_read_d_def.T;
P << remove_static_nms_adpcm_read_d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_nms_adpcm_read_d_def_void@
identifier F = nms_adpcm_read_d;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_nms_adpcm_read_d_def_void@
F << remove_static_nms_adpcm_read_d_def_void.F;
P << remove_static_nms_adpcm_read_d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_nms_adpcm_read_d_decl@
type T;
identifier F = nms_adpcm_read_d;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_nms_adpcm_read_d_decl@
F << remove_static_nms_adpcm_read_d_decl.F;
T << remove_static_nms_adpcm_read_d_decl.T;
P << remove_static_nms_adpcm_read_d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_nms_adpcm_read_d_decl_void@
identifier F = nms_adpcm_read_d;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_nms_adpcm_read_d_decl_void@
F << remove_static_nms_adpcm_read_d_decl_void.F;
P << remove_static_nms_adpcm_read_d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_nms_adpcm_read_d_def@
type T;
identifier F = nms_adpcm_read_d;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_nms_adpcm_read_d_def@
F << extract_nms_adpcm_read_d_def.F;
T << extract_nms_adpcm_read_d_def.T;
P << extract_nms_adpcm_read_d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_nms_adpcm_read_d_def_void@
identifier F = nms_adpcm_read_d;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_nms_adpcm_read_d_def_void@
F << extract_nms_adpcm_read_d_def_void.F;
P << extract_nms_adpcm_read_d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_nms_adpcm_read_d_decl@
type T;
identifier F = nms_adpcm_read_d;
parameter list P;
@@
T F(P);

@script:python depends on extract_nms_adpcm_read_d_decl@
F << extract_nms_adpcm_read_d_decl.F;
T << extract_nms_adpcm_read_d_decl.T;
P << extract_nms_adpcm_read_d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_nms_adpcm_read_d_decl_void@
identifier F = nms_adpcm_read_d;
parameter list P;
@@
void F(P);

@script:python depends on extract_nms_adpcm_read_d_decl_void@
F << extract_nms_adpcm_read_d_decl_void.F;
P << extract_nms_adpcm_read_d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: nms_adpcm_read_f
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_nms_adpcm_read_f_def@
type T;
identifier F = nms_adpcm_read_f;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_nms_adpcm_read_f_def@
F << remove_static_nms_adpcm_read_f_def.F;
T << remove_static_nms_adpcm_read_f_def.T;
P << remove_static_nms_adpcm_read_f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_nms_adpcm_read_f_def_void@
identifier F = nms_adpcm_read_f;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_nms_adpcm_read_f_def_void@
F << remove_static_nms_adpcm_read_f_def_void.F;
P << remove_static_nms_adpcm_read_f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_nms_adpcm_read_f_decl@
type T;
identifier F = nms_adpcm_read_f;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_nms_adpcm_read_f_decl@
F << remove_static_nms_adpcm_read_f_decl.F;
T << remove_static_nms_adpcm_read_f_decl.T;
P << remove_static_nms_adpcm_read_f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_nms_adpcm_read_f_decl_void@
identifier F = nms_adpcm_read_f;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_nms_adpcm_read_f_decl_void@
F << remove_static_nms_adpcm_read_f_decl_void.F;
P << remove_static_nms_adpcm_read_f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_nms_adpcm_read_f_def@
type T;
identifier F = nms_adpcm_read_f;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_nms_adpcm_read_f_def@
F << extract_nms_adpcm_read_f_def.F;
T << extract_nms_adpcm_read_f_def.T;
P << extract_nms_adpcm_read_f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_nms_adpcm_read_f_def_void@
identifier F = nms_adpcm_read_f;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_nms_adpcm_read_f_def_void@
F << extract_nms_adpcm_read_f_def_void.F;
P << extract_nms_adpcm_read_f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_nms_adpcm_read_f_decl@
type T;
identifier F = nms_adpcm_read_f;
parameter list P;
@@
T F(P);

@script:python depends on extract_nms_adpcm_read_f_decl@
F << extract_nms_adpcm_read_f_decl.F;
T << extract_nms_adpcm_read_f_decl.T;
P << extract_nms_adpcm_read_f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_nms_adpcm_read_f_decl_void@
identifier F = nms_adpcm_read_f;
parameter list P;
@@
void F(P);

@script:python depends on extract_nms_adpcm_read_f_decl_void@
F << extract_nms_adpcm_read_f_decl_void.F;
P << extract_nms_adpcm_read_f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: nms_adpcm_read_i
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_nms_adpcm_read_i_def@
type T;
identifier F = nms_adpcm_read_i;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_nms_adpcm_read_i_def@
F << remove_static_nms_adpcm_read_i_def.F;
T << remove_static_nms_adpcm_read_i_def.T;
P << remove_static_nms_adpcm_read_i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_nms_adpcm_read_i_def_void@
identifier F = nms_adpcm_read_i;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_nms_adpcm_read_i_def_void@
F << remove_static_nms_adpcm_read_i_def_void.F;
P << remove_static_nms_adpcm_read_i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_nms_adpcm_read_i_decl@
type T;
identifier F = nms_adpcm_read_i;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_nms_adpcm_read_i_decl@
F << remove_static_nms_adpcm_read_i_decl.F;
T << remove_static_nms_adpcm_read_i_decl.T;
P << remove_static_nms_adpcm_read_i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_nms_adpcm_read_i_decl_void@
identifier F = nms_adpcm_read_i;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_nms_adpcm_read_i_decl_void@
F << remove_static_nms_adpcm_read_i_decl_void.F;
P << remove_static_nms_adpcm_read_i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_nms_adpcm_read_i_def@
type T;
identifier F = nms_adpcm_read_i;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_nms_adpcm_read_i_def@
F << extract_nms_adpcm_read_i_def.F;
T << extract_nms_adpcm_read_i_def.T;
P << extract_nms_adpcm_read_i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_nms_adpcm_read_i_def_void@
identifier F = nms_adpcm_read_i;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_nms_adpcm_read_i_def_void@
F << extract_nms_adpcm_read_i_def_void.F;
P << extract_nms_adpcm_read_i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_nms_adpcm_read_i_decl@
type T;
identifier F = nms_adpcm_read_i;
parameter list P;
@@
T F(P);

@script:python depends on extract_nms_adpcm_read_i_decl@
F << extract_nms_adpcm_read_i_decl.F;
T << extract_nms_adpcm_read_i_decl.T;
P << extract_nms_adpcm_read_i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_nms_adpcm_read_i_decl_void@
identifier F = nms_adpcm_read_i;
parameter list P;
@@
void F(P);

@script:python depends on extract_nms_adpcm_read_i_decl_void@
F << extract_nms_adpcm_read_i_decl_void.F;
P << extract_nms_adpcm_read_i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: nms_adpcm_read_s
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_nms_adpcm_read_s_def@
type T;
identifier F = nms_adpcm_read_s;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_nms_adpcm_read_s_def@
F << remove_static_nms_adpcm_read_s_def.F;
T << remove_static_nms_adpcm_read_s_def.T;
P << remove_static_nms_adpcm_read_s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_nms_adpcm_read_s_def_void@
identifier F = nms_adpcm_read_s;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_nms_adpcm_read_s_def_void@
F << remove_static_nms_adpcm_read_s_def_void.F;
P << remove_static_nms_adpcm_read_s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_nms_adpcm_read_s_decl@
type T;
identifier F = nms_adpcm_read_s;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_nms_adpcm_read_s_decl@
F << remove_static_nms_adpcm_read_s_decl.F;
T << remove_static_nms_adpcm_read_s_decl.T;
P << remove_static_nms_adpcm_read_s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_nms_adpcm_read_s_decl_void@
identifier F = nms_adpcm_read_s;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_nms_adpcm_read_s_decl_void@
F << remove_static_nms_adpcm_read_s_decl_void.F;
P << remove_static_nms_adpcm_read_s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_nms_adpcm_read_s_def@
type T;
identifier F = nms_adpcm_read_s;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_nms_adpcm_read_s_def@
F << extract_nms_adpcm_read_s_def.F;
T << extract_nms_adpcm_read_s_def.T;
P << extract_nms_adpcm_read_s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_nms_adpcm_read_s_def_void@
identifier F = nms_adpcm_read_s;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_nms_adpcm_read_s_def_void@
F << extract_nms_adpcm_read_s_def_void.F;
P << extract_nms_adpcm_read_s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_nms_adpcm_read_s_decl@
type T;
identifier F = nms_adpcm_read_s;
parameter list P;
@@
T F(P);

@script:python depends on extract_nms_adpcm_read_s_decl@
F << extract_nms_adpcm_read_s_decl.F;
T << extract_nms_adpcm_read_s_decl.T;
P << extract_nms_adpcm_read_s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_nms_adpcm_read_s_decl_void@
identifier F = nms_adpcm_read_s;
parameter list P;
@@
void F(P);

@script:python depends on extract_nms_adpcm_read_s_decl_void@
F << extract_nms_adpcm_read_s_decl_void.F;
P << extract_nms_adpcm_read_s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: nms_adpcm_seek
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_nms_adpcm_seek_def@
type T;
identifier F = nms_adpcm_seek;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_nms_adpcm_seek_def@
F << remove_static_nms_adpcm_seek_def.F;
T << remove_static_nms_adpcm_seek_def.T;
P << remove_static_nms_adpcm_seek_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_nms_adpcm_seek_def_void@
identifier F = nms_adpcm_seek;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_nms_adpcm_seek_def_void@
F << remove_static_nms_adpcm_seek_def_void.F;
P << remove_static_nms_adpcm_seek_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_nms_adpcm_seek_decl@
type T;
identifier F = nms_adpcm_seek;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_nms_adpcm_seek_decl@
F << remove_static_nms_adpcm_seek_decl.F;
T << remove_static_nms_adpcm_seek_decl.T;
P << remove_static_nms_adpcm_seek_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_nms_adpcm_seek_decl_void@
identifier F = nms_adpcm_seek;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_nms_adpcm_seek_decl_void@
F << remove_static_nms_adpcm_seek_decl_void.F;
P << remove_static_nms_adpcm_seek_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_nms_adpcm_seek_def@
type T;
identifier F = nms_adpcm_seek;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_nms_adpcm_seek_def@
F << extract_nms_adpcm_seek_def.F;
T << extract_nms_adpcm_seek_def.T;
P << extract_nms_adpcm_seek_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_nms_adpcm_seek_def_void@
identifier F = nms_adpcm_seek;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_nms_adpcm_seek_def_void@
F << extract_nms_adpcm_seek_def_void.F;
P << extract_nms_adpcm_seek_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_nms_adpcm_seek_decl@
type T;
identifier F = nms_adpcm_seek;
parameter list P;
@@
T F(P);

@script:python depends on extract_nms_adpcm_seek_decl@
F << extract_nms_adpcm_seek_decl.F;
T << extract_nms_adpcm_seek_decl.T;
P << extract_nms_adpcm_seek_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_nms_adpcm_seek_decl_void@
identifier F = nms_adpcm_seek;
parameter list P;
@@
void F(P);

@script:python depends on extract_nms_adpcm_seek_decl_void@
F << extract_nms_adpcm_seek_decl_void.F;
P << extract_nms_adpcm_seek_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: nms_adpcm_write_d
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_nms_adpcm_write_d_def@
type T;
identifier F = nms_adpcm_write_d;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_nms_adpcm_write_d_def@
F << remove_static_nms_adpcm_write_d_def.F;
T << remove_static_nms_adpcm_write_d_def.T;
P << remove_static_nms_adpcm_write_d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_nms_adpcm_write_d_def_void@
identifier F = nms_adpcm_write_d;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_nms_adpcm_write_d_def_void@
F << remove_static_nms_adpcm_write_d_def_void.F;
P << remove_static_nms_adpcm_write_d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_nms_adpcm_write_d_decl@
type T;
identifier F = nms_adpcm_write_d;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_nms_adpcm_write_d_decl@
F << remove_static_nms_adpcm_write_d_decl.F;
T << remove_static_nms_adpcm_write_d_decl.T;
P << remove_static_nms_adpcm_write_d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_nms_adpcm_write_d_decl_void@
identifier F = nms_adpcm_write_d;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_nms_adpcm_write_d_decl_void@
F << remove_static_nms_adpcm_write_d_decl_void.F;
P << remove_static_nms_adpcm_write_d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_nms_adpcm_write_d_def@
type T;
identifier F = nms_adpcm_write_d;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_nms_adpcm_write_d_def@
F << extract_nms_adpcm_write_d_def.F;
T << extract_nms_adpcm_write_d_def.T;
P << extract_nms_adpcm_write_d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_nms_adpcm_write_d_def_void@
identifier F = nms_adpcm_write_d;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_nms_adpcm_write_d_def_void@
F << extract_nms_adpcm_write_d_def_void.F;
P << extract_nms_adpcm_write_d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_nms_adpcm_write_d_decl@
type T;
identifier F = nms_adpcm_write_d;
parameter list P;
@@
T F(P);

@script:python depends on extract_nms_adpcm_write_d_decl@
F << extract_nms_adpcm_write_d_decl.F;
T << extract_nms_adpcm_write_d_decl.T;
P << extract_nms_adpcm_write_d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_nms_adpcm_write_d_decl_void@
identifier F = nms_adpcm_write_d;
parameter list P;
@@
void F(P);

@script:python depends on extract_nms_adpcm_write_d_decl_void@
F << extract_nms_adpcm_write_d_decl_void.F;
P << extract_nms_adpcm_write_d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: nms_adpcm_write_f
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_nms_adpcm_write_f_def@
type T;
identifier F = nms_adpcm_write_f;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_nms_adpcm_write_f_def@
F << remove_static_nms_adpcm_write_f_def.F;
T << remove_static_nms_adpcm_write_f_def.T;
P << remove_static_nms_adpcm_write_f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_nms_adpcm_write_f_def_void@
identifier F = nms_adpcm_write_f;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_nms_adpcm_write_f_def_void@
F << remove_static_nms_adpcm_write_f_def_void.F;
P << remove_static_nms_adpcm_write_f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_nms_adpcm_write_f_decl@
type T;
identifier F = nms_adpcm_write_f;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_nms_adpcm_write_f_decl@
F << remove_static_nms_adpcm_write_f_decl.F;
T << remove_static_nms_adpcm_write_f_decl.T;
P << remove_static_nms_adpcm_write_f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_nms_adpcm_write_f_decl_void@
identifier F = nms_adpcm_write_f;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_nms_adpcm_write_f_decl_void@
F << remove_static_nms_adpcm_write_f_decl_void.F;
P << remove_static_nms_adpcm_write_f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_nms_adpcm_write_f_def@
type T;
identifier F = nms_adpcm_write_f;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_nms_adpcm_write_f_def@
F << extract_nms_adpcm_write_f_def.F;
T << extract_nms_adpcm_write_f_def.T;
P << extract_nms_adpcm_write_f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_nms_adpcm_write_f_def_void@
identifier F = nms_adpcm_write_f;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_nms_adpcm_write_f_def_void@
F << extract_nms_adpcm_write_f_def_void.F;
P << extract_nms_adpcm_write_f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_nms_adpcm_write_f_decl@
type T;
identifier F = nms_adpcm_write_f;
parameter list P;
@@
T F(P);

@script:python depends on extract_nms_adpcm_write_f_decl@
F << extract_nms_adpcm_write_f_decl.F;
T << extract_nms_adpcm_write_f_decl.T;
P << extract_nms_adpcm_write_f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_nms_adpcm_write_f_decl_void@
identifier F = nms_adpcm_write_f;
parameter list P;
@@
void F(P);

@script:python depends on extract_nms_adpcm_write_f_decl_void@
F << extract_nms_adpcm_write_f_decl_void.F;
P << extract_nms_adpcm_write_f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: nms_adpcm_write_i
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_nms_adpcm_write_i_def@
type T;
identifier F = nms_adpcm_write_i;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_nms_adpcm_write_i_def@
F << remove_static_nms_adpcm_write_i_def.F;
T << remove_static_nms_adpcm_write_i_def.T;
P << remove_static_nms_adpcm_write_i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_nms_adpcm_write_i_def_void@
identifier F = nms_adpcm_write_i;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_nms_adpcm_write_i_def_void@
F << remove_static_nms_adpcm_write_i_def_void.F;
P << remove_static_nms_adpcm_write_i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_nms_adpcm_write_i_decl@
type T;
identifier F = nms_adpcm_write_i;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_nms_adpcm_write_i_decl@
F << remove_static_nms_adpcm_write_i_decl.F;
T << remove_static_nms_adpcm_write_i_decl.T;
P << remove_static_nms_adpcm_write_i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_nms_adpcm_write_i_decl_void@
identifier F = nms_adpcm_write_i;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_nms_adpcm_write_i_decl_void@
F << remove_static_nms_adpcm_write_i_decl_void.F;
P << remove_static_nms_adpcm_write_i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_nms_adpcm_write_i_def@
type T;
identifier F = nms_adpcm_write_i;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_nms_adpcm_write_i_def@
F << extract_nms_adpcm_write_i_def.F;
T << extract_nms_adpcm_write_i_def.T;
P << extract_nms_adpcm_write_i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_nms_adpcm_write_i_def_void@
identifier F = nms_adpcm_write_i;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_nms_adpcm_write_i_def_void@
F << extract_nms_adpcm_write_i_def_void.F;
P << extract_nms_adpcm_write_i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_nms_adpcm_write_i_decl@
type T;
identifier F = nms_adpcm_write_i;
parameter list P;
@@
T F(P);

@script:python depends on extract_nms_adpcm_write_i_decl@
F << extract_nms_adpcm_write_i_decl.F;
T << extract_nms_adpcm_write_i_decl.T;
P << extract_nms_adpcm_write_i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_nms_adpcm_write_i_decl_void@
identifier F = nms_adpcm_write_i;
parameter list P;
@@
void F(P);

@script:python depends on extract_nms_adpcm_write_i_decl_void@
F << extract_nms_adpcm_write_i_decl_void.F;
P << extract_nms_adpcm_write_i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: nms_adpcm_write_s
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_nms_adpcm_write_s_def@
type T;
identifier F = nms_adpcm_write_s;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_nms_adpcm_write_s_def@
F << remove_static_nms_adpcm_write_s_def.F;
T << remove_static_nms_adpcm_write_s_def.T;
P << remove_static_nms_adpcm_write_s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_nms_adpcm_write_s_def_void@
identifier F = nms_adpcm_write_s;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_nms_adpcm_write_s_def_void@
F << remove_static_nms_adpcm_write_s_def_void.F;
P << remove_static_nms_adpcm_write_s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_nms_adpcm_write_s_decl@
type T;
identifier F = nms_adpcm_write_s;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_nms_adpcm_write_s_decl@
F << remove_static_nms_adpcm_write_s_decl.F;
T << remove_static_nms_adpcm_write_s_decl.T;
P << remove_static_nms_adpcm_write_s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_nms_adpcm_write_s_decl_void@
identifier F = nms_adpcm_write_s;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_nms_adpcm_write_s_decl_void@
F << remove_static_nms_adpcm_write_s_decl_void.F;
P << remove_static_nms_adpcm_write_s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_nms_adpcm_write_s_def@
type T;
identifier F = nms_adpcm_write_s;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_nms_adpcm_write_s_def@
F << extract_nms_adpcm_write_s_def.F;
T << extract_nms_adpcm_write_s_def.T;
P << extract_nms_adpcm_write_s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_nms_adpcm_write_s_def_void@
identifier F = nms_adpcm_write_s;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_nms_adpcm_write_s_def_void@
F << extract_nms_adpcm_write_s_def_void.F;
P << extract_nms_adpcm_write_s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_nms_adpcm_write_s_decl@
type T;
identifier F = nms_adpcm_write_s;
parameter list P;
@@
T F(P);

@script:python depends on extract_nms_adpcm_write_s_decl@
F << extract_nms_adpcm_write_s_decl.F;
T << extract_nms_adpcm_write_s_decl.T;
P << extract_nms_adpcm_write_s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_nms_adpcm_write_s_decl_void@
identifier F = nms_adpcm_write_s;
parameter list P;
@@
void F(P);

@script:python depends on extract_nms_adpcm_write_s_decl_void@
F << extract_nms_adpcm_write_s_decl_void.F;
P << extract_nms_adpcm_write_s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: ogg_close
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_ogg_close_def@
type T;
identifier F = ogg_close;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_ogg_close_def@
F << remove_static_ogg_close_def.F;
T << remove_static_ogg_close_def.T;
P << remove_static_ogg_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_ogg_close_def_void@
identifier F = ogg_close;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_ogg_close_def_void@
F << remove_static_ogg_close_def_void.F;
P << remove_static_ogg_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_ogg_close_decl@
type T;
identifier F = ogg_close;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_ogg_close_decl@
F << remove_static_ogg_close_decl.F;
T << remove_static_ogg_close_decl.T;
P << remove_static_ogg_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_ogg_close_decl_void@
identifier F = ogg_close;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_ogg_close_decl_void@
F << remove_static_ogg_close_decl_void.F;
P << remove_static_ogg_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_ogg_close_def@
type T;
identifier F = ogg_close;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_ogg_close_def@
F << extract_ogg_close_def.F;
T << extract_ogg_close_def.T;
P << extract_ogg_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_ogg_close_def_void@
identifier F = ogg_close;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_ogg_close_def_void@
F << extract_ogg_close_def_void.F;
P << extract_ogg_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_ogg_close_decl@
type T;
identifier F = ogg_close;
parameter list P;
@@
T F(P);

@script:python depends on extract_ogg_close_decl@
F << extract_ogg_close_decl.F;
T << extract_ogg_close_decl.T;
P << extract_ogg_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_ogg_close_decl_void@
identifier F = ogg_close;
parameter list P;
@@
void F(P);

@script:python depends on extract_ogg_close_decl_void@
F << extract_ogg_close_decl_void.F;
P << extract_ogg_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: ogg_opus_byterate
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_ogg_opus_byterate_def@
type T;
identifier F = ogg_opus_byterate;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_ogg_opus_byterate_def@
F << remove_static_ogg_opus_byterate_def.F;
T << remove_static_ogg_opus_byterate_def.T;
P << remove_static_ogg_opus_byterate_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_ogg_opus_byterate_def_void@
identifier F = ogg_opus_byterate;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_ogg_opus_byterate_def_void@
F << remove_static_ogg_opus_byterate_def_void.F;
P << remove_static_ogg_opus_byterate_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_ogg_opus_byterate_decl@
type T;
identifier F = ogg_opus_byterate;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_ogg_opus_byterate_decl@
F << remove_static_ogg_opus_byterate_decl.F;
T << remove_static_ogg_opus_byterate_decl.T;
P << remove_static_ogg_opus_byterate_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_ogg_opus_byterate_decl_void@
identifier F = ogg_opus_byterate;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_ogg_opus_byterate_decl_void@
F << remove_static_ogg_opus_byterate_decl_void.F;
P << remove_static_ogg_opus_byterate_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_ogg_opus_byterate_def@
type T;
identifier F = ogg_opus_byterate;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_ogg_opus_byterate_def@
F << extract_ogg_opus_byterate_def.F;
T << extract_ogg_opus_byterate_def.T;
P << extract_ogg_opus_byterate_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_ogg_opus_byterate_def_void@
identifier F = ogg_opus_byterate;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_ogg_opus_byterate_def_void@
F << extract_ogg_opus_byterate_def_void.F;
P << extract_ogg_opus_byterate_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_ogg_opus_byterate_decl@
type T;
identifier F = ogg_opus_byterate;
parameter list P;
@@
T F(P);

@script:python depends on extract_ogg_opus_byterate_decl@
F << extract_ogg_opus_byterate_decl.F;
T << extract_ogg_opus_byterate_decl.T;
P << extract_ogg_opus_byterate_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_ogg_opus_byterate_decl_void@
identifier F = ogg_opus_byterate;
parameter list P;
@@
void F(P);

@script:python depends on extract_ogg_opus_byterate_decl_void@
F << extract_ogg_opus_byterate_decl_void.F;
P << extract_ogg_opus_byterate_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: ogg_opus_close
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_ogg_opus_close_def@
type T;
identifier F = ogg_opus_close;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_ogg_opus_close_def@
F << remove_static_ogg_opus_close_def.F;
T << remove_static_ogg_opus_close_def.T;
P << remove_static_ogg_opus_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_ogg_opus_close_def_void@
identifier F = ogg_opus_close;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_ogg_opus_close_def_void@
F << remove_static_ogg_opus_close_def_void.F;
P << remove_static_ogg_opus_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_ogg_opus_close_decl@
type T;
identifier F = ogg_opus_close;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_ogg_opus_close_decl@
F << remove_static_ogg_opus_close_decl.F;
T << remove_static_ogg_opus_close_decl.T;
P << remove_static_ogg_opus_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_ogg_opus_close_decl_void@
identifier F = ogg_opus_close;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_ogg_opus_close_decl_void@
F << remove_static_ogg_opus_close_decl_void.F;
P << remove_static_ogg_opus_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_ogg_opus_close_def@
type T;
identifier F = ogg_opus_close;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_ogg_opus_close_def@
F << extract_ogg_opus_close_def.F;
T << extract_ogg_opus_close_def.T;
P << extract_ogg_opus_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_ogg_opus_close_def_void@
identifier F = ogg_opus_close;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_ogg_opus_close_def_void@
F << extract_ogg_opus_close_def_void.F;
P << extract_ogg_opus_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_ogg_opus_close_decl@
type T;
identifier F = ogg_opus_close;
parameter list P;
@@
T F(P);

@script:python depends on extract_ogg_opus_close_decl@
F << extract_ogg_opus_close_decl.F;
T << extract_ogg_opus_close_decl.T;
P << extract_ogg_opus_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_ogg_opus_close_decl_void@
identifier F = ogg_opus_close;
parameter list P;
@@
void F(P);

@script:python depends on extract_ogg_opus_close_decl_void@
F << extract_ogg_opus_close_decl_void.F;
P << extract_ogg_opus_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: ogg_opus_command
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_ogg_opus_command_def@
type T;
identifier F = ogg_opus_command;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_ogg_opus_command_def@
F << remove_static_ogg_opus_command_def.F;
T << remove_static_ogg_opus_command_def.T;
P << remove_static_ogg_opus_command_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_ogg_opus_command_def_void@
identifier F = ogg_opus_command;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_ogg_opus_command_def_void@
F << remove_static_ogg_opus_command_def_void.F;
P << remove_static_ogg_opus_command_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_ogg_opus_command_decl@
type T;
identifier F = ogg_opus_command;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_ogg_opus_command_decl@
F << remove_static_ogg_opus_command_decl.F;
T << remove_static_ogg_opus_command_decl.T;
P << remove_static_ogg_opus_command_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_ogg_opus_command_decl_void@
identifier F = ogg_opus_command;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_ogg_opus_command_decl_void@
F << remove_static_ogg_opus_command_decl_void.F;
P << remove_static_ogg_opus_command_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_ogg_opus_command_def@
type T;
identifier F = ogg_opus_command;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_ogg_opus_command_def@
F << extract_ogg_opus_command_def.F;
T << extract_ogg_opus_command_def.T;
P << extract_ogg_opus_command_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_ogg_opus_command_def_void@
identifier F = ogg_opus_command;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_ogg_opus_command_def_void@
F << extract_ogg_opus_command_def_void.F;
P << extract_ogg_opus_command_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_ogg_opus_command_decl@
type T;
identifier F = ogg_opus_command;
parameter list P;
@@
T F(P);

@script:python depends on extract_ogg_opus_command_decl@
F << extract_ogg_opus_command_decl.F;
T << extract_ogg_opus_command_decl.T;
P << extract_ogg_opus_command_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_ogg_opus_command_decl_void@
identifier F = ogg_opus_command;
parameter list P;
@@
void F(P);

@script:python depends on extract_ogg_opus_command_decl_void@
F << extract_ogg_opus_command_decl_void.F;
P << extract_ogg_opus_command_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: ogg_opus_read_d
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_ogg_opus_read_d_def@
type T;
identifier F = ogg_opus_read_d;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_ogg_opus_read_d_def@
F << remove_static_ogg_opus_read_d_def.F;
T << remove_static_ogg_opus_read_d_def.T;
P << remove_static_ogg_opus_read_d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_ogg_opus_read_d_def_void@
identifier F = ogg_opus_read_d;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_ogg_opus_read_d_def_void@
F << remove_static_ogg_opus_read_d_def_void.F;
P << remove_static_ogg_opus_read_d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_ogg_opus_read_d_decl@
type T;
identifier F = ogg_opus_read_d;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_ogg_opus_read_d_decl@
F << remove_static_ogg_opus_read_d_decl.F;
T << remove_static_ogg_opus_read_d_decl.T;
P << remove_static_ogg_opus_read_d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_ogg_opus_read_d_decl_void@
identifier F = ogg_opus_read_d;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_ogg_opus_read_d_decl_void@
F << remove_static_ogg_opus_read_d_decl_void.F;
P << remove_static_ogg_opus_read_d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_ogg_opus_read_d_def@
type T;
identifier F = ogg_opus_read_d;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_ogg_opus_read_d_def@
F << extract_ogg_opus_read_d_def.F;
T << extract_ogg_opus_read_d_def.T;
P << extract_ogg_opus_read_d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_ogg_opus_read_d_def_void@
identifier F = ogg_opus_read_d;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_ogg_opus_read_d_def_void@
F << extract_ogg_opus_read_d_def_void.F;
P << extract_ogg_opus_read_d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_ogg_opus_read_d_decl@
type T;
identifier F = ogg_opus_read_d;
parameter list P;
@@
T F(P);

@script:python depends on extract_ogg_opus_read_d_decl@
F << extract_ogg_opus_read_d_decl.F;
T << extract_ogg_opus_read_d_decl.T;
P << extract_ogg_opus_read_d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_ogg_opus_read_d_decl_void@
identifier F = ogg_opus_read_d;
parameter list P;
@@
void F(P);

@script:python depends on extract_ogg_opus_read_d_decl_void@
F << extract_ogg_opus_read_d_decl_void.F;
P << extract_ogg_opus_read_d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: ogg_opus_read_f
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_ogg_opus_read_f_def@
type T;
identifier F = ogg_opus_read_f;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_ogg_opus_read_f_def@
F << remove_static_ogg_opus_read_f_def.F;
T << remove_static_ogg_opus_read_f_def.T;
P << remove_static_ogg_opus_read_f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_ogg_opus_read_f_def_void@
identifier F = ogg_opus_read_f;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_ogg_opus_read_f_def_void@
F << remove_static_ogg_opus_read_f_def_void.F;
P << remove_static_ogg_opus_read_f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_ogg_opus_read_f_decl@
type T;
identifier F = ogg_opus_read_f;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_ogg_opus_read_f_decl@
F << remove_static_ogg_opus_read_f_decl.F;
T << remove_static_ogg_opus_read_f_decl.T;
P << remove_static_ogg_opus_read_f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_ogg_opus_read_f_decl_void@
identifier F = ogg_opus_read_f;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_ogg_opus_read_f_decl_void@
F << remove_static_ogg_opus_read_f_decl_void.F;
P << remove_static_ogg_opus_read_f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_ogg_opus_read_f_def@
type T;
identifier F = ogg_opus_read_f;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_ogg_opus_read_f_def@
F << extract_ogg_opus_read_f_def.F;
T << extract_ogg_opus_read_f_def.T;
P << extract_ogg_opus_read_f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_ogg_opus_read_f_def_void@
identifier F = ogg_opus_read_f;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_ogg_opus_read_f_def_void@
F << extract_ogg_opus_read_f_def_void.F;
P << extract_ogg_opus_read_f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_ogg_opus_read_f_decl@
type T;
identifier F = ogg_opus_read_f;
parameter list P;
@@
T F(P);

@script:python depends on extract_ogg_opus_read_f_decl@
F << extract_ogg_opus_read_f_decl.F;
T << extract_ogg_opus_read_f_decl.T;
P << extract_ogg_opus_read_f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_ogg_opus_read_f_decl_void@
identifier F = ogg_opus_read_f;
parameter list P;
@@
void F(P);

@script:python depends on extract_ogg_opus_read_f_decl_void@
F << extract_ogg_opus_read_f_decl_void.F;
P << extract_ogg_opus_read_f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: ogg_opus_read_i
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_ogg_opus_read_i_def@
type T;
identifier F = ogg_opus_read_i;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_ogg_opus_read_i_def@
F << remove_static_ogg_opus_read_i_def.F;
T << remove_static_ogg_opus_read_i_def.T;
P << remove_static_ogg_opus_read_i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_ogg_opus_read_i_def_void@
identifier F = ogg_opus_read_i;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_ogg_opus_read_i_def_void@
F << remove_static_ogg_opus_read_i_def_void.F;
P << remove_static_ogg_opus_read_i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_ogg_opus_read_i_decl@
type T;
identifier F = ogg_opus_read_i;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_ogg_opus_read_i_decl@
F << remove_static_ogg_opus_read_i_decl.F;
T << remove_static_ogg_opus_read_i_decl.T;
P << remove_static_ogg_opus_read_i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_ogg_opus_read_i_decl_void@
identifier F = ogg_opus_read_i;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_ogg_opus_read_i_decl_void@
F << remove_static_ogg_opus_read_i_decl_void.F;
P << remove_static_ogg_opus_read_i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_ogg_opus_read_i_def@
type T;
identifier F = ogg_opus_read_i;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_ogg_opus_read_i_def@
F << extract_ogg_opus_read_i_def.F;
T << extract_ogg_opus_read_i_def.T;
P << extract_ogg_opus_read_i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_ogg_opus_read_i_def_void@
identifier F = ogg_opus_read_i;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_ogg_opus_read_i_def_void@
F << extract_ogg_opus_read_i_def_void.F;
P << extract_ogg_opus_read_i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_ogg_opus_read_i_decl@
type T;
identifier F = ogg_opus_read_i;
parameter list P;
@@
T F(P);

@script:python depends on extract_ogg_opus_read_i_decl@
F << extract_ogg_opus_read_i_decl.F;
T << extract_ogg_opus_read_i_decl.T;
P << extract_ogg_opus_read_i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_ogg_opus_read_i_decl_void@
identifier F = ogg_opus_read_i;
parameter list P;
@@
void F(P);

@script:python depends on extract_ogg_opus_read_i_decl_void@
F << extract_ogg_opus_read_i_decl_void.F;
P << extract_ogg_opus_read_i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: ogg_opus_read_s
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_ogg_opus_read_s_def@
type T;
identifier F = ogg_opus_read_s;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_ogg_opus_read_s_def@
F << remove_static_ogg_opus_read_s_def.F;
T << remove_static_ogg_opus_read_s_def.T;
P << remove_static_ogg_opus_read_s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_ogg_opus_read_s_def_void@
identifier F = ogg_opus_read_s;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_ogg_opus_read_s_def_void@
F << remove_static_ogg_opus_read_s_def_void.F;
P << remove_static_ogg_opus_read_s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_ogg_opus_read_s_decl@
type T;
identifier F = ogg_opus_read_s;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_ogg_opus_read_s_decl@
F << remove_static_ogg_opus_read_s_decl.F;
T << remove_static_ogg_opus_read_s_decl.T;
P << remove_static_ogg_opus_read_s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_ogg_opus_read_s_decl_void@
identifier F = ogg_opus_read_s;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_ogg_opus_read_s_decl_void@
F << remove_static_ogg_opus_read_s_decl_void.F;
P << remove_static_ogg_opus_read_s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_ogg_opus_read_s_def@
type T;
identifier F = ogg_opus_read_s;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_ogg_opus_read_s_def@
F << extract_ogg_opus_read_s_def.F;
T << extract_ogg_opus_read_s_def.T;
P << extract_ogg_opus_read_s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_ogg_opus_read_s_def_void@
identifier F = ogg_opus_read_s;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_ogg_opus_read_s_def_void@
F << extract_ogg_opus_read_s_def_void.F;
P << extract_ogg_opus_read_s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_ogg_opus_read_s_decl@
type T;
identifier F = ogg_opus_read_s;
parameter list P;
@@
T F(P);

@script:python depends on extract_ogg_opus_read_s_decl@
F << extract_ogg_opus_read_s_decl.F;
T << extract_ogg_opus_read_s_decl.T;
P << extract_ogg_opus_read_s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_ogg_opus_read_s_decl_void@
identifier F = ogg_opus_read_s;
parameter list P;
@@
void F(P);

@script:python depends on extract_ogg_opus_read_s_decl_void@
F << extract_ogg_opus_read_s_decl_void.F;
P << extract_ogg_opus_read_s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: ogg_opus_seek
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_ogg_opus_seek_def@
type T;
identifier F = ogg_opus_seek;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_ogg_opus_seek_def@
F << remove_static_ogg_opus_seek_def.F;
T << remove_static_ogg_opus_seek_def.T;
P << remove_static_ogg_opus_seek_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_ogg_opus_seek_def_void@
identifier F = ogg_opus_seek;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_ogg_opus_seek_def_void@
F << remove_static_ogg_opus_seek_def_void.F;
P << remove_static_ogg_opus_seek_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_ogg_opus_seek_decl@
type T;
identifier F = ogg_opus_seek;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_ogg_opus_seek_decl@
F << remove_static_ogg_opus_seek_decl.F;
T << remove_static_ogg_opus_seek_decl.T;
P << remove_static_ogg_opus_seek_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_ogg_opus_seek_decl_void@
identifier F = ogg_opus_seek;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_ogg_opus_seek_decl_void@
F << remove_static_ogg_opus_seek_decl_void.F;
P << remove_static_ogg_opus_seek_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_ogg_opus_seek_def@
type T;
identifier F = ogg_opus_seek;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_ogg_opus_seek_def@
F << extract_ogg_opus_seek_def.F;
T << extract_ogg_opus_seek_def.T;
P << extract_ogg_opus_seek_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_ogg_opus_seek_def_void@
identifier F = ogg_opus_seek;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_ogg_opus_seek_def_void@
F << extract_ogg_opus_seek_def_void.F;
P << extract_ogg_opus_seek_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_ogg_opus_seek_decl@
type T;
identifier F = ogg_opus_seek;
parameter list P;
@@
T F(P);

@script:python depends on extract_ogg_opus_seek_decl@
F << extract_ogg_opus_seek_decl.F;
T << extract_ogg_opus_seek_decl.T;
P << extract_ogg_opus_seek_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_ogg_opus_seek_decl_void@
identifier F = ogg_opus_seek;
parameter list P;
@@
void F(P);

@script:python depends on extract_ogg_opus_seek_decl_void@
F << extract_ogg_opus_seek_decl_void.F;
P << extract_ogg_opus_seek_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: ogg_opus_write_d
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_ogg_opus_write_d_def@
type T;
identifier F = ogg_opus_write_d;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_ogg_opus_write_d_def@
F << remove_static_ogg_opus_write_d_def.F;
T << remove_static_ogg_opus_write_d_def.T;
P << remove_static_ogg_opus_write_d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_ogg_opus_write_d_def_void@
identifier F = ogg_opus_write_d;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_ogg_opus_write_d_def_void@
F << remove_static_ogg_opus_write_d_def_void.F;
P << remove_static_ogg_opus_write_d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_ogg_opus_write_d_decl@
type T;
identifier F = ogg_opus_write_d;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_ogg_opus_write_d_decl@
F << remove_static_ogg_opus_write_d_decl.F;
T << remove_static_ogg_opus_write_d_decl.T;
P << remove_static_ogg_opus_write_d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_ogg_opus_write_d_decl_void@
identifier F = ogg_opus_write_d;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_ogg_opus_write_d_decl_void@
F << remove_static_ogg_opus_write_d_decl_void.F;
P << remove_static_ogg_opus_write_d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_ogg_opus_write_d_def@
type T;
identifier F = ogg_opus_write_d;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_ogg_opus_write_d_def@
F << extract_ogg_opus_write_d_def.F;
T << extract_ogg_opus_write_d_def.T;
P << extract_ogg_opus_write_d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_ogg_opus_write_d_def_void@
identifier F = ogg_opus_write_d;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_ogg_opus_write_d_def_void@
F << extract_ogg_opus_write_d_def_void.F;
P << extract_ogg_opus_write_d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_ogg_opus_write_d_decl@
type T;
identifier F = ogg_opus_write_d;
parameter list P;
@@
T F(P);

@script:python depends on extract_ogg_opus_write_d_decl@
F << extract_ogg_opus_write_d_decl.F;
T << extract_ogg_opus_write_d_decl.T;
P << extract_ogg_opus_write_d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_ogg_opus_write_d_decl_void@
identifier F = ogg_opus_write_d;
parameter list P;
@@
void F(P);

@script:python depends on extract_ogg_opus_write_d_decl_void@
F << extract_ogg_opus_write_d_decl_void.F;
P << extract_ogg_opus_write_d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: ogg_opus_write_f
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_ogg_opus_write_f_def@
type T;
identifier F = ogg_opus_write_f;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_ogg_opus_write_f_def@
F << remove_static_ogg_opus_write_f_def.F;
T << remove_static_ogg_opus_write_f_def.T;
P << remove_static_ogg_opus_write_f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_ogg_opus_write_f_def_void@
identifier F = ogg_opus_write_f;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_ogg_opus_write_f_def_void@
F << remove_static_ogg_opus_write_f_def_void.F;
P << remove_static_ogg_opus_write_f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_ogg_opus_write_f_decl@
type T;
identifier F = ogg_opus_write_f;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_ogg_opus_write_f_decl@
F << remove_static_ogg_opus_write_f_decl.F;
T << remove_static_ogg_opus_write_f_decl.T;
P << remove_static_ogg_opus_write_f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_ogg_opus_write_f_decl_void@
identifier F = ogg_opus_write_f;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_ogg_opus_write_f_decl_void@
F << remove_static_ogg_opus_write_f_decl_void.F;
P << remove_static_ogg_opus_write_f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_ogg_opus_write_f_def@
type T;
identifier F = ogg_opus_write_f;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_ogg_opus_write_f_def@
F << extract_ogg_opus_write_f_def.F;
T << extract_ogg_opus_write_f_def.T;
P << extract_ogg_opus_write_f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_ogg_opus_write_f_def_void@
identifier F = ogg_opus_write_f;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_ogg_opus_write_f_def_void@
F << extract_ogg_opus_write_f_def_void.F;
P << extract_ogg_opus_write_f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_ogg_opus_write_f_decl@
type T;
identifier F = ogg_opus_write_f;
parameter list P;
@@
T F(P);

@script:python depends on extract_ogg_opus_write_f_decl@
F << extract_ogg_opus_write_f_decl.F;
T << extract_ogg_opus_write_f_decl.T;
P << extract_ogg_opus_write_f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_ogg_opus_write_f_decl_void@
identifier F = ogg_opus_write_f;
parameter list P;
@@
void F(P);

@script:python depends on extract_ogg_opus_write_f_decl_void@
F << extract_ogg_opus_write_f_decl_void.F;
P << extract_ogg_opus_write_f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: ogg_opus_write_header
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_ogg_opus_write_header_def@
type T;
identifier F = ogg_opus_write_header;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_ogg_opus_write_header_def@
F << remove_static_ogg_opus_write_header_def.F;
T << remove_static_ogg_opus_write_header_def.T;
P << remove_static_ogg_opus_write_header_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_ogg_opus_write_header_def_void@
identifier F = ogg_opus_write_header;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_ogg_opus_write_header_def_void@
F << remove_static_ogg_opus_write_header_def_void.F;
P << remove_static_ogg_opus_write_header_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_ogg_opus_write_header_decl@
type T;
identifier F = ogg_opus_write_header;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_ogg_opus_write_header_decl@
F << remove_static_ogg_opus_write_header_decl.F;
T << remove_static_ogg_opus_write_header_decl.T;
P << remove_static_ogg_opus_write_header_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_ogg_opus_write_header_decl_void@
identifier F = ogg_opus_write_header;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_ogg_opus_write_header_decl_void@
F << remove_static_ogg_opus_write_header_decl_void.F;
P << remove_static_ogg_opus_write_header_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_ogg_opus_write_header_def@
type T;
identifier F = ogg_opus_write_header;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_ogg_opus_write_header_def@
F << extract_ogg_opus_write_header_def.F;
T << extract_ogg_opus_write_header_def.T;
P << extract_ogg_opus_write_header_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_ogg_opus_write_header_def_void@
identifier F = ogg_opus_write_header;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_ogg_opus_write_header_def_void@
F << extract_ogg_opus_write_header_def_void.F;
P << extract_ogg_opus_write_header_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_ogg_opus_write_header_decl@
type T;
identifier F = ogg_opus_write_header;
parameter list P;
@@
T F(P);

@script:python depends on extract_ogg_opus_write_header_decl@
F << extract_ogg_opus_write_header_decl.F;
T << extract_ogg_opus_write_header_decl.T;
P << extract_ogg_opus_write_header_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_ogg_opus_write_header_decl_void@
identifier F = ogg_opus_write_header;
parameter list P;
@@
void F(P);

@script:python depends on extract_ogg_opus_write_header_decl_void@
F << extract_ogg_opus_write_header_decl_void.F;
P << extract_ogg_opus_write_header_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: ogg_opus_write_i
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_ogg_opus_write_i_def@
type T;
identifier F = ogg_opus_write_i;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_ogg_opus_write_i_def@
F << remove_static_ogg_opus_write_i_def.F;
T << remove_static_ogg_opus_write_i_def.T;
P << remove_static_ogg_opus_write_i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_ogg_opus_write_i_def_void@
identifier F = ogg_opus_write_i;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_ogg_opus_write_i_def_void@
F << remove_static_ogg_opus_write_i_def_void.F;
P << remove_static_ogg_opus_write_i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_ogg_opus_write_i_decl@
type T;
identifier F = ogg_opus_write_i;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_ogg_opus_write_i_decl@
F << remove_static_ogg_opus_write_i_decl.F;
T << remove_static_ogg_opus_write_i_decl.T;
P << remove_static_ogg_opus_write_i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_ogg_opus_write_i_decl_void@
identifier F = ogg_opus_write_i;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_ogg_opus_write_i_decl_void@
F << remove_static_ogg_opus_write_i_decl_void.F;
P << remove_static_ogg_opus_write_i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_ogg_opus_write_i_def@
type T;
identifier F = ogg_opus_write_i;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_ogg_opus_write_i_def@
F << extract_ogg_opus_write_i_def.F;
T << extract_ogg_opus_write_i_def.T;
P << extract_ogg_opus_write_i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_ogg_opus_write_i_def_void@
identifier F = ogg_opus_write_i;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_ogg_opus_write_i_def_void@
F << extract_ogg_opus_write_i_def_void.F;
P << extract_ogg_opus_write_i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_ogg_opus_write_i_decl@
type T;
identifier F = ogg_opus_write_i;
parameter list P;
@@
T F(P);

@script:python depends on extract_ogg_opus_write_i_decl@
F << extract_ogg_opus_write_i_decl.F;
T << extract_ogg_opus_write_i_decl.T;
P << extract_ogg_opus_write_i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_ogg_opus_write_i_decl_void@
identifier F = ogg_opus_write_i;
parameter list P;
@@
void F(P);

@script:python depends on extract_ogg_opus_write_i_decl_void@
F << extract_ogg_opus_write_i_decl_void.F;
P << extract_ogg_opus_write_i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: ogg_opus_write_s
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_ogg_opus_write_s_def@
type T;
identifier F = ogg_opus_write_s;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_ogg_opus_write_s_def@
F << remove_static_ogg_opus_write_s_def.F;
T << remove_static_ogg_opus_write_s_def.T;
P << remove_static_ogg_opus_write_s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_ogg_opus_write_s_def_void@
identifier F = ogg_opus_write_s;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_ogg_opus_write_s_def_void@
F << remove_static_ogg_opus_write_s_def_void.F;
P << remove_static_ogg_opus_write_s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_ogg_opus_write_s_decl@
type T;
identifier F = ogg_opus_write_s;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_ogg_opus_write_s_decl@
F << remove_static_ogg_opus_write_s_decl.F;
T << remove_static_ogg_opus_write_s_decl.T;
P << remove_static_ogg_opus_write_s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_ogg_opus_write_s_decl_void@
identifier F = ogg_opus_write_s;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_ogg_opus_write_s_decl_void@
F << remove_static_ogg_opus_write_s_decl_void.F;
P << remove_static_ogg_opus_write_s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_ogg_opus_write_s_def@
type T;
identifier F = ogg_opus_write_s;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_ogg_opus_write_s_def@
F << extract_ogg_opus_write_s_def.F;
T << extract_ogg_opus_write_s_def.T;
P << extract_ogg_opus_write_s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_ogg_opus_write_s_def_void@
identifier F = ogg_opus_write_s;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_ogg_opus_write_s_def_void@
F << extract_ogg_opus_write_s_def_void.F;
P << extract_ogg_opus_write_s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_ogg_opus_write_s_decl@
type T;
identifier F = ogg_opus_write_s;
parameter list P;
@@
T F(P);

@script:python depends on extract_ogg_opus_write_s_decl@
F << extract_ogg_opus_write_s_decl.F;
T << extract_ogg_opus_write_s_decl.T;
P << extract_ogg_opus_write_s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_ogg_opus_write_s_decl_void@
identifier F = ogg_opus_write_s;
parameter list P;
@@
void F(P);

@script:python depends on extract_ogg_opus_write_s_decl_void@
F << extract_ogg_opus_write_s_decl_void.F;
P << extract_ogg_opus_write_s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: opcm_close
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_opcm_close_def@
type T;
identifier F = opcm_close;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_opcm_close_def@
F << remove_static_opcm_close_def.F;
T << remove_static_opcm_close_def.T;
P << remove_static_opcm_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_opcm_close_def_void@
identifier F = opcm_close;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_opcm_close_def_void@
F << remove_static_opcm_close_def_void.F;
P << remove_static_opcm_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_opcm_close_decl@
type T;
identifier F = opcm_close;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_opcm_close_decl@
F << remove_static_opcm_close_decl.F;
T << remove_static_opcm_close_decl.T;
P << remove_static_opcm_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_opcm_close_decl_void@
identifier F = opcm_close;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_opcm_close_decl_void@
F << remove_static_opcm_close_decl_void.F;
P << remove_static_opcm_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_opcm_close_def@
type T;
identifier F = opcm_close;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_opcm_close_def@
F << extract_opcm_close_def.F;
T << extract_opcm_close_def.T;
P << extract_opcm_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_opcm_close_def_void@
identifier F = opcm_close;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_opcm_close_def_void@
F << extract_opcm_close_def_void.F;
P << extract_opcm_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_opcm_close_decl@
type T;
identifier F = opcm_close;
parameter list P;
@@
T F(P);

@script:python depends on extract_opcm_close_decl@
F << extract_opcm_close_decl.F;
T << extract_opcm_close_decl.T;
P << extract_opcm_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_opcm_close_decl_void@
identifier F = opcm_close;
parameter list P;
@@
void F(P);

@script:python depends on extract_opcm_close_decl_void@
F << extract_opcm_close_decl_void.F;
P << extract_opcm_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: opcm_command
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_opcm_command_def@
type T;
identifier F = opcm_command;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_opcm_command_def@
F << remove_static_opcm_command_def.F;
T << remove_static_opcm_command_def.T;
P << remove_static_opcm_command_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_opcm_command_def_void@
identifier F = opcm_command;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_opcm_command_def_void@
F << remove_static_opcm_command_def_void.F;
P << remove_static_opcm_command_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_opcm_command_decl@
type T;
identifier F = opcm_command;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_opcm_command_decl@
F << remove_static_opcm_command_decl.F;
T << remove_static_opcm_command_decl.T;
P << remove_static_opcm_command_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_opcm_command_decl_void@
identifier F = opcm_command;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_opcm_command_decl_void@
F << remove_static_opcm_command_decl_void.F;
P << remove_static_opcm_command_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_opcm_command_def@
type T;
identifier F = opcm_command;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_opcm_command_def@
F << extract_opcm_command_def.F;
T << extract_opcm_command_def.T;
P << extract_opcm_command_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_opcm_command_def_void@
identifier F = opcm_command;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_opcm_command_def_void@
F << extract_opcm_command_def_void.F;
P << extract_opcm_command_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_opcm_command_decl@
type T;
identifier F = opcm_command;
parameter list P;
@@
T F(P);

@script:python depends on extract_opcm_command_decl@
F << extract_opcm_command_decl.F;
T << extract_opcm_command_decl.T;
P << extract_opcm_command_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_opcm_command_decl_void@
identifier F = opcm_command;
parameter list P;
@@
void F(P);

@script:python depends on extract_opcm_command_decl_void@
F << extract_opcm_command_decl_void.F;
P << extract_opcm_command_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: opcm_read_d
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_opcm_read_d_def@
type T;
identifier F = opcm_read_d;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_opcm_read_d_def@
F << remove_static_opcm_read_d_def.F;
T << remove_static_opcm_read_d_def.T;
P << remove_static_opcm_read_d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_opcm_read_d_def_void@
identifier F = opcm_read_d;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_opcm_read_d_def_void@
F << remove_static_opcm_read_d_def_void.F;
P << remove_static_opcm_read_d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_opcm_read_d_decl@
type T;
identifier F = opcm_read_d;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_opcm_read_d_decl@
F << remove_static_opcm_read_d_decl.F;
T << remove_static_opcm_read_d_decl.T;
P << remove_static_opcm_read_d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_opcm_read_d_decl_void@
identifier F = opcm_read_d;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_opcm_read_d_decl_void@
F << remove_static_opcm_read_d_decl_void.F;
P << remove_static_opcm_read_d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_opcm_read_d_def@
type T;
identifier F = opcm_read_d;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_opcm_read_d_def@
F << extract_opcm_read_d_def.F;
T << extract_opcm_read_d_def.T;
P << extract_opcm_read_d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_opcm_read_d_def_void@
identifier F = opcm_read_d;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_opcm_read_d_def_void@
F << extract_opcm_read_d_def_void.F;
P << extract_opcm_read_d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_opcm_read_d_decl@
type T;
identifier F = opcm_read_d;
parameter list P;
@@
T F(P);

@script:python depends on extract_opcm_read_d_decl@
F << extract_opcm_read_d_decl.F;
T << extract_opcm_read_d_decl.T;
P << extract_opcm_read_d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_opcm_read_d_decl_void@
identifier F = opcm_read_d;
parameter list P;
@@
void F(P);

@script:python depends on extract_opcm_read_d_decl_void@
F << extract_opcm_read_d_decl_void.F;
P << extract_opcm_read_d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: opcm_read_f
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_opcm_read_f_def@
type T;
identifier F = opcm_read_f;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_opcm_read_f_def@
F << remove_static_opcm_read_f_def.F;
T << remove_static_opcm_read_f_def.T;
P << remove_static_opcm_read_f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_opcm_read_f_def_void@
identifier F = opcm_read_f;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_opcm_read_f_def_void@
F << remove_static_opcm_read_f_def_void.F;
P << remove_static_opcm_read_f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_opcm_read_f_decl@
type T;
identifier F = opcm_read_f;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_opcm_read_f_decl@
F << remove_static_opcm_read_f_decl.F;
T << remove_static_opcm_read_f_decl.T;
P << remove_static_opcm_read_f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_opcm_read_f_decl_void@
identifier F = opcm_read_f;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_opcm_read_f_decl_void@
F << remove_static_opcm_read_f_decl_void.F;
P << remove_static_opcm_read_f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_opcm_read_f_def@
type T;
identifier F = opcm_read_f;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_opcm_read_f_def@
F << extract_opcm_read_f_def.F;
T << extract_opcm_read_f_def.T;
P << extract_opcm_read_f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_opcm_read_f_def_void@
identifier F = opcm_read_f;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_opcm_read_f_def_void@
F << extract_opcm_read_f_def_void.F;
P << extract_opcm_read_f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_opcm_read_f_decl@
type T;
identifier F = opcm_read_f;
parameter list P;
@@
T F(P);

@script:python depends on extract_opcm_read_f_decl@
F << extract_opcm_read_f_decl.F;
T << extract_opcm_read_f_decl.T;
P << extract_opcm_read_f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_opcm_read_f_decl_void@
identifier F = opcm_read_f;
parameter list P;
@@
void F(P);

@script:python depends on extract_opcm_read_f_decl_void@
F << extract_opcm_read_f_decl_void.F;
P << extract_opcm_read_f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: opcm_read_i
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_opcm_read_i_def@
type T;
identifier F = opcm_read_i;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_opcm_read_i_def@
F << remove_static_opcm_read_i_def.F;
T << remove_static_opcm_read_i_def.T;
P << remove_static_opcm_read_i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_opcm_read_i_def_void@
identifier F = opcm_read_i;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_opcm_read_i_def_void@
F << remove_static_opcm_read_i_def_void.F;
P << remove_static_opcm_read_i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_opcm_read_i_decl@
type T;
identifier F = opcm_read_i;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_opcm_read_i_decl@
F << remove_static_opcm_read_i_decl.F;
T << remove_static_opcm_read_i_decl.T;
P << remove_static_opcm_read_i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_opcm_read_i_decl_void@
identifier F = opcm_read_i;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_opcm_read_i_decl_void@
F << remove_static_opcm_read_i_decl_void.F;
P << remove_static_opcm_read_i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_opcm_read_i_def@
type T;
identifier F = opcm_read_i;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_opcm_read_i_def@
F << extract_opcm_read_i_def.F;
T << extract_opcm_read_i_def.T;
P << extract_opcm_read_i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_opcm_read_i_def_void@
identifier F = opcm_read_i;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_opcm_read_i_def_void@
F << extract_opcm_read_i_def_void.F;
P << extract_opcm_read_i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_opcm_read_i_decl@
type T;
identifier F = opcm_read_i;
parameter list P;
@@
T F(P);

@script:python depends on extract_opcm_read_i_decl@
F << extract_opcm_read_i_decl.F;
T << extract_opcm_read_i_decl.T;
P << extract_opcm_read_i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_opcm_read_i_decl_void@
identifier F = opcm_read_i;
parameter list P;
@@
void F(P);

@script:python depends on extract_opcm_read_i_decl_void@
F << extract_opcm_read_i_decl_void.F;
P << extract_opcm_read_i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: opcm_read_s
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_opcm_read_s_def@
type T;
identifier F = opcm_read_s;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_opcm_read_s_def@
F << remove_static_opcm_read_s_def.F;
T << remove_static_opcm_read_s_def.T;
P << remove_static_opcm_read_s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_opcm_read_s_def_void@
identifier F = opcm_read_s;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_opcm_read_s_def_void@
F << remove_static_opcm_read_s_def_void.F;
P << remove_static_opcm_read_s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_opcm_read_s_decl@
type T;
identifier F = opcm_read_s;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_opcm_read_s_decl@
F << remove_static_opcm_read_s_decl.F;
T << remove_static_opcm_read_s_decl.T;
P << remove_static_opcm_read_s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_opcm_read_s_decl_void@
identifier F = opcm_read_s;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_opcm_read_s_decl_void@
F << remove_static_opcm_read_s_decl_void.F;
P << remove_static_opcm_read_s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_opcm_read_s_def@
type T;
identifier F = opcm_read_s;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_opcm_read_s_def@
F << extract_opcm_read_s_def.F;
T << extract_opcm_read_s_def.T;
P << extract_opcm_read_s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_opcm_read_s_def_void@
identifier F = opcm_read_s;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_opcm_read_s_def_void@
F << extract_opcm_read_s_def_void.F;
P << extract_opcm_read_s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_opcm_read_s_decl@
type T;
identifier F = opcm_read_s;
parameter list P;
@@
T F(P);

@script:python depends on extract_opcm_read_s_decl@
F << extract_opcm_read_s_decl.F;
T << extract_opcm_read_s_decl.T;
P << extract_opcm_read_s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_opcm_read_s_decl_void@
identifier F = opcm_read_s;
parameter list P;
@@
void F(P);

@script:python depends on extract_opcm_read_s_decl_void@
F << extract_opcm_read_s_decl_void.F;
P << extract_opcm_read_s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: opcm_seek
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_opcm_seek_def@
type T;
identifier F = opcm_seek;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_opcm_seek_def@
F << remove_static_opcm_seek_def.F;
T << remove_static_opcm_seek_def.T;
P << remove_static_opcm_seek_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_opcm_seek_def_void@
identifier F = opcm_seek;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_opcm_seek_def_void@
F << remove_static_opcm_seek_def_void.F;
P << remove_static_opcm_seek_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_opcm_seek_decl@
type T;
identifier F = opcm_seek;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_opcm_seek_decl@
F << remove_static_opcm_seek_decl.F;
T << remove_static_opcm_seek_decl.T;
P << remove_static_opcm_seek_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_opcm_seek_decl_void@
identifier F = opcm_seek;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_opcm_seek_decl_void@
F << remove_static_opcm_seek_decl_void.F;
P << remove_static_opcm_seek_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_opcm_seek_def@
type T;
identifier F = opcm_seek;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_opcm_seek_def@
F << extract_opcm_seek_def.F;
T << extract_opcm_seek_def.T;
P << extract_opcm_seek_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_opcm_seek_def_void@
identifier F = opcm_seek;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_opcm_seek_def_void@
F << extract_opcm_seek_def_void.F;
P << extract_opcm_seek_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_opcm_seek_decl@
type T;
identifier F = opcm_seek;
parameter list P;
@@
T F(P);

@script:python depends on extract_opcm_seek_decl@
F << extract_opcm_seek_decl.F;
T << extract_opcm_seek_decl.T;
P << extract_opcm_seek_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_opcm_seek_decl_void@
identifier F = opcm_seek;
parameter list P;
@@
void F(P);

@script:python depends on extract_opcm_seek_decl_void@
F << extract_opcm_seek_decl_void.F;
P << extract_opcm_seek_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: opcm_write_d
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_opcm_write_d_def@
type T;
identifier F = opcm_write_d;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_opcm_write_d_def@
F << remove_static_opcm_write_d_def.F;
T << remove_static_opcm_write_d_def.T;
P << remove_static_opcm_write_d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_opcm_write_d_def_void@
identifier F = opcm_write_d;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_opcm_write_d_def_void@
F << remove_static_opcm_write_d_def_void.F;
P << remove_static_opcm_write_d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_opcm_write_d_decl@
type T;
identifier F = opcm_write_d;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_opcm_write_d_decl@
F << remove_static_opcm_write_d_decl.F;
T << remove_static_opcm_write_d_decl.T;
P << remove_static_opcm_write_d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_opcm_write_d_decl_void@
identifier F = opcm_write_d;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_opcm_write_d_decl_void@
F << remove_static_opcm_write_d_decl_void.F;
P << remove_static_opcm_write_d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_opcm_write_d_def@
type T;
identifier F = opcm_write_d;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_opcm_write_d_def@
F << extract_opcm_write_d_def.F;
T << extract_opcm_write_d_def.T;
P << extract_opcm_write_d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_opcm_write_d_def_void@
identifier F = opcm_write_d;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_opcm_write_d_def_void@
F << extract_opcm_write_d_def_void.F;
P << extract_opcm_write_d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_opcm_write_d_decl@
type T;
identifier F = opcm_write_d;
parameter list P;
@@
T F(P);

@script:python depends on extract_opcm_write_d_decl@
F << extract_opcm_write_d_decl.F;
T << extract_opcm_write_d_decl.T;
P << extract_opcm_write_d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_opcm_write_d_decl_void@
identifier F = opcm_write_d;
parameter list P;
@@
void F(P);

@script:python depends on extract_opcm_write_d_decl_void@
F << extract_opcm_write_d_decl_void.F;
P << extract_opcm_write_d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: opcm_write_f
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_opcm_write_f_def@
type T;
identifier F = opcm_write_f;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_opcm_write_f_def@
F << remove_static_opcm_write_f_def.F;
T << remove_static_opcm_write_f_def.T;
P << remove_static_opcm_write_f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_opcm_write_f_def_void@
identifier F = opcm_write_f;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_opcm_write_f_def_void@
F << remove_static_opcm_write_f_def_void.F;
P << remove_static_opcm_write_f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_opcm_write_f_decl@
type T;
identifier F = opcm_write_f;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_opcm_write_f_decl@
F << remove_static_opcm_write_f_decl.F;
T << remove_static_opcm_write_f_decl.T;
P << remove_static_opcm_write_f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_opcm_write_f_decl_void@
identifier F = opcm_write_f;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_opcm_write_f_decl_void@
F << remove_static_opcm_write_f_decl_void.F;
P << remove_static_opcm_write_f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_opcm_write_f_def@
type T;
identifier F = opcm_write_f;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_opcm_write_f_def@
F << extract_opcm_write_f_def.F;
T << extract_opcm_write_f_def.T;
P << extract_opcm_write_f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_opcm_write_f_def_void@
identifier F = opcm_write_f;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_opcm_write_f_def_void@
F << extract_opcm_write_f_def_void.F;
P << extract_opcm_write_f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_opcm_write_f_decl@
type T;
identifier F = opcm_write_f;
parameter list P;
@@
T F(P);

@script:python depends on extract_opcm_write_f_decl@
F << extract_opcm_write_f_decl.F;
T << extract_opcm_write_f_decl.T;
P << extract_opcm_write_f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_opcm_write_f_decl_void@
identifier F = opcm_write_f;
parameter list P;
@@
void F(P);

@script:python depends on extract_opcm_write_f_decl_void@
F << extract_opcm_write_f_decl_void.F;
P << extract_opcm_write_f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: opcm_write_header
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_opcm_write_header_def@
type T;
identifier F = opcm_write_header;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_opcm_write_header_def@
F << remove_static_opcm_write_header_def.F;
T << remove_static_opcm_write_header_def.T;
P << remove_static_opcm_write_header_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_opcm_write_header_def_void@
identifier F = opcm_write_header;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_opcm_write_header_def_void@
F << remove_static_opcm_write_header_def_void.F;
P << remove_static_opcm_write_header_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_opcm_write_header_decl@
type T;
identifier F = opcm_write_header;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_opcm_write_header_decl@
F << remove_static_opcm_write_header_decl.F;
T << remove_static_opcm_write_header_decl.T;
P << remove_static_opcm_write_header_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_opcm_write_header_decl_void@
identifier F = opcm_write_header;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_opcm_write_header_decl_void@
F << remove_static_opcm_write_header_decl_void.F;
P << remove_static_opcm_write_header_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_opcm_write_header_def@
type T;
identifier F = opcm_write_header;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_opcm_write_header_def@
F << extract_opcm_write_header_def.F;
T << extract_opcm_write_header_def.T;
P << extract_opcm_write_header_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_opcm_write_header_def_void@
identifier F = opcm_write_header;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_opcm_write_header_def_void@
F << extract_opcm_write_header_def_void.F;
P << extract_opcm_write_header_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_opcm_write_header_decl@
type T;
identifier F = opcm_write_header;
parameter list P;
@@
T F(P);

@script:python depends on extract_opcm_write_header_decl@
F << extract_opcm_write_header_decl.F;
T << extract_opcm_write_header_decl.T;
P << extract_opcm_write_header_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_opcm_write_header_decl_void@
identifier F = opcm_write_header;
parameter list P;
@@
void F(P);

@script:python depends on extract_opcm_write_header_decl_void@
F << extract_opcm_write_header_decl_void.F;
P << extract_opcm_write_header_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: opcm_write_i
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_opcm_write_i_def@
type T;
identifier F = opcm_write_i;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_opcm_write_i_def@
F << remove_static_opcm_write_i_def.F;
T << remove_static_opcm_write_i_def.T;
P << remove_static_opcm_write_i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_opcm_write_i_def_void@
identifier F = opcm_write_i;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_opcm_write_i_def_void@
F << remove_static_opcm_write_i_def_void.F;
P << remove_static_opcm_write_i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_opcm_write_i_decl@
type T;
identifier F = opcm_write_i;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_opcm_write_i_decl@
F << remove_static_opcm_write_i_decl.F;
T << remove_static_opcm_write_i_decl.T;
P << remove_static_opcm_write_i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_opcm_write_i_decl_void@
identifier F = opcm_write_i;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_opcm_write_i_decl_void@
F << remove_static_opcm_write_i_decl_void.F;
P << remove_static_opcm_write_i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_opcm_write_i_def@
type T;
identifier F = opcm_write_i;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_opcm_write_i_def@
F << extract_opcm_write_i_def.F;
T << extract_opcm_write_i_def.T;
P << extract_opcm_write_i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_opcm_write_i_def_void@
identifier F = opcm_write_i;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_opcm_write_i_def_void@
F << extract_opcm_write_i_def_void.F;
P << extract_opcm_write_i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_opcm_write_i_decl@
type T;
identifier F = opcm_write_i;
parameter list P;
@@
T F(P);

@script:python depends on extract_opcm_write_i_decl@
F << extract_opcm_write_i_decl.F;
T << extract_opcm_write_i_decl.T;
P << extract_opcm_write_i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_opcm_write_i_decl_void@
identifier F = opcm_write_i;
parameter list P;
@@
void F(P);

@script:python depends on extract_opcm_write_i_decl_void@
F << extract_opcm_write_i_decl_void.F;
P << extract_opcm_write_i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: opcm_write_s
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_opcm_write_s_def@
type T;
identifier F = opcm_write_s;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_opcm_write_s_def@
F << remove_static_opcm_write_s_def.F;
T << remove_static_opcm_write_s_def.T;
P << remove_static_opcm_write_s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_opcm_write_s_def_void@
identifier F = opcm_write_s;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_opcm_write_s_def_void@
F << remove_static_opcm_write_s_def_void.F;
P << remove_static_opcm_write_s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_opcm_write_s_decl@
type T;
identifier F = opcm_write_s;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_opcm_write_s_decl@
F << remove_static_opcm_write_s_decl.F;
T << remove_static_opcm_write_s_decl.T;
P << remove_static_opcm_write_s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_opcm_write_s_decl_void@
identifier F = opcm_write_s;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_opcm_write_s_decl_void@
F << remove_static_opcm_write_s_decl_void.F;
P << remove_static_opcm_write_s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_opcm_write_s_def@
type T;
identifier F = opcm_write_s;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_opcm_write_s_def@
F << extract_opcm_write_s_def.F;
T << extract_opcm_write_s_def.T;
P << extract_opcm_write_s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_opcm_write_s_def_void@
identifier F = opcm_write_s;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_opcm_write_s_def_void@
F << extract_opcm_write_s_def_void.F;
P << extract_opcm_write_s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_opcm_write_s_decl@
type T;
identifier F = opcm_write_s;
parameter list P;
@@
T F(P);

@script:python depends on extract_opcm_write_s_decl@
F << extract_opcm_write_s_decl.F;
T << extract_opcm_write_s_decl.T;
P << extract_opcm_write_s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_opcm_write_s_decl_void@
identifier F = opcm_write_s;
parameter list P;
@@
void F(P);

@script:python depends on extract_opcm_write_s_decl_void@
F << extract_opcm_write_s_decl_void.F;
P << extract_opcm_write_s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: paf24_close
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_paf24_close_def@
type T;
identifier F = paf24_close;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_paf24_close_def@
F << remove_static_paf24_close_def.F;
T << remove_static_paf24_close_def.T;
P << remove_static_paf24_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_paf24_close_def_void@
identifier F = paf24_close;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_paf24_close_def_void@
F << remove_static_paf24_close_def_void.F;
P << remove_static_paf24_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_paf24_close_decl@
type T;
identifier F = paf24_close;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_paf24_close_decl@
F << remove_static_paf24_close_decl.F;
T << remove_static_paf24_close_decl.T;
P << remove_static_paf24_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_paf24_close_decl_void@
identifier F = paf24_close;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_paf24_close_decl_void@
F << remove_static_paf24_close_decl_void.F;
P << remove_static_paf24_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_paf24_close_def@
type T;
identifier F = paf24_close;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_paf24_close_def@
F << extract_paf24_close_def.F;
T << extract_paf24_close_def.T;
P << extract_paf24_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_paf24_close_def_void@
identifier F = paf24_close;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_paf24_close_def_void@
F << extract_paf24_close_def_void.F;
P << extract_paf24_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_paf24_close_decl@
type T;
identifier F = paf24_close;
parameter list P;
@@
T F(P);

@script:python depends on extract_paf24_close_decl@
F << extract_paf24_close_decl.F;
T << extract_paf24_close_decl.T;
P << extract_paf24_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_paf24_close_decl_void@
identifier F = paf24_close;
parameter list P;
@@
void F(P);

@script:python depends on extract_paf24_close_decl_void@
F << extract_paf24_close_decl_void.F;
P << extract_paf24_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: paf24_read_d
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_paf24_read_d_def@
type T;
identifier F = paf24_read_d;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_paf24_read_d_def@
F << remove_static_paf24_read_d_def.F;
T << remove_static_paf24_read_d_def.T;
P << remove_static_paf24_read_d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_paf24_read_d_def_void@
identifier F = paf24_read_d;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_paf24_read_d_def_void@
F << remove_static_paf24_read_d_def_void.F;
P << remove_static_paf24_read_d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_paf24_read_d_decl@
type T;
identifier F = paf24_read_d;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_paf24_read_d_decl@
F << remove_static_paf24_read_d_decl.F;
T << remove_static_paf24_read_d_decl.T;
P << remove_static_paf24_read_d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_paf24_read_d_decl_void@
identifier F = paf24_read_d;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_paf24_read_d_decl_void@
F << remove_static_paf24_read_d_decl_void.F;
P << remove_static_paf24_read_d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_paf24_read_d_def@
type T;
identifier F = paf24_read_d;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_paf24_read_d_def@
F << extract_paf24_read_d_def.F;
T << extract_paf24_read_d_def.T;
P << extract_paf24_read_d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_paf24_read_d_def_void@
identifier F = paf24_read_d;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_paf24_read_d_def_void@
F << extract_paf24_read_d_def_void.F;
P << extract_paf24_read_d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_paf24_read_d_decl@
type T;
identifier F = paf24_read_d;
parameter list P;
@@
T F(P);

@script:python depends on extract_paf24_read_d_decl@
F << extract_paf24_read_d_decl.F;
T << extract_paf24_read_d_decl.T;
P << extract_paf24_read_d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_paf24_read_d_decl_void@
identifier F = paf24_read_d;
parameter list P;
@@
void F(P);

@script:python depends on extract_paf24_read_d_decl_void@
F << extract_paf24_read_d_decl_void.F;
P << extract_paf24_read_d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: paf24_read_f
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_paf24_read_f_def@
type T;
identifier F = paf24_read_f;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_paf24_read_f_def@
F << remove_static_paf24_read_f_def.F;
T << remove_static_paf24_read_f_def.T;
P << remove_static_paf24_read_f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_paf24_read_f_def_void@
identifier F = paf24_read_f;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_paf24_read_f_def_void@
F << remove_static_paf24_read_f_def_void.F;
P << remove_static_paf24_read_f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_paf24_read_f_decl@
type T;
identifier F = paf24_read_f;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_paf24_read_f_decl@
F << remove_static_paf24_read_f_decl.F;
T << remove_static_paf24_read_f_decl.T;
P << remove_static_paf24_read_f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_paf24_read_f_decl_void@
identifier F = paf24_read_f;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_paf24_read_f_decl_void@
F << remove_static_paf24_read_f_decl_void.F;
P << remove_static_paf24_read_f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_paf24_read_f_def@
type T;
identifier F = paf24_read_f;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_paf24_read_f_def@
F << extract_paf24_read_f_def.F;
T << extract_paf24_read_f_def.T;
P << extract_paf24_read_f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_paf24_read_f_def_void@
identifier F = paf24_read_f;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_paf24_read_f_def_void@
F << extract_paf24_read_f_def_void.F;
P << extract_paf24_read_f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_paf24_read_f_decl@
type T;
identifier F = paf24_read_f;
parameter list P;
@@
T F(P);

@script:python depends on extract_paf24_read_f_decl@
F << extract_paf24_read_f_decl.F;
T << extract_paf24_read_f_decl.T;
P << extract_paf24_read_f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_paf24_read_f_decl_void@
identifier F = paf24_read_f;
parameter list P;
@@
void F(P);

@script:python depends on extract_paf24_read_f_decl_void@
F << extract_paf24_read_f_decl_void.F;
P << extract_paf24_read_f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: paf24_read_i
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_paf24_read_i_def@
type T;
identifier F = paf24_read_i;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_paf24_read_i_def@
F << remove_static_paf24_read_i_def.F;
T << remove_static_paf24_read_i_def.T;
P << remove_static_paf24_read_i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_paf24_read_i_def_void@
identifier F = paf24_read_i;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_paf24_read_i_def_void@
F << remove_static_paf24_read_i_def_void.F;
P << remove_static_paf24_read_i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_paf24_read_i_decl@
type T;
identifier F = paf24_read_i;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_paf24_read_i_decl@
F << remove_static_paf24_read_i_decl.F;
T << remove_static_paf24_read_i_decl.T;
P << remove_static_paf24_read_i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_paf24_read_i_decl_void@
identifier F = paf24_read_i;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_paf24_read_i_decl_void@
F << remove_static_paf24_read_i_decl_void.F;
P << remove_static_paf24_read_i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_paf24_read_i_def@
type T;
identifier F = paf24_read_i;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_paf24_read_i_def@
F << extract_paf24_read_i_def.F;
T << extract_paf24_read_i_def.T;
P << extract_paf24_read_i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_paf24_read_i_def_void@
identifier F = paf24_read_i;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_paf24_read_i_def_void@
F << extract_paf24_read_i_def_void.F;
P << extract_paf24_read_i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_paf24_read_i_decl@
type T;
identifier F = paf24_read_i;
parameter list P;
@@
T F(P);

@script:python depends on extract_paf24_read_i_decl@
F << extract_paf24_read_i_decl.F;
T << extract_paf24_read_i_decl.T;
P << extract_paf24_read_i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_paf24_read_i_decl_void@
identifier F = paf24_read_i;
parameter list P;
@@
void F(P);

@script:python depends on extract_paf24_read_i_decl_void@
F << extract_paf24_read_i_decl_void.F;
P << extract_paf24_read_i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: paf24_read_s
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_paf24_read_s_def@
type T;
identifier F = paf24_read_s;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_paf24_read_s_def@
F << remove_static_paf24_read_s_def.F;
T << remove_static_paf24_read_s_def.T;
P << remove_static_paf24_read_s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_paf24_read_s_def_void@
identifier F = paf24_read_s;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_paf24_read_s_def_void@
F << remove_static_paf24_read_s_def_void.F;
P << remove_static_paf24_read_s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_paf24_read_s_decl@
type T;
identifier F = paf24_read_s;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_paf24_read_s_decl@
F << remove_static_paf24_read_s_decl.F;
T << remove_static_paf24_read_s_decl.T;
P << remove_static_paf24_read_s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_paf24_read_s_decl_void@
identifier F = paf24_read_s;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_paf24_read_s_decl_void@
F << remove_static_paf24_read_s_decl_void.F;
P << remove_static_paf24_read_s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_paf24_read_s_def@
type T;
identifier F = paf24_read_s;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_paf24_read_s_def@
F << extract_paf24_read_s_def.F;
T << extract_paf24_read_s_def.T;
P << extract_paf24_read_s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_paf24_read_s_def_void@
identifier F = paf24_read_s;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_paf24_read_s_def_void@
F << extract_paf24_read_s_def_void.F;
P << extract_paf24_read_s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_paf24_read_s_decl@
type T;
identifier F = paf24_read_s;
parameter list P;
@@
T F(P);

@script:python depends on extract_paf24_read_s_decl@
F << extract_paf24_read_s_decl.F;
T << extract_paf24_read_s_decl.T;
P << extract_paf24_read_s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_paf24_read_s_decl_void@
identifier F = paf24_read_s;
parameter list P;
@@
void F(P);

@script:python depends on extract_paf24_read_s_decl_void@
F << extract_paf24_read_s_decl_void.F;
P << extract_paf24_read_s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: paf24_seek
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_paf24_seek_def@
type T;
identifier F = paf24_seek;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_paf24_seek_def@
F << remove_static_paf24_seek_def.F;
T << remove_static_paf24_seek_def.T;
P << remove_static_paf24_seek_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_paf24_seek_def_void@
identifier F = paf24_seek;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_paf24_seek_def_void@
F << remove_static_paf24_seek_def_void.F;
P << remove_static_paf24_seek_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_paf24_seek_decl@
type T;
identifier F = paf24_seek;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_paf24_seek_decl@
F << remove_static_paf24_seek_decl.F;
T << remove_static_paf24_seek_decl.T;
P << remove_static_paf24_seek_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_paf24_seek_decl_void@
identifier F = paf24_seek;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_paf24_seek_decl_void@
F << remove_static_paf24_seek_decl_void.F;
P << remove_static_paf24_seek_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_paf24_seek_def@
type T;
identifier F = paf24_seek;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_paf24_seek_def@
F << extract_paf24_seek_def.F;
T << extract_paf24_seek_def.T;
P << extract_paf24_seek_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_paf24_seek_def_void@
identifier F = paf24_seek;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_paf24_seek_def_void@
F << extract_paf24_seek_def_void.F;
P << extract_paf24_seek_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_paf24_seek_decl@
type T;
identifier F = paf24_seek;
parameter list P;
@@
T F(P);

@script:python depends on extract_paf24_seek_decl@
F << extract_paf24_seek_decl.F;
T << extract_paf24_seek_decl.T;
P << extract_paf24_seek_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_paf24_seek_decl_void@
identifier F = paf24_seek;
parameter list P;
@@
void F(P);

@script:python depends on extract_paf24_seek_decl_void@
F << extract_paf24_seek_decl_void.F;
P << extract_paf24_seek_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: paf24_write_d
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_paf24_write_d_def@
type T;
identifier F = paf24_write_d;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_paf24_write_d_def@
F << remove_static_paf24_write_d_def.F;
T << remove_static_paf24_write_d_def.T;
P << remove_static_paf24_write_d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_paf24_write_d_def_void@
identifier F = paf24_write_d;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_paf24_write_d_def_void@
F << remove_static_paf24_write_d_def_void.F;
P << remove_static_paf24_write_d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_paf24_write_d_decl@
type T;
identifier F = paf24_write_d;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_paf24_write_d_decl@
F << remove_static_paf24_write_d_decl.F;
T << remove_static_paf24_write_d_decl.T;
P << remove_static_paf24_write_d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_paf24_write_d_decl_void@
identifier F = paf24_write_d;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_paf24_write_d_decl_void@
F << remove_static_paf24_write_d_decl_void.F;
P << remove_static_paf24_write_d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_paf24_write_d_def@
type T;
identifier F = paf24_write_d;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_paf24_write_d_def@
F << extract_paf24_write_d_def.F;
T << extract_paf24_write_d_def.T;
P << extract_paf24_write_d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_paf24_write_d_def_void@
identifier F = paf24_write_d;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_paf24_write_d_def_void@
F << extract_paf24_write_d_def_void.F;
P << extract_paf24_write_d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_paf24_write_d_decl@
type T;
identifier F = paf24_write_d;
parameter list P;
@@
T F(P);

@script:python depends on extract_paf24_write_d_decl@
F << extract_paf24_write_d_decl.F;
T << extract_paf24_write_d_decl.T;
P << extract_paf24_write_d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_paf24_write_d_decl_void@
identifier F = paf24_write_d;
parameter list P;
@@
void F(P);

@script:python depends on extract_paf24_write_d_decl_void@
F << extract_paf24_write_d_decl_void.F;
P << extract_paf24_write_d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: paf24_write_f
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_paf24_write_f_def@
type T;
identifier F = paf24_write_f;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_paf24_write_f_def@
F << remove_static_paf24_write_f_def.F;
T << remove_static_paf24_write_f_def.T;
P << remove_static_paf24_write_f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_paf24_write_f_def_void@
identifier F = paf24_write_f;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_paf24_write_f_def_void@
F << remove_static_paf24_write_f_def_void.F;
P << remove_static_paf24_write_f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_paf24_write_f_decl@
type T;
identifier F = paf24_write_f;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_paf24_write_f_decl@
F << remove_static_paf24_write_f_decl.F;
T << remove_static_paf24_write_f_decl.T;
P << remove_static_paf24_write_f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_paf24_write_f_decl_void@
identifier F = paf24_write_f;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_paf24_write_f_decl_void@
F << remove_static_paf24_write_f_decl_void.F;
P << remove_static_paf24_write_f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_paf24_write_f_def@
type T;
identifier F = paf24_write_f;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_paf24_write_f_def@
F << extract_paf24_write_f_def.F;
T << extract_paf24_write_f_def.T;
P << extract_paf24_write_f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_paf24_write_f_def_void@
identifier F = paf24_write_f;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_paf24_write_f_def_void@
F << extract_paf24_write_f_def_void.F;
P << extract_paf24_write_f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_paf24_write_f_decl@
type T;
identifier F = paf24_write_f;
parameter list P;
@@
T F(P);

@script:python depends on extract_paf24_write_f_decl@
F << extract_paf24_write_f_decl.F;
T << extract_paf24_write_f_decl.T;
P << extract_paf24_write_f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_paf24_write_f_decl_void@
identifier F = paf24_write_f;
parameter list P;
@@
void F(P);

@script:python depends on extract_paf24_write_f_decl_void@
F << extract_paf24_write_f_decl_void.F;
P << extract_paf24_write_f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: paf24_write_i
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_paf24_write_i_def@
type T;
identifier F = paf24_write_i;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_paf24_write_i_def@
F << remove_static_paf24_write_i_def.F;
T << remove_static_paf24_write_i_def.T;
P << remove_static_paf24_write_i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_paf24_write_i_def_void@
identifier F = paf24_write_i;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_paf24_write_i_def_void@
F << remove_static_paf24_write_i_def_void.F;
P << remove_static_paf24_write_i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_paf24_write_i_decl@
type T;
identifier F = paf24_write_i;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_paf24_write_i_decl@
F << remove_static_paf24_write_i_decl.F;
T << remove_static_paf24_write_i_decl.T;
P << remove_static_paf24_write_i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_paf24_write_i_decl_void@
identifier F = paf24_write_i;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_paf24_write_i_decl_void@
F << remove_static_paf24_write_i_decl_void.F;
P << remove_static_paf24_write_i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_paf24_write_i_def@
type T;
identifier F = paf24_write_i;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_paf24_write_i_def@
F << extract_paf24_write_i_def.F;
T << extract_paf24_write_i_def.T;
P << extract_paf24_write_i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_paf24_write_i_def_void@
identifier F = paf24_write_i;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_paf24_write_i_def_void@
F << extract_paf24_write_i_def_void.F;
P << extract_paf24_write_i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_paf24_write_i_decl@
type T;
identifier F = paf24_write_i;
parameter list P;
@@
T F(P);

@script:python depends on extract_paf24_write_i_decl@
F << extract_paf24_write_i_decl.F;
T << extract_paf24_write_i_decl.T;
P << extract_paf24_write_i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_paf24_write_i_decl_void@
identifier F = paf24_write_i;
parameter list P;
@@
void F(P);

@script:python depends on extract_paf24_write_i_decl_void@
F << extract_paf24_write_i_decl_void.F;
P << extract_paf24_write_i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: paf24_write_s
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_paf24_write_s_def@
type T;
identifier F = paf24_write_s;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_paf24_write_s_def@
F << remove_static_paf24_write_s_def.F;
T << remove_static_paf24_write_s_def.T;
P << remove_static_paf24_write_s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_paf24_write_s_def_void@
identifier F = paf24_write_s;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_paf24_write_s_def_void@
F << remove_static_paf24_write_s_def_void.F;
P << remove_static_paf24_write_s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_paf24_write_s_decl@
type T;
identifier F = paf24_write_s;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_paf24_write_s_decl@
F << remove_static_paf24_write_s_decl.F;
T << remove_static_paf24_write_s_decl.T;
P << remove_static_paf24_write_s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_paf24_write_s_decl_void@
identifier F = paf24_write_s;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_paf24_write_s_decl_void@
F << remove_static_paf24_write_s_decl_void.F;
P << remove_static_paf24_write_s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_paf24_write_s_def@
type T;
identifier F = paf24_write_s;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_paf24_write_s_def@
F << extract_paf24_write_s_def.F;
T << extract_paf24_write_s_def.T;
P << extract_paf24_write_s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_paf24_write_s_def_void@
identifier F = paf24_write_s;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_paf24_write_s_def_void@
F << extract_paf24_write_s_def_void.F;
P << extract_paf24_write_s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_paf24_write_s_decl@
type T;
identifier F = paf24_write_s;
parameter list P;
@@
T F(P);

@script:python depends on extract_paf24_write_s_decl@
F << extract_paf24_write_s_decl.F;
T << extract_paf24_write_s_decl.T;
P << extract_paf24_write_s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_paf24_write_s_decl_void@
identifier F = paf24_write_s;
parameter list P;
@@
void F(P);

@script:python depends on extract_paf24_write_s_decl_void@
F << extract_paf24_write_s_decl_void.F;
P << extract_paf24_write_s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: paf_write_header
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_paf_write_header_def@
type T;
identifier F = paf_write_header;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_paf_write_header_def@
F << remove_static_paf_write_header_def.F;
T << remove_static_paf_write_header_def.T;
P << remove_static_paf_write_header_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_paf_write_header_def_void@
identifier F = paf_write_header;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_paf_write_header_def_void@
F << remove_static_paf_write_header_def_void.F;
P << remove_static_paf_write_header_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_paf_write_header_decl@
type T;
identifier F = paf_write_header;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_paf_write_header_decl@
F << remove_static_paf_write_header_decl.F;
T << remove_static_paf_write_header_decl.T;
P << remove_static_paf_write_header_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_paf_write_header_decl_void@
identifier F = paf_write_header;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_paf_write_header_decl_void@
F << remove_static_paf_write_header_decl_void.F;
P << remove_static_paf_write_header_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_paf_write_header_def@
type T;
identifier F = paf_write_header;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_paf_write_header_def@
F << extract_paf_write_header_def.F;
T << extract_paf_write_header_def.T;
P << extract_paf_write_header_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_paf_write_header_def_void@
identifier F = paf_write_header;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_paf_write_header_def_void@
F << extract_paf_write_header_def_void.F;
P << extract_paf_write_header_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_paf_write_header_decl@
type T;
identifier F = paf_write_header;
parameter list P;
@@
T F(P);

@script:python depends on extract_paf_write_header_decl@
F << extract_paf_write_header_decl.F;
T << extract_paf_write_header_decl.T;
P << extract_paf_write_header_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_paf_write_header_decl_void@
identifier F = paf_write_header;
parameter list P;
@@
void F(P);

@script:python depends on extract_paf_write_header_decl_void@
F << extract_paf_write_header_decl_void.F;
P << extract_paf_write_header_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: pcm_read_bei2d
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_pcm_read_bei2d_def@
type T;
identifier F = pcm_read_bei2d;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_pcm_read_bei2d_def@
F << remove_static_pcm_read_bei2d_def.F;
T << remove_static_pcm_read_bei2d_def.T;
P << remove_static_pcm_read_bei2d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_pcm_read_bei2d_def_void@
identifier F = pcm_read_bei2d;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_pcm_read_bei2d_def_void@
F << remove_static_pcm_read_bei2d_def_void.F;
P << remove_static_pcm_read_bei2d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_pcm_read_bei2d_decl@
type T;
identifier F = pcm_read_bei2d;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_pcm_read_bei2d_decl@
F << remove_static_pcm_read_bei2d_decl.F;
T << remove_static_pcm_read_bei2d_decl.T;
P << remove_static_pcm_read_bei2d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_pcm_read_bei2d_decl_void@
identifier F = pcm_read_bei2d;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_pcm_read_bei2d_decl_void@
F << remove_static_pcm_read_bei2d_decl_void.F;
P << remove_static_pcm_read_bei2d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_pcm_read_bei2d_def@
type T;
identifier F = pcm_read_bei2d;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_pcm_read_bei2d_def@
F << extract_pcm_read_bei2d_def.F;
T << extract_pcm_read_bei2d_def.T;
P << extract_pcm_read_bei2d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_pcm_read_bei2d_def_void@
identifier F = pcm_read_bei2d;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_pcm_read_bei2d_def_void@
F << extract_pcm_read_bei2d_def_void.F;
P << extract_pcm_read_bei2d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_pcm_read_bei2d_decl@
type T;
identifier F = pcm_read_bei2d;
parameter list P;
@@
T F(P);

@script:python depends on extract_pcm_read_bei2d_decl@
F << extract_pcm_read_bei2d_decl.F;
T << extract_pcm_read_bei2d_decl.T;
P << extract_pcm_read_bei2d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_pcm_read_bei2d_decl_void@
identifier F = pcm_read_bei2d;
parameter list P;
@@
void F(P);

@script:python depends on extract_pcm_read_bei2d_decl_void@
F << extract_pcm_read_bei2d_decl_void.F;
P << extract_pcm_read_bei2d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: pcm_read_bei2f
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_pcm_read_bei2f_def@
type T;
identifier F = pcm_read_bei2f;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_pcm_read_bei2f_def@
F << remove_static_pcm_read_bei2f_def.F;
T << remove_static_pcm_read_bei2f_def.T;
P << remove_static_pcm_read_bei2f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_pcm_read_bei2f_def_void@
identifier F = pcm_read_bei2f;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_pcm_read_bei2f_def_void@
F << remove_static_pcm_read_bei2f_def_void.F;
P << remove_static_pcm_read_bei2f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_pcm_read_bei2f_decl@
type T;
identifier F = pcm_read_bei2f;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_pcm_read_bei2f_decl@
F << remove_static_pcm_read_bei2f_decl.F;
T << remove_static_pcm_read_bei2f_decl.T;
P << remove_static_pcm_read_bei2f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_pcm_read_bei2f_decl_void@
identifier F = pcm_read_bei2f;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_pcm_read_bei2f_decl_void@
F << remove_static_pcm_read_bei2f_decl_void.F;
P << remove_static_pcm_read_bei2f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_pcm_read_bei2f_def@
type T;
identifier F = pcm_read_bei2f;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_pcm_read_bei2f_def@
F << extract_pcm_read_bei2f_def.F;
T << extract_pcm_read_bei2f_def.T;
P << extract_pcm_read_bei2f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_pcm_read_bei2f_def_void@
identifier F = pcm_read_bei2f;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_pcm_read_bei2f_def_void@
F << extract_pcm_read_bei2f_def_void.F;
P << extract_pcm_read_bei2f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_pcm_read_bei2f_decl@
type T;
identifier F = pcm_read_bei2f;
parameter list P;
@@
T F(P);

@script:python depends on extract_pcm_read_bei2f_decl@
F << extract_pcm_read_bei2f_decl.F;
T << extract_pcm_read_bei2f_decl.T;
P << extract_pcm_read_bei2f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_pcm_read_bei2f_decl_void@
identifier F = pcm_read_bei2f;
parameter list P;
@@
void F(P);

@script:python depends on extract_pcm_read_bei2f_decl_void@
F << extract_pcm_read_bei2f_decl_void.F;
P << extract_pcm_read_bei2f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: pcm_read_bei2i
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_pcm_read_bei2i_def@
type T;
identifier F = pcm_read_bei2i;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_pcm_read_bei2i_def@
F << remove_static_pcm_read_bei2i_def.F;
T << remove_static_pcm_read_bei2i_def.T;
P << remove_static_pcm_read_bei2i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_pcm_read_bei2i_def_void@
identifier F = pcm_read_bei2i;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_pcm_read_bei2i_def_void@
F << remove_static_pcm_read_bei2i_def_void.F;
P << remove_static_pcm_read_bei2i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_pcm_read_bei2i_decl@
type T;
identifier F = pcm_read_bei2i;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_pcm_read_bei2i_decl@
F << remove_static_pcm_read_bei2i_decl.F;
T << remove_static_pcm_read_bei2i_decl.T;
P << remove_static_pcm_read_bei2i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_pcm_read_bei2i_decl_void@
identifier F = pcm_read_bei2i;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_pcm_read_bei2i_decl_void@
F << remove_static_pcm_read_bei2i_decl_void.F;
P << remove_static_pcm_read_bei2i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_pcm_read_bei2i_def@
type T;
identifier F = pcm_read_bei2i;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_pcm_read_bei2i_def@
F << extract_pcm_read_bei2i_def.F;
T << extract_pcm_read_bei2i_def.T;
P << extract_pcm_read_bei2i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_pcm_read_bei2i_def_void@
identifier F = pcm_read_bei2i;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_pcm_read_bei2i_def_void@
F << extract_pcm_read_bei2i_def_void.F;
P << extract_pcm_read_bei2i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_pcm_read_bei2i_decl@
type T;
identifier F = pcm_read_bei2i;
parameter list P;
@@
T F(P);

@script:python depends on extract_pcm_read_bei2i_decl@
F << extract_pcm_read_bei2i_decl.F;
T << extract_pcm_read_bei2i_decl.T;
P << extract_pcm_read_bei2i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_pcm_read_bei2i_decl_void@
identifier F = pcm_read_bei2i;
parameter list P;
@@
void F(P);

@script:python depends on extract_pcm_read_bei2i_decl_void@
F << extract_pcm_read_bei2i_decl_void.F;
P << extract_pcm_read_bei2i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: pcm_read_bei2s
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_pcm_read_bei2s_def@
type T;
identifier F = pcm_read_bei2s;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_pcm_read_bei2s_def@
F << remove_static_pcm_read_bei2s_def.F;
T << remove_static_pcm_read_bei2s_def.T;
P << remove_static_pcm_read_bei2s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_pcm_read_bei2s_def_void@
identifier F = pcm_read_bei2s;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_pcm_read_bei2s_def_void@
F << remove_static_pcm_read_bei2s_def_void.F;
P << remove_static_pcm_read_bei2s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_pcm_read_bei2s_decl@
type T;
identifier F = pcm_read_bei2s;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_pcm_read_bei2s_decl@
F << remove_static_pcm_read_bei2s_decl.F;
T << remove_static_pcm_read_bei2s_decl.T;
P << remove_static_pcm_read_bei2s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_pcm_read_bei2s_decl_void@
identifier F = pcm_read_bei2s;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_pcm_read_bei2s_decl_void@
F << remove_static_pcm_read_bei2s_decl_void.F;
P << remove_static_pcm_read_bei2s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_pcm_read_bei2s_def@
type T;
identifier F = pcm_read_bei2s;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_pcm_read_bei2s_def@
F << extract_pcm_read_bei2s_def.F;
T << extract_pcm_read_bei2s_def.T;
P << extract_pcm_read_bei2s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_pcm_read_bei2s_def_void@
identifier F = pcm_read_bei2s;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_pcm_read_bei2s_def_void@
F << extract_pcm_read_bei2s_def_void.F;
P << extract_pcm_read_bei2s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_pcm_read_bei2s_decl@
type T;
identifier F = pcm_read_bei2s;
parameter list P;
@@
T F(P);

@script:python depends on extract_pcm_read_bei2s_decl@
F << extract_pcm_read_bei2s_decl.F;
T << extract_pcm_read_bei2s_decl.T;
P << extract_pcm_read_bei2s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_pcm_read_bei2s_decl_void@
identifier F = pcm_read_bei2s;
parameter list P;
@@
void F(P);

@script:python depends on extract_pcm_read_bei2s_decl_void@
F << extract_pcm_read_bei2s_decl_void.F;
P << extract_pcm_read_bei2s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: pcm_read_bes2d
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_pcm_read_bes2d_def@
type T;
identifier F = pcm_read_bes2d;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_pcm_read_bes2d_def@
F << remove_static_pcm_read_bes2d_def.F;
T << remove_static_pcm_read_bes2d_def.T;
P << remove_static_pcm_read_bes2d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_pcm_read_bes2d_def_void@
identifier F = pcm_read_bes2d;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_pcm_read_bes2d_def_void@
F << remove_static_pcm_read_bes2d_def_void.F;
P << remove_static_pcm_read_bes2d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_pcm_read_bes2d_decl@
type T;
identifier F = pcm_read_bes2d;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_pcm_read_bes2d_decl@
F << remove_static_pcm_read_bes2d_decl.F;
T << remove_static_pcm_read_bes2d_decl.T;
P << remove_static_pcm_read_bes2d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_pcm_read_bes2d_decl_void@
identifier F = pcm_read_bes2d;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_pcm_read_bes2d_decl_void@
F << remove_static_pcm_read_bes2d_decl_void.F;
P << remove_static_pcm_read_bes2d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_pcm_read_bes2d_def@
type T;
identifier F = pcm_read_bes2d;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_pcm_read_bes2d_def@
F << extract_pcm_read_bes2d_def.F;
T << extract_pcm_read_bes2d_def.T;
P << extract_pcm_read_bes2d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_pcm_read_bes2d_def_void@
identifier F = pcm_read_bes2d;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_pcm_read_bes2d_def_void@
F << extract_pcm_read_bes2d_def_void.F;
P << extract_pcm_read_bes2d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_pcm_read_bes2d_decl@
type T;
identifier F = pcm_read_bes2d;
parameter list P;
@@
T F(P);

@script:python depends on extract_pcm_read_bes2d_decl@
F << extract_pcm_read_bes2d_decl.F;
T << extract_pcm_read_bes2d_decl.T;
P << extract_pcm_read_bes2d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_pcm_read_bes2d_decl_void@
identifier F = pcm_read_bes2d;
parameter list P;
@@
void F(P);

@script:python depends on extract_pcm_read_bes2d_decl_void@
F << extract_pcm_read_bes2d_decl_void.F;
P << extract_pcm_read_bes2d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: pcm_read_bes2f
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_pcm_read_bes2f_def@
type T;
identifier F = pcm_read_bes2f;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_pcm_read_bes2f_def@
F << remove_static_pcm_read_bes2f_def.F;
T << remove_static_pcm_read_bes2f_def.T;
P << remove_static_pcm_read_bes2f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_pcm_read_bes2f_def_void@
identifier F = pcm_read_bes2f;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_pcm_read_bes2f_def_void@
F << remove_static_pcm_read_bes2f_def_void.F;
P << remove_static_pcm_read_bes2f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_pcm_read_bes2f_decl@
type T;
identifier F = pcm_read_bes2f;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_pcm_read_bes2f_decl@
F << remove_static_pcm_read_bes2f_decl.F;
T << remove_static_pcm_read_bes2f_decl.T;
P << remove_static_pcm_read_bes2f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_pcm_read_bes2f_decl_void@
identifier F = pcm_read_bes2f;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_pcm_read_bes2f_decl_void@
F << remove_static_pcm_read_bes2f_decl_void.F;
P << remove_static_pcm_read_bes2f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_pcm_read_bes2f_def@
type T;
identifier F = pcm_read_bes2f;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_pcm_read_bes2f_def@
F << extract_pcm_read_bes2f_def.F;
T << extract_pcm_read_bes2f_def.T;
P << extract_pcm_read_bes2f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_pcm_read_bes2f_def_void@
identifier F = pcm_read_bes2f;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_pcm_read_bes2f_def_void@
F << extract_pcm_read_bes2f_def_void.F;
P << extract_pcm_read_bes2f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_pcm_read_bes2f_decl@
type T;
identifier F = pcm_read_bes2f;
parameter list P;
@@
T F(P);

@script:python depends on extract_pcm_read_bes2f_decl@
F << extract_pcm_read_bes2f_decl.F;
T << extract_pcm_read_bes2f_decl.T;
P << extract_pcm_read_bes2f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_pcm_read_bes2f_decl_void@
identifier F = pcm_read_bes2f;
parameter list P;
@@
void F(P);

@script:python depends on extract_pcm_read_bes2f_decl_void@
F << extract_pcm_read_bes2f_decl_void.F;
P << extract_pcm_read_bes2f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: pcm_read_bes2i
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_pcm_read_bes2i_def@
type T;
identifier F = pcm_read_bes2i;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_pcm_read_bes2i_def@
F << remove_static_pcm_read_bes2i_def.F;
T << remove_static_pcm_read_bes2i_def.T;
P << remove_static_pcm_read_bes2i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_pcm_read_bes2i_def_void@
identifier F = pcm_read_bes2i;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_pcm_read_bes2i_def_void@
F << remove_static_pcm_read_bes2i_def_void.F;
P << remove_static_pcm_read_bes2i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_pcm_read_bes2i_decl@
type T;
identifier F = pcm_read_bes2i;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_pcm_read_bes2i_decl@
F << remove_static_pcm_read_bes2i_decl.F;
T << remove_static_pcm_read_bes2i_decl.T;
P << remove_static_pcm_read_bes2i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_pcm_read_bes2i_decl_void@
identifier F = pcm_read_bes2i;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_pcm_read_bes2i_decl_void@
F << remove_static_pcm_read_bes2i_decl_void.F;
P << remove_static_pcm_read_bes2i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_pcm_read_bes2i_def@
type T;
identifier F = pcm_read_bes2i;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_pcm_read_bes2i_def@
F << extract_pcm_read_bes2i_def.F;
T << extract_pcm_read_bes2i_def.T;
P << extract_pcm_read_bes2i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_pcm_read_bes2i_def_void@
identifier F = pcm_read_bes2i;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_pcm_read_bes2i_def_void@
F << extract_pcm_read_bes2i_def_void.F;
P << extract_pcm_read_bes2i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_pcm_read_bes2i_decl@
type T;
identifier F = pcm_read_bes2i;
parameter list P;
@@
T F(P);

@script:python depends on extract_pcm_read_bes2i_decl@
F << extract_pcm_read_bes2i_decl.F;
T << extract_pcm_read_bes2i_decl.T;
P << extract_pcm_read_bes2i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_pcm_read_bes2i_decl_void@
identifier F = pcm_read_bes2i;
parameter list P;
@@
void F(P);

@script:python depends on extract_pcm_read_bes2i_decl_void@
F << extract_pcm_read_bes2i_decl_void.F;
P << extract_pcm_read_bes2i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: pcm_read_bes2s
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_pcm_read_bes2s_def@
type T;
identifier F = pcm_read_bes2s;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_pcm_read_bes2s_def@
F << remove_static_pcm_read_bes2s_def.F;
T << remove_static_pcm_read_bes2s_def.T;
P << remove_static_pcm_read_bes2s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_pcm_read_bes2s_def_void@
identifier F = pcm_read_bes2s;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_pcm_read_bes2s_def_void@
F << remove_static_pcm_read_bes2s_def_void.F;
P << remove_static_pcm_read_bes2s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_pcm_read_bes2s_decl@
type T;
identifier F = pcm_read_bes2s;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_pcm_read_bes2s_decl@
F << remove_static_pcm_read_bes2s_decl.F;
T << remove_static_pcm_read_bes2s_decl.T;
P << remove_static_pcm_read_bes2s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_pcm_read_bes2s_decl_void@
identifier F = pcm_read_bes2s;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_pcm_read_bes2s_decl_void@
F << remove_static_pcm_read_bes2s_decl_void.F;
P << remove_static_pcm_read_bes2s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_pcm_read_bes2s_def@
type T;
identifier F = pcm_read_bes2s;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_pcm_read_bes2s_def@
F << extract_pcm_read_bes2s_def.F;
T << extract_pcm_read_bes2s_def.T;
P << extract_pcm_read_bes2s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_pcm_read_bes2s_def_void@
identifier F = pcm_read_bes2s;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_pcm_read_bes2s_def_void@
F << extract_pcm_read_bes2s_def_void.F;
P << extract_pcm_read_bes2s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_pcm_read_bes2s_decl@
type T;
identifier F = pcm_read_bes2s;
parameter list P;
@@
T F(P);

@script:python depends on extract_pcm_read_bes2s_decl@
F << extract_pcm_read_bes2s_decl.F;
T << extract_pcm_read_bes2s_decl.T;
P << extract_pcm_read_bes2s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_pcm_read_bes2s_decl_void@
identifier F = pcm_read_bes2s;
parameter list P;
@@
void F(P);

@script:python depends on extract_pcm_read_bes2s_decl_void@
F << extract_pcm_read_bes2s_decl_void.F;
P << extract_pcm_read_bes2s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: pcm_read_bet2d
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_pcm_read_bet2d_def@
type T;
identifier F = pcm_read_bet2d;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_pcm_read_bet2d_def@
F << remove_static_pcm_read_bet2d_def.F;
T << remove_static_pcm_read_bet2d_def.T;
P << remove_static_pcm_read_bet2d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_pcm_read_bet2d_def_void@
identifier F = pcm_read_bet2d;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_pcm_read_bet2d_def_void@
F << remove_static_pcm_read_bet2d_def_void.F;
P << remove_static_pcm_read_bet2d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_pcm_read_bet2d_decl@
type T;
identifier F = pcm_read_bet2d;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_pcm_read_bet2d_decl@
F << remove_static_pcm_read_bet2d_decl.F;
T << remove_static_pcm_read_bet2d_decl.T;
P << remove_static_pcm_read_bet2d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_pcm_read_bet2d_decl_void@
identifier F = pcm_read_bet2d;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_pcm_read_bet2d_decl_void@
F << remove_static_pcm_read_bet2d_decl_void.F;
P << remove_static_pcm_read_bet2d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_pcm_read_bet2d_def@
type T;
identifier F = pcm_read_bet2d;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_pcm_read_bet2d_def@
F << extract_pcm_read_bet2d_def.F;
T << extract_pcm_read_bet2d_def.T;
P << extract_pcm_read_bet2d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_pcm_read_bet2d_def_void@
identifier F = pcm_read_bet2d;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_pcm_read_bet2d_def_void@
F << extract_pcm_read_bet2d_def_void.F;
P << extract_pcm_read_bet2d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_pcm_read_bet2d_decl@
type T;
identifier F = pcm_read_bet2d;
parameter list P;
@@
T F(P);

@script:python depends on extract_pcm_read_bet2d_decl@
F << extract_pcm_read_bet2d_decl.F;
T << extract_pcm_read_bet2d_decl.T;
P << extract_pcm_read_bet2d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_pcm_read_bet2d_decl_void@
identifier F = pcm_read_bet2d;
parameter list P;
@@
void F(P);

@script:python depends on extract_pcm_read_bet2d_decl_void@
F << extract_pcm_read_bet2d_decl_void.F;
P << extract_pcm_read_bet2d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: pcm_read_bet2f
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_pcm_read_bet2f_def@
type T;
identifier F = pcm_read_bet2f;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_pcm_read_bet2f_def@
F << remove_static_pcm_read_bet2f_def.F;
T << remove_static_pcm_read_bet2f_def.T;
P << remove_static_pcm_read_bet2f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_pcm_read_bet2f_def_void@
identifier F = pcm_read_bet2f;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_pcm_read_bet2f_def_void@
F << remove_static_pcm_read_bet2f_def_void.F;
P << remove_static_pcm_read_bet2f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_pcm_read_bet2f_decl@
type T;
identifier F = pcm_read_bet2f;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_pcm_read_bet2f_decl@
F << remove_static_pcm_read_bet2f_decl.F;
T << remove_static_pcm_read_bet2f_decl.T;
P << remove_static_pcm_read_bet2f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_pcm_read_bet2f_decl_void@
identifier F = pcm_read_bet2f;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_pcm_read_bet2f_decl_void@
F << remove_static_pcm_read_bet2f_decl_void.F;
P << remove_static_pcm_read_bet2f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_pcm_read_bet2f_def@
type T;
identifier F = pcm_read_bet2f;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_pcm_read_bet2f_def@
F << extract_pcm_read_bet2f_def.F;
T << extract_pcm_read_bet2f_def.T;
P << extract_pcm_read_bet2f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_pcm_read_bet2f_def_void@
identifier F = pcm_read_bet2f;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_pcm_read_bet2f_def_void@
F << extract_pcm_read_bet2f_def_void.F;
P << extract_pcm_read_bet2f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_pcm_read_bet2f_decl@
type T;
identifier F = pcm_read_bet2f;
parameter list P;
@@
T F(P);

@script:python depends on extract_pcm_read_bet2f_decl@
F << extract_pcm_read_bet2f_decl.F;
T << extract_pcm_read_bet2f_decl.T;
P << extract_pcm_read_bet2f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_pcm_read_bet2f_decl_void@
identifier F = pcm_read_bet2f;
parameter list P;
@@
void F(P);

@script:python depends on extract_pcm_read_bet2f_decl_void@
F << extract_pcm_read_bet2f_decl_void.F;
P << extract_pcm_read_bet2f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: pcm_read_bet2i
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_pcm_read_bet2i_def@
type T;
identifier F = pcm_read_bet2i;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_pcm_read_bet2i_def@
F << remove_static_pcm_read_bet2i_def.F;
T << remove_static_pcm_read_bet2i_def.T;
P << remove_static_pcm_read_bet2i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_pcm_read_bet2i_def_void@
identifier F = pcm_read_bet2i;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_pcm_read_bet2i_def_void@
F << remove_static_pcm_read_bet2i_def_void.F;
P << remove_static_pcm_read_bet2i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_pcm_read_bet2i_decl@
type T;
identifier F = pcm_read_bet2i;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_pcm_read_bet2i_decl@
F << remove_static_pcm_read_bet2i_decl.F;
T << remove_static_pcm_read_bet2i_decl.T;
P << remove_static_pcm_read_bet2i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_pcm_read_bet2i_decl_void@
identifier F = pcm_read_bet2i;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_pcm_read_bet2i_decl_void@
F << remove_static_pcm_read_bet2i_decl_void.F;
P << remove_static_pcm_read_bet2i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_pcm_read_bet2i_def@
type T;
identifier F = pcm_read_bet2i;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_pcm_read_bet2i_def@
F << extract_pcm_read_bet2i_def.F;
T << extract_pcm_read_bet2i_def.T;
P << extract_pcm_read_bet2i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_pcm_read_bet2i_def_void@
identifier F = pcm_read_bet2i;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_pcm_read_bet2i_def_void@
F << extract_pcm_read_bet2i_def_void.F;
P << extract_pcm_read_bet2i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_pcm_read_bet2i_decl@
type T;
identifier F = pcm_read_bet2i;
parameter list P;
@@
T F(P);

@script:python depends on extract_pcm_read_bet2i_decl@
F << extract_pcm_read_bet2i_decl.F;
T << extract_pcm_read_bet2i_decl.T;
P << extract_pcm_read_bet2i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_pcm_read_bet2i_decl_void@
identifier F = pcm_read_bet2i;
parameter list P;
@@
void F(P);

@script:python depends on extract_pcm_read_bet2i_decl_void@
F << extract_pcm_read_bet2i_decl_void.F;
P << extract_pcm_read_bet2i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: pcm_read_bet2s
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_pcm_read_bet2s_def@
type T;
identifier F = pcm_read_bet2s;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_pcm_read_bet2s_def@
F << remove_static_pcm_read_bet2s_def.F;
T << remove_static_pcm_read_bet2s_def.T;
P << remove_static_pcm_read_bet2s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_pcm_read_bet2s_def_void@
identifier F = pcm_read_bet2s;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_pcm_read_bet2s_def_void@
F << remove_static_pcm_read_bet2s_def_void.F;
P << remove_static_pcm_read_bet2s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_pcm_read_bet2s_decl@
type T;
identifier F = pcm_read_bet2s;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_pcm_read_bet2s_decl@
F << remove_static_pcm_read_bet2s_decl.F;
T << remove_static_pcm_read_bet2s_decl.T;
P << remove_static_pcm_read_bet2s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_pcm_read_bet2s_decl_void@
identifier F = pcm_read_bet2s;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_pcm_read_bet2s_decl_void@
F << remove_static_pcm_read_bet2s_decl_void.F;
P << remove_static_pcm_read_bet2s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_pcm_read_bet2s_def@
type T;
identifier F = pcm_read_bet2s;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_pcm_read_bet2s_def@
F << extract_pcm_read_bet2s_def.F;
T << extract_pcm_read_bet2s_def.T;
P << extract_pcm_read_bet2s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_pcm_read_bet2s_def_void@
identifier F = pcm_read_bet2s;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_pcm_read_bet2s_def_void@
F << extract_pcm_read_bet2s_def_void.F;
P << extract_pcm_read_bet2s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_pcm_read_bet2s_decl@
type T;
identifier F = pcm_read_bet2s;
parameter list P;
@@
T F(P);

@script:python depends on extract_pcm_read_bet2s_decl@
F << extract_pcm_read_bet2s_decl.F;
T << extract_pcm_read_bet2s_decl.T;
P << extract_pcm_read_bet2s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_pcm_read_bet2s_decl_void@
identifier F = pcm_read_bet2s;
parameter list P;
@@
void F(P);

@script:python depends on extract_pcm_read_bet2s_decl_void@
F << extract_pcm_read_bet2s_decl_void.F;
P << extract_pcm_read_bet2s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: pcm_read_lei2d
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_pcm_read_lei2d_def@
type T;
identifier F = pcm_read_lei2d;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_pcm_read_lei2d_def@
F << remove_static_pcm_read_lei2d_def.F;
T << remove_static_pcm_read_lei2d_def.T;
P << remove_static_pcm_read_lei2d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_pcm_read_lei2d_def_void@
identifier F = pcm_read_lei2d;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_pcm_read_lei2d_def_void@
F << remove_static_pcm_read_lei2d_def_void.F;
P << remove_static_pcm_read_lei2d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_pcm_read_lei2d_decl@
type T;
identifier F = pcm_read_lei2d;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_pcm_read_lei2d_decl@
F << remove_static_pcm_read_lei2d_decl.F;
T << remove_static_pcm_read_lei2d_decl.T;
P << remove_static_pcm_read_lei2d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_pcm_read_lei2d_decl_void@
identifier F = pcm_read_lei2d;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_pcm_read_lei2d_decl_void@
F << remove_static_pcm_read_lei2d_decl_void.F;
P << remove_static_pcm_read_lei2d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_pcm_read_lei2d_def@
type T;
identifier F = pcm_read_lei2d;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_pcm_read_lei2d_def@
F << extract_pcm_read_lei2d_def.F;
T << extract_pcm_read_lei2d_def.T;
P << extract_pcm_read_lei2d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_pcm_read_lei2d_def_void@
identifier F = pcm_read_lei2d;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_pcm_read_lei2d_def_void@
F << extract_pcm_read_lei2d_def_void.F;
P << extract_pcm_read_lei2d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_pcm_read_lei2d_decl@
type T;
identifier F = pcm_read_lei2d;
parameter list P;
@@
T F(P);

@script:python depends on extract_pcm_read_lei2d_decl@
F << extract_pcm_read_lei2d_decl.F;
T << extract_pcm_read_lei2d_decl.T;
P << extract_pcm_read_lei2d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_pcm_read_lei2d_decl_void@
identifier F = pcm_read_lei2d;
parameter list P;
@@
void F(P);

@script:python depends on extract_pcm_read_lei2d_decl_void@
F << extract_pcm_read_lei2d_decl_void.F;
P << extract_pcm_read_lei2d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: pcm_read_lei2f
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_pcm_read_lei2f_def@
type T;
identifier F = pcm_read_lei2f;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_pcm_read_lei2f_def@
F << remove_static_pcm_read_lei2f_def.F;
T << remove_static_pcm_read_lei2f_def.T;
P << remove_static_pcm_read_lei2f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_pcm_read_lei2f_def_void@
identifier F = pcm_read_lei2f;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_pcm_read_lei2f_def_void@
F << remove_static_pcm_read_lei2f_def_void.F;
P << remove_static_pcm_read_lei2f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_pcm_read_lei2f_decl@
type T;
identifier F = pcm_read_lei2f;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_pcm_read_lei2f_decl@
F << remove_static_pcm_read_lei2f_decl.F;
T << remove_static_pcm_read_lei2f_decl.T;
P << remove_static_pcm_read_lei2f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_pcm_read_lei2f_decl_void@
identifier F = pcm_read_lei2f;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_pcm_read_lei2f_decl_void@
F << remove_static_pcm_read_lei2f_decl_void.F;
P << remove_static_pcm_read_lei2f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_pcm_read_lei2f_def@
type T;
identifier F = pcm_read_lei2f;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_pcm_read_lei2f_def@
F << extract_pcm_read_lei2f_def.F;
T << extract_pcm_read_lei2f_def.T;
P << extract_pcm_read_lei2f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_pcm_read_lei2f_def_void@
identifier F = pcm_read_lei2f;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_pcm_read_lei2f_def_void@
F << extract_pcm_read_lei2f_def_void.F;
P << extract_pcm_read_lei2f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_pcm_read_lei2f_decl@
type T;
identifier F = pcm_read_lei2f;
parameter list P;
@@
T F(P);

@script:python depends on extract_pcm_read_lei2f_decl@
F << extract_pcm_read_lei2f_decl.F;
T << extract_pcm_read_lei2f_decl.T;
P << extract_pcm_read_lei2f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_pcm_read_lei2f_decl_void@
identifier F = pcm_read_lei2f;
parameter list P;
@@
void F(P);

@script:python depends on extract_pcm_read_lei2f_decl_void@
F << extract_pcm_read_lei2f_decl_void.F;
P << extract_pcm_read_lei2f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: pcm_read_lei2i
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_pcm_read_lei2i_def@
type T;
identifier F = pcm_read_lei2i;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_pcm_read_lei2i_def@
F << remove_static_pcm_read_lei2i_def.F;
T << remove_static_pcm_read_lei2i_def.T;
P << remove_static_pcm_read_lei2i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_pcm_read_lei2i_def_void@
identifier F = pcm_read_lei2i;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_pcm_read_lei2i_def_void@
F << remove_static_pcm_read_lei2i_def_void.F;
P << remove_static_pcm_read_lei2i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_pcm_read_lei2i_decl@
type T;
identifier F = pcm_read_lei2i;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_pcm_read_lei2i_decl@
F << remove_static_pcm_read_lei2i_decl.F;
T << remove_static_pcm_read_lei2i_decl.T;
P << remove_static_pcm_read_lei2i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_pcm_read_lei2i_decl_void@
identifier F = pcm_read_lei2i;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_pcm_read_lei2i_decl_void@
F << remove_static_pcm_read_lei2i_decl_void.F;
P << remove_static_pcm_read_lei2i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_pcm_read_lei2i_def@
type T;
identifier F = pcm_read_lei2i;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_pcm_read_lei2i_def@
F << extract_pcm_read_lei2i_def.F;
T << extract_pcm_read_lei2i_def.T;
P << extract_pcm_read_lei2i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_pcm_read_lei2i_def_void@
identifier F = pcm_read_lei2i;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_pcm_read_lei2i_def_void@
F << extract_pcm_read_lei2i_def_void.F;
P << extract_pcm_read_lei2i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_pcm_read_lei2i_decl@
type T;
identifier F = pcm_read_lei2i;
parameter list P;
@@
T F(P);

@script:python depends on extract_pcm_read_lei2i_decl@
F << extract_pcm_read_lei2i_decl.F;
T << extract_pcm_read_lei2i_decl.T;
P << extract_pcm_read_lei2i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_pcm_read_lei2i_decl_void@
identifier F = pcm_read_lei2i;
parameter list P;
@@
void F(P);

@script:python depends on extract_pcm_read_lei2i_decl_void@
F << extract_pcm_read_lei2i_decl_void.F;
P << extract_pcm_read_lei2i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: pcm_read_lei2s
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_pcm_read_lei2s_def@
type T;
identifier F = pcm_read_lei2s;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_pcm_read_lei2s_def@
F << remove_static_pcm_read_lei2s_def.F;
T << remove_static_pcm_read_lei2s_def.T;
P << remove_static_pcm_read_lei2s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_pcm_read_lei2s_def_void@
identifier F = pcm_read_lei2s;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_pcm_read_lei2s_def_void@
F << remove_static_pcm_read_lei2s_def_void.F;
P << remove_static_pcm_read_lei2s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_pcm_read_lei2s_decl@
type T;
identifier F = pcm_read_lei2s;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_pcm_read_lei2s_decl@
F << remove_static_pcm_read_lei2s_decl.F;
T << remove_static_pcm_read_lei2s_decl.T;
P << remove_static_pcm_read_lei2s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_pcm_read_lei2s_decl_void@
identifier F = pcm_read_lei2s;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_pcm_read_lei2s_decl_void@
F << remove_static_pcm_read_lei2s_decl_void.F;
P << remove_static_pcm_read_lei2s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_pcm_read_lei2s_def@
type T;
identifier F = pcm_read_lei2s;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_pcm_read_lei2s_def@
F << extract_pcm_read_lei2s_def.F;
T << extract_pcm_read_lei2s_def.T;
P << extract_pcm_read_lei2s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_pcm_read_lei2s_def_void@
identifier F = pcm_read_lei2s;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_pcm_read_lei2s_def_void@
F << extract_pcm_read_lei2s_def_void.F;
P << extract_pcm_read_lei2s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_pcm_read_lei2s_decl@
type T;
identifier F = pcm_read_lei2s;
parameter list P;
@@
T F(P);

@script:python depends on extract_pcm_read_lei2s_decl@
F << extract_pcm_read_lei2s_decl.F;
T << extract_pcm_read_lei2s_decl.T;
P << extract_pcm_read_lei2s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_pcm_read_lei2s_decl_void@
identifier F = pcm_read_lei2s;
parameter list P;
@@
void F(P);

@script:python depends on extract_pcm_read_lei2s_decl_void@
F << extract_pcm_read_lei2s_decl_void.F;
P << extract_pcm_read_lei2s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: pcm_read_les2d
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_pcm_read_les2d_def@
type T;
identifier F = pcm_read_les2d;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_pcm_read_les2d_def@
F << remove_static_pcm_read_les2d_def.F;
T << remove_static_pcm_read_les2d_def.T;
P << remove_static_pcm_read_les2d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_pcm_read_les2d_def_void@
identifier F = pcm_read_les2d;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_pcm_read_les2d_def_void@
F << remove_static_pcm_read_les2d_def_void.F;
P << remove_static_pcm_read_les2d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_pcm_read_les2d_decl@
type T;
identifier F = pcm_read_les2d;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_pcm_read_les2d_decl@
F << remove_static_pcm_read_les2d_decl.F;
T << remove_static_pcm_read_les2d_decl.T;
P << remove_static_pcm_read_les2d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_pcm_read_les2d_decl_void@
identifier F = pcm_read_les2d;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_pcm_read_les2d_decl_void@
F << remove_static_pcm_read_les2d_decl_void.F;
P << remove_static_pcm_read_les2d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_pcm_read_les2d_def@
type T;
identifier F = pcm_read_les2d;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_pcm_read_les2d_def@
F << extract_pcm_read_les2d_def.F;
T << extract_pcm_read_les2d_def.T;
P << extract_pcm_read_les2d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_pcm_read_les2d_def_void@
identifier F = pcm_read_les2d;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_pcm_read_les2d_def_void@
F << extract_pcm_read_les2d_def_void.F;
P << extract_pcm_read_les2d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_pcm_read_les2d_decl@
type T;
identifier F = pcm_read_les2d;
parameter list P;
@@
T F(P);

@script:python depends on extract_pcm_read_les2d_decl@
F << extract_pcm_read_les2d_decl.F;
T << extract_pcm_read_les2d_decl.T;
P << extract_pcm_read_les2d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_pcm_read_les2d_decl_void@
identifier F = pcm_read_les2d;
parameter list P;
@@
void F(P);

@script:python depends on extract_pcm_read_les2d_decl_void@
F << extract_pcm_read_les2d_decl_void.F;
P << extract_pcm_read_les2d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: pcm_read_les2f
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_pcm_read_les2f_def@
type T;
identifier F = pcm_read_les2f;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_pcm_read_les2f_def@
F << remove_static_pcm_read_les2f_def.F;
T << remove_static_pcm_read_les2f_def.T;
P << remove_static_pcm_read_les2f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_pcm_read_les2f_def_void@
identifier F = pcm_read_les2f;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_pcm_read_les2f_def_void@
F << remove_static_pcm_read_les2f_def_void.F;
P << remove_static_pcm_read_les2f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_pcm_read_les2f_decl@
type T;
identifier F = pcm_read_les2f;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_pcm_read_les2f_decl@
F << remove_static_pcm_read_les2f_decl.F;
T << remove_static_pcm_read_les2f_decl.T;
P << remove_static_pcm_read_les2f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_pcm_read_les2f_decl_void@
identifier F = pcm_read_les2f;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_pcm_read_les2f_decl_void@
F << remove_static_pcm_read_les2f_decl_void.F;
P << remove_static_pcm_read_les2f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_pcm_read_les2f_def@
type T;
identifier F = pcm_read_les2f;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_pcm_read_les2f_def@
F << extract_pcm_read_les2f_def.F;
T << extract_pcm_read_les2f_def.T;
P << extract_pcm_read_les2f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_pcm_read_les2f_def_void@
identifier F = pcm_read_les2f;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_pcm_read_les2f_def_void@
F << extract_pcm_read_les2f_def_void.F;
P << extract_pcm_read_les2f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_pcm_read_les2f_decl@
type T;
identifier F = pcm_read_les2f;
parameter list P;
@@
T F(P);

@script:python depends on extract_pcm_read_les2f_decl@
F << extract_pcm_read_les2f_decl.F;
T << extract_pcm_read_les2f_decl.T;
P << extract_pcm_read_les2f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_pcm_read_les2f_decl_void@
identifier F = pcm_read_les2f;
parameter list P;
@@
void F(P);

@script:python depends on extract_pcm_read_les2f_decl_void@
F << extract_pcm_read_les2f_decl_void.F;
P << extract_pcm_read_les2f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: pcm_read_les2i
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_pcm_read_les2i_def@
type T;
identifier F = pcm_read_les2i;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_pcm_read_les2i_def@
F << remove_static_pcm_read_les2i_def.F;
T << remove_static_pcm_read_les2i_def.T;
P << remove_static_pcm_read_les2i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_pcm_read_les2i_def_void@
identifier F = pcm_read_les2i;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_pcm_read_les2i_def_void@
F << remove_static_pcm_read_les2i_def_void.F;
P << remove_static_pcm_read_les2i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_pcm_read_les2i_decl@
type T;
identifier F = pcm_read_les2i;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_pcm_read_les2i_decl@
F << remove_static_pcm_read_les2i_decl.F;
T << remove_static_pcm_read_les2i_decl.T;
P << remove_static_pcm_read_les2i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_pcm_read_les2i_decl_void@
identifier F = pcm_read_les2i;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_pcm_read_les2i_decl_void@
F << remove_static_pcm_read_les2i_decl_void.F;
P << remove_static_pcm_read_les2i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_pcm_read_les2i_def@
type T;
identifier F = pcm_read_les2i;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_pcm_read_les2i_def@
F << extract_pcm_read_les2i_def.F;
T << extract_pcm_read_les2i_def.T;
P << extract_pcm_read_les2i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_pcm_read_les2i_def_void@
identifier F = pcm_read_les2i;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_pcm_read_les2i_def_void@
F << extract_pcm_read_les2i_def_void.F;
P << extract_pcm_read_les2i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_pcm_read_les2i_decl@
type T;
identifier F = pcm_read_les2i;
parameter list P;
@@
T F(P);

@script:python depends on extract_pcm_read_les2i_decl@
F << extract_pcm_read_les2i_decl.F;
T << extract_pcm_read_les2i_decl.T;
P << extract_pcm_read_les2i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_pcm_read_les2i_decl_void@
identifier F = pcm_read_les2i;
parameter list P;
@@
void F(P);

@script:python depends on extract_pcm_read_les2i_decl_void@
F << extract_pcm_read_les2i_decl_void.F;
P << extract_pcm_read_les2i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: pcm_read_les2s
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_pcm_read_les2s_def@
type T;
identifier F = pcm_read_les2s;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_pcm_read_les2s_def@
F << remove_static_pcm_read_les2s_def.F;
T << remove_static_pcm_read_les2s_def.T;
P << remove_static_pcm_read_les2s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_pcm_read_les2s_def_void@
identifier F = pcm_read_les2s;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_pcm_read_les2s_def_void@
F << remove_static_pcm_read_les2s_def_void.F;
P << remove_static_pcm_read_les2s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_pcm_read_les2s_decl@
type T;
identifier F = pcm_read_les2s;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_pcm_read_les2s_decl@
F << remove_static_pcm_read_les2s_decl.F;
T << remove_static_pcm_read_les2s_decl.T;
P << remove_static_pcm_read_les2s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_pcm_read_les2s_decl_void@
identifier F = pcm_read_les2s;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_pcm_read_les2s_decl_void@
F << remove_static_pcm_read_les2s_decl_void.F;
P << remove_static_pcm_read_les2s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_pcm_read_les2s_def@
type T;
identifier F = pcm_read_les2s;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_pcm_read_les2s_def@
F << extract_pcm_read_les2s_def.F;
T << extract_pcm_read_les2s_def.T;
P << extract_pcm_read_les2s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_pcm_read_les2s_def_void@
identifier F = pcm_read_les2s;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_pcm_read_les2s_def_void@
F << extract_pcm_read_les2s_def_void.F;
P << extract_pcm_read_les2s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_pcm_read_les2s_decl@
type T;
identifier F = pcm_read_les2s;
parameter list P;
@@
T F(P);

@script:python depends on extract_pcm_read_les2s_decl@
F << extract_pcm_read_les2s_decl.F;
T << extract_pcm_read_les2s_decl.T;
P << extract_pcm_read_les2s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_pcm_read_les2s_decl_void@
identifier F = pcm_read_les2s;
parameter list P;
@@
void F(P);

@script:python depends on extract_pcm_read_les2s_decl_void@
F << extract_pcm_read_les2s_decl_void.F;
P << extract_pcm_read_les2s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: pcm_read_let2d
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_pcm_read_let2d_def@
type T;
identifier F = pcm_read_let2d;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_pcm_read_let2d_def@
F << remove_static_pcm_read_let2d_def.F;
T << remove_static_pcm_read_let2d_def.T;
P << remove_static_pcm_read_let2d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_pcm_read_let2d_def_void@
identifier F = pcm_read_let2d;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_pcm_read_let2d_def_void@
F << remove_static_pcm_read_let2d_def_void.F;
P << remove_static_pcm_read_let2d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_pcm_read_let2d_decl@
type T;
identifier F = pcm_read_let2d;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_pcm_read_let2d_decl@
F << remove_static_pcm_read_let2d_decl.F;
T << remove_static_pcm_read_let2d_decl.T;
P << remove_static_pcm_read_let2d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_pcm_read_let2d_decl_void@
identifier F = pcm_read_let2d;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_pcm_read_let2d_decl_void@
F << remove_static_pcm_read_let2d_decl_void.F;
P << remove_static_pcm_read_let2d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_pcm_read_let2d_def@
type T;
identifier F = pcm_read_let2d;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_pcm_read_let2d_def@
F << extract_pcm_read_let2d_def.F;
T << extract_pcm_read_let2d_def.T;
P << extract_pcm_read_let2d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_pcm_read_let2d_def_void@
identifier F = pcm_read_let2d;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_pcm_read_let2d_def_void@
F << extract_pcm_read_let2d_def_void.F;
P << extract_pcm_read_let2d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_pcm_read_let2d_decl@
type T;
identifier F = pcm_read_let2d;
parameter list P;
@@
T F(P);

@script:python depends on extract_pcm_read_let2d_decl@
F << extract_pcm_read_let2d_decl.F;
T << extract_pcm_read_let2d_decl.T;
P << extract_pcm_read_let2d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_pcm_read_let2d_decl_void@
identifier F = pcm_read_let2d;
parameter list P;
@@
void F(P);

@script:python depends on extract_pcm_read_let2d_decl_void@
F << extract_pcm_read_let2d_decl_void.F;
P << extract_pcm_read_let2d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: pcm_read_let2f
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_pcm_read_let2f_def@
type T;
identifier F = pcm_read_let2f;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_pcm_read_let2f_def@
F << remove_static_pcm_read_let2f_def.F;
T << remove_static_pcm_read_let2f_def.T;
P << remove_static_pcm_read_let2f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_pcm_read_let2f_def_void@
identifier F = pcm_read_let2f;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_pcm_read_let2f_def_void@
F << remove_static_pcm_read_let2f_def_void.F;
P << remove_static_pcm_read_let2f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_pcm_read_let2f_decl@
type T;
identifier F = pcm_read_let2f;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_pcm_read_let2f_decl@
F << remove_static_pcm_read_let2f_decl.F;
T << remove_static_pcm_read_let2f_decl.T;
P << remove_static_pcm_read_let2f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_pcm_read_let2f_decl_void@
identifier F = pcm_read_let2f;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_pcm_read_let2f_decl_void@
F << remove_static_pcm_read_let2f_decl_void.F;
P << remove_static_pcm_read_let2f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_pcm_read_let2f_def@
type T;
identifier F = pcm_read_let2f;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_pcm_read_let2f_def@
F << extract_pcm_read_let2f_def.F;
T << extract_pcm_read_let2f_def.T;
P << extract_pcm_read_let2f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_pcm_read_let2f_def_void@
identifier F = pcm_read_let2f;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_pcm_read_let2f_def_void@
F << extract_pcm_read_let2f_def_void.F;
P << extract_pcm_read_let2f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_pcm_read_let2f_decl@
type T;
identifier F = pcm_read_let2f;
parameter list P;
@@
T F(P);

@script:python depends on extract_pcm_read_let2f_decl@
F << extract_pcm_read_let2f_decl.F;
T << extract_pcm_read_let2f_decl.T;
P << extract_pcm_read_let2f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_pcm_read_let2f_decl_void@
identifier F = pcm_read_let2f;
parameter list P;
@@
void F(P);

@script:python depends on extract_pcm_read_let2f_decl_void@
F << extract_pcm_read_let2f_decl_void.F;
P << extract_pcm_read_let2f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: pcm_read_let2i
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_pcm_read_let2i_def@
type T;
identifier F = pcm_read_let2i;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_pcm_read_let2i_def@
F << remove_static_pcm_read_let2i_def.F;
T << remove_static_pcm_read_let2i_def.T;
P << remove_static_pcm_read_let2i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_pcm_read_let2i_def_void@
identifier F = pcm_read_let2i;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_pcm_read_let2i_def_void@
F << remove_static_pcm_read_let2i_def_void.F;
P << remove_static_pcm_read_let2i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_pcm_read_let2i_decl@
type T;
identifier F = pcm_read_let2i;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_pcm_read_let2i_decl@
F << remove_static_pcm_read_let2i_decl.F;
T << remove_static_pcm_read_let2i_decl.T;
P << remove_static_pcm_read_let2i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_pcm_read_let2i_decl_void@
identifier F = pcm_read_let2i;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_pcm_read_let2i_decl_void@
F << remove_static_pcm_read_let2i_decl_void.F;
P << remove_static_pcm_read_let2i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_pcm_read_let2i_def@
type T;
identifier F = pcm_read_let2i;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_pcm_read_let2i_def@
F << extract_pcm_read_let2i_def.F;
T << extract_pcm_read_let2i_def.T;
P << extract_pcm_read_let2i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_pcm_read_let2i_def_void@
identifier F = pcm_read_let2i;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_pcm_read_let2i_def_void@
F << extract_pcm_read_let2i_def_void.F;
P << extract_pcm_read_let2i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_pcm_read_let2i_decl@
type T;
identifier F = pcm_read_let2i;
parameter list P;
@@
T F(P);

@script:python depends on extract_pcm_read_let2i_decl@
F << extract_pcm_read_let2i_decl.F;
T << extract_pcm_read_let2i_decl.T;
P << extract_pcm_read_let2i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_pcm_read_let2i_decl_void@
identifier F = pcm_read_let2i;
parameter list P;
@@
void F(P);

@script:python depends on extract_pcm_read_let2i_decl_void@
F << extract_pcm_read_let2i_decl_void.F;
P << extract_pcm_read_let2i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: pcm_read_let2s
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_pcm_read_let2s_def@
type T;
identifier F = pcm_read_let2s;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_pcm_read_let2s_def@
F << remove_static_pcm_read_let2s_def.F;
T << remove_static_pcm_read_let2s_def.T;
P << remove_static_pcm_read_let2s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_pcm_read_let2s_def_void@
identifier F = pcm_read_let2s;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_pcm_read_let2s_def_void@
F << remove_static_pcm_read_let2s_def_void.F;
P << remove_static_pcm_read_let2s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_pcm_read_let2s_decl@
type T;
identifier F = pcm_read_let2s;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_pcm_read_let2s_decl@
F << remove_static_pcm_read_let2s_decl.F;
T << remove_static_pcm_read_let2s_decl.T;
P << remove_static_pcm_read_let2s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_pcm_read_let2s_decl_void@
identifier F = pcm_read_let2s;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_pcm_read_let2s_decl_void@
F << remove_static_pcm_read_let2s_decl_void.F;
P << remove_static_pcm_read_let2s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_pcm_read_let2s_def@
type T;
identifier F = pcm_read_let2s;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_pcm_read_let2s_def@
F << extract_pcm_read_let2s_def.F;
T << extract_pcm_read_let2s_def.T;
P << extract_pcm_read_let2s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_pcm_read_let2s_def_void@
identifier F = pcm_read_let2s;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_pcm_read_let2s_def_void@
F << extract_pcm_read_let2s_def_void.F;
P << extract_pcm_read_let2s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_pcm_read_let2s_decl@
type T;
identifier F = pcm_read_let2s;
parameter list P;
@@
T F(P);

@script:python depends on extract_pcm_read_let2s_decl@
F << extract_pcm_read_let2s_decl.F;
T << extract_pcm_read_let2s_decl.T;
P << extract_pcm_read_let2s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_pcm_read_let2s_decl_void@
identifier F = pcm_read_let2s;
parameter list P;
@@
void F(P);

@script:python depends on extract_pcm_read_let2s_decl_void@
F << extract_pcm_read_let2s_decl_void.F;
P << extract_pcm_read_let2s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: pcm_read_sc2d
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_pcm_read_sc2d_def@
type T;
identifier F = pcm_read_sc2d;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_pcm_read_sc2d_def@
F << remove_static_pcm_read_sc2d_def.F;
T << remove_static_pcm_read_sc2d_def.T;
P << remove_static_pcm_read_sc2d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_pcm_read_sc2d_def_void@
identifier F = pcm_read_sc2d;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_pcm_read_sc2d_def_void@
F << remove_static_pcm_read_sc2d_def_void.F;
P << remove_static_pcm_read_sc2d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_pcm_read_sc2d_decl@
type T;
identifier F = pcm_read_sc2d;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_pcm_read_sc2d_decl@
F << remove_static_pcm_read_sc2d_decl.F;
T << remove_static_pcm_read_sc2d_decl.T;
P << remove_static_pcm_read_sc2d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_pcm_read_sc2d_decl_void@
identifier F = pcm_read_sc2d;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_pcm_read_sc2d_decl_void@
F << remove_static_pcm_read_sc2d_decl_void.F;
P << remove_static_pcm_read_sc2d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_pcm_read_sc2d_def@
type T;
identifier F = pcm_read_sc2d;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_pcm_read_sc2d_def@
F << extract_pcm_read_sc2d_def.F;
T << extract_pcm_read_sc2d_def.T;
P << extract_pcm_read_sc2d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_pcm_read_sc2d_def_void@
identifier F = pcm_read_sc2d;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_pcm_read_sc2d_def_void@
F << extract_pcm_read_sc2d_def_void.F;
P << extract_pcm_read_sc2d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_pcm_read_sc2d_decl@
type T;
identifier F = pcm_read_sc2d;
parameter list P;
@@
T F(P);

@script:python depends on extract_pcm_read_sc2d_decl@
F << extract_pcm_read_sc2d_decl.F;
T << extract_pcm_read_sc2d_decl.T;
P << extract_pcm_read_sc2d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_pcm_read_sc2d_decl_void@
identifier F = pcm_read_sc2d;
parameter list P;
@@
void F(P);

@script:python depends on extract_pcm_read_sc2d_decl_void@
F << extract_pcm_read_sc2d_decl_void.F;
P << extract_pcm_read_sc2d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: pcm_read_sc2f
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_pcm_read_sc2f_def@
type T;
identifier F = pcm_read_sc2f;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_pcm_read_sc2f_def@
F << remove_static_pcm_read_sc2f_def.F;
T << remove_static_pcm_read_sc2f_def.T;
P << remove_static_pcm_read_sc2f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_pcm_read_sc2f_def_void@
identifier F = pcm_read_sc2f;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_pcm_read_sc2f_def_void@
F << remove_static_pcm_read_sc2f_def_void.F;
P << remove_static_pcm_read_sc2f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_pcm_read_sc2f_decl@
type T;
identifier F = pcm_read_sc2f;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_pcm_read_sc2f_decl@
F << remove_static_pcm_read_sc2f_decl.F;
T << remove_static_pcm_read_sc2f_decl.T;
P << remove_static_pcm_read_sc2f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_pcm_read_sc2f_decl_void@
identifier F = pcm_read_sc2f;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_pcm_read_sc2f_decl_void@
F << remove_static_pcm_read_sc2f_decl_void.F;
P << remove_static_pcm_read_sc2f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_pcm_read_sc2f_def@
type T;
identifier F = pcm_read_sc2f;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_pcm_read_sc2f_def@
F << extract_pcm_read_sc2f_def.F;
T << extract_pcm_read_sc2f_def.T;
P << extract_pcm_read_sc2f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_pcm_read_sc2f_def_void@
identifier F = pcm_read_sc2f;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_pcm_read_sc2f_def_void@
F << extract_pcm_read_sc2f_def_void.F;
P << extract_pcm_read_sc2f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_pcm_read_sc2f_decl@
type T;
identifier F = pcm_read_sc2f;
parameter list P;
@@
T F(P);

@script:python depends on extract_pcm_read_sc2f_decl@
F << extract_pcm_read_sc2f_decl.F;
T << extract_pcm_read_sc2f_decl.T;
P << extract_pcm_read_sc2f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_pcm_read_sc2f_decl_void@
identifier F = pcm_read_sc2f;
parameter list P;
@@
void F(P);

@script:python depends on extract_pcm_read_sc2f_decl_void@
F << extract_pcm_read_sc2f_decl_void.F;
P << extract_pcm_read_sc2f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: pcm_read_sc2i
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_pcm_read_sc2i_def@
type T;
identifier F = pcm_read_sc2i;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_pcm_read_sc2i_def@
F << remove_static_pcm_read_sc2i_def.F;
T << remove_static_pcm_read_sc2i_def.T;
P << remove_static_pcm_read_sc2i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_pcm_read_sc2i_def_void@
identifier F = pcm_read_sc2i;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_pcm_read_sc2i_def_void@
F << remove_static_pcm_read_sc2i_def_void.F;
P << remove_static_pcm_read_sc2i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_pcm_read_sc2i_decl@
type T;
identifier F = pcm_read_sc2i;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_pcm_read_sc2i_decl@
F << remove_static_pcm_read_sc2i_decl.F;
T << remove_static_pcm_read_sc2i_decl.T;
P << remove_static_pcm_read_sc2i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_pcm_read_sc2i_decl_void@
identifier F = pcm_read_sc2i;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_pcm_read_sc2i_decl_void@
F << remove_static_pcm_read_sc2i_decl_void.F;
P << remove_static_pcm_read_sc2i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_pcm_read_sc2i_def@
type T;
identifier F = pcm_read_sc2i;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_pcm_read_sc2i_def@
F << extract_pcm_read_sc2i_def.F;
T << extract_pcm_read_sc2i_def.T;
P << extract_pcm_read_sc2i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_pcm_read_sc2i_def_void@
identifier F = pcm_read_sc2i;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_pcm_read_sc2i_def_void@
F << extract_pcm_read_sc2i_def_void.F;
P << extract_pcm_read_sc2i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_pcm_read_sc2i_decl@
type T;
identifier F = pcm_read_sc2i;
parameter list P;
@@
T F(P);

@script:python depends on extract_pcm_read_sc2i_decl@
F << extract_pcm_read_sc2i_decl.F;
T << extract_pcm_read_sc2i_decl.T;
P << extract_pcm_read_sc2i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_pcm_read_sc2i_decl_void@
identifier F = pcm_read_sc2i;
parameter list P;
@@
void F(P);

@script:python depends on extract_pcm_read_sc2i_decl_void@
F << extract_pcm_read_sc2i_decl_void.F;
P << extract_pcm_read_sc2i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: pcm_read_sc2s
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_pcm_read_sc2s_def@
type T;
identifier F = pcm_read_sc2s;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_pcm_read_sc2s_def@
F << remove_static_pcm_read_sc2s_def.F;
T << remove_static_pcm_read_sc2s_def.T;
P << remove_static_pcm_read_sc2s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_pcm_read_sc2s_def_void@
identifier F = pcm_read_sc2s;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_pcm_read_sc2s_def_void@
F << remove_static_pcm_read_sc2s_def_void.F;
P << remove_static_pcm_read_sc2s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_pcm_read_sc2s_decl@
type T;
identifier F = pcm_read_sc2s;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_pcm_read_sc2s_decl@
F << remove_static_pcm_read_sc2s_decl.F;
T << remove_static_pcm_read_sc2s_decl.T;
P << remove_static_pcm_read_sc2s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_pcm_read_sc2s_decl_void@
identifier F = pcm_read_sc2s;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_pcm_read_sc2s_decl_void@
F << remove_static_pcm_read_sc2s_decl_void.F;
P << remove_static_pcm_read_sc2s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_pcm_read_sc2s_def@
type T;
identifier F = pcm_read_sc2s;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_pcm_read_sc2s_def@
F << extract_pcm_read_sc2s_def.F;
T << extract_pcm_read_sc2s_def.T;
P << extract_pcm_read_sc2s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_pcm_read_sc2s_def_void@
identifier F = pcm_read_sc2s;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_pcm_read_sc2s_def_void@
F << extract_pcm_read_sc2s_def_void.F;
P << extract_pcm_read_sc2s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_pcm_read_sc2s_decl@
type T;
identifier F = pcm_read_sc2s;
parameter list P;
@@
T F(P);

@script:python depends on extract_pcm_read_sc2s_decl@
F << extract_pcm_read_sc2s_decl.F;
T << extract_pcm_read_sc2s_decl.T;
P << extract_pcm_read_sc2s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_pcm_read_sc2s_decl_void@
identifier F = pcm_read_sc2s;
parameter list P;
@@
void F(P);

@script:python depends on extract_pcm_read_sc2s_decl_void@
F << extract_pcm_read_sc2s_decl_void.F;
P << extract_pcm_read_sc2s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: pcm_read_uc2d
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_pcm_read_uc2d_def@
type T;
identifier F = pcm_read_uc2d;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_pcm_read_uc2d_def@
F << remove_static_pcm_read_uc2d_def.F;
T << remove_static_pcm_read_uc2d_def.T;
P << remove_static_pcm_read_uc2d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_pcm_read_uc2d_def_void@
identifier F = pcm_read_uc2d;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_pcm_read_uc2d_def_void@
F << remove_static_pcm_read_uc2d_def_void.F;
P << remove_static_pcm_read_uc2d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_pcm_read_uc2d_decl@
type T;
identifier F = pcm_read_uc2d;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_pcm_read_uc2d_decl@
F << remove_static_pcm_read_uc2d_decl.F;
T << remove_static_pcm_read_uc2d_decl.T;
P << remove_static_pcm_read_uc2d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_pcm_read_uc2d_decl_void@
identifier F = pcm_read_uc2d;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_pcm_read_uc2d_decl_void@
F << remove_static_pcm_read_uc2d_decl_void.F;
P << remove_static_pcm_read_uc2d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_pcm_read_uc2d_def@
type T;
identifier F = pcm_read_uc2d;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_pcm_read_uc2d_def@
F << extract_pcm_read_uc2d_def.F;
T << extract_pcm_read_uc2d_def.T;
P << extract_pcm_read_uc2d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_pcm_read_uc2d_def_void@
identifier F = pcm_read_uc2d;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_pcm_read_uc2d_def_void@
F << extract_pcm_read_uc2d_def_void.F;
P << extract_pcm_read_uc2d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_pcm_read_uc2d_decl@
type T;
identifier F = pcm_read_uc2d;
parameter list P;
@@
T F(P);

@script:python depends on extract_pcm_read_uc2d_decl@
F << extract_pcm_read_uc2d_decl.F;
T << extract_pcm_read_uc2d_decl.T;
P << extract_pcm_read_uc2d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_pcm_read_uc2d_decl_void@
identifier F = pcm_read_uc2d;
parameter list P;
@@
void F(P);

@script:python depends on extract_pcm_read_uc2d_decl_void@
F << extract_pcm_read_uc2d_decl_void.F;
P << extract_pcm_read_uc2d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: pcm_read_uc2f
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_pcm_read_uc2f_def@
type T;
identifier F = pcm_read_uc2f;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_pcm_read_uc2f_def@
F << remove_static_pcm_read_uc2f_def.F;
T << remove_static_pcm_read_uc2f_def.T;
P << remove_static_pcm_read_uc2f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_pcm_read_uc2f_def_void@
identifier F = pcm_read_uc2f;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_pcm_read_uc2f_def_void@
F << remove_static_pcm_read_uc2f_def_void.F;
P << remove_static_pcm_read_uc2f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_pcm_read_uc2f_decl@
type T;
identifier F = pcm_read_uc2f;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_pcm_read_uc2f_decl@
F << remove_static_pcm_read_uc2f_decl.F;
T << remove_static_pcm_read_uc2f_decl.T;
P << remove_static_pcm_read_uc2f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_pcm_read_uc2f_decl_void@
identifier F = pcm_read_uc2f;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_pcm_read_uc2f_decl_void@
F << remove_static_pcm_read_uc2f_decl_void.F;
P << remove_static_pcm_read_uc2f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_pcm_read_uc2f_def@
type T;
identifier F = pcm_read_uc2f;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_pcm_read_uc2f_def@
F << extract_pcm_read_uc2f_def.F;
T << extract_pcm_read_uc2f_def.T;
P << extract_pcm_read_uc2f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_pcm_read_uc2f_def_void@
identifier F = pcm_read_uc2f;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_pcm_read_uc2f_def_void@
F << extract_pcm_read_uc2f_def_void.F;
P << extract_pcm_read_uc2f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_pcm_read_uc2f_decl@
type T;
identifier F = pcm_read_uc2f;
parameter list P;
@@
T F(P);

@script:python depends on extract_pcm_read_uc2f_decl@
F << extract_pcm_read_uc2f_decl.F;
T << extract_pcm_read_uc2f_decl.T;
P << extract_pcm_read_uc2f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_pcm_read_uc2f_decl_void@
identifier F = pcm_read_uc2f;
parameter list P;
@@
void F(P);

@script:python depends on extract_pcm_read_uc2f_decl_void@
F << extract_pcm_read_uc2f_decl_void.F;
P << extract_pcm_read_uc2f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: pcm_read_uc2i
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_pcm_read_uc2i_def@
type T;
identifier F = pcm_read_uc2i;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_pcm_read_uc2i_def@
F << remove_static_pcm_read_uc2i_def.F;
T << remove_static_pcm_read_uc2i_def.T;
P << remove_static_pcm_read_uc2i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_pcm_read_uc2i_def_void@
identifier F = pcm_read_uc2i;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_pcm_read_uc2i_def_void@
F << remove_static_pcm_read_uc2i_def_void.F;
P << remove_static_pcm_read_uc2i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_pcm_read_uc2i_decl@
type T;
identifier F = pcm_read_uc2i;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_pcm_read_uc2i_decl@
F << remove_static_pcm_read_uc2i_decl.F;
T << remove_static_pcm_read_uc2i_decl.T;
P << remove_static_pcm_read_uc2i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_pcm_read_uc2i_decl_void@
identifier F = pcm_read_uc2i;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_pcm_read_uc2i_decl_void@
F << remove_static_pcm_read_uc2i_decl_void.F;
P << remove_static_pcm_read_uc2i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_pcm_read_uc2i_def@
type T;
identifier F = pcm_read_uc2i;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_pcm_read_uc2i_def@
F << extract_pcm_read_uc2i_def.F;
T << extract_pcm_read_uc2i_def.T;
P << extract_pcm_read_uc2i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_pcm_read_uc2i_def_void@
identifier F = pcm_read_uc2i;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_pcm_read_uc2i_def_void@
F << extract_pcm_read_uc2i_def_void.F;
P << extract_pcm_read_uc2i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_pcm_read_uc2i_decl@
type T;
identifier F = pcm_read_uc2i;
parameter list P;
@@
T F(P);

@script:python depends on extract_pcm_read_uc2i_decl@
F << extract_pcm_read_uc2i_decl.F;
T << extract_pcm_read_uc2i_decl.T;
P << extract_pcm_read_uc2i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_pcm_read_uc2i_decl_void@
identifier F = pcm_read_uc2i;
parameter list P;
@@
void F(P);

@script:python depends on extract_pcm_read_uc2i_decl_void@
F << extract_pcm_read_uc2i_decl_void.F;
P << extract_pcm_read_uc2i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: pcm_read_uc2s
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_pcm_read_uc2s_def@
type T;
identifier F = pcm_read_uc2s;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_pcm_read_uc2s_def@
F << remove_static_pcm_read_uc2s_def.F;
T << remove_static_pcm_read_uc2s_def.T;
P << remove_static_pcm_read_uc2s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_pcm_read_uc2s_def_void@
identifier F = pcm_read_uc2s;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_pcm_read_uc2s_def_void@
F << remove_static_pcm_read_uc2s_def_void.F;
P << remove_static_pcm_read_uc2s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_pcm_read_uc2s_decl@
type T;
identifier F = pcm_read_uc2s;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_pcm_read_uc2s_decl@
F << remove_static_pcm_read_uc2s_decl.F;
T << remove_static_pcm_read_uc2s_decl.T;
P << remove_static_pcm_read_uc2s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_pcm_read_uc2s_decl_void@
identifier F = pcm_read_uc2s;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_pcm_read_uc2s_decl_void@
F << remove_static_pcm_read_uc2s_decl_void.F;
P << remove_static_pcm_read_uc2s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_pcm_read_uc2s_def@
type T;
identifier F = pcm_read_uc2s;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_pcm_read_uc2s_def@
F << extract_pcm_read_uc2s_def.F;
T << extract_pcm_read_uc2s_def.T;
P << extract_pcm_read_uc2s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_pcm_read_uc2s_def_void@
identifier F = pcm_read_uc2s;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_pcm_read_uc2s_def_void@
F << extract_pcm_read_uc2s_def_void.F;
P << extract_pcm_read_uc2s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_pcm_read_uc2s_decl@
type T;
identifier F = pcm_read_uc2s;
parameter list P;
@@
T F(P);

@script:python depends on extract_pcm_read_uc2s_decl@
F << extract_pcm_read_uc2s_decl.F;
T << extract_pcm_read_uc2s_decl.T;
P << extract_pcm_read_uc2s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_pcm_read_uc2s_decl_void@
identifier F = pcm_read_uc2s;
parameter list P;
@@
void F(P);

@script:python depends on extract_pcm_read_uc2s_decl_void@
F << extract_pcm_read_uc2s_decl_void.F;
P << extract_pcm_read_uc2s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: pcm_write_d2bei
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_pcm_write_d2bei_def@
type T;
identifier F = pcm_write_d2bei;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_pcm_write_d2bei_def@
F << remove_static_pcm_write_d2bei_def.F;
T << remove_static_pcm_write_d2bei_def.T;
P << remove_static_pcm_write_d2bei_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_pcm_write_d2bei_def_void@
identifier F = pcm_write_d2bei;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_pcm_write_d2bei_def_void@
F << remove_static_pcm_write_d2bei_def_void.F;
P << remove_static_pcm_write_d2bei_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_pcm_write_d2bei_decl@
type T;
identifier F = pcm_write_d2bei;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_pcm_write_d2bei_decl@
F << remove_static_pcm_write_d2bei_decl.F;
T << remove_static_pcm_write_d2bei_decl.T;
P << remove_static_pcm_write_d2bei_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_pcm_write_d2bei_decl_void@
identifier F = pcm_write_d2bei;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_pcm_write_d2bei_decl_void@
F << remove_static_pcm_write_d2bei_decl_void.F;
P << remove_static_pcm_write_d2bei_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_pcm_write_d2bei_def@
type T;
identifier F = pcm_write_d2bei;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_pcm_write_d2bei_def@
F << extract_pcm_write_d2bei_def.F;
T << extract_pcm_write_d2bei_def.T;
P << extract_pcm_write_d2bei_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_pcm_write_d2bei_def_void@
identifier F = pcm_write_d2bei;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_pcm_write_d2bei_def_void@
F << extract_pcm_write_d2bei_def_void.F;
P << extract_pcm_write_d2bei_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_pcm_write_d2bei_decl@
type T;
identifier F = pcm_write_d2bei;
parameter list P;
@@
T F(P);

@script:python depends on extract_pcm_write_d2bei_decl@
F << extract_pcm_write_d2bei_decl.F;
T << extract_pcm_write_d2bei_decl.T;
P << extract_pcm_write_d2bei_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_pcm_write_d2bei_decl_void@
identifier F = pcm_write_d2bei;
parameter list P;
@@
void F(P);

@script:python depends on extract_pcm_write_d2bei_decl_void@
F << extract_pcm_write_d2bei_decl_void.F;
P << extract_pcm_write_d2bei_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: pcm_write_d2bes
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_pcm_write_d2bes_def@
type T;
identifier F = pcm_write_d2bes;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_pcm_write_d2bes_def@
F << remove_static_pcm_write_d2bes_def.F;
T << remove_static_pcm_write_d2bes_def.T;
P << remove_static_pcm_write_d2bes_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_pcm_write_d2bes_def_void@
identifier F = pcm_write_d2bes;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_pcm_write_d2bes_def_void@
F << remove_static_pcm_write_d2bes_def_void.F;
P << remove_static_pcm_write_d2bes_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_pcm_write_d2bes_decl@
type T;
identifier F = pcm_write_d2bes;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_pcm_write_d2bes_decl@
F << remove_static_pcm_write_d2bes_decl.F;
T << remove_static_pcm_write_d2bes_decl.T;
P << remove_static_pcm_write_d2bes_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_pcm_write_d2bes_decl_void@
identifier F = pcm_write_d2bes;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_pcm_write_d2bes_decl_void@
F << remove_static_pcm_write_d2bes_decl_void.F;
P << remove_static_pcm_write_d2bes_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_pcm_write_d2bes_def@
type T;
identifier F = pcm_write_d2bes;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_pcm_write_d2bes_def@
F << extract_pcm_write_d2bes_def.F;
T << extract_pcm_write_d2bes_def.T;
P << extract_pcm_write_d2bes_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_pcm_write_d2bes_def_void@
identifier F = pcm_write_d2bes;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_pcm_write_d2bes_def_void@
F << extract_pcm_write_d2bes_def_void.F;
P << extract_pcm_write_d2bes_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_pcm_write_d2bes_decl@
type T;
identifier F = pcm_write_d2bes;
parameter list P;
@@
T F(P);

@script:python depends on extract_pcm_write_d2bes_decl@
F << extract_pcm_write_d2bes_decl.F;
T << extract_pcm_write_d2bes_decl.T;
P << extract_pcm_write_d2bes_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_pcm_write_d2bes_decl_void@
identifier F = pcm_write_d2bes;
parameter list P;
@@
void F(P);

@script:python depends on extract_pcm_write_d2bes_decl_void@
F << extract_pcm_write_d2bes_decl_void.F;
P << extract_pcm_write_d2bes_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: pcm_write_d2bet
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_pcm_write_d2bet_def@
type T;
identifier F = pcm_write_d2bet;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_pcm_write_d2bet_def@
F << remove_static_pcm_write_d2bet_def.F;
T << remove_static_pcm_write_d2bet_def.T;
P << remove_static_pcm_write_d2bet_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_pcm_write_d2bet_def_void@
identifier F = pcm_write_d2bet;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_pcm_write_d2bet_def_void@
F << remove_static_pcm_write_d2bet_def_void.F;
P << remove_static_pcm_write_d2bet_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_pcm_write_d2bet_decl@
type T;
identifier F = pcm_write_d2bet;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_pcm_write_d2bet_decl@
F << remove_static_pcm_write_d2bet_decl.F;
T << remove_static_pcm_write_d2bet_decl.T;
P << remove_static_pcm_write_d2bet_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_pcm_write_d2bet_decl_void@
identifier F = pcm_write_d2bet;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_pcm_write_d2bet_decl_void@
F << remove_static_pcm_write_d2bet_decl_void.F;
P << remove_static_pcm_write_d2bet_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_pcm_write_d2bet_def@
type T;
identifier F = pcm_write_d2bet;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_pcm_write_d2bet_def@
F << extract_pcm_write_d2bet_def.F;
T << extract_pcm_write_d2bet_def.T;
P << extract_pcm_write_d2bet_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_pcm_write_d2bet_def_void@
identifier F = pcm_write_d2bet;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_pcm_write_d2bet_def_void@
F << extract_pcm_write_d2bet_def_void.F;
P << extract_pcm_write_d2bet_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_pcm_write_d2bet_decl@
type T;
identifier F = pcm_write_d2bet;
parameter list P;
@@
T F(P);

@script:python depends on extract_pcm_write_d2bet_decl@
F << extract_pcm_write_d2bet_decl.F;
T << extract_pcm_write_d2bet_decl.T;
P << extract_pcm_write_d2bet_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_pcm_write_d2bet_decl_void@
identifier F = pcm_write_d2bet;
parameter list P;
@@
void F(P);

@script:python depends on extract_pcm_write_d2bet_decl_void@
F << extract_pcm_write_d2bet_decl_void.F;
P << extract_pcm_write_d2bet_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: pcm_write_d2lei
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_pcm_write_d2lei_def@
type T;
identifier F = pcm_write_d2lei;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_pcm_write_d2lei_def@
F << remove_static_pcm_write_d2lei_def.F;
T << remove_static_pcm_write_d2lei_def.T;
P << remove_static_pcm_write_d2lei_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_pcm_write_d2lei_def_void@
identifier F = pcm_write_d2lei;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_pcm_write_d2lei_def_void@
F << remove_static_pcm_write_d2lei_def_void.F;
P << remove_static_pcm_write_d2lei_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_pcm_write_d2lei_decl@
type T;
identifier F = pcm_write_d2lei;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_pcm_write_d2lei_decl@
F << remove_static_pcm_write_d2lei_decl.F;
T << remove_static_pcm_write_d2lei_decl.T;
P << remove_static_pcm_write_d2lei_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_pcm_write_d2lei_decl_void@
identifier F = pcm_write_d2lei;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_pcm_write_d2lei_decl_void@
F << remove_static_pcm_write_d2lei_decl_void.F;
P << remove_static_pcm_write_d2lei_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_pcm_write_d2lei_def@
type T;
identifier F = pcm_write_d2lei;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_pcm_write_d2lei_def@
F << extract_pcm_write_d2lei_def.F;
T << extract_pcm_write_d2lei_def.T;
P << extract_pcm_write_d2lei_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_pcm_write_d2lei_def_void@
identifier F = pcm_write_d2lei;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_pcm_write_d2lei_def_void@
F << extract_pcm_write_d2lei_def_void.F;
P << extract_pcm_write_d2lei_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_pcm_write_d2lei_decl@
type T;
identifier F = pcm_write_d2lei;
parameter list P;
@@
T F(P);

@script:python depends on extract_pcm_write_d2lei_decl@
F << extract_pcm_write_d2lei_decl.F;
T << extract_pcm_write_d2lei_decl.T;
P << extract_pcm_write_d2lei_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_pcm_write_d2lei_decl_void@
identifier F = pcm_write_d2lei;
parameter list P;
@@
void F(P);

@script:python depends on extract_pcm_write_d2lei_decl_void@
F << extract_pcm_write_d2lei_decl_void.F;
P << extract_pcm_write_d2lei_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: pcm_write_d2les
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_pcm_write_d2les_def@
type T;
identifier F = pcm_write_d2les;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_pcm_write_d2les_def@
F << remove_static_pcm_write_d2les_def.F;
T << remove_static_pcm_write_d2les_def.T;
P << remove_static_pcm_write_d2les_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_pcm_write_d2les_def_void@
identifier F = pcm_write_d2les;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_pcm_write_d2les_def_void@
F << remove_static_pcm_write_d2les_def_void.F;
P << remove_static_pcm_write_d2les_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_pcm_write_d2les_decl@
type T;
identifier F = pcm_write_d2les;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_pcm_write_d2les_decl@
F << remove_static_pcm_write_d2les_decl.F;
T << remove_static_pcm_write_d2les_decl.T;
P << remove_static_pcm_write_d2les_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_pcm_write_d2les_decl_void@
identifier F = pcm_write_d2les;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_pcm_write_d2les_decl_void@
F << remove_static_pcm_write_d2les_decl_void.F;
P << remove_static_pcm_write_d2les_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_pcm_write_d2les_def@
type T;
identifier F = pcm_write_d2les;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_pcm_write_d2les_def@
F << extract_pcm_write_d2les_def.F;
T << extract_pcm_write_d2les_def.T;
P << extract_pcm_write_d2les_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_pcm_write_d2les_def_void@
identifier F = pcm_write_d2les;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_pcm_write_d2les_def_void@
F << extract_pcm_write_d2les_def_void.F;
P << extract_pcm_write_d2les_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_pcm_write_d2les_decl@
type T;
identifier F = pcm_write_d2les;
parameter list P;
@@
T F(P);

@script:python depends on extract_pcm_write_d2les_decl@
F << extract_pcm_write_d2les_decl.F;
T << extract_pcm_write_d2les_decl.T;
P << extract_pcm_write_d2les_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_pcm_write_d2les_decl_void@
identifier F = pcm_write_d2les;
parameter list P;
@@
void F(P);

@script:python depends on extract_pcm_write_d2les_decl_void@
F << extract_pcm_write_d2les_decl_void.F;
P << extract_pcm_write_d2les_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: pcm_write_d2let
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_pcm_write_d2let_def@
type T;
identifier F = pcm_write_d2let;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_pcm_write_d2let_def@
F << remove_static_pcm_write_d2let_def.F;
T << remove_static_pcm_write_d2let_def.T;
P << remove_static_pcm_write_d2let_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_pcm_write_d2let_def_void@
identifier F = pcm_write_d2let;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_pcm_write_d2let_def_void@
F << remove_static_pcm_write_d2let_def_void.F;
P << remove_static_pcm_write_d2let_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_pcm_write_d2let_decl@
type T;
identifier F = pcm_write_d2let;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_pcm_write_d2let_decl@
F << remove_static_pcm_write_d2let_decl.F;
T << remove_static_pcm_write_d2let_decl.T;
P << remove_static_pcm_write_d2let_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_pcm_write_d2let_decl_void@
identifier F = pcm_write_d2let;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_pcm_write_d2let_decl_void@
F << remove_static_pcm_write_d2let_decl_void.F;
P << remove_static_pcm_write_d2let_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_pcm_write_d2let_def@
type T;
identifier F = pcm_write_d2let;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_pcm_write_d2let_def@
F << extract_pcm_write_d2let_def.F;
T << extract_pcm_write_d2let_def.T;
P << extract_pcm_write_d2let_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_pcm_write_d2let_def_void@
identifier F = pcm_write_d2let;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_pcm_write_d2let_def_void@
F << extract_pcm_write_d2let_def_void.F;
P << extract_pcm_write_d2let_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_pcm_write_d2let_decl@
type T;
identifier F = pcm_write_d2let;
parameter list P;
@@
T F(P);

@script:python depends on extract_pcm_write_d2let_decl@
F << extract_pcm_write_d2let_decl.F;
T << extract_pcm_write_d2let_decl.T;
P << extract_pcm_write_d2let_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_pcm_write_d2let_decl_void@
identifier F = pcm_write_d2let;
parameter list P;
@@
void F(P);

@script:python depends on extract_pcm_write_d2let_decl_void@
F << extract_pcm_write_d2let_decl_void.F;
P << extract_pcm_write_d2let_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: pcm_write_d2sc
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_pcm_write_d2sc_def@
type T;
identifier F = pcm_write_d2sc;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_pcm_write_d2sc_def@
F << remove_static_pcm_write_d2sc_def.F;
T << remove_static_pcm_write_d2sc_def.T;
P << remove_static_pcm_write_d2sc_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_pcm_write_d2sc_def_void@
identifier F = pcm_write_d2sc;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_pcm_write_d2sc_def_void@
F << remove_static_pcm_write_d2sc_def_void.F;
P << remove_static_pcm_write_d2sc_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_pcm_write_d2sc_decl@
type T;
identifier F = pcm_write_d2sc;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_pcm_write_d2sc_decl@
F << remove_static_pcm_write_d2sc_decl.F;
T << remove_static_pcm_write_d2sc_decl.T;
P << remove_static_pcm_write_d2sc_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_pcm_write_d2sc_decl_void@
identifier F = pcm_write_d2sc;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_pcm_write_d2sc_decl_void@
F << remove_static_pcm_write_d2sc_decl_void.F;
P << remove_static_pcm_write_d2sc_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_pcm_write_d2sc_def@
type T;
identifier F = pcm_write_d2sc;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_pcm_write_d2sc_def@
F << extract_pcm_write_d2sc_def.F;
T << extract_pcm_write_d2sc_def.T;
P << extract_pcm_write_d2sc_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_pcm_write_d2sc_def_void@
identifier F = pcm_write_d2sc;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_pcm_write_d2sc_def_void@
F << extract_pcm_write_d2sc_def_void.F;
P << extract_pcm_write_d2sc_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_pcm_write_d2sc_decl@
type T;
identifier F = pcm_write_d2sc;
parameter list P;
@@
T F(P);

@script:python depends on extract_pcm_write_d2sc_decl@
F << extract_pcm_write_d2sc_decl.F;
T << extract_pcm_write_d2sc_decl.T;
P << extract_pcm_write_d2sc_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_pcm_write_d2sc_decl_void@
identifier F = pcm_write_d2sc;
parameter list P;
@@
void F(P);

@script:python depends on extract_pcm_write_d2sc_decl_void@
F << extract_pcm_write_d2sc_decl_void.F;
P << extract_pcm_write_d2sc_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: pcm_write_d2uc
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_pcm_write_d2uc_def@
type T;
identifier F = pcm_write_d2uc;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_pcm_write_d2uc_def@
F << remove_static_pcm_write_d2uc_def.F;
T << remove_static_pcm_write_d2uc_def.T;
P << remove_static_pcm_write_d2uc_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_pcm_write_d2uc_def_void@
identifier F = pcm_write_d2uc;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_pcm_write_d2uc_def_void@
F << remove_static_pcm_write_d2uc_def_void.F;
P << remove_static_pcm_write_d2uc_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_pcm_write_d2uc_decl@
type T;
identifier F = pcm_write_d2uc;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_pcm_write_d2uc_decl@
F << remove_static_pcm_write_d2uc_decl.F;
T << remove_static_pcm_write_d2uc_decl.T;
P << remove_static_pcm_write_d2uc_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_pcm_write_d2uc_decl_void@
identifier F = pcm_write_d2uc;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_pcm_write_d2uc_decl_void@
F << remove_static_pcm_write_d2uc_decl_void.F;
P << remove_static_pcm_write_d2uc_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_pcm_write_d2uc_def@
type T;
identifier F = pcm_write_d2uc;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_pcm_write_d2uc_def@
F << extract_pcm_write_d2uc_def.F;
T << extract_pcm_write_d2uc_def.T;
P << extract_pcm_write_d2uc_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_pcm_write_d2uc_def_void@
identifier F = pcm_write_d2uc;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_pcm_write_d2uc_def_void@
F << extract_pcm_write_d2uc_def_void.F;
P << extract_pcm_write_d2uc_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_pcm_write_d2uc_decl@
type T;
identifier F = pcm_write_d2uc;
parameter list P;
@@
T F(P);

@script:python depends on extract_pcm_write_d2uc_decl@
F << extract_pcm_write_d2uc_decl.F;
T << extract_pcm_write_d2uc_decl.T;
P << extract_pcm_write_d2uc_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_pcm_write_d2uc_decl_void@
identifier F = pcm_write_d2uc;
parameter list P;
@@
void F(P);

@script:python depends on extract_pcm_write_d2uc_decl_void@
F << extract_pcm_write_d2uc_decl_void.F;
P << extract_pcm_write_d2uc_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: pcm_write_f2bei
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_pcm_write_f2bei_def@
type T;
identifier F = pcm_write_f2bei;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_pcm_write_f2bei_def@
F << remove_static_pcm_write_f2bei_def.F;
T << remove_static_pcm_write_f2bei_def.T;
P << remove_static_pcm_write_f2bei_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_pcm_write_f2bei_def_void@
identifier F = pcm_write_f2bei;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_pcm_write_f2bei_def_void@
F << remove_static_pcm_write_f2bei_def_void.F;
P << remove_static_pcm_write_f2bei_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_pcm_write_f2bei_decl@
type T;
identifier F = pcm_write_f2bei;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_pcm_write_f2bei_decl@
F << remove_static_pcm_write_f2bei_decl.F;
T << remove_static_pcm_write_f2bei_decl.T;
P << remove_static_pcm_write_f2bei_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_pcm_write_f2bei_decl_void@
identifier F = pcm_write_f2bei;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_pcm_write_f2bei_decl_void@
F << remove_static_pcm_write_f2bei_decl_void.F;
P << remove_static_pcm_write_f2bei_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_pcm_write_f2bei_def@
type T;
identifier F = pcm_write_f2bei;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_pcm_write_f2bei_def@
F << extract_pcm_write_f2bei_def.F;
T << extract_pcm_write_f2bei_def.T;
P << extract_pcm_write_f2bei_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_pcm_write_f2bei_def_void@
identifier F = pcm_write_f2bei;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_pcm_write_f2bei_def_void@
F << extract_pcm_write_f2bei_def_void.F;
P << extract_pcm_write_f2bei_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_pcm_write_f2bei_decl@
type T;
identifier F = pcm_write_f2bei;
parameter list P;
@@
T F(P);

@script:python depends on extract_pcm_write_f2bei_decl@
F << extract_pcm_write_f2bei_decl.F;
T << extract_pcm_write_f2bei_decl.T;
P << extract_pcm_write_f2bei_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_pcm_write_f2bei_decl_void@
identifier F = pcm_write_f2bei;
parameter list P;
@@
void F(P);

@script:python depends on extract_pcm_write_f2bei_decl_void@
F << extract_pcm_write_f2bei_decl_void.F;
P << extract_pcm_write_f2bei_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: pcm_write_f2bes
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_pcm_write_f2bes_def@
type T;
identifier F = pcm_write_f2bes;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_pcm_write_f2bes_def@
F << remove_static_pcm_write_f2bes_def.F;
T << remove_static_pcm_write_f2bes_def.T;
P << remove_static_pcm_write_f2bes_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_pcm_write_f2bes_def_void@
identifier F = pcm_write_f2bes;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_pcm_write_f2bes_def_void@
F << remove_static_pcm_write_f2bes_def_void.F;
P << remove_static_pcm_write_f2bes_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_pcm_write_f2bes_decl@
type T;
identifier F = pcm_write_f2bes;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_pcm_write_f2bes_decl@
F << remove_static_pcm_write_f2bes_decl.F;
T << remove_static_pcm_write_f2bes_decl.T;
P << remove_static_pcm_write_f2bes_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_pcm_write_f2bes_decl_void@
identifier F = pcm_write_f2bes;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_pcm_write_f2bes_decl_void@
F << remove_static_pcm_write_f2bes_decl_void.F;
P << remove_static_pcm_write_f2bes_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_pcm_write_f2bes_def@
type T;
identifier F = pcm_write_f2bes;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_pcm_write_f2bes_def@
F << extract_pcm_write_f2bes_def.F;
T << extract_pcm_write_f2bes_def.T;
P << extract_pcm_write_f2bes_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_pcm_write_f2bes_def_void@
identifier F = pcm_write_f2bes;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_pcm_write_f2bes_def_void@
F << extract_pcm_write_f2bes_def_void.F;
P << extract_pcm_write_f2bes_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_pcm_write_f2bes_decl@
type T;
identifier F = pcm_write_f2bes;
parameter list P;
@@
T F(P);

@script:python depends on extract_pcm_write_f2bes_decl@
F << extract_pcm_write_f2bes_decl.F;
T << extract_pcm_write_f2bes_decl.T;
P << extract_pcm_write_f2bes_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_pcm_write_f2bes_decl_void@
identifier F = pcm_write_f2bes;
parameter list P;
@@
void F(P);

@script:python depends on extract_pcm_write_f2bes_decl_void@
F << extract_pcm_write_f2bes_decl_void.F;
P << extract_pcm_write_f2bes_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: pcm_write_f2bet
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_pcm_write_f2bet_def@
type T;
identifier F = pcm_write_f2bet;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_pcm_write_f2bet_def@
F << remove_static_pcm_write_f2bet_def.F;
T << remove_static_pcm_write_f2bet_def.T;
P << remove_static_pcm_write_f2bet_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_pcm_write_f2bet_def_void@
identifier F = pcm_write_f2bet;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_pcm_write_f2bet_def_void@
F << remove_static_pcm_write_f2bet_def_void.F;
P << remove_static_pcm_write_f2bet_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_pcm_write_f2bet_decl@
type T;
identifier F = pcm_write_f2bet;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_pcm_write_f2bet_decl@
F << remove_static_pcm_write_f2bet_decl.F;
T << remove_static_pcm_write_f2bet_decl.T;
P << remove_static_pcm_write_f2bet_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_pcm_write_f2bet_decl_void@
identifier F = pcm_write_f2bet;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_pcm_write_f2bet_decl_void@
F << remove_static_pcm_write_f2bet_decl_void.F;
P << remove_static_pcm_write_f2bet_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_pcm_write_f2bet_def@
type T;
identifier F = pcm_write_f2bet;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_pcm_write_f2bet_def@
F << extract_pcm_write_f2bet_def.F;
T << extract_pcm_write_f2bet_def.T;
P << extract_pcm_write_f2bet_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_pcm_write_f2bet_def_void@
identifier F = pcm_write_f2bet;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_pcm_write_f2bet_def_void@
F << extract_pcm_write_f2bet_def_void.F;
P << extract_pcm_write_f2bet_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_pcm_write_f2bet_decl@
type T;
identifier F = pcm_write_f2bet;
parameter list P;
@@
T F(P);

@script:python depends on extract_pcm_write_f2bet_decl@
F << extract_pcm_write_f2bet_decl.F;
T << extract_pcm_write_f2bet_decl.T;
P << extract_pcm_write_f2bet_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_pcm_write_f2bet_decl_void@
identifier F = pcm_write_f2bet;
parameter list P;
@@
void F(P);

@script:python depends on extract_pcm_write_f2bet_decl_void@
F << extract_pcm_write_f2bet_decl_void.F;
P << extract_pcm_write_f2bet_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: pcm_write_f2lei
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_pcm_write_f2lei_def@
type T;
identifier F = pcm_write_f2lei;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_pcm_write_f2lei_def@
F << remove_static_pcm_write_f2lei_def.F;
T << remove_static_pcm_write_f2lei_def.T;
P << remove_static_pcm_write_f2lei_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_pcm_write_f2lei_def_void@
identifier F = pcm_write_f2lei;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_pcm_write_f2lei_def_void@
F << remove_static_pcm_write_f2lei_def_void.F;
P << remove_static_pcm_write_f2lei_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_pcm_write_f2lei_decl@
type T;
identifier F = pcm_write_f2lei;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_pcm_write_f2lei_decl@
F << remove_static_pcm_write_f2lei_decl.F;
T << remove_static_pcm_write_f2lei_decl.T;
P << remove_static_pcm_write_f2lei_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_pcm_write_f2lei_decl_void@
identifier F = pcm_write_f2lei;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_pcm_write_f2lei_decl_void@
F << remove_static_pcm_write_f2lei_decl_void.F;
P << remove_static_pcm_write_f2lei_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_pcm_write_f2lei_def@
type T;
identifier F = pcm_write_f2lei;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_pcm_write_f2lei_def@
F << extract_pcm_write_f2lei_def.F;
T << extract_pcm_write_f2lei_def.T;
P << extract_pcm_write_f2lei_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_pcm_write_f2lei_def_void@
identifier F = pcm_write_f2lei;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_pcm_write_f2lei_def_void@
F << extract_pcm_write_f2lei_def_void.F;
P << extract_pcm_write_f2lei_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_pcm_write_f2lei_decl@
type T;
identifier F = pcm_write_f2lei;
parameter list P;
@@
T F(P);

@script:python depends on extract_pcm_write_f2lei_decl@
F << extract_pcm_write_f2lei_decl.F;
T << extract_pcm_write_f2lei_decl.T;
P << extract_pcm_write_f2lei_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_pcm_write_f2lei_decl_void@
identifier F = pcm_write_f2lei;
parameter list P;
@@
void F(P);

@script:python depends on extract_pcm_write_f2lei_decl_void@
F << extract_pcm_write_f2lei_decl_void.F;
P << extract_pcm_write_f2lei_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: pcm_write_f2les
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_pcm_write_f2les_def@
type T;
identifier F = pcm_write_f2les;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_pcm_write_f2les_def@
F << remove_static_pcm_write_f2les_def.F;
T << remove_static_pcm_write_f2les_def.T;
P << remove_static_pcm_write_f2les_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_pcm_write_f2les_def_void@
identifier F = pcm_write_f2les;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_pcm_write_f2les_def_void@
F << remove_static_pcm_write_f2les_def_void.F;
P << remove_static_pcm_write_f2les_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_pcm_write_f2les_decl@
type T;
identifier F = pcm_write_f2les;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_pcm_write_f2les_decl@
F << remove_static_pcm_write_f2les_decl.F;
T << remove_static_pcm_write_f2les_decl.T;
P << remove_static_pcm_write_f2les_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_pcm_write_f2les_decl_void@
identifier F = pcm_write_f2les;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_pcm_write_f2les_decl_void@
F << remove_static_pcm_write_f2les_decl_void.F;
P << remove_static_pcm_write_f2les_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_pcm_write_f2les_def@
type T;
identifier F = pcm_write_f2les;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_pcm_write_f2les_def@
F << extract_pcm_write_f2les_def.F;
T << extract_pcm_write_f2les_def.T;
P << extract_pcm_write_f2les_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_pcm_write_f2les_def_void@
identifier F = pcm_write_f2les;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_pcm_write_f2les_def_void@
F << extract_pcm_write_f2les_def_void.F;
P << extract_pcm_write_f2les_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_pcm_write_f2les_decl@
type T;
identifier F = pcm_write_f2les;
parameter list P;
@@
T F(P);

@script:python depends on extract_pcm_write_f2les_decl@
F << extract_pcm_write_f2les_decl.F;
T << extract_pcm_write_f2les_decl.T;
P << extract_pcm_write_f2les_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_pcm_write_f2les_decl_void@
identifier F = pcm_write_f2les;
parameter list P;
@@
void F(P);

@script:python depends on extract_pcm_write_f2les_decl_void@
F << extract_pcm_write_f2les_decl_void.F;
P << extract_pcm_write_f2les_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: pcm_write_f2let
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_pcm_write_f2let_def@
type T;
identifier F = pcm_write_f2let;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_pcm_write_f2let_def@
F << remove_static_pcm_write_f2let_def.F;
T << remove_static_pcm_write_f2let_def.T;
P << remove_static_pcm_write_f2let_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_pcm_write_f2let_def_void@
identifier F = pcm_write_f2let;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_pcm_write_f2let_def_void@
F << remove_static_pcm_write_f2let_def_void.F;
P << remove_static_pcm_write_f2let_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_pcm_write_f2let_decl@
type T;
identifier F = pcm_write_f2let;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_pcm_write_f2let_decl@
F << remove_static_pcm_write_f2let_decl.F;
T << remove_static_pcm_write_f2let_decl.T;
P << remove_static_pcm_write_f2let_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_pcm_write_f2let_decl_void@
identifier F = pcm_write_f2let;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_pcm_write_f2let_decl_void@
F << remove_static_pcm_write_f2let_decl_void.F;
P << remove_static_pcm_write_f2let_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_pcm_write_f2let_def@
type T;
identifier F = pcm_write_f2let;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_pcm_write_f2let_def@
F << extract_pcm_write_f2let_def.F;
T << extract_pcm_write_f2let_def.T;
P << extract_pcm_write_f2let_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_pcm_write_f2let_def_void@
identifier F = pcm_write_f2let;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_pcm_write_f2let_def_void@
F << extract_pcm_write_f2let_def_void.F;
P << extract_pcm_write_f2let_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_pcm_write_f2let_decl@
type T;
identifier F = pcm_write_f2let;
parameter list P;
@@
T F(P);

@script:python depends on extract_pcm_write_f2let_decl@
F << extract_pcm_write_f2let_decl.F;
T << extract_pcm_write_f2let_decl.T;
P << extract_pcm_write_f2let_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_pcm_write_f2let_decl_void@
identifier F = pcm_write_f2let;
parameter list P;
@@
void F(P);

@script:python depends on extract_pcm_write_f2let_decl_void@
F << extract_pcm_write_f2let_decl_void.F;
P << extract_pcm_write_f2let_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: pcm_write_f2sc
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_pcm_write_f2sc_def@
type T;
identifier F = pcm_write_f2sc;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_pcm_write_f2sc_def@
F << remove_static_pcm_write_f2sc_def.F;
T << remove_static_pcm_write_f2sc_def.T;
P << remove_static_pcm_write_f2sc_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_pcm_write_f2sc_def_void@
identifier F = pcm_write_f2sc;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_pcm_write_f2sc_def_void@
F << remove_static_pcm_write_f2sc_def_void.F;
P << remove_static_pcm_write_f2sc_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_pcm_write_f2sc_decl@
type T;
identifier F = pcm_write_f2sc;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_pcm_write_f2sc_decl@
F << remove_static_pcm_write_f2sc_decl.F;
T << remove_static_pcm_write_f2sc_decl.T;
P << remove_static_pcm_write_f2sc_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_pcm_write_f2sc_decl_void@
identifier F = pcm_write_f2sc;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_pcm_write_f2sc_decl_void@
F << remove_static_pcm_write_f2sc_decl_void.F;
P << remove_static_pcm_write_f2sc_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_pcm_write_f2sc_def@
type T;
identifier F = pcm_write_f2sc;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_pcm_write_f2sc_def@
F << extract_pcm_write_f2sc_def.F;
T << extract_pcm_write_f2sc_def.T;
P << extract_pcm_write_f2sc_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_pcm_write_f2sc_def_void@
identifier F = pcm_write_f2sc;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_pcm_write_f2sc_def_void@
F << extract_pcm_write_f2sc_def_void.F;
P << extract_pcm_write_f2sc_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_pcm_write_f2sc_decl@
type T;
identifier F = pcm_write_f2sc;
parameter list P;
@@
T F(P);

@script:python depends on extract_pcm_write_f2sc_decl@
F << extract_pcm_write_f2sc_decl.F;
T << extract_pcm_write_f2sc_decl.T;
P << extract_pcm_write_f2sc_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_pcm_write_f2sc_decl_void@
identifier F = pcm_write_f2sc;
parameter list P;
@@
void F(P);

@script:python depends on extract_pcm_write_f2sc_decl_void@
F << extract_pcm_write_f2sc_decl_void.F;
P << extract_pcm_write_f2sc_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: pcm_write_f2uc
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_pcm_write_f2uc_def@
type T;
identifier F = pcm_write_f2uc;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_pcm_write_f2uc_def@
F << remove_static_pcm_write_f2uc_def.F;
T << remove_static_pcm_write_f2uc_def.T;
P << remove_static_pcm_write_f2uc_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_pcm_write_f2uc_def_void@
identifier F = pcm_write_f2uc;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_pcm_write_f2uc_def_void@
F << remove_static_pcm_write_f2uc_def_void.F;
P << remove_static_pcm_write_f2uc_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_pcm_write_f2uc_decl@
type T;
identifier F = pcm_write_f2uc;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_pcm_write_f2uc_decl@
F << remove_static_pcm_write_f2uc_decl.F;
T << remove_static_pcm_write_f2uc_decl.T;
P << remove_static_pcm_write_f2uc_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_pcm_write_f2uc_decl_void@
identifier F = pcm_write_f2uc;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_pcm_write_f2uc_decl_void@
F << remove_static_pcm_write_f2uc_decl_void.F;
P << remove_static_pcm_write_f2uc_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_pcm_write_f2uc_def@
type T;
identifier F = pcm_write_f2uc;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_pcm_write_f2uc_def@
F << extract_pcm_write_f2uc_def.F;
T << extract_pcm_write_f2uc_def.T;
P << extract_pcm_write_f2uc_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_pcm_write_f2uc_def_void@
identifier F = pcm_write_f2uc;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_pcm_write_f2uc_def_void@
F << extract_pcm_write_f2uc_def_void.F;
P << extract_pcm_write_f2uc_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_pcm_write_f2uc_decl@
type T;
identifier F = pcm_write_f2uc;
parameter list P;
@@
T F(P);

@script:python depends on extract_pcm_write_f2uc_decl@
F << extract_pcm_write_f2uc_decl.F;
T << extract_pcm_write_f2uc_decl.T;
P << extract_pcm_write_f2uc_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_pcm_write_f2uc_decl_void@
identifier F = pcm_write_f2uc;
parameter list P;
@@
void F(P);

@script:python depends on extract_pcm_write_f2uc_decl_void@
F << extract_pcm_write_f2uc_decl_void.F;
P << extract_pcm_write_f2uc_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: pcm_write_i2bei
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_pcm_write_i2bei_def@
type T;
identifier F = pcm_write_i2bei;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_pcm_write_i2bei_def@
F << remove_static_pcm_write_i2bei_def.F;
T << remove_static_pcm_write_i2bei_def.T;
P << remove_static_pcm_write_i2bei_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_pcm_write_i2bei_def_void@
identifier F = pcm_write_i2bei;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_pcm_write_i2bei_def_void@
F << remove_static_pcm_write_i2bei_def_void.F;
P << remove_static_pcm_write_i2bei_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_pcm_write_i2bei_decl@
type T;
identifier F = pcm_write_i2bei;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_pcm_write_i2bei_decl@
F << remove_static_pcm_write_i2bei_decl.F;
T << remove_static_pcm_write_i2bei_decl.T;
P << remove_static_pcm_write_i2bei_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_pcm_write_i2bei_decl_void@
identifier F = pcm_write_i2bei;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_pcm_write_i2bei_decl_void@
F << remove_static_pcm_write_i2bei_decl_void.F;
P << remove_static_pcm_write_i2bei_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_pcm_write_i2bei_def@
type T;
identifier F = pcm_write_i2bei;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_pcm_write_i2bei_def@
F << extract_pcm_write_i2bei_def.F;
T << extract_pcm_write_i2bei_def.T;
P << extract_pcm_write_i2bei_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_pcm_write_i2bei_def_void@
identifier F = pcm_write_i2bei;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_pcm_write_i2bei_def_void@
F << extract_pcm_write_i2bei_def_void.F;
P << extract_pcm_write_i2bei_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_pcm_write_i2bei_decl@
type T;
identifier F = pcm_write_i2bei;
parameter list P;
@@
T F(P);

@script:python depends on extract_pcm_write_i2bei_decl@
F << extract_pcm_write_i2bei_decl.F;
T << extract_pcm_write_i2bei_decl.T;
P << extract_pcm_write_i2bei_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_pcm_write_i2bei_decl_void@
identifier F = pcm_write_i2bei;
parameter list P;
@@
void F(P);

@script:python depends on extract_pcm_write_i2bei_decl_void@
F << extract_pcm_write_i2bei_decl_void.F;
P << extract_pcm_write_i2bei_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: pcm_write_i2bes
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_pcm_write_i2bes_def@
type T;
identifier F = pcm_write_i2bes;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_pcm_write_i2bes_def@
F << remove_static_pcm_write_i2bes_def.F;
T << remove_static_pcm_write_i2bes_def.T;
P << remove_static_pcm_write_i2bes_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_pcm_write_i2bes_def_void@
identifier F = pcm_write_i2bes;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_pcm_write_i2bes_def_void@
F << remove_static_pcm_write_i2bes_def_void.F;
P << remove_static_pcm_write_i2bes_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_pcm_write_i2bes_decl@
type T;
identifier F = pcm_write_i2bes;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_pcm_write_i2bes_decl@
F << remove_static_pcm_write_i2bes_decl.F;
T << remove_static_pcm_write_i2bes_decl.T;
P << remove_static_pcm_write_i2bes_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_pcm_write_i2bes_decl_void@
identifier F = pcm_write_i2bes;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_pcm_write_i2bes_decl_void@
F << remove_static_pcm_write_i2bes_decl_void.F;
P << remove_static_pcm_write_i2bes_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_pcm_write_i2bes_def@
type T;
identifier F = pcm_write_i2bes;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_pcm_write_i2bes_def@
F << extract_pcm_write_i2bes_def.F;
T << extract_pcm_write_i2bes_def.T;
P << extract_pcm_write_i2bes_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_pcm_write_i2bes_def_void@
identifier F = pcm_write_i2bes;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_pcm_write_i2bes_def_void@
F << extract_pcm_write_i2bes_def_void.F;
P << extract_pcm_write_i2bes_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_pcm_write_i2bes_decl@
type T;
identifier F = pcm_write_i2bes;
parameter list P;
@@
T F(P);

@script:python depends on extract_pcm_write_i2bes_decl@
F << extract_pcm_write_i2bes_decl.F;
T << extract_pcm_write_i2bes_decl.T;
P << extract_pcm_write_i2bes_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_pcm_write_i2bes_decl_void@
identifier F = pcm_write_i2bes;
parameter list P;
@@
void F(P);

@script:python depends on extract_pcm_write_i2bes_decl_void@
F << extract_pcm_write_i2bes_decl_void.F;
P << extract_pcm_write_i2bes_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: pcm_write_i2bet
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_pcm_write_i2bet_def@
type T;
identifier F = pcm_write_i2bet;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_pcm_write_i2bet_def@
F << remove_static_pcm_write_i2bet_def.F;
T << remove_static_pcm_write_i2bet_def.T;
P << remove_static_pcm_write_i2bet_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_pcm_write_i2bet_def_void@
identifier F = pcm_write_i2bet;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_pcm_write_i2bet_def_void@
F << remove_static_pcm_write_i2bet_def_void.F;
P << remove_static_pcm_write_i2bet_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_pcm_write_i2bet_decl@
type T;
identifier F = pcm_write_i2bet;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_pcm_write_i2bet_decl@
F << remove_static_pcm_write_i2bet_decl.F;
T << remove_static_pcm_write_i2bet_decl.T;
P << remove_static_pcm_write_i2bet_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_pcm_write_i2bet_decl_void@
identifier F = pcm_write_i2bet;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_pcm_write_i2bet_decl_void@
F << remove_static_pcm_write_i2bet_decl_void.F;
P << remove_static_pcm_write_i2bet_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_pcm_write_i2bet_def@
type T;
identifier F = pcm_write_i2bet;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_pcm_write_i2bet_def@
F << extract_pcm_write_i2bet_def.F;
T << extract_pcm_write_i2bet_def.T;
P << extract_pcm_write_i2bet_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_pcm_write_i2bet_def_void@
identifier F = pcm_write_i2bet;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_pcm_write_i2bet_def_void@
F << extract_pcm_write_i2bet_def_void.F;
P << extract_pcm_write_i2bet_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_pcm_write_i2bet_decl@
type T;
identifier F = pcm_write_i2bet;
parameter list P;
@@
T F(P);

@script:python depends on extract_pcm_write_i2bet_decl@
F << extract_pcm_write_i2bet_decl.F;
T << extract_pcm_write_i2bet_decl.T;
P << extract_pcm_write_i2bet_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_pcm_write_i2bet_decl_void@
identifier F = pcm_write_i2bet;
parameter list P;
@@
void F(P);

@script:python depends on extract_pcm_write_i2bet_decl_void@
F << extract_pcm_write_i2bet_decl_void.F;
P << extract_pcm_write_i2bet_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: pcm_write_i2lei
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_pcm_write_i2lei_def@
type T;
identifier F = pcm_write_i2lei;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_pcm_write_i2lei_def@
F << remove_static_pcm_write_i2lei_def.F;
T << remove_static_pcm_write_i2lei_def.T;
P << remove_static_pcm_write_i2lei_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_pcm_write_i2lei_def_void@
identifier F = pcm_write_i2lei;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_pcm_write_i2lei_def_void@
F << remove_static_pcm_write_i2lei_def_void.F;
P << remove_static_pcm_write_i2lei_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_pcm_write_i2lei_decl@
type T;
identifier F = pcm_write_i2lei;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_pcm_write_i2lei_decl@
F << remove_static_pcm_write_i2lei_decl.F;
T << remove_static_pcm_write_i2lei_decl.T;
P << remove_static_pcm_write_i2lei_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_pcm_write_i2lei_decl_void@
identifier F = pcm_write_i2lei;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_pcm_write_i2lei_decl_void@
F << remove_static_pcm_write_i2lei_decl_void.F;
P << remove_static_pcm_write_i2lei_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_pcm_write_i2lei_def@
type T;
identifier F = pcm_write_i2lei;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_pcm_write_i2lei_def@
F << extract_pcm_write_i2lei_def.F;
T << extract_pcm_write_i2lei_def.T;
P << extract_pcm_write_i2lei_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_pcm_write_i2lei_def_void@
identifier F = pcm_write_i2lei;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_pcm_write_i2lei_def_void@
F << extract_pcm_write_i2lei_def_void.F;
P << extract_pcm_write_i2lei_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_pcm_write_i2lei_decl@
type T;
identifier F = pcm_write_i2lei;
parameter list P;
@@
T F(P);

@script:python depends on extract_pcm_write_i2lei_decl@
F << extract_pcm_write_i2lei_decl.F;
T << extract_pcm_write_i2lei_decl.T;
P << extract_pcm_write_i2lei_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_pcm_write_i2lei_decl_void@
identifier F = pcm_write_i2lei;
parameter list P;
@@
void F(P);

@script:python depends on extract_pcm_write_i2lei_decl_void@
F << extract_pcm_write_i2lei_decl_void.F;
P << extract_pcm_write_i2lei_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: pcm_write_i2les
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_pcm_write_i2les_def@
type T;
identifier F = pcm_write_i2les;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_pcm_write_i2les_def@
F << remove_static_pcm_write_i2les_def.F;
T << remove_static_pcm_write_i2les_def.T;
P << remove_static_pcm_write_i2les_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_pcm_write_i2les_def_void@
identifier F = pcm_write_i2les;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_pcm_write_i2les_def_void@
F << remove_static_pcm_write_i2les_def_void.F;
P << remove_static_pcm_write_i2les_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_pcm_write_i2les_decl@
type T;
identifier F = pcm_write_i2les;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_pcm_write_i2les_decl@
F << remove_static_pcm_write_i2les_decl.F;
T << remove_static_pcm_write_i2les_decl.T;
P << remove_static_pcm_write_i2les_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_pcm_write_i2les_decl_void@
identifier F = pcm_write_i2les;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_pcm_write_i2les_decl_void@
F << remove_static_pcm_write_i2les_decl_void.F;
P << remove_static_pcm_write_i2les_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_pcm_write_i2les_def@
type T;
identifier F = pcm_write_i2les;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_pcm_write_i2les_def@
F << extract_pcm_write_i2les_def.F;
T << extract_pcm_write_i2les_def.T;
P << extract_pcm_write_i2les_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_pcm_write_i2les_def_void@
identifier F = pcm_write_i2les;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_pcm_write_i2les_def_void@
F << extract_pcm_write_i2les_def_void.F;
P << extract_pcm_write_i2les_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_pcm_write_i2les_decl@
type T;
identifier F = pcm_write_i2les;
parameter list P;
@@
T F(P);

@script:python depends on extract_pcm_write_i2les_decl@
F << extract_pcm_write_i2les_decl.F;
T << extract_pcm_write_i2les_decl.T;
P << extract_pcm_write_i2les_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_pcm_write_i2les_decl_void@
identifier F = pcm_write_i2les;
parameter list P;
@@
void F(P);

@script:python depends on extract_pcm_write_i2les_decl_void@
F << extract_pcm_write_i2les_decl_void.F;
P << extract_pcm_write_i2les_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: pcm_write_i2let
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_pcm_write_i2let_def@
type T;
identifier F = pcm_write_i2let;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_pcm_write_i2let_def@
F << remove_static_pcm_write_i2let_def.F;
T << remove_static_pcm_write_i2let_def.T;
P << remove_static_pcm_write_i2let_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_pcm_write_i2let_def_void@
identifier F = pcm_write_i2let;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_pcm_write_i2let_def_void@
F << remove_static_pcm_write_i2let_def_void.F;
P << remove_static_pcm_write_i2let_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_pcm_write_i2let_decl@
type T;
identifier F = pcm_write_i2let;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_pcm_write_i2let_decl@
F << remove_static_pcm_write_i2let_decl.F;
T << remove_static_pcm_write_i2let_decl.T;
P << remove_static_pcm_write_i2let_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_pcm_write_i2let_decl_void@
identifier F = pcm_write_i2let;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_pcm_write_i2let_decl_void@
F << remove_static_pcm_write_i2let_decl_void.F;
P << remove_static_pcm_write_i2let_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_pcm_write_i2let_def@
type T;
identifier F = pcm_write_i2let;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_pcm_write_i2let_def@
F << extract_pcm_write_i2let_def.F;
T << extract_pcm_write_i2let_def.T;
P << extract_pcm_write_i2let_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_pcm_write_i2let_def_void@
identifier F = pcm_write_i2let;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_pcm_write_i2let_def_void@
F << extract_pcm_write_i2let_def_void.F;
P << extract_pcm_write_i2let_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_pcm_write_i2let_decl@
type T;
identifier F = pcm_write_i2let;
parameter list P;
@@
T F(P);

@script:python depends on extract_pcm_write_i2let_decl@
F << extract_pcm_write_i2let_decl.F;
T << extract_pcm_write_i2let_decl.T;
P << extract_pcm_write_i2let_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_pcm_write_i2let_decl_void@
identifier F = pcm_write_i2let;
parameter list P;
@@
void F(P);

@script:python depends on extract_pcm_write_i2let_decl_void@
F << extract_pcm_write_i2let_decl_void.F;
P << extract_pcm_write_i2let_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: pcm_write_i2sc
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_pcm_write_i2sc_def@
type T;
identifier F = pcm_write_i2sc;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_pcm_write_i2sc_def@
F << remove_static_pcm_write_i2sc_def.F;
T << remove_static_pcm_write_i2sc_def.T;
P << remove_static_pcm_write_i2sc_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_pcm_write_i2sc_def_void@
identifier F = pcm_write_i2sc;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_pcm_write_i2sc_def_void@
F << remove_static_pcm_write_i2sc_def_void.F;
P << remove_static_pcm_write_i2sc_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_pcm_write_i2sc_decl@
type T;
identifier F = pcm_write_i2sc;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_pcm_write_i2sc_decl@
F << remove_static_pcm_write_i2sc_decl.F;
T << remove_static_pcm_write_i2sc_decl.T;
P << remove_static_pcm_write_i2sc_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_pcm_write_i2sc_decl_void@
identifier F = pcm_write_i2sc;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_pcm_write_i2sc_decl_void@
F << remove_static_pcm_write_i2sc_decl_void.F;
P << remove_static_pcm_write_i2sc_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_pcm_write_i2sc_def@
type T;
identifier F = pcm_write_i2sc;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_pcm_write_i2sc_def@
F << extract_pcm_write_i2sc_def.F;
T << extract_pcm_write_i2sc_def.T;
P << extract_pcm_write_i2sc_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_pcm_write_i2sc_def_void@
identifier F = pcm_write_i2sc;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_pcm_write_i2sc_def_void@
F << extract_pcm_write_i2sc_def_void.F;
P << extract_pcm_write_i2sc_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_pcm_write_i2sc_decl@
type T;
identifier F = pcm_write_i2sc;
parameter list P;
@@
T F(P);

@script:python depends on extract_pcm_write_i2sc_decl@
F << extract_pcm_write_i2sc_decl.F;
T << extract_pcm_write_i2sc_decl.T;
P << extract_pcm_write_i2sc_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_pcm_write_i2sc_decl_void@
identifier F = pcm_write_i2sc;
parameter list P;
@@
void F(P);

@script:python depends on extract_pcm_write_i2sc_decl_void@
F << extract_pcm_write_i2sc_decl_void.F;
P << extract_pcm_write_i2sc_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: pcm_write_i2uc
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_pcm_write_i2uc_def@
type T;
identifier F = pcm_write_i2uc;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_pcm_write_i2uc_def@
F << remove_static_pcm_write_i2uc_def.F;
T << remove_static_pcm_write_i2uc_def.T;
P << remove_static_pcm_write_i2uc_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_pcm_write_i2uc_def_void@
identifier F = pcm_write_i2uc;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_pcm_write_i2uc_def_void@
F << remove_static_pcm_write_i2uc_def_void.F;
P << remove_static_pcm_write_i2uc_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_pcm_write_i2uc_decl@
type T;
identifier F = pcm_write_i2uc;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_pcm_write_i2uc_decl@
F << remove_static_pcm_write_i2uc_decl.F;
T << remove_static_pcm_write_i2uc_decl.T;
P << remove_static_pcm_write_i2uc_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_pcm_write_i2uc_decl_void@
identifier F = pcm_write_i2uc;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_pcm_write_i2uc_decl_void@
F << remove_static_pcm_write_i2uc_decl_void.F;
P << remove_static_pcm_write_i2uc_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_pcm_write_i2uc_def@
type T;
identifier F = pcm_write_i2uc;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_pcm_write_i2uc_def@
F << extract_pcm_write_i2uc_def.F;
T << extract_pcm_write_i2uc_def.T;
P << extract_pcm_write_i2uc_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_pcm_write_i2uc_def_void@
identifier F = pcm_write_i2uc;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_pcm_write_i2uc_def_void@
F << extract_pcm_write_i2uc_def_void.F;
P << extract_pcm_write_i2uc_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_pcm_write_i2uc_decl@
type T;
identifier F = pcm_write_i2uc;
parameter list P;
@@
T F(P);

@script:python depends on extract_pcm_write_i2uc_decl@
F << extract_pcm_write_i2uc_decl.F;
T << extract_pcm_write_i2uc_decl.T;
P << extract_pcm_write_i2uc_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_pcm_write_i2uc_decl_void@
identifier F = pcm_write_i2uc;
parameter list P;
@@
void F(P);

@script:python depends on extract_pcm_write_i2uc_decl_void@
F << extract_pcm_write_i2uc_decl_void.F;
P << extract_pcm_write_i2uc_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: pcm_write_s2bei
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_pcm_write_s2bei_def@
type T;
identifier F = pcm_write_s2bei;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_pcm_write_s2bei_def@
F << remove_static_pcm_write_s2bei_def.F;
T << remove_static_pcm_write_s2bei_def.T;
P << remove_static_pcm_write_s2bei_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_pcm_write_s2bei_def_void@
identifier F = pcm_write_s2bei;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_pcm_write_s2bei_def_void@
F << remove_static_pcm_write_s2bei_def_void.F;
P << remove_static_pcm_write_s2bei_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_pcm_write_s2bei_decl@
type T;
identifier F = pcm_write_s2bei;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_pcm_write_s2bei_decl@
F << remove_static_pcm_write_s2bei_decl.F;
T << remove_static_pcm_write_s2bei_decl.T;
P << remove_static_pcm_write_s2bei_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_pcm_write_s2bei_decl_void@
identifier F = pcm_write_s2bei;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_pcm_write_s2bei_decl_void@
F << remove_static_pcm_write_s2bei_decl_void.F;
P << remove_static_pcm_write_s2bei_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_pcm_write_s2bei_def@
type T;
identifier F = pcm_write_s2bei;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_pcm_write_s2bei_def@
F << extract_pcm_write_s2bei_def.F;
T << extract_pcm_write_s2bei_def.T;
P << extract_pcm_write_s2bei_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_pcm_write_s2bei_def_void@
identifier F = pcm_write_s2bei;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_pcm_write_s2bei_def_void@
F << extract_pcm_write_s2bei_def_void.F;
P << extract_pcm_write_s2bei_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_pcm_write_s2bei_decl@
type T;
identifier F = pcm_write_s2bei;
parameter list P;
@@
T F(P);

@script:python depends on extract_pcm_write_s2bei_decl@
F << extract_pcm_write_s2bei_decl.F;
T << extract_pcm_write_s2bei_decl.T;
P << extract_pcm_write_s2bei_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_pcm_write_s2bei_decl_void@
identifier F = pcm_write_s2bei;
parameter list P;
@@
void F(P);

@script:python depends on extract_pcm_write_s2bei_decl_void@
F << extract_pcm_write_s2bei_decl_void.F;
P << extract_pcm_write_s2bei_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: pcm_write_s2bes
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_pcm_write_s2bes_def@
type T;
identifier F = pcm_write_s2bes;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_pcm_write_s2bes_def@
F << remove_static_pcm_write_s2bes_def.F;
T << remove_static_pcm_write_s2bes_def.T;
P << remove_static_pcm_write_s2bes_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_pcm_write_s2bes_def_void@
identifier F = pcm_write_s2bes;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_pcm_write_s2bes_def_void@
F << remove_static_pcm_write_s2bes_def_void.F;
P << remove_static_pcm_write_s2bes_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_pcm_write_s2bes_decl@
type T;
identifier F = pcm_write_s2bes;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_pcm_write_s2bes_decl@
F << remove_static_pcm_write_s2bes_decl.F;
T << remove_static_pcm_write_s2bes_decl.T;
P << remove_static_pcm_write_s2bes_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_pcm_write_s2bes_decl_void@
identifier F = pcm_write_s2bes;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_pcm_write_s2bes_decl_void@
F << remove_static_pcm_write_s2bes_decl_void.F;
P << remove_static_pcm_write_s2bes_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_pcm_write_s2bes_def@
type T;
identifier F = pcm_write_s2bes;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_pcm_write_s2bes_def@
F << extract_pcm_write_s2bes_def.F;
T << extract_pcm_write_s2bes_def.T;
P << extract_pcm_write_s2bes_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_pcm_write_s2bes_def_void@
identifier F = pcm_write_s2bes;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_pcm_write_s2bes_def_void@
F << extract_pcm_write_s2bes_def_void.F;
P << extract_pcm_write_s2bes_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_pcm_write_s2bes_decl@
type T;
identifier F = pcm_write_s2bes;
parameter list P;
@@
T F(P);

@script:python depends on extract_pcm_write_s2bes_decl@
F << extract_pcm_write_s2bes_decl.F;
T << extract_pcm_write_s2bes_decl.T;
P << extract_pcm_write_s2bes_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_pcm_write_s2bes_decl_void@
identifier F = pcm_write_s2bes;
parameter list P;
@@
void F(P);

@script:python depends on extract_pcm_write_s2bes_decl_void@
F << extract_pcm_write_s2bes_decl_void.F;
P << extract_pcm_write_s2bes_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: pcm_write_s2bet
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_pcm_write_s2bet_def@
type T;
identifier F = pcm_write_s2bet;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_pcm_write_s2bet_def@
F << remove_static_pcm_write_s2bet_def.F;
T << remove_static_pcm_write_s2bet_def.T;
P << remove_static_pcm_write_s2bet_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_pcm_write_s2bet_def_void@
identifier F = pcm_write_s2bet;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_pcm_write_s2bet_def_void@
F << remove_static_pcm_write_s2bet_def_void.F;
P << remove_static_pcm_write_s2bet_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_pcm_write_s2bet_decl@
type T;
identifier F = pcm_write_s2bet;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_pcm_write_s2bet_decl@
F << remove_static_pcm_write_s2bet_decl.F;
T << remove_static_pcm_write_s2bet_decl.T;
P << remove_static_pcm_write_s2bet_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_pcm_write_s2bet_decl_void@
identifier F = pcm_write_s2bet;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_pcm_write_s2bet_decl_void@
F << remove_static_pcm_write_s2bet_decl_void.F;
P << remove_static_pcm_write_s2bet_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_pcm_write_s2bet_def@
type T;
identifier F = pcm_write_s2bet;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_pcm_write_s2bet_def@
F << extract_pcm_write_s2bet_def.F;
T << extract_pcm_write_s2bet_def.T;
P << extract_pcm_write_s2bet_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_pcm_write_s2bet_def_void@
identifier F = pcm_write_s2bet;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_pcm_write_s2bet_def_void@
F << extract_pcm_write_s2bet_def_void.F;
P << extract_pcm_write_s2bet_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_pcm_write_s2bet_decl@
type T;
identifier F = pcm_write_s2bet;
parameter list P;
@@
T F(P);

@script:python depends on extract_pcm_write_s2bet_decl@
F << extract_pcm_write_s2bet_decl.F;
T << extract_pcm_write_s2bet_decl.T;
P << extract_pcm_write_s2bet_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_pcm_write_s2bet_decl_void@
identifier F = pcm_write_s2bet;
parameter list P;
@@
void F(P);

@script:python depends on extract_pcm_write_s2bet_decl_void@
F << extract_pcm_write_s2bet_decl_void.F;
P << extract_pcm_write_s2bet_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: pcm_write_s2lei
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_pcm_write_s2lei_def@
type T;
identifier F = pcm_write_s2lei;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_pcm_write_s2lei_def@
F << remove_static_pcm_write_s2lei_def.F;
T << remove_static_pcm_write_s2lei_def.T;
P << remove_static_pcm_write_s2lei_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_pcm_write_s2lei_def_void@
identifier F = pcm_write_s2lei;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_pcm_write_s2lei_def_void@
F << remove_static_pcm_write_s2lei_def_void.F;
P << remove_static_pcm_write_s2lei_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_pcm_write_s2lei_decl@
type T;
identifier F = pcm_write_s2lei;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_pcm_write_s2lei_decl@
F << remove_static_pcm_write_s2lei_decl.F;
T << remove_static_pcm_write_s2lei_decl.T;
P << remove_static_pcm_write_s2lei_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_pcm_write_s2lei_decl_void@
identifier F = pcm_write_s2lei;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_pcm_write_s2lei_decl_void@
F << remove_static_pcm_write_s2lei_decl_void.F;
P << remove_static_pcm_write_s2lei_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_pcm_write_s2lei_def@
type T;
identifier F = pcm_write_s2lei;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_pcm_write_s2lei_def@
F << extract_pcm_write_s2lei_def.F;
T << extract_pcm_write_s2lei_def.T;
P << extract_pcm_write_s2lei_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_pcm_write_s2lei_def_void@
identifier F = pcm_write_s2lei;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_pcm_write_s2lei_def_void@
F << extract_pcm_write_s2lei_def_void.F;
P << extract_pcm_write_s2lei_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_pcm_write_s2lei_decl@
type T;
identifier F = pcm_write_s2lei;
parameter list P;
@@
T F(P);

@script:python depends on extract_pcm_write_s2lei_decl@
F << extract_pcm_write_s2lei_decl.F;
T << extract_pcm_write_s2lei_decl.T;
P << extract_pcm_write_s2lei_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_pcm_write_s2lei_decl_void@
identifier F = pcm_write_s2lei;
parameter list P;
@@
void F(P);

@script:python depends on extract_pcm_write_s2lei_decl_void@
F << extract_pcm_write_s2lei_decl_void.F;
P << extract_pcm_write_s2lei_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: pcm_write_s2les
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_pcm_write_s2les_def@
type T;
identifier F = pcm_write_s2les;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_pcm_write_s2les_def@
F << remove_static_pcm_write_s2les_def.F;
T << remove_static_pcm_write_s2les_def.T;
P << remove_static_pcm_write_s2les_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_pcm_write_s2les_def_void@
identifier F = pcm_write_s2les;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_pcm_write_s2les_def_void@
F << remove_static_pcm_write_s2les_def_void.F;
P << remove_static_pcm_write_s2les_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_pcm_write_s2les_decl@
type T;
identifier F = pcm_write_s2les;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_pcm_write_s2les_decl@
F << remove_static_pcm_write_s2les_decl.F;
T << remove_static_pcm_write_s2les_decl.T;
P << remove_static_pcm_write_s2les_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_pcm_write_s2les_decl_void@
identifier F = pcm_write_s2les;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_pcm_write_s2les_decl_void@
F << remove_static_pcm_write_s2les_decl_void.F;
P << remove_static_pcm_write_s2les_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_pcm_write_s2les_def@
type T;
identifier F = pcm_write_s2les;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_pcm_write_s2les_def@
F << extract_pcm_write_s2les_def.F;
T << extract_pcm_write_s2les_def.T;
P << extract_pcm_write_s2les_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_pcm_write_s2les_def_void@
identifier F = pcm_write_s2les;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_pcm_write_s2les_def_void@
F << extract_pcm_write_s2les_def_void.F;
P << extract_pcm_write_s2les_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_pcm_write_s2les_decl@
type T;
identifier F = pcm_write_s2les;
parameter list P;
@@
T F(P);

@script:python depends on extract_pcm_write_s2les_decl@
F << extract_pcm_write_s2les_decl.F;
T << extract_pcm_write_s2les_decl.T;
P << extract_pcm_write_s2les_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_pcm_write_s2les_decl_void@
identifier F = pcm_write_s2les;
parameter list P;
@@
void F(P);

@script:python depends on extract_pcm_write_s2les_decl_void@
F << extract_pcm_write_s2les_decl_void.F;
P << extract_pcm_write_s2les_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: pcm_write_s2let
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_pcm_write_s2let_def@
type T;
identifier F = pcm_write_s2let;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_pcm_write_s2let_def@
F << remove_static_pcm_write_s2let_def.F;
T << remove_static_pcm_write_s2let_def.T;
P << remove_static_pcm_write_s2let_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_pcm_write_s2let_def_void@
identifier F = pcm_write_s2let;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_pcm_write_s2let_def_void@
F << remove_static_pcm_write_s2let_def_void.F;
P << remove_static_pcm_write_s2let_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_pcm_write_s2let_decl@
type T;
identifier F = pcm_write_s2let;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_pcm_write_s2let_decl@
F << remove_static_pcm_write_s2let_decl.F;
T << remove_static_pcm_write_s2let_decl.T;
P << remove_static_pcm_write_s2let_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_pcm_write_s2let_decl_void@
identifier F = pcm_write_s2let;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_pcm_write_s2let_decl_void@
F << remove_static_pcm_write_s2let_decl_void.F;
P << remove_static_pcm_write_s2let_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_pcm_write_s2let_def@
type T;
identifier F = pcm_write_s2let;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_pcm_write_s2let_def@
F << extract_pcm_write_s2let_def.F;
T << extract_pcm_write_s2let_def.T;
P << extract_pcm_write_s2let_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_pcm_write_s2let_def_void@
identifier F = pcm_write_s2let;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_pcm_write_s2let_def_void@
F << extract_pcm_write_s2let_def_void.F;
P << extract_pcm_write_s2let_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_pcm_write_s2let_decl@
type T;
identifier F = pcm_write_s2let;
parameter list P;
@@
T F(P);

@script:python depends on extract_pcm_write_s2let_decl@
F << extract_pcm_write_s2let_decl.F;
T << extract_pcm_write_s2let_decl.T;
P << extract_pcm_write_s2let_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_pcm_write_s2let_decl_void@
identifier F = pcm_write_s2let;
parameter list P;
@@
void F(P);

@script:python depends on extract_pcm_write_s2let_decl_void@
F << extract_pcm_write_s2let_decl_void.F;
P << extract_pcm_write_s2let_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: pcm_write_s2sc
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_pcm_write_s2sc_def@
type T;
identifier F = pcm_write_s2sc;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_pcm_write_s2sc_def@
F << remove_static_pcm_write_s2sc_def.F;
T << remove_static_pcm_write_s2sc_def.T;
P << remove_static_pcm_write_s2sc_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_pcm_write_s2sc_def_void@
identifier F = pcm_write_s2sc;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_pcm_write_s2sc_def_void@
F << remove_static_pcm_write_s2sc_def_void.F;
P << remove_static_pcm_write_s2sc_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_pcm_write_s2sc_decl@
type T;
identifier F = pcm_write_s2sc;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_pcm_write_s2sc_decl@
F << remove_static_pcm_write_s2sc_decl.F;
T << remove_static_pcm_write_s2sc_decl.T;
P << remove_static_pcm_write_s2sc_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_pcm_write_s2sc_decl_void@
identifier F = pcm_write_s2sc;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_pcm_write_s2sc_decl_void@
F << remove_static_pcm_write_s2sc_decl_void.F;
P << remove_static_pcm_write_s2sc_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_pcm_write_s2sc_def@
type T;
identifier F = pcm_write_s2sc;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_pcm_write_s2sc_def@
F << extract_pcm_write_s2sc_def.F;
T << extract_pcm_write_s2sc_def.T;
P << extract_pcm_write_s2sc_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_pcm_write_s2sc_def_void@
identifier F = pcm_write_s2sc;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_pcm_write_s2sc_def_void@
F << extract_pcm_write_s2sc_def_void.F;
P << extract_pcm_write_s2sc_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_pcm_write_s2sc_decl@
type T;
identifier F = pcm_write_s2sc;
parameter list P;
@@
T F(P);

@script:python depends on extract_pcm_write_s2sc_decl@
F << extract_pcm_write_s2sc_decl.F;
T << extract_pcm_write_s2sc_decl.T;
P << extract_pcm_write_s2sc_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_pcm_write_s2sc_decl_void@
identifier F = pcm_write_s2sc;
parameter list P;
@@
void F(P);

@script:python depends on extract_pcm_write_s2sc_decl_void@
F << extract_pcm_write_s2sc_decl_void.F;
P << extract_pcm_write_s2sc_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: pcm_write_s2uc
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_pcm_write_s2uc_def@
type T;
identifier F = pcm_write_s2uc;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_pcm_write_s2uc_def@
F << remove_static_pcm_write_s2uc_def.F;
T << remove_static_pcm_write_s2uc_def.T;
P << remove_static_pcm_write_s2uc_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_pcm_write_s2uc_def_void@
identifier F = pcm_write_s2uc;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_pcm_write_s2uc_def_void@
F << remove_static_pcm_write_s2uc_def_void.F;
P << remove_static_pcm_write_s2uc_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_pcm_write_s2uc_decl@
type T;
identifier F = pcm_write_s2uc;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_pcm_write_s2uc_decl@
F << remove_static_pcm_write_s2uc_decl.F;
T << remove_static_pcm_write_s2uc_decl.T;
P << remove_static_pcm_write_s2uc_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_pcm_write_s2uc_decl_void@
identifier F = pcm_write_s2uc;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_pcm_write_s2uc_decl_void@
F << remove_static_pcm_write_s2uc_decl_void.F;
P << remove_static_pcm_write_s2uc_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_pcm_write_s2uc_def@
type T;
identifier F = pcm_write_s2uc;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_pcm_write_s2uc_def@
F << extract_pcm_write_s2uc_def.F;
T << extract_pcm_write_s2uc_def.T;
P << extract_pcm_write_s2uc_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_pcm_write_s2uc_def_void@
identifier F = pcm_write_s2uc;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_pcm_write_s2uc_def_void@
F << extract_pcm_write_s2uc_def_void.F;
P << extract_pcm_write_s2uc_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_pcm_write_s2uc_decl@
type T;
identifier F = pcm_write_s2uc;
parameter list P;
@@
T F(P);

@script:python depends on extract_pcm_write_s2uc_decl@
F << extract_pcm_write_s2uc_decl.F;
T << extract_pcm_write_s2uc_decl.T;
P << extract_pcm_write_s2uc_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_pcm_write_s2uc_decl_void@
identifier F = pcm_write_s2uc;
parameter list P;
@@
void F(P);

@script:python depends on extract_pcm_write_s2uc_decl_void@
F << extract_pcm_write_s2uc_decl_void.F;
P << extract_pcm_write_s2uc_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: psf_default_seek
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_psf_default_seek_def@
type T;
identifier F = psf_default_seek;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_psf_default_seek_def@
F << remove_static_psf_default_seek_def.F;
T << remove_static_psf_default_seek_def.T;
P << remove_static_psf_default_seek_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_psf_default_seek_def_void@
identifier F = psf_default_seek;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_psf_default_seek_def_void@
F << remove_static_psf_default_seek_def_void.F;
P << remove_static_psf_default_seek_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_psf_default_seek_decl@
type T;
identifier F = psf_default_seek;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_psf_default_seek_decl@
F << remove_static_psf_default_seek_decl.F;
T << remove_static_psf_default_seek_decl.T;
P << remove_static_psf_default_seek_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_psf_default_seek_decl_void@
identifier F = psf_default_seek;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_psf_default_seek_decl_void@
F << remove_static_psf_default_seek_decl_void.F;
P << remove_static_psf_default_seek_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_psf_default_seek_def@
type T;
identifier F = psf_default_seek;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_psf_default_seek_def@
F << extract_psf_default_seek_def.F;
T << extract_psf_default_seek_def.T;
P << extract_psf_default_seek_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_psf_default_seek_def_void@
identifier F = psf_default_seek;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_psf_default_seek_def_void@
F << extract_psf_default_seek_def_void.F;
P << extract_psf_default_seek_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_psf_default_seek_decl@
type T;
identifier F = psf_default_seek;
parameter list P;
@@
T F(P);

@script:python depends on extract_psf_default_seek_decl@
F << extract_psf_default_seek_decl.F;
T << extract_psf_default_seek_decl.T;
P << extract_psf_default_seek_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_psf_default_seek_decl_void@
identifier F = psf_default_seek;
parameter list P;
@@
void F(P);

@script:python depends on extract_psf_default_seek_decl_void@
F << extract_psf_default_seek_decl_void.F;
P << extract_psf_default_seek_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: pvf_close
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_pvf_close_def@
type T;
identifier F = pvf_close;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_pvf_close_def@
F << remove_static_pvf_close_def.F;
T << remove_static_pvf_close_def.T;
P << remove_static_pvf_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_pvf_close_def_void@
identifier F = pvf_close;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_pvf_close_def_void@
F << remove_static_pvf_close_def_void.F;
P << remove_static_pvf_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_pvf_close_decl@
type T;
identifier F = pvf_close;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_pvf_close_decl@
F << remove_static_pvf_close_decl.F;
T << remove_static_pvf_close_decl.T;
P << remove_static_pvf_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_pvf_close_decl_void@
identifier F = pvf_close;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_pvf_close_decl_void@
F << remove_static_pvf_close_decl_void.F;
P << remove_static_pvf_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_pvf_close_def@
type T;
identifier F = pvf_close;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_pvf_close_def@
F << extract_pvf_close_def.F;
T << extract_pvf_close_def.T;
P << extract_pvf_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_pvf_close_def_void@
identifier F = pvf_close;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_pvf_close_def_void@
F << extract_pvf_close_def_void.F;
P << extract_pvf_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_pvf_close_decl@
type T;
identifier F = pvf_close;
parameter list P;
@@
T F(P);

@script:python depends on extract_pvf_close_decl@
F << extract_pvf_close_decl.F;
T << extract_pvf_close_decl.T;
P << extract_pvf_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_pvf_close_decl_void@
identifier F = pvf_close;
parameter list P;
@@
void F(P);

@script:python depends on extract_pvf_close_decl_void@
F << extract_pvf_close_decl_void.F;
P << extract_pvf_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: pvf_write_header
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_pvf_write_header_def@
type T;
identifier F = pvf_write_header;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_pvf_write_header_def@
F << remove_static_pvf_write_header_def.F;
T << remove_static_pvf_write_header_def.T;
P << remove_static_pvf_write_header_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_pvf_write_header_def_void@
identifier F = pvf_write_header;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_pvf_write_header_def_void@
F << remove_static_pvf_write_header_def_void.F;
P << remove_static_pvf_write_header_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_pvf_write_header_decl@
type T;
identifier F = pvf_write_header;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_pvf_write_header_decl@
F << remove_static_pvf_write_header_decl.F;
T << remove_static_pvf_write_header_decl.T;
P << remove_static_pvf_write_header_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_pvf_write_header_decl_void@
identifier F = pvf_write_header;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_pvf_write_header_decl_void@
F << remove_static_pvf_write_header_decl_void.F;
P << remove_static_pvf_write_header_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_pvf_write_header_def@
type T;
identifier F = pvf_write_header;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_pvf_write_header_def@
F << extract_pvf_write_header_def.F;
T << extract_pvf_write_header_def.T;
P << extract_pvf_write_header_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_pvf_write_header_def_void@
identifier F = pvf_write_header;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_pvf_write_header_def_void@
F << extract_pvf_write_header_def_void.F;
P << extract_pvf_write_header_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_pvf_write_header_decl@
type T;
identifier F = pvf_write_header;
parameter list P;
@@
T F(P);

@script:python depends on extract_pvf_write_header_decl@
F << extract_pvf_write_header_decl.F;
T << extract_pvf_write_header_decl.T;
P << extract_pvf_write_header_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_pvf_write_header_decl_void@
identifier F = pvf_write_header;
parameter list P;
@@
void F(P);

@script:python depends on extract_pvf_write_header_decl_void@
F << extract_pvf_write_header_decl_void.F;
P << extract_pvf_write_header_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: replace_read_d
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_replace_read_d_def@
type T;
identifier F = replace_read_d;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_replace_read_d_def@
F << remove_static_replace_read_d_def.F;
T << remove_static_replace_read_d_def.T;
P << remove_static_replace_read_d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_replace_read_d_def_void@
identifier F = replace_read_d;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_replace_read_d_def_void@
F << remove_static_replace_read_d_def_void.F;
P << remove_static_replace_read_d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_replace_read_d_decl@
type T;
identifier F = replace_read_d;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_replace_read_d_decl@
F << remove_static_replace_read_d_decl.F;
T << remove_static_replace_read_d_decl.T;
P << remove_static_replace_read_d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_replace_read_d_decl_void@
identifier F = replace_read_d;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_replace_read_d_decl_void@
F << remove_static_replace_read_d_decl_void.F;
P << remove_static_replace_read_d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_replace_read_d_def@
type T;
identifier F = replace_read_d;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_replace_read_d_def@
F << extract_replace_read_d_def.F;
T << extract_replace_read_d_def.T;
P << extract_replace_read_d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_replace_read_d_def_void@
identifier F = replace_read_d;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_replace_read_d_def_void@
F << extract_replace_read_d_def_void.F;
P << extract_replace_read_d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_replace_read_d_decl@
type T;
identifier F = replace_read_d;
parameter list P;
@@
T F(P);

@script:python depends on extract_replace_read_d_decl@
F << extract_replace_read_d_decl.F;
T << extract_replace_read_d_decl.T;
P << extract_replace_read_d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_replace_read_d_decl_void@
identifier F = replace_read_d;
parameter list P;
@@
void F(P);

@script:python depends on extract_replace_read_d_decl_void@
F << extract_replace_read_d_decl_void.F;
P << extract_replace_read_d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: replace_read_d2f
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_replace_read_d2f_def@
type T;
identifier F = replace_read_d2f;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_replace_read_d2f_def@
F << remove_static_replace_read_d2f_def.F;
T << remove_static_replace_read_d2f_def.T;
P << remove_static_replace_read_d2f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_replace_read_d2f_def_void@
identifier F = replace_read_d2f;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_replace_read_d2f_def_void@
F << remove_static_replace_read_d2f_def_void.F;
P << remove_static_replace_read_d2f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_replace_read_d2f_decl@
type T;
identifier F = replace_read_d2f;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_replace_read_d2f_decl@
F << remove_static_replace_read_d2f_decl.F;
T << remove_static_replace_read_d2f_decl.T;
P << remove_static_replace_read_d2f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_replace_read_d2f_decl_void@
identifier F = replace_read_d2f;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_replace_read_d2f_decl_void@
F << remove_static_replace_read_d2f_decl_void.F;
P << remove_static_replace_read_d2f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_replace_read_d2f_def@
type T;
identifier F = replace_read_d2f;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_replace_read_d2f_def@
F << extract_replace_read_d2f_def.F;
T << extract_replace_read_d2f_def.T;
P << extract_replace_read_d2f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_replace_read_d2f_def_void@
identifier F = replace_read_d2f;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_replace_read_d2f_def_void@
F << extract_replace_read_d2f_def_void.F;
P << extract_replace_read_d2f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_replace_read_d2f_decl@
type T;
identifier F = replace_read_d2f;
parameter list P;
@@
T F(P);

@script:python depends on extract_replace_read_d2f_decl@
F << extract_replace_read_d2f_decl.F;
T << extract_replace_read_d2f_decl.T;
P << extract_replace_read_d2f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_replace_read_d2f_decl_void@
identifier F = replace_read_d2f;
parameter list P;
@@
void F(P);

@script:python depends on extract_replace_read_d2f_decl_void@
F << extract_replace_read_d2f_decl_void.F;
P << extract_replace_read_d2f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: replace_read_d2i
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_replace_read_d2i_def@
type T;
identifier F = replace_read_d2i;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_replace_read_d2i_def@
F << remove_static_replace_read_d2i_def.F;
T << remove_static_replace_read_d2i_def.T;
P << remove_static_replace_read_d2i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_replace_read_d2i_def_void@
identifier F = replace_read_d2i;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_replace_read_d2i_def_void@
F << remove_static_replace_read_d2i_def_void.F;
P << remove_static_replace_read_d2i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_replace_read_d2i_decl@
type T;
identifier F = replace_read_d2i;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_replace_read_d2i_decl@
F << remove_static_replace_read_d2i_decl.F;
T << remove_static_replace_read_d2i_decl.T;
P << remove_static_replace_read_d2i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_replace_read_d2i_decl_void@
identifier F = replace_read_d2i;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_replace_read_d2i_decl_void@
F << remove_static_replace_read_d2i_decl_void.F;
P << remove_static_replace_read_d2i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_replace_read_d2i_def@
type T;
identifier F = replace_read_d2i;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_replace_read_d2i_def@
F << extract_replace_read_d2i_def.F;
T << extract_replace_read_d2i_def.T;
P << extract_replace_read_d2i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_replace_read_d2i_def_void@
identifier F = replace_read_d2i;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_replace_read_d2i_def_void@
F << extract_replace_read_d2i_def_void.F;
P << extract_replace_read_d2i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_replace_read_d2i_decl@
type T;
identifier F = replace_read_d2i;
parameter list P;
@@
T F(P);

@script:python depends on extract_replace_read_d2i_decl@
F << extract_replace_read_d2i_decl.F;
T << extract_replace_read_d2i_decl.T;
P << extract_replace_read_d2i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_replace_read_d2i_decl_void@
identifier F = replace_read_d2i;
parameter list P;
@@
void F(P);

@script:python depends on extract_replace_read_d2i_decl_void@
F << extract_replace_read_d2i_decl_void.F;
P << extract_replace_read_d2i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: replace_read_d2s
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_replace_read_d2s_def@
type T;
identifier F = replace_read_d2s;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_replace_read_d2s_def@
F << remove_static_replace_read_d2s_def.F;
T << remove_static_replace_read_d2s_def.T;
P << remove_static_replace_read_d2s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_replace_read_d2s_def_void@
identifier F = replace_read_d2s;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_replace_read_d2s_def_void@
F << remove_static_replace_read_d2s_def_void.F;
P << remove_static_replace_read_d2s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_replace_read_d2s_decl@
type T;
identifier F = replace_read_d2s;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_replace_read_d2s_decl@
F << remove_static_replace_read_d2s_decl.F;
T << remove_static_replace_read_d2s_decl.T;
P << remove_static_replace_read_d2s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_replace_read_d2s_decl_void@
identifier F = replace_read_d2s;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_replace_read_d2s_decl_void@
F << remove_static_replace_read_d2s_decl_void.F;
P << remove_static_replace_read_d2s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_replace_read_d2s_def@
type T;
identifier F = replace_read_d2s;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_replace_read_d2s_def@
F << extract_replace_read_d2s_def.F;
T << extract_replace_read_d2s_def.T;
P << extract_replace_read_d2s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_replace_read_d2s_def_void@
identifier F = replace_read_d2s;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_replace_read_d2s_def_void@
F << extract_replace_read_d2s_def_void.F;
P << extract_replace_read_d2s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_replace_read_d2s_decl@
type T;
identifier F = replace_read_d2s;
parameter list P;
@@
T F(P);

@script:python depends on extract_replace_read_d2s_decl@
F << extract_replace_read_d2s_decl.F;
T << extract_replace_read_d2s_decl.T;
P << extract_replace_read_d2s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_replace_read_d2s_decl_void@
identifier F = replace_read_d2s;
parameter list P;
@@
void F(P);

@script:python depends on extract_replace_read_d2s_decl_void@
F << extract_replace_read_d2s_decl_void.F;
P << extract_replace_read_d2s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: replace_read_f
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_replace_read_f_def@
type T;
identifier F = replace_read_f;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_replace_read_f_def@
F << remove_static_replace_read_f_def.F;
T << remove_static_replace_read_f_def.T;
P << remove_static_replace_read_f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_replace_read_f_def_void@
identifier F = replace_read_f;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_replace_read_f_def_void@
F << remove_static_replace_read_f_def_void.F;
P << remove_static_replace_read_f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_replace_read_f_decl@
type T;
identifier F = replace_read_f;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_replace_read_f_decl@
F << remove_static_replace_read_f_decl.F;
T << remove_static_replace_read_f_decl.T;
P << remove_static_replace_read_f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_replace_read_f_decl_void@
identifier F = replace_read_f;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_replace_read_f_decl_void@
F << remove_static_replace_read_f_decl_void.F;
P << remove_static_replace_read_f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_replace_read_f_def@
type T;
identifier F = replace_read_f;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_replace_read_f_def@
F << extract_replace_read_f_def.F;
T << extract_replace_read_f_def.T;
P << extract_replace_read_f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_replace_read_f_def_void@
identifier F = replace_read_f;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_replace_read_f_def_void@
F << extract_replace_read_f_def_void.F;
P << extract_replace_read_f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_replace_read_f_decl@
type T;
identifier F = replace_read_f;
parameter list P;
@@
T F(P);

@script:python depends on extract_replace_read_f_decl@
F << extract_replace_read_f_decl.F;
T << extract_replace_read_f_decl.T;
P << extract_replace_read_f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_replace_read_f_decl_void@
identifier F = replace_read_f;
parameter list P;
@@
void F(P);

@script:python depends on extract_replace_read_f_decl_void@
F << extract_replace_read_f_decl_void.F;
P << extract_replace_read_f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: replace_read_f2d
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_replace_read_f2d_def@
type T;
identifier F = replace_read_f2d;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_replace_read_f2d_def@
F << remove_static_replace_read_f2d_def.F;
T << remove_static_replace_read_f2d_def.T;
P << remove_static_replace_read_f2d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_replace_read_f2d_def_void@
identifier F = replace_read_f2d;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_replace_read_f2d_def_void@
F << remove_static_replace_read_f2d_def_void.F;
P << remove_static_replace_read_f2d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_replace_read_f2d_decl@
type T;
identifier F = replace_read_f2d;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_replace_read_f2d_decl@
F << remove_static_replace_read_f2d_decl.F;
T << remove_static_replace_read_f2d_decl.T;
P << remove_static_replace_read_f2d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_replace_read_f2d_decl_void@
identifier F = replace_read_f2d;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_replace_read_f2d_decl_void@
F << remove_static_replace_read_f2d_decl_void.F;
P << remove_static_replace_read_f2d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_replace_read_f2d_def@
type T;
identifier F = replace_read_f2d;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_replace_read_f2d_def@
F << extract_replace_read_f2d_def.F;
T << extract_replace_read_f2d_def.T;
P << extract_replace_read_f2d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_replace_read_f2d_def_void@
identifier F = replace_read_f2d;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_replace_read_f2d_def_void@
F << extract_replace_read_f2d_def_void.F;
P << extract_replace_read_f2d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_replace_read_f2d_decl@
type T;
identifier F = replace_read_f2d;
parameter list P;
@@
T F(P);

@script:python depends on extract_replace_read_f2d_decl@
F << extract_replace_read_f2d_decl.F;
T << extract_replace_read_f2d_decl.T;
P << extract_replace_read_f2d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_replace_read_f2d_decl_void@
identifier F = replace_read_f2d;
parameter list P;
@@
void F(P);

@script:python depends on extract_replace_read_f2d_decl_void@
F << extract_replace_read_f2d_decl_void.F;
P << extract_replace_read_f2d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: replace_read_f2i
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_replace_read_f2i_def@
type T;
identifier F = replace_read_f2i;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_replace_read_f2i_def@
F << remove_static_replace_read_f2i_def.F;
T << remove_static_replace_read_f2i_def.T;
P << remove_static_replace_read_f2i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_replace_read_f2i_def_void@
identifier F = replace_read_f2i;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_replace_read_f2i_def_void@
F << remove_static_replace_read_f2i_def_void.F;
P << remove_static_replace_read_f2i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_replace_read_f2i_decl@
type T;
identifier F = replace_read_f2i;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_replace_read_f2i_decl@
F << remove_static_replace_read_f2i_decl.F;
T << remove_static_replace_read_f2i_decl.T;
P << remove_static_replace_read_f2i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_replace_read_f2i_decl_void@
identifier F = replace_read_f2i;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_replace_read_f2i_decl_void@
F << remove_static_replace_read_f2i_decl_void.F;
P << remove_static_replace_read_f2i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_replace_read_f2i_def@
type T;
identifier F = replace_read_f2i;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_replace_read_f2i_def@
F << extract_replace_read_f2i_def.F;
T << extract_replace_read_f2i_def.T;
P << extract_replace_read_f2i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_replace_read_f2i_def_void@
identifier F = replace_read_f2i;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_replace_read_f2i_def_void@
F << extract_replace_read_f2i_def_void.F;
P << extract_replace_read_f2i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_replace_read_f2i_decl@
type T;
identifier F = replace_read_f2i;
parameter list P;
@@
T F(P);

@script:python depends on extract_replace_read_f2i_decl@
F << extract_replace_read_f2i_decl.F;
T << extract_replace_read_f2i_decl.T;
P << extract_replace_read_f2i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_replace_read_f2i_decl_void@
identifier F = replace_read_f2i;
parameter list P;
@@
void F(P);

@script:python depends on extract_replace_read_f2i_decl_void@
F << extract_replace_read_f2i_decl_void.F;
P << extract_replace_read_f2i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: replace_read_f2s
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_replace_read_f2s_def@
type T;
identifier F = replace_read_f2s;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_replace_read_f2s_def@
F << remove_static_replace_read_f2s_def.F;
T << remove_static_replace_read_f2s_def.T;
P << remove_static_replace_read_f2s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_replace_read_f2s_def_void@
identifier F = replace_read_f2s;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_replace_read_f2s_def_void@
F << remove_static_replace_read_f2s_def_void.F;
P << remove_static_replace_read_f2s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_replace_read_f2s_decl@
type T;
identifier F = replace_read_f2s;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_replace_read_f2s_decl@
F << remove_static_replace_read_f2s_decl.F;
T << remove_static_replace_read_f2s_decl.T;
P << remove_static_replace_read_f2s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_replace_read_f2s_decl_void@
identifier F = replace_read_f2s;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_replace_read_f2s_decl_void@
F << remove_static_replace_read_f2s_decl_void.F;
P << remove_static_replace_read_f2s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_replace_read_f2s_def@
type T;
identifier F = replace_read_f2s;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_replace_read_f2s_def@
F << extract_replace_read_f2s_def.F;
T << extract_replace_read_f2s_def.T;
P << extract_replace_read_f2s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_replace_read_f2s_def_void@
identifier F = replace_read_f2s;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_replace_read_f2s_def_void@
F << extract_replace_read_f2s_def_void.F;
P << extract_replace_read_f2s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_replace_read_f2s_decl@
type T;
identifier F = replace_read_f2s;
parameter list P;
@@
T F(P);

@script:python depends on extract_replace_read_f2s_decl@
F << extract_replace_read_f2s_decl.F;
T << extract_replace_read_f2s_decl.T;
P << extract_replace_read_f2s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_replace_read_f2s_decl_void@
identifier F = replace_read_f2s;
parameter list P;
@@
void F(P);

@script:python depends on extract_replace_read_f2s_decl_void@
F << extract_replace_read_f2s_decl_void.F;
P << extract_replace_read_f2s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: replace_write_d
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_replace_write_d_def@
type T;
identifier F = replace_write_d;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_replace_write_d_def@
F << remove_static_replace_write_d_def.F;
T << remove_static_replace_write_d_def.T;
P << remove_static_replace_write_d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_replace_write_d_def_void@
identifier F = replace_write_d;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_replace_write_d_def_void@
F << remove_static_replace_write_d_def_void.F;
P << remove_static_replace_write_d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_replace_write_d_decl@
type T;
identifier F = replace_write_d;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_replace_write_d_decl@
F << remove_static_replace_write_d_decl.F;
T << remove_static_replace_write_d_decl.T;
P << remove_static_replace_write_d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_replace_write_d_decl_void@
identifier F = replace_write_d;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_replace_write_d_decl_void@
F << remove_static_replace_write_d_decl_void.F;
P << remove_static_replace_write_d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_replace_write_d_def@
type T;
identifier F = replace_write_d;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_replace_write_d_def@
F << extract_replace_write_d_def.F;
T << extract_replace_write_d_def.T;
P << extract_replace_write_d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_replace_write_d_def_void@
identifier F = replace_write_d;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_replace_write_d_def_void@
F << extract_replace_write_d_def_void.F;
P << extract_replace_write_d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_replace_write_d_decl@
type T;
identifier F = replace_write_d;
parameter list P;
@@
T F(P);

@script:python depends on extract_replace_write_d_decl@
F << extract_replace_write_d_decl.F;
T << extract_replace_write_d_decl.T;
P << extract_replace_write_d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_replace_write_d_decl_void@
identifier F = replace_write_d;
parameter list P;
@@
void F(P);

@script:python depends on extract_replace_write_d_decl_void@
F << extract_replace_write_d_decl_void.F;
P << extract_replace_write_d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: replace_write_d2f
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_replace_write_d2f_def@
type T;
identifier F = replace_write_d2f;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_replace_write_d2f_def@
F << remove_static_replace_write_d2f_def.F;
T << remove_static_replace_write_d2f_def.T;
P << remove_static_replace_write_d2f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_replace_write_d2f_def_void@
identifier F = replace_write_d2f;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_replace_write_d2f_def_void@
F << remove_static_replace_write_d2f_def_void.F;
P << remove_static_replace_write_d2f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_replace_write_d2f_decl@
type T;
identifier F = replace_write_d2f;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_replace_write_d2f_decl@
F << remove_static_replace_write_d2f_decl.F;
T << remove_static_replace_write_d2f_decl.T;
P << remove_static_replace_write_d2f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_replace_write_d2f_decl_void@
identifier F = replace_write_d2f;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_replace_write_d2f_decl_void@
F << remove_static_replace_write_d2f_decl_void.F;
P << remove_static_replace_write_d2f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_replace_write_d2f_def@
type T;
identifier F = replace_write_d2f;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_replace_write_d2f_def@
F << extract_replace_write_d2f_def.F;
T << extract_replace_write_d2f_def.T;
P << extract_replace_write_d2f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_replace_write_d2f_def_void@
identifier F = replace_write_d2f;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_replace_write_d2f_def_void@
F << extract_replace_write_d2f_def_void.F;
P << extract_replace_write_d2f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_replace_write_d2f_decl@
type T;
identifier F = replace_write_d2f;
parameter list P;
@@
T F(P);

@script:python depends on extract_replace_write_d2f_decl@
F << extract_replace_write_d2f_decl.F;
T << extract_replace_write_d2f_decl.T;
P << extract_replace_write_d2f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_replace_write_d2f_decl_void@
identifier F = replace_write_d2f;
parameter list P;
@@
void F(P);

@script:python depends on extract_replace_write_d2f_decl_void@
F << extract_replace_write_d2f_decl_void.F;
P << extract_replace_write_d2f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: replace_write_f
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_replace_write_f_def@
type T;
identifier F = replace_write_f;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_replace_write_f_def@
F << remove_static_replace_write_f_def.F;
T << remove_static_replace_write_f_def.T;
P << remove_static_replace_write_f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_replace_write_f_def_void@
identifier F = replace_write_f;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_replace_write_f_def_void@
F << remove_static_replace_write_f_def_void.F;
P << remove_static_replace_write_f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_replace_write_f_decl@
type T;
identifier F = replace_write_f;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_replace_write_f_decl@
F << remove_static_replace_write_f_decl.F;
T << remove_static_replace_write_f_decl.T;
P << remove_static_replace_write_f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_replace_write_f_decl_void@
identifier F = replace_write_f;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_replace_write_f_decl_void@
F << remove_static_replace_write_f_decl_void.F;
P << remove_static_replace_write_f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_replace_write_f_def@
type T;
identifier F = replace_write_f;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_replace_write_f_def@
F << extract_replace_write_f_def.F;
T << extract_replace_write_f_def.T;
P << extract_replace_write_f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_replace_write_f_def_void@
identifier F = replace_write_f;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_replace_write_f_def_void@
F << extract_replace_write_f_def_void.F;
P << extract_replace_write_f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_replace_write_f_decl@
type T;
identifier F = replace_write_f;
parameter list P;
@@
T F(P);

@script:python depends on extract_replace_write_f_decl@
F << extract_replace_write_f_decl.F;
T << extract_replace_write_f_decl.T;
P << extract_replace_write_f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_replace_write_f_decl_void@
identifier F = replace_write_f;
parameter list P;
@@
void F(P);

@script:python depends on extract_replace_write_f_decl_void@
F << extract_replace_write_f_decl_void.F;
P << extract_replace_write_f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: replace_write_f2d
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_replace_write_f2d_def@
type T;
identifier F = replace_write_f2d;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_replace_write_f2d_def@
F << remove_static_replace_write_f2d_def.F;
T << remove_static_replace_write_f2d_def.T;
P << remove_static_replace_write_f2d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_replace_write_f2d_def_void@
identifier F = replace_write_f2d;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_replace_write_f2d_def_void@
F << remove_static_replace_write_f2d_def_void.F;
P << remove_static_replace_write_f2d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_replace_write_f2d_decl@
type T;
identifier F = replace_write_f2d;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_replace_write_f2d_decl@
F << remove_static_replace_write_f2d_decl.F;
T << remove_static_replace_write_f2d_decl.T;
P << remove_static_replace_write_f2d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_replace_write_f2d_decl_void@
identifier F = replace_write_f2d;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_replace_write_f2d_decl_void@
F << remove_static_replace_write_f2d_decl_void.F;
P << remove_static_replace_write_f2d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_replace_write_f2d_def@
type T;
identifier F = replace_write_f2d;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_replace_write_f2d_def@
F << extract_replace_write_f2d_def.F;
T << extract_replace_write_f2d_def.T;
P << extract_replace_write_f2d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_replace_write_f2d_def_void@
identifier F = replace_write_f2d;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_replace_write_f2d_def_void@
F << extract_replace_write_f2d_def_void.F;
P << extract_replace_write_f2d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_replace_write_f2d_decl@
type T;
identifier F = replace_write_f2d;
parameter list P;
@@
T F(P);

@script:python depends on extract_replace_write_f2d_decl@
F << extract_replace_write_f2d_decl.F;
T << extract_replace_write_f2d_decl.T;
P << extract_replace_write_f2d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_replace_write_f2d_decl_void@
identifier F = replace_write_f2d;
parameter list P;
@@
void F(P);

@script:python depends on extract_replace_write_f2d_decl_void@
F << extract_replace_write_f2d_decl_void.F;
P << extract_replace_write_f2d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: replace_write_i2d
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_replace_write_i2d_def@
type T;
identifier F = replace_write_i2d;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_replace_write_i2d_def@
F << remove_static_replace_write_i2d_def.F;
T << remove_static_replace_write_i2d_def.T;
P << remove_static_replace_write_i2d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_replace_write_i2d_def_void@
identifier F = replace_write_i2d;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_replace_write_i2d_def_void@
F << remove_static_replace_write_i2d_def_void.F;
P << remove_static_replace_write_i2d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_replace_write_i2d_decl@
type T;
identifier F = replace_write_i2d;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_replace_write_i2d_decl@
F << remove_static_replace_write_i2d_decl.F;
T << remove_static_replace_write_i2d_decl.T;
P << remove_static_replace_write_i2d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_replace_write_i2d_decl_void@
identifier F = replace_write_i2d;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_replace_write_i2d_decl_void@
F << remove_static_replace_write_i2d_decl_void.F;
P << remove_static_replace_write_i2d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_replace_write_i2d_def@
type T;
identifier F = replace_write_i2d;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_replace_write_i2d_def@
F << extract_replace_write_i2d_def.F;
T << extract_replace_write_i2d_def.T;
P << extract_replace_write_i2d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_replace_write_i2d_def_void@
identifier F = replace_write_i2d;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_replace_write_i2d_def_void@
F << extract_replace_write_i2d_def_void.F;
P << extract_replace_write_i2d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_replace_write_i2d_decl@
type T;
identifier F = replace_write_i2d;
parameter list P;
@@
T F(P);

@script:python depends on extract_replace_write_i2d_decl@
F << extract_replace_write_i2d_decl.F;
T << extract_replace_write_i2d_decl.T;
P << extract_replace_write_i2d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_replace_write_i2d_decl_void@
identifier F = replace_write_i2d;
parameter list P;
@@
void F(P);

@script:python depends on extract_replace_write_i2d_decl_void@
F << extract_replace_write_i2d_decl_void.F;
P << extract_replace_write_i2d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: replace_write_i2f
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_replace_write_i2f_def@
type T;
identifier F = replace_write_i2f;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_replace_write_i2f_def@
F << remove_static_replace_write_i2f_def.F;
T << remove_static_replace_write_i2f_def.T;
P << remove_static_replace_write_i2f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_replace_write_i2f_def_void@
identifier F = replace_write_i2f;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_replace_write_i2f_def_void@
F << remove_static_replace_write_i2f_def_void.F;
P << remove_static_replace_write_i2f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_replace_write_i2f_decl@
type T;
identifier F = replace_write_i2f;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_replace_write_i2f_decl@
F << remove_static_replace_write_i2f_decl.F;
T << remove_static_replace_write_i2f_decl.T;
P << remove_static_replace_write_i2f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_replace_write_i2f_decl_void@
identifier F = replace_write_i2f;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_replace_write_i2f_decl_void@
F << remove_static_replace_write_i2f_decl_void.F;
P << remove_static_replace_write_i2f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_replace_write_i2f_def@
type T;
identifier F = replace_write_i2f;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_replace_write_i2f_def@
F << extract_replace_write_i2f_def.F;
T << extract_replace_write_i2f_def.T;
P << extract_replace_write_i2f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_replace_write_i2f_def_void@
identifier F = replace_write_i2f;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_replace_write_i2f_def_void@
F << extract_replace_write_i2f_def_void.F;
P << extract_replace_write_i2f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_replace_write_i2f_decl@
type T;
identifier F = replace_write_i2f;
parameter list P;
@@
T F(P);

@script:python depends on extract_replace_write_i2f_decl@
F << extract_replace_write_i2f_decl.F;
T << extract_replace_write_i2f_decl.T;
P << extract_replace_write_i2f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_replace_write_i2f_decl_void@
identifier F = replace_write_i2f;
parameter list P;
@@
void F(P);

@script:python depends on extract_replace_write_i2f_decl_void@
F << extract_replace_write_i2f_decl_void.F;
P << extract_replace_write_i2f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: replace_write_s2d
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_replace_write_s2d_def@
type T;
identifier F = replace_write_s2d;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_replace_write_s2d_def@
F << remove_static_replace_write_s2d_def.F;
T << remove_static_replace_write_s2d_def.T;
P << remove_static_replace_write_s2d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_replace_write_s2d_def_void@
identifier F = replace_write_s2d;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_replace_write_s2d_def_void@
F << remove_static_replace_write_s2d_def_void.F;
P << remove_static_replace_write_s2d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_replace_write_s2d_decl@
type T;
identifier F = replace_write_s2d;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_replace_write_s2d_decl@
F << remove_static_replace_write_s2d_decl.F;
T << remove_static_replace_write_s2d_decl.T;
P << remove_static_replace_write_s2d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_replace_write_s2d_decl_void@
identifier F = replace_write_s2d;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_replace_write_s2d_decl_void@
F << remove_static_replace_write_s2d_decl_void.F;
P << remove_static_replace_write_s2d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_replace_write_s2d_def@
type T;
identifier F = replace_write_s2d;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_replace_write_s2d_def@
F << extract_replace_write_s2d_def.F;
T << extract_replace_write_s2d_def.T;
P << extract_replace_write_s2d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_replace_write_s2d_def_void@
identifier F = replace_write_s2d;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_replace_write_s2d_def_void@
F << extract_replace_write_s2d_def_void.F;
P << extract_replace_write_s2d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_replace_write_s2d_decl@
type T;
identifier F = replace_write_s2d;
parameter list P;
@@
T F(P);

@script:python depends on extract_replace_write_s2d_decl@
F << extract_replace_write_s2d_decl.F;
T << extract_replace_write_s2d_decl.T;
P << extract_replace_write_s2d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_replace_write_s2d_decl_void@
identifier F = replace_write_s2d;
parameter list P;
@@
void F(P);

@script:python depends on extract_replace_write_s2d_decl_void@
F << extract_replace_write_s2d_decl_void.F;
P << extract_replace_write_s2d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: replace_write_s2f
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_replace_write_s2f_def@
type T;
identifier F = replace_write_s2f;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_replace_write_s2f_def@
F << remove_static_replace_write_s2f_def.F;
T << remove_static_replace_write_s2f_def.T;
P << remove_static_replace_write_s2f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_replace_write_s2f_def_void@
identifier F = replace_write_s2f;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_replace_write_s2f_def_void@
F << remove_static_replace_write_s2f_def_void.F;
P << remove_static_replace_write_s2f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_replace_write_s2f_decl@
type T;
identifier F = replace_write_s2f;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_replace_write_s2f_decl@
F << remove_static_replace_write_s2f_decl.F;
T << remove_static_replace_write_s2f_decl.T;
P << remove_static_replace_write_s2f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_replace_write_s2f_decl_void@
identifier F = replace_write_s2f;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_replace_write_s2f_decl_void@
F << remove_static_replace_write_s2f_decl_void.F;
P << remove_static_replace_write_s2f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_replace_write_s2f_def@
type T;
identifier F = replace_write_s2f;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_replace_write_s2f_def@
F << extract_replace_write_s2f_def.F;
T << extract_replace_write_s2f_def.T;
P << extract_replace_write_s2f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_replace_write_s2f_def_void@
identifier F = replace_write_s2f;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_replace_write_s2f_def_void@
F << extract_replace_write_s2f_def_void.F;
P << extract_replace_write_s2f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_replace_write_s2f_decl@
type T;
identifier F = replace_write_s2f;
parameter list P;
@@
T F(P);

@script:python depends on extract_replace_write_s2f_decl@
F << extract_replace_write_s2f_decl.F;
T << extract_replace_write_s2f_decl.T;
P << extract_replace_write_s2f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_replace_write_s2f_decl_void@
identifier F = replace_write_s2f;
parameter list P;
@@
void F(P);

@script:python depends on extract_replace_write_s2f_decl_void@
F << extract_replace_write_s2f_decl_void.F;
P << extract_replace_write_s2f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: rf64_close
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_rf64_close_def@
type T;
identifier F = rf64_close;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_rf64_close_def@
F << remove_static_rf64_close_def.F;
T << remove_static_rf64_close_def.T;
P << remove_static_rf64_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_rf64_close_def_void@
identifier F = rf64_close;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_rf64_close_def_void@
F << remove_static_rf64_close_def_void.F;
P << remove_static_rf64_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_rf64_close_decl@
type T;
identifier F = rf64_close;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_rf64_close_decl@
F << remove_static_rf64_close_decl.F;
T << remove_static_rf64_close_decl.T;
P << remove_static_rf64_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_rf64_close_decl_void@
identifier F = rf64_close;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_rf64_close_decl_void@
F << remove_static_rf64_close_decl_void.F;
P << remove_static_rf64_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_rf64_close_def@
type T;
identifier F = rf64_close;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_rf64_close_def@
F << extract_rf64_close_def.F;
T << extract_rf64_close_def.T;
P << extract_rf64_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_rf64_close_def_void@
identifier F = rf64_close;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_rf64_close_def_void@
F << extract_rf64_close_def_void.F;
P << extract_rf64_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_rf64_close_decl@
type T;
identifier F = rf64_close;
parameter list P;
@@
T F(P);

@script:python depends on extract_rf64_close_decl@
F << extract_rf64_close_decl.F;
T << extract_rf64_close_decl.T;
P << extract_rf64_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_rf64_close_decl_void@
identifier F = rf64_close;
parameter list P;
@@
void F(P);

@script:python depends on extract_rf64_close_decl_void@
F << extract_rf64_close_decl_void.F;
P << extract_rf64_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: rf64_command
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_rf64_command_def@
type T;
identifier F = rf64_command;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_rf64_command_def@
F << remove_static_rf64_command_def.F;
T << remove_static_rf64_command_def.T;
P << remove_static_rf64_command_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_rf64_command_def_void@
identifier F = rf64_command;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_rf64_command_def_void@
F << remove_static_rf64_command_def_void.F;
P << remove_static_rf64_command_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_rf64_command_decl@
type T;
identifier F = rf64_command;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_rf64_command_decl@
F << remove_static_rf64_command_decl.F;
T << remove_static_rf64_command_decl.T;
P << remove_static_rf64_command_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_rf64_command_decl_void@
identifier F = rf64_command;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_rf64_command_decl_void@
F << remove_static_rf64_command_decl_void.F;
P << remove_static_rf64_command_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_rf64_command_def@
type T;
identifier F = rf64_command;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_rf64_command_def@
F << extract_rf64_command_def.F;
T << extract_rf64_command_def.T;
P << extract_rf64_command_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_rf64_command_def_void@
identifier F = rf64_command;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_rf64_command_def_void@
F << extract_rf64_command_def_void.F;
P << extract_rf64_command_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_rf64_command_decl@
type T;
identifier F = rf64_command;
parameter list P;
@@
T F(P);

@script:python depends on extract_rf64_command_decl@
F << extract_rf64_command_decl.F;
T << extract_rf64_command_decl.T;
P << extract_rf64_command_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_rf64_command_decl_void@
identifier F = rf64_command;
parameter list P;
@@
void F(P);

@script:python depends on extract_rf64_command_decl_void@
F << extract_rf64_command_decl_void.F;
P << extract_rf64_command_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: rf64_get_chunk_data
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_rf64_get_chunk_data_def@
type T;
identifier F = rf64_get_chunk_data;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_rf64_get_chunk_data_def@
F << remove_static_rf64_get_chunk_data_def.F;
T << remove_static_rf64_get_chunk_data_def.T;
P << remove_static_rf64_get_chunk_data_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_rf64_get_chunk_data_def_void@
identifier F = rf64_get_chunk_data;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_rf64_get_chunk_data_def_void@
F << remove_static_rf64_get_chunk_data_def_void.F;
P << remove_static_rf64_get_chunk_data_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_rf64_get_chunk_data_decl@
type T;
identifier F = rf64_get_chunk_data;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_rf64_get_chunk_data_decl@
F << remove_static_rf64_get_chunk_data_decl.F;
T << remove_static_rf64_get_chunk_data_decl.T;
P << remove_static_rf64_get_chunk_data_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_rf64_get_chunk_data_decl_void@
identifier F = rf64_get_chunk_data;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_rf64_get_chunk_data_decl_void@
F << remove_static_rf64_get_chunk_data_decl_void.F;
P << remove_static_rf64_get_chunk_data_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_rf64_get_chunk_data_def@
type T;
identifier F = rf64_get_chunk_data;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_rf64_get_chunk_data_def@
F << extract_rf64_get_chunk_data_def.F;
T << extract_rf64_get_chunk_data_def.T;
P << extract_rf64_get_chunk_data_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_rf64_get_chunk_data_def_void@
identifier F = rf64_get_chunk_data;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_rf64_get_chunk_data_def_void@
F << extract_rf64_get_chunk_data_def_void.F;
P << extract_rf64_get_chunk_data_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_rf64_get_chunk_data_decl@
type T;
identifier F = rf64_get_chunk_data;
parameter list P;
@@
T F(P);

@script:python depends on extract_rf64_get_chunk_data_decl@
F << extract_rf64_get_chunk_data_decl.F;
T << extract_rf64_get_chunk_data_decl.T;
P << extract_rf64_get_chunk_data_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_rf64_get_chunk_data_decl_void@
identifier F = rf64_get_chunk_data;
parameter list P;
@@
void F(P);

@script:python depends on extract_rf64_get_chunk_data_decl_void@
F << extract_rf64_get_chunk_data_decl_void.F;
P << extract_rf64_get_chunk_data_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: rf64_get_chunk_size
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_rf64_get_chunk_size_def@
type T;
identifier F = rf64_get_chunk_size;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_rf64_get_chunk_size_def@
F << remove_static_rf64_get_chunk_size_def.F;
T << remove_static_rf64_get_chunk_size_def.T;
P << remove_static_rf64_get_chunk_size_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_rf64_get_chunk_size_def_void@
identifier F = rf64_get_chunk_size;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_rf64_get_chunk_size_def_void@
F << remove_static_rf64_get_chunk_size_def_void.F;
P << remove_static_rf64_get_chunk_size_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_rf64_get_chunk_size_decl@
type T;
identifier F = rf64_get_chunk_size;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_rf64_get_chunk_size_decl@
F << remove_static_rf64_get_chunk_size_decl.F;
T << remove_static_rf64_get_chunk_size_decl.T;
P << remove_static_rf64_get_chunk_size_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_rf64_get_chunk_size_decl_void@
identifier F = rf64_get_chunk_size;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_rf64_get_chunk_size_decl_void@
F << remove_static_rf64_get_chunk_size_decl_void.F;
P << remove_static_rf64_get_chunk_size_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_rf64_get_chunk_size_def@
type T;
identifier F = rf64_get_chunk_size;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_rf64_get_chunk_size_def@
F << extract_rf64_get_chunk_size_def.F;
T << extract_rf64_get_chunk_size_def.T;
P << extract_rf64_get_chunk_size_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_rf64_get_chunk_size_def_void@
identifier F = rf64_get_chunk_size;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_rf64_get_chunk_size_def_void@
F << extract_rf64_get_chunk_size_def_void.F;
P << extract_rf64_get_chunk_size_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_rf64_get_chunk_size_decl@
type T;
identifier F = rf64_get_chunk_size;
parameter list P;
@@
T F(P);

@script:python depends on extract_rf64_get_chunk_size_decl@
F << extract_rf64_get_chunk_size_decl.F;
T << extract_rf64_get_chunk_size_decl.T;
P << extract_rf64_get_chunk_size_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_rf64_get_chunk_size_decl_void@
identifier F = rf64_get_chunk_size;
parameter list P;
@@
void F(P);

@script:python depends on extract_rf64_get_chunk_size_decl_void@
F << extract_rf64_get_chunk_size_decl_void.F;
P << extract_rf64_get_chunk_size_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: rf64_next_chunk_iterator
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_rf64_next_chunk_iterator_def@
type T;
identifier F = rf64_next_chunk_iterator;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_rf64_next_chunk_iterator_def@
F << remove_static_rf64_next_chunk_iterator_def.F;
T << remove_static_rf64_next_chunk_iterator_def.T;
P << remove_static_rf64_next_chunk_iterator_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_rf64_next_chunk_iterator_def_void@
identifier F = rf64_next_chunk_iterator;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_rf64_next_chunk_iterator_def_void@
F << remove_static_rf64_next_chunk_iterator_def_void.F;
P << remove_static_rf64_next_chunk_iterator_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_rf64_next_chunk_iterator_decl@
type T;
identifier F = rf64_next_chunk_iterator;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_rf64_next_chunk_iterator_decl@
F << remove_static_rf64_next_chunk_iterator_decl.F;
T << remove_static_rf64_next_chunk_iterator_decl.T;
P << remove_static_rf64_next_chunk_iterator_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_rf64_next_chunk_iterator_decl_void@
identifier F = rf64_next_chunk_iterator;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_rf64_next_chunk_iterator_decl_void@
F << remove_static_rf64_next_chunk_iterator_decl_void.F;
P << remove_static_rf64_next_chunk_iterator_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_rf64_next_chunk_iterator_def@
type T;
identifier F = rf64_next_chunk_iterator;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_rf64_next_chunk_iterator_def@
F << extract_rf64_next_chunk_iterator_def.F;
T << extract_rf64_next_chunk_iterator_def.T;
P << extract_rf64_next_chunk_iterator_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_rf64_next_chunk_iterator_def_void@
identifier F = rf64_next_chunk_iterator;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_rf64_next_chunk_iterator_def_void@
F << extract_rf64_next_chunk_iterator_def_void.F;
P << extract_rf64_next_chunk_iterator_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_rf64_next_chunk_iterator_decl@
type T;
identifier F = rf64_next_chunk_iterator;
parameter list P;
@@
T F(P);

@script:python depends on extract_rf64_next_chunk_iterator_decl@
F << extract_rf64_next_chunk_iterator_decl.F;
T << extract_rf64_next_chunk_iterator_decl.T;
P << extract_rf64_next_chunk_iterator_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_rf64_next_chunk_iterator_decl_void@
identifier F = rf64_next_chunk_iterator;
parameter list P;
@@
void F(P);

@script:python depends on extract_rf64_next_chunk_iterator_decl_void@
F << extract_rf64_next_chunk_iterator_decl_void.F;
P << extract_rf64_next_chunk_iterator_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: rf64_set_chunk
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_rf64_set_chunk_def@
type T;
identifier F = rf64_set_chunk;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_rf64_set_chunk_def@
F << remove_static_rf64_set_chunk_def.F;
T << remove_static_rf64_set_chunk_def.T;
P << remove_static_rf64_set_chunk_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_rf64_set_chunk_def_void@
identifier F = rf64_set_chunk;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_rf64_set_chunk_def_void@
F << remove_static_rf64_set_chunk_def_void.F;
P << remove_static_rf64_set_chunk_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_rf64_set_chunk_decl@
type T;
identifier F = rf64_set_chunk;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_rf64_set_chunk_decl@
F << remove_static_rf64_set_chunk_decl.F;
T << remove_static_rf64_set_chunk_decl.T;
P << remove_static_rf64_set_chunk_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_rf64_set_chunk_decl_void@
identifier F = rf64_set_chunk;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_rf64_set_chunk_decl_void@
F << remove_static_rf64_set_chunk_decl_void.F;
P << remove_static_rf64_set_chunk_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_rf64_set_chunk_def@
type T;
identifier F = rf64_set_chunk;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_rf64_set_chunk_def@
F << extract_rf64_set_chunk_def.F;
T << extract_rf64_set_chunk_def.T;
P << extract_rf64_set_chunk_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_rf64_set_chunk_def_void@
identifier F = rf64_set_chunk;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_rf64_set_chunk_def_void@
F << extract_rf64_set_chunk_def_void.F;
P << extract_rf64_set_chunk_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_rf64_set_chunk_decl@
type T;
identifier F = rf64_set_chunk;
parameter list P;
@@
T F(P);

@script:python depends on extract_rf64_set_chunk_decl@
F << extract_rf64_set_chunk_decl.F;
T << extract_rf64_set_chunk_decl.T;
P << extract_rf64_set_chunk_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_rf64_set_chunk_decl_void@
identifier F = rf64_set_chunk;
parameter list P;
@@
void F(P);

@script:python depends on extract_rf64_set_chunk_decl_void@
F << extract_rf64_set_chunk_decl_void.F;
P << extract_rf64_set_chunk_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: rf64_write_header
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_rf64_write_header_def@
type T;
identifier F = rf64_write_header;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_rf64_write_header_def@
F << remove_static_rf64_write_header_def.F;
T << remove_static_rf64_write_header_def.T;
P << remove_static_rf64_write_header_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_rf64_write_header_def_void@
identifier F = rf64_write_header;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_rf64_write_header_def_void@
F << remove_static_rf64_write_header_def_void.F;
P << remove_static_rf64_write_header_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_rf64_write_header_decl@
type T;
identifier F = rf64_write_header;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_rf64_write_header_decl@
F << remove_static_rf64_write_header_decl.F;
T << remove_static_rf64_write_header_decl.T;
P << remove_static_rf64_write_header_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_rf64_write_header_decl_void@
identifier F = rf64_write_header;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_rf64_write_header_decl_void@
F << remove_static_rf64_write_header_decl_void.F;
P << remove_static_rf64_write_header_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_rf64_write_header_def@
type T;
identifier F = rf64_write_header;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_rf64_write_header_def@
F << extract_rf64_write_header_def.F;
T << extract_rf64_write_header_def.T;
P << extract_rf64_write_header_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_rf64_write_header_def_void@
identifier F = rf64_write_header;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_rf64_write_header_def_void@
F << extract_rf64_write_header_def_void.F;
P << extract_rf64_write_header_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_rf64_write_header_decl@
type T;
identifier F = rf64_write_header;
parameter list P;
@@
T F(P);

@script:python depends on extract_rf64_write_header_decl@
F << extract_rf64_write_header_decl.F;
T << extract_rf64_write_header_decl.T;
P << extract_rf64_write_header_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_rf64_write_header_decl_void@
identifier F = rf64_write_header;
parameter list P;
@@
void F(P);

@script:python depends on extract_rf64_write_header_decl_void@
F << extract_rf64_write_header_decl_void.F;
P << extract_rf64_write_header_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: rx2_close
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_rx2_close_def@
type T;
identifier F = rx2_close;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_rx2_close_def@
F << remove_static_rx2_close_def.F;
T << remove_static_rx2_close_def.T;
P << remove_static_rx2_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_rx2_close_def_void@
identifier F = rx2_close;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_rx2_close_def_void@
F << remove_static_rx2_close_def_void.F;
P << remove_static_rx2_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_rx2_close_decl@
type T;
identifier F = rx2_close;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_rx2_close_decl@
F << remove_static_rx2_close_decl.F;
T << remove_static_rx2_close_decl.T;
P << remove_static_rx2_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_rx2_close_decl_void@
identifier F = rx2_close;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_rx2_close_decl_void@
F << remove_static_rx2_close_decl_void.F;
P << remove_static_rx2_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_rx2_close_def@
type T;
identifier F = rx2_close;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_rx2_close_def@
F << extract_rx2_close_def.F;
T << extract_rx2_close_def.T;
P << extract_rx2_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_rx2_close_def_void@
identifier F = rx2_close;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_rx2_close_def_void@
F << extract_rx2_close_def_void.F;
P << extract_rx2_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_rx2_close_decl@
type T;
identifier F = rx2_close;
parameter list P;
@@
T F(P);

@script:python depends on extract_rx2_close_decl@
F << extract_rx2_close_decl.F;
T << extract_rx2_close_decl.T;
P << extract_rx2_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_rx2_close_decl_void@
identifier F = rx2_close;
parameter list P;
@@
void F(P);

@script:python depends on extract_rx2_close_decl_void@
F << extract_rx2_close_decl_void.F;
P << extract_rx2_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: sd2_close
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_sd2_close_def@
type T;
identifier F = sd2_close;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_sd2_close_def@
F << remove_static_sd2_close_def.F;
T << remove_static_sd2_close_def.T;
P << remove_static_sd2_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_sd2_close_def_void@
identifier F = sd2_close;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_sd2_close_def_void@
F << remove_static_sd2_close_def_void.F;
P << remove_static_sd2_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_sd2_close_decl@
type T;
identifier F = sd2_close;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_sd2_close_decl@
F << remove_static_sd2_close_decl.F;
T << remove_static_sd2_close_decl.T;
P << remove_static_sd2_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_sd2_close_decl_void@
identifier F = sd2_close;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_sd2_close_decl_void@
F << remove_static_sd2_close_decl_void.F;
P << remove_static_sd2_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_sd2_close_def@
type T;
identifier F = sd2_close;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_sd2_close_def@
F << extract_sd2_close_def.F;
T << extract_sd2_close_def.T;
P << extract_sd2_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_sd2_close_def_void@
identifier F = sd2_close;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_sd2_close_def_void@
F << extract_sd2_close_def_void.F;
P << extract_sd2_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_sd2_close_decl@
type T;
identifier F = sd2_close;
parameter list P;
@@
T F(P);

@script:python depends on extract_sd2_close_decl@
F << extract_sd2_close_decl.F;
T << extract_sd2_close_decl.T;
P << extract_sd2_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_sd2_close_decl_void@
identifier F = sd2_close;
parameter list P;
@@
void F(P);

@script:python depends on extract_sd2_close_decl_void@
F << extract_sd2_close_decl_void.F;
P << extract_sd2_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: sds_2byte_read
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_sds_2byte_read_def@
type T;
identifier F = sds_2byte_read;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_sds_2byte_read_def@
F << remove_static_sds_2byte_read_def.F;
T << remove_static_sds_2byte_read_def.T;
P << remove_static_sds_2byte_read_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_sds_2byte_read_def_void@
identifier F = sds_2byte_read;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_sds_2byte_read_def_void@
F << remove_static_sds_2byte_read_def_void.F;
P << remove_static_sds_2byte_read_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_sds_2byte_read_decl@
type T;
identifier F = sds_2byte_read;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_sds_2byte_read_decl@
F << remove_static_sds_2byte_read_decl.F;
T << remove_static_sds_2byte_read_decl.T;
P << remove_static_sds_2byte_read_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_sds_2byte_read_decl_void@
identifier F = sds_2byte_read;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_sds_2byte_read_decl_void@
F << remove_static_sds_2byte_read_decl_void.F;
P << remove_static_sds_2byte_read_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_sds_2byte_read_def@
type T;
identifier F = sds_2byte_read;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_sds_2byte_read_def@
F << extract_sds_2byte_read_def.F;
T << extract_sds_2byte_read_def.T;
P << extract_sds_2byte_read_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_sds_2byte_read_def_void@
identifier F = sds_2byte_read;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_sds_2byte_read_def_void@
F << extract_sds_2byte_read_def_void.F;
P << extract_sds_2byte_read_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_sds_2byte_read_decl@
type T;
identifier F = sds_2byte_read;
parameter list P;
@@
T F(P);

@script:python depends on extract_sds_2byte_read_decl@
F << extract_sds_2byte_read_decl.F;
T << extract_sds_2byte_read_decl.T;
P << extract_sds_2byte_read_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_sds_2byte_read_decl_void@
identifier F = sds_2byte_read;
parameter list P;
@@
void F(P);

@script:python depends on extract_sds_2byte_read_decl_void@
F << extract_sds_2byte_read_decl_void.F;
P << extract_sds_2byte_read_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: sds_2byte_write
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_sds_2byte_write_def@
type T;
identifier F = sds_2byte_write;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_sds_2byte_write_def@
F << remove_static_sds_2byte_write_def.F;
T << remove_static_sds_2byte_write_def.T;
P << remove_static_sds_2byte_write_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_sds_2byte_write_def_void@
identifier F = sds_2byte_write;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_sds_2byte_write_def_void@
F << remove_static_sds_2byte_write_def_void.F;
P << remove_static_sds_2byte_write_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_sds_2byte_write_decl@
type T;
identifier F = sds_2byte_write;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_sds_2byte_write_decl@
F << remove_static_sds_2byte_write_decl.F;
T << remove_static_sds_2byte_write_decl.T;
P << remove_static_sds_2byte_write_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_sds_2byte_write_decl_void@
identifier F = sds_2byte_write;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_sds_2byte_write_decl_void@
F << remove_static_sds_2byte_write_decl_void.F;
P << remove_static_sds_2byte_write_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_sds_2byte_write_def@
type T;
identifier F = sds_2byte_write;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_sds_2byte_write_def@
F << extract_sds_2byte_write_def.F;
T << extract_sds_2byte_write_def.T;
P << extract_sds_2byte_write_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_sds_2byte_write_def_void@
identifier F = sds_2byte_write;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_sds_2byte_write_def_void@
F << extract_sds_2byte_write_def_void.F;
P << extract_sds_2byte_write_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_sds_2byte_write_decl@
type T;
identifier F = sds_2byte_write;
parameter list P;
@@
T F(P);

@script:python depends on extract_sds_2byte_write_decl@
F << extract_sds_2byte_write_decl.F;
T << extract_sds_2byte_write_decl.T;
P << extract_sds_2byte_write_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_sds_2byte_write_decl_void@
identifier F = sds_2byte_write;
parameter list P;
@@
void F(P);

@script:python depends on extract_sds_2byte_write_decl_void@
F << extract_sds_2byte_write_decl_void.F;
P << extract_sds_2byte_write_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: sds_3byte_read
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_sds_3byte_read_def@
type T;
identifier F = sds_3byte_read;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_sds_3byte_read_def@
F << remove_static_sds_3byte_read_def.F;
T << remove_static_sds_3byte_read_def.T;
P << remove_static_sds_3byte_read_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_sds_3byte_read_def_void@
identifier F = sds_3byte_read;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_sds_3byte_read_def_void@
F << remove_static_sds_3byte_read_def_void.F;
P << remove_static_sds_3byte_read_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_sds_3byte_read_decl@
type T;
identifier F = sds_3byte_read;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_sds_3byte_read_decl@
F << remove_static_sds_3byte_read_decl.F;
T << remove_static_sds_3byte_read_decl.T;
P << remove_static_sds_3byte_read_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_sds_3byte_read_decl_void@
identifier F = sds_3byte_read;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_sds_3byte_read_decl_void@
F << remove_static_sds_3byte_read_decl_void.F;
P << remove_static_sds_3byte_read_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_sds_3byte_read_def@
type T;
identifier F = sds_3byte_read;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_sds_3byte_read_def@
F << extract_sds_3byte_read_def.F;
T << extract_sds_3byte_read_def.T;
P << extract_sds_3byte_read_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_sds_3byte_read_def_void@
identifier F = sds_3byte_read;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_sds_3byte_read_def_void@
F << extract_sds_3byte_read_def_void.F;
P << extract_sds_3byte_read_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_sds_3byte_read_decl@
type T;
identifier F = sds_3byte_read;
parameter list P;
@@
T F(P);

@script:python depends on extract_sds_3byte_read_decl@
F << extract_sds_3byte_read_decl.F;
T << extract_sds_3byte_read_decl.T;
P << extract_sds_3byte_read_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_sds_3byte_read_decl_void@
identifier F = sds_3byte_read;
parameter list P;
@@
void F(P);

@script:python depends on extract_sds_3byte_read_decl_void@
F << extract_sds_3byte_read_decl_void.F;
P << extract_sds_3byte_read_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: sds_3byte_write
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_sds_3byte_write_def@
type T;
identifier F = sds_3byte_write;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_sds_3byte_write_def@
F << remove_static_sds_3byte_write_def.F;
T << remove_static_sds_3byte_write_def.T;
P << remove_static_sds_3byte_write_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_sds_3byte_write_def_void@
identifier F = sds_3byte_write;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_sds_3byte_write_def_void@
F << remove_static_sds_3byte_write_def_void.F;
P << remove_static_sds_3byte_write_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_sds_3byte_write_decl@
type T;
identifier F = sds_3byte_write;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_sds_3byte_write_decl@
F << remove_static_sds_3byte_write_decl.F;
T << remove_static_sds_3byte_write_decl.T;
P << remove_static_sds_3byte_write_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_sds_3byte_write_decl_void@
identifier F = sds_3byte_write;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_sds_3byte_write_decl_void@
F << remove_static_sds_3byte_write_decl_void.F;
P << remove_static_sds_3byte_write_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_sds_3byte_write_def@
type T;
identifier F = sds_3byte_write;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_sds_3byte_write_def@
F << extract_sds_3byte_write_def.F;
T << extract_sds_3byte_write_def.T;
P << extract_sds_3byte_write_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_sds_3byte_write_def_void@
identifier F = sds_3byte_write;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_sds_3byte_write_def_void@
F << extract_sds_3byte_write_def_void.F;
P << extract_sds_3byte_write_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_sds_3byte_write_decl@
type T;
identifier F = sds_3byte_write;
parameter list P;
@@
T F(P);

@script:python depends on extract_sds_3byte_write_decl@
F << extract_sds_3byte_write_decl.F;
T << extract_sds_3byte_write_decl.T;
P << extract_sds_3byte_write_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_sds_3byte_write_decl_void@
identifier F = sds_3byte_write;
parameter list P;
@@
void F(P);

@script:python depends on extract_sds_3byte_write_decl_void@
F << extract_sds_3byte_write_decl_void.F;
P << extract_sds_3byte_write_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: sds_4byte_read
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_sds_4byte_read_def@
type T;
identifier F = sds_4byte_read;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_sds_4byte_read_def@
F << remove_static_sds_4byte_read_def.F;
T << remove_static_sds_4byte_read_def.T;
P << remove_static_sds_4byte_read_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_sds_4byte_read_def_void@
identifier F = sds_4byte_read;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_sds_4byte_read_def_void@
F << remove_static_sds_4byte_read_def_void.F;
P << remove_static_sds_4byte_read_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_sds_4byte_read_decl@
type T;
identifier F = sds_4byte_read;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_sds_4byte_read_decl@
F << remove_static_sds_4byte_read_decl.F;
T << remove_static_sds_4byte_read_decl.T;
P << remove_static_sds_4byte_read_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_sds_4byte_read_decl_void@
identifier F = sds_4byte_read;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_sds_4byte_read_decl_void@
F << remove_static_sds_4byte_read_decl_void.F;
P << remove_static_sds_4byte_read_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_sds_4byte_read_def@
type T;
identifier F = sds_4byte_read;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_sds_4byte_read_def@
F << extract_sds_4byte_read_def.F;
T << extract_sds_4byte_read_def.T;
P << extract_sds_4byte_read_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_sds_4byte_read_def_void@
identifier F = sds_4byte_read;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_sds_4byte_read_def_void@
F << extract_sds_4byte_read_def_void.F;
P << extract_sds_4byte_read_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_sds_4byte_read_decl@
type T;
identifier F = sds_4byte_read;
parameter list P;
@@
T F(P);

@script:python depends on extract_sds_4byte_read_decl@
F << extract_sds_4byte_read_decl.F;
T << extract_sds_4byte_read_decl.T;
P << extract_sds_4byte_read_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_sds_4byte_read_decl_void@
identifier F = sds_4byte_read;
parameter list P;
@@
void F(P);

@script:python depends on extract_sds_4byte_read_decl_void@
F << extract_sds_4byte_read_decl_void.F;
P << extract_sds_4byte_read_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: sds_4byte_write
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_sds_4byte_write_def@
type T;
identifier F = sds_4byte_write;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_sds_4byte_write_def@
F << remove_static_sds_4byte_write_def.F;
T << remove_static_sds_4byte_write_def.T;
P << remove_static_sds_4byte_write_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_sds_4byte_write_def_void@
identifier F = sds_4byte_write;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_sds_4byte_write_def_void@
F << remove_static_sds_4byte_write_def_void.F;
P << remove_static_sds_4byte_write_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_sds_4byte_write_decl@
type T;
identifier F = sds_4byte_write;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_sds_4byte_write_decl@
F << remove_static_sds_4byte_write_decl.F;
T << remove_static_sds_4byte_write_decl.T;
P << remove_static_sds_4byte_write_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_sds_4byte_write_decl_void@
identifier F = sds_4byte_write;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_sds_4byte_write_decl_void@
F << remove_static_sds_4byte_write_decl_void.F;
P << remove_static_sds_4byte_write_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_sds_4byte_write_def@
type T;
identifier F = sds_4byte_write;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_sds_4byte_write_def@
F << extract_sds_4byte_write_def.F;
T << extract_sds_4byte_write_def.T;
P << extract_sds_4byte_write_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_sds_4byte_write_def_void@
identifier F = sds_4byte_write;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_sds_4byte_write_def_void@
F << extract_sds_4byte_write_def_void.F;
P << extract_sds_4byte_write_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_sds_4byte_write_decl@
type T;
identifier F = sds_4byte_write;
parameter list P;
@@
T F(P);

@script:python depends on extract_sds_4byte_write_decl@
F << extract_sds_4byte_write_decl.F;
T << extract_sds_4byte_write_decl.T;
P << extract_sds_4byte_write_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_sds_4byte_write_decl_void@
identifier F = sds_4byte_write;
parameter list P;
@@
void F(P);

@script:python depends on extract_sds_4byte_write_decl_void@
F << extract_sds_4byte_write_decl_void.F;
P << extract_sds_4byte_write_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: sds_byterate
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_sds_byterate_def@
type T;
identifier F = sds_byterate;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_sds_byterate_def@
F << remove_static_sds_byterate_def.F;
T << remove_static_sds_byterate_def.T;
P << remove_static_sds_byterate_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_sds_byterate_def_void@
identifier F = sds_byterate;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_sds_byterate_def_void@
F << remove_static_sds_byterate_def_void.F;
P << remove_static_sds_byterate_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_sds_byterate_decl@
type T;
identifier F = sds_byterate;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_sds_byterate_decl@
F << remove_static_sds_byterate_decl.F;
T << remove_static_sds_byterate_decl.T;
P << remove_static_sds_byterate_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_sds_byterate_decl_void@
identifier F = sds_byterate;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_sds_byterate_decl_void@
F << remove_static_sds_byterate_decl_void.F;
P << remove_static_sds_byterate_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_sds_byterate_def@
type T;
identifier F = sds_byterate;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_sds_byterate_def@
F << extract_sds_byterate_def.F;
T << extract_sds_byterate_def.T;
P << extract_sds_byterate_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_sds_byterate_def_void@
identifier F = sds_byterate;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_sds_byterate_def_void@
F << extract_sds_byterate_def_void.F;
P << extract_sds_byterate_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_sds_byterate_decl@
type T;
identifier F = sds_byterate;
parameter list P;
@@
T F(P);

@script:python depends on extract_sds_byterate_decl@
F << extract_sds_byterate_decl.F;
T << extract_sds_byterate_decl.T;
P << extract_sds_byterate_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_sds_byterate_decl_void@
identifier F = sds_byterate;
parameter list P;
@@
void F(P);

@script:python depends on extract_sds_byterate_decl_void@
F << extract_sds_byterate_decl_void.F;
P << extract_sds_byterate_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: sds_close
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_sds_close_def@
type T;
identifier F = sds_close;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_sds_close_def@
F << remove_static_sds_close_def.F;
T << remove_static_sds_close_def.T;
P << remove_static_sds_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_sds_close_def_void@
identifier F = sds_close;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_sds_close_def_void@
F << remove_static_sds_close_def_void.F;
P << remove_static_sds_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_sds_close_decl@
type T;
identifier F = sds_close;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_sds_close_decl@
F << remove_static_sds_close_decl.F;
T << remove_static_sds_close_decl.T;
P << remove_static_sds_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_sds_close_decl_void@
identifier F = sds_close;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_sds_close_decl_void@
F << remove_static_sds_close_decl_void.F;
P << remove_static_sds_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_sds_close_def@
type T;
identifier F = sds_close;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_sds_close_def@
F << extract_sds_close_def.F;
T << extract_sds_close_def.T;
P << extract_sds_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_sds_close_def_void@
identifier F = sds_close;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_sds_close_def_void@
F << extract_sds_close_def_void.F;
P << extract_sds_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_sds_close_decl@
type T;
identifier F = sds_close;
parameter list P;
@@
T F(P);

@script:python depends on extract_sds_close_decl@
F << extract_sds_close_decl.F;
T << extract_sds_close_decl.T;
P << extract_sds_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_sds_close_decl_void@
identifier F = sds_close;
parameter list P;
@@
void F(P);

@script:python depends on extract_sds_close_decl_void@
F << extract_sds_close_decl_void.F;
P << extract_sds_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: sds_read_d
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_sds_read_d_def@
type T;
identifier F = sds_read_d;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_sds_read_d_def@
F << remove_static_sds_read_d_def.F;
T << remove_static_sds_read_d_def.T;
P << remove_static_sds_read_d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_sds_read_d_def_void@
identifier F = sds_read_d;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_sds_read_d_def_void@
F << remove_static_sds_read_d_def_void.F;
P << remove_static_sds_read_d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_sds_read_d_decl@
type T;
identifier F = sds_read_d;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_sds_read_d_decl@
F << remove_static_sds_read_d_decl.F;
T << remove_static_sds_read_d_decl.T;
P << remove_static_sds_read_d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_sds_read_d_decl_void@
identifier F = sds_read_d;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_sds_read_d_decl_void@
F << remove_static_sds_read_d_decl_void.F;
P << remove_static_sds_read_d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_sds_read_d_def@
type T;
identifier F = sds_read_d;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_sds_read_d_def@
F << extract_sds_read_d_def.F;
T << extract_sds_read_d_def.T;
P << extract_sds_read_d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_sds_read_d_def_void@
identifier F = sds_read_d;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_sds_read_d_def_void@
F << extract_sds_read_d_def_void.F;
P << extract_sds_read_d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_sds_read_d_decl@
type T;
identifier F = sds_read_d;
parameter list P;
@@
T F(P);

@script:python depends on extract_sds_read_d_decl@
F << extract_sds_read_d_decl.F;
T << extract_sds_read_d_decl.T;
P << extract_sds_read_d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_sds_read_d_decl_void@
identifier F = sds_read_d;
parameter list P;
@@
void F(P);

@script:python depends on extract_sds_read_d_decl_void@
F << extract_sds_read_d_decl_void.F;
P << extract_sds_read_d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: sds_read_f
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_sds_read_f_def@
type T;
identifier F = sds_read_f;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_sds_read_f_def@
F << remove_static_sds_read_f_def.F;
T << remove_static_sds_read_f_def.T;
P << remove_static_sds_read_f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_sds_read_f_def_void@
identifier F = sds_read_f;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_sds_read_f_def_void@
F << remove_static_sds_read_f_def_void.F;
P << remove_static_sds_read_f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_sds_read_f_decl@
type T;
identifier F = sds_read_f;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_sds_read_f_decl@
F << remove_static_sds_read_f_decl.F;
T << remove_static_sds_read_f_decl.T;
P << remove_static_sds_read_f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_sds_read_f_decl_void@
identifier F = sds_read_f;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_sds_read_f_decl_void@
F << remove_static_sds_read_f_decl_void.F;
P << remove_static_sds_read_f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_sds_read_f_def@
type T;
identifier F = sds_read_f;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_sds_read_f_def@
F << extract_sds_read_f_def.F;
T << extract_sds_read_f_def.T;
P << extract_sds_read_f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_sds_read_f_def_void@
identifier F = sds_read_f;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_sds_read_f_def_void@
F << extract_sds_read_f_def_void.F;
P << extract_sds_read_f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_sds_read_f_decl@
type T;
identifier F = sds_read_f;
parameter list P;
@@
T F(P);

@script:python depends on extract_sds_read_f_decl@
F << extract_sds_read_f_decl.F;
T << extract_sds_read_f_decl.T;
P << extract_sds_read_f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_sds_read_f_decl_void@
identifier F = sds_read_f;
parameter list P;
@@
void F(P);

@script:python depends on extract_sds_read_f_decl_void@
F << extract_sds_read_f_decl_void.F;
P << extract_sds_read_f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: sds_read_i
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_sds_read_i_def@
type T;
identifier F = sds_read_i;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_sds_read_i_def@
F << remove_static_sds_read_i_def.F;
T << remove_static_sds_read_i_def.T;
P << remove_static_sds_read_i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_sds_read_i_def_void@
identifier F = sds_read_i;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_sds_read_i_def_void@
F << remove_static_sds_read_i_def_void.F;
P << remove_static_sds_read_i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_sds_read_i_decl@
type T;
identifier F = sds_read_i;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_sds_read_i_decl@
F << remove_static_sds_read_i_decl.F;
T << remove_static_sds_read_i_decl.T;
P << remove_static_sds_read_i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_sds_read_i_decl_void@
identifier F = sds_read_i;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_sds_read_i_decl_void@
F << remove_static_sds_read_i_decl_void.F;
P << remove_static_sds_read_i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_sds_read_i_def@
type T;
identifier F = sds_read_i;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_sds_read_i_def@
F << extract_sds_read_i_def.F;
T << extract_sds_read_i_def.T;
P << extract_sds_read_i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_sds_read_i_def_void@
identifier F = sds_read_i;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_sds_read_i_def_void@
F << extract_sds_read_i_def_void.F;
P << extract_sds_read_i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_sds_read_i_decl@
type T;
identifier F = sds_read_i;
parameter list P;
@@
T F(P);

@script:python depends on extract_sds_read_i_decl@
F << extract_sds_read_i_decl.F;
T << extract_sds_read_i_decl.T;
P << extract_sds_read_i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_sds_read_i_decl_void@
identifier F = sds_read_i;
parameter list P;
@@
void F(P);

@script:python depends on extract_sds_read_i_decl_void@
F << extract_sds_read_i_decl_void.F;
P << extract_sds_read_i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: sds_read_s
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_sds_read_s_def@
type T;
identifier F = sds_read_s;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_sds_read_s_def@
F << remove_static_sds_read_s_def.F;
T << remove_static_sds_read_s_def.T;
P << remove_static_sds_read_s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_sds_read_s_def_void@
identifier F = sds_read_s;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_sds_read_s_def_void@
F << remove_static_sds_read_s_def_void.F;
P << remove_static_sds_read_s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_sds_read_s_decl@
type T;
identifier F = sds_read_s;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_sds_read_s_decl@
F << remove_static_sds_read_s_decl.F;
T << remove_static_sds_read_s_decl.T;
P << remove_static_sds_read_s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_sds_read_s_decl_void@
identifier F = sds_read_s;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_sds_read_s_decl_void@
F << remove_static_sds_read_s_decl_void.F;
P << remove_static_sds_read_s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_sds_read_s_def@
type T;
identifier F = sds_read_s;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_sds_read_s_def@
F << extract_sds_read_s_def.F;
T << extract_sds_read_s_def.T;
P << extract_sds_read_s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_sds_read_s_def_void@
identifier F = sds_read_s;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_sds_read_s_def_void@
F << extract_sds_read_s_def_void.F;
P << extract_sds_read_s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_sds_read_s_decl@
type T;
identifier F = sds_read_s;
parameter list P;
@@
T F(P);

@script:python depends on extract_sds_read_s_decl@
F << extract_sds_read_s_decl.F;
T << extract_sds_read_s_decl.T;
P << extract_sds_read_s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_sds_read_s_decl_void@
identifier F = sds_read_s;
parameter list P;
@@
void F(P);

@script:python depends on extract_sds_read_s_decl_void@
F << extract_sds_read_s_decl_void.F;
P << extract_sds_read_s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: sds_seek
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_sds_seek_def@
type T;
identifier F = sds_seek;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_sds_seek_def@
F << remove_static_sds_seek_def.F;
T << remove_static_sds_seek_def.T;
P << remove_static_sds_seek_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_sds_seek_def_void@
identifier F = sds_seek;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_sds_seek_def_void@
F << remove_static_sds_seek_def_void.F;
P << remove_static_sds_seek_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_sds_seek_decl@
type T;
identifier F = sds_seek;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_sds_seek_decl@
F << remove_static_sds_seek_decl.F;
T << remove_static_sds_seek_decl.T;
P << remove_static_sds_seek_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_sds_seek_decl_void@
identifier F = sds_seek;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_sds_seek_decl_void@
F << remove_static_sds_seek_decl_void.F;
P << remove_static_sds_seek_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_sds_seek_def@
type T;
identifier F = sds_seek;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_sds_seek_def@
F << extract_sds_seek_def.F;
T << extract_sds_seek_def.T;
P << extract_sds_seek_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_sds_seek_def_void@
identifier F = sds_seek;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_sds_seek_def_void@
F << extract_sds_seek_def_void.F;
P << extract_sds_seek_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_sds_seek_decl@
type T;
identifier F = sds_seek;
parameter list P;
@@
T F(P);

@script:python depends on extract_sds_seek_decl@
F << extract_sds_seek_decl.F;
T << extract_sds_seek_decl.T;
P << extract_sds_seek_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_sds_seek_decl_void@
identifier F = sds_seek;
parameter list P;
@@
void F(P);

@script:python depends on extract_sds_seek_decl_void@
F << extract_sds_seek_decl_void.F;
P << extract_sds_seek_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: sds_write_d
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_sds_write_d_def@
type T;
identifier F = sds_write_d;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_sds_write_d_def@
F << remove_static_sds_write_d_def.F;
T << remove_static_sds_write_d_def.T;
P << remove_static_sds_write_d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_sds_write_d_def_void@
identifier F = sds_write_d;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_sds_write_d_def_void@
F << remove_static_sds_write_d_def_void.F;
P << remove_static_sds_write_d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_sds_write_d_decl@
type T;
identifier F = sds_write_d;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_sds_write_d_decl@
F << remove_static_sds_write_d_decl.F;
T << remove_static_sds_write_d_decl.T;
P << remove_static_sds_write_d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_sds_write_d_decl_void@
identifier F = sds_write_d;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_sds_write_d_decl_void@
F << remove_static_sds_write_d_decl_void.F;
P << remove_static_sds_write_d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_sds_write_d_def@
type T;
identifier F = sds_write_d;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_sds_write_d_def@
F << extract_sds_write_d_def.F;
T << extract_sds_write_d_def.T;
P << extract_sds_write_d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_sds_write_d_def_void@
identifier F = sds_write_d;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_sds_write_d_def_void@
F << extract_sds_write_d_def_void.F;
P << extract_sds_write_d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_sds_write_d_decl@
type T;
identifier F = sds_write_d;
parameter list P;
@@
T F(P);

@script:python depends on extract_sds_write_d_decl@
F << extract_sds_write_d_decl.F;
T << extract_sds_write_d_decl.T;
P << extract_sds_write_d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_sds_write_d_decl_void@
identifier F = sds_write_d;
parameter list P;
@@
void F(P);

@script:python depends on extract_sds_write_d_decl_void@
F << extract_sds_write_d_decl_void.F;
P << extract_sds_write_d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: sds_write_f
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_sds_write_f_def@
type T;
identifier F = sds_write_f;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_sds_write_f_def@
F << remove_static_sds_write_f_def.F;
T << remove_static_sds_write_f_def.T;
P << remove_static_sds_write_f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_sds_write_f_def_void@
identifier F = sds_write_f;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_sds_write_f_def_void@
F << remove_static_sds_write_f_def_void.F;
P << remove_static_sds_write_f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_sds_write_f_decl@
type T;
identifier F = sds_write_f;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_sds_write_f_decl@
F << remove_static_sds_write_f_decl.F;
T << remove_static_sds_write_f_decl.T;
P << remove_static_sds_write_f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_sds_write_f_decl_void@
identifier F = sds_write_f;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_sds_write_f_decl_void@
F << remove_static_sds_write_f_decl_void.F;
P << remove_static_sds_write_f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_sds_write_f_def@
type T;
identifier F = sds_write_f;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_sds_write_f_def@
F << extract_sds_write_f_def.F;
T << extract_sds_write_f_def.T;
P << extract_sds_write_f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_sds_write_f_def_void@
identifier F = sds_write_f;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_sds_write_f_def_void@
F << extract_sds_write_f_def_void.F;
P << extract_sds_write_f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_sds_write_f_decl@
type T;
identifier F = sds_write_f;
parameter list P;
@@
T F(P);

@script:python depends on extract_sds_write_f_decl@
F << extract_sds_write_f_decl.F;
T << extract_sds_write_f_decl.T;
P << extract_sds_write_f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_sds_write_f_decl_void@
identifier F = sds_write_f;
parameter list P;
@@
void F(P);

@script:python depends on extract_sds_write_f_decl_void@
F << extract_sds_write_f_decl_void.F;
P << extract_sds_write_f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: sds_write_header
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_sds_write_header_def@
type T;
identifier F = sds_write_header;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_sds_write_header_def@
F << remove_static_sds_write_header_def.F;
T << remove_static_sds_write_header_def.T;
P << remove_static_sds_write_header_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_sds_write_header_def_void@
identifier F = sds_write_header;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_sds_write_header_def_void@
F << remove_static_sds_write_header_def_void.F;
P << remove_static_sds_write_header_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_sds_write_header_decl@
type T;
identifier F = sds_write_header;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_sds_write_header_decl@
F << remove_static_sds_write_header_decl.F;
T << remove_static_sds_write_header_decl.T;
P << remove_static_sds_write_header_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_sds_write_header_decl_void@
identifier F = sds_write_header;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_sds_write_header_decl_void@
F << remove_static_sds_write_header_decl_void.F;
P << remove_static_sds_write_header_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_sds_write_header_def@
type T;
identifier F = sds_write_header;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_sds_write_header_def@
F << extract_sds_write_header_def.F;
T << extract_sds_write_header_def.T;
P << extract_sds_write_header_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_sds_write_header_def_void@
identifier F = sds_write_header;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_sds_write_header_def_void@
F << extract_sds_write_header_def_void.F;
P << extract_sds_write_header_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_sds_write_header_decl@
type T;
identifier F = sds_write_header;
parameter list P;
@@
T F(P);

@script:python depends on extract_sds_write_header_decl@
F << extract_sds_write_header_decl.F;
T << extract_sds_write_header_decl.T;
P << extract_sds_write_header_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_sds_write_header_decl_void@
identifier F = sds_write_header;
parameter list P;
@@
void F(P);

@script:python depends on extract_sds_write_header_decl_void@
F << extract_sds_write_header_decl_void.F;
P << extract_sds_write_header_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: sds_write_i
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_sds_write_i_def@
type T;
identifier F = sds_write_i;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_sds_write_i_def@
F << remove_static_sds_write_i_def.F;
T << remove_static_sds_write_i_def.T;
P << remove_static_sds_write_i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_sds_write_i_def_void@
identifier F = sds_write_i;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_sds_write_i_def_void@
F << remove_static_sds_write_i_def_void.F;
P << remove_static_sds_write_i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_sds_write_i_decl@
type T;
identifier F = sds_write_i;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_sds_write_i_decl@
F << remove_static_sds_write_i_decl.F;
T << remove_static_sds_write_i_decl.T;
P << remove_static_sds_write_i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_sds_write_i_decl_void@
identifier F = sds_write_i;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_sds_write_i_decl_void@
F << remove_static_sds_write_i_decl_void.F;
P << remove_static_sds_write_i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_sds_write_i_def@
type T;
identifier F = sds_write_i;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_sds_write_i_def@
F << extract_sds_write_i_def.F;
T << extract_sds_write_i_def.T;
P << extract_sds_write_i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_sds_write_i_def_void@
identifier F = sds_write_i;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_sds_write_i_def_void@
F << extract_sds_write_i_def_void.F;
P << extract_sds_write_i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_sds_write_i_decl@
type T;
identifier F = sds_write_i;
parameter list P;
@@
T F(P);

@script:python depends on extract_sds_write_i_decl@
F << extract_sds_write_i_decl.F;
T << extract_sds_write_i_decl.T;
P << extract_sds_write_i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_sds_write_i_decl_void@
identifier F = sds_write_i;
parameter list P;
@@
void F(P);

@script:python depends on extract_sds_write_i_decl_void@
F << extract_sds_write_i_decl_void.F;
P << extract_sds_write_i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: sds_write_s
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_sds_write_s_def@
type T;
identifier F = sds_write_s;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_sds_write_s_def@
F << remove_static_sds_write_s_def.F;
T << remove_static_sds_write_s_def.T;
P << remove_static_sds_write_s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_sds_write_s_def_void@
identifier F = sds_write_s;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_sds_write_s_def_void@
F << remove_static_sds_write_s_def_void.F;
P << remove_static_sds_write_s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_sds_write_s_decl@
type T;
identifier F = sds_write_s;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_sds_write_s_decl@
F << remove_static_sds_write_s_decl.F;
T << remove_static_sds_write_s_decl.T;
P << remove_static_sds_write_s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_sds_write_s_decl_void@
identifier F = sds_write_s;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_sds_write_s_decl_void@
F << remove_static_sds_write_s_decl_void.F;
P << remove_static_sds_write_s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_sds_write_s_def@
type T;
identifier F = sds_write_s;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_sds_write_s_def@
F << extract_sds_write_s_def.F;
T << extract_sds_write_s_def.T;
P << extract_sds_write_s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_sds_write_s_def_void@
identifier F = sds_write_s;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_sds_write_s_def_void@
F << extract_sds_write_s_def_void.F;
P << extract_sds_write_s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_sds_write_s_decl@
type T;
identifier F = sds_write_s;
parameter list P;
@@
T F(P);

@script:python depends on extract_sds_write_s_decl@
F << extract_sds_write_s_decl.F;
T << extract_sds_write_s_decl.T;
P << extract_sds_write_s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_sds_write_s_decl_void@
identifier F = sds_write_s;
parameter list P;
@@
void F(P);

@script:python depends on extract_sds_write_s_decl_void@
F << extract_sds_write_s_decl_void.F;
P << extract_sds_write_s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: spx_close
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_spx_close_def@
type T;
identifier F = spx_close;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_spx_close_def@
F << remove_static_spx_close_def.F;
T << remove_static_spx_close_def.T;
P << remove_static_spx_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_spx_close_def_void@
identifier F = spx_close;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_spx_close_def_void@
F << remove_static_spx_close_def_void.F;
P << remove_static_spx_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_spx_close_decl@
type T;
identifier F = spx_close;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_spx_close_decl@
F << remove_static_spx_close_decl.F;
T << remove_static_spx_close_decl.T;
P << remove_static_spx_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_spx_close_decl_void@
identifier F = spx_close;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_spx_close_decl_void@
F << remove_static_spx_close_decl_void.F;
P << remove_static_spx_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_spx_close_def@
type T;
identifier F = spx_close;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_spx_close_def@
F << extract_spx_close_def.F;
T << extract_spx_close_def.T;
P << extract_spx_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_spx_close_def_void@
identifier F = spx_close;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_spx_close_def_void@
F << extract_spx_close_def_void.F;
P << extract_spx_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_spx_close_decl@
type T;
identifier F = spx_close;
parameter list P;
@@
T F(P);

@script:python depends on extract_spx_close_decl@
F << extract_spx_close_decl.F;
T << extract_spx_close_decl.T;
P << extract_spx_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_spx_close_decl_void@
identifier F = spx_close;
parameter list P;
@@
void F(P);

@script:python depends on extract_spx_close_decl_void@
F << extract_spx_close_decl_void.F;
P << extract_spx_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: spx_command
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_spx_command_def@
type T;
identifier F = spx_command;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_spx_command_def@
F << remove_static_spx_command_def.F;
T << remove_static_spx_command_def.T;
P << remove_static_spx_command_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_spx_command_def_void@
identifier F = spx_command;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_spx_command_def_void@
F << remove_static_spx_command_def_void.F;
P << remove_static_spx_command_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_spx_command_decl@
type T;
identifier F = spx_command;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_spx_command_decl@
F << remove_static_spx_command_decl.F;
T << remove_static_spx_command_decl.T;
P << remove_static_spx_command_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_spx_command_decl_void@
identifier F = spx_command;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_spx_command_decl_void@
F << remove_static_spx_command_decl_void.F;
P << remove_static_spx_command_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_spx_command_def@
type T;
identifier F = spx_command;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_spx_command_def@
F << extract_spx_command_def.F;
T << extract_spx_command_def.T;
P << extract_spx_command_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_spx_command_def_void@
identifier F = spx_command;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_spx_command_def_void@
F << extract_spx_command_def_void.F;
P << extract_spx_command_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_spx_command_decl@
type T;
identifier F = spx_command;
parameter list P;
@@
T F(P);

@script:python depends on extract_spx_command_decl@
F << extract_spx_command_decl.F;
T << extract_spx_command_decl.T;
P << extract_spx_command_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_spx_command_decl_void@
identifier F = spx_command;
parameter list P;
@@
void F(P);

@script:python depends on extract_spx_command_decl_void@
F << extract_spx_command_decl_void.F;
P << extract_spx_command_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: spx_read_d
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_spx_read_d_def@
type T;
identifier F = spx_read_d;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_spx_read_d_def@
F << remove_static_spx_read_d_def.F;
T << remove_static_spx_read_d_def.T;
P << remove_static_spx_read_d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_spx_read_d_def_void@
identifier F = spx_read_d;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_spx_read_d_def_void@
F << remove_static_spx_read_d_def_void.F;
P << remove_static_spx_read_d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_spx_read_d_decl@
type T;
identifier F = spx_read_d;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_spx_read_d_decl@
F << remove_static_spx_read_d_decl.F;
T << remove_static_spx_read_d_decl.T;
P << remove_static_spx_read_d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_spx_read_d_decl_void@
identifier F = spx_read_d;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_spx_read_d_decl_void@
F << remove_static_spx_read_d_decl_void.F;
P << remove_static_spx_read_d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_spx_read_d_def@
type T;
identifier F = spx_read_d;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_spx_read_d_def@
F << extract_spx_read_d_def.F;
T << extract_spx_read_d_def.T;
P << extract_spx_read_d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_spx_read_d_def_void@
identifier F = spx_read_d;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_spx_read_d_def_void@
F << extract_spx_read_d_def_void.F;
P << extract_spx_read_d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_spx_read_d_decl@
type T;
identifier F = spx_read_d;
parameter list P;
@@
T F(P);

@script:python depends on extract_spx_read_d_decl@
F << extract_spx_read_d_decl.F;
T << extract_spx_read_d_decl.T;
P << extract_spx_read_d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_spx_read_d_decl_void@
identifier F = spx_read_d;
parameter list P;
@@
void F(P);

@script:python depends on extract_spx_read_d_decl_void@
F << extract_spx_read_d_decl_void.F;
P << extract_spx_read_d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: spx_read_f
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_spx_read_f_def@
type T;
identifier F = spx_read_f;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_spx_read_f_def@
F << remove_static_spx_read_f_def.F;
T << remove_static_spx_read_f_def.T;
P << remove_static_spx_read_f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_spx_read_f_def_void@
identifier F = spx_read_f;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_spx_read_f_def_void@
F << remove_static_spx_read_f_def_void.F;
P << remove_static_spx_read_f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_spx_read_f_decl@
type T;
identifier F = spx_read_f;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_spx_read_f_decl@
F << remove_static_spx_read_f_decl.F;
T << remove_static_spx_read_f_decl.T;
P << remove_static_spx_read_f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_spx_read_f_decl_void@
identifier F = spx_read_f;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_spx_read_f_decl_void@
F << remove_static_spx_read_f_decl_void.F;
P << remove_static_spx_read_f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_spx_read_f_def@
type T;
identifier F = spx_read_f;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_spx_read_f_def@
F << extract_spx_read_f_def.F;
T << extract_spx_read_f_def.T;
P << extract_spx_read_f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_spx_read_f_def_void@
identifier F = spx_read_f;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_spx_read_f_def_void@
F << extract_spx_read_f_def_void.F;
P << extract_spx_read_f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_spx_read_f_decl@
type T;
identifier F = spx_read_f;
parameter list P;
@@
T F(P);

@script:python depends on extract_spx_read_f_decl@
F << extract_spx_read_f_decl.F;
T << extract_spx_read_f_decl.T;
P << extract_spx_read_f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_spx_read_f_decl_void@
identifier F = spx_read_f;
parameter list P;
@@
void F(P);

@script:python depends on extract_spx_read_f_decl_void@
F << extract_spx_read_f_decl_void.F;
P << extract_spx_read_f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: spx_read_i
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_spx_read_i_def@
type T;
identifier F = spx_read_i;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_spx_read_i_def@
F << remove_static_spx_read_i_def.F;
T << remove_static_spx_read_i_def.T;
P << remove_static_spx_read_i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_spx_read_i_def_void@
identifier F = spx_read_i;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_spx_read_i_def_void@
F << remove_static_spx_read_i_def_void.F;
P << remove_static_spx_read_i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_spx_read_i_decl@
type T;
identifier F = spx_read_i;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_spx_read_i_decl@
F << remove_static_spx_read_i_decl.F;
T << remove_static_spx_read_i_decl.T;
P << remove_static_spx_read_i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_spx_read_i_decl_void@
identifier F = spx_read_i;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_spx_read_i_decl_void@
F << remove_static_spx_read_i_decl_void.F;
P << remove_static_spx_read_i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_spx_read_i_def@
type T;
identifier F = spx_read_i;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_spx_read_i_def@
F << extract_spx_read_i_def.F;
T << extract_spx_read_i_def.T;
P << extract_spx_read_i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_spx_read_i_def_void@
identifier F = spx_read_i;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_spx_read_i_def_void@
F << extract_spx_read_i_def_void.F;
P << extract_spx_read_i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_spx_read_i_decl@
type T;
identifier F = spx_read_i;
parameter list P;
@@
T F(P);

@script:python depends on extract_spx_read_i_decl@
F << extract_spx_read_i_decl.F;
T << extract_spx_read_i_decl.T;
P << extract_spx_read_i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_spx_read_i_decl_void@
identifier F = spx_read_i;
parameter list P;
@@
void F(P);

@script:python depends on extract_spx_read_i_decl_void@
F << extract_spx_read_i_decl_void.F;
P << extract_spx_read_i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: spx_read_s
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_spx_read_s_def@
type T;
identifier F = spx_read_s;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_spx_read_s_def@
F << remove_static_spx_read_s_def.F;
T << remove_static_spx_read_s_def.T;
P << remove_static_spx_read_s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_spx_read_s_def_void@
identifier F = spx_read_s;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_spx_read_s_def_void@
F << remove_static_spx_read_s_def_void.F;
P << remove_static_spx_read_s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_spx_read_s_decl@
type T;
identifier F = spx_read_s;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_spx_read_s_decl@
F << remove_static_spx_read_s_decl.F;
T << remove_static_spx_read_s_decl.T;
P << remove_static_spx_read_s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_spx_read_s_decl_void@
identifier F = spx_read_s;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_spx_read_s_decl_void@
F << remove_static_spx_read_s_decl_void.F;
P << remove_static_spx_read_s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_spx_read_s_def@
type T;
identifier F = spx_read_s;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_spx_read_s_def@
F << extract_spx_read_s_def.F;
T << extract_spx_read_s_def.T;
P << extract_spx_read_s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_spx_read_s_def_void@
identifier F = spx_read_s;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_spx_read_s_def_void@
F << extract_spx_read_s_def_void.F;
P << extract_spx_read_s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_spx_read_s_decl@
type T;
identifier F = spx_read_s;
parameter list P;
@@
T F(P);

@script:python depends on extract_spx_read_s_decl@
F << extract_spx_read_s_decl.F;
T << extract_spx_read_s_decl.T;
P << extract_spx_read_s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_spx_read_s_decl_void@
identifier F = spx_read_s;
parameter list P;
@@
void F(P);

@script:python depends on extract_spx_read_s_decl_void@
F << extract_spx_read_s_decl_void.F;
P << extract_spx_read_s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: spx_seek
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_spx_seek_def@
type T;
identifier F = spx_seek;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_spx_seek_def@
F << remove_static_spx_seek_def.F;
T << remove_static_spx_seek_def.T;
P << remove_static_spx_seek_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_spx_seek_def_void@
identifier F = spx_seek;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_spx_seek_def_void@
F << remove_static_spx_seek_def_void.F;
P << remove_static_spx_seek_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_spx_seek_decl@
type T;
identifier F = spx_seek;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_spx_seek_decl@
F << remove_static_spx_seek_decl.F;
T << remove_static_spx_seek_decl.T;
P << remove_static_spx_seek_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_spx_seek_decl_void@
identifier F = spx_seek;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_spx_seek_decl_void@
F << remove_static_spx_seek_decl_void.F;
P << remove_static_spx_seek_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_spx_seek_def@
type T;
identifier F = spx_seek;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_spx_seek_def@
F << extract_spx_seek_def.F;
T << extract_spx_seek_def.T;
P << extract_spx_seek_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_spx_seek_def_void@
identifier F = spx_seek;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_spx_seek_def_void@
F << extract_spx_seek_def_void.F;
P << extract_spx_seek_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_spx_seek_decl@
type T;
identifier F = spx_seek;
parameter list P;
@@
T F(P);

@script:python depends on extract_spx_seek_decl@
F << extract_spx_seek_decl.F;
T << extract_spx_seek_decl.T;
P << extract_spx_seek_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_spx_seek_decl_void@
identifier F = spx_seek;
parameter list P;
@@
void F(P);

@script:python depends on extract_spx_seek_decl_void@
F << extract_spx_seek_decl_void.F;
P << extract_spx_seek_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: spx_write_d
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_spx_write_d_def@
type T;
identifier F = spx_write_d;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_spx_write_d_def@
F << remove_static_spx_write_d_def.F;
T << remove_static_spx_write_d_def.T;
P << remove_static_spx_write_d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_spx_write_d_def_void@
identifier F = spx_write_d;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_spx_write_d_def_void@
F << remove_static_spx_write_d_def_void.F;
P << remove_static_spx_write_d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_spx_write_d_decl@
type T;
identifier F = spx_write_d;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_spx_write_d_decl@
F << remove_static_spx_write_d_decl.F;
T << remove_static_spx_write_d_decl.T;
P << remove_static_spx_write_d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_spx_write_d_decl_void@
identifier F = spx_write_d;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_spx_write_d_decl_void@
F << remove_static_spx_write_d_decl_void.F;
P << remove_static_spx_write_d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_spx_write_d_def@
type T;
identifier F = spx_write_d;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_spx_write_d_def@
F << extract_spx_write_d_def.F;
T << extract_spx_write_d_def.T;
P << extract_spx_write_d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_spx_write_d_def_void@
identifier F = spx_write_d;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_spx_write_d_def_void@
F << extract_spx_write_d_def_void.F;
P << extract_spx_write_d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_spx_write_d_decl@
type T;
identifier F = spx_write_d;
parameter list P;
@@
T F(P);

@script:python depends on extract_spx_write_d_decl@
F << extract_spx_write_d_decl.F;
T << extract_spx_write_d_decl.T;
P << extract_spx_write_d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_spx_write_d_decl_void@
identifier F = spx_write_d;
parameter list P;
@@
void F(P);

@script:python depends on extract_spx_write_d_decl_void@
F << extract_spx_write_d_decl_void.F;
P << extract_spx_write_d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: spx_write_f
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_spx_write_f_def@
type T;
identifier F = spx_write_f;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_spx_write_f_def@
F << remove_static_spx_write_f_def.F;
T << remove_static_spx_write_f_def.T;
P << remove_static_spx_write_f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_spx_write_f_def_void@
identifier F = spx_write_f;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_spx_write_f_def_void@
F << remove_static_spx_write_f_def_void.F;
P << remove_static_spx_write_f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_spx_write_f_decl@
type T;
identifier F = spx_write_f;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_spx_write_f_decl@
F << remove_static_spx_write_f_decl.F;
T << remove_static_spx_write_f_decl.T;
P << remove_static_spx_write_f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_spx_write_f_decl_void@
identifier F = spx_write_f;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_spx_write_f_decl_void@
F << remove_static_spx_write_f_decl_void.F;
P << remove_static_spx_write_f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_spx_write_f_def@
type T;
identifier F = spx_write_f;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_spx_write_f_def@
F << extract_spx_write_f_def.F;
T << extract_spx_write_f_def.T;
P << extract_spx_write_f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_spx_write_f_def_void@
identifier F = spx_write_f;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_spx_write_f_def_void@
F << extract_spx_write_f_def_void.F;
P << extract_spx_write_f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_spx_write_f_decl@
type T;
identifier F = spx_write_f;
parameter list P;
@@
T F(P);

@script:python depends on extract_spx_write_f_decl@
F << extract_spx_write_f_decl.F;
T << extract_spx_write_f_decl.T;
P << extract_spx_write_f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_spx_write_f_decl_void@
identifier F = spx_write_f;
parameter list P;
@@
void F(P);

@script:python depends on extract_spx_write_f_decl_void@
F << extract_spx_write_f_decl_void.F;
P << extract_spx_write_f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: spx_write_header
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_spx_write_header_def@
type T;
identifier F = spx_write_header;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_spx_write_header_def@
F << remove_static_spx_write_header_def.F;
T << remove_static_spx_write_header_def.T;
P << remove_static_spx_write_header_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_spx_write_header_def_void@
identifier F = spx_write_header;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_spx_write_header_def_void@
F << remove_static_spx_write_header_def_void.F;
P << remove_static_spx_write_header_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_spx_write_header_decl@
type T;
identifier F = spx_write_header;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_spx_write_header_decl@
F << remove_static_spx_write_header_decl.F;
T << remove_static_spx_write_header_decl.T;
P << remove_static_spx_write_header_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_spx_write_header_decl_void@
identifier F = spx_write_header;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_spx_write_header_decl_void@
F << remove_static_spx_write_header_decl_void.F;
P << remove_static_spx_write_header_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_spx_write_header_def@
type T;
identifier F = spx_write_header;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_spx_write_header_def@
F << extract_spx_write_header_def.F;
T << extract_spx_write_header_def.T;
P << extract_spx_write_header_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_spx_write_header_def_void@
identifier F = spx_write_header;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_spx_write_header_def_void@
F << extract_spx_write_header_def_void.F;
P << extract_spx_write_header_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_spx_write_header_decl@
type T;
identifier F = spx_write_header;
parameter list P;
@@
T F(P);

@script:python depends on extract_spx_write_header_decl@
F << extract_spx_write_header_decl.F;
T << extract_spx_write_header_decl.T;
P << extract_spx_write_header_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_spx_write_header_decl_void@
identifier F = spx_write_header;
parameter list P;
@@
void F(P);

@script:python depends on extract_spx_write_header_decl_void@
F << extract_spx_write_header_decl_void.F;
P << extract_spx_write_header_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: spx_write_i
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_spx_write_i_def@
type T;
identifier F = spx_write_i;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_spx_write_i_def@
F << remove_static_spx_write_i_def.F;
T << remove_static_spx_write_i_def.T;
P << remove_static_spx_write_i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_spx_write_i_def_void@
identifier F = spx_write_i;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_spx_write_i_def_void@
F << remove_static_spx_write_i_def_void.F;
P << remove_static_spx_write_i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_spx_write_i_decl@
type T;
identifier F = spx_write_i;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_spx_write_i_decl@
F << remove_static_spx_write_i_decl.F;
T << remove_static_spx_write_i_decl.T;
P << remove_static_spx_write_i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_spx_write_i_decl_void@
identifier F = spx_write_i;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_spx_write_i_decl_void@
F << remove_static_spx_write_i_decl_void.F;
P << remove_static_spx_write_i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_spx_write_i_def@
type T;
identifier F = spx_write_i;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_spx_write_i_def@
F << extract_spx_write_i_def.F;
T << extract_spx_write_i_def.T;
P << extract_spx_write_i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_spx_write_i_def_void@
identifier F = spx_write_i;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_spx_write_i_def_void@
F << extract_spx_write_i_def_void.F;
P << extract_spx_write_i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_spx_write_i_decl@
type T;
identifier F = spx_write_i;
parameter list P;
@@
T F(P);

@script:python depends on extract_spx_write_i_decl@
F << extract_spx_write_i_decl.F;
T << extract_spx_write_i_decl.T;
P << extract_spx_write_i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_spx_write_i_decl_void@
identifier F = spx_write_i;
parameter list P;
@@
void F(P);

@script:python depends on extract_spx_write_i_decl_void@
F << extract_spx_write_i_decl_void.F;
P << extract_spx_write_i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: spx_write_s
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_spx_write_s_def@
type T;
identifier F = spx_write_s;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_spx_write_s_def@
F << remove_static_spx_write_s_def.F;
T << remove_static_spx_write_s_def.T;
P << remove_static_spx_write_s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_spx_write_s_def_void@
identifier F = spx_write_s;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_spx_write_s_def_void@
F << remove_static_spx_write_s_def_void.F;
P << remove_static_spx_write_s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_spx_write_s_decl@
type T;
identifier F = spx_write_s;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_spx_write_s_decl@
F << remove_static_spx_write_s_decl.F;
T << remove_static_spx_write_s_decl.T;
P << remove_static_spx_write_s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_spx_write_s_decl_void@
identifier F = spx_write_s;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_spx_write_s_decl_void@
F << remove_static_spx_write_s_decl_void.F;
P << remove_static_spx_write_s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_spx_write_s_def@
type T;
identifier F = spx_write_s;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_spx_write_s_def@
F << extract_spx_write_s_def.F;
T << extract_spx_write_s_def.T;
P << extract_spx_write_s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_spx_write_s_def_void@
identifier F = spx_write_s;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_spx_write_s_def_void@
F << extract_spx_write_s_def_void.F;
P << extract_spx_write_s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_spx_write_s_decl@
type T;
identifier F = spx_write_s;
parameter list P;
@@
T F(P);

@script:python depends on extract_spx_write_s_decl@
F << extract_spx_write_s_decl.F;
T << extract_spx_write_s_decl.T;
P << extract_spx_write_s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_spx_write_s_decl_void@
identifier F = spx_write_s;
parameter list P;
@@
void F(P);

@script:python depends on extract_spx_write_s_decl_void@
F << extract_spx_write_s_decl_void.F;
P << extract_spx_write_s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: svx_close
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_svx_close_def@
type T;
identifier F = svx_close;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_svx_close_def@
F << remove_static_svx_close_def.F;
T << remove_static_svx_close_def.T;
P << remove_static_svx_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_svx_close_def_void@
identifier F = svx_close;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_svx_close_def_void@
F << remove_static_svx_close_def_void.F;
P << remove_static_svx_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_svx_close_decl@
type T;
identifier F = svx_close;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_svx_close_decl@
F << remove_static_svx_close_decl.F;
T << remove_static_svx_close_decl.T;
P << remove_static_svx_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_svx_close_decl_void@
identifier F = svx_close;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_svx_close_decl_void@
F << remove_static_svx_close_decl_void.F;
P << remove_static_svx_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_svx_close_def@
type T;
identifier F = svx_close;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_svx_close_def@
F << extract_svx_close_def.F;
T << extract_svx_close_def.T;
P << extract_svx_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_svx_close_def_void@
identifier F = svx_close;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_svx_close_def_void@
F << extract_svx_close_def_void.F;
P << extract_svx_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_svx_close_decl@
type T;
identifier F = svx_close;
parameter list P;
@@
T F(P);

@script:python depends on extract_svx_close_decl@
F << extract_svx_close_decl.F;
T << extract_svx_close_decl.T;
P << extract_svx_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_svx_close_decl_void@
identifier F = svx_close;
parameter list P;
@@
void F(P);

@script:python depends on extract_svx_close_decl_void@
F << extract_svx_close_decl_void.F;
P << extract_svx_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: svx_write_header
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_svx_write_header_def@
type T;
identifier F = svx_write_header;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_svx_write_header_def@
F << remove_static_svx_write_header_def.F;
T << remove_static_svx_write_header_def.T;
P << remove_static_svx_write_header_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_svx_write_header_def_void@
identifier F = svx_write_header;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_svx_write_header_def_void@
F << remove_static_svx_write_header_def_void.F;
P << remove_static_svx_write_header_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_svx_write_header_decl@
type T;
identifier F = svx_write_header;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_svx_write_header_decl@
F << remove_static_svx_write_header_decl.F;
T << remove_static_svx_write_header_decl.T;
P << remove_static_svx_write_header_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_svx_write_header_decl_void@
identifier F = svx_write_header;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_svx_write_header_decl_void@
F << remove_static_svx_write_header_decl_void.F;
P << remove_static_svx_write_header_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_svx_write_header_def@
type T;
identifier F = svx_write_header;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_svx_write_header_def@
F << extract_svx_write_header_def.F;
T << extract_svx_write_header_def.T;
P << extract_svx_write_header_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_svx_write_header_def_void@
identifier F = svx_write_header;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_svx_write_header_def_void@
F << extract_svx_write_header_def_void.F;
P << extract_svx_write_header_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_svx_write_header_decl@
type T;
identifier F = svx_write_header;
parameter list P;
@@
T F(P);

@script:python depends on extract_svx_write_header_decl@
F << extract_svx_write_header_decl.F;
T << extract_svx_write_header_decl.T;
P << extract_svx_write_header_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_svx_write_header_decl_void@
identifier F = svx_write_header;
parameter list P;
@@
void F(P);

@script:python depends on extract_svx_write_header_decl_void@
F << extract_svx_write_header_decl_void.F;
P << extract_svx_write_header_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: txw_read_d
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_txw_read_d_def@
type T;
identifier F = txw_read_d;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_txw_read_d_def@
F << remove_static_txw_read_d_def.F;
T << remove_static_txw_read_d_def.T;
P << remove_static_txw_read_d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_txw_read_d_def_void@
identifier F = txw_read_d;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_txw_read_d_def_void@
F << remove_static_txw_read_d_def_void.F;
P << remove_static_txw_read_d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_txw_read_d_decl@
type T;
identifier F = txw_read_d;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_txw_read_d_decl@
F << remove_static_txw_read_d_decl.F;
T << remove_static_txw_read_d_decl.T;
P << remove_static_txw_read_d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_txw_read_d_decl_void@
identifier F = txw_read_d;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_txw_read_d_decl_void@
F << remove_static_txw_read_d_decl_void.F;
P << remove_static_txw_read_d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_txw_read_d_def@
type T;
identifier F = txw_read_d;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_txw_read_d_def@
F << extract_txw_read_d_def.F;
T << extract_txw_read_d_def.T;
P << extract_txw_read_d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_txw_read_d_def_void@
identifier F = txw_read_d;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_txw_read_d_def_void@
F << extract_txw_read_d_def_void.F;
P << extract_txw_read_d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_txw_read_d_decl@
type T;
identifier F = txw_read_d;
parameter list P;
@@
T F(P);

@script:python depends on extract_txw_read_d_decl@
F << extract_txw_read_d_decl.F;
T << extract_txw_read_d_decl.T;
P << extract_txw_read_d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_txw_read_d_decl_void@
identifier F = txw_read_d;
parameter list P;
@@
void F(P);

@script:python depends on extract_txw_read_d_decl_void@
F << extract_txw_read_d_decl_void.F;
P << extract_txw_read_d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: txw_read_f
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_txw_read_f_def@
type T;
identifier F = txw_read_f;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_txw_read_f_def@
F << remove_static_txw_read_f_def.F;
T << remove_static_txw_read_f_def.T;
P << remove_static_txw_read_f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_txw_read_f_def_void@
identifier F = txw_read_f;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_txw_read_f_def_void@
F << remove_static_txw_read_f_def_void.F;
P << remove_static_txw_read_f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_txw_read_f_decl@
type T;
identifier F = txw_read_f;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_txw_read_f_decl@
F << remove_static_txw_read_f_decl.F;
T << remove_static_txw_read_f_decl.T;
P << remove_static_txw_read_f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_txw_read_f_decl_void@
identifier F = txw_read_f;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_txw_read_f_decl_void@
F << remove_static_txw_read_f_decl_void.F;
P << remove_static_txw_read_f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_txw_read_f_def@
type T;
identifier F = txw_read_f;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_txw_read_f_def@
F << extract_txw_read_f_def.F;
T << extract_txw_read_f_def.T;
P << extract_txw_read_f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_txw_read_f_def_void@
identifier F = txw_read_f;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_txw_read_f_def_void@
F << extract_txw_read_f_def_void.F;
P << extract_txw_read_f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_txw_read_f_decl@
type T;
identifier F = txw_read_f;
parameter list P;
@@
T F(P);

@script:python depends on extract_txw_read_f_decl@
F << extract_txw_read_f_decl.F;
T << extract_txw_read_f_decl.T;
P << extract_txw_read_f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_txw_read_f_decl_void@
identifier F = txw_read_f;
parameter list P;
@@
void F(P);

@script:python depends on extract_txw_read_f_decl_void@
F << extract_txw_read_f_decl_void.F;
P << extract_txw_read_f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: txw_read_i
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_txw_read_i_def@
type T;
identifier F = txw_read_i;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_txw_read_i_def@
F << remove_static_txw_read_i_def.F;
T << remove_static_txw_read_i_def.T;
P << remove_static_txw_read_i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_txw_read_i_def_void@
identifier F = txw_read_i;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_txw_read_i_def_void@
F << remove_static_txw_read_i_def_void.F;
P << remove_static_txw_read_i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_txw_read_i_decl@
type T;
identifier F = txw_read_i;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_txw_read_i_decl@
F << remove_static_txw_read_i_decl.F;
T << remove_static_txw_read_i_decl.T;
P << remove_static_txw_read_i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_txw_read_i_decl_void@
identifier F = txw_read_i;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_txw_read_i_decl_void@
F << remove_static_txw_read_i_decl_void.F;
P << remove_static_txw_read_i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_txw_read_i_def@
type T;
identifier F = txw_read_i;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_txw_read_i_def@
F << extract_txw_read_i_def.F;
T << extract_txw_read_i_def.T;
P << extract_txw_read_i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_txw_read_i_def_void@
identifier F = txw_read_i;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_txw_read_i_def_void@
F << extract_txw_read_i_def_void.F;
P << extract_txw_read_i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_txw_read_i_decl@
type T;
identifier F = txw_read_i;
parameter list P;
@@
T F(P);

@script:python depends on extract_txw_read_i_decl@
F << extract_txw_read_i_decl.F;
T << extract_txw_read_i_decl.T;
P << extract_txw_read_i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_txw_read_i_decl_void@
identifier F = txw_read_i;
parameter list P;
@@
void F(P);

@script:python depends on extract_txw_read_i_decl_void@
F << extract_txw_read_i_decl_void.F;
P << extract_txw_read_i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: txw_read_s
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_txw_read_s_def@
type T;
identifier F = txw_read_s;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_txw_read_s_def@
F << remove_static_txw_read_s_def.F;
T << remove_static_txw_read_s_def.T;
P << remove_static_txw_read_s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_txw_read_s_def_void@
identifier F = txw_read_s;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_txw_read_s_def_void@
F << remove_static_txw_read_s_def_void.F;
P << remove_static_txw_read_s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_txw_read_s_decl@
type T;
identifier F = txw_read_s;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_txw_read_s_decl@
F << remove_static_txw_read_s_decl.F;
T << remove_static_txw_read_s_decl.T;
P << remove_static_txw_read_s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_txw_read_s_decl_void@
identifier F = txw_read_s;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_txw_read_s_decl_void@
F << remove_static_txw_read_s_decl_void.F;
P << remove_static_txw_read_s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_txw_read_s_def@
type T;
identifier F = txw_read_s;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_txw_read_s_def@
F << extract_txw_read_s_def.F;
T << extract_txw_read_s_def.T;
P << extract_txw_read_s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_txw_read_s_def_void@
identifier F = txw_read_s;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_txw_read_s_def_void@
F << extract_txw_read_s_def_void.F;
P << extract_txw_read_s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_txw_read_s_decl@
type T;
identifier F = txw_read_s;
parameter list P;
@@
T F(P);

@script:python depends on extract_txw_read_s_decl@
F << extract_txw_read_s_decl.F;
T << extract_txw_read_s_decl.T;
P << extract_txw_read_s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_txw_read_s_decl_void@
identifier F = txw_read_s;
parameter list P;
@@
void F(P);

@script:python depends on extract_txw_read_s_decl_void@
F << extract_txw_read_s_decl_void.F;
P << extract_txw_read_s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: txw_seek
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_txw_seek_def@
type T;
identifier F = txw_seek;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_txw_seek_def@
F << remove_static_txw_seek_def.F;
T << remove_static_txw_seek_def.T;
P << remove_static_txw_seek_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_txw_seek_def_void@
identifier F = txw_seek;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_txw_seek_def_void@
F << remove_static_txw_seek_def_void.F;
P << remove_static_txw_seek_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_txw_seek_decl@
type T;
identifier F = txw_seek;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_txw_seek_decl@
F << remove_static_txw_seek_decl.F;
T << remove_static_txw_seek_decl.T;
P << remove_static_txw_seek_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_txw_seek_decl_void@
identifier F = txw_seek;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_txw_seek_decl_void@
F << remove_static_txw_seek_decl_void.F;
P << remove_static_txw_seek_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_txw_seek_def@
type T;
identifier F = txw_seek;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_txw_seek_def@
F << extract_txw_seek_def.F;
T << extract_txw_seek_def.T;
P << extract_txw_seek_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_txw_seek_def_void@
identifier F = txw_seek;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_txw_seek_def_void@
F << extract_txw_seek_def_void.F;
P << extract_txw_seek_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_txw_seek_decl@
type T;
identifier F = txw_seek;
parameter list P;
@@
T F(P);

@script:python depends on extract_txw_seek_decl@
F << extract_txw_seek_decl.F;
T << extract_txw_seek_decl.T;
P << extract_txw_seek_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_txw_seek_decl_void@
identifier F = txw_seek;
parameter list P;
@@
void F(P);

@script:python depends on extract_txw_seek_decl_void@
F << extract_txw_seek_decl_void.F;
P << extract_txw_seek_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: ulaw_read_ulaw2d
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_ulaw_read_ulaw2d_def@
type T;
identifier F = ulaw_read_ulaw2d;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_ulaw_read_ulaw2d_def@
F << remove_static_ulaw_read_ulaw2d_def.F;
T << remove_static_ulaw_read_ulaw2d_def.T;
P << remove_static_ulaw_read_ulaw2d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_ulaw_read_ulaw2d_def_void@
identifier F = ulaw_read_ulaw2d;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_ulaw_read_ulaw2d_def_void@
F << remove_static_ulaw_read_ulaw2d_def_void.F;
P << remove_static_ulaw_read_ulaw2d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_ulaw_read_ulaw2d_decl@
type T;
identifier F = ulaw_read_ulaw2d;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_ulaw_read_ulaw2d_decl@
F << remove_static_ulaw_read_ulaw2d_decl.F;
T << remove_static_ulaw_read_ulaw2d_decl.T;
P << remove_static_ulaw_read_ulaw2d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_ulaw_read_ulaw2d_decl_void@
identifier F = ulaw_read_ulaw2d;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_ulaw_read_ulaw2d_decl_void@
F << remove_static_ulaw_read_ulaw2d_decl_void.F;
P << remove_static_ulaw_read_ulaw2d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_ulaw_read_ulaw2d_def@
type T;
identifier F = ulaw_read_ulaw2d;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_ulaw_read_ulaw2d_def@
F << extract_ulaw_read_ulaw2d_def.F;
T << extract_ulaw_read_ulaw2d_def.T;
P << extract_ulaw_read_ulaw2d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_ulaw_read_ulaw2d_def_void@
identifier F = ulaw_read_ulaw2d;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_ulaw_read_ulaw2d_def_void@
F << extract_ulaw_read_ulaw2d_def_void.F;
P << extract_ulaw_read_ulaw2d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_ulaw_read_ulaw2d_decl@
type T;
identifier F = ulaw_read_ulaw2d;
parameter list P;
@@
T F(P);

@script:python depends on extract_ulaw_read_ulaw2d_decl@
F << extract_ulaw_read_ulaw2d_decl.F;
T << extract_ulaw_read_ulaw2d_decl.T;
P << extract_ulaw_read_ulaw2d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_ulaw_read_ulaw2d_decl_void@
identifier F = ulaw_read_ulaw2d;
parameter list P;
@@
void F(P);

@script:python depends on extract_ulaw_read_ulaw2d_decl_void@
F << extract_ulaw_read_ulaw2d_decl_void.F;
P << extract_ulaw_read_ulaw2d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: ulaw_read_ulaw2f
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_ulaw_read_ulaw2f_def@
type T;
identifier F = ulaw_read_ulaw2f;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_ulaw_read_ulaw2f_def@
F << remove_static_ulaw_read_ulaw2f_def.F;
T << remove_static_ulaw_read_ulaw2f_def.T;
P << remove_static_ulaw_read_ulaw2f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_ulaw_read_ulaw2f_def_void@
identifier F = ulaw_read_ulaw2f;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_ulaw_read_ulaw2f_def_void@
F << remove_static_ulaw_read_ulaw2f_def_void.F;
P << remove_static_ulaw_read_ulaw2f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_ulaw_read_ulaw2f_decl@
type T;
identifier F = ulaw_read_ulaw2f;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_ulaw_read_ulaw2f_decl@
F << remove_static_ulaw_read_ulaw2f_decl.F;
T << remove_static_ulaw_read_ulaw2f_decl.T;
P << remove_static_ulaw_read_ulaw2f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_ulaw_read_ulaw2f_decl_void@
identifier F = ulaw_read_ulaw2f;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_ulaw_read_ulaw2f_decl_void@
F << remove_static_ulaw_read_ulaw2f_decl_void.F;
P << remove_static_ulaw_read_ulaw2f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_ulaw_read_ulaw2f_def@
type T;
identifier F = ulaw_read_ulaw2f;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_ulaw_read_ulaw2f_def@
F << extract_ulaw_read_ulaw2f_def.F;
T << extract_ulaw_read_ulaw2f_def.T;
P << extract_ulaw_read_ulaw2f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_ulaw_read_ulaw2f_def_void@
identifier F = ulaw_read_ulaw2f;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_ulaw_read_ulaw2f_def_void@
F << extract_ulaw_read_ulaw2f_def_void.F;
P << extract_ulaw_read_ulaw2f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_ulaw_read_ulaw2f_decl@
type T;
identifier F = ulaw_read_ulaw2f;
parameter list P;
@@
T F(P);

@script:python depends on extract_ulaw_read_ulaw2f_decl@
F << extract_ulaw_read_ulaw2f_decl.F;
T << extract_ulaw_read_ulaw2f_decl.T;
P << extract_ulaw_read_ulaw2f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_ulaw_read_ulaw2f_decl_void@
identifier F = ulaw_read_ulaw2f;
parameter list P;
@@
void F(P);

@script:python depends on extract_ulaw_read_ulaw2f_decl_void@
F << extract_ulaw_read_ulaw2f_decl_void.F;
P << extract_ulaw_read_ulaw2f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: ulaw_read_ulaw2i
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_ulaw_read_ulaw2i_def@
type T;
identifier F = ulaw_read_ulaw2i;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_ulaw_read_ulaw2i_def@
F << remove_static_ulaw_read_ulaw2i_def.F;
T << remove_static_ulaw_read_ulaw2i_def.T;
P << remove_static_ulaw_read_ulaw2i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_ulaw_read_ulaw2i_def_void@
identifier F = ulaw_read_ulaw2i;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_ulaw_read_ulaw2i_def_void@
F << remove_static_ulaw_read_ulaw2i_def_void.F;
P << remove_static_ulaw_read_ulaw2i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_ulaw_read_ulaw2i_decl@
type T;
identifier F = ulaw_read_ulaw2i;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_ulaw_read_ulaw2i_decl@
F << remove_static_ulaw_read_ulaw2i_decl.F;
T << remove_static_ulaw_read_ulaw2i_decl.T;
P << remove_static_ulaw_read_ulaw2i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_ulaw_read_ulaw2i_decl_void@
identifier F = ulaw_read_ulaw2i;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_ulaw_read_ulaw2i_decl_void@
F << remove_static_ulaw_read_ulaw2i_decl_void.F;
P << remove_static_ulaw_read_ulaw2i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_ulaw_read_ulaw2i_def@
type T;
identifier F = ulaw_read_ulaw2i;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_ulaw_read_ulaw2i_def@
F << extract_ulaw_read_ulaw2i_def.F;
T << extract_ulaw_read_ulaw2i_def.T;
P << extract_ulaw_read_ulaw2i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_ulaw_read_ulaw2i_def_void@
identifier F = ulaw_read_ulaw2i;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_ulaw_read_ulaw2i_def_void@
F << extract_ulaw_read_ulaw2i_def_void.F;
P << extract_ulaw_read_ulaw2i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_ulaw_read_ulaw2i_decl@
type T;
identifier F = ulaw_read_ulaw2i;
parameter list P;
@@
T F(P);

@script:python depends on extract_ulaw_read_ulaw2i_decl@
F << extract_ulaw_read_ulaw2i_decl.F;
T << extract_ulaw_read_ulaw2i_decl.T;
P << extract_ulaw_read_ulaw2i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_ulaw_read_ulaw2i_decl_void@
identifier F = ulaw_read_ulaw2i;
parameter list P;
@@
void F(P);

@script:python depends on extract_ulaw_read_ulaw2i_decl_void@
F << extract_ulaw_read_ulaw2i_decl_void.F;
P << extract_ulaw_read_ulaw2i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: ulaw_read_ulaw2s
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_ulaw_read_ulaw2s_def@
type T;
identifier F = ulaw_read_ulaw2s;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_ulaw_read_ulaw2s_def@
F << remove_static_ulaw_read_ulaw2s_def.F;
T << remove_static_ulaw_read_ulaw2s_def.T;
P << remove_static_ulaw_read_ulaw2s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_ulaw_read_ulaw2s_def_void@
identifier F = ulaw_read_ulaw2s;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_ulaw_read_ulaw2s_def_void@
F << remove_static_ulaw_read_ulaw2s_def_void.F;
P << remove_static_ulaw_read_ulaw2s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_ulaw_read_ulaw2s_decl@
type T;
identifier F = ulaw_read_ulaw2s;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_ulaw_read_ulaw2s_decl@
F << remove_static_ulaw_read_ulaw2s_decl.F;
T << remove_static_ulaw_read_ulaw2s_decl.T;
P << remove_static_ulaw_read_ulaw2s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_ulaw_read_ulaw2s_decl_void@
identifier F = ulaw_read_ulaw2s;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_ulaw_read_ulaw2s_decl_void@
F << remove_static_ulaw_read_ulaw2s_decl_void.F;
P << remove_static_ulaw_read_ulaw2s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_ulaw_read_ulaw2s_def@
type T;
identifier F = ulaw_read_ulaw2s;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_ulaw_read_ulaw2s_def@
F << extract_ulaw_read_ulaw2s_def.F;
T << extract_ulaw_read_ulaw2s_def.T;
P << extract_ulaw_read_ulaw2s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_ulaw_read_ulaw2s_def_void@
identifier F = ulaw_read_ulaw2s;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_ulaw_read_ulaw2s_def_void@
F << extract_ulaw_read_ulaw2s_def_void.F;
P << extract_ulaw_read_ulaw2s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_ulaw_read_ulaw2s_decl@
type T;
identifier F = ulaw_read_ulaw2s;
parameter list P;
@@
T F(P);

@script:python depends on extract_ulaw_read_ulaw2s_decl@
F << extract_ulaw_read_ulaw2s_decl.F;
T << extract_ulaw_read_ulaw2s_decl.T;
P << extract_ulaw_read_ulaw2s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_ulaw_read_ulaw2s_decl_void@
identifier F = ulaw_read_ulaw2s;
parameter list P;
@@
void F(P);

@script:python depends on extract_ulaw_read_ulaw2s_decl_void@
F << extract_ulaw_read_ulaw2s_decl_void.F;
P << extract_ulaw_read_ulaw2s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: ulaw_write_d2ulaw
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_ulaw_write_d2ulaw_def@
type T;
identifier F = ulaw_write_d2ulaw;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_ulaw_write_d2ulaw_def@
F << remove_static_ulaw_write_d2ulaw_def.F;
T << remove_static_ulaw_write_d2ulaw_def.T;
P << remove_static_ulaw_write_d2ulaw_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_ulaw_write_d2ulaw_def_void@
identifier F = ulaw_write_d2ulaw;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_ulaw_write_d2ulaw_def_void@
F << remove_static_ulaw_write_d2ulaw_def_void.F;
P << remove_static_ulaw_write_d2ulaw_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_ulaw_write_d2ulaw_decl@
type T;
identifier F = ulaw_write_d2ulaw;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_ulaw_write_d2ulaw_decl@
F << remove_static_ulaw_write_d2ulaw_decl.F;
T << remove_static_ulaw_write_d2ulaw_decl.T;
P << remove_static_ulaw_write_d2ulaw_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_ulaw_write_d2ulaw_decl_void@
identifier F = ulaw_write_d2ulaw;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_ulaw_write_d2ulaw_decl_void@
F << remove_static_ulaw_write_d2ulaw_decl_void.F;
P << remove_static_ulaw_write_d2ulaw_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_ulaw_write_d2ulaw_def@
type T;
identifier F = ulaw_write_d2ulaw;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_ulaw_write_d2ulaw_def@
F << extract_ulaw_write_d2ulaw_def.F;
T << extract_ulaw_write_d2ulaw_def.T;
P << extract_ulaw_write_d2ulaw_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_ulaw_write_d2ulaw_def_void@
identifier F = ulaw_write_d2ulaw;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_ulaw_write_d2ulaw_def_void@
F << extract_ulaw_write_d2ulaw_def_void.F;
P << extract_ulaw_write_d2ulaw_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_ulaw_write_d2ulaw_decl@
type T;
identifier F = ulaw_write_d2ulaw;
parameter list P;
@@
T F(P);

@script:python depends on extract_ulaw_write_d2ulaw_decl@
F << extract_ulaw_write_d2ulaw_decl.F;
T << extract_ulaw_write_d2ulaw_decl.T;
P << extract_ulaw_write_d2ulaw_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_ulaw_write_d2ulaw_decl_void@
identifier F = ulaw_write_d2ulaw;
parameter list P;
@@
void F(P);

@script:python depends on extract_ulaw_write_d2ulaw_decl_void@
F << extract_ulaw_write_d2ulaw_decl_void.F;
P << extract_ulaw_write_d2ulaw_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: ulaw_write_f2ulaw
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_ulaw_write_f2ulaw_def@
type T;
identifier F = ulaw_write_f2ulaw;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_ulaw_write_f2ulaw_def@
F << remove_static_ulaw_write_f2ulaw_def.F;
T << remove_static_ulaw_write_f2ulaw_def.T;
P << remove_static_ulaw_write_f2ulaw_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_ulaw_write_f2ulaw_def_void@
identifier F = ulaw_write_f2ulaw;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_ulaw_write_f2ulaw_def_void@
F << remove_static_ulaw_write_f2ulaw_def_void.F;
P << remove_static_ulaw_write_f2ulaw_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_ulaw_write_f2ulaw_decl@
type T;
identifier F = ulaw_write_f2ulaw;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_ulaw_write_f2ulaw_decl@
F << remove_static_ulaw_write_f2ulaw_decl.F;
T << remove_static_ulaw_write_f2ulaw_decl.T;
P << remove_static_ulaw_write_f2ulaw_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_ulaw_write_f2ulaw_decl_void@
identifier F = ulaw_write_f2ulaw;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_ulaw_write_f2ulaw_decl_void@
F << remove_static_ulaw_write_f2ulaw_decl_void.F;
P << remove_static_ulaw_write_f2ulaw_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_ulaw_write_f2ulaw_def@
type T;
identifier F = ulaw_write_f2ulaw;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_ulaw_write_f2ulaw_def@
F << extract_ulaw_write_f2ulaw_def.F;
T << extract_ulaw_write_f2ulaw_def.T;
P << extract_ulaw_write_f2ulaw_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_ulaw_write_f2ulaw_def_void@
identifier F = ulaw_write_f2ulaw;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_ulaw_write_f2ulaw_def_void@
F << extract_ulaw_write_f2ulaw_def_void.F;
P << extract_ulaw_write_f2ulaw_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_ulaw_write_f2ulaw_decl@
type T;
identifier F = ulaw_write_f2ulaw;
parameter list P;
@@
T F(P);

@script:python depends on extract_ulaw_write_f2ulaw_decl@
F << extract_ulaw_write_f2ulaw_decl.F;
T << extract_ulaw_write_f2ulaw_decl.T;
P << extract_ulaw_write_f2ulaw_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_ulaw_write_f2ulaw_decl_void@
identifier F = ulaw_write_f2ulaw;
parameter list P;
@@
void F(P);

@script:python depends on extract_ulaw_write_f2ulaw_decl_void@
F << extract_ulaw_write_f2ulaw_decl_void.F;
P << extract_ulaw_write_f2ulaw_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: ulaw_write_i2ulaw
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_ulaw_write_i2ulaw_def@
type T;
identifier F = ulaw_write_i2ulaw;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_ulaw_write_i2ulaw_def@
F << remove_static_ulaw_write_i2ulaw_def.F;
T << remove_static_ulaw_write_i2ulaw_def.T;
P << remove_static_ulaw_write_i2ulaw_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_ulaw_write_i2ulaw_def_void@
identifier F = ulaw_write_i2ulaw;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_ulaw_write_i2ulaw_def_void@
F << remove_static_ulaw_write_i2ulaw_def_void.F;
P << remove_static_ulaw_write_i2ulaw_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_ulaw_write_i2ulaw_decl@
type T;
identifier F = ulaw_write_i2ulaw;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_ulaw_write_i2ulaw_decl@
F << remove_static_ulaw_write_i2ulaw_decl.F;
T << remove_static_ulaw_write_i2ulaw_decl.T;
P << remove_static_ulaw_write_i2ulaw_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_ulaw_write_i2ulaw_decl_void@
identifier F = ulaw_write_i2ulaw;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_ulaw_write_i2ulaw_decl_void@
F << remove_static_ulaw_write_i2ulaw_decl_void.F;
P << remove_static_ulaw_write_i2ulaw_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_ulaw_write_i2ulaw_def@
type T;
identifier F = ulaw_write_i2ulaw;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_ulaw_write_i2ulaw_def@
F << extract_ulaw_write_i2ulaw_def.F;
T << extract_ulaw_write_i2ulaw_def.T;
P << extract_ulaw_write_i2ulaw_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_ulaw_write_i2ulaw_def_void@
identifier F = ulaw_write_i2ulaw;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_ulaw_write_i2ulaw_def_void@
F << extract_ulaw_write_i2ulaw_def_void.F;
P << extract_ulaw_write_i2ulaw_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_ulaw_write_i2ulaw_decl@
type T;
identifier F = ulaw_write_i2ulaw;
parameter list P;
@@
T F(P);

@script:python depends on extract_ulaw_write_i2ulaw_decl@
F << extract_ulaw_write_i2ulaw_decl.F;
T << extract_ulaw_write_i2ulaw_decl.T;
P << extract_ulaw_write_i2ulaw_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_ulaw_write_i2ulaw_decl_void@
identifier F = ulaw_write_i2ulaw;
parameter list P;
@@
void F(P);

@script:python depends on extract_ulaw_write_i2ulaw_decl_void@
F << extract_ulaw_write_i2ulaw_decl_void.F;
P << extract_ulaw_write_i2ulaw_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: ulaw_write_s2ulaw
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_ulaw_write_s2ulaw_def@
type T;
identifier F = ulaw_write_s2ulaw;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_ulaw_write_s2ulaw_def@
F << remove_static_ulaw_write_s2ulaw_def.F;
T << remove_static_ulaw_write_s2ulaw_def.T;
P << remove_static_ulaw_write_s2ulaw_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_ulaw_write_s2ulaw_def_void@
identifier F = ulaw_write_s2ulaw;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_ulaw_write_s2ulaw_def_void@
F << remove_static_ulaw_write_s2ulaw_def_void.F;
P << remove_static_ulaw_write_s2ulaw_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_ulaw_write_s2ulaw_decl@
type T;
identifier F = ulaw_write_s2ulaw;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_ulaw_write_s2ulaw_decl@
F << remove_static_ulaw_write_s2ulaw_decl.F;
T << remove_static_ulaw_write_s2ulaw_decl.T;
P << remove_static_ulaw_write_s2ulaw_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_ulaw_write_s2ulaw_decl_void@
identifier F = ulaw_write_s2ulaw;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_ulaw_write_s2ulaw_decl_void@
F << remove_static_ulaw_write_s2ulaw_decl_void.F;
P << remove_static_ulaw_write_s2ulaw_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_ulaw_write_s2ulaw_def@
type T;
identifier F = ulaw_write_s2ulaw;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_ulaw_write_s2ulaw_def@
F << extract_ulaw_write_s2ulaw_def.F;
T << extract_ulaw_write_s2ulaw_def.T;
P << extract_ulaw_write_s2ulaw_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_ulaw_write_s2ulaw_def_void@
identifier F = ulaw_write_s2ulaw;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_ulaw_write_s2ulaw_def_void@
F << extract_ulaw_write_s2ulaw_def_void.F;
P << extract_ulaw_write_s2ulaw_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_ulaw_write_s2ulaw_decl@
type T;
identifier F = ulaw_write_s2ulaw;
parameter list P;
@@
T F(P);

@script:python depends on extract_ulaw_write_s2ulaw_decl@
F << extract_ulaw_write_s2ulaw_decl.F;
T << extract_ulaw_write_s2ulaw_decl.T;
P << extract_ulaw_write_s2ulaw_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_ulaw_write_s2ulaw_decl_void@
identifier F = ulaw_write_s2ulaw;
parameter list P;
@@
void F(P);

@script:python depends on extract_ulaw_write_s2ulaw_decl_void@
F << extract_ulaw_write_s2ulaw_decl_void.F;
P << extract_ulaw_write_s2ulaw_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: vfget_filelen
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_vfget_filelen_def@
type T;
identifier F = vfget_filelen;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_vfget_filelen_def@
F << remove_static_vfget_filelen_def.F;
T << remove_static_vfget_filelen_def.T;
P << remove_static_vfget_filelen_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_vfget_filelen_def_void@
identifier F = vfget_filelen;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_vfget_filelen_def_void@
F << remove_static_vfget_filelen_def_void.F;
P << remove_static_vfget_filelen_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_vfget_filelen_decl@
type T;
identifier F = vfget_filelen;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_vfget_filelen_decl@
F << remove_static_vfget_filelen_decl.F;
T << remove_static_vfget_filelen_decl.T;
P << remove_static_vfget_filelen_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_vfget_filelen_decl_void@
identifier F = vfget_filelen;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_vfget_filelen_decl_void@
F << remove_static_vfget_filelen_decl_void.F;
P << remove_static_vfget_filelen_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_vfget_filelen_def@
type T;
identifier F = vfget_filelen;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_vfget_filelen_def@
F << extract_vfget_filelen_def.F;
T << extract_vfget_filelen_def.T;
P << extract_vfget_filelen_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_vfget_filelen_def_void@
identifier F = vfget_filelen;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_vfget_filelen_def_void@
F << extract_vfget_filelen_def_void.F;
P << extract_vfget_filelen_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_vfget_filelen_decl@
type T;
identifier F = vfget_filelen;
parameter list P;
@@
T F(P);

@script:python depends on extract_vfget_filelen_decl@
F << extract_vfget_filelen_decl.F;
T << extract_vfget_filelen_decl.T;
P << extract_vfget_filelen_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_vfget_filelen_decl_void@
identifier F = vfget_filelen;
parameter list P;
@@
void F(P);

@script:python depends on extract_vfget_filelen_decl_void@
F << extract_vfget_filelen_decl_void.F;
P << extract_vfget_filelen_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: vfread
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_vfread_def@
type T;
identifier F = vfread;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_vfread_def@
F << remove_static_vfread_def.F;
T << remove_static_vfread_def.T;
P << remove_static_vfread_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_vfread_def_void@
identifier F = vfread;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_vfread_def_void@
F << remove_static_vfread_def_void.F;
P << remove_static_vfread_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_vfread_decl@
type T;
identifier F = vfread;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_vfread_decl@
F << remove_static_vfread_decl.F;
T << remove_static_vfread_decl.T;
P << remove_static_vfread_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_vfread_decl_void@
identifier F = vfread;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_vfread_decl_void@
F << remove_static_vfread_decl_void.F;
P << remove_static_vfread_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_vfread_def@
type T;
identifier F = vfread;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_vfread_def@
F << extract_vfread_def.F;
T << extract_vfread_def.T;
P << extract_vfread_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_vfread_def_void@
identifier F = vfread;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_vfread_def_void@
F << extract_vfread_def_void.F;
P << extract_vfread_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_vfread_decl@
type T;
identifier F = vfread;
parameter list P;
@@
T F(P);

@script:python depends on extract_vfread_decl@
F << extract_vfread_decl.F;
T << extract_vfread_decl.T;
P << extract_vfread_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_vfread_decl_void@
identifier F = vfread;
parameter list P;
@@
void F(P);

@script:python depends on extract_vfread_decl_void@
F << extract_vfread_decl_void.F;
P << extract_vfread_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: vfseek
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_vfseek_def@
type T;
identifier F = vfseek;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_vfseek_def@
F << remove_static_vfseek_def.F;
T << remove_static_vfseek_def.T;
P << remove_static_vfseek_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_vfseek_def_void@
identifier F = vfseek;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_vfseek_def_void@
F << remove_static_vfseek_def_void.F;
P << remove_static_vfseek_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_vfseek_decl@
type T;
identifier F = vfseek;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_vfseek_decl@
F << remove_static_vfseek_decl.F;
T << remove_static_vfseek_decl.T;
P << remove_static_vfseek_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_vfseek_decl_void@
identifier F = vfseek;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_vfseek_decl_void@
F << remove_static_vfseek_decl_void.F;
P << remove_static_vfseek_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_vfseek_def@
type T;
identifier F = vfseek;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_vfseek_def@
F << extract_vfseek_def.F;
T << extract_vfseek_def.T;
P << extract_vfseek_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_vfseek_def_void@
identifier F = vfseek;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_vfseek_def_void@
F << extract_vfseek_def_void.F;
P << extract_vfseek_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_vfseek_decl@
type T;
identifier F = vfseek;
parameter list P;
@@
T F(P);

@script:python depends on extract_vfseek_decl@
F << extract_vfseek_decl.F;
T << extract_vfseek_decl.T;
P << extract_vfseek_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_vfseek_decl_void@
identifier F = vfseek;
parameter list P;
@@
void F(P);

@script:python depends on extract_vfseek_decl_void@
F << extract_vfseek_decl_void.F;
P << extract_vfseek_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: vftell
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_vftell_def@
type T;
identifier F = vftell;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_vftell_def@
F << remove_static_vftell_def.F;
T << remove_static_vftell_def.T;
P << remove_static_vftell_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_vftell_def_void@
identifier F = vftell;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_vftell_def_void@
F << remove_static_vftell_def_void.F;
P << remove_static_vftell_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_vftell_decl@
type T;
identifier F = vftell;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_vftell_decl@
F << remove_static_vftell_decl.F;
T << remove_static_vftell_decl.T;
P << remove_static_vftell_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_vftell_decl_void@
identifier F = vftell;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_vftell_decl_void@
F << remove_static_vftell_decl_void.F;
P << remove_static_vftell_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_vftell_def@
type T;
identifier F = vftell;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_vftell_def@
F << extract_vftell_def.F;
T << extract_vftell_def.T;
P << extract_vftell_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_vftell_def_void@
identifier F = vftell;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_vftell_def_void@
F << extract_vftell_def_void.F;
P << extract_vftell_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_vftell_decl@
type T;
identifier F = vftell;
parameter list P;
@@
T F(P);

@script:python depends on extract_vftell_decl@
F << extract_vftell_decl.F;
T << extract_vftell_decl.T;
P << extract_vftell_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_vftell_decl_void@
identifier F = vftell;
parameter list P;
@@
void F(P);

@script:python depends on extract_vftell_decl_void@
F << extract_vftell_decl_void.F;
P << extract_vftell_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: vfwrite
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_vfwrite_def@
type T;
identifier F = vfwrite;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_vfwrite_def@
F << remove_static_vfwrite_def.F;
T << remove_static_vfwrite_def.T;
P << remove_static_vfwrite_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_vfwrite_def_void@
identifier F = vfwrite;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_vfwrite_def_void@
F << remove_static_vfwrite_def_void.F;
P << remove_static_vfwrite_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_vfwrite_decl@
type T;
identifier F = vfwrite;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_vfwrite_decl@
F << remove_static_vfwrite_decl.F;
T << remove_static_vfwrite_decl.T;
P << remove_static_vfwrite_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_vfwrite_decl_void@
identifier F = vfwrite;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_vfwrite_decl_void@
F << remove_static_vfwrite_decl_void.F;
P << remove_static_vfwrite_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_vfwrite_def@
type T;
identifier F = vfwrite;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_vfwrite_def@
F << extract_vfwrite_def.F;
T << extract_vfwrite_def.T;
P << extract_vfwrite_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_vfwrite_def_void@
identifier F = vfwrite;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_vfwrite_def_void@
F << extract_vfwrite_def_void.F;
P << extract_vfwrite_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_vfwrite_decl@
type T;
identifier F = vfwrite;
parameter list P;
@@
T F(P);

@script:python depends on extract_vfwrite_decl@
F << extract_vfwrite_decl.F;
T << extract_vfwrite_decl.T;
P << extract_vfwrite_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_vfwrite_decl_void@
identifier F = vfwrite;
parameter list P;
@@
void F(P);

@script:python depends on extract_vfwrite_decl_void@
F << extract_vfwrite_decl_void.F;
P << extract_vfwrite_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: voc_close
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_voc_close_def@
type T;
identifier F = voc_close;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_voc_close_def@
F << remove_static_voc_close_def.F;
T << remove_static_voc_close_def.T;
P << remove_static_voc_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_voc_close_def_void@
identifier F = voc_close;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_voc_close_def_void@
F << remove_static_voc_close_def_void.F;
P << remove_static_voc_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_voc_close_decl@
type T;
identifier F = voc_close;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_voc_close_decl@
F << remove_static_voc_close_decl.F;
T << remove_static_voc_close_decl.T;
P << remove_static_voc_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_voc_close_decl_void@
identifier F = voc_close;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_voc_close_decl_void@
F << remove_static_voc_close_decl_void.F;
P << remove_static_voc_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_voc_close_def@
type T;
identifier F = voc_close;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_voc_close_def@
F << extract_voc_close_def.F;
T << extract_voc_close_def.T;
P << extract_voc_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_voc_close_def_void@
identifier F = voc_close;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_voc_close_def_void@
F << extract_voc_close_def_void.F;
P << extract_voc_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_voc_close_decl@
type T;
identifier F = voc_close;
parameter list P;
@@
T F(P);

@script:python depends on extract_voc_close_decl@
F << extract_voc_close_decl.F;
T << extract_voc_close_decl.T;
P << extract_voc_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_voc_close_decl_void@
identifier F = voc_close;
parameter list P;
@@
void F(P);

@script:python depends on extract_voc_close_decl_void@
F << extract_voc_close_decl_void.F;
P << extract_voc_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: voc_multi_read_les2d
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_voc_multi_read_les2d_def@
type T;
identifier F = voc_multi_read_les2d;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_voc_multi_read_les2d_def@
F << remove_static_voc_multi_read_les2d_def.F;
T << remove_static_voc_multi_read_les2d_def.T;
P << remove_static_voc_multi_read_les2d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_voc_multi_read_les2d_def_void@
identifier F = voc_multi_read_les2d;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_voc_multi_read_les2d_def_void@
F << remove_static_voc_multi_read_les2d_def_void.F;
P << remove_static_voc_multi_read_les2d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_voc_multi_read_les2d_decl@
type T;
identifier F = voc_multi_read_les2d;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_voc_multi_read_les2d_decl@
F << remove_static_voc_multi_read_les2d_decl.F;
T << remove_static_voc_multi_read_les2d_decl.T;
P << remove_static_voc_multi_read_les2d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_voc_multi_read_les2d_decl_void@
identifier F = voc_multi_read_les2d;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_voc_multi_read_les2d_decl_void@
F << remove_static_voc_multi_read_les2d_decl_void.F;
P << remove_static_voc_multi_read_les2d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_voc_multi_read_les2d_def@
type T;
identifier F = voc_multi_read_les2d;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_voc_multi_read_les2d_def@
F << extract_voc_multi_read_les2d_def.F;
T << extract_voc_multi_read_les2d_def.T;
P << extract_voc_multi_read_les2d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_voc_multi_read_les2d_def_void@
identifier F = voc_multi_read_les2d;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_voc_multi_read_les2d_def_void@
F << extract_voc_multi_read_les2d_def_void.F;
P << extract_voc_multi_read_les2d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_voc_multi_read_les2d_decl@
type T;
identifier F = voc_multi_read_les2d;
parameter list P;
@@
T F(P);

@script:python depends on extract_voc_multi_read_les2d_decl@
F << extract_voc_multi_read_les2d_decl.F;
T << extract_voc_multi_read_les2d_decl.T;
P << extract_voc_multi_read_les2d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_voc_multi_read_les2d_decl_void@
identifier F = voc_multi_read_les2d;
parameter list P;
@@
void F(P);

@script:python depends on extract_voc_multi_read_les2d_decl_void@
F << extract_voc_multi_read_les2d_decl_void.F;
P << extract_voc_multi_read_les2d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: voc_multi_read_les2f
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_voc_multi_read_les2f_def@
type T;
identifier F = voc_multi_read_les2f;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_voc_multi_read_les2f_def@
F << remove_static_voc_multi_read_les2f_def.F;
T << remove_static_voc_multi_read_les2f_def.T;
P << remove_static_voc_multi_read_les2f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_voc_multi_read_les2f_def_void@
identifier F = voc_multi_read_les2f;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_voc_multi_read_les2f_def_void@
F << remove_static_voc_multi_read_les2f_def_void.F;
P << remove_static_voc_multi_read_les2f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_voc_multi_read_les2f_decl@
type T;
identifier F = voc_multi_read_les2f;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_voc_multi_read_les2f_decl@
F << remove_static_voc_multi_read_les2f_decl.F;
T << remove_static_voc_multi_read_les2f_decl.T;
P << remove_static_voc_multi_read_les2f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_voc_multi_read_les2f_decl_void@
identifier F = voc_multi_read_les2f;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_voc_multi_read_les2f_decl_void@
F << remove_static_voc_multi_read_les2f_decl_void.F;
P << remove_static_voc_multi_read_les2f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_voc_multi_read_les2f_def@
type T;
identifier F = voc_multi_read_les2f;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_voc_multi_read_les2f_def@
F << extract_voc_multi_read_les2f_def.F;
T << extract_voc_multi_read_les2f_def.T;
P << extract_voc_multi_read_les2f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_voc_multi_read_les2f_def_void@
identifier F = voc_multi_read_les2f;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_voc_multi_read_les2f_def_void@
F << extract_voc_multi_read_les2f_def_void.F;
P << extract_voc_multi_read_les2f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_voc_multi_read_les2f_decl@
type T;
identifier F = voc_multi_read_les2f;
parameter list P;
@@
T F(P);

@script:python depends on extract_voc_multi_read_les2f_decl@
F << extract_voc_multi_read_les2f_decl.F;
T << extract_voc_multi_read_les2f_decl.T;
P << extract_voc_multi_read_les2f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_voc_multi_read_les2f_decl_void@
identifier F = voc_multi_read_les2f;
parameter list P;
@@
void F(P);

@script:python depends on extract_voc_multi_read_les2f_decl_void@
F << extract_voc_multi_read_les2f_decl_void.F;
P << extract_voc_multi_read_les2f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: voc_multi_read_les2i
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_voc_multi_read_les2i_def@
type T;
identifier F = voc_multi_read_les2i;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_voc_multi_read_les2i_def@
F << remove_static_voc_multi_read_les2i_def.F;
T << remove_static_voc_multi_read_les2i_def.T;
P << remove_static_voc_multi_read_les2i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_voc_multi_read_les2i_def_void@
identifier F = voc_multi_read_les2i;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_voc_multi_read_les2i_def_void@
F << remove_static_voc_multi_read_les2i_def_void.F;
P << remove_static_voc_multi_read_les2i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_voc_multi_read_les2i_decl@
type T;
identifier F = voc_multi_read_les2i;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_voc_multi_read_les2i_decl@
F << remove_static_voc_multi_read_les2i_decl.F;
T << remove_static_voc_multi_read_les2i_decl.T;
P << remove_static_voc_multi_read_les2i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_voc_multi_read_les2i_decl_void@
identifier F = voc_multi_read_les2i;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_voc_multi_read_les2i_decl_void@
F << remove_static_voc_multi_read_les2i_decl_void.F;
P << remove_static_voc_multi_read_les2i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_voc_multi_read_les2i_def@
type T;
identifier F = voc_multi_read_les2i;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_voc_multi_read_les2i_def@
F << extract_voc_multi_read_les2i_def.F;
T << extract_voc_multi_read_les2i_def.T;
P << extract_voc_multi_read_les2i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_voc_multi_read_les2i_def_void@
identifier F = voc_multi_read_les2i;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_voc_multi_read_les2i_def_void@
F << extract_voc_multi_read_les2i_def_void.F;
P << extract_voc_multi_read_les2i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_voc_multi_read_les2i_decl@
type T;
identifier F = voc_multi_read_les2i;
parameter list P;
@@
T F(P);

@script:python depends on extract_voc_multi_read_les2i_decl@
F << extract_voc_multi_read_les2i_decl.F;
T << extract_voc_multi_read_les2i_decl.T;
P << extract_voc_multi_read_les2i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_voc_multi_read_les2i_decl_void@
identifier F = voc_multi_read_les2i;
parameter list P;
@@
void F(P);

@script:python depends on extract_voc_multi_read_les2i_decl_void@
F << extract_voc_multi_read_les2i_decl_void.F;
P << extract_voc_multi_read_les2i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: voc_multi_read_les2s
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_voc_multi_read_les2s_def@
type T;
identifier F = voc_multi_read_les2s;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_voc_multi_read_les2s_def@
F << remove_static_voc_multi_read_les2s_def.F;
T << remove_static_voc_multi_read_les2s_def.T;
P << remove_static_voc_multi_read_les2s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_voc_multi_read_les2s_def_void@
identifier F = voc_multi_read_les2s;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_voc_multi_read_les2s_def_void@
F << remove_static_voc_multi_read_les2s_def_void.F;
P << remove_static_voc_multi_read_les2s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_voc_multi_read_les2s_decl@
type T;
identifier F = voc_multi_read_les2s;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_voc_multi_read_les2s_decl@
F << remove_static_voc_multi_read_les2s_decl.F;
T << remove_static_voc_multi_read_les2s_decl.T;
P << remove_static_voc_multi_read_les2s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_voc_multi_read_les2s_decl_void@
identifier F = voc_multi_read_les2s;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_voc_multi_read_les2s_decl_void@
F << remove_static_voc_multi_read_les2s_decl_void.F;
P << remove_static_voc_multi_read_les2s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_voc_multi_read_les2s_def@
type T;
identifier F = voc_multi_read_les2s;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_voc_multi_read_les2s_def@
F << extract_voc_multi_read_les2s_def.F;
T << extract_voc_multi_read_les2s_def.T;
P << extract_voc_multi_read_les2s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_voc_multi_read_les2s_def_void@
identifier F = voc_multi_read_les2s;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_voc_multi_read_les2s_def_void@
F << extract_voc_multi_read_les2s_def_void.F;
P << extract_voc_multi_read_les2s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_voc_multi_read_les2s_decl@
type T;
identifier F = voc_multi_read_les2s;
parameter list P;
@@
T F(P);

@script:python depends on extract_voc_multi_read_les2s_decl@
F << extract_voc_multi_read_les2s_decl.F;
T << extract_voc_multi_read_les2s_decl.T;
P << extract_voc_multi_read_les2s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_voc_multi_read_les2s_decl_void@
identifier F = voc_multi_read_les2s;
parameter list P;
@@
void F(P);

@script:python depends on extract_voc_multi_read_les2s_decl_void@
F << extract_voc_multi_read_les2s_decl_void.F;
P << extract_voc_multi_read_les2s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: voc_multi_read_uc2d
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_voc_multi_read_uc2d_def@
type T;
identifier F = voc_multi_read_uc2d;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_voc_multi_read_uc2d_def@
F << remove_static_voc_multi_read_uc2d_def.F;
T << remove_static_voc_multi_read_uc2d_def.T;
P << remove_static_voc_multi_read_uc2d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_voc_multi_read_uc2d_def_void@
identifier F = voc_multi_read_uc2d;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_voc_multi_read_uc2d_def_void@
F << remove_static_voc_multi_read_uc2d_def_void.F;
P << remove_static_voc_multi_read_uc2d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_voc_multi_read_uc2d_decl@
type T;
identifier F = voc_multi_read_uc2d;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_voc_multi_read_uc2d_decl@
F << remove_static_voc_multi_read_uc2d_decl.F;
T << remove_static_voc_multi_read_uc2d_decl.T;
P << remove_static_voc_multi_read_uc2d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_voc_multi_read_uc2d_decl_void@
identifier F = voc_multi_read_uc2d;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_voc_multi_read_uc2d_decl_void@
F << remove_static_voc_multi_read_uc2d_decl_void.F;
P << remove_static_voc_multi_read_uc2d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_voc_multi_read_uc2d_def@
type T;
identifier F = voc_multi_read_uc2d;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_voc_multi_read_uc2d_def@
F << extract_voc_multi_read_uc2d_def.F;
T << extract_voc_multi_read_uc2d_def.T;
P << extract_voc_multi_read_uc2d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_voc_multi_read_uc2d_def_void@
identifier F = voc_multi_read_uc2d;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_voc_multi_read_uc2d_def_void@
F << extract_voc_multi_read_uc2d_def_void.F;
P << extract_voc_multi_read_uc2d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_voc_multi_read_uc2d_decl@
type T;
identifier F = voc_multi_read_uc2d;
parameter list P;
@@
T F(P);

@script:python depends on extract_voc_multi_read_uc2d_decl@
F << extract_voc_multi_read_uc2d_decl.F;
T << extract_voc_multi_read_uc2d_decl.T;
P << extract_voc_multi_read_uc2d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_voc_multi_read_uc2d_decl_void@
identifier F = voc_multi_read_uc2d;
parameter list P;
@@
void F(P);

@script:python depends on extract_voc_multi_read_uc2d_decl_void@
F << extract_voc_multi_read_uc2d_decl_void.F;
P << extract_voc_multi_read_uc2d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: voc_multi_read_uc2f
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_voc_multi_read_uc2f_def@
type T;
identifier F = voc_multi_read_uc2f;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_voc_multi_read_uc2f_def@
F << remove_static_voc_multi_read_uc2f_def.F;
T << remove_static_voc_multi_read_uc2f_def.T;
P << remove_static_voc_multi_read_uc2f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_voc_multi_read_uc2f_def_void@
identifier F = voc_multi_read_uc2f;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_voc_multi_read_uc2f_def_void@
F << remove_static_voc_multi_read_uc2f_def_void.F;
P << remove_static_voc_multi_read_uc2f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_voc_multi_read_uc2f_decl@
type T;
identifier F = voc_multi_read_uc2f;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_voc_multi_read_uc2f_decl@
F << remove_static_voc_multi_read_uc2f_decl.F;
T << remove_static_voc_multi_read_uc2f_decl.T;
P << remove_static_voc_multi_read_uc2f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_voc_multi_read_uc2f_decl_void@
identifier F = voc_multi_read_uc2f;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_voc_multi_read_uc2f_decl_void@
F << remove_static_voc_multi_read_uc2f_decl_void.F;
P << remove_static_voc_multi_read_uc2f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_voc_multi_read_uc2f_def@
type T;
identifier F = voc_multi_read_uc2f;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_voc_multi_read_uc2f_def@
F << extract_voc_multi_read_uc2f_def.F;
T << extract_voc_multi_read_uc2f_def.T;
P << extract_voc_multi_read_uc2f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_voc_multi_read_uc2f_def_void@
identifier F = voc_multi_read_uc2f;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_voc_multi_read_uc2f_def_void@
F << extract_voc_multi_read_uc2f_def_void.F;
P << extract_voc_multi_read_uc2f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_voc_multi_read_uc2f_decl@
type T;
identifier F = voc_multi_read_uc2f;
parameter list P;
@@
T F(P);

@script:python depends on extract_voc_multi_read_uc2f_decl@
F << extract_voc_multi_read_uc2f_decl.F;
T << extract_voc_multi_read_uc2f_decl.T;
P << extract_voc_multi_read_uc2f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_voc_multi_read_uc2f_decl_void@
identifier F = voc_multi_read_uc2f;
parameter list P;
@@
void F(P);

@script:python depends on extract_voc_multi_read_uc2f_decl_void@
F << extract_voc_multi_read_uc2f_decl_void.F;
P << extract_voc_multi_read_uc2f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: voc_multi_read_uc2i
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_voc_multi_read_uc2i_def@
type T;
identifier F = voc_multi_read_uc2i;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_voc_multi_read_uc2i_def@
F << remove_static_voc_multi_read_uc2i_def.F;
T << remove_static_voc_multi_read_uc2i_def.T;
P << remove_static_voc_multi_read_uc2i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_voc_multi_read_uc2i_def_void@
identifier F = voc_multi_read_uc2i;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_voc_multi_read_uc2i_def_void@
F << remove_static_voc_multi_read_uc2i_def_void.F;
P << remove_static_voc_multi_read_uc2i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_voc_multi_read_uc2i_decl@
type T;
identifier F = voc_multi_read_uc2i;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_voc_multi_read_uc2i_decl@
F << remove_static_voc_multi_read_uc2i_decl.F;
T << remove_static_voc_multi_read_uc2i_decl.T;
P << remove_static_voc_multi_read_uc2i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_voc_multi_read_uc2i_decl_void@
identifier F = voc_multi_read_uc2i;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_voc_multi_read_uc2i_decl_void@
F << remove_static_voc_multi_read_uc2i_decl_void.F;
P << remove_static_voc_multi_read_uc2i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_voc_multi_read_uc2i_def@
type T;
identifier F = voc_multi_read_uc2i;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_voc_multi_read_uc2i_def@
F << extract_voc_multi_read_uc2i_def.F;
T << extract_voc_multi_read_uc2i_def.T;
P << extract_voc_multi_read_uc2i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_voc_multi_read_uc2i_def_void@
identifier F = voc_multi_read_uc2i;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_voc_multi_read_uc2i_def_void@
F << extract_voc_multi_read_uc2i_def_void.F;
P << extract_voc_multi_read_uc2i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_voc_multi_read_uc2i_decl@
type T;
identifier F = voc_multi_read_uc2i;
parameter list P;
@@
T F(P);

@script:python depends on extract_voc_multi_read_uc2i_decl@
F << extract_voc_multi_read_uc2i_decl.F;
T << extract_voc_multi_read_uc2i_decl.T;
P << extract_voc_multi_read_uc2i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_voc_multi_read_uc2i_decl_void@
identifier F = voc_multi_read_uc2i;
parameter list P;
@@
void F(P);

@script:python depends on extract_voc_multi_read_uc2i_decl_void@
F << extract_voc_multi_read_uc2i_decl_void.F;
P << extract_voc_multi_read_uc2i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: voc_multi_read_uc2s
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_voc_multi_read_uc2s_def@
type T;
identifier F = voc_multi_read_uc2s;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_voc_multi_read_uc2s_def@
F << remove_static_voc_multi_read_uc2s_def.F;
T << remove_static_voc_multi_read_uc2s_def.T;
P << remove_static_voc_multi_read_uc2s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_voc_multi_read_uc2s_def_void@
identifier F = voc_multi_read_uc2s;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_voc_multi_read_uc2s_def_void@
F << remove_static_voc_multi_read_uc2s_def_void.F;
P << remove_static_voc_multi_read_uc2s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_voc_multi_read_uc2s_decl@
type T;
identifier F = voc_multi_read_uc2s;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_voc_multi_read_uc2s_decl@
F << remove_static_voc_multi_read_uc2s_decl.F;
T << remove_static_voc_multi_read_uc2s_decl.T;
P << remove_static_voc_multi_read_uc2s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_voc_multi_read_uc2s_decl_void@
identifier F = voc_multi_read_uc2s;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_voc_multi_read_uc2s_decl_void@
F << remove_static_voc_multi_read_uc2s_decl_void.F;
P << remove_static_voc_multi_read_uc2s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_voc_multi_read_uc2s_def@
type T;
identifier F = voc_multi_read_uc2s;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_voc_multi_read_uc2s_def@
F << extract_voc_multi_read_uc2s_def.F;
T << extract_voc_multi_read_uc2s_def.T;
P << extract_voc_multi_read_uc2s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_voc_multi_read_uc2s_def_void@
identifier F = voc_multi_read_uc2s;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_voc_multi_read_uc2s_def_void@
F << extract_voc_multi_read_uc2s_def_void.F;
P << extract_voc_multi_read_uc2s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_voc_multi_read_uc2s_decl@
type T;
identifier F = voc_multi_read_uc2s;
parameter list P;
@@
T F(P);

@script:python depends on extract_voc_multi_read_uc2s_decl@
F << extract_voc_multi_read_uc2s_decl.F;
T << extract_voc_multi_read_uc2s_decl.T;
P << extract_voc_multi_read_uc2s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_voc_multi_read_uc2s_decl_void@
identifier F = voc_multi_read_uc2s;
parameter list P;
@@
void F(P);

@script:python depends on extract_voc_multi_read_uc2s_decl_void@
F << extract_voc_multi_read_uc2s_decl_void.F;
P << extract_voc_multi_read_uc2s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: voc_write_header
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_voc_write_header_def@
type T;
identifier F = voc_write_header;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_voc_write_header_def@
F << remove_static_voc_write_header_def.F;
T << remove_static_voc_write_header_def.T;
P << remove_static_voc_write_header_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_voc_write_header_def_void@
identifier F = voc_write_header;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_voc_write_header_def_void@
F << remove_static_voc_write_header_def_void.F;
P << remove_static_voc_write_header_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_voc_write_header_decl@
type T;
identifier F = voc_write_header;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_voc_write_header_decl@
F << remove_static_voc_write_header_decl.F;
T << remove_static_voc_write_header_decl.T;
P << remove_static_voc_write_header_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_voc_write_header_decl_void@
identifier F = voc_write_header;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_voc_write_header_decl_void@
F << remove_static_voc_write_header_decl_void.F;
P << remove_static_voc_write_header_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_voc_write_header_def@
type T;
identifier F = voc_write_header;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_voc_write_header_def@
F << extract_voc_write_header_def.F;
T << extract_voc_write_header_def.T;
P << extract_voc_write_header_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_voc_write_header_def_void@
identifier F = voc_write_header;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_voc_write_header_def_void@
F << extract_voc_write_header_def_void.F;
P << extract_voc_write_header_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_voc_write_header_decl@
type T;
identifier F = voc_write_header;
parameter list P;
@@
T F(P);

@script:python depends on extract_voc_write_header_decl@
F << extract_voc_write_header_decl.F;
T << extract_voc_write_header_decl.T;
P << extract_voc_write_header_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_voc_write_header_decl_void@
identifier F = voc_write_header;
parameter list P;
@@
void F(P);

@script:python depends on extract_voc_write_header_decl_void@
F << extract_voc_write_header_decl_void.F;
P << extract_voc_write_header_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: vorbis_byterate
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_vorbis_byterate_def@
type T;
identifier F = vorbis_byterate;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_vorbis_byterate_def@
F << remove_static_vorbis_byterate_def.F;
T << remove_static_vorbis_byterate_def.T;
P << remove_static_vorbis_byterate_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_vorbis_byterate_def_void@
identifier F = vorbis_byterate;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_vorbis_byterate_def_void@
F << remove_static_vorbis_byterate_def_void.F;
P << remove_static_vorbis_byterate_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_vorbis_byterate_decl@
type T;
identifier F = vorbis_byterate;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_vorbis_byterate_decl@
F << remove_static_vorbis_byterate_decl.F;
T << remove_static_vorbis_byterate_decl.T;
P << remove_static_vorbis_byterate_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_vorbis_byterate_decl_void@
identifier F = vorbis_byterate;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_vorbis_byterate_decl_void@
F << remove_static_vorbis_byterate_decl_void.F;
P << remove_static_vorbis_byterate_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_vorbis_byterate_def@
type T;
identifier F = vorbis_byterate;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_vorbis_byterate_def@
F << extract_vorbis_byterate_def.F;
T << extract_vorbis_byterate_def.T;
P << extract_vorbis_byterate_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_vorbis_byterate_def_void@
identifier F = vorbis_byterate;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_vorbis_byterate_def_void@
F << extract_vorbis_byterate_def_void.F;
P << extract_vorbis_byterate_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_vorbis_byterate_decl@
type T;
identifier F = vorbis_byterate;
parameter list P;
@@
T F(P);

@script:python depends on extract_vorbis_byterate_decl@
F << extract_vorbis_byterate_decl.F;
T << extract_vorbis_byterate_decl.T;
P << extract_vorbis_byterate_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_vorbis_byterate_decl_void@
identifier F = vorbis_byterate;
parameter list P;
@@
void F(P);

@script:python depends on extract_vorbis_byterate_decl_void@
F << extract_vorbis_byterate_decl_void.F;
P << extract_vorbis_byterate_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: vorbis_close
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_vorbis_close_def@
type T;
identifier F = vorbis_close;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_vorbis_close_def@
F << remove_static_vorbis_close_def.F;
T << remove_static_vorbis_close_def.T;
P << remove_static_vorbis_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_vorbis_close_def_void@
identifier F = vorbis_close;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_vorbis_close_def_void@
F << remove_static_vorbis_close_def_void.F;
P << remove_static_vorbis_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_vorbis_close_decl@
type T;
identifier F = vorbis_close;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_vorbis_close_decl@
F << remove_static_vorbis_close_decl.F;
T << remove_static_vorbis_close_decl.T;
P << remove_static_vorbis_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_vorbis_close_decl_void@
identifier F = vorbis_close;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_vorbis_close_decl_void@
F << remove_static_vorbis_close_decl_void.F;
P << remove_static_vorbis_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_vorbis_close_def@
type T;
identifier F = vorbis_close;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_vorbis_close_def@
F << extract_vorbis_close_def.F;
T << extract_vorbis_close_def.T;
P << extract_vorbis_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_vorbis_close_def_void@
identifier F = vorbis_close;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_vorbis_close_def_void@
F << extract_vorbis_close_def_void.F;
P << extract_vorbis_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_vorbis_close_decl@
type T;
identifier F = vorbis_close;
parameter list P;
@@
T F(P);

@script:python depends on extract_vorbis_close_decl@
F << extract_vorbis_close_decl.F;
T << extract_vorbis_close_decl.T;
P << extract_vorbis_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_vorbis_close_decl_void@
identifier F = vorbis_close;
parameter list P;
@@
void F(P);

@script:python depends on extract_vorbis_close_decl_void@
F << extract_vorbis_close_decl_void.F;
P << extract_vorbis_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: vorbis_command
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_vorbis_command_def@
type T;
identifier F = vorbis_command;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_vorbis_command_def@
F << remove_static_vorbis_command_def.F;
T << remove_static_vorbis_command_def.T;
P << remove_static_vorbis_command_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_vorbis_command_def_void@
identifier F = vorbis_command;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_vorbis_command_def_void@
F << remove_static_vorbis_command_def_void.F;
P << remove_static_vorbis_command_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_vorbis_command_decl@
type T;
identifier F = vorbis_command;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_vorbis_command_decl@
F << remove_static_vorbis_command_decl.F;
T << remove_static_vorbis_command_decl.T;
P << remove_static_vorbis_command_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_vorbis_command_decl_void@
identifier F = vorbis_command;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_vorbis_command_decl_void@
F << remove_static_vorbis_command_decl_void.F;
P << remove_static_vorbis_command_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_vorbis_command_def@
type T;
identifier F = vorbis_command;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_vorbis_command_def@
F << extract_vorbis_command_def.F;
T << extract_vorbis_command_def.T;
P << extract_vorbis_command_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_vorbis_command_def_void@
identifier F = vorbis_command;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_vorbis_command_def_void@
F << extract_vorbis_command_def_void.F;
P << extract_vorbis_command_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_vorbis_command_decl@
type T;
identifier F = vorbis_command;
parameter list P;
@@
T F(P);

@script:python depends on extract_vorbis_command_decl@
F << extract_vorbis_command_decl.F;
T << extract_vorbis_command_decl.T;
P << extract_vorbis_command_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_vorbis_command_decl_void@
identifier F = vorbis_command;
parameter list P;
@@
void F(P);

@script:python depends on extract_vorbis_command_decl_void@
F << extract_vorbis_command_decl_void.F;
P << extract_vorbis_command_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: vorbis_rdouble
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_vorbis_rdouble_def@
type T;
identifier F = vorbis_rdouble;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_vorbis_rdouble_def@
F << remove_static_vorbis_rdouble_def.F;
T << remove_static_vorbis_rdouble_def.T;
P << remove_static_vorbis_rdouble_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_vorbis_rdouble_def_void@
identifier F = vorbis_rdouble;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_vorbis_rdouble_def_void@
F << remove_static_vorbis_rdouble_def_void.F;
P << remove_static_vorbis_rdouble_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_vorbis_rdouble_decl@
type T;
identifier F = vorbis_rdouble;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_vorbis_rdouble_decl@
F << remove_static_vorbis_rdouble_decl.F;
T << remove_static_vorbis_rdouble_decl.T;
P << remove_static_vorbis_rdouble_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_vorbis_rdouble_decl_void@
identifier F = vorbis_rdouble;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_vorbis_rdouble_decl_void@
F << remove_static_vorbis_rdouble_decl_void.F;
P << remove_static_vorbis_rdouble_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_vorbis_rdouble_def@
type T;
identifier F = vorbis_rdouble;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_vorbis_rdouble_def@
F << extract_vorbis_rdouble_def.F;
T << extract_vorbis_rdouble_def.T;
P << extract_vorbis_rdouble_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_vorbis_rdouble_def_void@
identifier F = vorbis_rdouble;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_vorbis_rdouble_def_void@
F << extract_vorbis_rdouble_def_void.F;
P << extract_vorbis_rdouble_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_vorbis_rdouble_decl@
type T;
identifier F = vorbis_rdouble;
parameter list P;
@@
T F(P);

@script:python depends on extract_vorbis_rdouble_decl@
F << extract_vorbis_rdouble_decl.F;
T << extract_vorbis_rdouble_decl.T;
P << extract_vorbis_rdouble_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_vorbis_rdouble_decl_void@
identifier F = vorbis_rdouble;
parameter list P;
@@
void F(P);

@script:python depends on extract_vorbis_rdouble_decl_void@
F << extract_vorbis_rdouble_decl_void.F;
P << extract_vorbis_rdouble_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: vorbis_read_d
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_vorbis_read_d_def@
type T;
identifier F = vorbis_read_d;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_vorbis_read_d_def@
F << remove_static_vorbis_read_d_def.F;
T << remove_static_vorbis_read_d_def.T;
P << remove_static_vorbis_read_d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_vorbis_read_d_def_void@
identifier F = vorbis_read_d;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_vorbis_read_d_def_void@
F << remove_static_vorbis_read_d_def_void.F;
P << remove_static_vorbis_read_d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_vorbis_read_d_decl@
type T;
identifier F = vorbis_read_d;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_vorbis_read_d_decl@
F << remove_static_vorbis_read_d_decl.F;
T << remove_static_vorbis_read_d_decl.T;
P << remove_static_vorbis_read_d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_vorbis_read_d_decl_void@
identifier F = vorbis_read_d;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_vorbis_read_d_decl_void@
F << remove_static_vorbis_read_d_decl_void.F;
P << remove_static_vorbis_read_d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_vorbis_read_d_def@
type T;
identifier F = vorbis_read_d;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_vorbis_read_d_def@
F << extract_vorbis_read_d_def.F;
T << extract_vorbis_read_d_def.T;
P << extract_vorbis_read_d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_vorbis_read_d_def_void@
identifier F = vorbis_read_d;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_vorbis_read_d_def_void@
F << extract_vorbis_read_d_def_void.F;
P << extract_vorbis_read_d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_vorbis_read_d_decl@
type T;
identifier F = vorbis_read_d;
parameter list P;
@@
T F(P);

@script:python depends on extract_vorbis_read_d_decl@
F << extract_vorbis_read_d_decl.F;
T << extract_vorbis_read_d_decl.T;
P << extract_vorbis_read_d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_vorbis_read_d_decl_void@
identifier F = vorbis_read_d;
parameter list P;
@@
void F(P);

@script:python depends on extract_vorbis_read_d_decl_void@
F << extract_vorbis_read_d_decl_void.F;
P << extract_vorbis_read_d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: vorbis_read_f
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_vorbis_read_f_def@
type T;
identifier F = vorbis_read_f;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_vorbis_read_f_def@
F << remove_static_vorbis_read_f_def.F;
T << remove_static_vorbis_read_f_def.T;
P << remove_static_vorbis_read_f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_vorbis_read_f_def_void@
identifier F = vorbis_read_f;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_vorbis_read_f_def_void@
F << remove_static_vorbis_read_f_def_void.F;
P << remove_static_vorbis_read_f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_vorbis_read_f_decl@
type T;
identifier F = vorbis_read_f;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_vorbis_read_f_decl@
F << remove_static_vorbis_read_f_decl.F;
T << remove_static_vorbis_read_f_decl.T;
P << remove_static_vorbis_read_f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_vorbis_read_f_decl_void@
identifier F = vorbis_read_f;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_vorbis_read_f_decl_void@
F << remove_static_vorbis_read_f_decl_void.F;
P << remove_static_vorbis_read_f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_vorbis_read_f_def@
type T;
identifier F = vorbis_read_f;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_vorbis_read_f_def@
F << extract_vorbis_read_f_def.F;
T << extract_vorbis_read_f_def.T;
P << extract_vorbis_read_f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_vorbis_read_f_def_void@
identifier F = vorbis_read_f;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_vorbis_read_f_def_void@
F << extract_vorbis_read_f_def_void.F;
P << extract_vorbis_read_f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_vorbis_read_f_decl@
type T;
identifier F = vorbis_read_f;
parameter list P;
@@
T F(P);

@script:python depends on extract_vorbis_read_f_decl@
F << extract_vorbis_read_f_decl.F;
T << extract_vorbis_read_f_decl.T;
P << extract_vorbis_read_f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_vorbis_read_f_decl_void@
identifier F = vorbis_read_f;
parameter list P;
@@
void F(P);

@script:python depends on extract_vorbis_read_f_decl_void@
F << extract_vorbis_read_f_decl_void.F;
P << extract_vorbis_read_f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: vorbis_read_i
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_vorbis_read_i_def@
type T;
identifier F = vorbis_read_i;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_vorbis_read_i_def@
F << remove_static_vorbis_read_i_def.F;
T << remove_static_vorbis_read_i_def.T;
P << remove_static_vorbis_read_i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_vorbis_read_i_def_void@
identifier F = vorbis_read_i;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_vorbis_read_i_def_void@
F << remove_static_vorbis_read_i_def_void.F;
P << remove_static_vorbis_read_i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_vorbis_read_i_decl@
type T;
identifier F = vorbis_read_i;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_vorbis_read_i_decl@
F << remove_static_vorbis_read_i_decl.F;
T << remove_static_vorbis_read_i_decl.T;
P << remove_static_vorbis_read_i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_vorbis_read_i_decl_void@
identifier F = vorbis_read_i;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_vorbis_read_i_decl_void@
F << remove_static_vorbis_read_i_decl_void.F;
P << remove_static_vorbis_read_i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_vorbis_read_i_def@
type T;
identifier F = vorbis_read_i;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_vorbis_read_i_def@
F << extract_vorbis_read_i_def.F;
T << extract_vorbis_read_i_def.T;
P << extract_vorbis_read_i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_vorbis_read_i_def_void@
identifier F = vorbis_read_i;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_vorbis_read_i_def_void@
F << extract_vorbis_read_i_def_void.F;
P << extract_vorbis_read_i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_vorbis_read_i_decl@
type T;
identifier F = vorbis_read_i;
parameter list P;
@@
T F(P);

@script:python depends on extract_vorbis_read_i_decl@
F << extract_vorbis_read_i_decl.F;
T << extract_vorbis_read_i_decl.T;
P << extract_vorbis_read_i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_vorbis_read_i_decl_void@
identifier F = vorbis_read_i;
parameter list P;
@@
void F(P);

@script:python depends on extract_vorbis_read_i_decl_void@
F << extract_vorbis_read_i_decl_void.F;
P << extract_vorbis_read_i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: vorbis_read_s
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_vorbis_read_s_def@
type T;
identifier F = vorbis_read_s;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_vorbis_read_s_def@
F << remove_static_vorbis_read_s_def.F;
T << remove_static_vorbis_read_s_def.T;
P << remove_static_vorbis_read_s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_vorbis_read_s_def_void@
identifier F = vorbis_read_s;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_vorbis_read_s_def_void@
F << remove_static_vorbis_read_s_def_void.F;
P << remove_static_vorbis_read_s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_vorbis_read_s_decl@
type T;
identifier F = vorbis_read_s;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_vorbis_read_s_decl@
F << remove_static_vorbis_read_s_decl.F;
T << remove_static_vorbis_read_s_decl.T;
P << remove_static_vorbis_read_s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_vorbis_read_s_decl_void@
identifier F = vorbis_read_s;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_vorbis_read_s_decl_void@
F << remove_static_vorbis_read_s_decl_void.F;
P << remove_static_vorbis_read_s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_vorbis_read_s_def@
type T;
identifier F = vorbis_read_s;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_vorbis_read_s_def@
F << extract_vorbis_read_s_def.F;
T << extract_vorbis_read_s_def.T;
P << extract_vorbis_read_s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_vorbis_read_s_def_void@
identifier F = vorbis_read_s;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_vorbis_read_s_def_void@
F << extract_vorbis_read_s_def_void.F;
P << extract_vorbis_read_s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_vorbis_read_s_decl@
type T;
identifier F = vorbis_read_s;
parameter list P;
@@
T F(P);

@script:python depends on extract_vorbis_read_s_decl@
F << extract_vorbis_read_s_decl.F;
T << extract_vorbis_read_s_decl.T;
P << extract_vorbis_read_s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_vorbis_read_s_decl_void@
identifier F = vorbis_read_s;
parameter list P;
@@
void F(P);

@script:python depends on extract_vorbis_read_s_decl_void@
F << extract_vorbis_read_s_decl_void.F;
P << extract_vorbis_read_s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: vorbis_rfloat
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_vorbis_rfloat_def@
type T;
identifier F = vorbis_rfloat;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_vorbis_rfloat_def@
F << remove_static_vorbis_rfloat_def.F;
T << remove_static_vorbis_rfloat_def.T;
P << remove_static_vorbis_rfloat_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_vorbis_rfloat_def_void@
identifier F = vorbis_rfloat;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_vorbis_rfloat_def_void@
F << remove_static_vorbis_rfloat_def_void.F;
P << remove_static_vorbis_rfloat_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_vorbis_rfloat_decl@
type T;
identifier F = vorbis_rfloat;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_vorbis_rfloat_decl@
F << remove_static_vorbis_rfloat_decl.F;
T << remove_static_vorbis_rfloat_decl.T;
P << remove_static_vorbis_rfloat_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_vorbis_rfloat_decl_void@
identifier F = vorbis_rfloat;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_vorbis_rfloat_decl_void@
F << remove_static_vorbis_rfloat_decl_void.F;
P << remove_static_vorbis_rfloat_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_vorbis_rfloat_def@
type T;
identifier F = vorbis_rfloat;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_vorbis_rfloat_def@
F << extract_vorbis_rfloat_def.F;
T << extract_vorbis_rfloat_def.T;
P << extract_vorbis_rfloat_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_vorbis_rfloat_def_void@
identifier F = vorbis_rfloat;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_vorbis_rfloat_def_void@
F << extract_vorbis_rfloat_def_void.F;
P << extract_vorbis_rfloat_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_vorbis_rfloat_decl@
type T;
identifier F = vorbis_rfloat;
parameter list P;
@@
T F(P);

@script:python depends on extract_vorbis_rfloat_decl@
F << extract_vorbis_rfloat_decl.F;
T << extract_vorbis_rfloat_decl.T;
P << extract_vorbis_rfloat_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_vorbis_rfloat_decl_void@
identifier F = vorbis_rfloat;
parameter list P;
@@
void F(P);

@script:python depends on extract_vorbis_rfloat_decl_void@
F << extract_vorbis_rfloat_decl_void.F;
P << extract_vorbis_rfloat_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: vorbis_rint
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_vorbis_rint_def@
type T;
identifier F = vorbis_rint;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_vorbis_rint_def@
F << remove_static_vorbis_rint_def.F;
T << remove_static_vorbis_rint_def.T;
P << remove_static_vorbis_rint_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_vorbis_rint_def_void@
identifier F = vorbis_rint;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_vorbis_rint_def_void@
F << remove_static_vorbis_rint_def_void.F;
P << remove_static_vorbis_rint_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_vorbis_rint_decl@
type T;
identifier F = vorbis_rint;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_vorbis_rint_decl@
F << remove_static_vorbis_rint_decl.F;
T << remove_static_vorbis_rint_decl.T;
P << remove_static_vorbis_rint_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_vorbis_rint_decl_void@
identifier F = vorbis_rint;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_vorbis_rint_decl_void@
F << remove_static_vorbis_rint_decl_void.F;
P << remove_static_vorbis_rint_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_vorbis_rint_def@
type T;
identifier F = vorbis_rint;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_vorbis_rint_def@
F << extract_vorbis_rint_def.F;
T << extract_vorbis_rint_def.T;
P << extract_vorbis_rint_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_vorbis_rint_def_void@
identifier F = vorbis_rint;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_vorbis_rint_def_void@
F << extract_vorbis_rint_def_void.F;
P << extract_vorbis_rint_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_vorbis_rint_decl@
type T;
identifier F = vorbis_rint;
parameter list P;
@@
T F(P);

@script:python depends on extract_vorbis_rint_decl@
F << extract_vorbis_rint_decl.F;
T << extract_vorbis_rint_decl.T;
P << extract_vorbis_rint_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_vorbis_rint_decl_void@
identifier F = vorbis_rint;
parameter list P;
@@
void F(P);

@script:python depends on extract_vorbis_rint_decl_void@
F << extract_vorbis_rint_decl_void.F;
P << extract_vorbis_rint_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: vorbis_rnull
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_vorbis_rnull_def@
type T;
identifier F = vorbis_rnull;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_vorbis_rnull_def@
F << remove_static_vorbis_rnull_def.F;
T << remove_static_vorbis_rnull_def.T;
P << remove_static_vorbis_rnull_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_vorbis_rnull_def_void@
identifier F = vorbis_rnull;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_vorbis_rnull_def_void@
F << remove_static_vorbis_rnull_def_void.F;
P << remove_static_vorbis_rnull_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_vorbis_rnull_decl@
type T;
identifier F = vorbis_rnull;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_vorbis_rnull_decl@
F << remove_static_vorbis_rnull_decl.F;
T << remove_static_vorbis_rnull_decl.T;
P << remove_static_vorbis_rnull_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_vorbis_rnull_decl_void@
identifier F = vorbis_rnull;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_vorbis_rnull_decl_void@
F << remove_static_vorbis_rnull_decl_void.F;
P << remove_static_vorbis_rnull_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_vorbis_rnull_def@
type T;
identifier F = vorbis_rnull;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_vorbis_rnull_def@
F << extract_vorbis_rnull_def.F;
T << extract_vorbis_rnull_def.T;
P << extract_vorbis_rnull_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_vorbis_rnull_def_void@
identifier F = vorbis_rnull;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_vorbis_rnull_def_void@
F << extract_vorbis_rnull_def_void.F;
P << extract_vorbis_rnull_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_vorbis_rnull_decl@
type T;
identifier F = vorbis_rnull;
parameter list P;
@@
T F(P);

@script:python depends on extract_vorbis_rnull_decl@
F << extract_vorbis_rnull_decl.F;
T << extract_vorbis_rnull_decl.T;
P << extract_vorbis_rnull_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_vorbis_rnull_decl_void@
identifier F = vorbis_rnull;
parameter list P;
@@
void F(P);

@script:python depends on extract_vorbis_rnull_decl_void@
F << extract_vorbis_rnull_decl_void.F;
P << extract_vorbis_rnull_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: vorbis_rshort
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_vorbis_rshort_def@
type T;
identifier F = vorbis_rshort;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_vorbis_rshort_def@
F << remove_static_vorbis_rshort_def.F;
T << remove_static_vorbis_rshort_def.T;
P << remove_static_vorbis_rshort_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_vorbis_rshort_def_void@
identifier F = vorbis_rshort;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_vorbis_rshort_def_void@
F << remove_static_vorbis_rshort_def_void.F;
P << remove_static_vorbis_rshort_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_vorbis_rshort_decl@
type T;
identifier F = vorbis_rshort;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_vorbis_rshort_decl@
F << remove_static_vorbis_rshort_decl.F;
T << remove_static_vorbis_rshort_decl.T;
P << remove_static_vorbis_rshort_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_vorbis_rshort_decl_void@
identifier F = vorbis_rshort;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_vorbis_rshort_decl_void@
F << remove_static_vorbis_rshort_decl_void.F;
P << remove_static_vorbis_rshort_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_vorbis_rshort_def@
type T;
identifier F = vorbis_rshort;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_vorbis_rshort_def@
F << extract_vorbis_rshort_def.F;
T << extract_vorbis_rshort_def.T;
P << extract_vorbis_rshort_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_vorbis_rshort_def_void@
identifier F = vorbis_rshort;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_vorbis_rshort_def_void@
F << extract_vorbis_rshort_def_void.F;
P << extract_vorbis_rshort_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_vorbis_rshort_decl@
type T;
identifier F = vorbis_rshort;
parameter list P;
@@
T F(P);

@script:python depends on extract_vorbis_rshort_decl@
F << extract_vorbis_rshort_decl.F;
T << extract_vorbis_rshort_decl.T;
P << extract_vorbis_rshort_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_vorbis_rshort_decl_void@
identifier F = vorbis_rshort;
parameter list P;
@@
void F(P);

@script:python depends on extract_vorbis_rshort_decl_void@
F << extract_vorbis_rshort_decl_void.F;
P << extract_vorbis_rshort_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: vorbis_seek
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_vorbis_seek_def@
type T;
identifier F = vorbis_seek;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_vorbis_seek_def@
F << remove_static_vorbis_seek_def.F;
T << remove_static_vorbis_seek_def.T;
P << remove_static_vorbis_seek_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_vorbis_seek_def_void@
identifier F = vorbis_seek;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_vorbis_seek_def_void@
F << remove_static_vorbis_seek_def_void.F;
P << remove_static_vorbis_seek_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_vorbis_seek_decl@
type T;
identifier F = vorbis_seek;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_vorbis_seek_decl@
F << remove_static_vorbis_seek_decl.F;
T << remove_static_vorbis_seek_decl.T;
P << remove_static_vorbis_seek_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_vorbis_seek_decl_void@
identifier F = vorbis_seek;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_vorbis_seek_decl_void@
F << remove_static_vorbis_seek_decl_void.F;
P << remove_static_vorbis_seek_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_vorbis_seek_def@
type T;
identifier F = vorbis_seek;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_vorbis_seek_def@
F << extract_vorbis_seek_def.F;
T << extract_vorbis_seek_def.T;
P << extract_vorbis_seek_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_vorbis_seek_def_void@
identifier F = vorbis_seek;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_vorbis_seek_def_void@
F << extract_vorbis_seek_def_void.F;
P << extract_vorbis_seek_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_vorbis_seek_decl@
type T;
identifier F = vorbis_seek;
parameter list P;
@@
T F(P);

@script:python depends on extract_vorbis_seek_decl@
F << extract_vorbis_seek_decl.F;
T << extract_vorbis_seek_decl.T;
P << extract_vorbis_seek_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_vorbis_seek_decl_void@
identifier F = vorbis_seek;
parameter list P;
@@
void F(P);

@script:python depends on extract_vorbis_seek_decl_void@
F << extract_vorbis_seek_decl_void.F;
P << extract_vorbis_seek_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: vorbis_write_d
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_vorbis_write_d_def@
type T;
identifier F = vorbis_write_d;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_vorbis_write_d_def@
F << remove_static_vorbis_write_d_def.F;
T << remove_static_vorbis_write_d_def.T;
P << remove_static_vorbis_write_d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_vorbis_write_d_def_void@
identifier F = vorbis_write_d;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_vorbis_write_d_def_void@
F << remove_static_vorbis_write_d_def_void.F;
P << remove_static_vorbis_write_d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_vorbis_write_d_decl@
type T;
identifier F = vorbis_write_d;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_vorbis_write_d_decl@
F << remove_static_vorbis_write_d_decl.F;
T << remove_static_vorbis_write_d_decl.T;
P << remove_static_vorbis_write_d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_vorbis_write_d_decl_void@
identifier F = vorbis_write_d;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_vorbis_write_d_decl_void@
F << remove_static_vorbis_write_d_decl_void.F;
P << remove_static_vorbis_write_d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_vorbis_write_d_def@
type T;
identifier F = vorbis_write_d;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_vorbis_write_d_def@
F << extract_vorbis_write_d_def.F;
T << extract_vorbis_write_d_def.T;
P << extract_vorbis_write_d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_vorbis_write_d_def_void@
identifier F = vorbis_write_d;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_vorbis_write_d_def_void@
F << extract_vorbis_write_d_def_void.F;
P << extract_vorbis_write_d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_vorbis_write_d_decl@
type T;
identifier F = vorbis_write_d;
parameter list P;
@@
T F(P);

@script:python depends on extract_vorbis_write_d_decl@
F << extract_vorbis_write_d_decl.F;
T << extract_vorbis_write_d_decl.T;
P << extract_vorbis_write_d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_vorbis_write_d_decl_void@
identifier F = vorbis_write_d;
parameter list P;
@@
void F(P);

@script:python depends on extract_vorbis_write_d_decl_void@
F << extract_vorbis_write_d_decl_void.F;
P << extract_vorbis_write_d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: vorbis_write_f
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_vorbis_write_f_def@
type T;
identifier F = vorbis_write_f;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_vorbis_write_f_def@
F << remove_static_vorbis_write_f_def.F;
T << remove_static_vorbis_write_f_def.T;
P << remove_static_vorbis_write_f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_vorbis_write_f_def_void@
identifier F = vorbis_write_f;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_vorbis_write_f_def_void@
F << remove_static_vorbis_write_f_def_void.F;
P << remove_static_vorbis_write_f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_vorbis_write_f_decl@
type T;
identifier F = vorbis_write_f;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_vorbis_write_f_decl@
F << remove_static_vorbis_write_f_decl.F;
T << remove_static_vorbis_write_f_decl.T;
P << remove_static_vorbis_write_f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_vorbis_write_f_decl_void@
identifier F = vorbis_write_f;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_vorbis_write_f_decl_void@
F << remove_static_vorbis_write_f_decl_void.F;
P << remove_static_vorbis_write_f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_vorbis_write_f_def@
type T;
identifier F = vorbis_write_f;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_vorbis_write_f_def@
F << extract_vorbis_write_f_def.F;
T << extract_vorbis_write_f_def.T;
P << extract_vorbis_write_f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_vorbis_write_f_def_void@
identifier F = vorbis_write_f;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_vorbis_write_f_def_void@
F << extract_vorbis_write_f_def_void.F;
P << extract_vorbis_write_f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_vorbis_write_f_decl@
type T;
identifier F = vorbis_write_f;
parameter list P;
@@
T F(P);

@script:python depends on extract_vorbis_write_f_decl@
F << extract_vorbis_write_f_decl.F;
T << extract_vorbis_write_f_decl.T;
P << extract_vorbis_write_f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_vorbis_write_f_decl_void@
identifier F = vorbis_write_f;
parameter list P;
@@
void F(P);

@script:python depends on extract_vorbis_write_f_decl_void@
F << extract_vorbis_write_f_decl_void.F;
P << extract_vorbis_write_f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: vorbis_write_header
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_vorbis_write_header_def@
type T;
identifier F = vorbis_write_header;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_vorbis_write_header_def@
F << remove_static_vorbis_write_header_def.F;
T << remove_static_vorbis_write_header_def.T;
P << remove_static_vorbis_write_header_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_vorbis_write_header_def_void@
identifier F = vorbis_write_header;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_vorbis_write_header_def_void@
F << remove_static_vorbis_write_header_def_void.F;
P << remove_static_vorbis_write_header_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_vorbis_write_header_decl@
type T;
identifier F = vorbis_write_header;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_vorbis_write_header_decl@
F << remove_static_vorbis_write_header_decl.F;
T << remove_static_vorbis_write_header_decl.T;
P << remove_static_vorbis_write_header_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_vorbis_write_header_decl_void@
identifier F = vorbis_write_header;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_vorbis_write_header_decl_void@
F << remove_static_vorbis_write_header_decl_void.F;
P << remove_static_vorbis_write_header_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_vorbis_write_header_def@
type T;
identifier F = vorbis_write_header;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_vorbis_write_header_def@
F << extract_vorbis_write_header_def.F;
T << extract_vorbis_write_header_def.T;
P << extract_vorbis_write_header_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_vorbis_write_header_def_void@
identifier F = vorbis_write_header;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_vorbis_write_header_def_void@
F << extract_vorbis_write_header_def_void.F;
P << extract_vorbis_write_header_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_vorbis_write_header_decl@
type T;
identifier F = vorbis_write_header;
parameter list P;
@@
T F(P);

@script:python depends on extract_vorbis_write_header_decl@
F << extract_vorbis_write_header_decl.F;
T << extract_vorbis_write_header_decl.T;
P << extract_vorbis_write_header_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_vorbis_write_header_decl_void@
identifier F = vorbis_write_header;
parameter list P;
@@
void F(P);

@script:python depends on extract_vorbis_write_header_decl_void@
F << extract_vorbis_write_header_decl_void.F;
P << extract_vorbis_write_header_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: vorbis_write_i
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_vorbis_write_i_def@
type T;
identifier F = vorbis_write_i;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_vorbis_write_i_def@
F << remove_static_vorbis_write_i_def.F;
T << remove_static_vorbis_write_i_def.T;
P << remove_static_vorbis_write_i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_vorbis_write_i_def_void@
identifier F = vorbis_write_i;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_vorbis_write_i_def_void@
F << remove_static_vorbis_write_i_def_void.F;
P << remove_static_vorbis_write_i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_vorbis_write_i_decl@
type T;
identifier F = vorbis_write_i;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_vorbis_write_i_decl@
F << remove_static_vorbis_write_i_decl.F;
T << remove_static_vorbis_write_i_decl.T;
P << remove_static_vorbis_write_i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_vorbis_write_i_decl_void@
identifier F = vorbis_write_i;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_vorbis_write_i_decl_void@
F << remove_static_vorbis_write_i_decl_void.F;
P << remove_static_vorbis_write_i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_vorbis_write_i_def@
type T;
identifier F = vorbis_write_i;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_vorbis_write_i_def@
F << extract_vorbis_write_i_def.F;
T << extract_vorbis_write_i_def.T;
P << extract_vorbis_write_i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_vorbis_write_i_def_void@
identifier F = vorbis_write_i;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_vorbis_write_i_def_void@
F << extract_vorbis_write_i_def_void.F;
P << extract_vorbis_write_i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_vorbis_write_i_decl@
type T;
identifier F = vorbis_write_i;
parameter list P;
@@
T F(P);

@script:python depends on extract_vorbis_write_i_decl@
F << extract_vorbis_write_i_decl.F;
T << extract_vorbis_write_i_decl.T;
P << extract_vorbis_write_i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_vorbis_write_i_decl_void@
identifier F = vorbis_write_i;
parameter list P;
@@
void F(P);

@script:python depends on extract_vorbis_write_i_decl_void@
F << extract_vorbis_write_i_decl_void.F;
P << extract_vorbis_write_i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: vorbis_write_s
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_vorbis_write_s_def@
type T;
identifier F = vorbis_write_s;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_vorbis_write_s_def@
F << remove_static_vorbis_write_s_def.F;
T << remove_static_vorbis_write_s_def.T;
P << remove_static_vorbis_write_s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_vorbis_write_s_def_void@
identifier F = vorbis_write_s;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_vorbis_write_s_def_void@
F << remove_static_vorbis_write_s_def_void.F;
P << remove_static_vorbis_write_s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_vorbis_write_s_decl@
type T;
identifier F = vorbis_write_s;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_vorbis_write_s_decl@
F << remove_static_vorbis_write_s_decl.F;
T << remove_static_vorbis_write_s_decl.T;
P << remove_static_vorbis_write_s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_vorbis_write_s_decl_void@
identifier F = vorbis_write_s;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_vorbis_write_s_decl_void@
F << remove_static_vorbis_write_s_decl_void.F;
P << remove_static_vorbis_write_s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_vorbis_write_s_def@
type T;
identifier F = vorbis_write_s;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_vorbis_write_s_def@
F << extract_vorbis_write_s_def.F;
T << extract_vorbis_write_s_def.T;
P << extract_vorbis_write_s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_vorbis_write_s_def_void@
identifier F = vorbis_write_s;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_vorbis_write_s_def_void@
F << extract_vorbis_write_s_def_void.F;
P << extract_vorbis_write_s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_vorbis_write_s_decl@
type T;
identifier F = vorbis_write_s;
parameter list P;
@@
T F(P);

@script:python depends on extract_vorbis_write_s_decl@
F << extract_vorbis_write_s_decl.F;
T << extract_vorbis_write_s_decl.T;
P << extract_vorbis_write_s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_vorbis_write_s_decl_void@
identifier F = vorbis_write_s;
parameter list P;
@@
void F(P);

@script:python depends on extract_vorbis_write_s_decl_void@
F << extract_vorbis_write_s_decl_void.F;
P << extract_vorbis_write_s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: vox_read_d
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_vox_read_d_def@
type T;
identifier F = vox_read_d;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_vox_read_d_def@
F << remove_static_vox_read_d_def.F;
T << remove_static_vox_read_d_def.T;
P << remove_static_vox_read_d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_vox_read_d_def_void@
identifier F = vox_read_d;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_vox_read_d_def_void@
F << remove_static_vox_read_d_def_void.F;
P << remove_static_vox_read_d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_vox_read_d_decl@
type T;
identifier F = vox_read_d;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_vox_read_d_decl@
F << remove_static_vox_read_d_decl.F;
T << remove_static_vox_read_d_decl.T;
P << remove_static_vox_read_d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_vox_read_d_decl_void@
identifier F = vox_read_d;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_vox_read_d_decl_void@
F << remove_static_vox_read_d_decl_void.F;
P << remove_static_vox_read_d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_vox_read_d_def@
type T;
identifier F = vox_read_d;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_vox_read_d_def@
F << extract_vox_read_d_def.F;
T << extract_vox_read_d_def.T;
P << extract_vox_read_d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_vox_read_d_def_void@
identifier F = vox_read_d;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_vox_read_d_def_void@
F << extract_vox_read_d_def_void.F;
P << extract_vox_read_d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_vox_read_d_decl@
type T;
identifier F = vox_read_d;
parameter list P;
@@
T F(P);

@script:python depends on extract_vox_read_d_decl@
F << extract_vox_read_d_decl.F;
T << extract_vox_read_d_decl.T;
P << extract_vox_read_d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_vox_read_d_decl_void@
identifier F = vox_read_d;
parameter list P;
@@
void F(P);

@script:python depends on extract_vox_read_d_decl_void@
F << extract_vox_read_d_decl_void.F;
P << extract_vox_read_d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: vox_read_f
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_vox_read_f_def@
type T;
identifier F = vox_read_f;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_vox_read_f_def@
F << remove_static_vox_read_f_def.F;
T << remove_static_vox_read_f_def.T;
P << remove_static_vox_read_f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_vox_read_f_def_void@
identifier F = vox_read_f;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_vox_read_f_def_void@
F << remove_static_vox_read_f_def_void.F;
P << remove_static_vox_read_f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_vox_read_f_decl@
type T;
identifier F = vox_read_f;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_vox_read_f_decl@
F << remove_static_vox_read_f_decl.F;
T << remove_static_vox_read_f_decl.T;
P << remove_static_vox_read_f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_vox_read_f_decl_void@
identifier F = vox_read_f;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_vox_read_f_decl_void@
F << remove_static_vox_read_f_decl_void.F;
P << remove_static_vox_read_f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_vox_read_f_def@
type T;
identifier F = vox_read_f;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_vox_read_f_def@
F << extract_vox_read_f_def.F;
T << extract_vox_read_f_def.T;
P << extract_vox_read_f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_vox_read_f_def_void@
identifier F = vox_read_f;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_vox_read_f_def_void@
F << extract_vox_read_f_def_void.F;
P << extract_vox_read_f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_vox_read_f_decl@
type T;
identifier F = vox_read_f;
parameter list P;
@@
T F(P);

@script:python depends on extract_vox_read_f_decl@
F << extract_vox_read_f_decl.F;
T << extract_vox_read_f_decl.T;
P << extract_vox_read_f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_vox_read_f_decl_void@
identifier F = vox_read_f;
parameter list P;
@@
void F(P);

@script:python depends on extract_vox_read_f_decl_void@
F << extract_vox_read_f_decl_void.F;
P << extract_vox_read_f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: vox_read_i
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_vox_read_i_def@
type T;
identifier F = vox_read_i;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_vox_read_i_def@
F << remove_static_vox_read_i_def.F;
T << remove_static_vox_read_i_def.T;
P << remove_static_vox_read_i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_vox_read_i_def_void@
identifier F = vox_read_i;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_vox_read_i_def_void@
F << remove_static_vox_read_i_def_void.F;
P << remove_static_vox_read_i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_vox_read_i_decl@
type T;
identifier F = vox_read_i;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_vox_read_i_decl@
F << remove_static_vox_read_i_decl.F;
T << remove_static_vox_read_i_decl.T;
P << remove_static_vox_read_i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_vox_read_i_decl_void@
identifier F = vox_read_i;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_vox_read_i_decl_void@
F << remove_static_vox_read_i_decl_void.F;
P << remove_static_vox_read_i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_vox_read_i_def@
type T;
identifier F = vox_read_i;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_vox_read_i_def@
F << extract_vox_read_i_def.F;
T << extract_vox_read_i_def.T;
P << extract_vox_read_i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_vox_read_i_def_void@
identifier F = vox_read_i;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_vox_read_i_def_void@
F << extract_vox_read_i_def_void.F;
P << extract_vox_read_i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_vox_read_i_decl@
type T;
identifier F = vox_read_i;
parameter list P;
@@
T F(P);

@script:python depends on extract_vox_read_i_decl@
F << extract_vox_read_i_decl.F;
T << extract_vox_read_i_decl.T;
P << extract_vox_read_i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_vox_read_i_decl_void@
identifier F = vox_read_i;
parameter list P;
@@
void F(P);

@script:python depends on extract_vox_read_i_decl_void@
F << extract_vox_read_i_decl_void.F;
P << extract_vox_read_i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: vox_read_s
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_vox_read_s_def@
type T;
identifier F = vox_read_s;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_vox_read_s_def@
F << remove_static_vox_read_s_def.F;
T << remove_static_vox_read_s_def.T;
P << remove_static_vox_read_s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_vox_read_s_def_void@
identifier F = vox_read_s;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_vox_read_s_def_void@
F << remove_static_vox_read_s_def_void.F;
P << remove_static_vox_read_s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_vox_read_s_decl@
type T;
identifier F = vox_read_s;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_vox_read_s_decl@
F << remove_static_vox_read_s_decl.F;
T << remove_static_vox_read_s_decl.T;
P << remove_static_vox_read_s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_vox_read_s_decl_void@
identifier F = vox_read_s;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_vox_read_s_decl_void@
F << remove_static_vox_read_s_decl_void.F;
P << remove_static_vox_read_s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_vox_read_s_def@
type T;
identifier F = vox_read_s;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_vox_read_s_def@
F << extract_vox_read_s_def.F;
T << extract_vox_read_s_def.T;
P << extract_vox_read_s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_vox_read_s_def_void@
identifier F = vox_read_s;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_vox_read_s_def_void@
F << extract_vox_read_s_def_void.F;
P << extract_vox_read_s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_vox_read_s_decl@
type T;
identifier F = vox_read_s;
parameter list P;
@@
T F(P);

@script:python depends on extract_vox_read_s_decl@
F << extract_vox_read_s_decl.F;
T << extract_vox_read_s_decl.T;
P << extract_vox_read_s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_vox_read_s_decl_void@
identifier F = vox_read_s;
parameter list P;
@@
void F(P);

@script:python depends on extract_vox_read_s_decl_void@
F << extract_vox_read_s_decl_void.F;
P << extract_vox_read_s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: vox_write_d
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_vox_write_d_def@
type T;
identifier F = vox_write_d;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_vox_write_d_def@
F << remove_static_vox_write_d_def.F;
T << remove_static_vox_write_d_def.T;
P << remove_static_vox_write_d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_vox_write_d_def_void@
identifier F = vox_write_d;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_vox_write_d_def_void@
F << remove_static_vox_write_d_def_void.F;
P << remove_static_vox_write_d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_vox_write_d_decl@
type T;
identifier F = vox_write_d;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_vox_write_d_decl@
F << remove_static_vox_write_d_decl.F;
T << remove_static_vox_write_d_decl.T;
P << remove_static_vox_write_d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_vox_write_d_decl_void@
identifier F = vox_write_d;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_vox_write_d_decl_void@
F << remove_static_vox_write_d_decl_void.F;
P << remove_static_vox_write_d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_vox_write_d_def@
type T;
identifier F = vox_write_d;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_vox_write_d_def@
F << extract_vox_write_d_def.F;
T << extract_vox_write_d_def.T;
P << extract_vox_write_d_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_vox_write_d_def_void@
identifier F = vox_write_d;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_vox_write_d_def_void@
F << extract_vox_write_d_def_void.F;
P << extract_vox_write_d_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_vox_write_d_decl@
type T;
identifier F = vox_write_d;
parameter list P;
@@
T F(P);

@script:python depends on extract_vox_write_d_decl@
F << extract_vox_write_d_decl.F;
T << extract_vox_write_d_decl.T;
P << extract_vox_write_d_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_vox_write_d_decl_void@
identifier F = vox_write_d;
parameter list P;
@@
void F(P);

@script:python depends on extract_vox_write_d_decl_void@
F << extract_vox_write_d_decl_void.F;
P << extract_vox_write_d_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: vox_write_f
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_vox_write_f_def@
type T;
identifier F = vox_write_f;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_vox_write_f_def@
F << remove_static_vox_write_f_def.F;
T << remove_static_vox_write_f_def.T;
P << remove_static_vox_write_f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_vox_write_f_def_void@
identifier F = vox_write_f;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_vox_write_f_def_void@
F << remove_static_vox_write_f_def_void.F;
P << remove_static_vox_write_f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_vox_write_f_decl@
type T;
identifier F = vox_write_f;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_vox_write_f_decl@
F << remove_static_vox_write_f_decl.F;
T << remove_static_vox_write_f_decl.T;
P << remove_static_vox_write_f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_vox_write_f_decl_void@
identifier F = vox_write_f;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_vox_write_f_decl_void@
F << remove_static_vox_write_f_decl_void.F;
P << remove_static_vox_write_f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_vox_write_f_def@
type T;
identifier F = vox_write_f;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_vox_write_f_def@
F << extract_vox_write_f_def.F;
T << extract_vox_write_f_def.T;
P << extract_vox_write_f_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_vox_write_f_def_void@
identifier F = vox_write_f;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_vox_write_f_def_void@
F << extract_vox_write_f_def_void.F;
P << extract_vox_write_f_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_vox_write_f_decl@
type T;
identifier F = vox_write_f;
parameter list P;
@@
T F(P);

@script:python depends on extract_vox_write_f_decl@
F << extract_vox_write_f_decl.F;
T << extract_vox_write_f_decl.T;
P << extract_vox_write_f_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_vox_write_f_decl_void@
identifier F = vox_write_f;
parameter list P;
@@
void F(P);

@script:python depends on extract_vox_write_f_decl_void@
F << extract_vox_write_f_decl_void.F;
P << extract_vox_write_f_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: vox_write_i
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_vox_write_i_def@
type T;
identifier F = vox_write_i;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_vox_write_i_def@
F << remove_static_vox_write_i_def.F;
T << remove_static_vox_write_i_def.T;
P << remove_static_vox_write_i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_vox_write_i_def_void@
identifier F = vox_write_i;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_vox_write_i_def_void@
F << remove_static_vox_write_i_def_void.F;
P << remove_static_vox_write_i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_vox_write_i_decl@
type T;
identifier F = vox_write_i;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_vox_write_i_decl@
F << remove_static_vox_write_i_decl.F;
T << remove_static_vox_write_i_decl.T;
P << remove_static_vox_write_i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_vox_write_i_decl_void@
identifier F = vox_write_i;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_vox_write_i_decl_void@
F << remove_static_vox_write_i_decl_void.F;
P << remove_static_vox_write_i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_vox_write_i_def@
type T;
identifier F = vox_write_i;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_vox_write_i_def@
F << extract_vox_write_i_def.F;
T << extract_vox_write_i_def.T;
P << extract_vox_write_i_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_vox_write_i_def_void@
identifier F = vox_write_i;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_vox_write_i_def_void@
F << extract_vox_write_i_def_void.F;
P << extract_vox_write_i_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_vox_write_i_decl@
type T;
identifier F = vox_write_i;
parameter list P;
@@
T F(P);

@script:python depends on extract_vox_write_i_decl@
F << extract_vox_write_i_decl.F;
T << extract_vox_write_i_decl.T;
P << extract_vox_write_i_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_vox_write_i_decl_void@
identifier F = vox_write_i;
parameter list P;
@@
void F(P);

@script:python depends on extract_vox_write_i_decl_void@
F << extract_vox_write_i_decl_void.F;
P << extract_vox_write_i_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: vox_write_s
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_vox_write_s_def@
type T;
identifier F = vox_write_s;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_vox_write_s_def@
F << remove_static_vox_write_s_def.F;
T << remove_static_vox_write_s_def.T;
P << remove_static_vox_write_s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_vox_write_s_def_void@
identifier F = vox_write_s;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_vox_write_s_def_void@
F << remove_static_vox_write_s_def_void.F;
P << remove_static_vox_write_s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_vox_write_s_decl@
type T;
identifier F = vox_write_s;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_vox_write_s_decl@
F << remove_static_vox_write_s_decl.F;
T << remove_static_vox_write_s_decl.T;
P << remove_static_vox_write_s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_vox_write_s_decl_void@
identifier F = vox_write_s;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_vox_write_s_decl_void@
F << remove_static_vox_write_s_decl_void.F;
P << remove_static_vox_write_s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_vox_write_s_def@
type T;
identifier F = vox_write_s;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_vox_write_s_def@
F << extract_vox_write_s_def.F;
T << extract_vox_write_s_def.T;
P << extract_vox_write_s_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_vox_write_s_def_void@
identifier F = vox_write_s;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_vox_write_s_def_void@
F << extract_vox_write_s_def_void.F;
P << extract_vox_write_s_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_vox_write_s_decl@
type T;
identifier F = vox_write_s;
parameter list P;
@@
T F(P);

@script:python depends on extract_vox_write_s_decl@
F << extract_vox_write_s_decl.F;
T << extract_vox_write_s_decl.T;
P << extract_vox_write_s_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_vox_write_s_decl_void@
identifier F = vox_write_s;
parameter list P;
@@
void F(P);

@script:python depends on extract_vox_write_s_decl_void@
F << extract_vox_write_s_decl_void.F;
P << extract_vox_write_s_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: w64_close
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_w64_close_def@
type T;
identifier F = w64_close;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_w64_close_def@
F << remove_static_w64_close_def.F;
T << remove_static_w64_close_def.T;
P << remove_static_w64_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_w64_close_def_void@
identifier F = w64_close;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_w64_close_def_void@
F << remove_static_w64_close_def_void.F;
P << remove_static_w64_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_w64_close_decl@
type T;
identifier F = w64_close;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_w64_close_decl@
F << remove_static_w64_close_decl.F;
T << remove_static_w64_close_decl.T;
P << remove_static_w64_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_w64_close_decl_void@
identifier F = w64_close;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_w64_close_decl_void@
F << remove_static_w64_close_decl_void.F;
P << remove_static_w64_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_w64_close_def@
type T;
identifier F = w64_close;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_w64_close_def@
F << extract_w64_close_def.F;
T << extract_w64_close_def.T;
P << extract_w64_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_w64_close_def_void@
identifier F = w64_close;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_w64_close_def_void@
F << extract_w64_close_def_void.F;
P << extract_w64_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_w64_close_decl@
type T;
identifier F = w64_close;
parameter list P;
@@
T F(P);

@script:python depends on extract_w64_close_decl@
F << extract_w64_close_decl.F;
T << extract_w64_close_decl.T;
P << extract_w64_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_w64_close_decl_void@
identifier F = w64_close;
parameter list P;
@@
void F(P);

@script:python depends on extract_w64_close_decl_void@
F << extract_w64_close_decl_void.F;
P << extract_w64_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: w64_write_header
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_w64_write_header_def@
type T;
identifier F = w64_write_header;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_w64_write_header_def@
F << remove_static_w64_write_header_def.F;
T << remove_static_w64_write_header_def.T;
P << remove_static_w64_write_header_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_w64_write_header_def_void@
identifier F = w64_write_header;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_w64_write_header_def_void@
F << remove_static_w64_write_header_def_void.F;
P << remove_static_w64_write_header_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_w64_write_header_decl@
type T;
identifier F = w64_write_header;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_w64_write_header_decl@
F << remove_static_w64_write_header_decl.F;
T << remove_static_w64_write_header_decl.T;
P << remove_static_w64_write_header_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_w64_write_header_decl_void@
identifier F = w64_write_header;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_w64_write_header_decl_void@
F << remove_static_w64_write_header_decl_void.F;
P << remove_static_w64_write_header_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_w64_write_header_def@
type T;
identifier F = w64_write_header;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_w64_write_header_def@
F << extract_w64_write_header_def.F;
T << extract_w64_write_header_def.T;
P << extract_w64_write_header_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_w64_write_header_def_void@
identifier F = w64_write_header;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_w64_write_header_def_void@
F << extract_w64_write_header_def_void.F;
P << extract_w64_write_header_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_w64_write_header_decl@
type T;
identifier F = w64_write_header;
parameter list P;
@@
T F(P);

@script:python depends on extract_w64_write_header_decl@
F << extract_w64_write_header_decl.F;
T << extract_w64_write_header_decl.T;
P << extract_w64_write_header_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_w64_write_header_decl_void@
identifier F = w64_write_header;
parameter list P;
@@
void F(P);

@script:python depends on extract_w64_write_header_decl_void@
F << extract_w64_write_header_decl_void.F;
P << extract_w64_write_header_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: wav_close
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_wav_close_def@
type T;
identifier F = wav_close;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_wav_close_def@
F << remove_static_wav_close_def.F;
T << remove_static_wav_close_def.T;
P << remove_static_wav_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_wav_close_def_void@
identifier F = wav_close;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_wav_close_def_void@
F << remove_static_wav_close_def_void.F;
P << remove_static_wav_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_wav_close_decl@
type T;
identifier F = wav_close;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_wav_close_decl@
F << remove_static_wav_close_decl.F;
T << remove_static_wav_close_decl.T;
P << remove_static_wav_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_wav_close_decl_void@
identifier F = wav_close;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_wav_close_decl_void@
F << remove_static_wav_close_decl_void.F;
P << remove_static_wav_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_wav_close_def@
type T;
identifier F = wav_close;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_wav_close_def@
F << extract_wav_close_def.F;
T << extract_wav_close_def.T;
P << extract_wav_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_wav_close_def_void@
identifier F = wav_close;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_wav_close_def_void@
F << extract_wav_close_def_void.F;
P << extract_wav_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_wav_close_decl@
type T;
identifier F = wav_close;
parameter list P;
@@
T F(P);

@script:python depends on extract_wav_close_decl@
F << extract_wav_close_decl.F;
T << extract_wav_close_decl.T;
P << extract_wav_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_wav_close_decl_void@
identifier F = wav_close;
parameter list P;
@@
void F(P);

@script:python depends on extract_wav_close_decl_void@
F << extract_wav_close_decl_void.F;
P << extract_wav_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: wav_command
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_wav_command_def@
type T;
identifier F = wav_command;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_wav_command_def@
F << remove_static_wav_command_def.F;
T << remove_static_wav_command_def.T;
P << remove_static_wav_command_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_wav_command_def_void@
identifier F = wav_command;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_wav_command_def_void@
F << remove_static_wav_command_def_void.F;
P << remove_static_wav_command_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_wav_command_decl@
type T;
identifier F = wav_command;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_wav_command_decl@
F << remove_static_wav_command_decl.F;
T << remove_static_wav_command_decl.T;
P << remove_static_wav_command_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_wav_command_decl_void@
identifier F = wav_command;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_wav_command_decl_void@
F << remove_static_wav_command_decl_void.F;
P << remove_static_wav_command_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_wav_command_def@
type T;
identifier F = wav_command;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_wav_command_def@
F << extract_wav_command_def.F;
T << extract_wav_command_def.T;
P << extract_wav_command_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_wav_command_def_void@
identifier F = wav_command;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_wav_command_def_void@
F << extract_wav_command_def_void.F;
P << extract_wav_command_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_wav_command_decl@
type T;
identifier F = wav_command;
parameter list P;
@@
T F(P);

@script:python depends on extract_wav_command_decl@
F << extract_wav_command_decl.F;
T << extract_wav_command_decl.T;
P << extract_wav_command_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_wav_command_decl_void@
identifier F = wav_command;
parameter list P;
@@
void F(P);

@script:python depends on extract_wav_command_decl_void@
F << extract_wav_command_decl_void.F;
P << extract_wav_command_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: wav_get_chunk_data
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_wav_get_chunk_data_def@
type T;
identifier F = wav_get_chunk_data;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_wav_get_chunk_data_def@
F << remove_static_wav_get_chunk_data_def.F;
T << remove_static_wav_get_chunk_data_def.T;
P << remove_static_wav_get_chunk_data_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_wav_get_chunk_data_def_void@
identifier F = wav_get_chunk_data;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_wav_get_chunk_data_def_void@
F << remove_static_wav_get_chunk_data_def_void.F;
P << remove_static_wav_get_chunk_data_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_wav_get_chunk_data_decl@
type T;
identifier F = wav_get_chunk_data;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_wav_get_chunk_data_decl@
F << remove_static_wav_get_chunk_data_decl.F;
T << remove_static_wav_get_chunk_data_decl.T;
P << remove_static_wav_get_chunk_data_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_wav_get_chunk_data_decl_void@
identifier F = wav_get_chunk_data;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_wav_get_chunk_data_decl_void@
F << remove_static_wav_get_chunk_data_decl_void.F;
P << remove_static_wav_get_chunk_data_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_wav_get_chunk_data_def@
type T;
identifier F = wav_get_chunk_data;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_wav_get_chunk_data_def@
F << extract_wav_get_chunk_data_def.F;
T << extract_wav_get_chunk_data_def.T;
P << extract_wav_get_chunk_data_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_wav_get_chunk_data_def_void@
identifier F = wav_get_chunk_data;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_wav_get_chunk_data_def_void@
F << extract_wav_get_chunk_data_def_void.F;
P << extract_wav_get_chunk_data_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_wav_get_chunk_data_decl@
type T;
identifier F = wav_get_chunk_data;
parameter list P;
@@
T F(P);

@script:python depends on extract_wav_get_chunk_data_decl@
F << extract_wav_get_chunk_data_decl.F;
T << extract_wav_get_chunk_data_decl.T;
P << extract_wav_get_chunk_data_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_wav_get_chunk_data_decl_void@
identifier F = wav_get_chunk_data;
parameter list P;
@@
void F(P);

@script:python depends on extract_wav_get_chunk_data_decl_void@
F << extract_wav_get_chunk_data_decl_void.F;
P << extract_wav_get_chunk_data_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: wav_get_chunk_size
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_wav_get_chunk_size_def@
type T;
identifier F = wav_get_chunk_size;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_wav_get_chunk_size_def@
F << remove_static_wav_get_chunk_size_def.F;
T << remove_static_wav_get_chunk_size_def.T;
P << remove_static_wav_get_chunk_size_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_wav_get_chunk_size_def_void@
identifier F = wav_get_chunk_size;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_wav_get_chunk_size_def_void@
F << remove_static_wav_get_chunk_size_def_void.F;
P << remove_static_wav_get_chunk_size_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_wav_get_chunk_size_decl@
type T;
identifier F = wav_get_chunk_size;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_wav_get_chunk_size_decl@
F << remove_static_wav_get_chunk_size_decl.F;
T << remove_static_wav_get_chunk_size_decl.T;
P << remove_static_wav_get_chunk_size_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_wav_get_chunk_size_decl_void@
identifier F = wav_get_chunk_size;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_wav_get_chunk_size_decl_void@
F << remove_static_wav_get_chunk_size_decl_void.F;
P << remove_static_wav_get_chunk_size_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_wav_get_chunk_size_def@
type T;
identifier F = wav_get_chunk_size;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_wav_get_chunk_size_def@
F << extract_wav_get_chunk_size_def.F;
T << extract_wav_get_chunk_size_def.T;
P << extract_wav_get_chunk_size_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_wav_get_chunk_size_def_void@
identifier F = wav_get_chunk_size;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_wav_get_chunk_size_def_void@
F << extract_wav_get_chunk_size_def_void.F;
P << extract_wav_get_chunk_size_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_wav_get_chunk_size_decl@
type T;
identifier F = wav_get_chunk_size;
parameter list P;
@@
T F(P);

@script:python depends on extract_wav_get_chunk_size_decl@
F << extract_wav_get_chunk_size_decl.F;
T << extract_wav_get_chunk_size_decl.T;
P << extract_wav_get_chunk_size_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_wav_get_chunk_size_decl_void@
identifier F = wav_get_chunk_size;
parameter list P;
@@
void F(P);

@script:python depends on extract_wav_get_chunk_size_decl_void@
F << extract_wav_get_chunk_size_decl_void.F;
P << extract_wav_get_chunk_size_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: wav_next_chunk_iterator
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_wav_next_chunk_iterator_def@
type T;
identifier F = wav_next_chunk_iterator;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_wav_next_chunk_iterator_def@
F << remove_static_wav_next_chunk_iterator_def.F;
T << remove_static_wav_next_chunk_iterator_def.T;
P << remove_static_wav_next_chunk_iterator_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_wav_next_chunk_iterator_def_void@
identifier F = wav_next_chunk_iterator;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_wav_next_chunk_iterator_def_void@
F << remove_static_wav_next_chunk_iterator_def_void.F;
P << remove_static_wav_next_chunk_iterator_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_wav_next_chunk_iterator_decl@
type T;
identifier F = wav_next_chunk_iterator;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_wav_next_chunk_iterator_decl@
F << remove_static_wav_next_chunk_iterator_decl.F;
T << remove_static_wav_next_chunk_iterator_decl.T;
P << remove_static_wav_next_chunk_iterator_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_wav_next_chunk_iterator_decl_void@
identifier F = wav_next_chunk_iterator;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_wav_next_chunk_iterator_decl_void@
F << remove_static_wav_next_chunk_iterator_decl_void.F;
P << remove_static_wav_next_chunk_iterator_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_wav_next_chunk_iterator_def@
type T;
identifier F = wav_next_chunk_iterator;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_wav_next_chunk_iterator_def@
F << extract_wav_next_chunk_iterator_def.F;
T << extract_wav_next_chunk_iterator_def.T;
P << extract_wav_next_chunk_iterator_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_wav_next_chunk_iterator_def_void@
identifier F = wav_next_chunk_iterator;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_wav_next_chunk_iterator_def_void@
F << extract_wav_next_chunk_iterator_def_void.F;
P << extract_wav_next_chunk_iterator_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_wav_next_chunk_iterator_decl@
type T;
identifier F = wav_next_chunk_iterator;
parameter list P;
@@
T F(P);

@script:python depends on extract_wav_next_chunk_iterator_decl@
F << extract_wav_next_chunk_iterator_decl.F;
T << extract_wav_next_chunk_iterator_decl.T;
P << extract_wav_next_chunk_iterator_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_wav_next_chunk_iterator_decl_void@
identifier F = wav_next_chunk_iterator;
parameter list P;
@@
void F(P);

@script:python depends on extract_wav_next_chunk_iterator_decl_void@
F << extract_wav_next_chunk_iterator_decl_void.F;
P << extract_wav_next_chunk_iterator_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: wav_set_chunk
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_wav_set_chunk_def@
type T;
identifier F = wav_set_chunk;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_wav_set_chunk_def@
F << remove_static_wav_set_chunk_def.F;
T << remove_static_wav_set_chunk_def.T;
P << remove_static_wav_set_chunk_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_wav_set_chunk_def_void@
identifier F = wav_set_chunk;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_wav_set_chunk_def_void@
F << remove_static_wav_set_chunk_def_void.F;
P << remove_static_wav_set_chunk_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_wav_set_chunk_decl@
type T;
identifier F = wav_set_chunk;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_wav_set_chunk_decl@
F << remove_static_wav_set_chunk_decl.F;
T << remove_static_wav_set_chunk_decl.T;
P << remove_static_wav_set_chunk_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_wav_set_chunk_decl_void@
identifier F = wav_set_chunk;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_wav_set_chunk_decl_void@
F << remove_static_wav_set_chunk_decl_void.F;
P << remove_static_wav_set_chunk_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_wav_set_chunk_def@
type T;
identifier F = wav_set_chunk;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_wav_set_chunk_def@
F << extract_wav_set_chunk_def.F;
T << extract_wav_set_chunk_def.T;
P << extract_wav_set_chunk_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_wav_set_chunk_def_void@
identifier F = wav_set_chunk;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_wav_set_chunk_def_void@
F << extract_wav_set_chunk_def_void.F;
P << extract_wav_set_chunk_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_wav_set_chunk_decl@
type T;
identifier F = wav_set_chunk;
parameter list P;
@@
T F(P);

@script:python depends on extract_wav_set_chunk_decl@
F << extract_wav_set_chunk_decl.F;
T << extract_wav_set_chunk_decl.T;
P << extract_wav_set_chunk_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_wav_set_chunk_decl_void@
identifier F = wav_set_chunk;
parameter list P;
@@
void F(P);

@script:python depends on extract_wav_set_chunk_decl_void@
F << extract_wav_set_chunk_decl_void.F;
P << extract_wav_set_chunk_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: wav_write_header
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_wav_write_header_def@
type T;
identifier F = wav_write_header;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_wav_write_header_def@
F << remove_static_wav_write_header_def.F;
T << remove_static_wav_write_header_def.T;
P << remove_static_wav_write_header_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_wav_write_header_def_void@
identifier F = wav_write_header;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_wav_write_header_def_void@
F << remove_static_wav_write_header_def_void.F;
P << remove_static_wav_write_header_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_wav_write_header_decl@
type T;
identifier F = wav_write_header;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_wav_write_header_decl@
F << remove_static_wav_write_header_decl.F;
T << remove_static_wav_write_header_decl.T;
P << remove_static_wav_write_header_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_wav_write_header_decl_void@
identifier F = wav_write_header;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_wav_write_header_decl_void@
F << remove_static_wav_write_header_decl_void.F;
P << remove_static_wav_write_header_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_wav_write_header_def@
type T;
identifier F = wav_write_header;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_wav_write_header_def@
F << extract_wav_write_header_def.F;
T << extract_wav_write_header_def.T;
P << extract_wav_write_header_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_wav_write_header_def_void@
identifier F = wav_write_header;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_wav_write_header_def_void@
F << extract_wav_write_header_def_void.F;
P << extract_wav_write_header_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_wav_write_header_decl@
type T;
identifier F = wav_write_header;
parameter list P;
@@
T F(P);

@script:python depends on extract_wav_write_header_decl@
F << extract_wav_write_header_decl.F;
T << extract_wav_write_header_decl.T;
P << extract_wav_write_header_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_wav_write_header_decl_void@
identifier F = wav_write_header;
parameter list P;
@@
void F(P);

@script:python depends on extract_wav_write_header_decl_void@
F << extract_wav_write_header_decl_void.F;
P << extract_wav_write_header_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: wavlike_ima_decode_block
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_wavlike_ima_decode_block_def@
type T;
identifier F = wavlike_ima_decode_block;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_wavlike_ima_decode_block_def@
F << remove_static_wavlike_ima_decode_block_def.F;
T << remove_static_wavlike_ima_decode_block_def.T;
P << remove_static_wavlike_ima_decode_block_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_wavlike_ima_decode_block_def_void@
identifier F = wavlike_ima_decode_block;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_wavlike_ima_decode_block_def_void@
F << remove_static_wavlike_ima_decode_block_def_void.F;
P << remove_static_wavlike_ima_decode_block_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_wavlike_ima_decode_block_decl@
type T;
identifier F = wavlike_ima_decode_block;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_wavlike_ima_decode_block_decl@
F << remove_static_wavlike_ima_decode_block_decl.F;
T << remove_static_wavlike_ima_decode_block_decl.T;
P << remove_static_wavlike_ima_decode_block_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_wavlike_ima_decode_block_decl_void@
identifier F = wavlike_ima_decode_block;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_wavlike_ima_decode_block_decl_void@
F << remove_static_wavlike_ima_decode_block_decl_void.F;
P << remove_static_wavlike_ima_decode_block_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_wavlike_ima_decode_block_def@
type T;
identifier F = wavlike_ima_decode_block;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_wavlike_ima_decode_block_def@
F << extract_wavlike_ima_decode_block_def.F;
T << extract_wavlike_ima_decode_block_def.T;
P << extract_wavlike_ima_decode_block_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_wavlike_ima_decode_block_def_void@
identifier F = wavlike_ima_decode_block;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_wavlike_ima_decode_block_def_void@
F << extract_wavlike_ima_decode_block_def_void.F;
P << extract_wavlike_ima_decode_block_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_wavlike_ima_decode_block_decl@
type T;
identifier F = wavlike_ima_decode_block;
parameter list P;
@@
T F(P);

@script:python depends on extract_wavlike_ima_decode_block_decl@
F << extract_wavlike_ima_decode_block_decl.F;
T << extract_wavlike_ima_decode_block_decl.T;
P << extract_wavlike_ima_decode_block_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_wavlike_ima_decode_block_decl_void@
identifier F = wavlike_ima_decode_block;
parameter list P;
@@
void F(P);

@script:python depends on extract_wavlike_ima_decode_block_decl_void@
F << extract_wavlike_ima_decode_block_decl_void.F;
P << extract_wavlike_ima_decode_block_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: wavlike_ima_encode_block
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_wavlike_ima_encode_block_def@
type T;
identifier F = wavlike_ima_encode_block;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_wavlike_ima_encode_block_def@
F << remove_static_wavlike_ima_encode_block_def.F;
T << remove_static_wavlike_ima_encode_block_def.T;
P << remove_static_wavlike_ima_encode_block_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_wavlike_ima_encode_block_def_void@
identifier F = wavlike_ima_encode_block;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_wavlike_ima_encode_block_def_void@
F << remove_static_wavlike_ima_encode_block_def_void.F;
P << remove_static_wavlike_ima_encode_block_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_wavlike_ima_encode_block_decl@
type T;
identifier F = wavlike_ima_encode_block;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_wavlike_ima_encode_block_decl@
F << remove_static_wavlike_ima_encode_block_decl.F;
T << remove_static_wavlike_ima_encode_block_decl.T;
P << remove_static_wavlike_ima_encode_block_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_wavlike_ima_encode_block_decl_void@
identifier F = wavlike_ima_encode_block;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_wavlike_ima_encode_block_decl_void@
F << remove_static_wavlike_ima_encode_block_decl_void.F;
P << remove_static_wavlike_ima_encode_block_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_wavlike_ima_encode_block_def@
type T;
identifier F = wavlike_ima_encode_block;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_wavlike_ima_encode_block_def@
F << extract_wavlike_ima_encode_block_def.F;
T << extract_wavlike_ima_encode_block_def.T;
P << extract_wavlike_ima_encode_block_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_wavlike_ima_encode_block_def_void@
identifier F = wavlike_ima_encode_block;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_wavlike_ima_encode_block_def_void@
F << extract_wavlike_ima_encode_block_def_void.F;
P << extract_wavlike_ima_encode_block_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_wavlike_ima_encode_block_decl@
type T;
identifier F = wavlike_ima_encode_block;
parameter list P;
@@
T F(P);

@script:python depends on extract_wavlike_ima_encode_block_decl@
F << extract_wavlike_ima_encode_block_decl.F;
T << extract_wavlike_ima_encode_block_decl.T;
P << extract_wavlike_ima_encode_block_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_wavlike_ima_encode_block_decl_void@
identifier F = wavlike_ima_encode_block;
parameter list P;
@@
void F(P);

@script:python depends on extract_wavlike_ima_encode_block_decl_void@
F << extract_wavlike_ima_encode_block_decl_void.F;
P << extract_wavlike_ima_encode_block_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: wavlike_ima_seek
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_wavlike_ima_seek_def@
type T;
identifier F = wavlike_ima_seek;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_wavlike_ima_seek_def@
F << remove_static_wavlike_ima_seek_def.F;
T << remove_static_wavlike_ima_seek_def.T;
P << remove_static_wavlike_ima_seek_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_wavlike_ima_seek_def_void@
identifier F = wavlike_ima_seek;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_wavlike_ima_seek_def_void@
F << remove_static_wavlike_ima_seek_def_void.F;
P << remove_static_wavlike_ima_seek_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_wavlike_ima_seek_decl@
type T;
identifier F = wavlike_ima_seek;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_wavlike_ima_seek_decl@
F << remove_static_wavlike_ima_seek_decl.F;
T << remove_static_wavlike_ima_seek_decl.T;
P << remove_static_wavlike_ima_seek_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_wavlike_ima_seek_decl_void@
identifier F = wavlike_ima_seek;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_wavlike_ima_seek_decl_void@
F << remove_static_wavlike_ima_seek_decl_void.F;
P << remove_static_wavlike_ima_seek_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_wavlike_ima_seek_def@
type T;
identifier F = wavlike_ima_seek;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_wavlike_ima_seek_def@
F << extract_wavlike_ima_seek_def.F;
T << extract_wavlike_ima_seek_def.T;
P << extract_wavlike_ima_seek_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_wavlike_ima_seek_def_void@
identifier F = wavlike_ima_seek;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_wavlike_ima_seek_def_void@
F << extract_wavlike_ima_seek_def_void.F;
P << extract_wavlike_ima_seek_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_wavlike_ima_seek_decl@
type T;
identifier F = wavlike_ima_seek;
parameter list P;
@@
T F(P);

@script:python depends on extract_wavlike_ima_seek_decl@
F << extract_wavlike_ima_seek_decl.F;
T << extract_wavlike_ima_seek_decl.T;
P << extract_wavlike_ima_seek_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_wavlike_ima_seek_decl_void@
identifier F = wavlike_ima_seek;
parameter list P;
@@
void F(P);

@script:python depends on extract_wavlike_ima_seek_decl_void@
F << extract_wavlike_ima_seek_decl_void.F;
P << extract_wavlike_ima_seek_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: wve_close
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_wve_close_def@
type T;
identifier F = wve_close;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_wve_close_def@
F << remove_static_wve_close_def.F;
T << remove_static_wve_close_def.T;
P << remove_static_wve_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_wve_close_def_void@
identifier F = wve_close;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_wve_close_def_void@
F << remove_static_wve_close_def_void.F;
P << remove_static_wve_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_wve_close_decl@
type T;
identifier F = wve_close;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_wve_close_decl@
F << remove_static_wve_close_decl.F;
T << remove_static_wve_close_decl.T;
P << remove_static_wve_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_wve_close_decl_void@
identifier F = wve_close;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_wve_close_decl_void@
F << remove_static_wve_close_decl_void.F;
P << remove_static_wve_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_wve_close_def@
type T;
identifier F = wve_close;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_wve_close_def@
F << extract_wve_close_def.F;
T << extract_wve_close_def.T;
P << extract_wve_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_wve_close_def_void@
identifier F = wve_close;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_wve_close_def_void@
F << extract_wve_close_def_void.F;
P << extract_wve_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_wve_close_decl@
type T;
identifier F = wve_close;
parameter list P;
@@
T F(P);

@script:python depends on extract_wve_close_decl@
F << extract_wve_close_decl.F;
T << extract_wve_close_decl.T;
P << extract_wve_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_wve_close_decl_void@
identifier F = wve_close;
parameter list P;
@@
void F(P);

@script:python depends on extract_wve_close_decl_void@
F << extract_wve_close_decl_void.F;
P << extract_wve_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: wve_write_header
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_wve_write_header_def@
type T;
identifier F = wve_write_header;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_wve_write_header_def@
F << remove_static_wve_write_header_def.F;
T << remove_static_wve_write_header_def.T;
P << remove_static_wve_write_header_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_wve_write_header_def_void@
identifier F = wve_write_header;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_wve_write_header_def_void@
F << remove_static_wve_write_header_def_void.F;
P << remove_static_wve_write_header_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_wve_write_header_decl@
type T;
identifier F = wve_write_header;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_wve_write_header_decl@
F << remove_static_wve_write_header_decl.F;
T << remove_static_wve_write_header_decl.T;
P << remove_static_wve_write_header_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_wve_write_header_decl_void@
identifier F = wve_write_header;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_wve_write_header_decl_void@
F << remove_static_wve_write_header_decl_void.F;
P << remove_static_wve_write_header_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_wve_write_header_def@
type T;
identifier F = wve_write_header;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_wve_write_header_def@
F << extract_wve_write_header_def.F;
T << extract_wve_write_header_def.T;
P << extract_wve_write_header_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_wve_write_header_def_void@
identifier F = wve_write_header;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_wve_write_header_def_void@
F << extract_wve_write_header_def_void.F;
P << extract_wve_write_header_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_wve_write_header_decl@
type T;
identifier F = wve_write_header;
parameter list P;
@@
T F(P);

@script:python depends on extract_wve_write_header_decl@
F << extract_wve_write_header_decl.F;
T << extract_wve_write_header_decl.T;
P << extract_wve_write_header_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_wve_write_header_decl_void@
identifier F = wve_write_header;
parameter list P;
@@
void F(P);

@script:python depends on extract_wve_write_header_decl_void@
F << extract_wve_write_header_decl_void.F;
P << extract_wve_write_header_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: xi_close
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_xi_close_def@
type T;
identifier F = xi_close;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_xi_close_def@
F << remove_static_xi_close_def.F;
T << remove_static_xi_close_def.T;
P << remove_static_xi_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_xi_close_def_void@
identifier F = xi_close;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_xi_close_def_void@
F << remove_static_xi_close_def_void.F;
P << remove_static_xi_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_xi_close_decl@
type T;
identifier F = xi_close;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_xi_close_decl@
F << remove_static_xi_close_decl.F;
T << remove_static_xi_close_decl.T;
P << remove_static_xi_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_xi_close_decl_void@
identifier F = xi_close;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_xi_close_decl_void@
F << remove_static_xi_close_decl_void.F;
P << remove_static_xi_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_xi_close_def@
type T;
identifier F = xi_close;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_xi_close_def@
F << extract_xi_close_def.F;
T << extract_xi_close_def.T;
P << extract_xi_close_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_xi_close_def_void@
identifier F = xi_close;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_xi_close_def_void@
F << extract_xi_close_def_void.F;
P << extract_xi_close_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_xi_close_decl@
type T;
identifier F = xi_close;
parameter list P;
@@
T F(P);

@script:python depends on extract_xi_close_decl@
F << extract_xi_close_decl.F;
T << extract_xi_close_decl.T;
P << extract_xi_close_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_xi_close_decl_void@
identifier F = xi_close;
parameter list P;
@@
void F(P);

@script:python depends on extract_xi_close_decl_void@
F << extract_xi_close_decl_void.F;
P << extract_xi_close_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Rules for function: xi_write_header
// ============================================================

// Rule 1: static function definition with return type -> remove static, extract declaration
@remove_static_xi_write_header_def@
type T;
identifier F = xi_write_header;
parameter list P;
@@
- static T F(P)
+ T F(P)
{
  ...
}

@script:python depends on remove_static_xi_write_header_def@
F << remove_static_xi_write_header_def.F;
T << remove_static_xi_write_header_def.T;
P << remove_static_xi_write_header_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 2: static void function definition -> remove static, extract declaration
@remove_static_xi_write_header_def_void@
identifier F = xi_write_header;
parameter list P;
@@
- static void F(P)
+ void F(P)
{
  ...
}

@script:python depends on remove_static_xi_write_header_def_void@
F << remove_static_xi_write_header_def_void.F;
P << remove_static_xi_write_header_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 3: static function declaration with return type -> remove static
@remove_static_xi_write_header_decl@
type T;
identifier F = xi_write_header;
parameter list P;
@@
- static T F(P);
+ T F(P);

@script:python depends on remove_static_xi_write_header_decl@
F << remove_static_xi_write_header_decl.F;
T << remove_static_xi_write_header_decl.T;
P << remove_static_xi_write_header_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 4: static void function declaration -> remove static
@remove_static_xi_write_header_decl_void@
identifier F = xi_write_header;
parameter list P;
@@
- static void F(P);
+ void F(P);

@script:python depends on remove_static_xi_write_header_decl_void@
F << remove_static_xi_write_header_decl_void.F;
P << remove_static_xi_write_header_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 5: non-static function definition with return type -> just extract declaration
@extract_xi_write_header_def@
type T;
identifier F = xi_write_header;
parameter list P;
@@
T F(P)
{
  ...
}

@script:python depends on extract_xi_write_header_def@
F << extract_xi_write_header_def.F;
T << extract_xi_write_header_def.T;
P << extract_xi_write_header_def.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 6: non-static void function definition -> just extract declaration
@extract_xi_write_header_def_void@
identifier F = xi_write_header;
parameter list P;
@@
void F(P)
{
  ...
}

@script:python depends on extract_xi_write_header_def_void@
F << extract_xi_write_header_def_void.F;
P << extract_xi_write_header_def_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)

// Rule 7: non-static function declaration with return type -> extract as-is
@extract_xi_write_header_decl@
type T;
identifier F = xi_write_header;
parameter list P;
@@
T F(P);

@script:python depends on extract_xi_write_header_decl@
F << extract_xi_write_header_decl.F;
T << extract_xi_write_header_decl.T;
P << extract_xi_write_header_decl.P;
@@
extract_and_save_signature("%s %s(%s);" % (T, F, P), F)

// Rule 8: non-static void function declaration -> extract as-is
@extract_xi_write_header_decl_void@
identifier F = xi_write_header;
parameter list P;
@@
void F(P);

@script:python depends on extract_xi_write_header_decl_void@
F << extract_xi_write_header_decl_void.F;
P << extract_xi_write_header_decl_void.P;
@@
extract_and_save_signature("void %s(%s);" % (F, P), F)


// ============================================================
// Consolidation Script
// ============================================================

@script:python@
@@
import os
import glob

print("\n>>> CONSOLIDATING FUNCTION DECLARATIONS")

target_functions = ["aiff_close", "aiff_command", "aiff_get_chunk_data", "aiff_get_chunk_size", "aiff_ima_decode_block", "aiff_ima_encode_block", "aiff_ima_seek", "aiff_next_chunk_iterator", "aiff_set_chunk", "aiff_write_header", "alac_byterate", "alac_close", "alac_read_d", "alac_read_f", "alac_read_i", "alac_read_s", "alac_seek", "alac_write_d", "alac_write_f", "alac_write_i", "alac_write_s", "alaw_read_alaw2d", "alaw_read_alaw2f", "alaw_read_alaw2i", "alaw_read_alaw2s", "alaw_write_d2alaw", "alaw_write_f2alaw", "alaw_write_i2alaw", "alaw_write_s2alaw", "au_close", "au_write_header", "avr_close", "avr_write_header", "caf_close", "caf_command", "caf_get_chunk_data", "caf_get_chunk_size", "caf_next_chunk_iterator", "caf_set_chunk", "caf_write_header", "dither_read_int", "dither_read_short", "dither_write_double", "dither_write_float", "dither_write_int", "dither_write_short", "dpcm_read_dles2d", "dpcm_read_dles2f", "dpcm_read_dles2i", "dpcm_read_dles2s", "dpcm_read_dsc2d", "dpcm_read_dsc2f", "dpcm_read_dsc2i", "dpcm_read_dsc2s", "dpcm_seek", "dpcm_write_d2dles", "dpcm_write_d2dsc", "dpcm_write_f2dles", "dpcm_write_f2dsc", "dpcm_write_i2dles", "dpcm_write_i2dsc", "dpcm_write_s2dles", "dpcm_write_s2dsc", "dwd_close", "dwvw_byterate", "dwvw_close", "dwvw_read_d", "dwvw_read_f", "dwvw_read_i", "dwvw_read_s", "dwvw_seek", "dwvw_write_d", "dwvw_write_f", "dwvw_write_i", "dwvw_write_s", "flac_byterate", "flac_close", "flac_command", "flac_read_flac2d", "flac_read_flac2f", "flac_read_flac2i", "flac_read_flac2s", "flac_seek", "flac_write_d2flac", "flac_write_f2flac", "flac_write_header", "flac_write_i2flac", "flac_write_s2flac", "g721_decoder", "g721_encoder", "g723_16_decoder", "g723_16_encoder", "g723_24_decoder", "g723_24_encoder", "g723_40_decoder", "g723_40_encoder", "g72x_close", "g72x_read_d", "g72x_read_f", "g72x_read_i", "g72x_read_s", "g72x_seek", "g72x_write_d", "g72x_write_f", "g72x_write_i", "g72x_write_s", "gsm610_close", "gsm610_decode_block", "gsm610_encode_block", "gsm610_read_d", "gsm610_read_f", "gsm610_read_i", "gsm610_read_s", "gsm610_seek", "gsm610_wav_decode_block", "gsm610_wav_encode_block", "gsm610_write_d", "gsm610_write_f", "gsm610_write_i", "gsm610_write_s", "host_read_d", "host_read_d2f", "host_read_d2i", "host_read_d2s", "host_read_f", "host_read_f2d", "host_read_f2i", "host_read_f2s", "host_write_d", "host_write_d2f", "host_write_f", "host_write_f2d", "host_write_i2d", "host_write_i2f", "host_write_s2d", "host_write_s2f", "htk_close", "htk_write_header", "ima_close", "ima_read_d", "ima_read_f", "ima_read_i", "ima_read_s", "ima_write_d", "ima_write_f", "ima_write_i", "ima_write_s", "interleave_read_double", "interleave_read_float", "interleave_read_int", "interleave_read_short", "interleave_seek", "ircam_close", "ircam_write_header", "mat4_close", "mat4_write_header", "mat5_close", "mat5_write_header", "mpc2k_close", "mpc2k_write_header", "mpeg_command", "mpeg_dec_byterate", "mpeg_dec_close", "mpeg_dec_read_d", "mpeg_dec_read_f", "mpeg_dec_read_i", "mpeg_dec_read_s", "mpeg_dec_seek", "mpeg_l3_encode_write_double_mono", "mpeg_l3_encode_write_double_stereo", "mpeg_l3_encode_write_float_mono", "mpeg_l3_encode_write_float_stereo", "mpeg_l3_encode_write_int_mono", "mpeg_l3_encode_write_int_stereo", "mpeg_l3_encode_write_short_mono", "mpeg_l3_encode_write_short_stereo", "mpeg_l3_encoder_byterate", "mpeg_l3_encoder_close", "mpeg_write_header", "msadpcm_close", "msadpcm_read_d", "msadpcm_read_f", "msadpcm_read_i", "msadpcm_read_s", "msadpcm_seek", "msadpcm_write_d", "msadpcm_write_f", "msadpcm_write_i", "msadpcm_write_s", "nist_close", "nist_write_header", "nms_adpcm_close", "nms_adpcm_read_d", "nms_adpcm_read_f", "nms_adpcm_read_i", "nms_adpcm_read_s", "nms_adpcm_seek", "nms_adpcm_write_d", "nms_adpcm_write_f", "nms_adpcm_write_i", "nms_adpcm_write_s", "ogg_close", "ogg_opus_byterate", "ogg_opus_close", "ogg_opus_command", "ogg_opus_read_d", "ogg_opus_read_f", "ogg_opus_read_i", "ogg_opus_read_s", "ogg_opus_seek", "ogg_opus_write_d", "ogg_opus_write_f", "ogg_opus_write_header", "ogg_opus_write_i", "ogg_opus_write_s", "opcm_close", "opcm_command", "opcm_read_d", "opcm_read_f", "opcm_read_i", "opcm_read_s", "opcm_seek", "opcm_write_d", "opcm_write_f", "opcm_write_header", "opcm_write_i", "opcm_write_s", "paf24_close", "paf24_read_d", "paf24_read_f", "paf24_read_i", "paf24_read_s", "paf24_seek", "paf24_write_d", "paf24_write_f", "paf24_write_i", "paf24_write_s", "paf_write_header", "pcm_read_bei2d", "pcm_read_bei2f", "pcm_read_bei2i", "pcm_read_bei2s", "pcm_read_bes2d", "pcm_read_bes2f", "pcm_read_bes2i", "pcm_read_bes2s", "pcm_read_bet2d", "pcm_read_bet2f", "pcm_read_bet2i", "pcm_read_bet2s", "pcm_read_lei2d", "pcm_read_lei2f", "pcm_read_lei2i", "pcm_read_lei2s", "pcm_read_les2d", "pcm_read_les2f", "pcm_read_les2i", "pcm_read_les2s", "pcm_read_let2d", "pcm_read_let2f", "pcm_read_let2i", "pcm_read_let2s", "pcm_read_sc2d", "pcm_read_sc2f", "pcm_read_sc2i", "pcm_read_sc2s", "pcm_read_uc2d", "pcm_read_uc2f", "pcm_read_uc2i", "pcm_read_uc2s", "pcm_write_d2bei", "pcm_write_d2bes", "pcm_write_d2bet", "pcm_write_d2lei", "pcm_write_d2les", "pcm_write_d2let", "pcm_write_d2sc", "pcm_write_d2uc", "pcm_write_f2bei", "pcm_write_f2bes", "pcm_write_f2bet", "pcm_write_f2lei", "pcm_write_f2les", "pcm_write_f2let", "pcm_write_f2sc", "pcm_write_f2uc", "pcm_write_i2bei", "pcm_write_i2bes", "pcm_write_i2bet", "pcm_write_i2lei", "pcm_write_i2les", "pcm_write_i2let", "pcm_write_i2sc", "pcm_write_i2uc", "pcm_write_s2bei", "pcm_write_s2bes", "pcm_write_s2bet", "pcm_write_s2lei", "pcm_write_s2les", "pcm_write_s2let", "pcm_write_s2sc", "pcm_write_s2uc", "psf_default_seek", "pvf_close", "pvf_write_header", "replace_read_d", "replace_read_d2f", "replace_read_d2i", "replace_read_d2s", "replace_read_f", "replace_read_f2d", "replace_read_f2i", "replace_read_f2s", "replace_write_d", "replace_write_d2f", "replace_write_f", "replace_write_f2d", "replace_write_i2d", "replace_write_i2f", "replace_write_s2d", "replace_write_s2f", "rf64_close", "rf64_command", "rf64_get_chunk_data", "rf64_get_chunk_size", "rf64_next_chunk_iterator", "rf64_set_chunk", "rf64_write_header", "rx2_close", "sd2_close", "sds_2byte_read", "sds_2byte_write", "sds_3byte_read", "sds_3byte_write", "sds_4byte_read", "sds_4byte_write", "sds_byterate", "sds_close", "sds_read_d", "sds_read_f", "sds_read_i", "sds_read_s", "sds_seek", "sds_write_d", "sds_write_f", "sds_write_header", "sds_write_i", "sds_write_s", "spx_close", "spx_command", "spx_read_d", "spx_read_f", "spx_read_i", "spx_read_s", "spx_seek", "spx_write_d", "spx_write_f", "spx_write_header", "spx_write_i", "spx_write_s", "svx_close", "svx_write_header", "txw_read_d", "txw_read_f", "txw_read_i", "txw_read_s", "txw_seek", "ulaw_read_ulaw2d", "ulaw_read_ulaw2f", "ulaw_read_ulaw2i", "ulaw_read_ulaw2s", "ulaw_write_d2ulaw", "ulaw_write_f2ulaw", "ulaw_write_i2ulaw", "ulaw_write_s2ulaw", "vfget_filelen", "vfread", "vfseek", "vftell", "vfwrite", "voc_close", "voc_multi_read_les2d", "voc_multi_read_les2f", "voc_multi_read_les2i", "voc_multi_read_les2s", "voc_multi_read_uc2d", "voc_multi_read_uc2f", "voc_multi_read_uc2i", "voc_multi_read_uc2s", "voc_write_header", "vorbis_byterate", "vorbis_close", "vorbis_command", "vorbis_rdouble", "vorbis_read_d", "vorbis_read_f", "vorbis_read_i", "vorbis_read_s", "vorbis_rfloat", "vorbis_rint", "vorbis_rnull", "vorbis_rshort", "vorbis_seek", "vorbis_write_d", "vorbis_write_f", "vorbis_write_header", "vorbis_write_i", "vorbis_write_s", "vox_read_d", "vox_read_f", "vox_read_i", "vox_read_s", "vox_write_d", "vox_write_f", "vox_write_i", "vox_write_s", "w64_close", "w64_write_header", "wav_close", "wav_command", "wav_get_chunk_data", "wav_get_chunk_size", "wav_next_chunk_iterator", "wav_set_chunk", "wav_write_header", "wavlike_ima_decode_block", "wavlike_ima_encode_block", "wavlike_ima_seek", "wve_close", "wve_write_header", "xi_close", "xi_write_header"]

def_files = glob.glob("definitions/*.txt")
if not def_files:
    print(">>> No function declarations found to consolidate")
else:
    print(">>> Found %d function declarations" % len(def_files))
    
    # Read all declarations
    declarations = {}
    for def_file in sorted(def_files):
        func_name = os.path.basename(def_file).replace('.txt', '')
        try:
            with open(def_file, 'r') as f:
                signature = f.read().strip()
            declarations[func_name] = signature
        except Exception as e:
            print(">>> [ERROR] Failed to read %s: %s" % (def_file, e))
    
    # Write consolidated header file
    header_path = "extracted_declarations.h"
    try:
        with open(header_path, 'w') as f:
            f.write("/* Extracted function declarations */\n")
            f.write("/* Generated by Coccinelle script */\n")
            f.write("/* Static keyword removed where applicable */\n\n")
            f.write("#ifndef EXTRACTED_DECLARATIONS_H\n")
            f.write("#define EXTRACTED_DECLARATIONS_H\n\n")
            
            # Write declarations in sorted order
            for func_name in sorted(declarations.keys()):
                f.write(declarations[func_name] + "\n")
            
            f.write("\n#endif /* EXTRACTED_DECLARATIONS_H */\n")
        
        print(">>> Successfully created header: %s" % header_path)
        print(">>> Total declarations extracted: %d" % len(declarations))
        
        # Report missing functions
        missing = [f for f in target_functions if f not in declarations]
        if missing:
            print(">>> Missing declarations: %d" % len(missing))
            for m in missing[:10]:
                print(">>>   - %s" % m)
            if len(missing) > 10:
                print(">>>   ... and %d more" % (len(missing) - 10))
            
    except Exception as e:
        print(">>> [ERROR] Failed to create header: %s" % e)

print(">>> Consolidation complete")

@finalize:python@
@@
print("\n>>> PROCESSING COMPLETE")
print(">>> Total target functions: 432")
print(">>> Successfully extracted: %d" % len(processed_functions))
print(">>> Individual declarations: definitions/*.txt")
print(">>> Consolidated header: extracted_declarations.h")
